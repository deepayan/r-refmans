<!DOCTYPE html><html><head><title>Help for package insect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {insect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allocateCVI'><p>Allocate sequences for cross validation by identity.</p></a></li>
<li><a href='#classify'><p>Tree-based sequence classification.</p></a></li>
<li><a href='#conversion'><p>Convert sequences between binary and character string formats.</p></a></li>
<li><a href='#demultiplex'><p>Demultiplex merged FASTQ</p></a></li>
<li><a href='#disambiguate'><p>Convert oligonucleotide sequences into regular expressions.</p></a></li>
<li><a href='#encoding'><p>Encode and decode profile HMMs in raw byte format.</p></a></li>
<li><a href='#expand'><p>Expand an existing classification tree.</p></a></li>
<li><a href='#get_lineage'><p>Get full lineage details from a taxonomic ID number.</p></a></li>
<li><a href='#get_taxID'><p>Get taxon ID from taxonomy database.</p></a></li>
<li><a href='#hash'><p>Convert sequences to MD5 hashes.</p></a></li>
<li><a href='#insect'><p>Informatic sequence classification trees.</p></a></li>
<li><a href='#join'><p>Concatenate DNAbin objects while preserving attributes.</p></a></li>
<li><a href='#learn'><p>Informatic sequence classification tree learning.</p></a></li>
<li><a href='#manipulate'><p>Further bit-level manipulation of DNA and amino acid sequences.</p></a></li>
<li><a href='#prune_taxonomy'><p>Prune taxonomy database.</p></a></li>
<li><a href='#purge'><p>Identify and remove erroneous reference sequences.</p></a></li>
<li><a href='#qfilter'><p>Quality filtering for amplicon sequences.</p></a></li>
<li><a href='#rc'><p>Reverse complement DNA in character string format.</p></a></li>
<li><a href='#read'><p>Read FASTA and FASTQ files.</p></a></li>
<li><a href='#replicate'><p>Dereplicate and rereplicate sequence datasets.</p></a></li>
<li><a href='#samoa'><p>Table of marine COI amplicon sequence variants from American Samoa</p></a></li>
<li><a href='#searchGB'><p>Query the NCBI GenBank database.</p></a></li>
<li><a href='#shave'><p>Shave ends from DNA and amino acid sequences</p></a></li>
<li><a href='#stitch'><p>Paired-end read stitching.</p></a></li>
<li><a href='#taxonomy'><p>Download taxonomy database.</p></a></li>
<li><a href='#trim'><p>Trim primer and/or index sequences.</p></a></li>
<li><a href='#virtualFISH'><p>Virtual <em>in situ</em> hybridization.</p></a></li>
<li><a href='#virtualPCR'><p>Virtual PCR.</p></a></li>
<li><a href='#whale_taxonomy'><p>Cetacean section of NCBI taxonomy database.</p></a></li>
<li><a href='#whales'><p>Cetacean 16S rDNA sequences.</p></a></li>
<li><a href='#write'><p>Write sequences to text in FASTA or FASTQ format.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Informatic Sequence Classification Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Shaun Wilkinson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shaun Wilkinson &lt;shaunpwilkinson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for probabilistic taxon assignment with informatic sequence classification trees. See Wilkinson et al (2018) &lt;<a href="https://doi.org/10.7287%2Fpeerj.preprints.26812v1">doi:10.7287/peerj.preprints.26812v1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shaunpwilkinson/insect/">https://github.com/shaunpwilkinson/insect/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shaunpwilkinson/insect/issues/">https://github.com/shaunpwilkinson/insect/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape (&ge; 3.0.0), aphid (&ge; 1.3.1), kmer (&ge; 1.1.0), openssl,
phylogram (&ge; 2.0.0), RANN, seqinr, stats, utils, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-06 23:35:00 UTC; shaun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-09 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='allocateCVI'>Allocate sequences for cross validation by identity.</h2><span id='topic+allocateCVI'></span>

<h3>Description</h3>

<p>This function takes a reference sequence database and allocates each sequence to either
a query set (a.k.a. test set) or a training set, in order to cross validate a
supervised taxon classifier. The method is based on that of Edgar (2018), but uses
recursive divisive clustering and retains all sequences rather than discarding those that
violate the top-hit identity constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocateCVI(x, threshold = 0.9, allocate = "max", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocateCVI_+3A_x">x</code></td>
<td>
<p>a set of reference sequences. Can be a
&quot;DNAbin&quot; object or a named vector of upper-case DNA character strings.</p>
</td></tr>
<tr><td><code id="allocateCVI_+3A_threshold">threshold</code></td>
<td>
<p>numeric between 0 and 1 giving the identity threshold for sequence allocation.</p>
</td></tr>
<tr><td><code id="allocateCVI_+3A_allocate">allocate</code></td>
<td>
<p>character giving the method to use to allocate eligible sequences to the query set.
Options are &quot;max&quot; (default) which chooses the largest node from each pair in order to
maximize the size of the query set,
or &quot;sample&quot;, which randomly chooses one node from each eligible pair.</p>
</td></tr>
<tr><td><code id="allocateCVI_+3A_...">...</code></td>
<td>
<p>further arguments to pass to &quot;kmeans&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector the same length as the input object, indicating which sequences
should be allocated to the query set
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Edgar RC (2018) Accuracy of taxonomy prediction for 16S rRNA and fungal ITS sequences.
PeerJ 6:e4652. DOI 10.7717/peerj.4652
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(whales)
  allocateCVI(whales)

</code></pre>

<hr>
<h2 id='classify'>Tree-based sequence classification.</h2><span id='topic+classify'></span>

<h3>Description</h3>

<p><code>"classify"</code> assigns taxon IDs to DNA sequences using an
informatic sequence classification tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(
  x,
  tree,
  threshold = 0.8,
  decay = FALSE,
  ping = 0.98,
  mincount = 5,
  offset = 0,
  ranks = c("kingdom", "phylum", "class", "order", "family", "genus", "species"),
  species = "ping100",
  tabulize = FALSE,
  metadata = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>a sequence or set of sequences. Can be a
&quot;DNAbin&quot; or &quot;AAbin&quot; object or a named vector of
upper-case DNA character strings.</p>
</td></tr>
<tr><td><code id="classify_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>"insect"</code>
(see <code><a href="#topic+learn">learn</a></code> for details).</p>
</td></tr>
<tr><td><code id="classify_+3A_threshold">threshold</code></td>
<td>
<p>numeric between 0 and 1 giving the minimum
Akaike weight for the recursive classification procedure
to continue toward the leaves of the tree. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="classify_+3A_decay">decay</code></td>
<td>
<p>logical indicating whether the decision to terminate the
classification process should be made based on decaying Akaike weights
(at each node, the Akaike weight of the selected model is multiplied by
the Akaike weight of the selected model at the parent node) or whether
each Akaike weight should be calculated independently of that of the
parent node. Defaults to FALSE (the latter).</p>
</td></tr>
<tr><td><code id="classify_+3A_ping">ping</code></td>
<td>
<p>logical or numeric (between 0 and 1) indicating whether
a nearest neighbor search should
be carried out, and if so,
what the minimum distance to the nearest neighbor
should be for the the recursive classification algorithm to be skipped.
If TRUE and the query sequence is identical to
at least one of the training sequences used to learn the tree,
the common ancestor of the matching training sequences is returned
with an score of NA.
If a value between 0 and 1 is provided, the common ancestor of the
training sequences with similarity greater than or equal to 'ping'
is returned, again with a score of NA.
If <code>ping</code> is set to 0 or FALSE, the recursive classification
algorithm is applied to all sequences, regardless of proximity to
those in the training set.
For high values (e.g. <code>ping &gt;= 0.98</code>) the output will generally
specify the taxonomic ID to species or genus level;
however a higher rank may be returned for low-resolution genetic markers.</p>
</td></tr>
<tr><td><code id="classify_+3A_mincount">mincount</code></td>
<td>
<p>integer, the minimum number of training sequences belonging to a
selected child node for the classification to progress. Defaults to 5.</p>
</td></tr>
<tr><td><code id="classify_+3A_offset">offset</code></td>
<td>
<p>log-odds score offset parameter governing whether
the minimum score is met at each node. Defaults to 0.
Values above 0 increase precision (fewer type I errors),
values below 0 increase recall (fewer type II errors).</p>
</td></tr>
<tr><td><code id="classify_+3A_ranks">ranks</code></td>
<td>
<p>character vector giving the taxonomic ranks to be
included in the output table. Must be a valid rank from the
taxonomy database attributed to the classification tree
(<code>attr(tree, "taxonomy")</code>). Set to NULL to exclude taxonomic ranks
from the output table.</p>
</td></tr>
<tr><td><code id="classify_+3A_species">species</code></td>
<td>
<p>character string, indicating whether to include all
species-level classifications in the output (species = 'all'),
only those generated by exact matching (&quot;ping100&quot;; the default setting),
only those generated by exact matching or near-neighbor searching
(species = 'ping'). If <code>species = "ping"</code> or <code>species = "ping100"</code>,
non-matched species are returned at genus level.
Alternatively, if species = 'none', all species-level classifications
are returned at genus level.</p>
</td></tr>
<tr><td><code id="classify_+3A_tabulize">tabulize</code></td>
<td>
<p>logical indicating whether sequence counts should be
attached to the output table. If TRUE, the output table will have one
row for each unique sequence, and columns will include counts for
each sample (where samples names precede sequence identifiers in the input
object; see details below).</p>
</td></tr>
<tr><td><code id="classify_+3A_metadata">metadata</code></td>
<td>
<p>logical indicating whether to include additional columns
containing the paths, individual node scores and reasons for termination.
Defaults to FALSE. Included for advanced use and debugging.</p>
</td></tr>
<tr><td><code id="classify_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading (defaults to 1).
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a pre-computed classification tree
of class &quot;insect&quot;, which is a dendrogram object with additional attributes
(see <code><a href="#topic+learn">learn</a></code> for details).
Query sequences obtained from the same primer set used to construct
the tree are classified to produce taxonomic
IDs with an associated degree of confidence.
The classification algorithm works as follows:
starting from the root node of the tree,
the log-likelihood of the query sequence
(the log-probability of the sequence given a particular model)
is computed for each of the models occupying the two child nodes using the
forward algorithm (see Durbin et al. (1998)).
The competing likelihood values are then compared by computing
their Akaike weights (Johnson and Omland, 2004).
If one model is overwhelmingly more likely to have produced
the sequence than the other,
that child node is chosen and the classification is updated
to reflect the taxonomic ID stored at the node.
This classification procedure is repeated, continuing down the
tree until either an inconclusive result is returned by a
model comparison test (i.e. the Akaike weight is lower than
a pre-defined threshold, e.g. 0.9),
or a terminal leaf node is reached,
at which point a species-level classification is generally returned.
The function outputs a table with one row for each input sequence
Output table fields include &quot;name&quot; (the unique sequence identifier),
&quot;taxID&quot; (the taxonomic identification number from the taxonomy database),
&quot;taxon&quot; (the name of the taxon),
&quot;rank&quot; (the rank of the taxon, e.g. species, genus family, etc),
and &quot;score&quot; (the Akaike weight from the model selection procedure).
Note that the default behavior is for the Akaike weight to ‘decay’
as it moves down the tree, by computing the cumulative product of
all preceding Akaike weight values.
This minimizes the chance of type I taxon ID errors (overclassifications and misclassifications).
The output table also includes the higher taxonomic ranks specified in the
<code>ranks</code> argument, and if <code>metadata = TRUE</code> additional columns
are included called &quot;path&quot;
(the path of the sequence through the classification tree), &quot;scores&quot; (the
scores at each node through the tree, UTF-8-encoded),
and &quot;reason&quot; outlining why the recursive classification procedure was
terminated:
</p>

<ul>
<li><p> 0 reached leaf node
</p>
</li>
<li><p> 1 failed to meet minimum score threshold at inner node
</p>
</li>
<li><p> 2 failed to meet minimum score of training sequences at inner node
</p>
</li>
<li><p> 3 sequence length shorter than minimum length of training sequences at inner node
</p>
</li>
<li><p> 4 sequence length exceeded maximum length of training sequences at inner node
</p>
</li>
<li><p> 5 nearest neighbor in training set does not belong to selected node (obsolete)
</p>
</li>
<li><p> 6 node is supported by too few sequences
</p>
</li>
<li><p> 7 reserved
</p>
</li>
<li><p> 8 sequence could not be translated (amino acids only)
</p>
</li>
<li><p> 9 translated sequence contains stop codon(s) (amino acids only)
</p>
</li></ul>

<p>Additional columns detailing the nearest neighbor search include &quot;NNtaxID&quot;, &quot;NNtaxon&quot;,
&quot;NNrank&quot;, and &quot;NNdistance&quot;.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Johnson JB, Omland KS (2004) Model selection in ecology and evolution.
<em>Trends in Ecology and Evolution</em>. <strong>19</strong>, 101-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+learn">learn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(whales)
  data(whale_taxonomy)
  ## use all sequences except first one to train the classifier
  set.seed(999)
  tree &lt;- learn(whales[-1], db = whale_taxonomy, maxiter = 5, cores = 2)
  ## find predicted lineage for first sequence
  classify(whales[1], tree)
  ## compare with actual lineage
  taxID &lt;- as.integer(gsub(".+\\|", "", names(whales)[1]))
  get_lineage(taxID, whale_taxonomy)

</code></pre>

<hr>
<h2 id='conversion'>Convert sequences between binary and character string formats.</h2><span id='topic+conversion'></span><span id='topic+dna2char'></span><span id='topic+aa2char'></span><span id='topic+char2dna'></span><span id='topic+char2aa'></span>

<h3>Description</h3>

<p>These functions convert DNA and amino acid sequences in
&quot;DNAbin&quot; or &quot;AAbin&quot; format to concatenated character strings,
and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dna2char(x)

aa2char(x)

char2dna(z, simplify = FALSE)

char2aa(z, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion_+3A_x">x</code></td>
<td>
<p>a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="conversion_+3A_z">z</code></td>
<td>
<p>a vector of concatenated strings representing DNA or
amino acid sequences in upper case.</p>
</td></tr>
<tr><td><code id="conversion_+3A_simplify">simplify</code></td>
<td>
<p>logical indicating whether length-one &quot;DNAbin&quot;
or &quot;AAbin&quot; objects should be simplified to vectors.
Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used to convert concatenated character strings
(e.g. &quot;TAACGC&quot;) to binary format and vice versa.
To convert DNAbin and AAbin objects to non-concatenated
character objects (e.g. <code>c("T", "A", "A", "C", "G", "C")</code>)
refer to the <code><a href="ape.html#topic+ape">ape</a></code> package functions
<code><a href="ape.html#topic+as.character.DNAbin">as.character.DNAbin</a></code> and
<code><a href="ape.html#topic+as.character.AAbin">as.character.AAbin</a></code>.
Likewise the <code><a href="ape.html#topic+ape">ape</a></code> package functions
<code><a href="ape.html#topic+as.DNAbin">as.DNAbin</a></code> and <code><a href="ape.html#topic+as.AAbin">as.AAbin</a></code>
are used to convert non-concatenated character
objects to binary format.
</p>


<h3>Value</h3>

<p><code>dna2char</code> and <code>aa2char</code> return vectors of upper case
character strings.
<code>char2dna</code> and <code>char2aa</code> return &quot;DNAbin&quot; and &quot;AAbin&quot; objects,
respectively. These will be lists unless the input object
has length one and simplify = TRUE, in which case the returned object
will be a vector.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2007) A bit-level coding scheme for nucleotides. <a href="http://ape-package.ird.fr/misc/BitLevelCodingScheme.html">http://ape-package.ird.fr/misc/BitLevelCodingScheme.html</a>.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  char2dna("TAACGC")
  char2aa("VGAHAGEY")
  dna2char(char2dna("TAACGC"))
  aa2char(char2aa("VGAHAGEY"))
  char2dna(list(seq1 = "TAACGC", seq2 = "ATTGCG"))
  char2aa(list(seq1 = "VGAHAGEY", seq2 = "VNVDEV"))
</code></pre>

<hr>
<h2 id='demultiplex'>Demultiplex merged FASTQ</h2><span id='topic+demultiplex'></span>

<h3>Description</h3>

<p>This function is used to demultiplex FASTQ files
containing sequence reads with index and primer sequences still attached.
The function trims the tags and primers, and exports
two FASTQ files for each forward-reverse index combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demultiplex(
  R1,
  R2 = NULL,
  tags,
  up,
  down,
  destdir = "demux",
  adapter1 = NULL,
  adapter2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demultiplex_+3A_r1">R1</code></td>
<td>
<p>character string giving the path to the first FASTQ file</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_r2">R2</code></td>
<td>
<p>character string giving the path to the second FASTQ file.
Set to NULL for single-end reads.</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_tags">tags</code></td>
<td>
<p>named character vector specifying the unique forward:reverse
tag combinations used in the run.
Each tag combination should be entered as an upper case character string delimited by a colon
(e.g. &quot;ATCGACAC:ATGCACTG&quot;) and named according to the unique sample ID.</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_up">up</code>, <code id="demultiplex_+3A_down">down</code></td>
<td>
<p>upper case character strings giving the forward and reverse primer sequences.</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_destdir">destdir</code></td>
<td>
<p>character string giving the path to the directory where
the new FASTQ files should be written.</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_adapter1">adapter1</code></td>
<td>
<p>the forward flowcell adapter sequence to check and trim (set NULL to ignore).
For standard Illumina MiSeq forward adapter set to &quot;AATGATACGGCGACCACCGAGATCTACAC&quot; (paired end sequencing only).</p>
</td></tr>
<tr><td><code id="demultiplex_+3A_adapter2">adapter2</code></td>
<td>
<p>the reverse flowcell adapter sequence to check and trim (set NULL to ignore).
For standard Illumina MiSeq reverse adapter set to &quot;CAAGCAGAAGACGGCATACGAGAT&quot; (single or paired end sequencing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisibly)
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>

<hr>
<h2 id='disambiguate'>Convert oligonucleotide sequences into regular expressions.</h2><span id='topic+disambiguate'></span>

<h3>Description</h3>

<p>This function is used to convert an oligonucleotide sequence into a regular
expression that can be used to query a sequence dataset.
This is generally used for finding and removing primer,
adapter and/or index sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disambiguate(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disambiguate_+3A_z">z</code></td>
<td>
<p>a concatenated string representing a DNA oligonucleotide sequence,
possibly with IUPAC ambiguity codes (all in upper case).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular expression.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disambiguate("GGWACWGGWTGAACWGTWTAYCCYCC")
</code></pre>

<hr>
<h2 id='encoding'>Encode and decode profile HMMs in raw byte format.</h2><span id='topic+encoding'></span><span id='topic+encodePHMM'></span><span id='topic+decodePHMM'></span>

<h3>Description</h3>

<p>These functions are used to compress and decompress profile
hidden Markov models for DNA to improve memory efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encodePHMM(x)

decodePHMM(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encoding_+3A_x">x</code></td>
<td>
<p>an object of class &quot;PHMM&quot;</p>
</td></tr>
<tr><td><code id="encoding_+3A_z">z</code></td>
<td>
<p>a raw vector in the encodePHMM schema.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Profile HMMs used in tree-based classification
usually include many parameters, and hence large trees with
many PHMMs can occupy a lot of memory. Hence a basic encoding
system was devised to store the emission and transition probabilities
in raw-byte format to three (nearly four) decimal places.
This does not seem to significantly affect the accuracy of likelihood scoring,
and has a moderate impact on classification speed, but can
reduce the memory allocation requirements for large trees by up to
95 percent.
</p>


<h3>Value</h3>

<p>encodePHMM returns a raw vector. <code>decodePHMM</code> returns
an object of class &quot;PHMM&quot; (see Durbin et al (1998) and
the <code><a href="aphid.html#topic+aphid">aphid</a></code>
package for more details
on profile hidden Markov models).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## generate a simple classification tree with two child nodes
  data(whales)
  data(whale_taxonomy)
  tree &lt;- learn(whales, db = whale_taxonomy, recursive = FALSE)
  ## extract the omnibus profile HMM from the root node
  PHMM0 &lt;- decodePHMM(attr(tree, "model"))
  ## extract the profile HMM from the first child node
  PHMM1 &lt;- decodePHMM(attr(tree[[1]], "model"))
 
</code></pre>

<hr>
<h2 id='expand'>Expand an existing classification tree.</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>This function is used to grow an existing classification tree, typically
using more relaxed parameter settings than those used when the tree was
created, or if fine-scale control over the tree-learning operation
is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(
  tree,
  clades = "0",
  refine = "Viterbi",
  iterations = 50,
  nstart = 20,
  minK = 2,
  maxK = 2,
  minscore = 0.9,
  probs = 0.5,
  retry = TRUE,
  resize = TRUE,
  maxsize = 1000,
  recursive = TRUE,
  cores = 1,
  quiet = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_tree">tree</code></td>
<td>
<p>an object of class <code>"insect"</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_clades">clades</code></td>
<td>
<p>a vector of character strings giving the binary indices
matching the labels of the nodes that are to be expanded.
Defaults to &quot;0&quot;, meaning all subclades are expanded.
See below for further details on clade indexing.</p>
</td></tr>
<tr><td><code id="expand_+3A_refine">refine</code></td>
<td>
<p>character string giving the iterative model refinement
method to be used in the partitioning process. Valid options are
<code>"Viterbi"</code> (Viterbi training; the default option) and
<code>"BaumWelch"</code> (a modified version of the Expectation-Maximization
algorithm).</p>
</td></tr>
<tr><td><code id="expand_+3A_iterations">iterations</code></td>
<td>
<p>integer giving the maximum number of training-classification
iterations to be used in the splitting process.
Note that this is not necessarily the same as the number of Viterbi training
or Baum Welch iterations to be used in model training, which can be set
using the argument <code>"maxiter"</code> (eventually passed to
<code><a href="aphid.html#topic+train">train</a></code> via the dots argument &quot;...&quot;).</p>
</td></tr>
<tr><td><code id="expand_+3A_nstart">nstart</code></td>
<td>
<p>integer. The number of random starting sets to be chosen
for initial k-means assignment of sequences to groups. Defaults to 20.</p>
</td></tr>
<tr><td><code id="expand_+3A_mink">minK</code></td>
<td>
<p>integer. The minimum number of furications allowed at each inner
node of the tree. Defaults to 2 (all inner nodes are bifuricating).</p>
</td></tr>
<tr><td><code id="expand_+3A_maxk">maxK</code></td>
<td>
<p>integer. The maximum number of furications allowed at each inner
node of the tree. Defaults to 2 (all inner nodes are bifuricating).</p>
</td></tr>
<tr><td><code id="expand_+3A_minscore">minscore</code></td>
<td>
<p>numeric between 0 and 1. The minimum acceptable value
for the <em>n</em>th percentile of Akaike weights (where <em>n</em> is
the value given in <code>"probs"</code>, for the node to be split and the
recursion process to continue.
At any given node, if the <em>n</em>th percentile of Akaike weights
falls below this threshold, the recursion process for the node will
terminate. As an example, if <code>minscore = 0.95</code> and
<code>probs = 0.5</code> (the default settings), and after generating two
candidate PHMMs to occupy the candidate subnodes the median
Akaike weight is less than 0.95, the splitting process will
terminate and the function will simply return the unsplit root node.</p>
</td></tr>
<tr><td><code id="expand_+3A_probs">probs</code></td>
<td>
<p>numeric between 0 and 1. The percentile of Akaike weights
to test against the minimum score threshold given in <code>"minscore"</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_retry">retry</code></td>
<td>
<p>logical indicating whether failure to split a node based on
the criteria outlined in 'minscore' and 'probs' should prompt a second
attempt with different initial groupings. These groupings are based on
maximum kmer frequencies rather than k-means division, which can give
suboptimal groupings when the cluster sizes are different (due to
the up-weighting of larger clusters in the k-means algorithm).</p>
</td></tr>
<tr><td><code id="expand_+3A_resize">resize</code></td>
<td>
<p>logical indicating whether the models should be free to
change size during the training process or if the number of modules
should be fixed. Defaults to TRUE. Only applicable if
<code>refine = "Viterbi"</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_maxsize">maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMMs. If NULL, no maximum size is enforced.</p>
</td></tr>
<tr><td><code id="expand_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating whether the splitting process
should continue recursively until the discrimination criteria
are not met (TRUE; default), or whether a single split should
take place at each of the nodes specified in <code>clades</code>.</p>
</td></tr>
<tr><td><code id="expand_+3A_cores">cores</code></td>
<td>
<p>integer giving the number processors for multithreading. Defaults to 1.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
e.g. by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores
available.</p>
</td></tr>
<tr><td><code id="expand_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td></tr>
<tr><td><code id="expand_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether extra feedback should be
printed to the console, including progress at each split.</p>
</td></tr>
<tr><td><code id="expand_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code><a href="aphid.html#topic+train">train</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clade indexing system used here is based on character strings,
where &quot;0&quot; refers to the root node,
&quot;01&quot; is the first child node, &quot;02&quot; is the second child node,
&quot;011&quot; is the first child node of the first child node, etc.
Note that this means each node cannot have more than 9 child nodes.
</p>


<h3>Value</h3>

<p>an object of class <code>"insect"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+learn">learn</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(whales)
  data(whale_taxonomy)
  ## split the first node
  set.seed(123)
  tree &lt;- learn(whales, db = whale_taxonomy, recursive = FALSE)
  ## expand only the first clade
  tree &lt;- expand(tree, clades = "1")
 
</code></pre>

<hr>
<h2 id='get_lineage'>Get full lineage details from a taxonomic ID number.</h2><span id='topic+get_lineage'></span>

<h3>Description</h3>

<p>This function derives the full lineage of a taxon ID number
from a given taxonomy database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lineage(taxIDs, db, simplify = TRUE, numbers = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lineage_+3A_taxids">taxIDs</code></td>
<td>
<p>integer or vector of integers giving the taxonomic ID number(s).</p>
</td></tr>
<tr><td><code id="get_lineage_+3A_db">db</code></td>
<td>
<p>a taxonomy database (a data.frame object).
See <code><a href="#topic+taxonomy">taxonomy</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_lineage_+3A_simplify">simplify</code></td>
<td>
<p>logical indicating whether a single lineage
derived from a length-one input
should be simplified from a list to a named character vector.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="get_lineage_+3A_numbers">numbers</code></td>
<td>
<p>logical indicating whether the output string(s) should
be comprised of the taxonomic ID numbers rather than taxon names.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_lineage_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading (Defaults to 1).
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be processed, due to the extra time required to initialize
the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the full lineage as a named character vector, or list of named character
vectors if the length of the input object is &gt; 1 or simplify = FALSE.
&quot;names&quot; attributes are taxonomic ranks.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Federhen S (2012) The NCBI Taxonomy database.
<em>Nucleic Acids Research</em>
<strong>40</strong>, D136-D143. doi:10.1093/nar/gkr1178.
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/taxonomy/">https://www.ncbi.nlm.nih.gov/taxonomy/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(whales)
data(whale_taxonomy)
taxIDs &lt;- as.integer(gsub(".+\\|", "", names(whales)[1:2]))
get_lineage(taxIDs, db = whale_taxonomy)
</code></pre>

<hr>
<h2 id='get_taxID'>Get taxon ID from taxonomy database.</h2><span id='topic+get_taxID'></span>

<h3>Description</h3>

<p>This function returns the unique ID for a specified taxon name by looking
up a taxonomy database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxID(lineage, db, multimatch = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxID_+3A_lineage">lineage</code></td>
<td>
<p>character vector of taxon names or semicolon-delimited
lineage strings.</p>
</td></tr>
<tr><td><code id="get_taxID_+3A_db">db</code></td>
<td>
<p>a valid taxonomy database (as a data.frame object).
See <code><a href="#topic+taxonomy">taxonomy</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_taxID_+3A_multimatch">multimatch</code></td>
<td>
<p>integer giving the value to return if the query
matches multiple entries. Defaults to NA_integer_.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the unique taxon ID,
or NA if the taxon is not found in the database.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Federhen S (2012) The NCBI Taxonomy database.
<em>Nucleic Acids Research</em>
<strong>40</strong>, D136-D143. doi:10.1093/nar/gkr1178.
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/taxonomy/">https://www.ncbi.nlm.nih.gov/taxonomy/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(whale_taxonomy)
get_taxID("Odontoceti", db = whale_taxonomy)
</code></pre>

<hr>
<h2 id='hash'>Convert sequences to MD5 hashes.</h2><span id='topic+hash'></span>

<h3>Description</h3>

<p>This function converts DNA or amino acid sequences to 128-bit
MD5 hash values for efficient duplicate identification and dereplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_+3A_x">x</code></td>
<td>
<p>a sequence or list of sequences, either in character string,
character vector, or raw byte format (eg DNAbin or AAbin objects).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>md5</code> function from the openSSL library
(<a href="https://www.openssl.org/">https://www.openssl.org/</a>)
to digest sequences to 128-bit hashes.
These can be compared using base functions such
as <code>duplicated</code> and <code>unique</code>, for fast identification and
management of duplicate sequences in large datasets.
</p>


<h3>Value</h3>

<p>a character vector.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Ooms J (2017) openssl: toolkit for encryption, signatures and
certificates based on OpenSSL. R package version 0.9.7.
<a href="https://CRAN.R-project.org/package=openssl">https://CRAN.R-project.org/package=openssl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(whales)
 hashes &lt;- hash(whales)
 sum(duplicated(hashes))
</code></pre>

<hr>
<h2 id='insect'>Informatic sequence classification trees.</h2><span id='topic+insect'></span>

<h3>Description</h3>

<p>R package 'insect' contains functions to create and use
classification trees for DNA meta-barcoding. This enables
users to quickly and accurately assign the taxonomic identities of
large numbers of DNA barcodes or other informative sequences
generated on one of the standard high-throughput sequencing platforms.
</p>

<hr>
<h2 id='join'>Concatenate DNAbin objects while preserving attributes.</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>This function joins two or more <code>DNAbin</code> objects, retaining any
attributes whose lengths match those of the input objects (e.g. &quot;species&quot;,
&quot;lineage&quot; and/or &quot;taxID&quot; attributes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p><code>DNAbin</code> objects to be concatenated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>DNAbin</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.DNAbin">subset.DNAbin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(whales)
whales1 &lt;- whales[1:10]
whales2 &lt;- whales[11:19]
join(whales1, whales2)
</code></pre>

<hr>
<h2 id='learn'>Informatic sequence classification tree learning.</h2><span id='topic+learn'></span>

<h3>Description</h3>

<p>This function learns a classification tree from a reference sequence database
using a recursive partitioning procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>learn(
  x,
  db = NULL,
  model = NULL,
  refine = "Viterbi",
  iterations = 50,
  nstart = 20,
  minK = 2,
  maxK = 2,
  minscore = 0.95,
  probs = 0.5,
  retry = FALSE,
  resize = TRUE,
  maxsize = 1000,
  recursive = TRUE,
  cores = 1,
  quiet = FALSE,
  verbose = FALSE,
  numcode = NULL,
  frame = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="learn_+3A_x">x</code></td>
<td>
<p>a reference database of class<code>"DNAbin"</code> representing a list of
DNA sequences to be used as the training data.
All sequences should be from the same genetic region of interest
and be globally alignable (i.e. without unjustified end-gaps).
The sequences must have &quot;names&quot; attributes, either in RDP format
(containing semicolon-delimited lineage strings),
or that include taxonomic ID numbers corresponding with those in the taxonomy
database <code>db</code> (separated from the sequence ID by a &quot;|&quot; character).
For example: &quot;AF296347|30962&quot;, &quot;AF296346|8022&quot;, &quot;AF296345|8017&quot;, etc.
See <code><a href="#topic+searchGB">searchGB</a></code> for more details on creating the reference
sequence database and <code><a href="#topic+taxonomy">taxonomy</a></code> for the associated heirarchical
taxonomic database.</p>
</td></tr>
<tr><td><code id="learn_+3A_db">db</code></td>
<td>
<p>a heirarchical taxonomy database in the form of a data.frame.
Cannot be NULL unless training data is in RDP format
(containing semicolon delimited lineage strings).
The object should have
four columns, labeled &quot;taxID&quot;, &quot;parent_taxID&quot;, &quot;rank&quot; and &quot;name&quot;.
The first two should be numeric, and all ID numbers in the
&quot;parent_taxID&quot; column should link to those in the &quot;taxID&quot; column.
This excludes the first row,
which should have <code>parent_taxID = 0</code> and <code>name = "root"</code>.
See <code><a href="#topic+taxonomy">taxonomy</a></code> for more details.</p>
</td></tr>
<tr><td><code id="learn_+3A_model">model</code></td>
<td>
<p>an optional object of class <code>"PHMM"</code> providing the
starting parameters. Used to train (optimize parameters for)
subsequent nested models to be positioned at successive
sub-nodes. If NULL, the root model is derived from the
sequence list prior to the recursive partitioning process.</p>
</td></tr>
<tr><td><code id="learn_+3A_refine">refine</code></td>
<td>
<p>character string giving the iterative model refinement
method to be used in the partitioning process. Valid options are
<code>"Viterbi"</code> (Viterbi training; the default option) and
<code>"BaumWelch"</code> (a modified version of the Expectation-Maximization
algorithm).</p>
</td></tr>
<tr><td><code id="learn_+3A_iterations">iterations</code></td>
<td>
<p>integer giving the maximum number of training-classification
iterations to be used in the splitting process.
Note that this is not necessarily the same as the number of Viterbi training
or Baum Welch iterations to be used in model training, which can be set
using the argument <code>"maxiter"</code> (eventually passed to
<code><a href="aphid.html#topic+train">train</a></code> via the dots argument &quot;...&quot;).</p>
</td></tr>
<tr><td><code id="learn_+3A_nstart">nstart</code></td>
<td>
<p>integer. The number of random starting sets to be chosen
for initial k-means assignment of sequences to groups. Defaults to 20.</p>
</td></tr>
<tr><td><code id="learn_+3A_mink">minK</code></td>
<td>
<p>integer. The minimum number of furications allowed at each inner
node of the tree. Defaults to 2 (all inner nodes are bifuricating).</p>
</td></tr>
<tr><td><code id="learn_+3A_maxk">maxK</code></td>
<td>
<p>integer. The maximum number of furications allowed at each inner
node of the tree. Defaults to 2 (all inner nodes are bifuricating).</p>
</td></tr>
<tr><td><code id="learn_+3A_minscore">minscore</code></td>
<td>
<p>numeric between 0 and 1. The minimum acceptable value
for the <em>n</em>th percentile of Akaike weights (where <em>n</em> is
the value given in <code>"probs"</code>, for the node to be split and the
recursion process to continue.
At any given node, if the <em>n</em>th percentile of Akaike weights
falls below this threshold, the recursion process for the node will
terminate. As an example, if <code>minscore = 0.95</code> and
<code>probs = 0.5</code> (the default settings), and after generating two
candidate PHMMs to occupy the candidate subnodes the median
Akaike weight is less than 0.95, the splitting process will
terminate and the function will simply return the unsplit root node.</p>
</td></tr>
<tr><td><code id="learn_+3A_probs">probs</code></td>
<td>
<p>numeric between 0 and 1. The percentile of Akaike weights
to test against the minimum score threshold given in <code>"minscore"</code>.</p>
</td></tr>
<tr><td><code id="learn_+3A_retry">retry</code></td>
<td>
<p>logical indicating whether failure to split a node based on
the criteria outlined in 'minscore' and 'probs' should prompt a second
attempt with different initial groupings. These groupings are based on
maximum kmer frequencies rather than k-means division, which can give
suboptimal groupings when the cluster sizes are different (due to
the up-weighting of larger clusters in the k-means algorithm).</p>
</td></tr>
<tr><td><code id="learn_+3A_resize">resize</code></td>
<td>
<p>logical indicating whether the models should be free to
change size during the training process or if the number of modules
should be fixed. Defaults to TRUE. Only applicable if
<code>refine = "Viterbi"</code>.</p>
</td></tr>
<tr><td><code id="learn_+3A_maxsize">maxsize</code></td>
<td>
<p>integer giving the upper bound on the number of modules
in the PHMMs. If NULL, no maximum size is enforced.</p>
</td></tr>
<tr><td><code id="learn_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating whether the splitting process
should continue recursively until the discrimination criteria
are not met (TRUE; default), or whether a single split should
take place at the root node.</p>
</td></tr>
<tr><td><code id="learn_+3A_cores">cores</code></td>
<td>
<p>integer giving the number processors for multithreading. Defaults to 1.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
e.g. by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores
available.</p>
</td></tr>
<tr><td><code id="learn_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether feedback should be printed
to the console.</p>
</td></tr>
<tr><td><code id="learn_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether extra feedback should be
printed to the console, including progress at each split.</p>
</td></tr>
<tr><td><code id="learn_+3A_numcode">numcode</code>, <code id="learn_+3A_frame">frame</code></td>
<td>
<p>passed to <code><a href="seqinr.html#topic+translate">translate</a></code>.
Set to NULL (default) unless learning a hybrid DNA/amino acid sequence classifier.</p>
</td></tr>
<tr><td><code id="learn_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code><a href="aphid.html#topic+train">train</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;insect&quot; object type is a dendrogram
with several additional attributes stored at each node.
These include:
&quot;clade&quot; the index of the node (see further details below);
&quot;sequences&quot; the indices of the sequences in the reference
database used to create the object;
&quot;taxID&quot; the taxonomic identifier of the lowest common taxon
of the sequences belonging to the node (linking to <code>"db"</code>);
&quot;minscore&quot; the lowest likelihood among the training sequences given
the profile HMM stored at the node;
&quot;minlength&quot; the minimum length of the sequences belonging to the node;
&quot;maxlength&quot; the maximum length of the sequences belonging to the node;
&quot;model&quot; the profile HMM derived from the sequence subset belonging to the node;
&quot;nunique&quot; the number of unique sequences belonging to the node;
&quot;ntotal&quot; the total number of sequences belonging to the node (including duplicates);
&quot;key&quot; the hash key used for exact sequence matching
(bypasses the classification procedure if an exact match is found; root node only);
&quot;taxonomy&quot; the taxonomy database containing the taxon ID numbers (root node only).
</p>
<p>The clade indexing system used here is based on character strings,
where &quot;0&quot; refers to the root node,
&quot;01&quot; is the first child node, &quot;02&quot; is the second child node,
&quot;011&quot; is the first child node of the first child node, etc.
The leading zero may be omitted for brevity.
Note that each inner node can not have more than 9 child nodes.
</p>


<h3>Value</h3>

<p>an object of class <code>"insect"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Blackshields G, Sievers F, Shi W, Wilm A, Higgins DG (2010) Sequence embedding
for fast construction of guide trees for multiple sequence alignment.
<em>Algorithms for Molecular Biology</em>, <strong>5</strong>, 21.
</p>
<p>Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological
sequence analysis: probabilistic models of proteins and nucleic acids.
Cambridge University Press, Cambridge, United Kingdom.
</p>
<p>Gerstein M, Sonnhammer ELL, Chothia C (1994) Volume changes in protein evolution.
<em>Journal of Molecular Biology</em>, <strong>236</strong>, 1067-1078.
</p>
<p>Juang B-H, Rabiner LR (1990) The segmental K-means
algorithm for estimating parameters of hidden Markov models.
<em>IEEE Transactions on Acoustics, Speech, and Signal Processing</em>,
<strong>38</strong>, 1639-1641.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(whales)
  data(whale_taxonomy)
  ## use all sequences except first one to train the classifier
  set.seed(999)
  tree &lt;- learn(whales[-1], db = whale_taxonomy, maxiter = 5, cores = 2)
  ## find predicted lineage for first sequence
  classify(whales[1], tree)
  ## compare with actual lineage
  taxID &lt;- as.integer(gsub(".+\\|", "", names(whales)[1]))
  get_lineage(taxID, whale_taxonomy)

</code></pre>

<hr>
<h2 id='manipulate'>Further bit-level manipulation of DNA and amino acid sequences.</h2><span id='topic+manipulate'></span><span id='topic+duplicated.DNAbin'></span><span id='topic+unique.DNAbin'></span><span id='topic+subset.DNAbin'></span><span id='topic+duplicated.AAbin'></span><span id='topic+unique.AAbin'></span><span id='topic+subset.AAbin'></span>

<h3>Description</h3>

<p>These functions provide additional methods to manipulate objects of class
<code>"DNAbin"</code> and <code>"AAbin"</code> to supplement those available in the
<code><a href="ape.html#topic+ape">ape</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNAbin'
duplicated(x, incomparables = FALSE, pointers = TRUE, ...)

## S3 method for class 'DNAbin'
unique(x, incomparables = FALSE, attrs = TRUE, drop = FALSE, ...)

## S3 method for class 'DNAbin'
subset(x, subset, attrs = TRUE, drop = FALSE, ...)

## S3 method for class 'AAbin'
duplicated(x, incomparables = FALSE, pointers = TRUE, ...)

## S3 method for class 'AAbin'
unique(x, incomparables = FALSE, attrs = TRUE, drop = FALSE, ...)

## S3 method for class 'AAbin'
subset(x, subset, attrs = TRUE, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manipulate_+3A_x">x</code></td>
<td>
<p>a <code>"DNAbin"</code> or <code>"AAbin"</code> object.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_incomparables">incomparables</code></td>
<td>
<p>placeholder, not currently functional.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_pointers">pointers</code></td>
<td>
<p>logical indicating whether the re-replication index key
should be returned as a <code>"pointers"</code> attribute of the output vector
(only applicable for <code>duplicated.DNAbin</code> and <code>duplicated.AAbin</code>).
Note that this can increase the computational
time for larger sequence lists.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_...">...</code></td>
<td>
<p>further arguments to be passed between methods.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_attrs">attrs</code></td>
<td>
<p>logical indicating whether the attributes of the input object
whose length match the object length (or number of rows if it is a matrix)
should be retained and subsetted along with the object.
This is useful if the input object has species, lineage and/or taxon ID
metadata that need to be retained following the duplicate analysis.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_drop">drop</code></td>
<td>
<p>logical; indicates whether the input matrix (assuming one is
passed) should be reduced to a vector if subset to a single sequence.
Defaults to FALSE in keeping with the style of the <code><a href="ape.html#topic+ape">ape</a></code>
package functions.</p>
</td></tr>
<tr><td><code id="manipulate_+3A_subset">subset</code></td>
<td>
<p>logical vector giving the elements or rows to be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>unique</code> and <code>subset</code> return a
<code>DNAbin</code> or <code>AAbin</code> object. <code>duplicated</code> returns a logical vector.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2007) A bit-level coding scheme for nucleotides. <a href="http://ape-package.ird.fr/misc/BitLevelCodingScheme.html">http://ape-package.ird.fr/misc/BitLevelCodingScheme.html</a>.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+DNAbin">DNAbin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(whales)
  duplicates &lt;- duplicated.DNAbin(whales, point = TRUE)
  attr(duplicates, "pointers")
  ## returned indices show that the last sequence is
  ## identical to the second one.
  ## subset the reference sequence database to only include unques
  whales &lt;- subset.DNAbin(whales, subset = !duplicates)
  ## this gives the same result as
  unique.DNAbin(whales)
</code></pre>

<hr>
<h2 id='prune_taxonomy'>Prune taxonomy database.</h2><span id='topic+prune_taxonomy'></span>

<h3>Description</h3>

<p>This function prunes the taxon database, removing specified taxa as
desired to improve speed and memory efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_taxonomy(db, taxIDs, keep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_taxonomy_+3A_db">db</code></td>
<td>
<p>a valid taxonomy database, e.g. obtained by running the
<code><a href="#topic+taxonomy">taxonomy</a></code> function.</p>
</td></tr>
<tr><td><code id="prune_taxonomy_+3A_taxids">taxIDs</code></td>
<td>
<p>the names or taxon ID numbers of the taxa to be retained
(or discarded if <code>keep = FALSE</code>).</p>
</td></tr>
<tr><td><code id="prune_taxonomy_+3A_keep">keep</code></td>
<td>
<p>logical, indicates whether the specified taxa should be
kept and the rest of the database removed or vice versa. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TBA
</p>


<h3>Value</h3>

<p>a data.frame with the same column names as
the input object
(&quot;taxID&quot;, &quot;parent_taxID&quot;, &quot;rank&quot;, &quot;name&quot;).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Federhen S (2012) The NCBI Taxonomy database.
<em>Nucleic Acids Research</em>
<strong>40</strong>, D136-D143. doi:10.1093/nar/gkr1178.
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/taxonomy/">https://www.ncbi.nlm.nih.gov/taxonomy/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## remove Odontoceti suborder from cetacean taxonomy database
data(whale_taxonomy)
prune_taxonomy(whale_taxonomy, taxIDs = 9722, keep = FALSE)
</code></pre>

<hr>
<h2 id='purge'>Identify and remove erroneous reference sequences.</h2><span id='topic+purge'></span>

<h3>Description</h3>

<p>This function evaluates a DNA reference database (a &quot;DNAbin&quot; object)
and removes any sequences whose taxonomic metadata appear to be inconsistent
with those of their most closely related sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purge(x, db, level = "order", confidence = 0.8, cores = 1, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="purge_+3A_x">x</code></td>
<td>
<p>a DNAbin list object whose names include taxonomic identification numbers
(see <code><a href="#topic+searchGB">searchGB</a></code> for details).</p>
</td></tr>
<tr><td><code id="purge_+3A_db">db</code></td>
<td>
<p>a valid taxonomy database containing the taxonomic identification numbers
included in the &quot;names&quot; attribute of the primary input object (a data.frame object;
see <code><a href="#topic+taxonomy">taxonomy</a></code>).</p>
</td></tr>
<tr><td><code id="purge_+3A_level">level</code></td>
<td>
<p>character string giving the taxonomic level at which
heterogeneity within a cluster will flag a sequence as potentially erroneous.
This should be a recognized rank within the taxonomy database.</p>
</td></tr>
<tr><td><code id="purge_+3A_confidence">confidence</code></td>
<td>
<p>numeric, the minimum confidence value for a sequence to be purged.
For example, if <code>confidence = 0.8</code> (the default value) a sequence will only be
purged if its taxonomy differs from at least four other independent sequences
in its cluster.</p>
</td></tr>
<tr><td><code id="purge_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading. Defaults to 1.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be processed, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="purge_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether progress should be printed to the console.</p>
</td></tr>
<tr><td><code id="purge_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="kmer.html#topic+otu">otu</a></code> (not including
<code>nstart</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first clusters the sequence dataset into operational
taxonomic units (OTUs) based on a given genetic similarity threshold
using the <code><a href="kmer.html#topic+otu">otu</a></code> function from the <code><a href="kmer.html#topic+kmer">kmer</a></code>
package.
Each cluster is then checked for taxonomic homogeneity at a given rank,
and any sequences that appear out of place are removed.
The criteria for sequence removal are that at least two other independent
studies should contradict the taxonomic metadata attributed to the sequence.
</p>


<h3>Value</h3>

<p>a &quot;DNAbin&quot; object.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(whales)
  data(whale_taxonomy)
  whales &lt;- purge(whales, db = whale_taxonomy, level = "species",
                  threshold = 0.97, method = "farthest")
</code></pre>

<hr>
<h2 id='qfilter'>Quality filtering for amplicon sequences.</h2><span id='topic+qfilter'></span>

<h3>Description</h3>

<p>This function performs several quality checks for FASTQ input files,
removing any sequences that do not conform to the specified
quality standards.
This includes an average quality score assessment, size selection,
singleton removal (or an alternative minimum count) and ambiguous
base-call filtering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfilter(
  x,
  minqual = 30,
  maxambigs = 0,
  mincount = 2,
  minlength = 50,
  maxlength = 500
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfilter_+3A_x">x</code></td>
<td>
<p>a vector of concatenated strings representing DNA sequences
(in upper case) or a DNAbin list object with quality attributes.
This argument will usually be produced by <code>readFASTQ</code>.</p>
</td></tr>
<tr><td><code id="qfilter_+3A_minqual">minqual</code></td>
<td>
<p>integer, the minimum average quality score for a
sequence to pass the filter. Defaults to 30.</p>
</td></tr>
<tr><td><code id="qfilter_+3A_maxambigs">maxambigs</code></td>
<td>
<p>integer, the maximum number of ambiguities for a sequence
to pass the filter. Defaults to 0.</p>
</td></tr>
<tr><td><code id="qfilter_+3A_mincount">mincount</code></td>
<td>
<p>integer, the minimum acceptable number of occurrences of a
sequence for it to pass the filter. Defaults to 2 (removes singletons).</p>
</td></tr>
<tr><td><code id="qfilter_+3A_minlength">minlength</code></td>
<td>
<p>integer, the minimum acceptable sequence length.
Defaults to 50.</p>
</td></tr>
<tr><td><code id="qfilter_+3A_maxlength">maxlength</code></td>
<td>
<p>integer, the maximum acceptable sequence length.
Defaults to 500.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same type as the primary input argument
(i.e. a &quot;DNAbin&quot; object if x is a &quot;DNAbin&quot; object, or a vector
of concatenated character strings otherwise).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## download and extract example FASTQ file to temporary directory
  td &lt;- tempdir()
  URL &lt;- "https://www.dropbox.com/s/71ixehy8e51etdd/insect_tutorial1_files.zip?dl=1"
  dest &lt;- paste0(td, "/insect_tutorial1_files.zip")
  download.file(URL, destfile = dest, mode = "wb")
  unzip(dest, exdir = td)
  x &lt;- readFASTQ(paste0(td, "/COI_sample2.fastq"))
  ## trim primers from sequences
  mlCOIintF &lt;- "GGWACWGGWTGAACWGTWTAYCCYCC"
  jgHCO2198 &lt;- "TAIACYTCIGGRTGICCRAARAAYCA"
  x &lt;- trim(x, up = mlCOIintF, down = jgHCO2198)
  ## filter sequences to remove singletons, low quality &amp; short/long reads
  x &lt;- qfilter(x, minlength = 250, maxlength = 350)
 
</code></pre>

<hr>
<h2 id='rc'>Reverse complement DNA in character string format.</h2><span id='topic+rc'></span>

<h3>Description</h3>

<p>This function reverse complements a DNA sequence or vector of DNA
sequences that are stored as character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rc_+3A_z">z</code></td>
<td>
<p>a vector of DNA sequences in upper case character string format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts only DNA sequences in concatenated character
string format, see <code><a href="ape.html#topic+complement">complement</a></code> in the <code><a href="ape.html#topic+ape">ape</a></code>
package for &quot;DNAbin&quot; input objects, and <code><a href="seqinr.html#topic+comp">comp</a></code> in the
<code><a href="seqinr.html#topic+seqinr">seqinr</a></code> package for when the input object is a character
vector.
</p>


<h3>Value</h3>

<p>a vector of DNA sequences as upper case character strings.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rc("TATTG")
</code></pre>

<hr>
<h2 id='read'>Read FASTA and FASTQ files.</h2><span id='topic+read'></span><span id='topic+readFASTQ'></span><span id='topic+readFASTA'></span>

<h3>Description</h3>

<p>Text parsing functions for reading sequences in the FASTA or FASTQ format into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFASTQ(file = file.choose(), bin = TRUE)

readFASTA(
  file = file.choose(),
  bin = TRUE,
  residues = "DNA",
  alignment = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_file">file</code></td>
<td>
<p>the name of the FASTA or FASTQ file from which the sequences
are to be read.</p>
</td></tr>
<tr><td><code id="read_+3A_bin">bin</code></td>
<td>
<p>logical indicating whether the returned object should be in
binary/raw byte format (i.e. &quot;DNAbin&quot; or &quot;AAbin&quot; objects for
nucleotide and amino acid sequences, respectively).
If FALSE a vector of named character strings is returned.</p>
</td></tr>
<tr><td><code id="read_+3A_residues">residues</code></td>
<td>
<p>character string indicating whether the sequences to
be read are composed of nucleotides (&quot;DNA&quot;; default) or amino acids (&quot;AA&quot;).
Only required for <code>readFASTA</code> and if <code>bin = TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_+3A_alignment">alignment</code></td>
<td>
<p>logical indicating whether the sequences represent
an alignment to be parsed as a matrix.
Only applies to <code>readFASTA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Compatibility:</h4>

<p>The FASTQ convention is somewhat
ambiguous with several slightly different interpretations appearing
in the literature. For now, this function supports the Illumina
convention for FASTQ files, where each sequence and its associated
metadata occupies four line of the text file as follows : (1) the
run and cluster metadata preceded by an @ symbol; (2) the sequence
itself in capitals without spaces;
(3) a single &quot;+&quot; symbol; and (4) the Phred quality
scores from 0 to 93 represented as ASCII symbols. For more information
on this convention see the Illumina help page
<a href="https://help.basespace.illumina.com/articles/descriptive/fastq-files/">here</a>
.</p>



<h4>Speed and Memory Requirements:</h4>

<p>For optimal memory efficiency and compatibility with other functions,
it is recommended to store sequences in raw byte format
as either DNAbin or AAbin objects.
For FASTQ files when bin = TRUE, a vector of quality scores
(also in raw-byte format) is attributed to each sequence.
These can be converted back to numeric quality scores with <code>as.integer</code>.
For FASTQ files when bin = FALSE the function returns a vector with each
sequence as a concatenated string with a similarly concatenated quality attribute
comprised of the same ASCII metacharacters used in the FASTQ coding scheme.
</p>
<p>This function can take a while to process larger FASTQ files,
a multithreading option may be available in a future version.</p>



<h3>Value</h3>

<p>Either a vector of character strings (if bin = FALSE),
or a list of raw (&quot;DNAbin&quot; or &quot;AAbin&quot;) vectors,
with each element having a &quot;quality&quot; attribute.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Bokulich NA, Subramanian S, Faith JJ, Gevers D, Gordon JI, Knight R,
Mills DA, Caporaso JG (2013) Quality-filtering vastly improves diversity
estimates from Illumina amplicon sequencing.
<em>Nat Methods</em>, <strong>1</strong>, 57-59.
</p>
<p>Illumina help page:
<a href="https://help.basespace.illumina.com/articles/descriptive/fastq-files/">https://help.basespace.illumina.com/articles/descriptive/fastq-files/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeFASTQ">writeFASTQ</a></code> and <code><a href="#topic+writeFASTA">writeFASTA</a></code>
for writing sequences to text in the FASTA or FASTQ format.
See also <code><a href="ape.html#topic+read.dna">read.dna</a></code> in the <code><a href="ape.html#topic+ape">ape</a></code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## download and extract example FASTQ file to temporary directory
  td &lt;- tempdir()
  URL &lt;- "https://www.dropbox.com/s/71ixehy8e51etdd/insect_tutorial1_files.zip?dl=1"
  dest &lt;- paste0(td, "/insect_tutorial1_files.zip")
  download.file(URL, destfile = dest, mode = "wb")
  unzip(dest, exdir = td)
  x &lt;- readFASTQ(paste0(td, "/COI_sample2.fastq"))
 
</code></pre>

<hr>
<h2 id='replicate'>Dereplicate and rereplicate sequence datasets.</h2><span id='topic+replicate'></span><span id='topic+dereplicate'></span><span id='topic+rereplicate'></span>

<h3>Description</h3>

<p>These functions are used to extract only the unique sequences from
a set of DNA reads, with the ability to rebuild the original
sequence set at a later time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dereplicate(x, cores = 1)

rereplicate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicate_+3A_x">x</code></td>
<td>
<p>a list of sequences in <code>DNAbin</code> or <code>AAbin</code> format, or a
vector of sequences as concatenated upper-case character strings.</p>
</td></tr>
<tr><td><code id="replicate_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading (defaults to 1).
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
e.g. by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores
available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a DNAbin/AAbin object, or a vector of concatenated
upper-case character strings, depending on the input object.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(whales)
  tmp &lt;- dereplicate(whales)
  whales &lt;- rereplicate(tmp)
</code></pre>

<hr>
<h2 id='samoa'>Table of marine COI amplicon sequence variants from American Samoa</h2><span id='topic+samoa'></span>

<h3>Description</h3>

<p>This matrix contains counts of COI amplicon sequence variants (ASV)
extracted from autonomous reef monitoring structures (ARMS) in
Ofu, American Samoa. Unpublished data courtesy of Molly Timmers (NOAA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samoa
</code></pre>


<h3>Format</h3>

<p>a 2 x 16 integer matrix containing abundance counts of 16 ASVs from
two sites. This table contains the first 16 rows of the 'seqtab.nochim' output from
the DADA2 pipeline (<a href="https://benjjneb.github.io/dada2/tutorial.html">https://benjjneb.github.io/dada2/tutorial.html</a>).
The column names contain the DNA sequences of the ASVs, and row names
correspond with site codes.
</p>

<hr>
<h2 id='searchGB'>Query the NCBI GenBank database.</h2><span id='topic+searchGB'></span>

<h3>Description</h3>

<p><code>searchGB</code> queries GenBank using the
Entrez search utilities, and downloads the matching sequences
and/or their accession numbers. A vector of
accession numbers can be passed in lieu of a query, in which case the function
downloads the matching sequences from GenBank.
Internet connectivity is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchGB(
  query = NULL,
  accession = NULL,
  sequences = TRUE,
  bin = TRUE,
  db = "nucleotide",
  taxIDs = TRUE,
  prompt = TRUE,
  contact = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchGB_+3A_query">query</code></td>
<td>
<p>an Entrez search query. For help compiling Entrez queries see
<a href="https://www.ncbi.nlm.nih.gov/books/NBK3837/#EntrezHelp.Entrez_Searching_Options">https://www.ncbi.nlm.nih.gov/books/NBK3837/#EntrezHelp.Entrez_Searching_Options</a>
and <a href="https://www.ncbi.nlm.nih.gov/books/NBK49540/">https://www.ncbi.nlm.nih.gov/books/NBK49540/</a>.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_accession">accession</code></td>
<td>
<p>an optional vector of GenBank accession numbers to be input
in place of a search query. If both query and accession arguments are
provided the function returns an error.
Currently, a maximum of 200 accession numbers can be
processed at a time.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_sequences">sequences</code></td>
<td>
<p>logical. Should the sequences be returned or only the
GenBank accession numbers? Note that taxon IDs
are not returned if <code>sequences</code> is set to FALSE.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_bin">bin</code></td>
<td>
<p>logical indicating whether the returned sequences should
be in raw-byte format (&quot;DNAbin&quot; or &quot;AAbin&quot; object type) or as a
vector of named character strings. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_db">db</code></td>
<td>
<p>the NCBI database from which to download the sequences and/or
accession names. Accepted options are &quot;nucleotide&quot; (default) and &quot;protein&quot;.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_taxids">taxIDs</code></td>
<td>
<p>logical indicating whether the NCBI taxon ID numbers should
be appended to the names of the output object (delimited by a &quot;|&quot; character).
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_prompt">prompt</code></td>
<td>
<p>logical indicating whether to check with the user before
downloading sequences.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_contact">contact</code></td>
<td>
<p>an optional character string with the users email address.
This is added to the E-utilities URL and may be used by NCBI to contact
the user if the application causes unintended issues.</p>
</td></tr>
<tr><td><code id="searchGB_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether the progress should be printed
to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the Entrez e-utilities API to search and download
sequences from GenBank.
Occasionally users may encounter an unknown non-reproducible error
and appears to be related to database records being updated in GenBank.
This can generally be remedied by re-running the function. If problems
persist please feel free to raise an issue on the package bug-reports page at
&lt;https://github.com/shaunpwilkinson/insect/issues/&gt;.
</p>


<h3>Value</h3>

<p>a list of sequences as either a <code>DNAbin</code> or <code>AAbin</code>
object (depending on <code>"db"</code>),
or a named vector of character strings (if <code>bin = FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>NCBI Resource Coordinators (2012) Database resources of the National
Center for Biotechnology Information. <em>Nucleic Acids Research</em>,
<strong>41</strong> (Database issue): D8–D20.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.GenBank">read.GenBank</a></code> (ape)
for an alternative means of downloading DNA sequences from GenBank
using accession numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Query the GenBank database for Eukaryote mitochondrial 16S DNA sequences
  ## between 100 and 300 base pairs in length that were modified between
  ## the years 1999 and 2000.
  
    query &lt;- "Eukaryota[ORGN]+AND+16S[TITL]+AND+100:300[SLEN]+AND+1999:2000[MDAT]"
    x &lt;- searchGB(query, prompt = FALSE)
  
</code></pre>

<hr>
<h2 id='shave'>Shave ends from DNA and amino acid sequences</h2><span id='topic+shave'></span>

<h3>Description</h3>

<p>This function uses the Viterbi algorithm to semi-globally align a motif to
a DNA or AA sequence, and removes all nucleotides to the left and/or right of the
motif.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shave(x, motif, direction = "both", cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shave_+3A_x">x</code></td>
<td>
<p>an object of class <code>DNAbin</code> or <code>AAbin</code>.</p>
</td></tr>
<tr><td><code id="shave_+3A_motif">motif</code></td>
<td>
<p>a <code>DNAbin</code>, <code>AAbin</code> or <code>PHMM</code> object.</p>
</td></tr>
<tr><td><code id="shave_+3A_direction">direction</code></td>
<td>
<p>character string indicating
the direction of the shave. Options are &quot;forward&quot; (shaves everything to
the right of the motif), &quot;backward&quot; (shaves everything to the left of
the motif) or &quot;both&quot; (retains the motif region only).</p>
</td></tr>
<tr><td><code id="shave_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading.
Defaults to 1, and reverts to 1 if <code>x</code> is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be processed, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="shave_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="aphid.html#topic+Viterbi">Viterbi</a></code>
(not including 'type').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions finds the optimal semiglobal alignment (a.k.a. &quot;glocal&quot;
alignment or global alignment with free end gaps) between a
sequence <code>"x"</code> and a shorter sequence <code>"motif"</code>, returning
the motif region of x along with the nucleotides to the left or right
if <code>direction</code> is set to <code>"reverse"</code> or <code>"forward"</code>,
respectively.
</p>


<h3>Value</h3>

<p>an object of class <code>DNAbin</code> or <code>AAbin</code>
(depending on the input object).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+virtualPCR">virtualPCR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(whales)
  motif = char2dna("AAGTGTAGCATCACTTATTGATCCAAATT")
  shave(whales, motif = motif, direction = "both")
</code></pre>

<hr>
<h2 id='stitch'>Paired-end read stitching.</h2><span id='topic+stitch'></span>

<h3>Description</h3>

<p>This function aligns forward and reverse reads generated from a
2x amplicon sequencing platform, and produces a consensus sequence with
maximum base-call quality scores attached as &quot;quality&quot; attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch(x, y, up = NULL, down = NULL, mindiff = 6, minoverlap = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitch_+3A_x">x</code>, <code id="stitch_+3A_y">y</code></td>
<td>
<p>DNAbin objects with quality attributes (see <code><a href="#topic+readFASTQ">readFASTQ</a></code> to
generate these objects from fastq text files), representing the forward and
reverse reads to be stitched. These objects can be either vectors or lists.
In the latter case, the two objects must be equal length.</p>
</td></tr>
<tr><td><code id="stitch_+3A_up">up</code>, <code id="stitch_+3A_down">down</code></td>
<td>
<p>forward and reverse primer sequences (either as concatenated
character strings or &quot;DNAbin&quot; objects).
Either both or neither should be provided (not one or the other).</p>
</td></tr>
<tr><td><code id="stitch_+3A_mindiff">mindiff</code></td>
<td>
<p>the minimum difference in quality between two different base calls
for the higher quality call to be added to the consensus alignment. In cases where
the quality differences are less than this threshold, the ambiguity code &quot;N&quot; is added
to the consensus sequence. Defaults to 6.</p>
</td></tr>
<tr><td><code id="stitch_+3A_minoverlap">minoverlap</code></td>
<td>
<p>integer giving the minimum number of nucleotides that
should be shared between the forward and reverse sequence alignments.
Defaults to 16.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;DNAbin&quot; object or a vector of concatenated character strings,
depending on the input.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFASTQ">readFASTQ</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## download and extract example FASTQ file to temporary directory
  td &lt;- tempdir()
  URL &lt;- "https://www.dropbox.com/s/71ixehy8e51etdd/insect_tutorial1_files.zip?dl=1"
  dest &lt;- paste0(td, "/insect_tutorial1_files.zip")
  download.file(URL, destfile = dest, mode = "wb")
  unzip(dest, exdir = td)
  x &lt;- readFASTQ(paste0(td, "/COI_sample1_read1.fastq"), bin = FALSE)
  y &lt;- readFASTQ(paste0(td, "/COI_sample1_read2.fastq"), bin = FALSE)
  z &lt;- stitch(x, y)
  z[1]
  attr(z, "quality")[1]

</code></pre>

<hr>
<h2 id='taxonomy'>Download taxonomy database.</h2><span id='topic+taxonomy'></span>

<h3>Description</h3>

<p>This function downloads an up-to-date copy of the taxonomy database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonomy(db = "NCBI", synonyms = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxonomy_+3A_db">db</code></td>
<td>
<p>character string specifying which taxonomy database to download.
Currently only &quot;NCBI&quot; is supported.</p>
</td></tr>
<tr><td><code id="taxonomy_+3A_synonyms">synonyms</code></td>
<td>
<p>logical indicating whether synonyms should be included.
Note that this increases the size of the returned object by around 10%.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function downloads the specified taxonomy database as a data.frame
object with the following columns:
&quot;taxID&quot;, &quot;parent_taxID&quot;, &quot;rank&quot;, &quot;name&quot;.
As of early 2018 the zip archive to download the NCBI taxonomy database
is approximately 40Mb in size, and the output dataframe object is around
200Mb in memory. Once downloaded, the dataframe can be pruned
for increased speed and memory efficiency using the function
<code><a href="#topic+prune_taxonomy">prune_taxonomy</a></code>.
</p>


<h3>Value</h3>

<p>a dataframe with the following elements:
&quot;taxID&quot;, &quot;parent_taxID&quot;, &quot;rank&quot;, &quot;name&quot;.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Federhen S (2012) The NCBI Taxonomy database.
<em>Nucleic Acids Research</em>
<strong>40</strong>, D136-D143. doi:10.1093/nar/gkr1178.
</p>
<p><a href="https://www.ncbi.nlm.nih.gov/taxonomy/">https://www.ncbi.nlm.nih.gov/taxonomy/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # db &lt;- taxonomy()

</code></pre>

<hr>
<h2 id='trim'>Trim primer and/or index sequences.</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>This function trims the primer and/or index sequence(s) from a set of DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x, up, down = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>a &quot;DNAbin&quot; object or a vector of concatenated upper-case character strings,
containing the sequences to be trimmed.</p>
</td></tr>
<tr><td><code id="trim_+3A_up">up</code>, <code id="trim_+3A_down">down</code></td>
<td>
<p>&quot;DNAbin&quot; objects or vectors of concatenated upper-case character strings,
representing the primer sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any sequences not containing the primer(s) in either direction are discarded.
Hence this function can also be used to de-multiplex sequences and remove indices,
though it will generally be faster to do this on the sequencing platform prior to
exporting the FASTQ files.
</p>


<h3>Value</h3>

<p>a &quot;DNAbin&quot; object or a vector of concatenated character strings,
depending on the input.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## download and extract example FASTQ file to temporary directory
  td &lt;- tempdir()
  URL &lt;- "https://www.dropbox.com/s/71ixehy8e51etdd/insect_tutorial1_files.zip?dl=1"
  dest &lt;- paste0(td, "/insect_tutorial1_files.zip")
  download.file(URL, destfile = dest, mode = "wb")
  unzip(dest, exdir = td)
  x &lt;- readFASTQ(paste0(td, "/COI_sample2.fastq"))
  ## trim primers from sequences
  mlCOIintF &lt;- "GGWACWGGWTGAACWGTWTAYCCYCC"
  jgHCO2198 &lt;- "TAIACYTCIGGRTGICCRAARAAYCA"
  x &lt;- trim(x, up = mlCOIintF, down = jgHCO2198)

</code></pre>

<hr>
<h2 id='virtualFISH'>Virtual <em>in situ</em> hybridization.</h2><span id='topic+virtualFISH'></span>

<h3>Description</h3>

<p>This function queries a list of DNA sequences with a virtual probe
(either a sequence or a profile hidden Markov model) and returns only
the sequences and regions that are of sufficient similarity based on
log-odds alignment scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>virtualFISH(
  x,
  probe,
  minscore = 100,
  minamplen = 50,
  maxamplen = 500,
  up = NULL,
  down = NULL,
  rcdown = TRUE,
  minfsc = 60,
  minrsc = 60,
  maxNs = 0.02,
  cores = 1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="virtualFISH_+3A_x">x</code></td>
<td>
<p>a list of DNA sequences in <code>DNAbin</code> format.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_probe">probe</code></td>
<td>
<p>a DNA sequence (&quot;DNAbin&quot; object) or profile hidden
Markov model (&quot;PHMM&quot; object) to be used as the virtual hybridization probe.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_minscore">minscore</code></td>
<td>
<p>numeric; the minimum specificity (log-odds score
for the optimal alignment) between the query sequence and the probe
for the former to be retained in the output object.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_minamplen">minamplen</code>, <code id="virtualFISH_+3A_maxamplen">maxamplen</code></td>
<td>
<p>integers giving the minimum and maximum
acceptable amplicon lengths.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_up">up</code>, <code id="virtualFISH_+3A_down">down</code></td>
<td>
<p>optional objects of class <code>DNAbin</code>
giving the forward and reverse primer sequences with which
to query the sequence list following virtual probe hybridization.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_rcdown">rcdown</code></td>
<td>
<p>logical indicating whether the reverse primer should be
reverse-complemented prior to aligning with the input sequences.
Should be set to TRUE if <code>down</code>
is the reverse complement of the target sequence (e.g. the sequence of
a reverse primer as would be ordered from an oligo supplier).</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_minfsc">minfsc</code></td>
<td>
<p>numeric, giving the minimum specificity(log-odds score
for the optimal alignment) between the forward primer and a sequence
for that sequence to be retained.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_minrsc">minrsc</code></td>
<td>
<p>numeric, the minimum specificity (log-odds score for
the optimal alignment) between the reverse primer (if provided) and
a sequence for that sequence to be retained.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_maxns">maxNs</code></td>
<td>
<p>numeric giving the maximum acceptable proportion
of the ambiguous residue &quot;N&quot; within the output sequences.
Defaults to 0.02.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading.
Defaults to 1, and reverts to 1 if <code>x</code> is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be processed, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="virtualFISH_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether progress should be printed to
the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is generally used when filtering/trimming a
local sequence database,
to mop up any high-scoring sequences with partial/missing primer
bind sites that were not included in the output of the
<code><a href="#topic+virtualPCR">virtualPCR</a></code>.
For example, this includes sequences that were generated using the same
primer set as used in the virtual PCR, and whose primer binding sites
were trimmed prior to deposition in the sequence database.
Unlike the virtualPCR function, there is
no option to retain the primer-bind sites in the returned sequences.
</p>


<h3>Value</h3>

<p>a list of trimmed sequences, returned as an object of class
<code>DNAbin</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+virtualPCR">virtualPCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## ensure whale sequences are globally alignable
  data(whales)
  model &lt;- aphid::derivePHMM(whales)
  z &lt;- virtualFISH(whales, probe = model)
</code></pre>

<hr>
<h2 id='virtualPCR'>Virtual PCR.</h2><span id='topic+virtualPCR'></span>

<h3>Description</h3>

<p><code>virtualPCR</code> queries a list of DNA sequences with virtual primers
(either sequences or profile hidden Markov models) and returns only
the sequences that contain regions of sufficient similarity based on
log-odds alignment scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>virtualPCR(
  x,
  up,
  down = NULL,
  rcdown = TRUE,
  trimprimers = FALSE,
  minfsc = 50,
  minrsc = 50,
  minamplen = 50,
  maxamplen = 2000,
  maxNs = 0.02,
  partialbind = TRUE,
  cores = 1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="virtualPCR_+3A_x">x</code></td>
<td>
<p>a list of DNA sequences in <code>DNAbin</code> format.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_up">up</code></td>
<td>
<p>an object of class <code>DNAbin</code> or <code>PHMM</code> giving the
forward primer with which to query the sequence list.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_down">down</code></td>
<td>
<p>an optional argument the same type as <code>up</code> giving the
reverse primer with which to query the sequence list. If NULL only
the forward primer is used.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_rcdown">rcdown</code></td>
<td>
<p>logical indicating whether the reverse primer should be
reverse-complemented prior to aligning with the input sequences. Set
to TRUE only if <code>down</code> is not NULL, is of class <code>DNAbin</code>, and
is the reverse complement of the target sequence (e.g. the sequence of
a reverse primer as would be ordered from an oligo supplier).</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_trimprimers">trimprimers</code></td>
<td>
<p>logical indicating whether the primer-binding sites
should be removed from the sequences in the returned list.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_minfsc">minfsc</code></td>
<td>
<p>numeric, giving the minimum specificity(log-odds score
for the optimal alignment) between the forward primer and a sequence
for that sequence to be retained.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_minrsc">minrsc</code></td>
<td>
<p>numeric, the minimum specificity (log-odds score for
the optimal alignment) between the reverse primer (if provided) and
a sequence for that sequence to be retained.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_minamplen">minamplen</code>, <code id="virtualPCR_+3A_maxamplen">maxamplen</code></td>
<td>
<p>integers giving the minimum and maximum
acceptable amplicon lengths. Sequences are discarded if the number
of base pairs between the primer-binding sites falls outside of these
limits.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_maxns">maxNs</code></td>
<td>
<p>numeric giving the maximum acceptable proportion
of the ambiguous residue &quot;N&quot; within the output sequences.
Defaults to 0.02.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_partialbind">partialbind</code></td>
<td>
<p>logical indicating whether partial primer matching is
accepted. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_cores">cores</code></td>
<td>
<p>integer giving the number of processors for multithreading.
Defaults to 1, and reverts to 1 if x is not a list.
This argument may alternatively be a 'cluster' object,
in which case it is the user's responsibility to close the socket
connection at the conclusion of the operation,
for example by running <code>parallel::stopCluster(cores)</code>.
The string 'autodetect' is also accepted, in which case the maximum
number of cores to use is one less than the total number of cores available.
Note that in this case there
may be a tradeoff in terms of speed depending on the number and size
of sequences to be processed, due to the extra time required to initialize
the cluster.</p>
</td></tr>
<tr><td><code id="virtualPCR_+3A_quiet">quiet</code></td>
<td>
<p>logical indicating whether progress should be printed to
the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of trimmed sequences, an object of class
<code>DNAbin</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## trim whale sequences using a new set of inner primers
  inner_for &lt;- "CGGTTGGGGTGACCTCGGAGTA"
  inner_rev &lt;- "GCTGTTATCCCTAGGGTAA"
  whales_short &lt;- virtualPCR(whales, up = inner_for, down = inner_rev,
                             trimprimers = TRUE)
</code></pre>

<hr>
<h2 id='whale_taxonomy'>Cetacean section of NCBI taxonomy database.</h2><span id='topic+whale_taxonomy'></span>

<h3>Description</h3>

<p>A copy of the NCBI taxonomy reference database, subsetted to include only the
cetacean taxa in the <code><a href="#topic+whales">whales</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whale_taxonomy
</code></pre>


<h3>Format</h3>

<p>A data.frame object with 72 rows and four columns, labeled as follows:
</p>

<dl>
<dt>taxID</dt><dd><p>the NCBI unique taxon identifier (integer).</p>
</dd>
<dt>parent_taxID</dt><dd><p>the NCBI unique taxon identifier
of the immediate parent taxon (integer).</p>
</dd>
<dt>rank</dt><dd><p>The taxonomic rank (i.e. species, genus, etc; character).</p>
</dd>
<dt>name</dt><dd><p>The scientific name of the taxon (character).</p>
</dd>
</dl>

<p>The database was accessed from
<a href="ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz">ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz</a> on 17 June 2018
using the <code><a href="#topic+taxonomy">taxonomy</a></code> function, and pruned using
<code><a href="#topic+prune_taxonomy">prune_taxonomy</a></code> with
<code>taxIDs = as.integer(gsub(".+\|", "", names(whales)))</code>.
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/taxonomy/">https://www.ncbi.nlm.nih.gov/taxonomy/</a>
</p>

<hr>
<h2 id='whales'>Cetacean 16S rDNA sequences.</h2><span id='topic+whales'></span>

<h3>Description</h3>

<p>A dataset containing 19 mitochondrial 16S rDNA sequences from 18 cetacean species,
downloaded from GenBank on 27 March 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whales
</code></pre>


<h3>Format</h3>

<p>A &quot;DNAbin&quot; list object containing 19 cetacean mitochondrial sequences
in raw-byte format,
averaging 130 nucleotides in length. The sequences are named with the GenBank
accession numbers followed by a &quot;|&quot; symbol, followed by their NCBI taxonomy ID
numbers.
The sequences were downloaded using the
<code><a href="#topic+searchGB">searchGB</a></code> function on 17 June 2018
(query term: &quot;cetacea[ORGN]+AND+16S+rRNA[GENE]&quot;), and trimmed using the
<code><a href="#topic+virtualPCR">virtualPCR</a></code> function with the primers 16Smam1 and 16Smam2
(CGGTTGGGGTGACCTCGGA and GCTGTTATCCCTAGGGTAACT, respectively; Taylor 1996).
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/genbank/">https://www.ncbi.nlm.nih.gov/genbank/</a>
</p>


<h3>References</h3>

<p>Taylor PG (1996) Reproducibility of ancient DNA sequences from extinct
Pleistocene fauna. <em>Molecular Biology and Evolution</em>, <strong>13</strong>, 283-285.
</p>

<hr>
<h2 id='write'>Write sequences to text in FASTA or FASTQ format.</h2><span id='topic+write'></span><span id='topic+writeFASTQ'></span><span id='topic+writeFASTA'></span>

<h3>Description</h3>

<p>These functions take a list of DNA or amino acid sequences in
<code>DNAbin</code> or <code>AAbin</code> format
and outputs a text file to a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFASTQ(x, file = "", compress = FALSE, append = FALSE)

writeFASTA(x, file = "", compress = FALSE, append = FALSE, wrap = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_+3A_x">x</code></td>
<td>
<p>a list of sequences in <code>DNAbin</code> or <code>AAbin</code> format, or a
vector of sequences as concatenated upper-case character strings.
For writeFASTQ, only DNAbin objects are accepted, and each element should have
a vector of quality scores of equal length attributed to the sequence.
These vectors are comprised of raw bytes ranging from 00 to 5d
(0 to 93 when converted to integers).
See <code><a href="#topic+readFASTQ">readFASTQ</a></code> for more details.</p>
</td></tr>
<tr><td><code id="write_+3A_file">file</code></td>
<td>
<p>character string giving a valid file path to output the text to.
If file = &quot;&quot; (default setting) the text file is written to the
console.</p>
</td></tr>
<tr><td><code id="write_+3A_compress">compress</code></td>
<td>
<p>logical indicating whether the output file should be gzipped.</p>
</td></tr>
<tr><td><code id="write_+3A_append">append</code></td>
<td>
<p>logical indicating whether the output should be appended to the file.</p>
</td></tr>
<tr><td><code id="write_+3A_wrap">wrap</code></td>
<td>
<p>integer giving the maximum number of characters on each sequence line.
Defaults to NULL (no wrapping).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisibly).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Illumina help page:
<a href="https://help.basespace.illumina.com/articles/descriptive/fastq-files/">https://help.basespace.illumina.com/articles/descriptive/fastq-files/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFASTQ">readFASTQ</a></code> for reading FASTQ files into R,
and <code><a href="ape.html#topic+write.dna">write.dna</a></code> in the ape package
for writing DNA to text in FASTA and other formats.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## download and extract example FASTQ file to temporary directory
  td &lt;- tempdir()
  URL &lt;- "https://www.dropbox.com/s/71ixehy8e51etdd/insect_tutorial1_files.zip?dl=1"
  dest &lt;- paste0(td, "/insect_tutorial1_files.zip")
  download.file(URL, destfile = dest, mode = "wb")
  unzip(dest, exdir = td)
  x &lt;- readFASTQ(paste0(td, "/COI_sample2.fastq"))
  ## trim primers from sequences
  mlCOIintF &lt;- "GGWACWGGWTGAACWGTWTAYCCYCC"
  jgHCO2198 &lt;- "TAIACYTCIGGRTGICCRAARAAYCA"
  x &lt;- trim(x, up = mlCOIintF, down = jgHCO2198)
  ## quality filter with size selection and singleton removal
  x &lt;- qfilter(x, minlength = 250, maxlength = 350)
  ## output filtered FASTQ file
  writeFASTQ(x, file = paste0(td, "/COI_sample2_filtered.fastq"))
  writeFASTA(x, file = paste0(td, "/COI_sample2_filtered.fasta"))
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
