<!DOCTYPE html><html><head><title>Help for package BioMark</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BioMark}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aux.biom'><p>Auxiliary functions in the biomarker package</p></a></li>
<li><a href='#biom.options'><p>Set or return options for stability-based biomarker selection</p></a></li>
<li><a href='#gen.data'><p>Simulate data sets</p></a></li>
<li><a href='#get.biom'><p>Get biomarkers discriminating between two classes</p></a></li>
<li><a href='#get.segments'><p>Subsampling segments</p></a></li>
<li><a href='#HCthresh'><p>Biomarker thresholding by Higher Criticism</p></a></li>
<li><a href='#ROC'><p>ROC curves</p></a></li>
<li><a href='#scalefun'><p>Different forms of scaling</p></a></li>
<li><a href='#selection'><p>Accessor function to the selected variables of a BioMark object</p></a></li>
<li><a href='#SpikedApple'><p>Spike-in metabolomics data for apple extracts</p></a></li>
<li><a href='#spikedApples'><p>Metabolomics data on spiked apples</p></a></li>
<li><a href='#traceplot'><p>Plot the coefficient or stability trace for the lasso/elastic net</p>
biomarker selection.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Find Biomarkers in Two-Class Discrimination Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Ron Wehrens, Pietro Franceschi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ron Wehrens &lt;ron.wehrens@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Variable selection methods are provided for several classification methods: the lasso/elastic net, PCLDA, PLSDA, and several t-tests. Two approaches for selecting cutoffs can be used, one based on the stability of model coefficients under perturbation, and the other on higher criticism.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>pls, glmnet, MASS, st (&ge; 1.1.6)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-07 12:04:07 UTC; ron</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-07 18:17:37</td>
</tr>
</table>
<hr>
<h2 id='aux.biom'>Auxiliary functions in the biomarker package</h2><span id='topic+aux.biom'></span><span id='topic+pcr.coef'></span><span id='topic+pcr.stab'></span><span id='topic+pls.coef'></span><span id='topic+lasso.coef'></span><span id='topic+lasso.stab'></span><span id='topic+vip.coef'></span><span id='topic+vip.stab'></span><span id='topic+pls.coef'></span><span id='topic+pls.stab'></span><span id='topic+shrinkt.coef'></span><span id='topic+shrinkt.stab'></span><span id='topic+studentt.coef'></span><span id='topic+studentt.stab'></span><span id='topic+pval.plsvip'></span><span id='topic+pval.pcr'></span>

<h3>Description</h3>

<p>These functions return coefficient sizes for a variety of
modelling methods. Not to be called directly by the user - use function
<code>get.biom</code> for that.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcr.coef(X, Y, ncomp, scale.p, ...)
pcr.stab(X, Y, ncomp, scale.p,
           segments = NULL, variables = NULL, ...)
pls.coef(X, Y, ncomp, scale.p, ...)
pls.stab(X, Y, ncomp, scale.p,
           segments = NULL, variables = NULL, ...)
vip.coef(X, Y, ncomp, scale.p, ...)
vip.stab(X, Y, ncomp, scale.p,
         segments = NULL, variables = NULL, ...)
lasso.coef(X, Y, scale.p,
           lasso.opt = biom.options()$lasso,...)
lasso.stab(X, Y, scale.p,
           segments = NULL, variables = NULL, ...)
shrinkt.coef(X, Y, scale.p, ...)
shrinkt.stab(X, Y, scale.p,
             segments = NULL, variables = NULL, ...)
studentt.coef(X, Y, scale.p, ...)
studentt.stab(X, Y, scale.p,
              segments = NULL, variables = NULL, ...)
pval.pcr(X, Y, ncomp, scale.p, npermut)
pval.plsvip(X, Y, ncomp, scale.p, npermut, smethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux.biom_+3A_x">X</code></td>
<td>
<p>Data matrix. Usually the number of columns (variables) is
(much) larger than the number of rows (samples).</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_y">Y</code></td>
<td>
<p>Class indication. Either a factor, or a numeric vector.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent variables to use in PCR and PLS (VIP)
modelling. In function <code>get.biom</code> this may be a vector; in all
other functions it should be one number. Default: 2.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_scale.p">scale.p</code></td>
<td>
<p>Scaling. This is performed individually in every
crossvalidation iteration, and can have a profound effect on the
results. Default: &quot;none&quot;. Other possible choices: &quot;auto&quot; for
autoscaling, &quot;pareto&quot; for pareto scaling, &quot;log&quot; and &quot;sqrt&quot; for log
and square root scaling, respectively.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_segments">segments</code></td>
<td>
<p>matrix where each column indicates a set of samples to
be left out of the analysis.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_variables">variables</code></td>
<td>
<p>indices of variables to be used in the analysis.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_lasso.opt">lasso.opt</code></td>
<td>
<p>optional arguments to the <code>glmnet</code> function, in
the form of a list.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_...">...</code></td>
<td>
<p>Further arguments for modelling functions. Often used to
catch unused arguments.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_npermut">npermut</code></td>
<td>
<p>Number of permutations to use in the calculation of the
p values.</p>
</td></tr>
<tr><td><code id="aux.biom_+3A_smethod">smethod</code></td>
<td>
<p>Either &quot;both&quot;, &quot;pls&quot;, or &quot;vip&quot; - indicates what
coefficients to convert to p values. Both are derived from PLS
models so it is much more efficient to calculate them together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions ending in <code>coef</code> return t-statistics or
model coefficients for all variables. The functions
ending in <code>stab</code> return these statistics in a matrix, one column
per segment. The functions starting with <code>pval</code> convert model
coefficients or VIP statistics into p values, using permutation
resampling.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.biom">get.biom</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>, <code><a href="#topic+scalefun">scalefun</a></code></p>

<hr>
<h2 id='biom.options'>Set or return options for stability-based biomarker selection</h2><span id='topic+biom.options'></span>

<h3>Description</h3>

<p>A function to set options for stability-based biomarker selection in
the <span class="pkg">BioMark</span> package, or to return the current options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biom.options(..., reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biom.options_+3A_...">...</code></td>
<td>
<p>a single list, a single character vector, or any number
of named arguments (<var>name = value</var>).</p>
</td></tr>
<tr><td><code id="biom.options_+3A_reset">reset</code></td>
<td>
<p>logical: if TRUE all options are set to their factory
defaults.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called with no arguments, or with an empty list as the single
argument, <code>biom.options</code> returns the current options.
</p>
<p>If called with a character vector as the single argument, a list with
the arguments named in the vector are returned.
</p>
<p>If called with a non-empty list as the single arguments, the list
elements should be named, and are treated as named arguments to the
function.
</p>
<p>Otherwise, <code>biom.options</code> should be called with one or more named
arguments <var>name = value</var>.  For each argument, the option named
<var>name</var> will be given the value <var>value</var>.
</p>
<p>The options are saved in an envirtonment variable
<code>.biom.Options</code>, and remain in effect until the end of the
session.  If the environment is saved upon exit, they will be
remembered in the next session.
</p>
<p>The recognised options are:
</p>

<dl>
<dt>max.seg</dt><dd><p>Maximal number of jackknife iterations. Default: 100.</p>
</dd>
<dt>oob.size, oob.fraction</dt><dd><p>Size of the out-of-bag fraction, either
given as an absolute number (oob.size) or as a fraction. Default is
to leave out ten percent. If oob.size is given explicitly, it takes
precedence over oob.fraction. Default: oob.fraction = .1.</p>
</dd>
<dt>variable.fraction</dt><dd><p>Use 1 to always include all variables - use a
smaller fraction to have a different random subset of all variables
in each iteration (stability-based identification). Default: .7.</p>
</dd>
<dt>ntop</dt><dd><p>The number of &quot;top&quot; coefficients taken into account in
stability-based biomarker identification. If a variable appears
consistently among the <code>ntop</code> biggest coefficients, it is said
to be stable. If ntop is a number between 0 and 1, it is taken to
indicate the fraction of variables to be included in the model.
Default: 10.</p>
</dd>
<dt>min.present</dt><dd><p>The minimal fraction of times a variable should be in
the top list to be considered as a potential biomarker
(stability-based identification). Setting this
argument to 0 will lead to a list containing all coefficients that
were present in the top list at least once - a value of 1 only
returns those variables that are selected in every
iteration. Default: .1.</p>
</dd>
<dt>nset</dt><dd><p>The number of permutations to establish null
distributions for PCR, PLS and VIP statistics in the
Higher-Criticism approach. Default: 10,000.</p>
</dd>
<dt>fmethods</dt><dd><p>All biomarker selection methods available within
BioMark. Currently equal to <code>c("studentt", "shrinkt", "pcr",
	"pls", "vip", "lasso"</code>. </p>
</dd> 
<dt>univ.methods</dt><dd><p>The names of the univariate biomarker selection
methods currently known to BioMark. Currently equal to
<code>c("studentt", "shrinkt")</code></p>
</dd>
<dt>HCalpha</dt><dd><p>The default of the alpha parameter in the HC
method. Value: 0.1.</p>
</dd>
<dt>lasso</dt><dd><p>a list of arguments passed to the underlying
<code>glmnet</code> function, such as <code>family</code>, <code>nlambda</code>,
<code>alpha</code>, <code>lambda</code>, or <code>lambda.min.ratio</code>. For
binary classification, the &quot;binomial&quot; family is the default, but
the most similar setting compared to the other methods in the package
is <code>family = "gaussian"</code>. For choices other than the default,
a warning is printed to the screen.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the (possibly changed) options.  If any named argument (or
list element) was provided, the list is returned invisibly.
</p>


<h3>Side Effects</h3>

<p>If any named argument (or list element) was provided,
<code>biom.options</code> updates the elements of the option list
<code>.biom.Options$options</code>.
</p>


<h3>Note</h3>

<p>This function is based on the <code><a href="pls.html#topic+pls.options">pls.options</a></code>
function in package <span class="pkg">pls</span>.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="glmnet.html#topic+glmnet">glmnet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Return current options:
biom.options()
biom.options("max.seg")

## Set options:
biom.options(max.seg = 100, oob.fraction = .2)
biom.options(lasso = list(alpha = .75, nlambda = 50))
biom.options()
## the next line removes some options - for these, glmnet defaults will be used
biom.options(lasso = list(alpha = .9, family = "binomial"))

## Restore factory settings:
biom.options(reset = TRUE)
</code></pre>

<hr>
<h2 id='gen.data'>Simulate data sets</h2><span id='topic+gen.data'></span><span id='topic+gen.data2'></span>

<h3>Description</h3>

<p>The functions <code>gen.data</code> and <code>gen.data2</code> generate one or more
two-class data matrices where the first <code>nbiom</code> variables are changed
in the treatment class. The aim is to provide an easy means to evaluate the
performance of biomarker identification methods. Function
<code>gen.data</code> samples from a multivariate normal distribution;
<code>gen.data2</code> generates spiked data either by adding differences to
the first columns, or by multiplying with factors given by the
user. Note that whereas <code>gen.data</code> will provide completely new
simulated data, both for the control and treatment classes,
<code>gen.data2</code> essentially only changes the biomarker part of the
treated class.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.data(ncontrol, ntreated = ncontrol, nvar, nbiom = 5, group.diff = 0.5,
         nsimul = 100, means = rep(0, nvar), cormat = diag(nvar))
gen.data2(X, ncontrol, nbiom, spikeI,
          type = c("multiplicative", "additive"),
          nsimul = 100, stddev = .05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.data_+3A_ncontrol">ncontrol</code>, <code id="gen.data_+3A_ntreated">ntreated</code></td>
<td>
<p>Numbers of objects in the two classes. If only
ncontrol is given, the two classes are assumed to be of equal size,
or, in the case of <code>gen.data2</code>, the remainder of the samples are
taken to be the treatment samples.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_nvar">nvar</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_nbiom">nbiom</code></td>
<td>
<p>Number of biomarkers, i.e. the number of variables to be
changed in the treatment class compared to the control class. The
variables that are changed are always the first variables in the
data matrix.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_group.diff">group.diff</code></td>
<td>
<p>group difference; the average difference between
values of the biomarkers in the two classes.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_nsimul">nsimul</code></td>
<td>
<p>Number of data sets to simulate.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_means">means</code></td>
<td>
<p>Mean values of all variables, a vector.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_cormat">cormat</code></td>
<td>
<p>Correlation matrix to be used in the simulation. Default
is the identity matrix.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_x">X</code></td>
<td>
<p>Experimental data matrix, without group differences.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_spikei">spikeI</code></td>
<td>
<p>A vector of at least three different numbers, used to
generate new values for the biomarker variables in the treated class.</p>
</td></tr>
<tr><td><code id="gen.data_+3A_type">type</code></td>
<td>
<p>Whether to use multiplication (useful when simulating
cases where things like &quot;twofold differences&quot; are relevant), or
addition (in the case of absolute differences in the treatment and
control groups).</p>
</td></tr>
<tr><td><code id="gen.data_+3A_stddev">stddev</code></td>
<td>
<p>Additional noise: in every simulation, normally
distributed noise with a standard deviation of
<code>stddev * mean(spikeI)</code> will be added to <code>spikeI</code> before
generating the actual simulated data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>spikeI</code> argument in function <code>gen.data2</code>
provides the numbers that will be used to artificially &quot;spike&quot; the
biomarker variables, either by multiplication (the default) or by
addition. To obtain approximate two-fold differences, for example, one
could use <code>spikeI = c(1.8, 2.0, 2.2)</code>. At least three different
values should be given since in most cases more than one set will be
simulated and we require different values in the biomarker
variables.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>An array of dimension <code>nobj1 + nobj2</code> times <code>nvar</code>
times <code>nsimul</code>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The class vector.</p>
</td></tr>
<tr><td><code>n.biomarkers</code></td>
<td>
<p>The number of biomarkers.</p>
</td></tr>
</table>
<p>Note that the biomarkers are always in the first <code>nbiom</code> columns
of the data matrix.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X &lt;- gen.data(10, nvar = 200)
names(X)
dim(X$X)

set.seed(7)
simdat &lt;- gen.data(10, nvar = 1200, nbiom = 22, nsimul = 1,
                   group.diff = 2)
simdat.stab &lt;- get.biom(simdat$X[,,1], simdat$Y, fmethod = "all",
                        type = "stab", ncomp = 3, scale.p = "auto")
## show LASSO success
traceplot(simdat.stab, lty = 1, col = rep(2:1, c(22, 1610)))

data(SpikePos)
real.markers &lt;- which(SpikePos$annotation$found.in.standards &gt; 0)
X.no.diff &lt;- SpikePos$data[1:20, -real.markers]

set.seed(7)
simdat2 &lt;- gen.data2(X.no.diff, ncontrol = 10, nbiom = 22,
                     spikeI = c(1.2, 1.4, 2), nsimul = 1)
simdat2.stab &lt;- get.biom(simdat2$X[,,1], simdat$Y,
                         fmethod = "all", type = "stab", ncomp = 3,
                         scale.p = "auto")
## show LASSO success
traceplot(simdat2.stab, lty = 1, col = rep(2:1, c(22, 1610)))

## End(Not run)
</code></pre>

<hr>
<h2 id='get.biom'>Get biomarkers discriminating between two classes</h2><span id='topic+get.biom'></span><span id='topic+print.BMark'></span><span id='topic+summary.BMark'></span><span id='topic+coef.BMark'></span>

<h3>Description</h3>

<p>Biomarkers can be identified in several ways: the classical way
is to look at those variables with large model coefficients or large t
statistics. One other is based on the higher criticism approach (HC),
and the third possibility assesses the stability of these coefficients
under subsampling of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.biom(X, Y, fmethod = "all", type = c("stab", "HC", "coef"),
         ncomp = 2, biom.opt = biom.options(), scale.p = "auto",
         ...)
## S3 method for class 'BMark'
coef(object, ...)
## S3 method for class 'BMark'
print(x, ...)
## S3 method for class 'BMark'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.biom_+3A_x">X</code></td>
<td>
<p>Data matrix. Usually the number of columns (variables) is
(much) larger than the number of rows (samples).</p>
</td></tr>
<tr><td><code id="get.biom_+3A_y">Y</code></td>
<td>
<p>Class indication. For classification with two or more factors
a factor; a numeric vector will be interpreted as a regression
situation, which can only be tackled by <code>fmethod = "lasso"</code>.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_fmethod">fmethod</code></td>
<td>
<p>Modelling method(s) employed. The default is to use
<code>"all"</code>, which will test all methods in the current
<code>biom.options$fmethods</code> list. Note that from version 0.4.0,
<code>"plsda"</code> and <code>"pclda"</code> are no longer in the list of
methods - they have been replaced by <code>"pls"</code> and <code>"pcr"</code>,
respectively. For compatibility reasons, using the old terms will
not lead to an error but only a warning.</p>
</td></tr> 
<tr><td><code id="get.biom_+3A_type">type</code></td>
<td>
<p>Whether to use coefficient size as a criterion
(<code>"coef"</code>), <code>"stab"</code> or <code>"HC"</code>.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of latent variables to use in PCR and PLS (VIP)
modelling. In function <code>get.biom</code> this may be a vector; in all
other functions it should be one number. Default: 2.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_biom.opt">biom.opt</code></td>
<td>
<p>Options for the biomarker selection - a list with
several named elements. See <code><a href="#topic+biom.options">biom.options</a></code>.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_scale.p">scale.p</code></td>
<td>
<p>Scaling. This is performed individually in every
crossvalidation iteration, and can have a profound effect on the
results. Default: &quot;auto&quot; (autoscaling). Other possible choices:
&quot;none&quot; for no scaling, &quot;pareto&quot; for pareto scaling, &quot;log&quot; and &quot;sqrt&quot; for log
and square root scaling, respectively.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_object">object</code>, <code id="get.biom_+3A_x">x</code></td>
<td>
<p>A BMark object.</p>
</td></tr>
<tr><td><code id="get.biom_+3A_...">...</code></td>
<td>
<p>Further arguments for modelling functions. Often used to
catch unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>get.biom</code> returns an object of class &quot;BMark&quot;, a
list containing an element 
for every <code>fmethod</code> that is selected, as well as an element
<code>info</code>. The individual elements contain information depending on
the type chosen: for <code>type == "coef"</code>, the only element returned
is a matrix containing coefficient sizes. For <code>type == "HC"</code>
and <code>type == "stab"</code>, a list is returned containing elements
<code>biom.indices</code>, and either <code>pvals</code> (for <code>type == "HC"</code>)
or <code>fraction.selected</code> (for <code>type == "stab"</code>).
Element <code>biom.indices</code> contains the indices of
the selected variables, and can be extracted using function
<code>selection</code>. Element <code>pvals</code> contains the p values
used to perform HC thresholding; these are presented in the original
order of the variables, and can be obtained directly from e.g. t
statistics, or from permutation sampling. Element
<code>fraction.selected</code> indicates in what fraction of the
stability selection iterations a particular variable has been
selected. The more often it has been selected, the more stable it is
as a biomarker. Generic function <code>coef.biom</code> extracts model
coefficients, p values or stability fractions for types <code>"coef"</code>,
<code>"HC"</code> and <code>"stab"</code>, respectively.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>See Also</h3>

<p><code><a href="#topic+biom.options">biom.options</a></code>, <code><a href="#topic+get.segments">get.segments</a></code>,
<code><a href="#topic+selection">selection</a></code>, <code><a href="#topic+scalefun">scalefun</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Real apple data (small set)
data(spikedApples)
apple.coef &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = factor(rep(1:2, each = 10)),
                       ncomp = 2:3, type = "coef")
coef.sizes &lt;- coef(apple.coef) 
sapply(coef.sizes, range)

## stability-based selection
set.seed(17)
apple.stab &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = factor(rep(1:2, each = 10)),
                       ncomp = 2:3, type = "stab")
selected.variables &lt;- selection(apple.stab)
unlist(sapply(selected.variables, function(x) sapply(x, length)))
## Ranging from more than 70 for pcr, approx 40 for pls and student t,
## to 0-29 for the lasso
unlist(sapply(selected.variables,
              function(x) lapply(x, function(xx, y) sum(xx %in% y),
              spikedApples$biom)))
## TPs (stab): all find 5/5, except pcr.2 and the lasso with values for lambda
## larger than 0.0484

unlist(sapply(selected.variables,
              function(x) lapply(x, function(xx, y) sum(!(xx %in% y)),
              spikedApples$biom)))
## FPs (stab): PCR finds most FPs (approx. 60), other latent-variable
## methods approx 40, lasso allows for the optimal selection around 
## lambda = 0.0702

## regression example
data(gasoline) ## from the pls package
gasoline.stab &lt;- get.biom(gasoline$NIR, gasoline$octane,
                          fmethod = c("pcr", "pls", "lasso"), type = "stab")


## Not run: 
## Same for HC-based selection
## Warning: takes a long time!
apple.HC &lt;- get.biom(X = spikedApples$dataMatrix,
                     Y = factor(rep(1:2, each = 10)),
                     ncomp = 2:3, type = "HC")
sapply(apple.HC[names(apple.HC) != "info"],
       function(x, y) sum(x$biom.indices %in% y),
       spikedApples$biom)
sapply(apple.HC[names(apple.HC) != "info"],
       function(x, y) sum(!(x$biom.indices %in% y)),
       spikedApples$biom)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.segments'>Subsampling segments</h2><span id='topic+get.segments'></span>

<h3>Description</h3>

<p>Provides combinations of samples to be left out in
subsampling, with a maximum given by parameter <code>max.seg</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.segments(i1, i2 = NULL, oob.size = 1, max.seg = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.segments_+3A_i1">i1</code></td>
<td>
<p>either an index vector for objects in class 1, or a
classification vector (factor, or numeric), from which the indices
of both classes can be derived.</p>
</td></tr>
<tr><td><code id="get.segments_+3A_i2">i2</code></td>
<td>
<p>if non-NULL, vector indexing objects in class 2.</p>
</td></tr>
<tr><td><code id="get.segments_+3A_oob.size">oob.size</code></td>
<td>
<p>number of samples to be left out in every
iteration. If one (the default), this corresponds to LOO
subsampling.</p>
</td></tr>
<tr><td><code id="get.segments_+3A_max.seg">max.seg</code></td>
<td>
<p>maximal number of segments to return. If null, all
possible combinations are returned &ndash; this option is only possible
if oob.size equals 1. If oob.size is larger, max.seg must be defined
since the number of possibilities becomes too large for even very
small numbers of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix where the columns contain the numbers of the samples to
be left out in the respective iterations.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.biom">get.biom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i1 &lt;- seq(1, 10, by = 2)
i2 &lt;- seq(2, 15, by = 2)
get.segments(i1, i2)
get.segments(i1, i2, max.seg = 10)
get.segments(i1, i2, oob.size = 2, max.seg = 10)

I &lt;- rep(1:2, c(5,6))
get.segments(I)
get.segments(I, max.seg = 15)
</code></pre>

<hr>
<h2 id='HCthresh'>Biomarker thresholding by Higher Criticism</h2><span id='topic+HCthresh'></span>

<h3>Description</h3>

<p>Higher Criticism (HC) is a second-level significance testing approach
to determine which variables in a multivariate set show significant
differences in two classes. Function <code>HCthresh</code> selects those p
values that are significantly different from what would be expected
from their uniform distribution under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCthresh(pvec, alpha = 0.1, plotit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCthresh_+3A_pvec">pvec</code></td>
<td>
<p>Vector of p values.</p>
</td></tr>
<tr><td><code id="HCthresh_+3A_alpha">alpha</code></td>
<td>
<p>Parameter of the HC approach: the maximal fraction of
differentially expressed p values.</p>
</td></tr>
<tr><td><code id="HCthresh_+3A_plotit">plotit</code></td>
<td>
<p>Logical, whether or not a plot should be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In HC, one tests the deviation of the expected behaviour of p values
under a null distribution. Function <code>HCthresh</code> implements the
approach by Donoho and Jin to find out which of these correspond to
real differences. The prerequisites are that the true biomarkers are
rare (consist of only a small fraction of all variables) and weak (are
not able to discriminate between the two classes all by themselves).
</p>


<h3>Value</h3>

<p>A vector containing the ordered
indices of the p values satisfying the HC criterion. 
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>David Donoho and Jiashun Jin: Higher criticism thresholding: Optimal
feature selection when useful features are rare and weak. <em>PNAS</em>
108:14790-14795 (2008).
</p>
<p>Ron Wehrens and Pietro Franceschi: Thresholding for Biomarker
Selection in Multivariate Data using Higher Criticism.
Mol. Biosystems (2012). In press. DOI: 10.1039/C2MB25121C
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.biom">get.biom</a></code> for general approaches to obtain biomarkers
based on multivariate discriminant methods and t statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spikedApples)
bms &lt;- get.biom(spikedApples$dataMatrix, rep(0:1, each = 10),
                type = "coef", fmethod = "studentt")
bms.pvalues &lt;- 2 * (1 - pt(abs(bms[[1]]), 18))
sum(bms.pvalues &lt; .05)                           ## 15
sum(p.adjust(bms.pvalues, method = "fdr") &lt; .05) ## 4
signif.bms &lt;- HCthresh(bms.pvalues, plotit = TRUE)
length(signif.bms)                               ## 11
</code></pre>

<hr>
<h2 id='ROC'>ROC curves</h2><span id='topic+ROC'></span><span id='topic+print.ROC'></span><span id='topic+plot.ROC'></span><span id='topic+lines.ROC'></span><span id='topic+points.ROC'></span><span id='topic+identify.ROC'></span><span id='topic+ROC.default'></span><span id='topic+roc.value'></span><span id='topic+AUC'></span>

<h3>Description</h3>

<p>Functions for making, plotting and analysing ROC curves.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROC(TestResult, ...)
## Default S3 method:
ROC(TestResult, D, take.abs = TRUE, ...)
## S3 method for class 'ROC'
plot(x, type = "b", null.line = TRUE,
xlab = "False Pos. Rate", ylab = "True Pos. Rate",
xlim = c(0, 1), ylim = c(0, 1), main = "ROC", ...) 
## S3 method for class 'ROC'
points(x, ...)
## S3 method for class 'ROC'
lines(x, ...)
## S3 method for class 'ROC'
identify(x, labels = NULL, ..., digits = 1)
## S3 method for class 'ROC'
print(x, ...)
roc.value(found, true, totalN)
AUC(x, max.mspec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROC_+3A_testresult">TestResult</code></td>
<td>
<p>Typically regression coefficients or t
statistics. Note that when p values are used directly, the least
significant values would be selected first. In this case one should
use 1/p.</p>
</td></tr>
<tr><td><code id="ROC_+3A_d">D</code></td>
<td>
<p>True, known, differences, either expressed as a vector of 0
and 1 of the same length as <code>TestResult</code> or as a vector of
indices.</p>
</td></tr>
<tr><td><code id="ROC_+3A_take.abs">take.abs</code></td>
<td>
<p>Logical, indicating whether to take absolute values of
the test statistic.</p>
</td></tr>
<tr><td><code id="ROC_+3A_x">x</code></td>
<td>
<p>An object of class ROC.</p>
</td></tr>
<tr><td><code id="ROC_+3A_type">type</code>, <code id="ROC_+3A_xlab">xlab</code>, <code id="ROC_+3A_ylab">ylab</code>, <code id="ROC_+3A_xlim">xlim</code>, <code id="ROC_+3A_ylim">ylim</code>, <code id="ROC_+3A_main">main</code>, <code id="ROC_+3A_labels">labels</code>, <code id="ROC_+3A_digits">digits</code></td>
<td>
<p>Standard
arguments to functions like <code>plot</code> and <code>identify</code>.</p>
</td></tr>
<tr><td><code id="ROC_+3A_null.line">null.line</code></td>
<td>
<p>Logical, whether to draw the line y = x,
corresponding to random guessing.</p>
</td></tr>
<tr><td><code id="ROC_+3A_max.mspec">max.mspec</code></td>
<td>
<p>Maximal value of the True Positive Rate to consider
in AUC calculations. Setting this to a value smaller than one (which
is the default) leads to a partial AUC value, which may in many
cases be more useful.</p>
</td></tr>
<tr><td><code id="ROC_+3A_found">found</code></td>
<td>
<p>The indices of the coefficients identified with a
biomarker identification method.</p>
</td></tr>
<tr><td><code id="ROC_+3A_true">true</code></td>
<td>
<p>The indices of the true biomarkers.</p>
</td></tr>
<tr><td><code id="ROC_+3A_totaln">totalN</code></td>
<td>
<p>The total number of variables to choose from.</p>
</td></tr>
<tr><td><code id="ROC_+3A_...">...</code></td>
<td>
<p>Further arguments, especially useful in the plotting
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>ROC</code> returns a list with elements:
</p>

<ol>
<li><p>sensSensitivity, or True Positive Rate (TPR).
</p>
</li>
<li><p>mspec1 - Specificity, or False Positive Rate (FPR).
</p>
</li>
<li><p>testlevels of the test statistic.
</p>
</li>
<li><p>callFunction call.
</p>
</li></ol>

<p>Function <code>roc.value</code> returns a list with elements <code>sens</code> and
<code>mspec</code>, i.e., one point on a ROC curve.
</p>
<p>Function <code>AUC</code> returns the area under the curve, measured up to the
value of <code>max.mspec</code> - if the latter is smaller than 1, it is a
partial AUC curve.
</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>T. Lumley: ROC curves - in Programme's Niche, R News 4/1, June 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spikedApples)
apple.coef &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = rep(1:2, each = 10),
                       fmethod = "vip",
                       ncomp = 3, type = "coef")

## ROC curve for all VIP values, ordered according to size
true.biom &lt;- (1:ncol(spikedApples$dataMatrix) %in% spikedApples$biom)
vip.roc &lt;- ROC(apple.coef$vip, true.biom)
plot(vip.roc)

## Add stability-based selection point
apple.stab &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = rep(1:2, each = 10),
                       fmethod = "vip",
                       ncomp = 3, type = "stab")
stab.roc &lt;- roc.value(apple.stab$vip[[1]]$biom.indices,
                      spikedApples$biom,
                      totalN = ncol(spikedApples$dataMatrix))
points(stab.roc, col = "red", pch = 19, cex = 1.5)

## Not run: 
## Add HC-based selection point
## Attention: takes approx. 2 minutes on my PC
apple.HC &lt;- get.biom(X = spikedApples$dataMatrix,
                     Y = rep(1:2, each = 10),
                     fmethod = "vip",
                     ncomp = 3, type = "HC")
HC.roc &lt;- roc.value(apple.HC$vip$biom.indices,
                    spikedApples$biom,
                    totalN = ncol(spikedApples$dataMatrix))
points(HC.roc, col = "blue", pch = 19, cex = 1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='scalefun'>Different forms of scaling</h2><span id='topic+scalefun'></span>

<h3>Description</h3>

<p>Function providing different forms of scaling in disciminant analysis
- the resulting data matrix is mean-centered after the
scaling. Modelled after functions in the st package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalefun(sc.p = c("none", "log", "sqrt", "pareto", "auto"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalefun_+3A_sc.p">sc.p</code></td>
<td>
<p>Type of scaling. A pass-through option, performing only
mean-centering, is provided by argument &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. The function performs the required scaling, and
mean-centers the result.</p>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- gen.data(5, nvar = 9, nsimul = 1)
FUN &lt;- scalefun(sc.p = "pareto")
FUN(X$X[,,1])
</code></pre>

<hr>
<h2 id='selection'>Accessor function to the selected variables of a BioMark object</h2><span id='topic+selection'></span>

<h3>Description</h3>

<p>Convenience function to get the indices of the selection in
a BioMark object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_+3A_object">object</code></td>
<td>
<p>An object of class <code>BioMark</code>.</p>
</td></tr>
<tr><td><code id="selection_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the indices of the selected variables.</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.biom">get.biom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## stability-based selection
set.seed(17)
data(spikedApples)
apple.stab &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = factor(rep(1:2, each = 10)),
                       ncomp = 2:3, type = "stab")
selected.variables &lt;- selection(apple.stab)
</code></pre>

<hr>
<h2 id='SpikedApple'>Spike-in metabolomics data for apple extracts</h2><span id='topic+SpikedApple'></span><span id='topic+SpikeNeg'></span><span id='topic+SpikePos'></span><span id='topic+neg.markers'></span><span id='topic+pos.markers'></span>

<h3>Description</h3>

<p>Data from a spike-in experiment for apple extracts. Twenty apple
extracts are divided in two groups, one control, and one spike-in
group. The control group is measured without any spiking - the spike-in
group is spiked with nine chemical compounds in three different
combinations of concentrations. The data provide the experimental data
of the forty apple extracts in lists <code>SpikePos</code> and <code>SpikeNeg</code>
for positive and negative ionization, respectively, and in two separate
data.frames (<code>pos.markers</code> and <code>neg.markers</code>) contains
information of the features of the standards, i.e., the spike-in compounds.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SpikePos)
data(SpikeNeg)
</code></pre>


<h3>Format</h3>

<p><code>SpikePos</code> and <code>SpikeNeg</code> are lists with three
elements:
</p>

<dl>
<dt>data</dt><dd><p>Data matrix, describing for each of the forty injections
the intensity of the features (columns). Column names consist of a
combination of retention time (in seconds) and m/z values, and are
sorted on retention time.</p>
</dd>
<dt>classes</dt><dd><p>Class labels for the forty injections (control, or
group1, 2 or 3).</p>
</dd>
<dt>annotation</dt><dd><p>Matrix, containing for each of the features XCMS
and CAMERA information, such as mz, rt, number of times a feature
is identified in the control or spike-in samples, possible isotope
or adduct annotation, and whether or not the feature is identified
in the standards (the spike-in data).</p>
</dd>
</dl>

<p>In addition, <code>pos.markers</code> and <code>neg.markers</code> contain the
information of the standards, i.e. the compounds that are spiked
in. These data.frames describe in their rows single features
identified with XCMS and CAMERA, using the same settings as the 
experimental apple data, and have the following columns:
</p>

<dl>
<dt>comp</dt><dd><p>The (short) name of the spiked-in compound giving rise
to this particular feature.</p>
</dd>
<dt>mz, rt, isotope, adduct</dt><dd><p>Feature information, similar to the
information in the <code>annotation</code> fields in <code>SpikePos</code> and
<code>SpikeNeg</code>.</p>
</dd>
<dt>feature.nr</dt><dd><p>The number of the corresponding feature in either
<code>SpikePos</code> or <code>SpikeNeg</code>.</p>
</dd>
<dt>group1, group2, group3</dt><dd><p>Approximate spiking levels for the
three groups. A value of 1.0 corresponds to an increase that is
roughly equal to the naturally occuring concentration in
apple. Exceptions are trans-resveratrol and
cyanidin-3-galactoside, both not naturally occuring. These two
compounds have been spiked in at one constant level which gives
features of comparable size.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is the complete data set, from which <code>spikedApples</code> is a
subset, basically presenting the control and group1 information with
hand-picked spike-in features. The data in SpikePos and SpikeNeg use
CAMERA grouping to automatically determine which features are
corresponding to which spike-in compounds. Raw data in CDF format are
available from the MetaboLights repository.
</p>


<h3>Author(s)</h3>

<p>Pietro Franceschi</p>


<h3>Source</h3>

<p>http://www.ebi.ac.uk/metabolights/MTBLS59
</p>
<p>P. Franceschi, D. Masuero, U. Vrhovsek, F. Mattivi and R. Wehrens: A
benchmark spike-in data set for biomarker identification in
metabolomics. J. Chemom. 26, 16-24 (2012).
</p>


<h3>See Also</h3>

<p>spikedApples</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SpikePos)
plot(SpikePos$annotation[,c("rt", "mz")],
     xlab = "Time (s)", ylab = "m/z",
     main = "Positive ionization mode")
points(pos.markers[!is.na(pos.markers$feature.nr), c("rt", "mz")],
       pch = 19, col = 2)

data(SpikeNeg)
plot(SpikeNeg$annotation[,c("rt", "mz")],
     xlab = "Time (s)", ylab = "m/z",
     main = "Negative ionization mode")
points(neg.markers[!is.na(neg.markers$feature.nr), c("rt", "mz")],
       pch = 19, col = 2)
</code></pre>

<hr>
<h2 id='spikedApples'>Metabolomics data on spiked apples</h2><span id='topic+spikedApples'></span>

<h3>Description</h3>

<p>An data set of LC-MS features, obtained from twenty
apples. The last ten apples are spiked with known compounds. This set
provides a test case for biomarker selection methods: the task is to
retrieve the true biomarker variables. The raw LC-MS data have been
converted to CDF format and processed with XCMS to obtain the features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spikedApples)</code></pre>


<h3>Format</h3>

<p>The format is a list of four elements:
</p>

<dl>
<dt>mz</dt><dd><p>the m/z values of the features (rounded)</p>
</dd>
<dt>rt</dt><dd><p>the retention times of the features</p>
</dd>
<dt>dataMatrix</dt><dd><p>the intensities of the features in the individual samples</p>
</dd>
<dt>biom</dt><dd><p>the indices of the &quot;true&quot; biomarkers</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pietro Franceschi</p>


<h3>References</h3>

<p>P. Franceschi, D. Masuero, U. Vrhovsek, F. Mattivi and R. Wehrens: A
benchmark spike-in data set for biomarker identification in
metabolomics. J. Chemom. 26, 16-24 (2012)
</p>
<p>R. Wehrens, P. Franceschi, U. Vrhovsek and F. Mattivi. Stability-based
biomarker selection. Analytica Chimica Acta (2011), 705, 15-23.
http://dx.doi.org/10.1016/j.aca.2011.01.039.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spikedApples)
## show features identified in all apples
plot(spikedApples$rt, spikedApples$mz,
     xlab = "Retention time (s)", ylab = "m/z",
     main = "Spiked apples - subset")
</code></pre>

<hr>
<h2 id='traceplot'>Plot the coefficient or stability trace for the lasso/elastic net
biomarker selection.</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>The function plots the coefficient or stability traces for the lasso
element of a BioMark object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_object">object</code></td>
<td>
<p>An object of class <code>BioMark</code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>Further plotting arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ron Wehrens</p>


<h3>References</h3>

<p>N. Meinshausen and P. Buhlmann: Stability
Selection. J. R. Statist. Soc. B 72, 417-473 (2010)</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.biom">get.biom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BioMark)
data(spikedApples)

mycols &lt;- rep("gray", ncol(spikedApples$dataMatrix))
mycols[spikedApples$biom] &lt;- "red"
myltys &lt;- rep(2, ncol(spikedApples$dataMatrix))
myltys[spikedApples$biom] &lt;- 1

par(mfrow = c(1,2))
apple.coef &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = factor(rep(0:1, each = 10)),
                       ncomp = 2:3, type = "coef")
traceplot(apple.coef, col = mycols, lty = myltys)

apple.stab &lt;- get.biom(X = spikedApples$dataMatrix,
                       Y = factor(rep(0:1, each = 10)),
                       fmethod = c("vip","lasso"), type = "stab")
traceplot(apple.stab, col = mycols, lty = myltys)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
