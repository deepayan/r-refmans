<!DOCTYPE html><html><head><title>Help for package skpr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {skpr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>re-export magrittr pipe operator</p></a></li>
<li><a href='#add_ci_bounds_mc_power'><p>Calculate CI bounds on Monte Carlo</p></a></li>
<li><a href='#aliasmodel'><p>Alias terms</p></a></li>
<li><a href='#anticoef_from_delta'><p>Generates Anticipated Coefficients from delta</p></a></li>
<li><a href='#anticoef_from_delta_surv'><p>Generates Anticipated Coefficients from delta for eval_design_suvival_mc</p></a></li>
<li><a href='#blockingstructure'><p>Find block sizes in column</p></a></li>
<li><a href='#calc_conservative_anticoef'><p>Calculate Conservative Anticipated Coefficients</p></a></li>
<li><a href='#calc_interaction_degrees'><p>Calculate Interaction Degrees of Freedom</p></a></li>
<li><a href='#calcblocksizes'><p>Calculate block sizes</p></a></li>
<li><a href='#calcnoncentralparam'><p>Calculate Non-Centrality Parameter</p></a></li>
<li><a href='#calculate_block_nesting'><p>Determine Nesting Level of Blocks</p></a></li>
<li><a href='#calculate_degrees_of_freedom'><p>Calculate Degrees of Freedom</p></a></li>
<li><a href='#calculate_gefficiency'><p>Calculate G Efficiency</p></a></li>
<li><a href='#calculate_level_vector'><p>Calculate level vector</p></a></li>
<li><a href='#calculate_power_curves'><p>Calculate Power Curves</p></a></li>
<li><a href='#calculate_split_columns'><p>Calculate Split Plot Columns</p></a></li>
<li><a href='#calculate_v_from_blocks'><p>Calculate V from Blocks</p></a></li>
<li><a href='#calculatepower'><p>Calculate Power</p></a></li>
<li><a href='#check_for_suggest_packages'><p>check_for_suggest_packages</p></a></li>
<li><a href='#check_model_validity'><p>Check Model Formula Validity</p></a></li>
<li><a href='#constructRunMatrix'><p>Construct Run Matrix given rows</p></a></li>
<li><a href='#contr.simplex'><p>Orthonormal Contrast Generator</p></a></li>
<li><a href='#convert_blockcolumn_rownames'><p>Convert Block Column to Rownames</p></a></li>
<li><a href='#convert_model_dots'><p>Converts dot operator to terms</p></a></li>
<li><a href='#convert_rownames_to_covariance'><p>Converts dot operator to terms</p></a></li>
<li><a href='#disallowed_combinations'><p>Detect and list disallowed combinations in candidate set</p></a></li>
<li><a href='#effectpower'><p>Calculate Effect Power</p></a></li>
<li><a href='#effectpowermc'><p>Fit Anova for Effect Power Calculation in Monte Carlo</p></a></li>
<li><a href='#eval_design'><p>Calculate Power of an Experimental Design</p></a></li>
<li><a href='#eval_design_custom_mc'><p>Monte Carlo power evaluation for experimental designs with user-supplied libraries</p></a></li>
<li><a href='#eval_design_mc'><p>Monte Carlo Power Evaluation for Experimental Designs</p></a></li>
<li><a href='#eval_design_survival_mc'><p>Evaluate Power for Survival Design</p></a></li>
<li><a href='#extractPvalues'><p>Extract p-values from a model object</p></a></li>
<li><a href='#gen_anticoef'><p>Generates Anticipated Coefficients</p></a></li>
<li><a href='#gen_binomial_anticoef'><p>Generates Binomial Anticipated Coefficients</p></a></li>
<li><a href='#gen_design'><p>Generate optimal experimental designs</p></a></li>
<li><a href='#gen_exponential_anticoef'><p>Generates Exponential Anticipated Coefficients</p></a></li>
<li><a href='#gen_momentsmatrix'><p>Generates the moment matrix</p></a></li>
<li><a href='#gen_poisson_anticoef'><p>Generates Poisson Anticipated Coefficients</p></a></li>
<li><a href='#generate_block_panel'><p>Generate Block Panel</p></a></li>
<li><a href='#generate_factor_input_panel'><p>Generate Factor Input Panel</p></a></li>
<li><a href='#generate_noise_block'><p>Generate Noise Block</p></a></li>
<li><a href='#generate_optimality_results'><p>Generate Optimality Results</p></a></li>
<li><a href='#genhypmatrix'><p>Generate Hypothesis Matrix</p></a></li>
<li><a href='#genparammatrix'><p>Generate Parameter Matrix</p></a></li>
<li><a href='#get_attribute'><p>Get attribute values</p></a></li>
<li><a href='#get_block_groups'><p>Calculate block structure lengths</p></a></li>
<li><a href='#get_optimality'><p>Get optimality values</p></a></li>
<li><a href='#get_power_curve_output'><p>Get Power Curve Warnings and Errors</p></a></li>
<li><a href='#is_intralayer_interaction'><p>Layer Interaction</p></a></li>
<li><a href='#is_rendering_in_knitr'><p>Determines if rendering in knitr</p></a></li>
<li><a href='#normalize_design'><p>Normalize Design</p></a></li>
<li><a href='#parameterpower'><p>Calculates parameter power</p></a></li>
<li><a href='#permutations'><p>Permutations</p></a></li>
<li><a href='#plot_correlations'><p>Plots design diagnostics</p></a></li>
<li><a href='#plot_fds'><p>Fraction of Design Space Plot</p></a></li>
<li><a href='#potential_permuted_factors'><p>Find potential permuted interactions</p></a></li>
<li><a href='#print.skpr_eval_output'><p>Print evaluation information</p></a></li>
<li><a href='#print.skpr_power_curve_output'><p>Print evaluation information</p></a></li>
<li><a href='#priorlevels'><p>Prior levels</p></a></li>
<li><a href='#quad'><p>quadratic</p></a></li>
<li><a href='#rearrange_formula_by_order'><p>Rearrange formula by order</p></a></li>
<li><a href='#reduceRunMatrix'><p>Remove columns not in model</p></a></li>
<li><a href='#remove_skpr_blockcols'><p>Remove skpr-generated blocking columns</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#set_up_progressr_handler'><p>Set up progressr handler</p></a></li>
<li><a href='#skprGUI'><p>Graphical User Interface for skpr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Design of Experiments Suite: Generate and Evaluate Optimal
Designs</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-25</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates and evaluates D, I, A, Alias, E, T, and G optimal designs. Supports generation and evaluation of blocked and split/split-split/.../N-split plot designs. Includes parametric and Monte Carlo power evaluation functions, and supports calculating power for censored responses. Provides a framework to evaluate power using functions provided in other packages or written by the user. Includes a Shiny graphical user interface that displays the underlying code used to create and evaluate the design to improve ease-of-use and make analyses more reproducible. For details, see Morgan-Wall et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v099.i01">doi:10.18637/jss.v099.i01</a>&gt;.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Institute for Defense Analyses</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, iterators, stats, lme4, Rcpp (&ge; 0.11.0), foreach,
doParallel, survival, future, car, viridis, magrittr, lmerTest,
methods, progress, scales, doRNG, doFuture, progressr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mbest, ggplot2, lmtest, cli, gridExtra, rintrojs,
shinythemes, shiny, shinyjs, gt, shinytest2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tylermorganwall/skpr">https://github.com/tylermorganwall/skpr</a>,
<a href="https://tylermorganwall.github.io/skpr/">https://tylermorganwall.github.io/skpr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/skpr/issues">https://github.com/tylermorganwall/skpr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 20:37:02 UTC; tmorganw</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall [aut, cre],
  George Khoury [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 01:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>re-export magrittr pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>re-export magrittr pipe operator
</p>

<hr>
<h2 id='add_ci_bounds_mc_power'>Calculate CI bounds on Monte Carlo</h2><span id='topic+add_ci_bounds_mc_power'></span>

<h3>Description</h3>

<p>Calculates CI bounds for Monte Carlo power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_ci_bounds_mc_power(power_results, nsim, conf = 0.95)
</code></pre>


<h3>Value</h3>

<p>Power data.frame with conf intervals
</p>

<hr>
<h2 id='aliasmodel'>Alias terms</h2><span id='topic+aliasmodel'></span>

<h3>Description</h3>

<p>Creates alias terms for Alias-optimal designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliasmodel(formula, power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliasmodel_+3A_formula">formula</code></td>
<td>
<p>The formula to be expanded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns aliased model terms from formula
</p>

<hr>
<h2 id='anticoef_from_delta'>Generates Anticipated Coefficients from delta</h2><span id='topic+anticoef_from_delta'></span>

<h3>Description</h3>

<p>Generates Anticipated Coefficients from delta parameter
The logic for generating anticipated coefficients from delta varies with
glm family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anticoef_from_delta(default_coef, delta, glmfamily)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anticoef_from_delta_+3A_default_coef">default_coef</code></td>
<td>
<p>a vector of default coefficients, from gen_anticoef</p>
</td></tr>
<tr><td><code id="anticoef_from_delta_+3A_delta">delta</code></td>
<td>
<p>the user-input delta parameter, must be a numeric vector of length 1 or 2</p>
</td></tr>
<tr><td><code id="anticoef_from_delta_+3A_glmfamily">glmfamily</code></td>
<td>
<p>the user-supplied glmfamily, either a string or a glmfamily object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='anticoef_from_delta_surv'>Generates Anticipated Coefficients from delta for eval_design_suvival_mc</h2><span id='topic+anticoef_from_delta_surv'></span>

<h3>Description</h3>

<p>Generates Anticipated Coefficients from delta parameter
The logic for generating anticipated coefficients from delta varies with
glm family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anticoef_from_delta_surv(default_coef, delta, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anticoef_from_delta_surv_+3A_default_coef">default_coef</code></td>
<td>
<p>a vector of default coefficients, from gen_anticoef</p>
</td></tr>
<tr><td><code id="anticoef_from_delta_surv_+3A_delta">delta</code></td>
<td>
<p>the user-input delta parameter, must be a numeric vector of length 1 or 2</p>
</td></tr>
<tr><td><code id="anticoef_from_delta_surv_+3A_distribution">distribution</code></td>
<td>
<p>the user-supplied distribution, either a string or a survreg distribution object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='blockingstructure'>Find block sizes in column</h2><span id='topic+blockingstructure'></span>

<h3>Description</h3>

<p>Returns blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockingstructure(blocklist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockingstructure_+3A_blocklist">blocklist</code></td>
<td>
<p>Block list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the blocking structure given a vector of block ids
</p>

<hr>
<h2 id='calc_conservative_anticoef'>Calculate Conservative Anticipated Coefficients</h2><span id='topic+calc_conservative_anticoef'></span>

<h3>Description</h3>

<p>Calculate Conservative Anticipated Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_conservative_anticoef(results, effectsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_conservative_anticoef_+3A_results">results</code></td>
<td>
<p>The power results matrix</p>
</td></tr>
<tr><td><code id="calc_conservative_anticoef_+3A_effectsize">effectsize</code></td>
<td>
<p>The effectsize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of conservative anticipated coefficients
</p>

<hr>
<h2 id='calc_interaction_degrees'>Calculate Interaction Degrees of Freedom</h2><span id='topic+calc_interaction_degrees'></span>

<h3>Description</h3>

<p>Calculate interaction degrees of freedom for split-plot designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_interaction_degrees(
  design,
  model,
  contrast,
  nointercept,
  split_layers,
  split_degrees,
  split_plot_structure
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_interaction_degrees_+3A_design">design</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code id="calc_interaction_degrees_+3A_model">model</code></td>
<td>
<p>The model</p>
</td></tr>
<tr><td><code id="calc_interaction_degrees_+3A_contrast">contrast</code></td>
<td>
<p>The contrast</p>
</td></tr>
<tr><td><code id="calc_interaction_degrees_+3A_split_layers">split_layers</code></td>
<td>
<p>The layer of split plots for each main effect term</p>
</td></tr>
<tr><td><code id="calc_interaction_degrees_+3A_split_degrees">split_degrees</code></td>
<td>
<p>The number of degrees of freedom for each main effect term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Degrees of freedom vector
</p>

<hr>
<h2 id='calcblocksizes'>Calculate block sizes</h2><span id='topic+calcblocksizes'></span>

<h3>Description</h3>

<p>Calculate block size vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcblocksizes(trials, blocksize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcblocksizes_+3A_trials">trials</code></td>
<td>
<p>Number of trials in design</p>
</td></tr>
<tr><td><code id="calcblocksizes_+3A_blocksize">blocksize</code></td>
<td>
<p>The desired size of each block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The blocksize vector
</p>

<hr>
<h2 id='calcnoncentralparam'>Calculate Non-Centrality Parameter</h2><span id='topic+calcnoncentralparam'></span>

<h3>Description</h3>

<p>Calculates the non-centrality parameter for the model matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcnoncentralparam(X, L, b, vinv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcnoncentralparam_+3A_x">X</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="calcnoncentralparam_+3A_l">L</code></td>
<td>
<p>The parameter matrix/vector</p>
</td></tr>
<tr><td><code id="calcnoncentralparam_+3A_b">b</code></td>
<td>
<p>The anticipated coefficients</p>
</td></tr>
<tr><td><code id="calcnoncentralparam_+3A_vinv">vinv</code></td>
<td>
<p>variance-covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The non-centrality parameter for the F test
</p>

<hr>
<h2 id='calculate_block_nesting'>Determine Nesting Level of Blocks</h2><span id='topic+calculate_block_nesting'></span>

<h3>Description</h3>

<p>Calculates if a block is fully nested within another block, and
what the highest level of nesting is. 1 indicates the block isn't nested within
another block&ndash;just within the intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_block_nesting(blockgroups, blockstructure)
</code></pre>


<h3>Value</h3>

<p>Vector of numbers indicating the hierarchy
</p>

<hr>
<h2 id='calculate_degrees_of_freedom'>Calculate Degrees of Freedom</h2><span id='topic+calculate_degrees_of_freedom'></span>

<h3>Description</h3>

<p>Calculates the degrees of freedom adjustment for models with random effects from Penheiro and Bates, pg. 91
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_degrees_of_freedom(
  run_matrix_processed,
  nointercept,
  model,
  contrasts
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_degrees_of_freedom_+3A_run_matrix_processed">run_matrix_processed</code></td>
<td>
<p>The design</p>
</td></tr>
<tr><td><code id="calculate_degrees_of_freedom_+3A_nointercept">nointercept</code></td>
<td>
<p>Whether the intercept term is present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numbers indicating split plot layers
</p>

<hr>
<h2 id='calculate_gefficiency'>Calculate G Efficiency</h2><span id='topic+calculate_gefficiency'></span>

<h3>Description</h3>

<p>Either calculates G-Efficiency by Monte Carlo sampling from the design space (ignoring constraints),
searching for the maximum point (slower but higher quality), or by using a user-specified candidate set
for the design space (fastest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_gefficiency(
  design,
  calculation_type = "random",
  randsearches = 10000,
  design_space_mm = NULL
)
</code></pre>


<h3>Value</h3>

<p>Normalized run matrix
</p>

<hr>
<h2 id='calculate_level_vector'>Calculate level vector</h2><span id='topic+calculate_level_vector'></span>

<h3>Description</h3>

<p>Calculate level vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_level_vector(design, model, nointercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_level_vector_+3A_design">design</code></td>
<td>
<p>Design to be analyzed.</p>
</td></tr>
<tr><td><code id="calculate_level_vector_+3A_model">model</code></td>
<td>
<p>The model.</p>
</td></tr>
<tr><td><code id="calculate_level_vector_+3A_nointercept">nointercept</code></td>
<td>
<p>Whether an intercept is included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We can pass either the output of gen_design or eval_design to plot_correlations
</code></pre>

<hr>
<h2 id='calculate_power_curves'>Calculate Power Curves</h2><span id='topic+calculate_power_curves'></span>

<h3>Description</h3>

<p>Calculate and optionally plot power curves for different effect sizes and
trial counts. This function takes a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_power_curves(
  trials,
  effectsize = 1,
  candidateset = NULL,
  model = NULL,
  alpha = 0.05,
  gen_args = list(),
  eval_function = "eval_design",
  eval_args = list(),
  random_seed = 123,
  iterate_seed = FALSE,
  plot_results = TRUE,
  auto_scale = TRUE,
  x_breaks = NULL,
  y_breaks = seq(0, 1, by = 0.1),
  ggplot_elements = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_power_curves_+3A_trials">trials</code></td>
<td>
<p>A numeric vector indicating the trial(s) used when computing the power curve. If a single
value, this will be fixed and only 'effectsize' will be varied.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_effectsize">effectsize</code></td>
<td>
<p>Default '1'. A numeric vector indicating the effect size(s) used when computing the power curve. If a single
value, this will be fixed and only 'trials' will be varied. If using a length-2 effect size with 'eval_design_mc()' (such as
a binomial probability interval), the effect size pairs can be input as entries in a list.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_candidateset">candidateset</code></td>
<td>
<p>Default 'NULL'. The candidate set (see 'gen_design()' documentation for more information). Provided to aid code completion: can also
be provided in 'gen_args'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_model">model</code></td>
<td>
<p>Default 'NULL'. The model (see 'gen_design()' and 'eval_design()' documentation for more information). Provided to aid code completion: can also
be provided in 'gen_args'/'eval_args'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_alpha">alpha</code></td>
<td>
<p>Default '0.05'. The allowable Type-I error rate (see 'eval_design()' documentation for more information). Provided to aid code completion: can also
be provided in 'eval_args'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_gen_args">gen_args</code></td>
<td>
<p>Default 'list()'. A list of argument/value pairs to specify the design generation parameters for 'gen_design()'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_eval_function">eval_function</code></td>
<td>
<p>Default '&quot;eval_design&quot;'. A string (or function) specifying the skpr power evaluation function.
Can also be '&quot;eval_design_mc&quot;', '&quot;eval_design_survival_mc&quot;', and '&quot;eval_design_custom_mc&quot;'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_eval_args">eval_args</code></td>
<td>
<p>Default 'list()'. A list of argument/value pairs to specify the design power evaluation parameters for 'eval_function'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_random_seed">random_seed</code></td>
<td>
<p>Default '123'. The random seed used to generate and then evaluate the design. The seed is set right before design generation.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_iterate_seed">iterate_seed</code></td>
<td>
<p>Default 'FALSE'. This will iterate the random seed with each new design. Set this to 'TRUE' to add more variability to the design generation process.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_plot_results">plot_results</code></td>
<td>
<p>Default 'TRUE'. Whether to print out a plot of the power curves in addition to the data frame of results. Requires 'ggplot2'.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_auto_scale">auto_scale</code></td>
<td>
<p>Default 'TRUE'. Whether to automatically scale the y-axis to 0 and 1.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_x_breaks">x_breaks</code></td>
<td>
<p>Default 'NULL', automaticly generated by ggplot2.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_y_breaks">y_breaks</code></td>
<td>
<p>Default 'seq(0,1,by=0.1)'. Y-axis breaks.</p>
</td></tr>
<tr><td><code id="calculate_power_curves_+3A_ggplot_elements">ggplot_elements</code></td>
<td>
<p>Default 'list()'. Extra 'ggplot2' elements to customize the plot, passed in as elements in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of power values with design generation information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(skpr:::run_documentation()) {
cand_set = expand.grid(brew_temp = c(80, 85, 90),
                      altitude = c(0, 2000, 4000),
                      bean_sun = c("low", "partial", "high"))
#Plot power for a linear model with all interactions
calculate_power_curves(trials=seq(10,60,by=5),
                      candidateset = cand_set,
                      model = ~.*.,
                      alpha = 0.05,
                      effectsize = 1,
                      eval_function = "eval_design") |&gt;
 head(30)

}
if(skpr:::run_documentation()) {
#Add multiple effect sizes
calculate_power_curves(trials=seq(10,60,by=1),
                      candidateset = cand_set,
                      model = ~.*.,
                      alpha = 0.05,
                      effectsize = c(1,2),
                      eval_function = "eval_design") |&gt;
 head(30)
}
if(skpr:::run_documentation()) {
#Generate power curve for a binomial model
calculate_power_curves(trials=seq(50,150,by=10),
                      candidateset = cand_set,
                      model = ~.,
                      effectsize = c(0.6,0.9),
                      eval_function = "eval_design_mc",
                      eval_args = list(nsim = 100, glmfamily = "binomial")) |&gt;
 head(30)
}
if(skpr:::run_documentation()) {
#Generate power curve for a binomial model and multiple effect sizes
calculate_power_curves(trials=seq(50,150,by=10),
                      candidateset = cand_set,
                      model = ~.,
                      effectsize = list(c(0.5,0.9),c(0.6,0.9)),
                      eval_function = "eval_design_mc",
                      eval_args = list(nsim = 100, glmfamily = "binomial")) |&gt;
 head(30)
}
</code></pre>

<hr>
<h2 id='calculate_split_columns'>Calculate Split Plot Columns</h2><span id='topic+calculate_split_columns'></span>

<h3>Description</h3>

<p>Calculates which columns correspond to which layers of randomization restriction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_split_columns(run_matrix_processed, blockgroups, blockstructure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_split_columns_+3A_run_matrix_processed">run_matrix_processed</code></td>
<td>
<p>The design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numbers indicating split plot layers
</p>

<hr>
<h2 id='calculate_v_from_blocks'>Calculate V from Blocks</h2><span id='topic+calculate_v_from_blocks'></span>

<h3>Description</h3>

<p>Calculates the V matrix from the block structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_v_from_blocks(
  nrow_design,
  blockgroups,
  blockstructure,
  varianceratios
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_v_from_blocks_+3A_nrow_design">nrow_design</code></td>
<td>
<p>The number of runs in the design</p>
</td></tr>
<tr><td><code id="calculate_v_from_blocks_+3A_blockgroups">blockgroups</code></td>
<td>
<p>List indicating the size of each block for each layer</p>
</td></tr>
<tr><td><code id="calculate_v_from_blocks_+3A_blockstructure">blockstructure</code></td>
<td>
<p>Matrix indicating the block structure from the rownames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-Covariance Matrix
</p>

<hr>
<h2 id='calculatepower'>Calculate Power</h2><span id='topic+calculatepower'></span>

<h3>Description</h3>

<p>Calculates the power of the model given the non-centrality parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculatepower(X, L, lambda, alpha, degrees_of_freedom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculatepower_+3A_x">X</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="calculatepower_+3A_l">L</code></td>
<td>
<p>The parameter matrix/vector</p>
</td></tr>
<tr><td><code id="calculatepower_+3A_lambda">lambda</code></td>
<td>
<p>The non-centrality parameter for the F test</p>
</td></tr>
<tr><td><code id="calculatepower_+3A_alpha">alpha</code></td>
<td>
<p>the specified type-I error</p>
</td></tr>
<tr><td><code id="calculatepower_+3A_degrees_of_freedom">degrees_of_freedom</code></td>
<td>
<p>The number of degrees of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The power for a given parameter L, given the
</p>

<hr>
<h2 id='check_for_suggest_packages'>check_for_suggest_packages</h2><span id='topic+check_for_suggest_packages'></span>

<h3>Description</h3>

<p>checks for suggests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_for_suggest_packages(packages)
</code></pre>


<h3>Value</h3>

<p>none
</p>

<hr>
<h2 id='check_model_validity'>Check Model Formula Validity</h2><span id='topic+check_model_validity'></span>

<h3>Description</h3>

<p>Check Model Formula Validity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model_validity(model)
</code></pre>

<hr>
<h2 id='constructRunMatrix'>Construct Run Matrix given rows</h2><span id='topic+constructRunMatrix'></span>

<h3>Description</h3>

<p>Returns number of levels prior to each parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructRunMatrix(rowIndices, candidateList, augment = NULL)
</code></pre>


<h3>Value</h3>

<p>Returns a vector consisting of the number
of levels preceeding each parameter (including the intercept)
</p>

<hr>
<h2 id='contr.simplex'>Orthonormal Contrast Generator</h2><span id='topic+contr.simplex'></span>

<h3>Description</h3>

<p>Generates orthonormal (orthogonal and normalized) contrasts. Each row is the vertex of an N-dimensional simplex. The only exception are contrasts for the 2-level case, which return 1 and -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.simplex(n, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.simplex_+3A_n">n</code></td>
<td>
<p>The number of levels in the catagorical variable. If this is a factor or character vector, 'n' will be 'length(n)'</p>
</td></tr>
<tr><td><code id="contr.simplex_+3A_size">size</code></td>
<td>
<p>Default '1'. The length of the simplex vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of Orthonormal contrasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contr.simplex(4)
</code></pre>

<hr>
<h2 id='convert_blockcolumn_rownames'>Convert Block Column to Rownames</h2><span id='topic+convert_blockcolumn_rownames'></span>

<h3>Description</h3>

<p>Detect externally generated blocking columns and convert to rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_blockcolumn_rownames(
  RunMatrix,
  blocking,
  varianceratios,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_blockcolumn_rownames_+3A_runmatrix">RunMatrix</code></td>
<td>
<p>The run matrix</p>
</td></tr>
<tr><td><code id="convert_blockcolumn_rownames_+3A_blocking">blocking</code></td>
<td>
<p>Whether random effects should be included.</p>
</td></tr>
<tr><td><code id="convert_blockcolumn_rownames_+3A_varianceratios">varianceratios</code></td>
<td>
<p>A vector of variance ratios for each level of restricted randomization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Row-name encoded blocked run matrix
</p>

<hr>
<h2 id='convert_model_dots'>Converts dot operator to terms</h2><span id='topic+convert_model_dots'></span>

<h3>Description</h3>

<p>Converts the dot operator '.' in a formula to the linear terms in the model. Includes interactions (e.g. .*.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_model_dots(design, model, splitplotdesign = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_model_dots_+3A_design">design</code></td>
<td>
<p>The design</p>
</td></tr>
<tr><td><code id="convert_model_dots_+3A_model">model</code></td>
<td>
<p>Base model</p>
</td></tr>
<tr><td><code id="convert_model_dots_+3A_splitplotdesign">splitplotdesign</code></td>
<td>
<p>split plot design data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New model with dot operator replaced
</p>

<hr>
<h2 id='convert_rownames_to_covariance'>Converts dot operator to terms</h2><span id='topic+convert_rownames_to_covariance'></span>

<h3>Description</h3>

<p>Converts the row names to a variance-covariance matrix (using the user-supplied variance ratio)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rownames_to_covariance(
  run_matrix_processed,
  varianceratios,
  user_specified_varianceratio
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_rownames_to_covariance_+3A_run_matrix_processed">run_matrix_processed</code></td>
<td>
<p>The design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance-covariance matrix V
</p>

<hr>
<h2 id='disallowed_combinations'>Detect and list disallowed combinations in candidate set</h2><span id='topic+disallowed_combinations'></span>

<h3>Description</h3>

<p>Detects and list disallowed combinations in candidate set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disallowed_combinations(candidateset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disallowed_combinations_+3A_candidateset">candidateset</code></td>
<td>
<p>Block list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the disallowed combinations
</p>

<hr>
<h2 id='effectpower'>Calculate Effect Power</h2><span id='topic+effectpower'></span>

<h3>Description</h3>

<p>Calculates the effect power given the anticipated coefficients and the type-I error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectpower(
  RunMatrix,
  levelvector,
  anticoef,
  alpha,
  vinv = NULL,
  degrees = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectpower_+3A_runmatrix">RunMatrix</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="effectpower_+3A_levelvector">levelvector</code></td>
<td>
<p>The number of levels in each parameter (1st is always the intercept)</p>
</td></tr>
<tr><td><code id="effectpower_+3A_anticoef">anticoef</code></td>
<td>
<p>The anticipated coefficients</p>
</td></tr>
<tr><td><code id="effectpower_+3A_alpha">alpha</code></td>
<td>
<p>the specified type-I error</p>
</td></tr>
<tr><td><code id="effectpower_+3A_vinv">vinv</code></td>
<td>
<p>The V inverse matrix</p>
</td></tr>
<tr><td><code id="effectpower_+3A_degrees">degrees</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The effect power for the parameters
</p>

<hr>
<h2 id='effectpowermc'>Fit Anova for Effect Power Calculation in Monte Carlo</h2><span id='topic+effectpowermc'></span>

<h3>Description</h3>

<p>Calculates the p-values for the effect power calculation in Monte Carlo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectpowermc(
  fit,
  type = "III",
  test = "Pr(&gt;Chisq)",
  model_formula = NULL,
  firth = FALSE,
  glmfamily = "gaussian",
  effect_terms = NULL,
  RunMatrixReduced = NULL,
  method = NULL,
  contrastslist = contrastslist,
  effect_anova = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectpowermc_+3A_fit">fit</code></td>
<td>
<p>Fit from regression</p>
</td></tr>
<tr><td><code id="effectpowermc_+3A_type">type</code></td>
<td>
<p>Default 'III'</p>
</td></tr>
<tr><td><code id="effectpowermc_+3A_test">test</code></td>
<td>
<p>Default 'Pr(&gt;Chisq)'.</p>
</td></tr>
<tr><td><code id="effectpowermc_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to car::Anova</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-values
</p>

<hr>
<h2 id='eval_design'>Calculate Power of an Experimental Design</h2><span id='topic+eval_design'></span>

<h3>Description</h3>

<p>Evaluates the power of an experimental design, for normal response variables,
given the design's run matrix and the statistical model to be fit to the data.
Returns a data frame of parameter and effect powers. Designs can
consist of both continuous and categorical factors. By default, <code>eval_design</code>
assumes a signal-to-noise ratio of 2, but this can be changed with the
<code>effectsize</code> or <code>anticoef</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_design(
  design,
  model = NULL,
  alpha = 0.05,
  blocking = NULL,
  anticoef = NULL,
  effectsize = 2,
  varianceratios = NULL,
  contrasts = contr.sum,
  conservative = FALSE,
  reorder_factors = FALSE,
  detailedoutput = FALSE,
  advancedoptions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_design_+3A_design">design</code></td>
<td>
<p>The experimental design. Internally, <code>eval_design</code> rescales each numeric column
to the range [-1, 1], so you do not need to do this scaling manually.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_model">model</code></td>
<td>
<p>The model used in evaluating the design. If this is missing and the design
was generated with skpr, the generating model will be used. It can be a subset of the model used to
generate the design, or include higher order effects not in the original design generation. It cannot include
factors that are not present in the experimental design.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_alpha">alpha</code></td>
<td>
<p>Default '0.05'. The specified type-I error.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_blocking">blocking</code></td>
<td>
<p>Default 'NULL'. If 'TRUE', <code>eval_design</code> will look at the rownames (or blocking columns) to determine blocking structure. Default FALSE.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_anticoef">anticoef</code></td>
<td>
<p>The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the <code>effectsize</code> argument.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_effectsize">effectsize</code></td>
<td>
<p>Default '2'. The signal-to-noise ratio. For continuous factors, this specifies the
difference in response between the highest and lowest levels of the factor (which are -1 and +1 after <code>eval_design</code>
normalizes the input data), assuming that the root mean square error is 1. If you do not specify <code>anticoef</code>,
the anticipated coefficients will be half of <code>effectsize</code>. If you do specify <code>anticoef</code>, <code>effectsize</code> will be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_varianceratios">varianceratios</code></td>
<td>
<p>Default 'NULL'. The ratio of the whole plot variance to the run-to-run variance.
If not specified during design generation, this will default to 1. For designs with more than one subplot
this ratio can be a vector specifying the variance ratio for each subplot (comparing to the run-to-run variance).
Otherwise, it will use a single value for all strata.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_contrasts">contrasts</code></td>
<td>
<p>Default <code>contr.sum</code>. The function to use to encode the categorical factors in the model matrix. If the user has specified their own contrasts
for a categorical factor using the contrasts function, those will be used. Otherwise, skpr will use 'contr.sum'.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_conservative">conservative</code></td>
<td>
<p>Specifies whether default method for generating
anticipated coefficents should be conservative or not. 'TRUE' will give the most conservative
estimate of power by setting all but one (or multiple if they are equally low) level in each categorical factor's anticipated coefficients
to zero. Default 'FALSE'.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_reorder_factors">reorder_factors</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the levels will be reordered to generate the most conservative calculation of effect power.
The function searches through all possible reference levels for a given factor and chooses the one that results in the lowest effect power.
The reordering will be presenting in the output when 'detailedoutput = TRUE'.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_detailedoutput">detailedoutput</code></td>
<td>
<p>If 'TRUE&ldquo;, return additional information about evaluation in results. Default FALSE.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_advancedoptions">advancedoptions</code></td>
<td>
<p>Default 'NULL'. A named list with parameters to specify additional attributes to calculate. Options: 'aliaspower'
gives the degree at which the Alias matrix should be calculated.</p>
</td></tr>
<tr><td><code id="eval_design_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the power of experimental designs.
</p>
<p>If the design is has no blocking or restrictions on randomization, the model assumed is:
</p>
<p><code class="reqn">y = X \beta + \epsilon</code>.
</p>
<p>If the design is a split-plot design, the model is as follows:
</p>
<p><code class="reqn">y = X \beta + Z b</code><sub>i</sub> + <code class="reqn">\epsilon</code><sub>ij</sub>,
</p>
<p>Here, <code class="reqn">y</code> is the vector of experimental responses, <code class="reqn">X</code> is the model matrix, <code class="reqn">\beta</code> is
the vector of model coefficients, <code class="reqn">Z_{i}</code> are the blocking indicator,
<code class="reqn">b_{i}</code> is the random variable associated with the <code class="reqn">i</code>th block, and <code class="reqn">\epsilon</code>
is a random variable normally distributed with zero mean and unit variance (root-mean-square error is 1.0).
</p>
<p><code>eval_design</code> calculates both parameter power as well as effect power, defined as follows:
</p>
<p>1) Parameter power is the probability of rejecting the hypothesis <code class="reqn">H_0 : \beta_i = 0</code>, where <code class="reqn">\beta_i</code> is a single parameter
in the model
2) Effect power is the probability of rejecting the hypothesis <code class="reqn">H_0 : \beta_{1} = \beta_{2} = ... = \beta_{n} 0</code> for all <code class="reqn">n</code> coefficients
for a categorical factor.
</p>
<p>The two power types are equivalent for continuous factors and two-level categorical factors,
but they will differ for categorical factors with three or more levels.
</p>
<p>For split-plot designs, the degrees of freedom are allocated to each term according to the algorithm
given in &quot;Mixed-Effects Models in S and S-PLUS&quot; (Pinheiro and Bates, pp. 91).
</p>
<p>When using <code>conservative = TRUE</code>, <code>eval_design</code> first evaluates the power with the default (or given) coefficients. Then,
for each multi-level categorical, it sets all coefficients to zero except the level that produced the lowest power,
and then re-evaluates the power with this modified set of anticipated coefficients. If there are two or more
equal power values in a multi-level categorical, two of the lowest equal terms are given opposite sign anticipated coefficients
and the rest (for that categorical factor) are set to zero.
</p>


<h3>Value</h3>

<p>A data frame with the parameters of the model, the type of power analysis, and the power. Several
design diagnostics are stored as attributes of the data frame. In particular,
the <code>modelmatrix</code> attribute contains the model matrix that was used for power evaluation. This is
especially useful if you want to specify the anticipated coefficients to use for power evaluation. The model
matrix provides the order of the model coefficients, as well as the
encoding used for categorical factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generating a simple 2x3 factorial to feed into our optimal design generation
#of an 11-run design.
factorial = expand.grid(A = c(1, -1), B = c(1, -1), C = c(1, -1))

optdesign = gen_design(candidateset = factorial,
                      model= ~A + B + C, trials = 11, optimality = "D", repeats = 100)

#Now evaluating that design (with default anticipated coefficients and a effectsize of 2):
eval_design(design = optdesign, model= ~A + B + C, alpha = 0.2)

#Evaluating a subset of the design (which changes the power due to a different number of
#degrees of freedom)
eval_design(design = optdesign, model= ~A + C, alpha = 0.2)

#We do not have to input the model if it's the same as the model used
#During design generation. Here, we also use the default value for alpha (`0.05`)
eval_design(optdesign)

#Halving the signal-to-noise ratio by setting a different effectsize (default is 2):
eval_design(design = optdesign, model= ~A + B + C, alpha = 0.2, effectsize = 1)

#With 3+ level categorical factors, the choice of anticipated coefficients directly changes the
#final power calculation. For the most conservative power calculation, that involves
#setting all anticipated coefficients in a factor to zero except for one. We can specify this
#option with the "conservative" argument.

factorialcoffee = expand.grid(cost = c(1, 2),
                              type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                              size = as.factor(c("Short", "Grande", "Venti")))

designcoffee = gen_design(factorialcoffee,
                         ~cost + size + type, trials = 29, optimality = "D", repeats = 100)

#Evaluate the design, with default anticipated coefficients (conservative is FALSE by default).
eval_design(designcoffee)

#Evaluate the design, with conservative anticipated coefficients:
eval_design(designcoffee, conservative = TRUE)

#which is the same as the following, but now explicitly entering the coefficients:
eval_design(designcoffee, anticoef = c(1, 1, 1, 0, 0, 1, 0))

#You can also evaluate the design with higher order effects, even if they were not
#used in design generation:
eval_design(designcoffee, model = ~cost + size + type + cost * type)


#Generating and evaluating a split plot design:
splitfactorialcoffee = expand.grid(caffeine = c(1, -1),
                                  cost = c(1, 2),
                                  type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                                  size = as.factor(c("Short", "Grande", "Venti")))

coffeeblockdesign = gen_design(splitfactorialcoffee, ~caffeine, trials = 12)
coffeefinaldesign = gen_design(splitfactorialcoffee,
                              model = ~caffeine + cost + size + type, trials = 36,
                              splitplotdesign = coffeeblockdesign, blocksizes = 3)

#Evaluating design (blocking is automatically detected)
eval_design(coffeefinaldesign, 0.2, blocking = TRUE)

#Manually turn blocking off to see completely randomized design power
eval_design(coffeefinaldesign, 0.2, blocking = FALSE)

#We can also evaluate the design with a custom ratio between the whole plot error to
#the run-to-run error.
eval_design(coffeefinaldesign, 0.2, varianceratios = 2)

#If the design was generated outside of skpr and thus the row names do not have the
#blocking structure encoded already, the user can add these manually. For a 12-run
#design with 4 blocks, here is a vector indicated the blocks:

blockcolumn = c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4)

#If we wanted to add this blocking structure to the design coffeeblockdesign, we would
#add a column with the format "Block1", "Block2", "Block3" ... and each one will be treated
#as a separate blocking layer.

coffeeblockdesign$Block1 = blockcolumn

#By default, skpr will throw out the blocking columns unless the user specifies `blocking = TRUE`.
eval_design(coffeeblockdesign, blocking=TRUE)
</code></pre>

<hr>
<h2 id='eval_design_custom_mc'>Monte Carlo power evaluation for experimental designs with user-supplied libraries</h2><span id='topic+eval_design_custom_mc'></span>

<h3>Description</h3>

<p>Evaluates the power of an experimental design, given its run matrix and the
statistical model to be fit to the data, using monte carlo simulation. Simulated data is fit using a
user-supplied fitting library and power is estimated by the fraction of times a parameter is significant. Returns
a data frame of parameter powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_design_custom_mc(
  design,
  model = NULL,
  alpha = 0.05,
  nsim,
  rfunction,
  fitfunction,
  pvalfunction,
  anticoef,
  effectsize = 2,
  contrasts = contr.sum,
  coef_function = coef,
  calceffect = FALSE,
  detailedoutput = FALSE,
  parameternames = NULL,
  advancedoptions = NULL,
  progress = TRUE,
  parallel = FALSE,
  parallel_pkgs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_design_custom_mc_+3A_design">design</code></td>
<td>
<p>The experimental design. Internally, <code>eval_design_custom_mc</code> rescales each numeric column
to the range [-1, 1].</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_model">model</code></td>
<td>
<p>The model used in evaluating the design. If this is missing and the design
was generated with skpr, the generating model will be used. It can be a subset of the model used to
generate the design, or include higher order effects not in the original design generation. It cannot include
factors that are not present in the experimental design.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_alpha">alpha</code></td>
<td>
<p>Default '0.05'. The type-I error. p-values less than this will be counted as significant.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_rfunction">rfunction</code></td>
<td>
<p>Random number generator function. Should be a function of the form f(X, b), where X is the
model matrix and b are the anticipated coefficients.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_fitfunction">fitfunction</code></td>
<td>
<p>Function used to fit the data. Should be of the form f(formula, X, contrasts)
where X is the model matrix. If contrasts do not need to be specified for the user supplied
library, that argument can be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_pvalfunction">pvalfunction</code></td>
<td>
<p>Function that returns a vector of p-values from the object returned from the fitfunction.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_anticoef">anticoef</code></td>
<td>
<p>The anticipated coefficients for calculating the power. If missing, coefficients will be
automatically generated based on <code>effectsize</code>.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_effectsize">effectsize</code></td>
<td>
<p>The signal-to-noise ratio. Default 2. For a gaussian model, and for
continuous factors, this specifies the difference in response between the highest
and lowest levels of a factor (which are +1 and -1 after normalization).
More precisely: If you do not specify <code>anticoef</code>, the anticipated coefficients will be
half of <code>effectsize</code>. If you do specify <code>anticoef</code>, <code>effectsize</code> will be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_contrasts">contrasts</code></td>
<td>
<p>Default <code>contr.sum</code>. Function used to generate the contrasts encoding for categorical variables. If the user has specified their own contrasts
for a categorical factor using the contrasts function, those will be used. Otherwise, skpr will use contr.sum.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_coef_function">coef_function</code></td>
<td>
<p>Function that, when applied to a fitfunction return object, returns the estimated coefficients.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_calceffect">calceffect</code></td>
<td>
<p>Default 'FALSE'. Calculates effect power for a Type-III Anova (using the car package) using a Wald test.
this ratio can be a vector specifying the variance ratio for each subplot. Otherwise, it will use a single value for all strata. To work, the
fit returned by 'fitfunction' must have a method compatable with the car package.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_detailedoutput">detailedoutput</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', return additional information about evaluation in results.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_parameternames">parameternames</code></td>
<td>
<p>Vector of parameter names if the coefficients do not correspond simply to the columns in the model matrix
(e.g. coefficients from an MLE fit).</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_advancedoptions">advancedoptions</code></td>
<td>
<p>Default 'NULL'. Named list of advanced options. 'advancedoptions$anovatype' specifies the Anova type in the car package (default type 'III'),
user can change to type 'II'). 'advancedoptions$anovatest' specifies the test statistic if the user does not want a 'Wald' test&ndash;other options are likelyhood-ratio 'LR' and F-test 'F'.
'advancedoptions$progressBarUpdater' is a function called in non-parallel simulations that can be used to update external progress bar.'advancedoptions$GUI' turns off some warning messages when in the GUI.
If 'advancedoptions$save_simulated_responses = TRUE', the dataframe will have an attribute 'simulated_responses' that contains the simulated responses from the power evaluation. 'advancedoptions$ci_error_conf' will
set the confidence level for power intervals, which are printed when 'detailedoutput = TRUE'.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to include a progress bar.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the power simulation will use all but one of the available cores.
If the user wants to set the number of cores manually, they can do this by setting 'options(&quot;cores&quot;)' to the desired number (e.g. 'options(&quot;cores&quot; = parallel::detectCores())').
NOTE: If you have installed BLAS libraries that include multicore support (e.g. Intel MKL that comes with Microsoft R Open), turning on parallel could result in reduced performance.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_parallel_pkgs">parallel_pkgs</code></td>
<td>
<p>A vector of strings listing the external packages to be included in each parallel worker.</p>
</td></tr>
<tr><td><code id="eval_design_custom_mc_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of the parameters and their powers. The parameter estimates from the simulations are
stored in the 'estimates' attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#To demonstrate how a user can use their own libraries for Monte Carlo power generation,
#We will recreate eval_design_survival_mc using the eval_design_custom_mc framework.

#To begin, first let us generate the same design and random generation function shown in the
#eval_design_survival_mc examples:

basicdesign = expand.grid(a = c(-1, 1), b = c("a","b","c"))
design = gen_design(candidateset = basicdesign, model = ~a + b + a:b, trials = 100,
                         optimality = "D", repeats = 100)

#Random number generating function

rsurvival = function(X, b) {
 Y = rexp(n = nrow(X), rate = exp(-(X %*% b)))
 censored = Y &gt; 1
 Y[censored] = 1
 return(survival::Surv(time = Y, event = !censored, type = "right"))
}

#We now need to tell the package how we want to fit our data,
#given the formula and the model matrix X (and, if needed, the list of contrasts).
#If the contrasts aren't required, "contrastslist" should be set to NULL.
#This should return some type of fit object.

fitsurv = function(formula, X, contrastslist = NULL) {
 return(survival::survreg(formula, data = X, dist = "exponential"))
}


#We now need to tell the package how to extract the p-values from the fit object returned
#from the fit function. This is how to extract the p-values from the survreg fit object:

pvalsurv = function(fit) {
 return(summary(fit)$table[, 4])
}

#And now we evaluate the design, passing the fitting function and p-value extracting function
#in along with the standard inputs for eval_design_mc.
#This has the exact same behavior as eval_design_survival_mc for the exponential distribution.
eval_design_custom_mc(design = design, model = ~a + b + a:b,
                     alpha = 0.05, nsim = 100,
                     fitfunction = fitsurv, pvalfunction = pvalsurv,
                     rfunction = rsurvival, effectsize = 1)
#We can also use skpr's framework for parallel computation to automatically parallelize this
#to speed up computation
## Not run: eval_design_custom_mc(design = design, model = ~a + b + a:b,
                         alpha = 0.05, nsim = 1000,
                         fitfunction = fitsurv, pvalfunction = pvalsurv,
                         rfunction = rsurvival, effectsize = 1,
                         parallel = TRUE, parallel_pkgs = "survival")

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_design_mc'>Monte Carlo Power Evaluation for Experimental Designs</h2><span id='topic+eval_design_mc'></span>

<h3>Description</h3>

<p>Evaluates the power of an experimental design, given the run matrix and the
statistical model to be fit to the data, using monte carlo simulation. Simulated data is fit using a
generalized linear model
and power is estimated by the fraction of times a parameter is significant.
Returns a data frame of parameter powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_design_mc(
  design,
  model = NULL,
  alpha = 0.05,
  blocking = NULL,
  nsim = 1000,
  glmfamily = "gaussian",
  calceffect = TRUE,
  effect_anova = TRUE,
  varianceratios = NULL,
  rfunction = NULL,
  anticoef = NULL,
  firth = FALSE,
  effectsize = 2,
  contrasts = contr.sum,
  parallel = FALSE,
  adjust_alpha_inflation = FALSE,
  detailedoutput = FALSE,
  progress = TRUE,
  advancedoptions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_design_mc_+3A_design">design</code></td>
<td>
<p>The experimental design. Internally, <code>eval_design_mc</code> rescales each numeric column
to the range [-1, 1].</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_model">model</code></td>
<td>
<p>The model used in evaluating the design. If this is missing and the design
was generated with skpr, the generating model will be used. It can be a subset of the model used to
generate the design, or include higher order effects not in the original design generation. It cannot include
factors that are not present in the experimental design.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_alpha">alpha</code></td>
<td>
<p>Default '0.05'. The type-I error. p-values less than this will be counted as significant.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_blocking">blocking</code></td>
<td>
<p>Default 'NULL'. If 'TRUE', <code>eval_design_mc</code> will look at the rownames (or blocking columns) to determine blocking structure. Default FALSE.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_nsim">nsim</code></td>
<td>
<p>Default '1000'. The number of Monte Carlo simulations to perform.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_glmfamily">glmfamily</code></td>
<td>
<p>Default 'gaussian'. String indicating the family of distribution for the 'glm' function
(&quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;, or &quot;exponential&quot;).</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_calceffect">calceffect</code></td>
<td>
<p>Default 'TRUE'. Whether to calculate effect power. This calculation is more expensive than parameter power,
so turned off (if not needed) can greatly speed up calculation time.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_effect_anova">effect_anova</code></td>
<td>
<p>Default 'TRUE', whether to a Type-III Anova or a likelihood ratio test to calculate effect power.
If 'TRUE', effect power will be calculated using a Type-III Anova (using the car package) and a Wald test. If 'FALSE',
a likelihood ratio test (using a reduced model for each effect) will performed using the 'lmtest' package. If 'firth = TRUE',
this will be set to 'FALSE' automatically.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_varianceratios">varianceratios</code></td>
<td>
<p>Default 'NULL'. The ratio of the whole plot variance to the run-to-run variance.
If not specified during design generation, this will default to 1. For designs with more than one subplot
this ratio can be a vector specifying the variance ratio for each subplot (comparing to the run-to-run variance).
Otherwise, it will use a single value for all strata.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_rfunction">rfunction</code></td>
<td>
<p>Default 'NULL'.Random number generator function for the response variable. Should be a function of the form f(X, b, delta), where X is the
model matrix, b are the anticipated coefficients, and delta is a vector of blocking errors. Typically something like rnorm(nrow(X), X * b + delta, 1).
You only need to specify this if you do not like the default behavior described below.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_anticoef">anticoef</code></td>
<td>
<p>Default 'NULL'.The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the <code>effectsize</code> argument.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_firth">firth</code></td>
<td>
<p>Default 'FALSE'. Whether to apply the firth correction (via the 'mbest' package) to a logistic regression. This
setting also automatically sets 'effect_lr = TRUE'.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_effectsize">effectsize</code></td>
<td>
<p>Helper argument to generate anticipated coefficients. See details for more info.
If you specify <code>anticoef</code>, <code>effectsize</code> will be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_contrasts">contrasts</code></td>
<td>
<p>Default <code>contr.sum</code>. The contrasts to use for categorical factors. If the user has specified their own contrasts
for a categorical factor using the contrasts function, those will be used. Otherwise, skpr will use contr.sum.
If the user wants to set the number of cores manually, they can do this by setting 'options(&quot;cores&quot;)' to the desired number (e.g. 'options(&quot;cores&quot; = parallel::detectCores())').
NOTE: If you have installed BLAS libraries that include multicore support (e.g. Intel MKL that comes with Microsoft R Open), turning on parallel could result in reduced performance.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the Monte Carlo power calculation will use all but one of the available cores. If the user wants to set the number of cores manually, they can do this by setting 'options(&quot;cores&quot;)' to the desired number (e.g. 'options(&quot;cores&quot; = parallel::detectCores())').
NOTE: If you have installed BLAS libraries that include multicore support (e.g. Intel MKL that comes with Microsoft R Open), turning on parallel could result in reduced performance.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_adjust_alpha_inflation">adjust_alpha_inflation</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will run the simulation twice:
first to calculate the empirical distribution of p-values under the null hypothesis and find
the true Type-I error cutoff that corresponds to the desired Type-I error rate,
and then again given effect size to calculate power values.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_detailedoutput">detailedoutput</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', return additional information about evaluation in results.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to include a progress bar.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_advancedoptions">advancedoptions</code></td>
<td>
<p>Default 'NULL'. Named list of advanced options. 'advancedoptions$anovatype' specifies the Anova type in the car package (default type 'III'),
user can change to type 'II'). 'advancedoptions$anovatest' specifies the test statistic if the user does not want a 'Wald' test&ndash;other options are likelyhood-ratio 'LR' and F-test 'F'.
'advancedoptions$progressBarUpdater' is a function called in non-parallel simulations that can be used to update external progress bar.'advancedoptions$GUI' turns off some warning messages when in the GUI.
If 'advancedoptions$save_simulated_responses = TRUE', the dataframe will have an attribute 'simulated_responses' that contains the simulated responses from the power evaluation. 'advancedoptions$ci_error_conf' will
set the confidence level for power intervals, which are printed when 'detailedoutput = TRUE'.</p>
</td></tr>
<tr><td><code id="eval_design_mc_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the power of a design with Monte Carlo simulation. Data is simulated and then fit
with a generalized linear model, and the fraction of simulations in which a parameter
is significant (its p-value, according to the fit function used, is less than the specified <code>alpha</code>)
is the estimate of power for that parameter.
</p>
<p>First, if <code>blocking = TURE</code>, the random noise from blocking is generated with <code>rnorm</code>.
Each block gets a single sample of Gaussian random noise, with a variance as specified in
<code>varianceratios</code>,
and that sample is copied to each run in the block. Then, <code>rfunction</code> is called to generate a simulated
response for each run of the design, and the data is fit using the appropriate fitting function.
The functions used to simulate the data and fit it are determined by the <code>glmfamily</code>
and <code>blocking</code> arguments
as follows. Below, X is the model matrix, b is the anticipated coefficients, and d
is a vector of blocking noise (if <code>blocking = FALSE</code> then d = 0):
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>glmfamily</b>      </td><td style="text-align: left;"> <b>blocking</b> </td><td style="text-align: right;"> <b>rfunction</b> </td><td style="text-align: right;"> <b>fit</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
"gaussian"     </td><td style="text-align: left;"> F        </td><td style="text-align: right;"> <code>rnorm(mean = X %*% b + d, sd = 1)</code>        </td><td style="text-align: right;"> <code>lm</code>         </td>
</tr>
<tr>
 <td style="text-align: left;">
"gaussian"     </td><td style="text-align: left;"> T        </td><td style="text-align: right;"> <code>rnorm(mean = X %*% b + d, sd = 1)</code>        </td><td style="text-align: right;"> <code>lme4::lmer</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
"binomial"     </td><td style="text-align: left;"> F        </td><td style="text-align: right;"> <code>rbinom(prob = 1/(1+exp(-(X %*% b + d))))</code> </td><td style="text-align: right;"> <code>glm(family = "binomial")</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
"binomial"     </td><td style="text-align: left;"> T        </td><td style="text-align: right;"> <code>rbinom(prob = 1/(1+exp(-(X %*% b + d))))</code> </td><td style="text-align: right;"> <code>lme4::glmer(family = "binomial")</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
"poisson"      </td><td style="text-align: left;"> F        </td><td style="text-align: right;"> <code>rpois(lambda = exp((X %*% b + d)))</code>       </td><td style="text-align: right;"> <code>glm(family = "poisson")</code>         </td>
</tr>
<tr>
 <td style="text-align: left;">
"poisson"      </td><td style="text-align: left;"> T        </td><td style="text-align: right;"> <code>rpois(lambda = exp((X %*% b + d)))</code>       </td><td style="text-align: right;"> <code>lme4::glmer(family = "poisson")</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
"exponential"  </td><td style="text-align: left;"> F        </td><td style="text-align: right;"> <code>rexp(rate = exp(-(X %*% b + d)))</code>            </td><td style="text-align: right;"> <code>glm(family = Gamma(link = "log"))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
"exponential"  </td><td style="text-align: left;"> T        </td><td style="text-align: right;"> <code>rexp(rate = exp(-(X %*% b + d)))</code>            </td><td style="text-align: right;"> <code>lme4:glmer(family = Gamma(link = "log"))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that the exponential random generator uses the &quot;rate&quot; parameter, but <code>skpr</code> and <code>glm</code> use
the mean value parameterization (= 1 / rate), hence the minus sign above. Also note that
the gaussian model assumes a root-mean-square error of 1.
</p>
<p>Power is dependent on the anticipated coefficients. You can specify those directly with the <code>anticoef</code>
argument, or you can use the <code>effectsize</code> argument to specify an effect size and <code>skpr</code> will auto-generate them.
You can provide either a length-1 or length-2 vector. If you provide a length-1 vector, the anticipated
coefficients will be half of <code>effectsize</code>; this is equivalent to saying that the <em>linear predictor</em>
(for a gaussian model, the mean response; for a binomial model, the log odds ratio; for an exponential model,
the log of the mean value; for a poisson model, the log of the expected response)
changes by <code>effectsize</code> when a continuous factor goes from its lowest level to its highest level. If you provide a
length-2 vector, the anticipated coefficients will be set such that the <em>mean response</em> (for
a gaussian model, the mean response; for a binomial model, the probability; for an exponential model, the mean
response; for a poisson model, the expected response) changes from
<code>effectsize[1]</code> to <code>effectsize[2]</code> when a factor goes from its lowest level to its highest level, assuming
that the other factors are inactive (their x-values are zero).
</p>
<p>The effect of a length-2 <code>effectsize</code> depends on the <code>glmfamily</code> argument as follows:
</p>
<p>For <code>glmfamily = 'gaussian'</code>, the coefficients are set to <code>(effectsize[2] - effectsize[1]) / 2</code>.
</p>
<p>For <code>glmfamily = 'binomial'</code>, the intercept will be
<code>1/2 * log(effectsize[1] * effectsize[2] / (1 - effectsize[1]) / (1 - effectsize[2]))</code>,
and the other coefficients will be
<code>1/2 * log(effectsize[2] * (1 - effectsize[1]) / (1 - effectsize[2]) / effectsize[1])</code>.
</p>
<p>For <code>glmfamily = 'exponential'</code> or <code>'poisson'</code>,
the intercept will be
<code>1 / 2 * (log(effectsize[2]) + log(effectsize[1]))</code>,
and the other coefficients will be
<code>1 / 2 * (log(effectsize[2]) - log(effectsize[1]))</code>.
</p>


<h3>Value</h3>

<p>A data frame consisting of the parameters and their powers, with supplementary information
stored in the data frame's attributes. The parameter estimates from the simulations are stored in the &quot;estimates&quot;
attribute. The &quot;modelmatrix&quot; attribute contains the model matrix that was used for power evaluation, and
also provides the encoding used for categorical factors. If you want to specify the anticipated
coefficients manually, do so in the order the parameters appear in the model matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We first generate a full factorial design using expand.grid:
factorialcoffee = expand.grid(cost = c(-1, 1),
                              type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                              size = as.factor(c("Short", "Grande", "Venti")))
if(skpr:::run_documentation()) {
#And then generate the 21-run D-optimal design using gen_design.
designcoffee = gen_design(factorialcoffee,
                         model = ~cost + type + size, trials = 21, optimality = "D")
}
if(skpr:::run_documentation()) {
#To evaluate this design using a normal approximation, we just use eval_design
#(here using the default settings for contrasts, effectsize, and the anticipated coefficients):

eval_design(design = designcoffee, model = ~cost + type + size, 0.05)
}
if(skpr:::run_documentation()) {
#To evaluate this design with a Monte Carlo method, we enter the same information
#used in eval_design, with the addition of the number of simulations "nsim" and the distribution
#family used in fitting for the glm "glmfamily". For gaussian, binomial, exponential, and poisson
#families, a default random generating function (rfunction) will be supplied. If another glm
#family is used or the default random generating function is not adequate, a custom generating
#function can be supplied by the user. Like in `eval_design()`, if the model isn't entered, the
#model used in generating the design will be used.

eval_design_mc(designcoffee, nsim = 100, glmfamily = "gaussian")
}
if(skpr:::run_documentation()) {
#We can also add error bars on the Monte Carlo power values by setting
#`detailedoutput = TRUE` (which will print out other information as well).
#We can set the confidence via the `advancedoptions` argument.
eval_design_mc(designcoffee, nsim = 100, glmfamily = "gaussian",
              detailedoutput = TRUE, advancedoptions = list(ci_error_conf  = 0.8))
}
if(skpr:::run_documentation()) {
#We see here we generate approximately the same parameter powers as we do
#using the normal approximation in eval_design. Like eval_design, we can also change
#effectsize to produce a different signal-to-noise ratio:

eval_design_mc(design = designcoffee, nsim = 100,
                       glmfamily = "gaussian", effectsize = 1)
}
if(skpr:::run_documentation()) {
#Like eval_design, we can also evaluate the design with a different model than
#the one that generated the design.
eval_design_mc(design = designcoffee, model = ~cost + type, alpha = 0.05,
              nsim = 100, glmfamily = "gaussian")
}
if(skpr:::run_documentation()) {
#And here it is evaluated with additional interactions included:
eval_design_mc(design = designcoffee, model = ~cost + type + size + cost * type, 0.05,
              nsim = 100, glmfamily = "gaussian")
}
if(skpr:::run_documentation()) {
#We can also set "parallel = TRUE" to use all the cores available to speed up
#computation.
eval_design_mc(design = designcoffee, nsim = 10000,
                       glmfamily = "gaussian", parallel = TRUE)
}
if(skpr:::run_documentation()) {
#We can also evaluate split-plot designs. First, let us generate the split-plot design:

factorialcoffee2 = expand.grid(Temp = c(1, -1),
                               Store = as.factor(c("A", "B")),
                               cost = c(-1, 1),
                               type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                               size = as.factor(c("Short", "Grande", "Venti")))

vhtcdesign = gen_design(factorialcoffee2,
                       model = ~Store, trials = 6, varianceratio = 1)
htcdesign = gen_design(factorialcoffee2, model = ~Store + Temp, trials = 18,
                       splitplotdesign = vhtcdesign, blocksizes = rep(3, 6), varianceratio = 1)
splitplotdesign = gen_design(factorialcoffee2,
                            model = ~Store + Temp + cost + type + size, trials = 54,
                            splitplotdesign = htcdesign, blocksizes = rep(3, 18),
                            varianceratio = 1)

#Each block has an additional noise term associated with it in addition to the normal error
#term in the model. This is specified by a vector specifying the additional variance for
#each split-plot level. This is equivalent to specifying a variance ratio of one between
#the whole plots and the run-to-run variance for gaussian models.

#Evaluate the design. Note the decreased power for the blocking factors.
eval_design_mc(splitplotdesign, blocking = TRUE, nsim = 100,
                       glmfamily = "gaussian", varianceratios = c(1, 1, 1))
}
if(skpr:::run_documentation()) {
#We can also use this method to evaluate designs that cannot be easily
#evaluated using normal approximations. Here, we evaluate a design with a binomial response and see
#whether we can detect the difference between each factor changing whether an event occurs
#70% of the time or 90% of the time.

factorialbinom = expand.grid(a = c(-1, 1), b = c(-1, 1))
designbinom = gen_design(factorialbinom, model = ~a + b, trials = 90, optimality = "D")

eval_design_mc(designbinom, ~a + b, alpha = 0.2, nsim = 100, effectsize = c(0.7, 0.9),
              glmfamily = "binomial")
}
if(skpr:::run_documentation()) {
#We can also use this method to determine power for poisson response variables.
#Generate the design:

factorialpois = expand.grid(a = as.numeric(c(-1, 0, 1)), b = c(-1, 0, 1))
designpois = gen_design(factorialpois, ~a + b, trials = 70, optimality = "D")

#Evaluate the power:

eval_design_mc(designpois, ~a + b, 0.05, nsim = 100, glmfamily = "poisson",
               anticoef = log(c(0.2, 2, 2)))
}

#The coefficients above set the nominal value -- that is, the expected count
#when all inputs = 0 -- to 0.2 (from the intercept), and say that each factor
#changes this count by a factor of 4 (multiplied by 2 when x= +1, and divided by 2 when x = -1).
#Note the use of log() in the anticipated coefficients.
</code></pre>

<hr>
<h2 id='eval_design_survival_mc'>Evaluate Power for Survival Design</h2><span id='topic+eval_design_survival_mc'></span>

<h3>Description</h3>

<p>Evaluates power for an experimental design in which the response variable may be
right- or left-censored. Power is evaluated with a Monte Carlo simulation,
using the <code>survival</code> package and <code>survreg</code> to fit the data. Split-plot designs are not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_design_survival_mc(
  design,
  model = NULL,
  alpha = 0.05,
  nsim = 1000,
  distribution = "gaussian",
  censorpoint = NA,
  censortype = "right",
  rfunctionsurv = NULL,
  anticoef = NULL,
  effectsize = 2,
  contrasts = contr.sum,
  parallel = FALSE,
  detailedoutput = FALSE,
  progress = TRUE,
  advancedoptions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_design_survival_mc_+3A_design">design</code></td>
<td>
<p>The experimental design. Internally, all numeric columns will be rescaled to [-1, +1].</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_model">model</code></td>
<td>
<p>The model used in evaluating the design. If this is missing and the design
was generated with skpr, the generating model will be used. It can be a subset of the model used to
generate the design, or include higher order effects not in the original design generation. It cannot include
factors that are not present in the experimental design.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_alpha">alpha</code></td>
<td>
<p>Default '0.05'. The type-I error. p-values less than this will be counted as significant.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations. Default 1000.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_distribution">distribution</code></td>
<td>
<p>Distribution of survival function to use when fitting the data. Valid choices are described
in the documentation for <code>survreg</code>. <em>Supported</em> options are
&quot;exponential&quot;, &quot;lognormal&quot;, or &quot;gaussian&quot;. Default &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_censorpoint">censorpoint</code></td>
<td>
<p>The point after/before (for right-censored or left-censored data, respectively)
which data should be labelled as censored. Default NA for no censoring. This argument is
used only by the internal random number generators; if you supply your own function to
the <code>rfunctionsurv</code> parameter, then this parameter will be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_censortype">censortype</code></td>
<td>
<p>The type of censoring (either &quot;left&quot; or &quot;right&quot;). Default &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_rfunctionsurv">rfunctionsurv</code></td>
<td>
<p>Random number generator function. Should be a function of the form f(X, b), where X is the
model matrix and b are the anticipated coefficients. This function should return a <code>Surv</code> object from
the <code>survival</code> package. You do not need to provide this argument if <code>distribution</code> is one of
the supported choices and you are satisfied with the default behavior described below.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_anticoef">anticoef</code></td>
<td>
<p>The anticipated coefficients for calculating the power. If missing, coefficients
will be automatically generated based on the <code>effectsize</code> argument.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_effectsize">effectsize</code></td>
<td>
<p>Helper argument to generate anticipated coefficients. See details for more info.
If you specify <code>anticoef</code>, <code>effectsize</code> will be ignored.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_contrasts">contrasts</code></td>
<td>
<p>Default <code>contr.sum</code>. Function used to encode categorical variables in the model matrix. If the user has specified their own contrasts
for a categorical factor using the contrasts function, those will be used. Otherwise, skpr will use contr.sum.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the power simulation will use all but one of the available cores.
If the user wants to set the number of cores manually, they can do this by setting 'options(&quot;cores&quot;)' to the desired number (e.g. 'options(&quot;cores&quot; = parallel::detectCores())').
NOTE: If you have installed BLAS libraries that include multicore support (e.g. Intel MKL that comes with Microsoft R Open), turning on parallel could result in reduced performance.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_detailedoutput">detailedoutput</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', return additional information about evaluation in results.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to include a progress bar.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_advancedoptions">advancedoptions</code></td>
<td>
<p>Default 'NULL'. Named list of advanced options. Pass 'progressBarUpdater' to include function called in non-parallel simulations that can be used to update external progress bar.
'advancedoptions$ci_error_conf' will set the confidence level for power intervals, which are printed when 'detailedoutput = TRUE'.</p>
</td></tr>
<tr><td><code id="eval_design_survival_mc_+3A_...">...</code></td>
<td>
<p>Any additional arguments to be passed into the <code>survreg</code> function during fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the power of a design with Monte Carlo simulation. Data is simulated and then fit
with a survival model (<code>survival::survreg</code>), and the fraction of simulations in which a parameter
is significant
(its p-value is less than the specified <code>alpha</code>)
is the estimate of power for that parameter.
</p>
<p>If not supplied by the user, <code>rfunctionsurv</code> will be generated based on the <code>distribution</code>
argument as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>distribution</b>  </td><td style="text-align: right;"> <b>generating function</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
"gaussian"                  </td><td style="text-align: right;"> <code>rnorm(mean = X %*% b, sd = 1)</code>           </td>
</tr>
<tr>
 <td style="text-align: left;">
"exponential"               </td><td style="text-align: right;"> <code>rexp(rate = exp(-X %*% b))</code>           </td>
</tr>
<tr>
 <td style="text-align: left;">
"lognormal"                 </td><td style="text-align: right;"> <code>rlnorm(meanlog = X %*% b, sdlog = 1)</code>           </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In each case, if a simulated data point is past the censorpoint (greater than for right-censored, less than for
left-censored) it is marked as censored. See the examples below for how to construct your own function.
</p>
<p>Power is dependent on the anticipated coefficients. You can specify those directly with the <code>anticoef</code>
argument, or you can use the <code>effectsize</code> argument to specify an effect size and <code>skpr</code> will auto-generate them.
You can provide either a length-1 or length-2 vector. If you provide a length-1 vector, the anticipated
coefficients will be half of <code>effectsize</code>; this is equivalent to saying that the <em>linear predictor</em>
(for a gaussian model, the mean response; for an exponential model or lognormal model,
the log of the mean value)
changes by <code>effectsize</code> when a continuous factor goes from its lowest level to its highest level. If you provide a
length-2 vector, the anticipated coefficients will be set such that the <em>mean response</em> changes from
<code>effectsize[1]</code> to <code>effectsize[2]</code> when a factor goes from its lowest level to its highest level, assuming
that the other factors are inactive (their x-values are zero).
</p>
<p>The effect of a length-2 <code>effectsize</code> depends on the <code>distribution</code> argument as follows:
</p>
<p>For <code>distribution = 'gaussian'</code>, the coefficients are set to <code>(effectsize[2] - effectsize[1]) / 2</code>.
</p>
<p>For <code>distribution = 'exponential'</code> or <code>'lognormal'</code>,
the intercept will be
<code>1 / 2 * (log(effectsize[2]) + log(effectsize[1]))</code>,
and the other coefficients will be
<code>1 / 2 * (log(effectsize[2]) - log(effectsize[1]))</code>.
</p>


<h3>Value</h3>

<p>A data frame consisting of the parameters and their powers. The parameter estimates from the simulations are
stored in the 'estimates' attribute. The 'modelmatrix' attribute contains the model matrix and the encoding used for
categorical factors. If you manually specify anticipated coefficients, do so in the order of the model matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#These examples focus on the survival analysis case and assume familiarity
#with the basic functionality of eval_design_mc.

#We first generate a simple 2-level design using expand.grid:
basicdesign = expand.grid(a = c(-1, 1))
design = gen_design(candidateset = basicdesign, model = ~a, trials = 15)

#We can then evaluate the power of the design in the same way as eval_design_mc,
#now including the type of censoring (either right or left) and the point at which
#the data should be censored:

eval_design_survival_mc(design = design, model = ~a, alpha = 0.05,
                        nsim = 100, distribution = "exponential",
                        censorpoint = 5, censortype = "right")

#Built-in Monte Carlo random generating functions are included for the gaussian, exponential,
#and lognormal distributions.

#We can also evaluate different censored distributions by specifying a custom
#random generating function and changing the distribution argument.

rlognorm = function(X, b) {
  Y = rlnorm(n = nrow(X), meanlog = X %*% b, sdlog = 0.4)
  censored = Y &gt; 1.2
  Y[censored] = 1.2
  return(survival::Surv(time = Y, event = !censored, type = "right"))
}

#Any additional arguments are passed into the survreg function call.  As an example, you
#might want to fix the "scale" argument to survreg, when fitting a lognormal:

eval_design_survival_mc(design = design, model = ~a, alpha = 0.2, nsim = 100,
                        distribution = "lognormal", rfunctionsurv = rlognorm,
                        anticoef = c(0.184, 0.101), scale = 0.4)
</code></pre>

<hr>
<h2 id='extractPvalues'>Extract p-values from a model object</h2><span id='topic+extractPvalues'></span>

<h3>Description</h3>

<p>Extract p-values from a model object. Currently works with lm, glm, lme4, glmer,
and survreg model objects. If possible, uses the p-values reported in summary(model_fit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPvalues(model_fit, glmfamily = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractPvalues_+3A_model_fit">model_fit</code></td>
<td>
<p>The model object from which to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of p-values. If model_fit is not a supported model type, returns NULL.
</p>

<hr>
<h2 id='gen_anticoef'>Generates Anticipated Coefficients</h2><span id='topic+gen_anticoef'></span>

<h3>Description</h3>

<p>Generates Anticipated Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_anticoef(RunMatrix, model, nointercept)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_anticoef_+3A_runmatrix">RunMatrix</code></td>
<td>
<p>The run matrix</p>
</td></tr>
<tr><td><code id="gen_anticoef_+3A_model">model</code></td>
<td>
<p>The model</p>
</td></tr>
<tr><td><code id="gen_anticoef_+3A_nointercept">nointercept</code></td>
<td>
<p>TRUE if intercept not in model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='gen_binomial_anticoef'>Generates Binomial Anticipated Coefficients</h2><span id='topic+gen_binomial_anticoef'></span>

<h3>Description</h3>

<p>Generates Binomial Anticipated Coefficients
Solves the logistic function
log(p / (1-p)) = beta0 + beta1 * x
such that p = lowprob when x = -1, and p = highprob when x = +1.
Equivalently, solves this set of equations for beta0 and beta1:
log(lowprob / (1 - lowprob)) = beta0 - beta1
log(highprob / (1 - highprob)) = beta0 + beta1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_binomial_anticoef(anticoef, lowprob, highprob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_binomial_anticoef_+3A_anticoef">anticoef</code></td>
<td>
<p>Anticipated coefficients</p>
</td></tr>
<tr><td><code id="gen_binomial_anticoef_+3A_lowprob">lowprob</code></td>
<td>
<p>Default 0.50. The base probability</p>
</td></tr>
<tr><td><code id="gen_binomial_anticoef_+3A_highprob">highprob</code></td>
<td>
<p>Default 0.80. The high probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='gen_design'>Generate optimal experimental designs</h2><span id='topic+gen_design'></span>

<h3>Description</h3>

<p>Creates an experimental design given a model, desired number of runs, and a data frame of candidate
test points. <code>gen_design</code> chooses points from the candidate set and returns a design that is optimal for the given
statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_design(
  candidateset,
  model,
  trials,
  splitplotdesign = NULL,
  blocksizes = NULL,
  optimality = "D",
  augmentdesign = NULL,
  repeats = 20,
  custom_v = NULL,
  varianceratio = 1,
  contrast = contr.simplex,
  aliaspower = 2,
  minDopt = 0.8,
  k = NA,
  parallel = FALSE,
  progress = TRUE,
  add_blocking_columns = FALSE,
  randomized = TRUE,
  advancedoptions = NULL,
  timer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_design_+3A_candidateset">candidateset</code></td>
<td>
<p>A data frame of candidate test points; each run of the optimal design will be chosen (with replacement)
from this candidate set. Each row of the data frame is a candidate test point. Each row should be unique.
Usually this is a full factorial test matrix generated for the factors in the model unless there are disallowed combinations of runs.
Factors present in the candidate set but not present in the model are stripped out, and the duplicate entries in the candidate set are removed.
Disallowed combinations can be specified by simply removing them from the candidate set. Disallowed combinations between a
hard-to-change and an easy-to-change factor are detected by comparing an internal candidate set generated by the unique levels
present in the candidate set and the split plot design. Those points are then excluded from the search.
If a factor is continuous, its column should be type <code>numeric</code>. If a factor is categorical, its column should be type <code>factor</code> or <code>character</code>.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_model">model</code></td>
<td>
<p>The statistical model used to generate the test design.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_trials">trials</code></td>
<td>
<p>The number of runs in the design.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_splitplotdesign">splitplotdesign</code></td>
<td>
<p>If 'NULL', a fully randomized design is generated. If not NULL, a split-plot design is generated, and
this argument specifies the design for all of the factors harder to change than the current set of factors.
Each row corresponds to a block in which the harder to change factors will be held
constant. Each row of <code>splitplotdesign</code> will be replicated as specified in <code>blocksizes</code>,
and the optimal design is found for all of the factors given in the
<code>model</code> argument, taking into consideration the fixed and replicated hard-to-change factors. If <code>blocksizes</code> is missing,
'gen_design' will attempt to allocate the runs in the most balanced design possible,
given the number of blocks given in the argument 'splitplotdesign' and the total number of 'trials'.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_blocksizes">blocksizes</code></td>
<td>
<p>Default 'NULL'. Specifies the block size(s) for design generation. If only one number is passed, 'gen_design()'
will create blocks of the specified size, and if the total number of run specified in 'trials' is not divisible by the number,
'gen_design()' will attempt to allocate the runs in the most balanced design possible. If a list is passed, each entry
in the list will specify an additional layer of blocking. If 'splitplotdesign' is not 'NULL', this argument
specifies the number of subplots within each whole plot (each whole plot corresponding to a row in the 'splitplotdesign' data.frame).</p>
</td></tr>
<tr><td><code id="gen_design_+3A_optimality">optimality</code></td>
<td>
<p>Default 'D'. The optimality criterion used in generating the design. Full list of supported criteria: &quot;D&quot;, &quot;I&quot;, &quot;A&quot;, &quot;ALIAS&quot;, &quot;G&quot;, &quot;T&quot;, &quot;E&quot;, or &quot;CUSTOM&quot;. If &quot;CUSTOM&quot;, user must also
define a function of the model matrix named 'customOpt' in their namespace that returns a single value, which the algorithm will attempt to optimize. For
'CUSTOM' optimality split-plot designs, the user must instead define 'customBlockedOpt', which should be a function of the model matrix and the variance-covariance matrix. For
information on the algorithm behind Alias-optimal designs, see <em>Jones and Nachtsheim. &quot;Efficient Designs With Minimal Aliasing.&quot; Technometrics, vol. 53, no. 1, 2011, pp. 62-71</em>.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_augmentdesign">augmentdesign</code></td>
<td>
<p>Default NULL. A 'data.frame' of runs that are fixed during the optimal search process. The columns of 'augmentdesign' must match those of the candidate set.
The search algorithm will search for the optimal 'trials' - 'nrow(augmentdesign)' remaining runs.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_repeats">repeats</code></td>
<td>
<p>Default '20'. The number of times to repeat the search for the best optimal design.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_custom_v">custom_v</code></td>
<td>
<p>Default 'NULL'. The user can pass a custom variance-covariance matrix to be used during blocked design generation.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_varianceratio">varianceratio</code></td>
<td>
<p>Default '1'. The ratio between the block and run-to-run variance for a given stratum in
a split plot/blocked design. This requires a design passed into 'splitplotdesign', so it will be overridden to '1'
if no split plot design is entered.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_contrast">contrast</code></td>
<td>
<p>Default 'contr.simplex', an orthonormal sum contrast. Function used to generate the encoding for categorical variables.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_aliaspower">aliaspower</code></td>
<td>
<p>Default '2'. Degree of interactions to be used in calculating the alias matrix for alias optimal designs.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_mindopt">minDopt</code></td>
<td>
<p>Default '0.8'. Minimum value for the D-Optimality of a design when searching for Alias-optimal designs.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_k">k</code></td>
<td>
<p>Default 'NA'. For D-optimal designs, this changes the search to a k-exchange algorithm
<em>Johnson and Nachtsheim. &quot;Some Guidelines for Constructing Exact D-Optimal Designs on Convex Design Spaces.&quot; Technometrics, vol. 25, 1983, pp. 271-277</em>.
This exchanges only the k lowest variance runs in the design at each search iteration. Lower numbers can result
in a faster search, but are less likely tofind an optimal design. Values of 'k &gt;= n/4' have been shown empirically to generate similar designs to the full
search. When &lsquo;k == trials', this results in the default modified Federov&rsquo;s algorithm.
A &lsquo;k' of 1 is a form of Wynn&rsquo;s algorithm <em>Wynn. &quot;Results in the Theory and Construction of D-Optimum Experimental Designs,&quot; Journal of the Royal Statistical Society, Ser. B,vol. 34, 1972, pp. 133-14</em>.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_parallel">parallel</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', the optimal design search will use all but one of the available cores.
This can lead to a substantial speed-up in the search for complex designs. If the user wants to set the number of cores manually, they can do this by setting 'options(&quot;cores&quot;)' to the desired number (e.g. 'options(&quot;cores&quot; = parallel::detectCores())').
NOTE: If you have installed BLAS libraries that include multicore support (e.g. Intel MKL that comes with Microsoft R Open), turning on parallel could result in reduced performance.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to include a progress bar.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_add_blocking_columns">add_blocking_columns</code></td>
<td>
<p>Default 'FALSE'. The blocking structure of the design will be indicated in the row names of the returned
design. If 'TRUE', the design also will have extra columns to indicate the blocking structure. If no blocking is detected, no columns will be added.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_randomized">randomized</code></td>
<td>
<p>Default 'TRUE', due to the intrinsic randomization of the design search algorithm. If 'FALSE',
the randomized design will be re-ordered from left to right.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_advancedoptions">advancedoptions</code></td>
<td>
<p>Default 'NULL'. An named list for advanced users who want to adjust the optimal design algorithm parameters. Advanced option names
are 'design_search_tolerance' (the smallest fractional increase below which the design search terminates), 'alias_tie_power' (the degree of the aliasing
matrix when calculating optimality tie-breakers), 'alias_tie_tolerance' (the smallest absolute difference in the optimality criterion where designs are
considered equal before considering the aliasing structure),  'alias_compare&ldquo; (which if set to FALSE turns off alias tie breaking completely),
'aliasmodel' (provided if the user does not want to calculate Alias-optimality using all 'aliaspower' interaction terms),
and &lsquo;progressBarUpdater&ldquo; (a function called in non-parallel optimal searches that can be used to update an external progress bar). Finally, there&rsquo;s
'g_efficiency_method', which sets the method used to calculate G-efficiency (default is &quot;random&quot; for a random Monte Carlo sampling of the design space,
&quot;optim&quot; for to use simulated annealing, or &quot;custom&quot; to explicitly define the points in the design space, which is the fastest method
and the only way to calculate prediction variance with disallowed combinations). With this, there's also 'g_efficiency_samples', which specifies
the number of random samples  (default 1000 if 'g_efficiency_method = &quot;random&quot;'), attempts at simulated annealing (default 1 if 'g_efficiency_method = &quot;optim&quot;'),
or a data.frame defining the exact points of the design space if 'g_efficiency_method = &quot;custom&quot;'.</p>
</td></tr>
<tr><td><code id="gen_design_+3A_timer">timer</code></td>
<td>
<p>Deprecated: Use 'progress' instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split-plot designs can be generated with repeated applications of <code>gen_design</code>; see examples for details.
</p>


<h3>Value</h3>

<p>A data frame containing the run matrix for the optimal design. The returned data frame contains supplementary
information in its attributes, which can be accessed with the 'get_attributes()' and 'get_optimality()' functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate the basic factorial candidate set with expand.grid.
#Generating a basic 2 factor candidate set:
basic_candidates = expand.grid(x1 = c(-1, 1), x2 = c(-1, 1))

#This candidate set is used as an input in the optimal design generation for a
#D-optimal design with 11 runs.
design = gen_design(candidateset = basic_candidates, model = ~x1 + x2, trials = 11)

#We can also use the dot formula to automatically use all of the terms in the model:
design = gen_design(candidateset = basic_candidates, model = ~., trials = 11)

#Here we add categorical factors, specified by using "as.factor" in expand.grid:
categorical_candidates = expand.grid(a = c(-1, 1),
                                     b = as.factor(c("A", "B")),
                                     c = as.factor(c("High", "Med", "Low")))

#This candidate set is used as an input in the optimal design generation.
design2 = gen_design(candidateset = categorical_candidates, model = ~a + b + c, trials = 19)

#We can also increase the number of times the algorithm repeats
#the search to increase the probability that the globally optimal design was found.
design2 = gen_design(candidateset = categorical_candidates,
                    model = ~a + b + c, trials = 19, repeats = 100)

#We can perform a k-exchange algorithm instead of a full search to help speed up
#the search process, although this can lead to less optimal designs. Here, we only
#exchange the 10 lowest variance runs in each search iteration.
if(skpr:::run_documentation()) {
design_k = gen_design(candidateset = categorical_candidates,
                    model = ~a + b + c, trials = 19, repeats = 100, k = 10)
}

#To speed up the design search, you can turn on multicore support with the parallel option.
#You can also customize the number of cores used by setting the cores option. By default,
#all cores are used.
if(skpr:::run_documentation()) {
options(cores = 2)
design2 = gen_design(categorical_candidates,
                    model = ~a + b + c, trials = 19, repeats = 1000, parallel = TRUE)
}

#You can also use a higher order model when generating the design:
design2 = gen_design(categorical_candidates,
                    model = ~a + b + c + a * b * c, trials = 12, repeats = 10)

#To evaluate a response surface design, include center points
#in the candidate set and include quadratic effects (but not for the categorical factors).

quad_candidates = expand.grid(a = c(1, 0, -1), b = c(-1, 0, 1), c = c("A", "B", "C"))

gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20)

#The optimality criterion can also be changed:
gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20,
          optimality = "I", repeats = 10)
gen_design(quad_candidates, ~a + b + I(a^2) + I(b^2) + a * b * c, 20,
          optimality = "A", repeats = 10)

#A blocked design can be generated by specifying the `blocksizes` argument. Passing a single
#number will create designs with blocks of that size, while passing multiple values in a list
#will specify multiple layers of blocking.

#Specify a single layer
gen_design(quad_candidates, ~a + b + c, 21, blocksizes=3, add_blocking_column=TRUE)

#Manually specify the block sizes for a single layer, must add to `trials``
gen_design(quad_candidates, ~a + b + c, 21, blocksizes=c(4,3,2,3,3,3,3),
          add_blocking_column=TRUE)

#Multiple layers of blocking
gen_design(quad_candidates, ~a + b + c, 21, blocksizes=list(7,3),
          add_blocking_column=TRUE)

#Multiple layers of blocking, specified individually
gen_design(quad_candidates, ~a + b + c, 21, blocksizes=list(7,c(4,3,2,3,3,3,3)),
          add_blocking_column=TRUE)

#A split-plot design can be generated by first generating an optimal blocking design using the
#hard-to-change factors and then using that as the input for the split-plot design.
#This generates an optimal subplot design that accounts for the existing split-plot settings.

splitplotcandidateset = expand.grid(Altitude = c(-1, 1),
                                    Range = as.factor(c("Close", "Medium", "Far")),
                                    Power = c(1, -1))
hardtochangedesign = gen_design(splitplotcandidateset, model = ~Altitude,
                               trials = 11, repeats = 10)

#Now we can use the D-optimal blocked design as an input to our full design.

#Here, we add the easy to change factors from the candidate set to the model,
#and input the hard-to-change design along with the new number of trials. `gen_design` will
#automatically allocate the runs in the blocks in the most balanced way possible.

designsplitplot = gen_design(splitplotcandidateset, ~Altitude + Range + Power, trials = 33,
                             splitplotdesign = hardtochangedesign, repeats = 10)

#If we want to allocate the blocks manually, we can do that with the argument `blocksizes`. This
#vector must sum to the number of `trials` specified.

#Putting this all together:
designsplitplot = gen_design(splitplotcandidateset, ~Altitude + Range + Power, trials = 33,
                             splitplotdesign = hardtochangedesign,
                             blocksizes = c(4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2), repeats = 10)

#The split-plot structure is encoded into the row names, with a period
#demarcating the blocking level. This process can be repeated for arbitrary
#levels of blocking (i.e. a split-plot design can be entered in as the hard-to-change
#to produce a split-split-plot design, which can be passed as another
#hard-to-change design to produce a split-split-split plot design, etc).
#In the following, note that the model builds up as we build up split plot strata.

splitplotcandidateset2 = expand.grid(Location = as.factor(c("East", "West")),
                                     Climate = as.factor(c("Dry", "Wet", "Arid")),
                                     Vineyard = as.factor(c("A", "B", "C", "D")),
                                     Age = c(1, -1))
#6 blocks of Location:
temp = gen_design(splitplotcandidateset2, ~Location, trials = 6, varianceratio = 2, repeats = 10)

#Each Location block has 2 blocks of Climate:
temp = gen_design(splitplotcandidateset2, ~Location + Climate,
                  trials = 12, splitplotdesign = temp, blocksizes = 2,
                  varianceratio = 1, repeats = 10)

#Each Climate block has 4 blocks of Vineyard:
temp = gen_design(splitplotcandidateset2, ~Location + Climate + Vineyard,
                  trials = 48, splitplotdesign = temp, blocksizes = 4,
                  varianceratio = 1, repeats = 10)

#Each Vineyard block has 4 runs with different Age:
if(skpr:::run_documentation()) {
splitsplitsplitplotdesign = gen_design(splitplotcandidateset2, ~Location + Climate + Vineyard + Age,
                                       trials = 192, splitplotdesign = temp, blocksizes = 4,
                                       varianceratio = 1, add_blocking_columns = TRUE)
}
#gen_design also supports user-defined optimality criterion. The user defines a function
#of the model matrix named customOpt, and gen_design will attempt to generate a design
#that maximizes that function. This function needs to be in the global environment, and be
#named either customOpt or customBlockedOpt, depending on whether a split-plot design is being
#generated. customBlockedOpt should be a function of the model matrix as well as the
#variance-covariance matrix, vInv. Due to the underlying C + + code having to call back to the R
#environment repeatedly, this criterion will be significantly slower than the built-in algorithms.
#It does, however, offer the user a great deal of flexibility in generating their designs.

#We are going to write our own D-optimal search algorithm using base R functions. Here, write
#a function that calculates the determinant of the information matrix. gen_design will search
#for a design that maximizes this function.

customOpt = function(currentDesign) {
 return(det(t(currentDesign) %*% currentDesign))
}

#Generate the whole plots for our split-plot design, using the custom criterion.

candlistcustom = expand.grid(Altitude = c(10000, 20000),
                            Range = as.factor(c("Close", "Medium", "Far")),
                            Power = c(50, 100))
htcdesign = gen_design(candlistcustom, model = ~Altitude + Range,
                      trials = 11, optimality = "CUSTOM", repeats = 10)

#Now define a function that is a function of both the model matrix,
#as well as the variance-covariance matrix vInv. This takes the blocking structure into account
#when calculating our determinant.

customBlockedOpt = function(currentDesign, vInv) {
 return(det(t(currentDesign) %*% vInv %*% currentDesign))
}

#And finally, calculate the design. This (likely) results in the same design had we chosen the
#"D" criterion.

design = gen_design(candlistcustom,
                   ~Altitude + Range + Power, trials = 33,
                   splitplotdesign = htcdesign, blocksizes = 3,
                   optimality = "CUSTOM", repeats = 10)

#gen_design can also augment an existing design. Input a dataframe of pre-existing runs
#to the `augmentdesign` argument. Those runs in the new design will be fixed, and gen_design
#will perform a search for the remaining `trials - nrow(augmentdesign)` runs.

candidateset = expand.grid(height = c(10, 20), weight = c(45, 55, 65), range = c(1, 2, 3))

design_to_augment = gen_design(candidateset, ~height + weight + range, 5)

#As long as the columns in the augmented design match the columns in the candidate set,
#this design can be augmented.

augmented_design = gen_design(candidateset,
                             ~height + weight + range, 16, augmentdesign = design_to_augment)

#A design's diagnostics can be accessed via the `get_optimality()` function:

get_optimality(augmented_design)

#And design attributes can be accessed with the `get_attribute()` function:

get_attribute(design)

#A correlation color map can be produced by calling the plot_correlation command with the output
#of gen_design()

if(skpr:::run_documentation()) {
plot_correlations(design2)
}

#A fraction of design space plot can be produced by calling the plot_fds command
if(skpr:::run_documentation()) {
plot_fds(design2)
}

#Evaluating the design for power can be done with eval_design, eval_design_mc (Monte Carlo)
#eval_design_survival_mc (Monte Carlo survival analysis), and
#eval_design_custom_mc (Custom Library Monte Carlo)
</code></pre>

<hr>
<h2 id='gen_exponential_anticoef'>Generates Exponential Anticipated Coefficients</h2><span id='topic+gen_exponential_anticoef'></span>

<h3>Description</h3>

<p>Generates Exponential Anticipated Coefficients
Solves the exponential link function
mean = exp(beta0 + beta1 * x)
such that mean = mean_low when x = -1, and mean = mean_high when x = +1.
Equivalently, solves this set of equations for beta0 and beta1:
mean_low = exp(beta0 - beta1)
mean_high = exp(beta0 + beta1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_exponential_anticoef(anticoef, mean_low, mean_high)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_exponential_anticoef_+3A_anticoef">anticoef</code></td>
<td>
<p>input anticipated coefficeints</p>
</td></tr>
<tr><td><code id="gen_exponential_anticoef_+3A_mean_low">mean_low</code></td>
<td>
<p>The low value of the mean value (= 1/rate)</p>
</td></tr>
<tr><td><code id="gen_exponential_anticoef_+3A_mean_high">mean_high</code></td>
<td>
<p>The high value of the mean value (= 1/rate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='gen_momentsmatrix'>Generates the moment matrix</h2><span id='topic+gen_momentsmatrix'></span>

<h3>Description</h3>

<p>Returns number of levels prior to each parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_momentsmatrix(modelfactors, levelvector, classvector)
</code></pre>


<h3>Value</h3>

<p>Returns a vector consisting of the number
of levels preceeding each parameter (including the intercept)
</p>

<hr>
<h2 id='gen_poisson_anticoef'>Generates Poisson Anticipated Coefficients</h2><span id='topic+gen_poisson_anticoef'></span>

<h3>Description</h3>

<p>Generates Poisson Anticipated Coefficients
Solves the Poisson link function
mean = exp(beta0 + beta1 * x)
such that mean = mean_low when x = -1, and mean = mean_high when x = +1.
Equivalently, solves this set of equations for beta0 and beta1:
mean_low = exp(beta0 - beta1)
mean_high = exp(beta0 + beta1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_poisson_anticoef(anticoef, mean_low, mean_high)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_poisson_anticoef_+3A_anticoef">anticoef</code></td>
<td>
<p>input anticipated coefficients of the proper length for your model matrix</p>
</td></tr>
<tr><td><code id="gen_poisson_anticoef_+3A_mean_low">mean_low</code></td>
<td>
<p>The low value of the mean value</p>
</td></tr>
<tr><td><code id="gen_poisson_anticoef_+3A_mean_high">mean_high</code></td>
<td>
<p>The high value of the mean value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anticipated coefficients.
</p>

<hr>
<h2 id='generate_block_panel'>Generate Block Panel</h2><span id='topic+generate_block_panel'></span>

<h3>Description</h3>

<p>Generate Block Panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_block_panel(any_htc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_block_panel_+3A_any_htc">any_htc</code></td>
<td>
<p>Factor number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shiny UI
</p>

<hr>
<h2 id='generate_factor_input_panel'>Generate Factor Input Panel</h2><span id='topic+generate_factor_input_panel'></span>

<h3>Description</h3>

<p>Generate Factor Input Panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_factor_input_panel(factor_n = 1, factor_input_cache = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_factor_input_panel_+3A_factor_n">factor_n</code></td>
<td>
<p>Factor number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shiny UI
</p>

<hr>
<h2 id='generate_noise_block'>Generate Noise Block</h2><span id='topic+generate_noise_block'></span>

<h3>Description</h3>

<p>Generates the noise to be added in the REML power calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_noise_block(noise, groups, blockstructure)
</code></pre>


<h3>Value</h3>

<p>Noise vector
</p>

<hr>
<h2 id='generate_optimality_results'>Generate Optimality Results</h2><span id='topic+generate_optimality_results'></span>

<h3>Description</h3>

<p>Generate Optimality Results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_optimality_results(any_htc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_optimality_results_+3A_any_htc">any_htc</code></td>
<td>
<p>Factor number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shiny UI
</p>

<hr>
<h2 id='genhypmatrix'>Generate Hypothesis Matrix</h2><span id='topic+genhypmatrix'></span>

<h3>Description</h3>

<p>Generates hypothesis matrix for power calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genhypmatrix(parameters, levels, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genhypmatrix_+3A_parameters">parameters</code></td>
<td>
<p>Number of parameters total in model</p>
</td></tr>
<tr><td><code id="genhypmatrix_+3A_levels">levels</code></td>
<td>
<p>Number of levels in parameter of interest</p>
</td></tr>
<tr><td><code id="genhypmatrix_+3A_g">g</code></td>
<td>
<p>Number of levels/parameters preceding parameter of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameter matrix L isolating the levels of parameter of interest
</p>

<hr>
<h2 id='genparammatrix'>Generate Parameter Matrix</h2><span id='topic+genparammatrix'></span>

<h3>Description</h3>

<p>Generates the parameter matrix L to isolate the levels of interest
in the calculation of power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genparammatrix(parameters, levels, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genparammatrix_+3A_parameters">parameters</code></td>
<td>
<p>Number of parameters total in model.</p>
</td></tr>
<tr><td><code id="genparammatrix_+3A_levels">levels</code></td>
<td>
<p>Number of levels in parameter of interest</p>
</td></tr>
<tr><td><code id="genparammatrix_+3A_g">g</code></td>
<td>
<p>Number of levels/parameters preceeding parameter of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameter vector Q isolating the levels of parameter of interest
</p>

<hr>
<h2 id='get_attribute'>Get attribute values</h2><span id='topic+get_attribute'></span>

<h3>Description</h3>

<p>Returns one or more of underlying attributes used in design generation/evaluation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attribute(output, attr = NULL, round = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_attribute_+3A_output">output</code></td>
<td>
<p>The output of either 'gen_design()' or 'eval_design()'/'eval_design_mc()&ldquo;</p>
</td></tr>
<tr><td><code id="get_attribute_+3A_attr">attr</code></td>
<td>
<p>Default 'NULL'. Return just the specific value requested.
Potential values are 'model.matrix' for model used, 'moments.matrix', 'variance.matrix', 'alias.matrix',
'correlation.matrix', and 'model' for the model used in the evaluation/generation of the design.</p>
</td></tr>
<tr><td><code id="get_attribute_+3A_round">round</code></td>
<td>
<p>Default 'TRUE'. Rounds off values smaller than the magnitude '1e-15&ldquo; in the 'correlation.matrix' and 'alias.matrix' matrix attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We can extract the attributes of a design from either the output of `gen_design()`
# or the output of `eval_design()`

factorialcoffee = expand.grid(cost = c(1, 2),
                             type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                             size = as.factor(c("Short", "Grande", "Venti")))

designcoffee = gen_design(factorialcoffee, ~cost + size + type, trials = 29,
                         optimality = "D", repeats = 100)

#Extract a list of all attributes
get_attribute(designcoffee)

#Get just one attribute
get_attribute(designcoffee,"model.matrix")

# Extract from `eval_design()` output
power_output = eval_design(designcoffee, model = ~cost + size + type,
                          alpha = 0.05, detailedoutput = TRUE)

get_attribute(power_output,"correlation.matrix")
</code></pre>

<hr>
<h2 id='get_block_groups'>Calculate block structure lengths</h2><span id='topic+get_block_groups'></span>

<h3>Description</h3>

<p>Calculate block structure lengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_block_groups(existing_block_structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_block_groups_+3A_existing_block_structure">existing_block_structure</code></td>
<td>
<p>character matrix from rownames, split by '.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of numbers indicating split plot layer sizes
</p>

<hr>
<h2 id='get_optimality'>Get optimality values</h2><span id='topic+get_optimality'></span>

<h3>Description</h3>

<p>Returns a list of optimality values (or one value in particular).
</p>
<p>Note: The choice of contrast will effect the 'G' efficiency value, and 'gen_design()'
and 'eval_design()' by default set different contrasts ('contr.simplex' vs 'contr.sum').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_optimality(output, optimality = NULL, calc_g = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_optimality_+3A_output">output</code></td>
<td>
<p>The output of either gen_design or eval_design/eval_design_mc.</p>
</td></tr>
<tr><td><code id="get_optimality_+3A_optimality">optimality</code></td>
<td>
<p>Default 'NULL'. Return just the specific optimality requested.</p>
</td></tr>
<tr><td><code id="get_optimality_+3A_calc_g">calc_g</code></td>
<td>
<p>Default 'FALSE'. Whether to calculate the g-efficiency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of optimality conditions. 'D', 'A', and 'G' are efficiencies (value is out of 100).
'T' is the trace of the information matrix, 'E' is the minimum eigenvalue of the information matrix,
'I' is the average prediction variance, and 'Alias' is the trace of the alias matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We can extract the optimality of a design from either the output of `gen_design()`
# or the output of `eval_design()`

factorialcoffee = expand.grid(cost = c(1, 2),
                             type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                             size = as.factor(c("Short", "Grande", "Venti")))

designcoffee = gen_design(factorialcoffee, ~cost + size + type, trials = 29,
                         optimality = "D", repeats = 100)

#Extract a list of all attributes
get_optimality(designcoffee)

#Get just one attribute
get_optimality(designcoffee,"D")

# Extract from `eval_design()` output
power_output = eval_design(designcoffee, model = ~cost + size + type,
                          alpha = 0.05, detailedoutput = TRUE)

get_optimality(power_output)
</code></pre>

<hr>
<h2 id='get_power_curve_output'>Get Power Curve Warnings and Errors</h2><span id='topic+get_power_curve_output'></span>

<h3>Description</h3>

<p>Gets the warnings and errors from 'calculate_power_curves()' output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_power_curve_output(power_curve)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_power_curve_output_+3A_power_curve">power_curve</code></td>
<td>
<p>The output from 'calculate_power_curves()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data.frames containing warning/error information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate sample
if(skpr:::run_documentation()) {
calculate_power_curves(trials=seq(50,150,by=20),
                      candidateset = expand.grid(x=c(-1,1),y=c(-1,1)),
                      model = ~.,
                      effectsize = list(c(0.5,0.9),c(0.6,0.9)),
                      eval_function = eval_design_mc,
                      eval_args = list(nsim = 100, glmfamily = "binomial"))
}
</code></pre>

<hr>
<h2 id='is_intralayer_interaction'>Layer Interaction</h2><span id='topic+is_intralayer_interaction'></span>

<h3>Description</h3>

<p>Determines if a factor is a intra-layer interaction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_intralayer_interaction(design, model, split_layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_intralayer_interaction_+3A_design">design</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code id="is_intralayer_interaction_+3A_model">model</code></td>
<td>
<p>The model</p>
</td></tr>
<tr><td><code id="is_intralayer_interaction_+3A_split_layers">split_layers</code></td>
<td>
<p>The layer of split plots for each main effect term</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of booleans for each subplot strata layer
</p>

<hr>
<h2 id='is_rendering_in_knitr'>Determines if rendering in knitr</h2><span id='topic+is_rendering_in_knitr'></span>

<h3>Description</h3>

<p>Determines if rendering in knitr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rendering_in_knitr()
</code></pre>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='normalize_design'>Normalize Design</h2><span id='topic+normalize_design'></span>

<h3>Description</h3>

<p>Normalizes the numeric columns in the design to -1 to 1. This is important to do if your model has interaction or polynomial terms,
as these terms can introduce multi-collinearity and standardizing the numeric columns can reduce this problem.
</p>
<p>Normalizes the numeric columns in the design to -1 to 1. This is important to do if your model has interaction or polynomial terms,
as these terms can introduce multi-collinearity and standardizing the numeric columns can reduce this problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_design(design, augmented = NULL)

normalize_design(design, augmented = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_design_+3A_design">design</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code id="normalize_design_+3A_augmented">augmented</code></td>
<td>
<p>Default 'NULL'. If</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized design matrix
</p>
<p>Normalized run matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Normalize a design
if(skpr:::run_documentation()) {
cand_set = expand.grid(temp = c(100,300,500),
                      altitude = c(10000,20000),
                      offset = seq(-10,-5,by=1),
                      type = c("A","B", "C"))
design = gen_design(cand_set, ~., 24)

#Un-normalized design
design
}
if(skpr:::run_documentation()) {
#Normalized design
normalize_design(design)
}
</code></pre>

<hr>
<h2 id='parameterpower'>Calculates parameter power</h2><span id='topic+parameterpower'></span>

<h3>Description</h3>

<p>Calculates parameter power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterpower(
  RunMatrix,
  levelvector = NULL,
  anticoef,
  alpha,
  vinv = NULL,
  degrees = NULL,
  parameter_names
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameterpower_+3A_runmatrix">RunMatrix</code></td>
<td>
<p>The run matrix</p>
</td></tr>
<tr><td><code id="parameterpower_+3A_levelvector">levelvector</code></td>
<td>
<p>The number of levels in each parameter (1st is always the intercept)</p>
</td></tr>
<tr><td><code id="parameterpower_+3A_anticoef">anticoef</code></td>
<td>
<p>The anticipated coefficients</p>
</td></tr>
<tr><td><code id="parameterpower_+3A_alpha">alpha</code></td>
<td>
<p>the specified type-I error</p>
</td></tr>
<tr><td><code id="parameterpower_+3A_vinv">vinv</code></td>
<td>
<p>The V inverse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameter power for the parameters
</p>

<hr>
<h2 id='permutations'>Permutations</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>Return permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permutations_+3A_n">n</code></td>
<td>
<p>Number of elements to permute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of permuted element ids
</p>

<hr>
<h2 id='plot_correlations'>Plots design diagnostics</h2><span id='topic+plot_correlations'></span>

<h3>Description</h3>

<p>Plots design diagnostics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_correlations(
  genoutput,
  model = NULL,
  customcolors = NULL,
  pow = 2,
  custompar = NULL,
  standardize = TRUE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_correlations_+3A_genoutput">genoutput</code></td>
<td>
<p>The output of either gen_design or eval_design/eval_design_mc</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_model">model</code></td>
<td>
<p>Default 'NULL'. Defaults to the model used in generating/evaluating
the design, augmented with 2-factor interactions. If specified, it will override the default
model used to generate/evaluate the design.</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_customcolors">customcolors</code></td>
<td>
<p>A vector of colors for customizing the appearance of the colormap</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_pow">pow</code></td>
<td>
<p>Default 2. The interaction level that the correlation map is showing.</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_custompar">custompar</code></td>
<td>
<p>Default NULL. Custom parameters to pass to the 'par' function for base R plotting.</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_standardize">standardize</code></td>
<td>
<p>Default 'TRUE'. Whether to standardize (scale to -1 and 1 and center) the continuous numeric columns. Not
standardizing the numeric columns can increase multi-collinearity (predictors that are correlated with other predictors in the model).</p>
</td></tr>
<tr><td><code id="plot_correlations_+3A_plot">plot</code></td>
<td>
<p>Default 'TRUE'. If 'FALSE', this will return the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently returns the correlation matrix with the proper row and column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We can pass either the output of gen_design or eval_design to plot_correlations
#in order to obtain the correlation map. Passing the output of eval_design is useful
#if you want to plot the correlation map from an externally generated design.

#First generate the design:

candidatelist = expand.grid(cost = c(15000, 20000), year = c("2001", "2002", "2003", "2004"),
                           type = c("SUV", "Sedan", "Hybrid"))
cardesign = gen_design(candidatelist, ~(cost+type+year)^2, 30)
plot_correlations(cardesign)

#We can also increase the level of interactions that are shown by default.

plot_correlations(cardesign, pow = 3)

#You can also pass in a custom color map.
plot_correlations(cardesign, customcolors = c("blue", "grey", "red"))
plot_correlations(cardesign, customcolors = c("blue", "green", "yellow", "orange", "red"))
</code></pre>

<hr>
<h2 id='plot_fds'>Fraction of Design Space Plot</h2><span id='topic+plot_fds'></span>

<h3>Description</h3>

<p>Creates a fraction of design space plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fds(
  genoutput,
  model = NULL,
  continuouslength = 1001,
  plot = TRUE,
  sample_size = 10000,
  yaxis_max = NULL,
  description = "Fraction of Design Space"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fds_+3A_genoutput">genoutput</code></td>
<td>
<p>The design, or the output of the power evaluation functions. This can also be a list
of several designs, which will result in all of them being plotted in a row (for easy comparison).</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_model">model</code></td>
<td>
<p>Default 'NULL'. The model, if 'NULL' it defaults to the model used in 'eval_design' or 'gen_design'.</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_continuouslength">continuouslength</code></td>
<td>
<p>Default '11'. The precision of the continuous variables. Decrease for faster (but less precise) plotting.</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_plot">plot</code></td>
<td>
<p>Default 'TRUE'. Whether to plot the FDS, or just calculate the cumulative distribution function.</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_sample_size">sample_size</code></td>
<td>
<p>Default '10000'. Number of samples to take of the design space.</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_yaxis_max">yaxis_max</code></td>
<td>
<p>Default 'NULL'. Manually set the maximum value of the prediction variance.</p>
</td></tr>
<tr><td><code id="plot_fds_+3A_description">description</code></td>
<td>
<p>Default 'Fraction of Design Space'. The description to add to the plot. If a vector and multiple designs
passed to genoutput, it will be the description for each plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots design diagnostics, and invisibly returns the vector of values representing the fraction of design space plot. If multiple
designs are passed, this will return a list of all FDS vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We can pass either the output of gen_design or eval_design to plot_correlations
#in order to obtain the correlation map. Passing the output of eval_design is useful
#if you want to plot the correlation map from an externally generated design.

#First generate the design:

candidatelist = expand.grid(X1 = c(1, -1), X2 = c(1, -1))

design = gen_design(candidatelist, ~(X1 + X2), 15)

plot_fds(design)
</code></pre>

<hr>
<h2 id='potential_permuted_factors'>Find potential permuted interactions</h2><span id='topic+potential_permuted_factors'></span>

<h3>Description</h3>

<p>Returns permuted interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>potential_permuted_factors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="potential_permuted_factors_+3A_x">x</code></td>
<td>
<p>character vector of interaction terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of potential interaction terms
</p>

<hr>
<h2 id='print.skpr_eval_output'>Print evaluation information</h2><span id='topic+print.skpr_eval_output'></span>

<h3>Description</h3>

<p>Prints design evaluation information below the data.frame of power values
</p>
<p>Note: If options(&quot;skpr.ANSI&quot;) is 'NULL' or 'TRUE', ANSI codes will be used during printing
to prettify the output. If this is 'FALSE', only ASCII will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skpr_eval_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.skpr_eval_output_+3A_x">x</code></td>
<td>
<p>The x of the evaluation functions in skpr</p>
</td></tr>
<tr><td><code id="print.skpr_eval_output_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate/evaluate a design and print its information
factorialcoffee = expand.grid(cost = c(1, 2),
                              type = as.factor(c("Kona", "Colombian", "Ethiopian", "Sumatra")),
                              size = as.factor(c("Short", "Grande", "Venti")))

designcoffee = gen_design(factorialcoffee,
                         ~cost + size + type, trials = 29, optimality = "D", repeats = 100)

eval_design(designcoffee)
</code></pre>

<hr>
<h2 id='print.skpr_power_curve_output'>Print evaluation information</h2><span id='topic+print.skpr_power_curve_output'></span>

<h3>Description</h3>

<p>Prints design evaluation information below the data.frame of power values
</p>
<p>Note: If options(&quot;skpr.ANSI&quot;) is 'NULL' or 'TRUE', ANSI codes will be used during printing
to prettify the output. If this is 'FALSE', only ASCII will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'skpr_power_curve_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.skpr_power_curve_output_+3A_x">x</code></td>
<td>
<p>The x of the evaluation functions in skpr</p>
</td></tr>
<tr><td><code id="print.skpr_power_curve_output_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate/evaluate a design and print its information
factorialcoffee = expand.grid(cost = c(1, 2),
                              type = as.factor(c("Kona",
                                                 "Colombian",
                                                 "Ethiopian",
                                                 "Sumatra")),
                              size = as.factor(c("Short",
                                                 "Grande",
                                                 "Venti")))

coffee_curves = calculate_power_curves(candidateset = factorialcoffee,
                                      model = ~(cost + size + type)^2,
                                      trials = 30:40, plot_results = FALSE)
coffee_curves
</code></pre>

<hr>
<h2 id='priorlevels'>Prior levels</h2><span id='topic+priorlevels'></span>

<h3>Description</h3>

<p>Returns number of levels prior to each parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorlevels(levelvector)
</code></pre>


<h3>Value</h3>

<p>Returns a vector consisting of the number
of levels preceeding each parameter (including the intercept)
</p>

<hr>
<h2 id='quad'>quadratic</h2><span id='topic+quad'></span>

<h3>Description</h3>

<p>quadratic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad_+3A_formula">formula</code></td>
<td>
<p>The formula to be expanded</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns quadratic model from formula
</p>

<hr>
<h2 id='rearrange_formula_by_order'>Rearrange formula by order</h2><span id='topic+rearrange_formula_by_order'></span>

<h3>Description</h3>

<p>Rearrange higher order arithmatic terms to end of formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearrange_formula_by_order(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearrange_formula_by_order_+3A_model">model</code></td>
<td>
<p>Base model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rearranged model
</p>

<hr>
<h2 id='reduceRunMatrix'>Remove columns not in model</h2><span id='topic+reduceRunMatrix'></span>

<h3>Description</h3>

<p>Remove columns not in model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceRunMatrix(RunMatrix, model, first_run = TRUE)
</code></pre>


<h3>Value</h3>

<p>The reduced model matrix.
</p>

<hr>
<h2 id='remove_skpr_blockcols'>Remove skpr-generated blocking columns</h2><span id='topic+remove_skpr_blockcols'></span>

<h3>Description</h3>

<p>Remove skpr-generated REML blocking columns if present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_skpr_blockcols(RunMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_skpr_blockcols_+3A_runmatrix">RunMatrix</code></td>
<td>
<p>The run matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Run Matrix
</p>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>Run Documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>bool
</p>

<hr>
<h2 id='set_up_progressr_handler'>Set up progressr handler</h2><span id='topic+set_up_progressr_handler'></span>

<h3>Description</h3>

<p>Set up progressr handler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_up_progressr_handler(msg_string, type_string)
</code></pre>

<hr>
<h2 id='skprGUI'>Graphical User Interface for skpr</h2><span id='topic+skprGUI'></span>

<h3>Description</h3>

<p>skprGUI provides a graphical user interface to skpr, within R Studio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skprGUI(
  browser = FALSE,
  return_app = FALSE,
  multiuser = FALSE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skprGUI_+3A_browser">browser</code></td>
<td>
<p>Default 'FALSE'. Whether to open the application in an external browser.</p>
</td></tr>
<tr><td><code id="skprGUI_+3A_return_app">return_app</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will return the shinyApp object.</p>
</td></tr>
<tr><td><code id="skprGUI_+3A_multiuser">multiuser</code></td>
<td>
<p>Default 'FALSE'. If 'TRUE', this will turn off and disable multicore functionality and enable non-blocking operation.</p>
</td></tr>
<tr><td><code id="skprGUI_+3A_progress">progress</code></td>
<td>
<p>Default 'TRUE'. Whether to include a progress bar in the application. Note: if 'multiuser = TRUE', progress
bars are turned on by default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Type `skprGUI()` to begin

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
