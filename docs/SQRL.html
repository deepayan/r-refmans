<!DOCTYPE html><html lang="en"><head><title>Help for package SQRL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SQRL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SQRL-package'>
<p>Simple and Powerful ODBC Interfaces</p></a></li>
<li><a href='#sqrlAll'>
<p>Broadcast a Command to All Data Sources</p></a></li>
<li><a href='#sqrlConfig'>
<p>Configuration Files</p></a></li>
<li><a href='#sqrlInterface'>
<p>Creates Data Source Interfaces</p></a></li>
<li><a href='#sqrlOff'>
<p>Close Connections and Deactivate the Package</p></a></li>
<li><a href='#sqrlParams'>
<p>Control and Communication Parameters</p></a></li>
<li><a href='#sqrlScript'>
<p>Hybrid Script Syntax</p></a></li>
<li><a href='#sqrlSource'>
<p>Define New Data Sources</p></a></li>
<li><a href='#sqrlSources'>
<p>List Data Sources and their Interfaces</p></a></li>
<li><a href='#sqrlUsage'>
<p>How to Use the Interface Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Enhances Interaction with 'ODBC' Databases</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Lee</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Lee &lt;random.deviate@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides simple and powerful interfaces that facilitate interaction
    with 'ODBC' data sources. Each data source gets its own unique and dedicated
    interface, wrapped around 'RODBC'. Communication settings are remembered
    between queries, and are managed silently in the background. The interfaces
    support multi-statement 'SQL' scripts, which can be parameterised via
    metaprogramming structures and embedded 'R' expressions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RODBC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tools, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-03 04:30:28 UTC; Mike</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-03 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SQRL-package'>
Simple and Powerful ODBC Interfaces
</h2><span id='topic+SQRL-package'></span><span id='topic+SQRL'></span><span id='topic+sqrl'></span>

<h3>Description</h3>

<p>Streamlines interactive exploratory work, and short-order ad hoc jobs, on
<abbr><span class="acronym">ODBC</span></abbr> data sources.
</p>


<h3>Details</h3>

<p>Automatically generates a dedicated and like-named interface function to each
<abbr><span class="acronym">ODBC</span></abbr> <abbr><span class="acronym">DSN</span></abbr> (Open DataBase Connectivity Data Source Name).
These functions manage communications behind the scenes, whilst supporting
multi-statement <abbr><span class="acronym">SQL</span></abbr> scripts.
Hybrid (<abbr><span class="acronym">SQRL</span></abbr>) scripting syntax allows <abbr><span class="acronym">SQL</span></abbr> with embedded <span class="rlang"><b>R</b></span>,
thereby enabling parameterisation of queries, feedback of intermediate results,
the addition of flow-control structures within and around <abbr><span class="acronym">SQL</span></abbr>, and the
use of libraries of stored scripts.
Additional sources and interfaces can be defined at any time.
The package is a wrapper about <span class="pkg">RODBC</span>.
</p>


<h3>Author(s)</h3>

<p>Mike Lee
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlSources">sqrlSources</a></code>,
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(SQRL)

# Show (automatic) data sources.
sqrlSources()

## Not run: 
# If 'ratatoskr' were one of those sources (i.e.,
# if a DSN of that name was found), then a multi-
# statement query could be submitted like so:
ratatoskr("use yggdrasil; select messages from ",
          "vedfolnir where addressee = 'nidhogg' ",
          "limit ", 5)

# Submit a parameterised query from file.
ratatoskr("messages.sqrl", year = 950)

# Obtain help on usage.
ratatoskr("help")

## End(Not run)

# Define a new data source (interface).
sqrlSource("mysource",
           driver = "MYSQL ODBC 5.3 ANSI Driver",
           server = "localhost",
           user = "&lt;uid&gt;",
           password = "&lt;pwd&gt;")

## Not run: 
# Submit a query to the new source.
mysource("select * from database.table")

## End(Not run)
</code></pre>

<hr>
<h2 id='sqrlAll'>
Broadcast a Command to All Data Sources
</h2><span id='topic+sqrlAll'></span>

<h3>Description</h3>

<p>Passes a single command to every <span class="pkg">SQRL</span> data source in turn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrlAll(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrlAll_+3A_...">...</code></td>
<td>

<p>The command to broadcast (as per <code><a href="#topic+sqrlUsage">sqrlUsage</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list, containing the result of the command for each data source.
The list is invisible, except when retrieving (getting) a named parameter value.
</p>


<h3>Note</h3>

<p>The command is passed to all <span class="pkg">SQRL</span> data sources, whether or not they have
interface functions.
</p>
<p>The command can be a <abbr><span class="acronym">SQL</span></abbr> query.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlOff">sqrlOff</a></code>,
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show all interfaces (visible return).
sqrlAll("interface")

# Enable all connection indicators.
sqrlAll(visible = TRUE)

# Close all open channels.
sqrlAll("close")

# Remove all defined sources.
sqrlAll("remove")
</code></pre>

<hr>
<h2 id='sqrlConfig'>
Configuration Files
</h2><span id='topic+sqrlConfig'></span>

<h3>Description</h3>

<p>This material does not describe a function, but (rather) the file format used to
configure <span class="pkg">SQRL</span> interfaces and <span class="pkg">RODBC</span> communications.
</p>
<p>Configuration files can be used to define new data sources, set blanket
parameter values for existing sources, or set individually named parameter
values.
</p>


<h3>Example Configuration File</h3>

<pre>
# Parameters for RODBC::odbcConnect/RODBC::odbcDriverConnect.
dsn                 = NULL
uid                 = "Blake"
pwd                 = 'C:/some/other/file.txt'
connection          = "driver=&lt;driver&gt;;dbalias=alpha;uid=&lt;uid&gt;;pwd=&lt;pwd&gt;;"
case                = "nochange"
believeNRows        = TRUE
colQuote            = c("`", "'")
tabQuote            = '"'
interpretDot        = TRUE
DBMSencoding        = ""
rows_at_time        = 100
readOnlyOptimize    = FALSE

# Additional parameters for RODBC::sqlQuery.
errors              = TRUE
as.is               = TRUE
max                 = 0
buffsize            = 1000
nullstring          = NA_character_
na.strings          = c("NA", "-", "")
dec                 = "."
stringsAsFactors    = FALSE

# Parameters for SQRL.
aCollapse           = ','
autoclose           = TRUE
driver              = "{IBM DB2 ODBC DRIVER}"
interface           = "Z"
lCollapse           = "\n"
library             = "my/library/file.sqrl"
ping                = "select 1 from dual"
verbose             = FALSE
visible             = TRUE
prompt              = "Z"
retry               = TRUE
scdo                = TRUE
wintitle            = "(Zen)"
</pre>


<h3>Commentary on Example File</h3>

<p>This is a sample configuration file, exhibiting almost all parameters.
In general, a file need not include all of these (default values are in place).
</p>
<p>Parameters may be defined as the path to some other file.
The <var>driver</var> and <var>dsn</var> parameters will take that path as their value.
For all other parameters, a value will be read from within the file.
Such files may contain only a single line with nothing but the value on it, or
they may adhere to the full (multiple line) &lsquo;parameter = value&rsquo; format
(as above).
</p>
<p>Configuration scripts are parsed and evaluated as <span class="rlang"><b>R</b></span>, but any expressions in
which the final assignment is made via <code>=</code> (as opposed to <code>&lt;-</code>) are
interpreted as requests to set <span class="pkg">SQRL</span>/<span class="pkg">RODBC</span> parameter values, rather
than <span class="rlang"><b>R</b></span> environment variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlParams">sqrlParams</a></code>,
<code><a href="#topic+sqrlSource">sqrlSource</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a new source (not from file).
sqrlSource("Orac", "UID=Avon;PWD=&lt;pwd&gt;",
           "Driver=Oracle 19 ODBC driver",
           "Server=db.starone.mil:1521/dwprd")

# Review its configuration (parameter values).
Orac("config")

# Create a file, containing only 'TRUE'.
file1 &lt;- normalizePath(tempfile(), "/", FALSE)
writeLines("TRUE", file1)

# Create a file, containing named parameter values.
file2 &lt;- normalizePath(tempfile(), "/", FALSE)
writeLines(c("dsn = 'Aristo'",
             "uid = 'Ensor'",
             "autoclose = TRUE",
             "as.is = FALSE"),
           file2)

# Create a configuration file, referencing the two above.
# Observe the use of temporary (non-parameter) variable 'x'.
file3 &lt;- tempfile()
writeLines(c("aCollapse = ', '",
             paste0("verbose = \"", file1, "\""),
             "x &lt;- 4",
             "max = sqrt(100 * x)",
             "as.is = TRUE",
             paste0("autoclose = '", file2, "'")),
           file3)
readLines(file3)

# Configure from the main (third) file.
Orac(config = file3)

# Alternative file-import forms.
Orac("config", file3)
Orac(paste("config", file3))

# Confirm imported values.
# Only 'autoclose' has been read from file2.
Orac("config")

# Import one parameter value from a file
# containing only a single unnamed value.
Orac(readOnlyOptimize = file1)
Orac("readOnlyOptimize")

# Import only a single specific parameter value
# from a file containing several named values.
Orac(uid = file2)
Orac("uid")

# Define and configure a new source from file.
sqrlSource("Caro", file2)
Caro("config")

# Configuration can also be performed from a named list,
# which could be generated by any R function or script.
Caro(config = list(autoclose = FALSE, max = 100))
Caro("config")[c("autoclose", "max")]

# Delete files.
unlink(c(file1, file2, file3))
</code></pre>

<hr>
<h2 id='sqrlInterface'>
Creates Data Source Interfaces
</h2><span id='topic+sqrlInterface'></span>

<h3>Description</h3>

<p>Creates, renames, and removes data-source interface functions.
</p>
<p>Communications with data sources (including <abbr><span class="acronym">SQL</span></abbr> queries) are conducted
through these interfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrlInterface(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrlInterface_+3A_...">...</code></td>
<td>

<p>The name of a registered data source, and the name to use for its interface.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The source and interface names may be supplied as two character strings,
<code>("source", "interface")</code>, or as a <code>(source = "interface")</code>, or
<code>("source" = "interface")</code>, parameter-value pair.
</p>
<p>The setting of an interface whose name would clash with that of any other
function already on the <span class="rlang"><b>R</b></span> search path is prevented.
An error will be thrown if a potential conflict is detected.
Conversely, a successful call of this function guarantees both the existence of
the new interface, and the uniqueness of its name (amongst functions).
</p>
<p>If the interface name is specified as either <code>NULL</code> or <code>"remove"</code>,
then any existing interface is deleted (and no new interface is created).
</p>
<p>If only a single string is supplied, the name of that source's interface
function is returned.
</p>
<p>Use of this functions is not ordinarily required, except when a registered
data source does not already have an interface function.
</p>


<h3>Value</h3>

<p>Returns the name of the source's interface function (visibly on get, invisibly
on set).
</p>


<h3>Note</h3>

<p>Interfaces are stored in a publicly accessible environment, <code>SQRL:Face</code>.
This is attached to the <span class="rlang"><b>R</b></span> search path when the package is loaded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlSource">sqrlSource</a></code>
<code><a href="#topic+sqrlSources">sqrlSources</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a new data source, named 'entropy'.
sqrlSource("entropy", uid = "ludwig",
           driver = "{SQL Server Native Client 11.0}",
           server = "Clausius", database = "Gibbs")

# The source comes with an interface of the same name.
sqrlInterface("entropy")
entropy("sources")

# Change the name of the interface function.
sqrlInterface(entropy = "S")

# An equivalent alternative form.
sqrlInterface("entropy", "S")

# The name of the source remains unchanged.
sqrlInterface("entropy")
S("sources")

# Submit a dummy 'query', via the interface.
# Normally, you'd put some SQL in here, but
# the source would have to exist for that.
S("&lt;R&gt; 'hello, world'")

# Remove the source's interface function.
sqrlInterface(entropy = NULL)

# An equivalent alternative form.
sqrlInterface("entropy", "remove")

# The source remains, but has no interface.
sqrlInterface("entropy")
sqrlSources()
</code></pre>

<hr>
<h2 id='sqrlOff'>
Close Connections and Deactivate the Package
</h2><span id='topic+sqrlOff'></span>

<h3>Description</h3>

<p>Closes all connections, detaches the interface environment (<var>SQRL:Face</var>)
from the search path, and unloads the <span class="pkg">SQRL</span> namespace.
No further communication with any data source will be possible through
<span class="pkg">SQRL</span> (until it is reloaded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrlOff()
</code></pre>


<h3>Value</h3>

<p>Returns invisible <code>NULL</code>.
</p>


<h3>Note</h3>

<p>Calls to <code><a href="RODBC.html#topic+odbcClose">RODBC::odbcCloseAll</a></code> will close any
connection channels open in <span class="pkg">SQRL</span>.
</p>


<h3>See Also</h3>

<p><span class="pkg"><a href="#topic+SQRL-package">SQRL</a></span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Calling sqrlOff() will deactivate and unload SQRL.
sqrlOff()

## End(Not run)
</code></pre>

<hr>
<h2 id='sqrlParams'>
Control and Communication Parameters
</h2><span id='topic+sqrlParams'></span>

<h3>Description</h3>

<p>This material does not describe a function, but (rather) the various parameters
governing <abbr><span class="acronym">ODBC</span></abbr> communications and package behaviour.
The majority of these are passed through to <span class="pkg">RODBC</span>.
</p>
<p><span class="pkg">SQRL</span> adopts a set-and-forget approach, wherein changes to the values of
these parameters are persistent, and all subsequent communications make use of
those values.
Each registered (<span class="pkg">SQRL</span>) data source has its own independent set of values.
</p>


<h3>Parameters</h3>


<dl>
<dt><var>aCollapse</var>:</dt><dd>
<p>A character string (typically a single character).
When an atomic object (typically a vector of character or integer type) is
pasted into <abbr><span class="acronym">SQL</span></abbr>, that object is first collapsed to a single string,
with <var>aCollapse</var> separating each sequential pair of the object's elements.
The default value is comma (&ldquo;,&rdquo;).
</p>
</dd>
<dt><var>as.is</var>:</dt><dd>
<p>A logical vector, or a numeric vector (of column indices), or a  character
vector (of column names).
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code> (see also
<code><a href="utils.html#topic+read.table">utils::read.table</a></code>).
Tells <span class="pkg">RODBC</span> which character columns of a table, as returned by a query
to the <abbr><span class="acronym">ODBC</span></abbr> connection, <em>not</em> to convert to some other data type
(i.e., which character columns to leave as is).
Due to <span class="pkg">SQRL</span>'s set-and-forget approach to parameters, it is inconvenient to
change <var>as.is</var> on a query-by-query basis.
That being the case, it is often best defined as a logical singleton (either
<code>TRUE</code> or <code>FALSE</code>).
Alternatively, temporary query-specific values can be set within <abbr><span class="acronym">SQRL</span></abbr>
scripts (see <code><a href="#topic+sqrlSource">sqrlSource</a></code>).
The default value is <code>FALSE</code> (convert all character columns).
</p>
</dd>
<dt><var>autoclose</var>:</dt><dd>
<p>A logical singleton.
Tells <span class="pkg">SQRL</span> whether or not to automatically close the data source
connection after each query (in general, a sequence of multiple statements).
The default value is <code>FALSE</code>, which leaves the connection open.
When set to <code>TRUE</code>, connections will open only for the duration of each
query.
When user input is required for authentication each time a new connection is
opened, the default setting will be more convenient.
</p>
</dd>
<dt><var>believeNRows</var>:</dt><dd>
<p>A logical singleton.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Tells <span class="pkg">RODBC</span> whether or not to trust the nominal number of rows returned by
the <abbr><span class="acronym">ODBC</span></abbr> connection.
Locked while the connection is open.
The default value is <code>TRUE</code>, except for SQLite (<code>FALSE</code>).
</p>
</dd>
<dt><var>buffsize</var>:</dt><dd>
<p>A positive integer.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Specifies the number of rows (of a query result) to fetch at a time.
The default value is 1000.
</p>
</dd>
<dt><var>case</var>:</dt><dd>
<p>A character string, specifically one of &ldquo;nochange&rdquo;, &ldquo;toupper&rdquo;,
&ldquo;tolower&rdquo;, &ldquo;mysql&rdquo;, &ldquo;postgresql&rdquo;, or &ldquo;msaccess&rdquo;.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies case-changing behaviour for table and column names.
Locked while the connection is open.
The default value is &ldquo;nochange&rdquo;.
</p>
</dd>
<dt><var>channel</var>:</dt><dd>
<p>An <span class="pkg">RODBC</span> connection handle.
Returned by <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
This parameter is read-only.
</p>
</dd>
<dt><var>colQuote</var>:</dt><dd>
<p>A character vector of length 0, 1, or 2, or <code>NULL</code>.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies the quote character(s) for column names.
A vector of length zero means no quotes, of length one means apply the specified
quote character at both ends of a name, and of length two means apply the first
character to the start of the name and the second character to the end of the
name.
Locked while the connection is open.
The default value is a backtick for MySQL, and a double-quote for everything
else.
</p>
</dd>
<dt><var>connection</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies an <abbr><span class="acronym">ODBC</span></abbr> connection string.
The content of this string will be database-management system (<abbr><span class="acronym">DBMS</span></abbr>)
dependent.
Overrides <var>dsn</var>, should both be defined.
Locked while the connection is open.
Defaults to the empty string (connect via <abbr><span class="acronym">DSN</span></abbr> instead).
Will accept <code>NULL</code> as an alias for the empty string.
Can be specified as a character vector of named (and/or unnamed) components,
from which a single string will be constructed (see the examples in
<code><a href="#topic+sqrlSource">sqrlSource</a></code>).
Setting <var>connection</var> resets <var>dsn</var>, unless <var>connection</var> contains the
&ldquo;&lt;dsn&gt;&rdquo; placeholder (see <code><a href="#topic+sqrlSource">sqrlSource</a></code>).
</p>
</dd>
<dt><var>DBMSencoding</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Names the encoding returned by the <abbr><span class="acronym">DBMS</span></abbr>.
Locked while the connection is open.
Defaults to the empty string (use encoding of the <span class="rlang"><b>R</b></span> locale).
Will accept <code>NULL</code> as an alias for the empty string.
</p>
</dd>
<dt><var>dec</var>:</dt><dd>
<p>A character string (typically a single character).
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Defines the decimal-place marker to be used when converting data from text to
numeric format.
The default value is <code>options("dec")</code>, as set by <span class="pkg">RODBC</span>.
</p>
</dd>
<dt><var>driver</var>:</dt><dd>
<p>A character string.
The name or file path of the <abbr><span class="acronym">ODBC</span></abbr> driver for the source (either
currently in use, or to be used when a channel is opened).
This determines the requisite dialect of <abbr><span class="acronym">SQL</span></abbr>.
Locked while the connection channel is open.
Defaults to the empty string.
Will accept <code>NULL</code> as an alias for the empty string.
</p>
</dd>
<dt><var>dsn</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcConnect</a></code>.
Specifies the data source name (<abbr><span class="acronym">DSN</span></abbr>) to connect to.
Can be a file path.
Overridden by <var>connection</var>, when that parameter is defined.
Setting <var>dsn</var> resets <var>connection</var>, unless <var>connection</var> contains the
&ldquo;&lt;dsn&gt;&rdquo; placeholder (see <code><a href="#topic+sqrlSource">sqrlSource</a></code>).
Setting <var>dsn</var> also sets <var>driver</var>, if the <abbr><span class="acronym">DSN</span></abbr> exists and the
associated driver can be identified.
Locked while the connection is open.
Defaults to the empty string.
Will accept <code>NULL</code> as an alias for the empty string.
</p>
</dd>
<dt><var>errors</var>:</dt><dd>
<p>A logical singleton.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Controls whether or not to throw <span class="rlang"><b>R</b></span> errors in response to
<abbr><span class="acronym">DBMS</span></abbr>/<abbr><span class="acronym">ODBC</span></abbr> exceptions.
The default value is <code>TRUE</code> (this differs from the <span class="pkg">RODBC</span> default).
</p>
</dd>
<dt><var>interface</var>:</dt><dd>
<p>A character string, or <code>NULL</code>.
The name of the <span class="pkg">SQRL</span> interface function for this data source (see
<code><a href="#topic+sqrlInterface">sqrlInterface</a></code>).
Setting <code>NULL</code> or &ldquo;remove&rdquo; removes the interface.
The default value is <code>NULL</code> (undefined).
</p>
</dd>
<dt><var>interpretDot</var>:</dt><dd>
<p>A logical singleton.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Locked while the connection is open.
Controls whether or not to interpret table names of the form &ldquo;aaa.bbb&rdquo; as
table &ldquo;bbb&rdquo; in schema/database &ldquo;aaa&rdquo;.
The default value is <code>TRUE</code>.
</p>
</dd>
<dt><var>lCollapse</var>:</dt><dd>
<p>A character string (typically a single character).
When a list-like object (typically an actual list) is pasted into <abbr><span class="acronym">SQL</span></abbr>,
that object is first collapsed to a single string, with <var>lCollapse</var>
separating each sequential pair of the object's elements (to each of which,
<var>aCollapse</var> will have first been applied).
The default value is the empty string (&ldquo;&rdquo;).
</p>
</dd>
<dt><var>library</var>:</dt><dd>
<p>A character vector.
Empty by default.
Holds named procedures, as defined by the user (see <code><a href="#topic+sqrlScript">sqrlScript</a></code> and
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>).
Setting to <code>NULL</code> empties the library.
</p>
</dd>
<dt><var>max</var>:</dt><dd>
<p>An integer.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Caps the number of rows fetched back to <span class="rlang"><b>R</b></span>.
The default value is 0 (meaning unlimited; retrieve all rows).
</p>
</dd>
<dt><var>na.strings</var>:</dt><dd>
<p>A character vector.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Specifies strings to be mapped to <code>NA</code> within character data.
The default value is &ldquo;NA&rdquo;.
</p>
</dd>
<dt><var>name</var>:</dt><dd>
<p>A character string.
The name of this <span class="pkg">SQRL</span> data source.
While often identical to the names of both the underlying <abbr><span class="acronym">ODBC</span></abbr>
data source and the <span class="pkg">SQRL</span> interface function, it need match neither in
general.
Multiple <span class="pkg">SQRL</span> sources may interface with the same <abbr><span class="acronym">ODBC</span></abbr> source.
This parameter is write once, and cannot be changed after creation of the
<span class="pkg">SQRL</span> source.
There is no default value.
</p>
</dd>
<dt><var>nullstring</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
The string with which to replace <code>SQL_NULL_DATA</code> items within character
columns.
The default value is <code>NA_character_</code>.
</p>
</dd>
<dt><var>ping</var>:</dt><dd>
<p>A character string.
Defines a reliable, trusted, <abbr><span class="acronym">SQL</span></abbr> statement, used by <span class="pkg">SQRL</span> to
verify source connections.
The initial value is <code>NULL</code>, which causes a simple,
<abbr><span class="acronym">DBMS</span></abbr>-dependent, statement to be determined the first time a connection
is opened.
Manual definition may be necessary in the event that <span class="pkg">SQRL</span> fails to
identify an appropriate statement for the particular <abbr><span class="acronym">DBMS</span></abbr> of the
source.
An invalid ping statement may lead to incorrect assessments of whether or not
the connection is open.
Manually setting <code>NULL</code> causes the statement to be redetermined the next
time a connection is opened.
Pings are submitted verbatim, without passing through <span class="pkg">SQRL</span>'s parser.
</p>
</dd>
<dt><var>prompt</var>:</dt><dd>
<p>A character string (typically a single character).
Defines an indicator to be applied to the <span class="rlang"><b>R</b></span> command prompt when the connection
is open and <var>visible</var> is <code>TRUE</code>.
Defaults to the first character of <var>name</var>.
Single-letter indicators are recommended since, if two sources are open and one
indicator is a substring of the other, then <span class="pkg">SQRL</span> may fail to correctly
update the prompt when one source is closed.
Can be set to an empty string, in which case nothing is applied to the prompt.
Will accept <code>NULL</code> as an alias for the empty string.
</p>
</dd>
<dt><var>pwd</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcConnect</a></code>.
Specifies a password to use at the next authentication request.
This need not match the password that was used to open the current channel.
Defaults to the empty string (interpreted as do not supply a password to the
<abbr><span class="acronym">ODBC</span></abbr> driver).
Will accept <code>NULL</code> as an alias for the empty string.
Write-only.
</p>
</dd>
<dt><var>readOnlyOptimize</var>:</dt><dd>
<p>A logical singleton.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies whether or not to optimise the <abbr><span class="acronym">ODBC</span></abbr> connection for read-only
access.
Locked while the connection is open.
The default value is <code>FALSE</code>.
</p>
</dd>
<dt><var>result</var>:</dt><dd>
<p>An arbitrary object, being the final outcome of the last successful query or
procedure.
Read-mostly.
Can be set to <code>NULL</code> (its default value), to free memory.
</p>
</dd>
<dt><var>retry</var>:</dt><dd>
<p>A logical singleton, <code>TRUE</code> by default.
Should a query fail due to an apparent network outage or other unexpected loss
of connection, a <var>ping</var> (above) is made to verify that occurrence before
reconnecting and resubmitting the failed query.
This process is automatic and silent, unless manual input is required for
authentication.
However, as any temporary tables will not have survived the initial connection
loss, a non-existence error may eventually occur.
Failure of the second attempt is always fatal (no third attempt will be made).
Changing <var>retry</var> to <code>FALSE</code> disables this action.
</p>
</dd>
<dt><var>rows_at_time</var>:</dt><dd>
<p>A positive integer, between 1 and 1024.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies the number of rows to fetch at a time when retrieving query results.
Locked while the connection is open.
The default value is 100.
Manually setting 1 may be necessary with some <abbr><span class="acronym">ODBC</span></abbr> drivers.
</p>
</dd>
<dt><var>scdo</var>:</dt><dd>
<p>A logical singleton.
Controls <span class="pkg">SQRL</span> parser behaviour.
When <code>TRUE</code> (the default), the parser splits multi-statement scripts on
what it considers to be statement-terminating semicolons; submitting the
individual statements as each such semicolon is encountered.
This may fail in the presence of <abbr><span class="acronym">DBMS</span></abbr>-specific procedural-language
syntax.
When <code>FALSE</code> (the fallback mode), sequential statements are delimited only
by <abbr><span class="acronym">SQRL</span></abbr> tags, especially the <code>&lt;do&gt;</code> tag (see
<code><a href="#topic+sqrlScript">sqrlScript</a></code>).
</p>
</dd>
<dt><var>stringsAsFactors</var>:</dt><dd>
<p>A logical singleton.
Argument to <code><a href="RODBC.html#topic+sqlQuery">RODBC::sqlQuery</a></code>.
Controls the conversion of character columns to factor columns within query
results, excluding those columns covered by <var>as.is</var>.
The default value is <code>FALSE</code>.
</p>
</dd>
<dt><var>tabQuote</var>:</dt><dd>
<p>A character vector of length 0, 1, or 2, or <code>NULL</code>.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcDriverConnect</a></code>.
Specifies the quote character(s) for table names.
A vector of length zero means no quotes, of length one means apply the specified
quote character at both ends of a name, and of length two means apply the first
character to the start of the name and the second character to the end of the
name.
Locked while the connection is open.
Defaults to the value of <var>colQuote</var>.
</p>
</dd>
<dt><var>uid</var>:</dt><dd>
<p>A character string.
Argument to <code><a href="RODBC.html#topic+odbcConnect">RODBC::odbcConnect</a></code>.
Specifies the user identity (<abbr><span class="acronym">UID</span></abbr>, user name) to use on the data
source.
Locked while the connection is open.
Defaults to the local name of the <span class="rlang"><b>R</b></span> user (<code>Sys.info()["user"]</code>).
Will accept <code>NULL</code> as an alias for the empty string (which is interpreted
as do not pass a <abbr><span class="acronym">UID</span></abbr> to the <abbr><span class="acronym">ODBC</span></abbr> driver).
May be inaccurate when the <abbr><span class="acronym">UID</span></abbr> is specified within a <abbr><span class="acronym">DSN</span></abbr>.
</p>
</dd>
<dt><var>verbose</var>:</dt><dd>
<p>A logical singleton.
Controls whether or not to display verbose output during query submission.
Intended mainly for debugging.
The default value is <code>FALSE</code> (verbose output disabled).
Verbose output is always disabled within non-interactive sessions.
</p>
</dd>
<dt><var>visible</var>:</dt><dd>
<p>A logical singleton.
Toggles display of the <var>wintitle</var> and <var>prompt</var> indicators (while an
open connection channel exists to the source).
The default value is <code>FALSE</code> (do not show indicators).
Changing this to <code>TRUE</code> authorises modification of the &ldquo;prompt&rdquo;
global option (see <code><a href="base.html#topic+options">base::options</a></code>).
</p>
</dd>
<dt><var>wintitle</var>:</dt><dd>
<p>A character string, possibly empty.
Will accept <code>NULL</code> as an alias for the empty string.
Defines an indicator that, unless empty, is displayed on the <span class="rlang"><b>R</b></span> window title bar
while a connection channel is open to the source, and provided <var>visible</var> is
<code>TRUE</code>.
An asterisk (*) is appended to the indicator while a query is running on the
source, and a plus-sign (+) is appended while results are being retrieved from
it.
A question mark (?) is appended during connection-testing pings, but these are
usually fleeting.
If two sources are open and one indicator is a substring of the other, then
<span class="pkg">SQRL</span> may fail to correctly update the title when one source is closed.
Only works with &lsquo;<span class="file">R.exe</span>&rsquo;, &lsquo;<span class="file">Rterm.exe</span>&rsquo; and &lsquo;<span class="file">Rgui.exe</span>&rsquo;, and then
only while running on a &ldquo;Windows&rdquo; operating system.
Works with both <abbr><span class="acronym">MDI</span></abbr> and <abbr><span class="acronym">SDI</span></abbr> modes, but does not work with
&ldquo;RStudio&rdquo;.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Each <span class="pkg">SQRL</span> data source has its own set of the above parameters.
Altering the value of a parameter (e.g., <var>stringsAsFactors</var>) for one source
does not affect the value for any other source.
Use <code><a href="#topic+sqrlAll">sqrlAll</a></code> to make blanket changes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlUsage">sqrlUsage</a></code>,
<span class="pkg"><a href="RODBC.html#topic+RODBC-package">RODBC</a></span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a new source.
sqrlSource("thoth", dbcname = "Karnak",
           driver = "Teradata Database ODBC Driver 16.10")

# Retrieve all parameter values.
thoth("config")

# Retrieve a (fixed) subset of parameter values.
thoth("settings")

# Retrieve a single (named) parameter value.
thoth("as.is")

# Various means of setting a value.
thoth(as.is = TRUE)
thoth("as.is" = TRUE)
thoth("as.is", TRUE)
thoth("as.is", "TRUE")
thoth("as.is TRUE")

# If you wanted the string 'TRUE'.
thoth(as.is = "TRUE")
thoth("as.is 'TRUE'")

# Various means of setting multiple values.
thoth(as.is = TRUE, stringsAsFactors = FALSE)
thoth(list(as.is = TRUE, stringsAsFactors = FALSE))
thoth(config = list(as.is = TRUE, stringsAsFactors = FALSE))
</code></pre>

<hr>
<h2 id='sqrlScript'>
Hybrid Script Syntax
</h2><span id='topic+sqrlScript'></span>

<h3>Description</h3>

<p>This material does not describe a function, but (instead) the <abbr><span class="acronym">SQRL</span></abbr>
scripting syntax for <abbr><span class="acronym">SQL</span></abbr> with embedded <span class="rlang"><b>R</b></span>.
</p>
<p>For instructions on how to submit (run) these scripts from file, refer to
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>.
</p>


<h3>Script #01 (Pure SQL)</h3>

<pre>
use database;
select * from table;
</pre>


<h4>Commentary on Script #01</h4>

<p>Multi-statement <abbr><span class="acronym">SQL</span></abbr> scripts can be taken directly from
&lsquo;<span class="file">SQL Developer</span>&rsquo; (or similar application), and (usually) run without
modification.
The <span class="pkg">SQRL</span> parser identifies statement-terminating semicolons, and submits
each statement in turn, as those semicolons (or the end of the script) are
encountered.
</p>



<h3>Script #02 (SQL, with R in it)</h3>

<pre>
select isotope from periodic_table
where atomic_number = &lt;R&gt; Z &lt;/R&gt;
</pre>


<h4>Commentary on Script #02</h4>

<p>Scripts can be parameterised, via embedded <span class="rlang"><b>R</b></span>.
In <abbr><span class="acronym">SQRL</span></abbr>, <abbr><span class="acronym">XML</span></abbr>-style tags mark the beginning and end of an <span class="rlang"><b>R</b></span>
block.
As shown in <code><a href="#topic+sqrlUsage">sqrlUsage</a></code>, values can either be passed explicitly, or
inherited from the calling environment.
Embedded <span class="rlang"><b>R</b></span> is not restricted to the insertion of values for filtering, and can
be used to specify column names, clauses, or entire <abbr><span class="acronym">SQL</span></abbr> statements.
</p>
<p>Tags are not case sensitive.
</p>



<h3>Script #03 (Comments, and Arbitrary R)</h3>

<pre>
/* SQL-comment within SQL */
-- SQL-comment within SQL
select
  &lt;R&gt;
    /* SQL-comment within R */
    -- SQL-comment within R
    # R comment within R
    letter &lt;- sample(letters, 1)
    paste0("'", letter, "'")
  &lt;/R&gt;
</pre>


<h4>Commentary on Script #03</h4>

<p>The parser supports <span class="rlang"><b>R</b></span> comments, and two kinds of <abbr><span class="acronym">SQL</span></abbr> comments.
For syntax-highlighting purposes, <abbr><span class="acronym">SQL</span></abbr> comments may be used within <span class="rlang"><b>R</b></span>
sections (but <span class="rlang"><b>R</b></span> comments cannot be used within <abbr><span class="acronym">SQL</span></abbr>).
Since <code>a -- b</code> is legitimate <span class="rlang"><b>R</b></span>, it would need to be rewritten with a space
between the minus signs, or as <code>a + b</code>, to avoid being interpreted as a
comment.
</p>
<p>Otherwise-arbitrary <span class="rlang"><b>R</b></span> script is allowed within (tag-delimited) <span class="rlang"><b>R</b></span> sections.
Evaluation of such <span class="rlang"><b>R</b></span> script takes place in a temporary child environment of the
calling environment.
The final result of that evaluation is then pasted into the surrounding
<abbr><span class="acronym">SQL</span></abbr>, before its submission.
This mechanism cannot be used to insert additional tags into the <abbr><span class="acronym">SQRL</span></abbr>
script.
</p>



<h3>Script #04 (R, out of SQL)</h3>

<pre>
&lt;R&gt;
  threshold &lt;- 9000
  sq &lt;- function(x) paste0("'", x, "'")
&lt;do&gt; -- This tag terminates the R section.

&lt;R&gt;
  if (!exists("date", inherits = FALSE))
    date &lt;- format(Sys.Date(), "%Y-%m-%d");
; -- This semicolon terminates the R section.

select * from database.table
where event_date = &lt;R&gt; sq(date) &lt;/R&gt;
and event_size &gt; &lt;R&gt; threshold &lt;/R&gt;
</pre>


<h4>Commentary on Script #04</h4>

<p>As in scripts #02 and #03, when an <span class="rlang"><b>R</b></span> section ends with <code>&lt;/R&gt;</code>, the result
of evaluating that section is pasted into the surrounding <abbr><span class="acronym">SQL</span></abbr> (or
implied <abbr><span class="acronym">SQL</span></abbr>, if those surroundings are blank).
However, an <span class="rlang"><b>R</b></span> section can also be terminated by a <code>&lt;do&gt;</code> tag, or by a
non-syntactical semicolon (that being one with nothing but whitespace between it
and the previous semicolon, newline, or <code>&lt;R&gt;</code> tag).
Such sections are evaluated in the same way as those ending in <code>&lt;/R&gt;</code> tags,
but the results are not pasted into <abbr><span class="acronym">SQL</span></abbr>.
These sections can only appear between, not within, <abbr><span class="acronym">SQL</span></abbr> statements.
</p>
<p>In this script, the first out-of-<abbr><span class="acronym">SQL</span></abbr> <span class="rlang"><b>R</b></span> section defines a numerical
constant, and also a function for wrapping strings in single quotes.
The second out-of-<abbr><span class="acronym">SQL</span></abbr> <span class="rlang"><b>R</b></span> section supplies a default value for a
variable, <var>date</var>, if none was explicitly passed in (see
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>).
These two <span class="rlang"><b>R</b></span> sections could be combined into one.
The function and values from these sections are applied in the subsequent
<abbr><span class="acronym">SQL</span></abbr>.
</p>



<h3>Script #05 (Temporary Parameter Settings)</h3>

<pre>
&lt;with&gt;
  na.strings = c('NA', "-")   -- comment
  x &lt;- 5; max = x + 1         /* comment */
  verbose = TRUE               # comment
  as.is = "configfile.txt"     # read from file
&lt;/with&gt;

-- Run this query with the above settings.
select * from database.table
</pre>


<h4>Commentary on Script #05</h4>

<p>Tags <code>&lt;with&gt;</code> and <code>&lt;/with&gt;</code> delimit special-purpose blocks of <span class="rlang"><b>R</b></span>.
They are used to set temporary parameter values, which remain in effect only
for the duration of the script.
To be clear, temporary values survive beyond the <code>&lt;/with&gt;</code> tag, but not
beyond the end of the script.
The exception is that temporary values of <var>ping</var> are retained if and only if
the connection would otherwise be left open without a defined <var>ping</var>.
</p>
<p>This mechanism only works for a limited number of parameters:
<var>aCollapse</var>, <var>as.is</var>, <var>buffsize</var>, <var>dec</var>, <var>errors</var>,
<var>lCollapse</var>, <var>max</var>, <var>na.strings</var>, <var>nullstring</var>, <var>ping</var>,
<var>pwd</var>, <var>retry</var>, <var>scdo</var>, <var>stringsAsFactors</var>, and <var>verbose</var>.
</p>



<h3>Script #06 (Procedural Language Blocks)</h3>

<pre>
select 1 from dual; -- This semicolon terminates the statement.

declare
  x integer := 0;
begin
  for i in 1..10 loop
    x := x + 1;
    if x &gt; 7 then
      x := 0;
    else
      begin
        null;
      end;
    end if;
  end loop;
end; -- This semicolon terminates the block.

select 2 as N from dual
</pre>


<h4>Commentary on Script #06</h4>

<p>As with statement-terminating semicolons (refer to script #01), the <span class="pkg">SQRL</span>
parser attempts to identify procedural-language block-terminating semicolons,
and submits each such block as those semicolons are encountered.
The parser also submits (when necessary) upon reaching the end of the script.
Although trailing semicolons are not usually mandatory for <abbr><span class="acronym">SQL</span></abbr>
statements, they usually are mandatory at the end of a procedural block.
</p>
<p>If you have a script that came with forward-slashes, /, at the end
of procedural blocks, those slashes will normally need to be removed (as, say,
&lsquo;<span class="file">SQL Developer</span>&rsquo; would do for you).
</p>
<p>When a script contains multiple statements and/or blocks, only the final result
is returned.
In this case, that would be <code>data.frame(N = 2L)</code>.
</p>



<h3>Script #07 (Parser Control)</h3>

<pre>
-- Change parser to fallback mode.
&lt;with&gt;
  scdo = FALSE
&lt;/with&gt;

-- An outside-of-SQL R section.
&lt;R&gt;
  N &lt;- 2;
&lt;do&gt; -- This tag terminates the section.

-- The default (scdo = TRUE) SQRL parser would
-- not find the end of this procedural block.
begin
  null;
end /**/ ;
&lt;do&gt; -- This tag terminates the block.

select 1 from dual; -- Semicolon ignored.
&lt;do&gt; -- This tag terminates the statement.

select &lt;R&gt; N &lt;/R&gt; from dual
</pre>


<h4>Commentary on Script #07</h4>

<p>While the parser detects terminal semicolons at the ends of <abbr><span class="acronym">SQL</span></abbr>
statements and <span class="rlang"><b>R</b></span> sections, it remains unsophisticated, and ignorant of
<abbr><span class="acronym">DBMS</span></abbr>-specific procedural-language syntaxes.
That being the case, if you are working with procedural-language extensions to
<abbr><span class="acronym">SQL</span></abbr>, sooner or later the parser will fail to detect the end of a
block.
Presently, a simple thing that causes this is the presence of a comment between
an <code>end</code> and its semicolon (as appears, above).
</p>
<p>Setting the <var>scdo</var> parameter to FALSE causes the parser to ignore semicolons
and to conclude (out of <abbr><span class="acronym">SQL</span></abbr>) <span class="rlang"><b>R</b></span> sections, <abbr><span class="acronym">SQL</span></abbr> statements,
and procedural blocks only upon encountering a <code>&lt;do&gt;</code> tag.
This provides a robust multi-statement capability when need be, but will
require appropriate modification of any scripts originally developed for some
other application.
</p>
<p>Note that <code>&lt;do&gt;</code> tags function irrespective of the <var>scdo</var> setting.
That being the case, the use of these can be preferable to semicolons when
a <abbr><span class="acronym">SQRL</span></abbr> script is developed from scratch.
When <var>scdo</var> is <code>TRUE</code>, and a terminating semicolon is followed by a
<code>&lt;do&gt;</code> tag, with nothing but whitespace between them, they are treated as a
single <code>&lt;do&gt;</code> (only one submission is made).
An implied <code>do</code> tag exists at the end of every script.
</p>



<h3>Script #08 (Manipulation of Results)</h3>

<pre>
select
  calDate, Snowfall
from
  Weather.SparseDailySnowfall
where
  calYear = &lt;R&gt; year &lt;/R&gt;

-- Submit the above, assign the result to 'a',
-- and immediately begin an R section.
&lt;result -&gt; var&gt;

  names(var)[names(var) == "calDate"] &lt;- "Date"
  var$Snowfall &lt;- as.numeric(var$Snowfall)
  first &lt;- as.Date(paste(year, 1, 1, sep = "-"))
  last &lt;- as.Date(paste(year, 12, 31, sep = "-"))
  alldates &lt;- data.frame(Date = seq(first, last, 1))
  merge(alldates, var, all.x = TRUE)
</pre>


<h4>Commentary on Script #08</h4>

<p>A <code>&lt;result&gt;</code> tag acts as a combination of the <code>&lt;do&gt;</code> and <code>&lt;R&gt;</code>
tags, wherein the result of the query is assigned to an object within the
working (script evaluation) environment.
Any syntactically valid <span class="rlang"><b>R</b></span> variable name could be used in place of <var>var</var>.
Whilst the main tag is not case sensitive, the name of the variable is.
</p>
<p>An <span class="rlang"><b>R</b></span> section begins immediately after the <code>&lt;result&gt;</code> tag.
This can be useful when preferred <span class="rlang"><b>R</b></span> column names are reserved <abbr><span class="acronym">SQL</span></abbr>
keywords (such as &ldquo;date&rdquo;), when dates come back in unconventional
formats (and need conversion), when strict type-conversion control is required
(typically in combination with <code>as.is = TRUE</code>), or when data is sparse
(zero-valued entries are not stored) and results need to be expanded to
explicitly include the implied zero-valued data.
The net effect is a single script, combining <abbr><span class="acronym">SQL</span></abbr> data extraction with
<span class="rlang"><b>R</b></span> reformatting.
</p>
<p>Using &ldquo;null&rdquo; or &ldquo;NULL&rdquo; as the variable name stops assignment of
the query result (but the <span class="rlang"><b>R</b></span> section still begins).
</p>
<p>Only the final value of any <abbr><span class="acronym">SQRL</span></abbr> script is returned.
In this example, that value is the merged data frame.
</p>
<p>Note that <code>&lt;result&gt;</code> tags cannot be used to conclude <span class="rlang"><b>R</b></span> sections.
Also, <span class="rlang"><b>R</b></span> sections beginning with <code>&lt;result&gt;</code> tags cannot end in <code>&lt;/R&gt;</code>.
</p>
<p>When <var>scdo</var> is <code>TRUE</code>, and a terminating semicolon is followed by a
<code>&lt;result&gt;</code> tag, with nothing but whitespace between them, they are treated
as a single <code>&lt;result&gt;</code> tag (only one query submission is made).
However, when a <code>&lt;do&gt;</code> tag is followed by a <code>&lt;result&gt;</code> tag, two
submissions are made, irrespective of <var>scdo</var>.
First, the query before the <code>&lt;do&gt;</code> is submitted, and then the (blank) query
between the <code>&lt;do&gt;</code> and the <code>&lt;return&gt;</code>.
In <span class="pkg">SQRL</span>, blank queries (blank <abbr><span class="acronym">SQL</span></abbr> statements) are always
allowed, and return no value.
</p>



<h3>Script #09 (Feedback of Intermediate Results)</h3>

<pre>
select distinct customer_number from our.customers
where town in (&lt;R&gt; paste0("'", towns, "'") &lt;/R&gt;)

&lt;result -&gt; z&gt;; -- Same thing as &lt;result -&gt; z&gt;&lt;do&gt;

select sum(transactions) from online.orders
where customer_number in (&lt;R&gt; z$customer_number &lt;/R&gt;)
</pre>


<h4>Commentary on Script #09</h4>

<p>This script takes one parameter, <var>towns</var>, a character vector.
By default, atomic vectors are pasted into <abbr><span class="acronym">SQL</span></abbr> as comma-separated
values.
The first query returns a data frame, which we save, as <var>z</var>, but have no
need to manipulate.
Its (integer-valued) <var>customer_number</var> column is then applied to the second
query, once again as comma-separated values.
Only the final result (of the second query) is returned.
</p>
<p>Of course, this particular example could instead have been implemented with a
join, or temp table.
</p>
<p>The pasting behaviour of atomic objects is controlled by the <var>aCollapse</var>
parameter.
Similarly, the pasting behaviour of list-like objects is controlled by the
<var>lCollapse</var> parameter (which defaults to the empty string).
To restore <span class="pkg">SQRL</span>-0.6.3 pasting rules, insert
<code>&lt;with&gt; aCollapse = "\n"; lCollapse = ", " &lt;/with&gt;</code> at the top of a script.
See <code><a href="#topic+sqrlUsage">sqrlUsage</a></code> and <code><a href="#topic+sqrlParams">sqrlParams</a></code> for further detail.
</p>



<h3>Script #10 (Combining Data Sources)</h3>

<pre>
&lt;R&gt;
  n &lt;- OtherSource("select distinct customer_number ",
                   "from our.customers where town in "
                   "(" paste0("'", towns, "'") ")")
&lt;do&gt;

select sum(transactions) from online.orders
where customer_number in (&lt;R&gt; n$customer_number &lt;/R&gt;)
</pre>


<h4>Commentary on Script #10</h4>

<p>This is a repeat of script #09, except now the tables of the first and second
queries are hosted on two entirely separate data sources.
The function <code>OtherSource</code> is the <span class="pkg">SQRL</span> interface to the data source
of the first query, while this script should be run from the interface to the
final source.
Again, there are other ways to do this, but the general idea is for the main <span class="rlang"><b>R</b></span>
script (performing the modelling and analysis) to make a single call
&ldquo;get me this data&rdquo;, without clutter, or concern for the true horror of
where that data comes from.
</p>



<h3>Script #11 (The sqrl Function)</h3>

<pre>
&lt;R&gt;
  -- Check this is the intended source.
  stopifnot(sqrl("name") == "MySource")

  -- Remember initial parameter values.
  initials &lt;- sqrl("settings")

  -- Set some parameter values.
  sqrl(stringsAsFactors = FALSE,
       wintitle = "[MySource]",
       visible = TRUE)
;

-- Submit the query, record the result.
select * from database.table
&lt;result -&gt; out&gt;;

&lt;R&gt;
  -- Restore initial parameter values.
  sqrl(initials)

  -- Return the query result.
  out
</pre>


<h4>Commentary on Script #11</h4>

<p>The function <code>sqrl(...)</code> is a special interface that is automatically
defined into the temporary script-evaluation (working) environment.
It acts as a cut-down <code><a href="#topic+sqrlAll">sqrlAll</a></code>, relaying its
arguments only to whichever <span class="pkg">SQRL</span> data source is executing the script.
It works even when the name of the invoking interface function changes, or
when that interface function does not exist.
Consequently, <code>sqrl</code> should be adopted in preference to hard-coding
interface names into scripts.
</p>
<p>Here, the <code>sqrl</code> function is first used to provide an assert, which, in
this case, verifies the script is being run only on the intended data source.
A second call then takes a snapshot of the current <span class="pkg">RODBC</span>/<span class="pkg">SQRL</span>
parameter settings (the <code>settings</code> command is described in
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>).
A third call then sets new values for three of those parameters, prior to
submission of the <abbr><span class="acronym">SQL</span></abbr> query.
</p>
<p>Due to <span class="pkg">SQRL</span>'s set-and-forget approach, these values are persistent, and
(unless they are changed again) will remain in effect after execution of the
script has completed.
That being the case, another call of <code>sqrl</code> is made after the query, in
order to restore the original parameter values.
</p>
<p>Note that (temporary) parameter values set via <code>&lt;with&gt; ... &lt;/with&gt;</code> take
precedence over (persistent) values set via <code>sqrl(...)</code>, irrespective of
the order in which those settings are made within the script.
Also, whilst (for example) <code>sqrl(max = 1)</code> sets the persistent value for
parameter <var>max</var>, <code>sqrl("max")</code> returns the value currently in effect
(which might be a temporary value).
Hence, for purposes of setting script-specific parameter values, using
<code>&lt;with&gt;</code> is, when possible, generally preferable to calling <code>sqrl</code>.
</p>
<p>As shown in script #17, the <code>sqrl</code> function can also be used to make nested
queries (its arguments could just as easily be another script).
</p>
<p>When a script is being run from some particular interface, explicit calls to
that same interface function (as opposed to <code>sqrl</code>) are normally blocked.
Calls to <code><a href="#topic+sqrlAll">sqrlAll</a></code>, <code><a href="#topic+sqrlInterface">sqrlInterface</a></code>,
<code><a href="#topic+sqrlOff">sqrlOff</a></code>, <code><a href="#topic+sqrlSource">sqrlSource</a></code>, and <code><a href="#topic+sqrlSources">sqrlSources</a></code>
are also normally blocked.
If you really want a way around these blocks, calls can be made to
<code>SQRL::sqrlAll</code>, instead of just <code>sqrlAll</code>, and so on.
Alternatively, <code>&lt;R&gt; rm("sqrlAll") &lt;do&gt;</code> (et cetera) removes the block (this
also works for unblocking the interface function).
</p>



<h3>Script #12 (Closing Connections)</h3>

<pre>
-- Ensure readOnlyOptimise is TRUE.
&lt;R&gt;
  if (!sqrl("readOnlyOptimize"))
  {
    sqrl("close")
    sqrl(readOnlyOptimize = TRUE)
  }
&lt;do&gt;

-- Pull data (reopening is automatic).
select * from database.table;

-- Close the connection.
&lt;close&gt;
</pre>


<h4>Commentary on Script #12</h4>

<p>Many communications parameters are &ldquo;locked while open&rdquo;, and cannot be
changed while a connection (channel) exists to the source (see
<code><a href="#topic+sqrlParams">sqrlParams</a></code>).
In this example, we want a particular value for one such parameter, namely
<var>readOnlyOptimize</var>.
If its value needs changing, we must first ensure the channel is closed.
Within the <span class="rlang"><b>R</b></span> section, this is achieved with <code>sqrl("close")</code> (see
<code><a href="#topic+sqrlUsage">sqrlUsage</a></code>).
</p>
<p>When the <abbr><span class="acronym">SQL</span></abbr> query is submitted, <span class="pkg">SQRL</span> will automatically open a
new connection, if need be.
</p>
<p>After the data is pulled, the <code>&lt;close&gt;</code> tag closes the channel (because, in
this example, we do not want to leave it open).
Unlike <code>&lt;R&gt;sqrl("close")&lt;do&gt;</code>, <code>&lt;close&gt;</code> tags return no value of their
own, which means the final value of this <abbr><span class="acronym">SQRL</span></abbr> script is still that of
the query (as we require).
</p>
<p>Be aware that <code>&lt;close&gt;</code> does not imply <code>&lt;do&gt;</code>, and it is an error to
use <code>&lt;close&gt;</code> in the presence of partially-formed, or unsubmitted,
<abbr><span class="acronym">SQL</span></abbr>.
Conversely, <code>&lt;R&gt;sqrl("close")&lt;/R&gt;</code> is allowed within <abbr><span class="acronym">SQL</span></abbr>.
</p>
<p>An alternative to putting <code>&lt;close&gt;</code> at the end of a script is to set the
<var>autoclose</var> parameter to <code>TRUE</code> (see <code><a href="#topic+sqrlParams">sqrlParams</a></code>).
Placing <code>&lt;close&gt;</code> at the beginning of a script can be used to ensure no
temporary tables are in existence (when no better mechanism is available).
</p>
<p>When user-input is required for authentication on the opening of a new channel,
connection closures should be kept to a bare minimum.
</p>



<h3>Script #13 (Returns)</h3>

<pre>
-- This selects 1 (the result of the embedded R expression).
select &lt;R&gt; return(1); 2 &lt;/R&gt;

-- This return doesn't exit the script either (only the R section).
&lt;R&gt;
  return(1)
  print("this won't be printed")
&lt;do&gt;

-- Pull from a temporary table, and save the result.
select some_columns from temp_table
&lt;result -&gt; a&gt;;

-- Drop the temp table (this returns a value).
drop temp_table;

-- Return the value of interest (exit the script).
&lt;return (a)&gt;

-- This is unreachable.
select 1
</pre>


<h4>Commentary on Script #13</h4>

<p>The difference between a <code>&lt;return (a)&gt;</code> and <code>&lt;R&gt;return(a)&lt;do&gt;</code>, is
that the former exits the <abbr><span class="acronym">SQRL</span></abbr> script, while the latter only exits
from the (embedded) <span class="rlang"><b>R</b></span> section (back into <abbr><span class="acronym">SQL</span></abbr>), before continuing with
the script.
</p>
<p>Almost any valid <span class="rlang"><b>R</b></span> expression is allowed between the (mandatory) parentheses of
a <code>&lt;return&gt;</code> tag (see script #03).
Note that <code>&lt;return&gt;</code> tags are not recognised within <span class="rlang"><b>R</b></span> sections.
Also, <code>&lt;return&gt;</code> tags do not imply <code>&lt;do&gt;</code>, and it is an error to
attempt a <code>&lt;return&gt;</code> within partially-formed (unsubmitted) <abbr><span class="acronym">SQL</span></abbr>.
Because <code>x &lt;- y</code> returns invisibly, so too do <code>&lt;R&gt; x &lt;- y &lt;do&gt;</code> and
<code>&lt;return (x &lt;- y)&gt;</code> (see example script #16).
</p>
<p>The next example shows how <code>&lt;return&gt;</code> tags become much more useful when
combined with conditional expressions.
</p>



<h3>Script #14 (If, Else If, Else)</h3>

<pre>
-- Submit this when we have a 9-digit code.
&lt;if (nchar(code) == 9)&gt;
  select category from item_category
  where long_item_code = &lt;R&gt; code &lt;/R&gt;
  &lt;result -&gt; k&gt; k &lt;- as.integer(k) &lt;do&gt;

-- Submit this when we have a 6-digit code.
&lt;else if (nchar(code) == 6)&gt;
  select category from item_category
  where short_item_code = &lt;R&gt; code &lt;/R&gt;
  &lt;result -&gt; k&gt; k &lt;- as.integer(k) &lt;do&gt;

-- Exit here when we have neither
-- (because the next query would fail).
&lt;else&gt;
  &lt;return (NULL)&gt;
&lt;/if&gt;

-- Obtain all items in the same category,
-- in the original (long or short) format.
select
  category,
  &lt;if (nchar(code) == 9)&gt;
    long_item_code
  &lt;else&gt;
    short_item_code
  &lt;/if&gt;
from item_category
where category = &lt;R&gt; k &lt;/R&gt;
</pre>


<h4>Commentary on Script #14</h4>

<p>In this example, we have a table of (say) stock items, each of which has both a
long (9 digit) and short (6 digit) identity code, and is assigned to some kind
of category (with another integer identifier).
The script takes a single integer argument, <var>code</var>, which might be in either
the long or short format.
</p>
<p>The <code>&lt;if&gt;</code> and <code>&lt;else if&gt;</code> tags are used to submit an appropriate
query, according to the type of identity code supplied.
In the event that the code is of an unrecognised type, the <code>&lt;else&gt;</code> tag is
used, with <code>&lt;return&gt;</code>, to exit cleanly (without submitting any query).
Provided that the code is of a recognised type, a second query is submitted,
wherein <code>&lt;if&gt;</code> and <code>&lt;else&gt;</code> control which column is selected.
</p>
<p>In the final query, the appropriate column could instead have been named from
within <code>&lt;R&gt;</code> and <code>&lt;/R&gt;</code> tags, but the earlier conditional submission
and conditional return cannot easily be achieved in that way.
Essentially arbitrary <span class="rlang"><b>R</b></span> is allowed between the (mandatory) parentheses of an
<code>&lt;if&gt;</code> or <code>&lt;else if&gt;</code> tag (see script #03), but the final result of
evaluating that <span class="rlang"><b>R</b></span> must be either <code>TRUE</code> or <code>FALSE</code>.
None of these tags are recognised within <span class="rlang"><b>R</b></span> sections.
To enable their intra-statement application (as in the final query of the
example script), none of these tags imply <code>&lt;do&gt;</code>.
The space in <code>else if</code> is optional (i.e., <code>elseif</code> is equally valid).
</p>



<h3>Script #15 (Caching)</h3>

<pre>
-- If we already have a cached copy of the
-- data, return that.
&lt;if (exists(.cached, .GlobalEnv))&gt;
  &lt;return (get(.cached, .GlobalEnv))&gt;
&lt;/if&gt;

-- Otherwise, submit the query and cache the
-- result before returing it.
select * from table
&lt;result -&gt; x&gt;
  assign(.cached, x, .GlobalEnv)
  x
</pre>


<h4>Commentary on Script #15</h4>

<p>In this example, the result of a large query is cached locally, with <code>&lt;if&gt;</code>
and <code>&lt;return&gt;</code> logic being used to return that cached result should the
script be run again.
</p>
<p>This is most useful when the data changes infrequently, the query takes a long
time to run, and the script is stored as a procedure in the library (see script
#18).
</p>



<h3>Script #16 (While Loops)</h3>

<pre>
&lt;R&gt;
  batch &lt;- split(ID, ceiling(seq_along(ID) / 1000))
  x &lt;- NULL
  i &lt;- 1
&lt;do&gt;

-- Pull and accumulate results, a thousand at a time.
&lt;while (i &lt;= length(batch))&gt;
  select idnumber, name from identity_lookup
  where idnumber in (&lt;R&gt; batch[[i]] &lt;/R&gt;)
  &lt;result -&gt; y&gt;
    i &lt;- i + 1
    x &lt;- rbind(x, y)
  &lt;do&gt;
&lt;/while&gt;
</pre>


<h4>Commentary on Script #16</h4>

<p>In this example, we have a script with a single argument; <code>ID</code>, a vector of
integer codes.
Supposing that vector might be too long for the <abbr><span class="acronym">SQL</span></abbr> <code>in</code>
operator, a <code>&lt;while&gt;</code> loop is used to pull the results in batches.
</p>
<p>Essentially arbitrary <span class="rlang"><b>R</b></span> is allowed between the (mandatory) parentheses of a
<code>&lt;while&gt;</code> tag (see script #03), but the final result of evaluating it must
be either <code>TRUE</code> or <code>FALSE</code>.
As with the <code>&lt;if&gt;</code> family, <code>&lt;while&gt;</code> and <code>&lt;/while&gt;</code> tags are not
recognised within <span class="rlang"><b>R</b></span> sections, and do not imply <code>&lt;do&gt;</code>.
Ordinarily, loops over <abbr><span class="acronym">SQL</span></abbr> should be avoided, or used only as a last
resort, but there are use-cases (see script #18), including for the insertion of
rows.
</p>
<p>Referring back to script #13, the final result of script #16 (that of
<code>x &lt;- rbind(x, y)</code>) is invisible.
If visible output is required, <code>&lt;R&gt;x</code> or <code>&lt;return (x)&gt;</code> could be
appended to the script.
</p>
<p>The parser is simple, and does not verify or enforce correct nesting structure.
Unintuitive output may appear when nesting violations occur.
</p>



<h3>Script #17 (Procedures)</h3>

<pre>
&lt;proc "random patients"&gt;
  select patient_number
    from patient_details
    order by rand()
    limit &lt;R&gt; N &lt;/R&gt;
  &lt;result -&gt; a&gt;
    a[, 1L]
&lt;/proc&gt;

select days_in_hospital
from patient_history
where patient_number in
  (&lt;R&gt; sqrl("random patients", N = 200) &lt;/R&gt;)
</pre>


<h4>Commentary on Script #17</h4>

<p>It is possible to define reusable <abbr><span class="acronym">SQRL</span></abbr> procedures within (between)
<code>&lt;proc&gt;</code> and <code>&lt;/proc&gt;</code> tags.
Here, a (parameterised) procedure is employed as a nested-query alternative to
the sequential feedback mechanism of script #09.
</p>
<p>Each procedure must be named (in its <code>&lt;proc&gt;</code> tag), with quotes (either
single or double) being mandatory about that name.
The end of a procedure definition acts in the same way as the end of a script
(as an implied <code>&lt;do&gt;</code>).
Note that <code>&lt;/proc&gt;</code> tags are only recognised within <span class="rlang"><b>R</b></span> sections, when (as
is the case in this example) the <span class="rlang"><b>R</b></span> section is within a procedure definition
(i.e., under a <code>&lt;proc&gt;</code> tag).
Opening <code>&lt;proc&gt;</code> tags are never recognised within <span class="rlang"><b>R</b></span> sections.
</p>



<h3>Script #18 (Libraries)</h3>

<pre>
&lt;proc "add na.strings"&gt;
  -- Takes one argument, 'add' (a character vector),
  -- and adds its strings to the na.strings parameter.
  &lt;R&gt;
    sqrl(na.strings = unique(c(sqrl("na.strings"), add)))
  &lt;do&gt;
&lt;/proc&gt;

&lt;proc "drop if exists"&gt;
  /* Takes one argument, 'tables', being a
     character vector of tables to be dropped. */
  -- Force as.is to be TRUE (for the query).
  &lt;with&gt;
    as.is = TRUE
  &lt;/with&gt;
  -- Pull details of temporary tables.
  help volatile table
  &lt;result -&gt; v&gt;
  &lt;do&gt;
  -- Exit here when the above query did not return
  -- a data frame (when no volatile table exists).
  &lt;if (class(v) != class(data.frame()))&gt;
    &lt;return (invisible())&gt;
  &lt;/if&gt;
  -- Extract the names of all volatile tables
  -- in existence, retain only those (unique)
  -- tables to be dropped that actually exist,
  -- and initialise the iterator.
  &lt;R&gt;
    volatiles &lt;- as.character(v[, "Table SQL Name"])
    tables &lt;- unique(tables[tables %in% volatiles])
    i &lt;- 0L
  &lt;do&gt;
  -- Drop each requested table (that exists).
  &lt;while (i &lt;- i + 1L; i &lt;= length(tables))&gt;
    drop table &lt;R&gt; tables[i] &lt;/R&gt; &lt;do&gt;
  &lt;/while&gt;
  -- Return invisible NULL.
  &lt;return (invisible())&gt;
&lt;/proc&gt;
</pre>


<h4>Commentary on Script #18</h4>

<p>The previous example, script #17, exhibited a procedure defined as a utility
within a larger <abbr><span class="acronym">SQRL</span></abbr> script.
Such definitions are not persistent, with the procedures vanishing upon the
conclusion of their parent script.
</p>
<p>However, as shown in <code><a href="#topic+sqrlUsage">sqrlUsage</a></code>, it is possible to construct a
persistent library of procedures.
As is the case above, <abbr><span class="acronym">SQRL</span></abbr> scripts intended for libraries must
consist only of procedure definitions; no other <abbr><span class="acronym">SQL</span></abbr> or <span class="rlang"><b>R</b></span> is allowed.
This example script defines two procedures (both parameterised).
The first, &ldquo;add na.strings&rdquo;, adds strings to the existing
<var>na.strings</var> vector (refer to <code><a href="#topic+sqrlParams">sqrlParams</a></code>).
The second, &ldquo;drop if exists&rdquo;, implements that capability for Teradata
<abbr><span class="acronym">SQL</span></abbr> (which doesn't).
</p>
<p>Following <code><a href="#topic+sqrlUsage">sqrlUsage</a></code>, let's say the above script is recorded in a
file &lsquo;<span class="file">library.sqrl</span>&rsquo;, and that we have a <span class="pkg">SQRL</span> interface function
called <code>owl</code>.
The library is then established with <code>owl(library = "library.sqrl")</code>, and
the procedures are called with (for instance)
<code>owl("add na.strings", add = c("N/A", "-"))</code>, and
<code>owl("drop if exists", tables = c("tableA", "tableB"))</code>.
</p>
<p>Ultimately, procedures do not confer any capability beyond that of
<abbr><span class="acronym">SQRL</span></abbr> files.
Procedure libraries merely allow the consolidation of multiple files into one.
They also offer another slight advantage in that when you change working
directory, they come along.
</p>



<h3>Script #19 (Stop)</h3>

<pre>
select 1

-- This ends the script.
&lt;stop&gt;

-- This is unreachable.
select 2
</pre>


<h4>Commentary on Script #19</h4>

<p>Lastly, <code>&lt;stop&gt;</code> tags act as an early end-of-script (with its implied
<code>&lt;do&gt;</code>).
They apply within <span class="rlang"><b>R</b></span> sections, as well as <abbr><span class="acronym">SQL</span></abbr>, and even on the inside
of a <code>FALSE</code> conditional block (i.e., the <code>&lt;stop&gt;</code> still functions in
<code>&lt;if (FALSE)&gt;&lt;R&gt;&lt;stop&gt;</code>).
They are intended as a troubleshooting aid.
</p>



<h3>Summary of Tags</h3>


<dl>
<dt><code>&lt;R&gt;</code>:</dt><dd>
<p>Begins an <span class="rlang"><b>R</b></span> section (leaves <abbr><span class="acronym">SQL</span></abbr>).
Once begun, only <code>&lt;/R&gt;</code>, <code>&lt;do&gt;</code>, <code>;</code>, <code>&lt;stop&gt;</code>, <code>EOS</code>,
and <code>&lt;/proc&gt;</code> are recognised (and can end the section).
The <code>&lt;/proc&gt;</code> case is only recognised when the initiating <code>&lt;R&gt;</code> tag is
within a procedure definition (beneath a <code>&lt;proc&gt;</code> tag).
</p>
</dd>
<dt><code>&lt;/R&gt;</code>:</dt><dd>
<p>Ends an <span class="rlang"><b>R</b></span> section, causing that section to be evaluated.
The result of that evaluation is pasted back into the surrounding <abbr><span class="acronym">SQL</span></abbr>.
</p>
</dd>
<dt><code>&lt;do&gt;</code>:</dt><dd>
<p>If inside an <span class="rlang"><b>R</b></span> section, ends and evaluates that section (without pasting the
result back into <abbr><span class="acronym">SQL</span></abbr>).
If outside of an <span class="rlang"><b>R</b></span> section, causes the preceding <abbr><span class="acronym">SQL</span></abbr> (which may be
blank) to be submitted.
</p>
</dd>
<dt><code>&lt;result -&gt; name&gt;</code>:</dt><dd>
<p>Submits the preceding <abbr><span class="acronym">SQL</span></abbr>, and assigns the result of that submission
to the <span class="rlang"><b>R</b></span> variable <code>name</code>.
Any syntactically valid <span class="rlang"><b>R</b></span> name, or &ldquo;NULL&rdquo;, is allowed (in place of
<code>name</code>).
An <span class="rlang"><b>R</b></span> section begins immediately after the tag.
That section concludes with any of the tags listed (above) for <code>&lt;R&gt;</code>,
besides <code>&lt;/R&gt;</code>.
</p>
</dd>
<dt><code>&lt;close&gt;</code>:</dt><dd>
<p>Closes the <abbr><span class="acronym">ODBC</span></abbr> channel (connection) to the data source.
</p>
</dd>
<dt><code>&lt;return (Rexp)&gt;</code>:</dt><dd>
<p>Evaluates <code>Rexp</code>, which can be any <span class="rlang"><b>R</b></span> expression, and returns the resulting
value (exits the script).
The parentheses are mandatory.
</p>
</dd>
<dt><code>&lt;with&gt;</code>:</dt><dd>
<p>Begins a special <span class="rlang"><b>R</b></span> section, for assigning temporary values to
<span class="pkg">RODBC</span>/<span class="pkg">SQRL</span> parameters.
Once begun, only <code>&lt;/with&gt;</code>, <code>&lt;stop&gt;</code>, <code>EOS</code>, and <code>&lt;/proc&gt;</code>
are recognised (and can end the section).
The <code>&lt;/proc&gt;</code> case is only recognised when the initiating <code>&lt;with&gt;</code> tag
lies within a procedure definition (beneath a <code>&lt;proc&gt;</code> tag).
Only the <var>aCollapse</var>, <var>as.is</var>, <var>buffsize</var>, <var>dec</var>, <var>errors</var>,
<var>lCollapse</var>, <var>max</var>, <var>na.strings</var>, <var>nullstring</var>, <var>ping</var>,
<var>pwd</var>, <var>retry</var>, <var>scdo</var>, <var>stringsAsFactors</var>, and <var>verbose</var>
parameters permit temporary value assignments.
</p>
</dd>
<dt><code>&lt;/with&gt;</code>:</dt><dd>
<p>Ends an <span class="rlang"><b>R</b></span> section begun by <code>&lt;with&gt;</code>.
Causes the section to be evaluated, and assigns temporary parameter values
accordingly.
</p>
</dd>
<dt><code>&lt;if (Rexp)&gt;</code>:</dt><dd>
<p>Evaluates <code>Rexp</code>, which can be any <span class="rlang"><b>R</b></span> expression.
If that expression evaluated to <code>TRUE</code>, the (arbitrary) script beneath the
tag is acted upon.
If that expression evaluated to <code>FALSE</code>, the (arbitrary) script beneath the
tag is ignored (except for any <code>&lt;stop&gt;</code> tags).
The parentheses are mandatory.
</p>
</dd>
<dt><code>&lt;else if (Rexp)&gt;</code>:</dt><dd>
<p>Acts as <code>&lt;if (Rexp)&gt;</code>, when the (mandatory) previous <code>&lt;if ((Rexp)&gt;</code>,
and all the (multiple, optional) previous <code>&lt;else if (Rexp)&gt;</code> tags,
evaluated to <code>FALSE</code>.
Otherwise (when any of those evaluated to <code>TRUE</code>), acts as
<code>&lt;if (FALSE)&gt;</code>.
The parentheses are mandatory.
</p>
</dd>
<dt><code>&lt;else&gt;</code>:</dt><dd>
<p>Acts as <code>&lt;else if (TRUE)&gt;</code>.
</p>
</dd>
<dt><code>&lt;/if&gt;</code>:</dt><dd>
<p>Marks the end of an <code>&lt;if (Rexp)&gt;</code> - <code>&lt;else if (Rexp)&gt;</code> - <code>&lt;else&gt;</code>
flow-control structure.
</p>
</dd>
<dt><code>&lt;while (Rexp)&gt;</code>:</dt><dd>
<p>Acts in the manner of <code>&lt;if (Rexp)&gt;</code>.
The parentheses are mandatory.
</p>
</dd>
<dt><code>&lt;/while&gt;</code>:</dt><dd>
<p>Marks the end of a <code>&lt;while (Rexp)&gt;</code> flow-control loop.
If the previous <code>&lt;while (Rexp)&gt;</code> evaluated to <code>TRUE</code>, the parser
returns to that <code>&lt;while (Rexp)&gt;</code> tag, and re-evaluates the <span class="rlang"><b>R</b></span> expression.
Otherwise (if the previous <code>&lt;while (Rexp)&gt;</code> evaluated to <code>FALSE</code>), no
action is performed (the parser continues from this point).
</p>
</dd>
<dt><code>&lt;proc "name"&gt;</code>:</dt><dd>
<p>Marks the beginning of the definition of a procedure called <var>name</var>.
Any character string can be used in place of <var>name</var>.
The quotation marks are mandatory (but can be singles or doubles).
</p>
</dd>
<dt><code>&lt;/proc&gt;</code>:</dt><dd>
<p>Marks the end of a procedure definition (acts as an <var>EOS</var> for that
procedure).
</p>
</dd>
<dt><code>&lt;stop&gt;</code>:</dt><dd>
<p>Acts as <var>EOS</var>.
Applies even from within a <code>FALSE</code> conditional block.
Intended for debugging, only.
</p>
</dd>
<dt><code>;</code>:</dt><dd>
<p>When the <var>scdo</var> parameter is at its default value of <code>TRUE</code> (see
<code><a href="#topic+sqrlParams">sqrlParams</a></code>), the <abbr><span class="acronym">SQRL</span></abbr> parser attempts to identify
<abbr><span class="acronym">SQL</span></abbr> statement terminating semicolons, procedural language block
terminating semicolons, and any extra semicolons within <span class="rlang"><b>R</b></span> sections.
When detected, these all act as <code>&lt;do&gt;</code>.
</p>
</dd>
<dt><var>EOS</var>:</dt><dd>
<p>The end of the script (<var>EOS</var>), acts as <code>&lt;do&gt;</code>.
As necessary, it also acts as <code>&lt;/if&gt;</code> and <code>&lt;/proc&gt;</code> (it does not act
as <code>&lt;/while&gt;</code>).
</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <var>verbose</var> parameter toggles extended output when running scripts (see
<code><a href="#topic+sqrlParams">sqrlParams</a></code>).
This includes the display of intermediate values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlUsage">sqrlUsage</a></code>
</p>

<hr>
<h2 id='sqrlSource'>
Define New Data Sources
</h2><span id='topic+sqrlSource'></span>

<h3>Description</h3>

<p>Defines (registers) new data sources and creates the interface functions for
communicating with them.
For <abbr><span class="acronym">DSN</span></abbr>s, this process occurs automatically when <span class="pkg">SQRL</span> is loaded,
thereby making the manual use of this function unnecessary for those sources.
The function can also redefine or delete (deregister) existing sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrlSource(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrlSource_+3A_...">...</code></td>
<td>

<p>A name and definition for the source (refer to the details section, below).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments must contain (at least) a name and definition for the source.
In simplest form, these could be given as either (<var>name</var>, <var>definition</var>)
or (<var>name</var> = <var>definition</var>), where both <var>name</var> and <var>definition</var>
are single character strings.
In decreasing order of precedence, the definition can be the path of a
configuration file (containing a connection string or <abbr><span class="acronym">DSN</span></abbr>, as per
<code><a href="#topic+sqrlConfig">sqrlConfig</a></code>), the name of an existing <span class="pkg">SQRL</span> source (to copy
all settings from), an <abbr><span class="acronym">ODBC</span></abbr> connection string (as a character vector
of components, or as a single string containing the equals character; =), or
as the name of a <abbr><span class="acronym">DSN</span></abbr>.
</p>
<p>When clarity is required, the keywords <code>config</code>, <code>copy</code>,
<code>connection</code> and <code>dsn</code> can be used to explicitly specify a
configuration file, existing source, connection string or <abbr><span class="acronym">DSN</span></abbr>,
respectively.
If the definition is given as multiple terms, and none of these four keywords
are present, or if one of the named terms does not correspond to the name of
an <span class="pkg">RODBC</span>/<span class="pkg">SQRL</span> parameter, then the terms are assumed to be
components of a connection string.
If, instead, the definition is given as multiple terms and at least one of these
four keywords is present, and when all of the remaining terms appear to be
<span class="pkg">RODBC</span>/<span class="pkg">SQRL</span> parameters, then those remaining terms will be treated
as such (rather than as connection string components).
The examples (below) should illustrate these statements.
</p>
<p>Whichever form of definition is employed, the new interface name (which defaults
to the source name) must not conflict with that of any function on the <span class="rlang"><b>R</b></span> search
path (or else an error will be thrown).
</p>
<p>Redefinition of an existing source is allowed, provided it is closed at the
time.
</p>
<p>When the source name is &ldquo;remove&rdquo;, the definition is interpreted as a list
of sources to be deregistered.
This precludes the use of &ldquo;remove&rdquo; as a source name.
Alternatively, redefining a source to <code>NULL</code> also deregisters the source.
</p>


<h3>Value</h3>

<p>An invisible list of the new source's parameter values.
</p>


<h3>Note</h3>

<p>Source definitions are not checked for validity (specified connection strings
need not be correct, specified <abbr><span class="acronym">DSN</span></abbr>s need not exist).
</p>
<p>Connection strings may include placeholders; &ldquo;&lt;dsn&gt;&rdquo;, &ldquo;&lt;driver&gt;&rdquo;,
&ldquo;&lt;uid&gt;&rdquo;, and &ldquo;&lt;pwd&gt;&rdquo;, to be replaced with the corresponding
parameter values on the opening of a channel.
These placeholders are case sensitive (see <code><a href="#topic+sqrlParams">sqrlParams</a></code>).
</p>
<p>In &lsquo;<span class="file">Rgui.exe</span>&rsquo;, the <abbr><span class="acronym">ODBC</span></abbr> driver may, via <span class="pkg">RODBC</span>, prompt for
missing connection details (username, password, etc.).
In other <span class="rlang"><b>R</b></span> applications, those details will need to be complete (no prompting
occurs).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlConfig">sqrlConfig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a new source, 'A', by a connection string. Alternatively,
# the string could be replaced with the name of a DSN, the path of
# a config file, or the name of an existing source (to be copied).
# This particular connection string would be for a GNU/Linux system
# upon which the unixODBC driver alias 'MariaDB' has been defined,
# in addition to the 'MDB' alias for the server address. In general,
# there should be no space between 'Driver=' and the driver name.
sqrlSource(A = "Driver=MariaDB;Server=MDB;User=zarkov;Password=zenith")

# Redefine source 'A', by a connection string given in sections.
# This is for a GNU/Linux system without a unixODBC driver alias.
sqrlSource("A", "dbcname=planet;uid=zakharov;pwd=$tdwallet(planet)",
                "driver=/opt/teradata/client/16.10/lib64/tdata.so")

# Define a new source, by way of named connection-string components.
# This example is for a Windows-system client, and uses the '&lt;pwd&gt;'
# placeholder (it remains to set a value for the pwd parameter before
# connecting to the ODBC source).
sqrlSource("jumbo",
           driver = "PostgreSQL ANSI(x64)",
           server = "localhost",
           port = 5432,
           uid = "admin",
           pwd = "&lt;pwd&gt;")

# Define another source, as a vector of connection string
# components, along with some RODBC/SQRL parameter values.
sqrlSource("mydb", believeNRows = FALSE, autoclose = TRUE,
           connection = c(Driver = "SQLite3 ODBC Driver",
                          Database = "C:/mydatabase.db",
                          Timeout = 10000,
                          StepAPI = 1))

# Define another source, from a DSN (rather than a connection
# string), while also setting an RODBC/SQRL parameter value.
sqrlSource("ak", dsn = "Akademgorodok", as.is = TRUE)

# Redefine the source. This time, the dsn term is treated as a
# connection string component (because the server term must be).
sqrlSource("ak", dsn = "Akademgorodok", server = "Novosibirsk")

# Define another source, 'Huma', by a list of components, which
# includes an explicit source name, a vector of connection string
# components, a config list of RODBC/SQRL parameter values, and
# one more RODBC/SQRL parameter value outside of that config list.
# This list format is convenient for programmatic source creation.
sqrlSource(list(name = "Huma",
                connection = c(DRIVER = "Firebird/InterBase(r) driver",
                               DBNAME = "C:\\Database\\myDB.fdb",
                               UID = "MCSSITE",
                               PWD = "mcssite"),
                config = list(as.is = TRUE, scdo = FALSE),
                visible = TRUE))

# Define a source called 'source'. Although the name 'source' clashes
# with that of the base::source function, this definition is allowed
# because we simultaneously set an interface, 'S', that does not clash.
# Note the mixture of named and unnamed connection string components.
sqrlSource(source = list(connection = c("DSN=Source", UID = "me"),
                         interface = "S"))

# Another source, defined by a list of named connection string
# components (without setting any other parameter values).
sqrlSource(sf = list(driver = "{SnowflakeDSIIDriver}",
                     server = "xyz.eu-central-1.snowflakecomputing.com",
                     uid = "me", pwd = "guess", port = 443))

# Create a configuration file, and define a new source, 'sage',
# from it. Compare with the very first example, and with the 'mydb'
# example (both above). Once prepared, using a file is simple.
config.file &lt;- tempfile()
writeLines(c("connection = c(driver   = 'SQLite3 ODBC Driver',",
             "               database = 'D:/mydb.db')",
             "autoclose = TRUE; believeNRows = TRUE"),
           config.file)
sqrlSource(sage = config.file)

# Create a (partial) configuration file (defining values for
# communications settings, but not the data source itself).
writeLines(c("autoclose = TRUE",
             "readOnlyOptimize = TRUE",
             "visible = FALSE"),
           config.file)

# Define a new source, 'papango', as a copy of the existing source,
# 'Huma', then apply the above configuration file over that, and
# then set values for the dsn and interface parameters over those.
# In this example, the value of the 'visible' parameter inherited
# from Huma is overwritten by the value from the config file.
# Setting the dsn parameter likewise erases the value of the
# connection parameter inherited from Huma, while the inherited
# uid and pwd values survive. Alternatively, we could have set
# 'connection = "dsn=Aythya"' in place of 'dsn = "Aythya"', and
# this would ignore the inherited uid and pwd values.
sqrlSource("papango",
           copy = "Huma",
           config = config.file,
           dsn = "Aythya",
           interface = "P")

# Review all defined sources.
sqrlSources()

# Review the configuration of the papango source.
P("config")

# Review details of how we connect to the source.
P("source")

# Clean-up (various methods of source removal).
sqrlSource("remove", "jumbo")
sqrlSource(remove = c("mongo", "papango"))
sqrlSource(Huma = NULL)
unlink(config.file)
</code></pre>

<hr>
<h2 id='sqrlSources'>
List Data Sources and their Interfaces
</h2><span id='topic+sqrlSources'></span>

<h3>Description</h3>

<p>Returns a summary of defined data sources.
These will consist of system and user <abbr><span class="acronym">DSN</span></abbr>s, plus any additional
sources defined via <code><a href="#topic+sqrlSource">sqrlSource</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrlSources(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrlSources_+3A_...">...</code></td>
<td>

<p>An optional character string.
If set to one of &ldquo;all&rdquo;, &ldquo;user&rdquo;, or &ldquo;system&rdquo;, then a call is
made to <code><a href="RODBC.html#topic+odbcDataSources">RODBC::odbcDataSources</a></code> (with the
corresponding <var>type</var> value) to re-examine that class of data source names
(<abbr><span class="acronym">DSN</span></abbr>s) and import all those found.
If set to &ldquo;remove&rdquo;, then all currently defined sources are deregistered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of data source details.
</p>


<h3>Note</h3>

<p>The return frame may have zero rows, if no data sources are defined.
</p>
<p>Sources need only to have been defined; they need not actually exist.
</p>
<p><abbr><span class="acronym">DSN</span></abbr>s with &ldquo;Access&rdquo;, &ldquo;dBASE&rdquo;, or &ldquo;Excel&rdquo; in their
names are not automatically imported.
They can be manually added via <code><a href="#topic+sqrlSource">sqrlSource</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlInterface">sqrlInterface</a></code>,
<code><a href="#topic+sqrlSource">sqrlSource</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Review defined sources.
sqrlSources()

## Not run: 
# Sample sqrlSources() output:

   name interface open                     driver
1 chaos     chaos    N       PostgreSQL ANSI(x64)
2 order      &lt;NA&gt;    N MySQL ODBC 5.3 ANSI Driver

# Here, there are two data sources; 'order' and 'chaos'.
# The interface to 'chaos' is a function of the same name.
# No interface has yet been defined for 'order' (use of
# that name is prevented due to its conflicting with the
# base::order function). Neither source (channel) is open.

## End(Not run)

# Remove all sources.
sqrlSources("remove")

# Reload user DSNs.
sqrlSources("user")
</code></pre>

<hr>
<h2 id='sqrlUsage'>
How to Use the Interface Functions
</h2><span id='topic+sqrlUsage'></span>

<h3>Description</h3>

<p>This material does not describe a single function, but (rather) how to use
<span class="pkg">SQRL</span> interfaces (once created).
These interface functions do not have their own static help files, since their
names are not known at build time.
</p>


<h3>Details</h3>

<p>Once you have a named interface (created either automatically, on loading of the
<span class="pkg">SQRL</span> namespace, or manually, via <code><a href="#topic+sqrlSource">sqrlSource</a></code>), it can be used
to communicate with the associated data source.
Connection handles and communication parameters are managed under the hood.
</p>
<p>The following sections provide usage examples for an interface called
<code>owl</code>.
The names of your own interface functions can be discovered by calling
<code><a href="#topic+sqrlSources">sqrlSources()</a></code>.
</p>


<h3>Opening and Closing</h3>

<pre>
# Open a connection to the data source.
owl()

# Alternative method (explicit form).
owl("open")

# This is fine (the channel survives).
rm(list = ls(all.names = TRUE))

# Check if the connection is open.
owl("isopen")

# Open a connection and confirm status.
owl()$isopen

# Close the connection.
owl("close")

# Close the connection when not in use.
owl(autoclose = TRUE)
</pre>
<p>Opening connections in the above way isn't usually necessary, since this occurs
automatically, as and when required.
</p>
<p>When necessary, the <code>isopen</code> command &lsquo;pings&rsquo; the data source, to
reliably establish whether or not the connection really is open (including after
a network outage or remote closure).
</p>
<p>With <code>autoclose = TRUE</code>, <code>owl("isopen")</code> should always return
<code>FALSE</code>, whereas <code>owl()$isopen</code> will often return <code>TRUE</code>.
This is because the latter command attempts to open a connection, with its
return value being the connectivity status immediately after that attempt
(before <var>autoclose</var> takes effect and closes the connection).
This provides a test of data source reachability and responsiveness, regardless
of the <var>autoclose</var> setting.
</p>


<h3>Submitting Queries</h3>

<pre>
# Submit a query.
owl("select 1")

# Submit another query.
owl("select '", sample(letters, 1), "' from dual")

# Submit a multi-statement query.
owl("use necronomicon; select top ",
    sample(6, 1), " shoggoths from pit")

# Filtering against a set of values.
owl("select columnA from database.table ",
    "where columnB in (", c(2, 3, 5), ")")

# Supplying a query as a list of components.
owl(list("select ", c("'red'", "'blue'")))

# A parameterised query (SQL with R in it).
owl("select &lt;R&gt; a + b &lt;/R&gt;", a = 0, b = 1)

# Explicit form.
owl(query = list("select ", "&lt;R&gt;sin(x)&lt;/R&gt;"), x = 0)

# Verbatim query.
owl(verbatim = "select 1 as N")

# Recall the result of the last successful query.
owl("result")
</pre>
<p>If necessary, a connection channel will be opened automatically.
The connection will remain open afterwards, unless <var>autoclose</var> is
<code>TRUE</code>.
</p>
<p>When a query is supplied as components, the pieces are pasted together without
any intervening whitespace.
To facilitate their use with the <abbr><span class="acronym">SQL</span></abbr> <code>in</code> operator, any atomic
vectors are collapsed to comma-separated values, beforehand.
This (default) behaviour can be altered with the <var>aCollapse</var> and
<var>lCollapse</var> parameters (as described in <code><a href="#topic+sqrlParams">sqrlParams</a></code>).
</p>
<p>Using the <var>query</var> keyword overrides the order of precedence (as detailed
below).
Whereas <var>query</var> arguments go through the usual <span class="pkg">SQRL</span> concatenation,
parsing, and <span class="rlang"><b>R</b></span>-substitution process, <var>verbatim</var> arguments are submitted
directly and without alteration.
Consequently, the <var>verbatim</var> command accepts only a single character string,
which cannot be parameterised via embedded <span class="rlang"><b>R</b></span>.
</p>
<p>As <span class="pkg">SQRL</span> aims to be flexible on input formatting, the above examples can be
extrapolated.
For instance, the explicit <var>query</var> could have been a single string.
</p>
<p>When a query returns no data (as would &ldquo;use database&rdquo;), the interface
function returns invisibly.
</p>
<p>If a query should fail due to an unexpectedly lost connection, one further
attempt will be made to reconnect and resubmit (provided the <var>retry</var>
parameter is <code>TRUE</code>).
Unless user input is required for authentication, this should go unnoticed.
If temp tables were in use, then these will have been dropped along with the
original connection, and an error may still occur.
</p>


<h3>Submitting Queries from File</h3>

<pre>
# Submit a query from file.
owl("my/file.sql")

# Equivalent alternative forms.
owl("my/", "file.sql")
owl(c("my/", "file.sql"))

# Explicit alternative forms.
owl(file = "my/file.sql")
owl(file = c("my/", "file.sql"))
</pre>
<p>Using the <var>file</var> keyword overrides the order of precedence (as detailed
below).
In its absence, unnamed arguments are treated as a file path when they point to
a readable file.
</p>
<p>In the above examples, <code>list(...)</code> works just as well as <code>c(...)</code>.
Either way, the path components are pasted together without any intervening
whitespace (the path not being a literal query).
</p>


<h3>Submitting Parameterised Queries from File</h3>

<pre>
# Submit a parameterised query from file.
owl("my/file.sqrl", day = 1, month = "May")

# Supplying the arguments in a list.
owl("my/file.sqrl", list(day = 1, month = "May"))

# Supplying the arguments in an explicitly named list.
owl("my/file.sqrl", args = list(day = 1, month = "May"))

# Supplying both the query and its arguments in a list.
owl(list(file = "my/file.sqrl", day = 1, month = "May"))
owl(list(file = c("my/", "file.sqrl"),
         args = list(day = 1, month = "May")))
</pre>
<p>To be clear, the phrase &ldquo;parameterised query&rdquo; is not meant in the sense
of prepared or parameterised statements (as per package <span class="pkg">RODBCext</span>).
In <span class="pkg">SQRL</span>, parameter substitution occurs within <span class="rlang"><b>R</b></span> (locally), with the
resulting string being passed to the <abbr><span class="acronym">ODBC</span></abbr> driver as an ordinary query.
Refer to <code><a href="#topic+sqrlScript">sqrlScript</a></code> for the details.
</p>
<p>The use of the <var>args</var> keyword is optional when all list members have
syntactically valid names (in the sense of
<code><a href="base.html#topic+make.names">base::make.names</a></code>).
Any such lists are automatically interpreted as collections of named arguments
(and are unpacked to those collections).
Query arguments called, for instance, <var>file</var>, <var>proc</var>, or <var>query</var>,
may need to be wrapped in <var>args</var> to ensure they are treated as intended,
and not as query (script) specifiers.
</p>
<p>In keeping with <span class="pkg">SQRL</span>'s intended flexibility around input formatting, any
of the file path specification methods of the previous section could also be
used here.
</p>


<h3>Stored Procedures</h3>

<pre>
# Import procedures from file.
owl(library = "my/library.sqrl")

# List procedure names.
owl("library")

# List procedure definitions.
owl("Library")

# Run a named procedure.
owl("my procedure")

# Equivalent explicit form.
owl(proc = "my procedure")

# Run a parameterised procedure.
owl("Cropp River Rainfall", date = Sys.Date() - 1)

# Empty the library.
owl(library = NULL)
</pre>
<p>As detailed below, procedures top the order of precedence.
Consequently, the <var>proc</var> keyword is an entirely optional transparency
device.
In its absence, unnamed arguments are treated as the name of a procedure when
they name a procedure within the library.
</p>
<p>The library-file procedure-definition format is described in
<code><a href="#topic+sqrlScript">sqrlScript</a></code>.
The path to such a file (i.e., the value of the <var>library</var> keyword) can be
supplied in any of the file-path formats of the previous sections (that is, as
a list or vector of components).
</p>
<p>Any of the file-path and/or query-argument specification formats seen in the
previous two sections can equally be used with procedure names.
The only difference is to replace any <var>file</var> keyword with the <var>proc</var>
keyword.
</p>


<h3>Querying Metadata</h3>

<pre>
# List all tables.
owl("tables")

# List all tables within a database (schema).
owl("tables", "mydatabase")

# Get information on the columns of a particular table.
owl("columns", "mydatabase.table")

# Get information on the primary keys of a particular table.
owl("primarykeys mydatabase.table")

# Get information on source data types.
owl("typeinfo")
</pre>
<p>The <code>tables</code>, <code>columns</code>, <code>primarykeys</code> and
<code>typeinfo</code> commands are simple (reduced functionality) wrappers about
<span class="pkg">RODBC</span>'s <code><a href="RODBC.html#topic+sqlTables">sqlTables</a></code>,
<code><a href="RODBC.html#topic+sqlColumns">sqlColumns</a></code>,
<code><a href="RODBC.html#topic+sqlColumns">sqlPrimaryKeys</a></code>, and
<code><a href="RODBC.html#topic+sqlTypeInfo">sqlTypeInfo</a></code>, respectively.
These features are dependent upon the support of your <abbr><span class="acronym">DBMS</span></abbr> and driver.
For some sources, the <var>believeNRows</var> parameter may need to be <code>FALSE</code>.
Metadata queries bypass SQRL's parser.
</p>


<h3>Reviewing Settings</h3>

<pre>
# Get the associated source definition.
owl("source")

# Get the value of one named parameter.
owl("uid")

# Alternative method (pings the source).
owl()$uid

# List the values of all parameters.
owl("config")

# List a subset of parameter values.
owl("settings")
</pre>
<p>The <code>settings</code> subset is intended for restoring <span class="pkg">RODBC</span> and/or
<span class="pkg">SQRL</span> parameter values at the end of a script that changed some.
An example of this is given in <code><a href="#topic+sqrlScript">sqrlScript</a></code>.
It can also be used to transfer parameter values between sources.
</p>


<h3>Setting Parameters</h3>

<pre>
# Set a parameter value.
owl(stringsAsFactors = FALSE)

# Set multiple parameter values.
owl(max = 1000, na.strings = c("NA", "-", ""))

# Set multiple values from a list.
owl(list(case = "toupper", scdo = FALSE))

# Set values from a list (explicit form).
owl(config = list(visible = TRUE, autoclose = TRUE))

# Import values from source 'wol'.
owl(config = wol("settings"))

# Import values from a configuration file.
owl(config = "my/config/file.txt"))

# Import one value from a file.
owl(pwd = c("path/", "to/", "file", ".txt"))

# Reset parameters to their default values.
owl(reset = c("errors", "nullstring"))
</pre>
<p>The <var>driver</var> and <var>dsn</var> parameters accept file paths as their values.
For all other parameters, values are extracted from within any specified files.
</p>
<p>Assigning <var>visible</var> <code>TRUE</code> authorises modification of the global
<code>prompt</code> option.
When running &lsquo;<span class="file">R.exe</span>&rsquo;, &lsquo;<span class="file">Rterm.exe</span>&rsquo; or &lsquo;<span class="file">Rgui.exe</span>&rsquo; on a Windows
operating system, this also authorises modification of the<span class="rlang"><b>R</b></span> window title.
</p>
<p>Calling <code>reset</code> on its own, as in <code>owl("reset")</code>, does nothing.
</p>
<p>Further alternative input formats appear in the examples section of
<code><a href="#topic+sqrlParams">sqrlParams</a></code>.
</p>


<h3>Changing the Interface</h3>

<pre>
# Change the interface.
owl(interface = "O")

# Change it back.
O(interface = "owl")
</pre>
<p>Changing the interface is just a particular case of setting a parameter.
</p>
<p>If the proposed new interface name already belongs to some other function within
the <span class="rlang"><b>R</b></span> search path, then the change request will be denied (unless that name is
<code>remove</code>, in which case the current interface function will be deleted).
</p>
<p>A successful change deletes the previous interface.
</p>


<h3>Listing Data Sources</h3>

<pre>
# See the data sources and their interfaces.
owl("sources")
</pre>
<p>This is equivalent to calling <code><a href="#topic+sqrlSources">sqrlSources()</a></code>.
</p>


<h3>Getting Help</h3>

<pre>
# Get help on 'owl' (alternative forms).
owl("help")
owl("?")

# Obtain help, in specific formats.
owl("help text")
owl("help html")
</pre>
<p>The above calls will attempt to provide help tailored for the specific
interface, and will fall back to these notes (<code>help(sqrlUsage)</code> or
<code>?sqrlUsage</code>) should that fail.
</p>


<h3>Removing the Source</h3>

<pre>
# Deregister the associated source.
owl("remove")
</pre>
<p>This closes any open connection to the data source, deletes the interface
function (<code>owl</code>), and deregisters the source from <span class="pkg">SQRL</span>.
</p>


<h3>Order of Precedence</h3>

<p>When unnamed arguments are supplied, such as in <code>owl("something")</code>,
<span class="pkg">SQRL</span> interprets those arguments with the following order of precedence:
</p>

<ol>
<li><p> Procedure names (in the <var>library</var>),
</p>
</li>
<li><p> File paths (of <abbr><span class="acronym">SQL</span></abbr> or <abbr><span class="acronym">SQRL</span></abbr> scripts),
</p>
</li>
<li><p> Special words (&ldquo;close&rdquo;, &ldquo;config&rdquo;, etc.),
</p>
</li>
<li><p> Parameter names (optionally followed by values),
</p>
</li>
<li><p> Literal <abbr><span class="acronym">SQRL</span></abbr> script (including pure <abbr><span class="acronym">SQL</span></abbr>).
</p>
</li></ol>

<p>Hence, if a file called (say) &lsquo;<span class="file">use database</span>&rsquo; should exist, then
<code>owl("use database")</code> submits the content of that file (rather than the
apparent <abbr><span class="acronym">SQL</span></abbr> command).
Such conflicts can be resolved by assigning the unnamed arguments to the
appropriate keyword (<var>file</var>, <var>proc</var>, or <var>query</var>).
In this case, the new command would be <code>owl(query = "use database")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sqrlAll">sqrlAll</a></code>,
<code><a href="#topic+sqrlConfig">sqrlConfig</a></code>,
<code><a href="#topic+sqrlParams">sqrlParams</a></code>,
<code><a href="#topic+sqrlScript">sqrlScript</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some default values, for demonstration purposes.
x &lt;- 1; y &lt;- 2

# Define a new SQRL source and its interface. The DSN need
# not exist, but this will fail (by design) if a function
# called 'owl' already exists on the R search path.
sqrlSource("owl", dsn = "HundredAcreWood")

# This (ordinarily pointless) SQRL script contains no SQL,
# which allows it to run even when the DSN does not exist
# (there being no need to open a connection). In this case,
# the x and y variables are implicitly inherited.
owl("&lt;R&gt; x * y")

# Explicitly assign x, while inheriting y.
owl("&lt;R&gt; x * y", x = 2)

# An alternative arrangement of arguments.
owl(x = 3, query = "&lt;R&gt; x * y", y = 1)

# Write the script to file.
myfile &lt;- tempfile()
writeLines("&lt;R&gt; x * y", myfile)

# Run the script from file, inheriting variables.
owl(myfile)

# Run the script from file, with explicit arguments.
# (These are all equivalent.)
owl(myfile, x = 2, y = 3)
owl(myfile, list(x = 2, y = 3))
owl(myfile, args = list(x = 2, y = 3))
owl(file = myfile, x = 2, y = 3)
owl(file = myfile, list(x = 2, y = 3))
owl(file = myfile, args = list(x = 2, y = 3))
owl(list(file = myfile, x = 2, y = 3))
owl(list(file = myfile, args = list(x = 2, y = 3)))

# With the file path specified as components.
owl(dirname(myfile), "/", basename(myfile), x = 2, y = 3)
owl(file = c(dirname(myfile), "/", basename(myfile)),
    args = list(x = 2, y = 3))

# Construct a library file (of procedure definitions).
mylibraryfile &lt;- tempfile()
writeLines(c("&lt;proc 'proc-a'&gt; &lt;R&gt; x * y &lt;/proc&gt;",
             "&lt;proc 'proc-b'&gt; &lt;R&gt; x + y &lt;/proc&gt;"),
           mylibraryfile)

# Import procedures from file (to owl's library).
owl(library = mylibraryfile)

# Run the imported procedures.
owl("proc-a")
owl("proc-b", x = 2, y = c(3, 4))

# Review the last result.
owl("result")

# Clean-up.
unlink(c(myfile, mylibraryfile))
owl("remove")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
