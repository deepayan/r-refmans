<!DOCTYPE html><html><head><title>Help for package seqgendiff</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqgendiff}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#seqgendiff-package'><p>seqgendiff: RNA-Seq Generation/Modification for Simulation</p></a></li>
<li><a href='#corassign'><p>Group assignment that is correlated with latent factors.</p></a></li>
<li><a href='#effective_cor'><p>Estimates the effective correlation.</p></a></li>
<li><a href='#est_sv'><p>Estimate the surrogate variables.</p></a></li>
<li><a href='#fix_cor'><p>Fixes an invalid target correlation.</p></a></li>
<li><a href='#permute_design'><p>Permute the design matrix so that it is approximately correlated with</p>
the surrogate variables.</a></li>
<li><a href='#poisthin'><p>Apply Poisson thinning to a matrix of count data.</p></a></li>
<li><a href='#select_counts'><p>Subsample the rows and columns of a count matrix.</p></a></li>
<li><a href='#summary.ThinData'><p>Provide summary output of a ThinData S3 object.</p></a></li>
<li><a href='#thin_2group'><p>Binomial thinning in the two-group model.</p></a></li>
<li><a href='#thin_all'><p>Binomial thinning for altering read-depth.</p></a></li>
<li><a href='#thin_base'><p>Base binomial thinning function.</p></a></li>
<li><a href='#thin_diff'><p>Binomial thinning for differential expression analysis.</p></a></li>
<li><a href='#thin_gene'><p>Binomial thinning for altering total gene expression levels</p></a></li>
<li><a href='#thin_lib'><p>Binomial thinning for altering library size.</p></a></li>
<li><a href='#ThinDataToDESeqDataSet'><p>Converts a ThinData S3 object into a DESeqDataSet S4 object.</p></a></li>
<li><a href='#ThinDataToSummarizedExperiment'><p>Converts a ThinData S3 object into a SummarizedExperiment S4 object.</p></a></li>
<li><a href='#uncorassign'><p>Group assignment independent of anything.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>RNA-Seq Generation/Modification for Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates/modifies RNA-seq data for use in simulations. We provide
    a suite of functions that will add a known amount of signal to a real 
    RNA-seq dataset. The advantage of using this approach over simulating under
    a theoretical distribution is that common/annoying aspects of the data
    are more preserved, giving a more realistic evaluation of your method. 
    The main functions are select_counts(), thin_diff(), thin_lib(), 
    thin_gene(), thin_2group(), thin_all(), and effective_cor(). See
    Gerard (2020) &lt;<a href="https://doi.org/10.1186%2Fs12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>&gt; for details on the
    implemented methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dcgerard/seqgendiff">https://github.com/dcgerard/seqgendiff</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcgerard/seqgendiff/issues">https://github.com/dcgerard/seqgendiff/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 2.1.0), SummarizedExperiment, DESeq2,
knitr, rmarkdown, airway, limma, qvalue, edgeR</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, irlba, sva, pdist, matchingR, clue</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 10:10:51 UTC; dgerard</td>
</tr>
<tr>
<td>Author:</td>
<td>David Gerard <a href="https://orcid.org/0000-0001-9450-5023"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Gerard &lt;gerard.1787@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='seqgendiff-package'>seqgendiff: RNA-Seq Generation/Modification for Simulation</h2><span id='topic+seqgendiff-package'></span><span id='topic+seqgendiff'></span>

<h3>Description</h3>

<p>This package is designed to take real RNA-seq data and alter it by
adding a known amount of signal. You can then use this modified dataset
in simulation studies for differential expression analysis, factor
analysis, confounder adjustment, or library size adjustment. The
advantage of this way of simulating data is that you can see how
your method behaves when the simulated data exhibit common
(and annoying) features of real data. For example, in the real world
data are not normally (or negative binomially) distributed and
unobserved confounding is a major issue. This package will simulate
data that exhibit these characteristics. The methods used in this
package are described in detail in Gerard (2020).
</p>


<h3>seqgendiff Functions</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a>()</code></dt><dd><p>Subsample the columns and rows
of a real RNA-seq count matrix. You would then feed this sub-matrix
into one of the thinning functions below.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a>()</code></dt><dd><p>The function most users should
be using for general-purpose binomial thinning. For the special
applications of the two-group model or library/gene thinning, see
the functions listed below.</p>
</dd>
<dt><code><a href="#topic+thin_2group">thin_2group</a>()</code></dt><dd><p>The specific application of
thinning in the two-group model.</p>
</dd>
<dt><code><a href="#topic+thin_lib">thin_lib</a>()</code></dt><dd><p>The specific application of
library size thinning.</p>
</dd>
<dt><code><a href="#topic+thin_gene">thin_gene</a>()</code></dt><dd><p>The specific application of
total gene expression thinning.</p>
</dd>
<dt><code><a href="#topic+thin_all">thin_all</a>()</code></dt><dd><p>The specific application of thinning
all counts.</p>
</dd>
<dt><code><a href="#topic+effective_cor">effective_cor</a>()</code></dt><dd><p>Returns an estimate of the actual
correlation between surrogate variables and a user-specified
design matrix.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a>()</code></dt><dd><p>Converts a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a>()</code></dt><dd><p>Converts a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dcgerard/seqgendiff">https://github.com/dcgerard/seqgendiff</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dcgerard/seqgendiff/issues">https://github.com/dcgerard/seqgendiff/issues</a>
</p>
</li></ul>


<hr>
<h2 id='corassign'>Group assignment that is correlated with latent factors.</h2><span id='topic+corassign'></span>

<h3>Description</h3>

<p>We extract latent factors from the log of <code>mat</code> using an SVD, then
generate an underlying group-assignment variable from a conditional
normal distribution (conditional on the latent factors). This underlying
group-assignment variable is used to assign groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corassign(mat, nfac = NULL, corvec = NULL, return = c("group", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corassign_+3A_mat">mat</code></td>
<td>
<p>A matrix of count data. The rows index the individuals and
the columns index the genes.</p>
</td></tr>
<tr><td><code id="corassign_+3A_nfac">nfac</code></td>
<td>
<p>The number of latent factors. If <code>NULL</code>, then we will
use the method of Onatski (2010) to choose the number of latent factors.</p>
</td></tr>
<tr><td><code id="corassign_+3A_corvec">corvec</code></td>
<td>
<p>The vector of correlations. <code>corvec[i]</code> is the correlation
between latent factor <code>i</code> and the underlying group-assignment variable.
You can think of the correlations in <code>corvec</code> as a kind of &quot;tetrachoric
correlation.&quot; If <code>NULL</code>, then it assumes independence between
factors and group assignment. Note that the correlations of the
latent factors with the observed group-assignment vector (instead of the
latent group-assignment vector) will be <code>corvec * sqrt(2 / pi)</code>.</p>
</td></tr>
<tr><td><code id="corassign_+3A_return">return</code></td>
<td>
<p>What should we return? Just the group assignment
(<code>"group"</code>) or a list of a bunch of things (<code>"full"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nfac</code> is provided, then <code>corvec</code> must be the same length as <code>nfac</code>.
If <code>nfac</code> is not provided, then it is assumed that the first <code>nfac</code>
elements of <code>corvec</code> are the underlying correlations, if <code>nfac</code> turns out to be
smaller than the length of <code>corvec</code>. If <code>nfac</code> turns
out to be larger than the length of <code>corvec</code>, then the factors without
defined correlations are assumed to have correlation 0.
</p>


<h3>Value</h3>

<p>A list with some or all of the following elements:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The vector of group assignments. <code>0L</code> indicates
membership to one group and <code>1L</code> indicates membership to
the other group.</p>
</dd>
<dt><code>nfac</code></dt><dd><p>The number of assumed latent factors.</p>
</dd>
<dt><code>facmat</code></dt><dd><p>A matrix, whose columns contain the latent factors.</p>
</dd>
<dt><code>groupfac</code></dt><dd><p>The underlying group-assignment factor.</p>
</dd>
<dt><code>corvec</code></dt><dd><p>The correlation vector. Note that this is the
correlation between random variables observed in <code>groupfac</code>
and <code>facmat</code>, </p>
</dd>
</dl>

<p>If <code>return = "group"</code>, then the list only contains <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li> <p>A. Onatski (2010), Determining the number of factors from empirical distribution of eigenvalues. The Review of Economics and Statistics 92(4).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 1000
ngene &lt;- 10
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 50), nrow = ngene)

## Set target correlation to be 0.9 and nfac to be 1
corvec &lt;- 0.9
nfac   &lt;- 1

## Group assignment
cout &lt;- corassign(mat    = t(Y),
                  nfac   = nfac,
                  corvec = corvec,
                  return = "full")

## Correlation between facmat and groupfac should be about 0.9
cor(cout$facmat, cout$groupfac)

## Correlation between facmat and x should be about 0.9 * sqrt(2 / pi)
cor(cout$facmat, cout$x)
corvec * sqrt(2 / pi)


</code></pre>

<hr>
<h2 id='effective_cor'>Estimates the effective correlation.</h2><span id='topic+effective_cor'></span>

<h3>Description</h3>

<p>Will return the estimated correlation between the design matrix and the
surrogate variables when you assign a target correlation. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_cor(
  design_perm,
  sv,
  target_cor,
  calc_first = c("cor", "mean"),
  method = c("hungarian", "marriage"),
  iternum = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effective_cor_+3A_design_perm">design_perm</code></td>
<td>
<p>A numeric design matrix whose rows are to be permuted
(thus controlling the amount by which they are correlated with the
surrogate variables). The rows index the samples and the columns index
the variables. The intercept should <em>not</em> be included
(though see Section &quot;Unestimable Components&quot;).</p>
</td></tr>
<tr><td><code id="effective_cor_+3A_sv">sv</code></td>
<td>
<p>A matrix of surrogate variables</p>
</td></tr>
<tr><td><code id="effective_cor_+3A_target_cor">target_cor</code></td>
<td>
<p>A numeric matrix of target correlations between the
variables in <code>design_perm</code> and the surrogate variables. The
rows index the observed covariates and the columns index the surrogate
variables. That is, <code>target_cor[i, j]</code> specifies the target
correlation between the <code>i</code>th column of <code>design_perm</code> and the
<code>j</code>th surrogate variable. The surrogate variables are estimated
either using factor analysis or surrogate variable analysis (see the
parameter <code>use_sva</code>).
The number of columns in <code>target_cor</code> specifies the number of
surrogate variables. Set <code>target_cor</code> to <code>NULL</code> to indicate
that <code>design_perm</code> and the surrogate variables are independent.</p>
</td></tr>
<tr><td><code id="effective_cor_+3A_calc_first">calc_first</code></td>
<td>
<p>Should we calculate the correlation of the mean
<code>design_perm</code> and <code>sv</code> (<code>calc_first = "mean"</code>), or
should we calculate the mean of the correlations between
<code>design_perm</code> and <code>sv</code> (<code>calc_first = "cor"</code>)? This
should only be changed by expert users.</p>
</td></tr>
<tr><td><code id="effective_cor_+3A_method">method</code></td>
<td>
<p>Should we use the Gale-Shapley algorithm
for stable marriages (<code>"marriage"</code>) (Gale and Shapley, 1962)
as implemented in the matchingR package, or the Hungarian algorithm
(Papadimitriou and Steiglitz, 1982) (<code>"hungarian"</code>)
as implemented in the clue package (Hornik, 2005)? The
Hungarian method almost always works better, so is the default.</p>
</td></tr>
<tr><td><code id="effective_cor_+3A_iternum">iternum</code></td>
<td>
<p>The total number of simulated correlations to consider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permutes the rows of <code>design_perm</code> many times, each
time calculating the Pearson correlation between the columns of
<code>design_perm</code> and the columns of <code>sv</code>. It then returns the
averages of these Pearson correlations. The permutation is done
using <code><a href="#topic+permute_design">permute_design</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of correlations. The rows index the observed covariates
and the columns index the surrogate variables. Element (i, j) is
the estimated correlation between the ith variable in
<code>design_perm</code> and the jth variable in <code>sv</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gale, David, and Lloyd S. Shapley. &quot;College admissions and the stability of marriage.&quot; <em>The American Mathematical Monthly</em> 69, no. 1 (1962): 9-15. <a href="https://doi.org/10.1080/00029890.1962.11989827">doi:10.1080/00029890.1962.11989827</a>.
</p>
</li>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li>
<li><p>Hornik K (2005). &quot;A CLUE for CLUster Ensembles.&quot; <em>Journal of Statistical Software</em>, 14(12). <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>. <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>.
</p>
</li>
<li><p>C. Papadimitriou and K. Steiglitz (1982), Combinatorial Optimization: Algorithms and Complexity. Englewood Cliffs: Prentice Hall.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate the design matrices and set target correlation -----------------
n &lt;- 10
design_perm &lt;- cbind(rep(c(0, 1), each = n / 2),
                     rep(c(0, 1), length.out = n))
sv &lt;- matrix(rnorm(n))
target_cor &lt;- matrix(c(0.9, 0.1), ncol = 1)

## Get estimated true correlation ------------------------------------------
## You should use a much larger iternum in practice
effective_cor(design_perm = design_perm,
              sv = sv,
              target_cor = target_cor,
              iternum = 10)

</code></pre>

<hr>
<h2 id='est_sv'>Estimate the surrogate variables.</h2><span id='topic+est_sv'></span>

<h3>Description</h3>

<p>This will use either <code><a href="sva.html#topic+sva">sva</a></code> or an SVD on the residuals
of a regression of <code>mat</code> on <code>design_obs</code> to estimate the
surrogate variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_sv(mat, n_sv, design_obs, use_sva = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_sv_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="est_sv_+3A_n_sv">n_sv</code></td>
<td>
<p>The number of surrogate variables.</p>
</td></tr>
<tr><td><code id="est_sv_+3A_design_obs">design_obs</code></td>
<td>
<p>A numeric matrix of observed covariates that are NOT to
be a part of the signal generating process. Only used in estimating the
surrogate variables (if <code>target_cor</code> is not <code>NULL</code>).
The intercept should <em>not</em> be included (it will sometimes
produce an error if it is included).</p>
</td></tr>
<tr><td><code id="est_sv_+3A_use_sva">use_sva</code></td>
<td>
<p>A logical. Should we use surrogate variable analysis
(Leek and Storey, 2008) using <code>design_obs</code>
to estimate the hidden covariates (<code>TRUE</code>)
or should we just do an SVD on <code>log2(mat + 0.5)</code> after
regressing out <code>design_obs</code> (<code>FALSE</code>)? Setting this to
<code>TRUE</code> allows the surrogate variables to be correlated with the
observed covariates, while setting this to <code>FALSE</code> assumes that
the surrogate variables are orthogonal to the observed covariates. This
option only matters if <code>design_obs</code> is not <code>NULL</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of estimated surrogate variables. The columns index the
surrogate variables and the rows index the individuals. The surrogate
variables are centered and scaled to have mean 0 and variance 1.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='fix_cor'>Fixes an invalid target correlation.</h2><span id='topic+fix_cor'></span>

<h3>Description</h3>

<p>Shrinks the target correlation using a uniform scaling factor so that
the overall correlation matrix is positive semi-definite. The method
is described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_cor(design_perm, target_cor, num_steps = 51)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_cor_+3A_design_perm">design_perm</code></td>
<td>
<p>A numeric design matrix whose rows are to be permuted
(thus controlling the amount by which they are correlated with the
surrogate variables). The rows index the samples and the columns index
the variables. The intercept should <em>not</em> be included
(though see Section &quot;Unestimable Components&quot;).</p>
</td></tr>
<tr><td><code id="fix_cor_+3A_target_cor">target_cor</code></td>
<td>
<p>A numeric matrix of target correlations between the
variables in <code>design_perm</code> and the surrogate variables. The
rows index the observed covariates and the columns index the surrogate
variables. That is, <code>target_cor[i, j]</code> specifies the target
correlation between the <code>i</code>th column of <code>design_perm</code> and the
<code>j</code>th surrogate variable. The surrogate variables are estimated
either using factor analysis or surrogate variable analysis (see the
parameter <code>use_sva</code>).
The number of columns in <code>target_cor</code> specifies the number of
surrogate variables. Set <code>target_cor</code> to <code>NULL</code> to indicate
that <code>design_perm</code> and the surrogate variables are independent.</p>
</td></tr>
<tr><td><code id="fix_cor_+3A_num_steps">num_steps</code></td>
<td>
<p>The number of steps between 0 and 1 to take in the
grid search for the shrinkage factor. The step-size would be
<code>1 / (num_steps - 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">W</code> = <code>cor(design_perm)</code>. Let <code class="reqn">R</code> = <code>target_cor</code>.
Then the overall correlation matrix is:
</p>
<p style="text-align: center;"><code class="reqn"> \left(
\begin{array}{cc}
W  &amp; R\\
R' &amp; I_K
\end{array}
\right).
</code>
</p>

<p>This function applies a multiplicative scaling factor to <code class="reqn">R</code> until
the above matrix is positive semi-definite. That is, it finds <code class="reqn">a</code>
between 0 and 1 such that
</p>
<p style="text-align: center;"><code class="reqn"> \left(
\begin{array}{cc}
W  &amp; aR\\
aR' &amp; I_K
\end{array}
\right)
</code>
</p>

<p>is positive semi-definite.
</p>


<h3>Value</h3>

<p>A matrix of correlations the same dimension as <code>target_cor</code>.
Actually, the returned matrix is <code>a * target_cor</code>, where <code>a</code>
was determined to make the overall correlation matrix positive
semi-definite.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
design_perm &lt;- matrix(rep(c(0, 1), length.out = n))
target_cor &lt;- matrix(seq(1, 0, length.out = 10), nrow = 1)
new_cor &lt;- seqgendiff:::fix_cor(design_perm = design_perm, target_cor = target_cor)
new_cor / target_cor

## In the case of one observed covariate, the requirement is just that
## the sum of squared correlations is less than or equal to one.
sum(target_cor ^ 2)
sum(new_cor ^ 2)
</code></pre>

<hr>
<h2 id='permute_design'>Permute the design matrix so that it is approximately correlated with
the surrogate variables.</h2><span id='topic+permute_design'></span>

<h3>Description</h3>

<p>Permute the design matrix so that it is approximately correlated with
the surrogate variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_design(
  design_perm,
  sv,
  target_cor,
  method = c("hungarian", "marriage")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_design_+3A_design_perm">design_perm</code></td>
<td>
<p>A numeric design matrix whose rows are to be permuted
(thus controlling the amount by which they are correlated with the
surrogate variables). The rows index the samples and the columns index
the variables. The intercept should <em>not</em> be included
(though see Section &quot;Unestimable Components&quot;).</p>
</td></tr>
<tr><td><code id="permute_design_+3A_sv">sv</code></td>
<td>
<p>A matrix of surrogate variables</p>
</td></tr>
<tr><td><code id="permute_design_+3A_target_cor">target_cor</code></td>
<td>
<p>A numeric matrix of target correlations between the
variables in <code>design_perm</code> and the surrogate variables. The
rows index the observed covariates and the columns index the surrogate
variables. That is, <code>target_cor[i, j]</code> specifies the target
correlation between the <code>i</code>th column of <code>design_perm</code> and the
<code>j</code>th surrogate variable. The surrogate variables are estimated
either using factor analysis or surrogate variable analysis (see the
parameter <code>use_sva</code>).
The number of columns in <code>target_cor</code> specifies the number of
surrogate variables. Set <code>target_cor</code> to <code>NULL</code> to indicate
that <code>design_perm</code> and the surrogate variables are independent.</p>
</td></tr>
<tr><td><code id="permute_design_+3A_method">method</code></td>
<td>
<p>Should we use the Gale-Shapley algorithm
for stable marriages (<code>"marriage"</code>) (Gale and Shapley, 1962)
as implemented in the matchingR package, or the Hungarian algorithm
(Papadimitriou and Steiglitz, 1982) (<code>"hungarian"</code>)
as implemented in the clue package (Hornik, 2005)? The
Hungarian method almost always works better, so is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<dl>
<dt><code>design_perm</code></dt><dd><p>A row-permuted version of the user-provided
<code>design_perm</code>.</p>
</dd>
<dt><code>latent_var</code></dt><dd><p>A matrix of the latent variables on which
<code>design_perm</code> was matched.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gale, David, and Lloyd S. Shapley. &quot;College admissions and the stability of marriage.&quot; <em>The American Mathematical Monthly</em> 69, no. 1 (1962): 9-15. <a href="https://doi.org/10.1080/00029890.1962.11989827">doi:10.1080/00029890.1962.11989827</a>.
</p>
</li>
<li><p>C. Papadimitriou and K. Steiglitz (1982), Combinatorial Optimization: Algorithms and Complexity. Englewood Cliffs: Prentice Hall.
</p>
</li>
<li><p>Hornik K (2005). &quot;A CLUE for CLUster Ensembles.&quot; <em>Journal of Statistical Software</em>, 14(12). <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>. <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>.
</p>
</li></ul>


<hr>
<h2 id='poisthin'>Apply Poisson thinning to a matrix of count data.</h2><span id='topic+poisthin'></span>

<h3>Description</h3>

<p>This is now defunct. Please try out <code><a href="#topic+select_counts">select_counts</a></code> and
<code><a href="#topic+thin_2group">thin_2group</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisthin(
  mat,
  nsamp = nrow(mat),
  ngene = ncol(mat),
  gselect = c("max", "random", "rand_max", "custom", "mean_max"),
  gvec = NULL,
  skip_gene = 0L,
  signal_fun = stats::rnorm,
  signal_params = list(mean = 0, sd = 1),
  prop_null = 1,
  alpha = 0,
  group_assign = c("frac", "random", "cor"),
  group_prop = 0.5,
  corvec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisthin_+3A_mat">mat</code></td>
<td>
<p>A matrix of count data. The rows index the individuals and
the columns index the genes.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_nsamp">nsamp</code></td>
<td>
<p>The number of samples to select from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_ngene">ngene</code></td>
<td>
<p>The number of genes to select from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_gselect">gselect</code></td>
<td>
<p>How should we select the subset of genes? Should we choose
the <code>ngene</code> most median expressed genes (<code>"max"</code>), a random sample
of the genes (<code>"random"</code>), a random sample of the most expressed
genes (<code>"rand_max"</code>), a user-provided list (<code>"custom"</code>), or by maximum
mean expression level (<code>"mean_max"</code>)?
If <code>"custom"</code>, then <code>gvec</code> should be specified. Expression levels
of a gene are measured by median expression across individuals with ties broken
by mean expression.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_gvec">gvec</code></td>
<td>
<p>A logical of length <code>ncol(mat)</code>. A <code>TRUE</code> in position <code class="reqn">i</code>
indicates inclusion into the smaller dataset. Hence, <code>sum(gvec)</code> should
equal <code>ngene</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_skip_gene">skip_gene</code></td>
<td>
<p>The number of maximally expressed genes to skip.
Not used if <code>gselect = "custom"</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_signal_fun">signal_fun</code></td>
<td>
<p>A function that returns the signal. This should take as
input <code>n</code> for the number of samples to return and then return only
a vector of samples.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_signal_params">signal_params</code></td>
<td>
<p>A list of additional arguments to pass to <code>signal_fun</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_prop_null">prop_null</code></td>
<td>
<p>The proportion of genes that are null.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_alpha">alpha</code></td>
<td>
<p>If <code class="reqn">b</code> is an effect and <code class="reqn">s</code> is an empirical standard deviation, then
we model <code class="reqn">b/s^\alpha</code> as being exchangeable.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_group_assign">group_assign</code></td>
<td>
<p>How should we assign groups? Exactly specifying the
proportion of individuals in each group (<code>"frac"</code>), with a
Bernoulli distribution (<code>"random"</code>), or correlated with latent factors
(<code>"cor"</code>)? If <code>group_assign = "cor"</code>, then you have to specify
<code>corvec</code>. If <code>group_assign = "frac"</code> or
<code>group_assign = "random"</code>, then the proportion of samples in each
group is specified with the <code>group_prop</code> argument.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_group_prop">group_prop</code></td>
<td>
<p>The proportion of individuals that are in group 1.
This proportion is deterministic if <code>group_assign = "frac"</code>, and
is the expected proportion if <code>group_assign = "random"</code>. This
argument is not used if <code>group_assign = "cor"</code>.</p>
</td></tr>
<tr><td><code id="poisthin_+3A_corvec">corvec</code></td>
<td>
<p>A vector of correlations. <code>corvec[i]</code> is the correlation
of the latent group assignment vector with the ith latent confounder.
Only used if <code>group_assign = "cor"</code>. This vector is constrained
so that <code>crossprod(corvec) &lt; 1</code>. The number of latent factors
is taken to be the length of corvec. Note that the correlations of the
latent factors with the observed group-assignment vector (instead of the
latent group-assignment vector) will be <code>corvec * sqrt(2 / pi)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix of RNA-seq counts, this function will randomly select two groups of
samples and add signal to a known proportion of the genes. This signal
is the log (base 2) effect size of the group indicator in a linear model.
The user may specify the distribution of the effects.
</p>
<p>The Poisson thinning approach first randomly assigns samples to be in one of two groups. Then,
given this assignment, will Binomially sample counts with a sample size of the gene expression
counts and a probability that is a function of the effect size. For details, see
Gerard and Stephens (2021).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt><code>Y</code></dt><dd><p>A matrix of altered counts with <code>nsamp</code> rows
and <code>ngene</code> columns.</p>
</dd>
<dt><code>X</code></dt><dd><p>A design matrix. The first column contains a vector ones (for an
intercept term) and the second column contains an indicator for group membership.</p>
</dd>
<dt><code>beta</code></dt><dd><p>The approximately true effect sizes of <code class="reqn">log(Y) ~ X\beta</code>.</p>
</dd>
<dt><code>corassign</code></dt><dd><p>The output from the call to <code><a href="#topic+corassign">corassign</a></code>.
Only returned if <code>group_assign = "cor"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D., and Stephens, M. (2021). &quot;Unifying and Generalizing Methods for Removing Unwanted Variation Based on Negative Controls.&quot; <em>Statistica Sinica</em>, 31(3), 1145-1166 <a href="https://doi.org/10.5705/ss.202018.0345">doi:10.5705/ss.202018.0345</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 10
ngene &lt;- 1000
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 50), nrow = ngene)


## Apply thinning
poisout &lt;- poisthin(mat           = t(Y),
                    nsamp         = 9,
                    ngene         = 999,
                    signal_fun    = stats::rnorm,
                    signal_params = list(mean = 0, sd = 1),
                    prop_null     = 0.9)

## Dimension of count matrix is smaller.
dim(poisout$Y)

## Can verify signal was added by estimating it with lm().
betahat &lt;- coef(lm(log2(poisout$Y + 1) ~ poisout$X[, 2]))[2, ]
plot(poisout$beta, betahat, xlab = "Coefficients", ylab = "Estimates")
abline(0, 1, col = 2, lty = 2)

</code></pre>

<hr>
<h2 id='select_counts'>Subsample the rows and columns of a count matrix.</h2><span id='topic+select_counts'></span>

<h3>Description</h3>

<p>It is a good idea to subsample (each iteration) the genes and samples from
a real RNA-seq dataset prior to applying <code><a href="#topic+thin_diff">thin_diff</a></code>
(and related functions) so that your conclusions are not dependent on the
specific structure of your dataset. This function is designed to efficiently
do this for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_counts(
  mat,
  nsamp = ncol(mat),
  ngene = nrow(mat),
  gselect = c("random", "max", "mean_max", "custom"),
  gvec = NULL,
  filter_first = FALSE,
  nskip = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_counts_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes
and the columns index the samples.</p>
</td></tr>
<tr><td><code id="select_counts_+3A_nsamp">nsamp</code></td>
<td>
<p>The number of samples (columns) to select from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="select_counts_+3A_ngene">ngene</code></td>
<td>
<p>The number of genes (rows) to select from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="select_counts_+3A_gselect">gselect</code></td>
<td>
<p>How should we select the subset of genes? Options include:
</p>

<dl>
<dt><code>random</code></dt><dd><p>Randomly select the genes, with each gene having
an equal probability of being included in the subsampled matrix.</p>
</dd>
<dt><code>max</code></dt><dd><p>Choose the <code>ngene</code> most median-expressed genes.
Ties are broken by mean-expression.</p>
</dd>
<dt><code>mean_max</code></dt><dd><p>Choose the <code>ngene</code> most mean-expressed
genes.</p>
</dd>
<dt><code>custom</code></dt><dd><p>A user-specified list of genes. If
<code>gselect = "custom"</code> then <code>gvec</code> needs to be
non-<code>NULL</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="select_counts_+3A_gvec">gvec</code></td>
<td>
<p>A logical vector of length <code>nrow(mat)</code>. A <code>TRUE</code>
in position <code class="reqn">i</code> indicates inclusion into the smaller dataset.
Hence, <code>sum(gvec)</code> should equal <code>ngene</code>.</p>
</td></tr>
<tr><td><code id="select_counts_+3A_filter_first">filter_first</code></td>
<td>
<p>Should we first filter genes by the method of
Chen et al. (2016) (<code>TRUE</code>) or not (<code>FALSE</code>)? If
<code>TRUE</code> then the <code>edgeR</code> package should be installed.</p>
</td></tr>
<tr><td><code id="select_counts_+3A_nskip">nskip</code></td>
<td>
<p>The number of median-maximally expressed genes to skip.
Not used if <code>gselect = "custom"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples (columns) are chosen randomly, with each sample having
an equal probability of being in the sub-matrix. The genes are selected
according to one of four schemes (see the description of the <code>gselect</code>
argument).
</p>
<p>If you have edgeR installed, then some functionality is provided for
filtering out the lowest expressed genes prior to applying subsampling
(see the <code>filter_first</code> argument).
This filtering scheme is described in Chen et al. (2016).
If you want more control over this filtering, you should use
the <code><a href="edgeR.html#topic+filterByExpr">filterByExpr</a></code> function from edgeR directly. You
can install edgeR by following instructions at
<a href="https://doi.org/10.18129/B9.bioc.edgeR">doi:10.18129/B9.bioc.edgeR</a>.
</p>


<h3>Value</h3>

<p>A numeric matrix, which is a <code>ngene</code> by <code>nsamp</code> sub-matrix
of <code>mat</code>. If <code>rownames(mat)</code> is <code>NULL</code>, then the
row names of the returned matrix are the indices in <code>mat</code> of the
selected genes. If <code>colnames(mat)</code> is <code>NULL</code>, then the
column names of the returned matrix are the indices in <code>mat</code> of
the selected samples.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Chen, Yunshun, Aaron TL Lun, and Gordon K. Smyth. &quot;From reads to genes to pathways: differential expression analysis of RNA-Seq experiments using Rsubread and the edgeR quasi-likelihood pipeline.&quot; <em>F1000Research</em> 5 (2016). <a href="https://doi.org/10.12688/f1000research.8987.2">doi:10.12688/f1000research.8987.2</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from given matrix of counts
## In practice, you would obtain mat from a real dataset, not simulate it.
set.seed(1)
n   &lt;- 100
p   &lt;- 1000
mat &lt;- matrix(stats::rpois(n * p, lambda = 50), nrow = p)

## Subsample the matrix, then feed it into a thinning function
submat &lt;- select_counts(mat = mat, nsamp = 10, ngene = 100)
thout  &lt;- thin_2group(mat = submat, prop_null = 0.5)

## The rownames and colnames (if NULL in mat) tell you which genes/samples
## were selected.
rownames(submat)
colnames(submat)

</code></pre>

<hr>
<h2 id='summary.ThinData'>Provide summary output of a ThinData S3 object.</h2><span id='topic+summary.ThinData'></span>

<h3>Description</h3>

<p>Provide summary output of a ThinData S3 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ThinData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ThinData_+3A_object">object</code></td>
<td>
<p>A ThinData S3 object. This is generally output by either
<code><a href="#topic+thin_diff">thin_diff</a></code>, <code><a href="#topic+thin_2group">thin_2group</a></code>, or
<code><a href="#topic+thin_lib">thin_lib</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ThinData_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing. Prints out some summary information on
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>

<hr>
<h2 id='thin_2group'>Binomial thinning in the two-group model.</h2><span id='topic+thin_2group'></span>

<h3>Description</h3>

<p>Given a matrix of real RNA-seq counts, this function will
randomly assign samples to one of two groups, draw
the log2-fold change in expression between two groups for each gene,
and add this signal to the RNA-seq counts matrix. The user may specify
the proportion of samples in each group, the proportion of null genes
(where the log2-fold change is 0),
and the signal function. This is a specific application of the
general binomial thinning approach implemented in <code><a href="#topic+thin_diff">thin_diff</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_2group(
  mat,
  prop_null = 1,
  signal_fun = stats::rnorm,
  signal_params = list(mean = 0, sd = 1),
  group_prop = 0.5,
  corvec = NULL,
  alpha = 0,
  permute_method = c("hungarian", "marriage"),
  type = c("thin", "mult")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_2group_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_prop_null">prop_null</code></td>
<td>
<p>The proportion of genes that are null.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_signal_fun">signal_fun</code></td>
<td>
<p>A function that returns the signal. This should take as
input <code>n</code> for the number of samples to return and then return only
a vector of samples. Additional parameters may be passed through
<code>signal_params</code>.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_signal_params">signal_params</code></td>
<td>
<p>A list of additional arguments to pass to
<code>signal_fun</code>.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_group_prop">group_prop</code></td>
<td>
<p>The proportion of individuals that are in group 1.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_corvec">corvec</code></td>
<td>
<p>A vector of target correlations. <code>corvec[i]</code> is the
target correlation of the latent group assignment vector with the
<code>i</code>th surrogate variable. The default is to set this to <code>NULL</code>,
in which case group assignment is made independently of any
unobserved confounding.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_alpha">alpha</code></td>
<td>
<p>The scaling factor for the signal distribution from
Stephens (2016). If <code class="reqn">x_1, x_2, ..., x_n</code> are drawn from
<code>signal_fun</code>, then the signal is set to
<code class="reqn">x_1 s_1^{\alpha}, x_2 s_2^{\alpha}, ..., x_n s_n^{\alpha}</code>, where
<code class="reqn">s_g</code> is the empirical standard deviation of gene <code class="reqn">g</code>.
Setting this to <code>0</code> means that the effects are exchangeable, setting
this to <code>1</code> corresponds to the p-value prior of
Wakefield (2009). You would rarely set this to anything but <code>0</code>
or <code>1</code>.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_permute_method">permute_method</code></td>
<td>
<p>Should we use the Gale-Shapley algorithm
for stable marriages (<code>"marriage"</code>) (Gale and Shapley, 1962)
as implemented in the matchingR package, or the Hungarian algorithm
(Papadimitriou and Steiglitz, 1982) (<code>"hungarian"</code>)
as implemented in the clue package (Hornik, 2005)? The
Hungarian method almost always works better, so is the default.</p>
</td></tr>
<tr><td><code id="thin_2group_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific application of binomial thinning to the two-group model was
used in Gerard and Stephens (2018) and Gerard and Stephens (2021). This is
a specific case of the general method described in Gerard (2020).
</p>


<h3>Value</h3>

<p>A list-like S3 object of class <code>ThinData</code>.
Components include some or all of the following:
</p>

<dl>
<dt><code>mat</code></dt><dd><p>The modified matrix of counts.</p>
</dd>
<dt><code>designmat</code></dt><dd><p>The design matrix of variables used to simulate
signal. This is made by column-binding <code>design_fixed</code> and the
permuted version of <code>design_perm</code>.</p>
</dd>
<dt><code>coefmat</code></dt><dd><p>A matrix of coefficients corresponding to
<code>designmat</code>.</p>
</dd>
<dt><code>design_obs</code></dt><dd><p>Additional variables that should be included in
your design matrix in downstream fittings. This is made by
column-binding the vector of 1's with <code>design_obs</code>.</p>
</dd>
<dt><code>sv</code></dt><dd><p>A matrix of estimated surrogate variables. In simulation
studies you would probably leave this out and estimate your own
surrogate variables.</p>
</dd>
<dt><code>cormat</code></dt><dd><p>A matrix of target correlations between the
surrogate variables and the permuted variables in the design matrix.
This might be different from the <code>target_cor</code> you input because
we pass it through <code><a href="#topic+fix_cor">fix_cor</a></code> to ensure
positive semi-definiteness of the resulting covariance matrix.</p>
</dd>
<dt><code>matching_var</code></dt><dd><p>A matrix of simulated variables used to
permute <code>design_perm</code> if the <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gale, David, and Lloyd S. Shapley. &quot;College admissions and the stability of marriage.&quot; <em>The American Mathematical Monthly</em> 69, no. 1 (1962): 9-15. <a href="https://doi.org/10.1080/00029890.1962.11989827">doi:10.1080/00029890.1962.11989827</a>.
</p>
</li>
<li><p>Gerard, D., and Stephens, M. (2021). &quot;Unifying and Generalizing Methods for Removing Unwanted Variation Based on Negative Controls.&quot; <em>Statistica Sinica</em>, 31(3), 1145-1166 <a href="https://doi.org/10.5705/ss.202018.0345">doi:10.5705/ss.202018.0345</a>.
</p>
</li>
<li><p>David Gerard and Matthew Stephens (2018). &quot;Empirical Bayes shrinkage and false discovery rate estimation, allowing for unwanted variation.&quot; <em>Biostatistics</em>, <a href="https://doi.org/10.1093/biostatistics/kxy029">doi:10.1093/biostatistics/kxy029</a>.
</p>
</li>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li>
<li><p>Hornik K (2005). &quot;A CLUE for CLUster Ensembles.&quot; <em>Journal of Statistical Software</em>, 14(12). <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>. <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>.
</p>
</li>
<li><p>C. Papadimitriou and K. Steiglitz (1982), Combinatorial Optimization: Algorithms and Complexity. Englewood Cliffs: Prentice Hall.
</p>
</li>
<li><p>Stephens, Matthew. &quot;False discovery rates: a new deal.&quot; <em>Biostatistics</em> 18, no. 2 (2016): 275-294. <a href="https://doi.org/10.1093/biostatistics/kxw041">doi:10.1093/biostatistics/kxw041</a>.
</p>
</li>
<li><p>Wakefield, Jon. &quot;Bayes factors for genome-wide association studies: comparison with P-values.&quot; <em>Genetic epidemiology</em> 33, no. 1 (2009): 79-86. <a href="https://doi.org/10.1002/gepi.20359">doi:10.1002/gepi.20359</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a></code></dt><dd><p>For the more general thinning approach.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a></code></dt><dd><p>For converting a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a></code></dt><dd><p>For converting a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 10
ngene &lt;- 1000
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 50), nrow = ngene)
thinout &lt;- thin_2group(mat           = Y,
                       prop_null     = 0.9,
                       signal_fun    = stats::rexp,
                       signal_params = list(rate = 0.5))

## 90 percent of genes are null
mean(abs(thinout$coef) &lt; 10^-6)

## Check the estimates of the log2-fold change
Ynew &lt;- log2(t(thinout$mat + 0.5))
X    &lt;- thinout$designmat
Bhat &lt;- coef(lm(Ynew ~ X))["X", ]
plot(thinout$coefmat,
     Bhat,
     xlab = "log2-fold change",
     ylab = "Estimated log2-fold change")
abline(0, 1, col = 2, lwd = 2)

</code></pre>

<hr>
<h2 id='thin_all'>Binomial thinning for altering read-depth.</h2><span id='topic+thin_all'></span>

<h3>Description</h3>

<p>Given a matrix of real RNA-seq counts, this function will apply a
thinning factor uniformly to every count in this matrix. This uniformly
lowers the read-depth for the entire dataset. The thinning factor should
be provided on the log2-scale. This is a specific application of the
binomial thinning approach in <code><a href="#topic+thin_diff">thin_diff</a></code>. Though this particular
form of thinning was used by Robinson and Storey (2014) in the context
of deriving read-depth suggestions. It is also
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_all(mat, thinlog2, type = c("thin", "mult"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_all_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_all_+3A_thinlog2">thinlog2</code></td>
<td>
<p>A numeric scalar. This is the amount to shrink each count
in <code>mat</code> (on the log2-scale).  For
example, a value of 0 means that we do not thin, a value of 1 means
that we thin by a factor of 2, a value of 2 means we thin by a factor
of 4, etc.</p>
</td></tr>
<tr><td><code id="thin_all_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-like S3 object of class <code>ThinData</code>.
Components include some or all of the following:
</p>

<dl>
<dt><code>mat</code></dt><dd><p>The modified matrix of counts.</p>
</dd>
<dt><code>designmat</code></dt><dd><p>The design matrix of variables used to simulate
signal. This is made by column-binding <code>design_fixed</code> and the
permuted version of <code>design_perm</code>.</p>
</dd>
<dt><code>coefmat</code></dt><dd><p>A matrix of coefficients corresponding to
<code>designmat</code>.</p>
</dd>
<dt><code>design_obs</code></dt><dd><p>Additional variables that should be included in
your design matrix in downstream fittings. This is made by
column-binding the vector of 1's with <code>design_obs</code>.</p>
</dd>
<dt><code>sv</code></dt><dd><p>A matrix of estimated surrogate variables. In simulation
studies you would probably leave this out and estimate your own
surrogate variables.</p>
</dd>
<dt><code>cormat</code></dt><dd><p>A matrix of target correlations between the
surrogate variables and the permuted variables in the design matrix.
This might be different from the <code>target_cor</code> you input because
we pass it through <code><a href="#topic+fix_cor">fix_cor</a></code> to ensure
positive semi-definiteness of the resulting covariance matrix.</p>
</dd>
<dt><code>matching_var</code></dt><dd><p>A matrix of simulated variables used to
permute <code>design_perm</code> if the <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li>
<li><p>Robinson, David G., and John D. Storey. &quot;subSeq: determining appropriate sequencing depth through efficient read subsampling.&quot; <em>Bioinformatics</em> 30, no. 23 (2014): 3424-3426. <a href="https://doi.org/10.1093/bioinformatics/btu552">doi:10.1093/bioinformatics/btu552</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a></code></dt><dd><p>For the more general thinning approach.</p>
</dd>
<dt><code><a href="#topic+thin_lib">thin_lib</a></code></dt><dd><p>For thinning sample-wise.</p>
</dd>
<dt><code><a href="#topic+thin_gene">thin_gene</a></code></dt><dd><p>For thinning gene-wise.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a></code></dt><dd><p>For converting a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a></code></dt><dd><p>For converting a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate count data and set thinning factor
## In practice, you would obtain mat from a real dataset, not simulate it.
set.seed(1)
n &lt;- 10
p &lt;- 1000
lambda &lt;- 1000
mat &lt;- matrix(lambda, ncol = n, nrow = p)
thinlog2 &lt;- 1

## Thin read-depths
thout &lt;- thin_all(mat = mat, thinlog2 = thinlog2)

## Compare empirical and theoretical proportions
mean(thout$mat) / lambda
2 ^ -thinlog2

</code></pre>

<hr>
<h2 id='thin_base'>Base binomial thinning function.</h2><span id='topic+thin_base'></span>

<h3>Description</h3>

<p>Given a matrix of counts (<code class="reqn">Y</code>) where <code class="reqn">log_2(E[Y]) = Q</code>,
a design matrix (<code class="reqn">X</code>), and a matrix of coefficients (<code class="reqn">B</code>),
<code>thin_diff</code> will generate a new matrix of counts such that
<code class="reqn">log_2(E[Y]) = BX' + u1' + Q</code>, where <code class="reqn">u</code> is some vector
of intercept coefficients. This function is used by all other
thinning functions. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_base(mat, designmat, coefmat, relative = TRUE, type = c("thin", "mult"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_base_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_base_+3A_designmat">designmat</code></td>
<td>
<p>A design matrix. The rows index the samples and the columns
index the variables. The intercept should <em>not</em> be included.</p>
</td></tr>
<tr><td><code id="thin_base_+3A_coefmat">coefmat</code></td>
<td>
<p>A matrix of coefficients. The rows index the genes and the
columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_base_+3A_relative">relative</code></td>
<td>
<p>A logical. Should we apply relative thinning (<code>TRUE</code>)
or absolute thinning (<code>FALSE</code>). Only experts should change
the default.</p>
</td></tr>
<tr><td><code id="thin_base_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of new RNA-seq read-counts. This matrix has the signal
added from <code>designmat</code> and <code>coefmat</code>.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a></code></dt><dd><p>For the function most users should
be using for general-purpose binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_2group">thin_2group</a></code></dt><dd><p>For the specific application of
thinning in the two-group model.</p>
</dd>
<dt><code><a href="#topic+thin_lib">thin_lib</a></code></dt><dd><p>For the specific application of
library size thinning.</p>
</dd>
<dt><code><a href="#topic+thin_gene">thin_gene</a></code></dt><dd><p>For the specific application of
total gene expression thinning.</p>
</dd>
<dt><code><a href="#topic+thin_all">thin_all</a></code></dt><dd><p>For the specific application of
thinning all counts uniformly.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data from given matrix of counts
## In practice, you would obtain Y from a real dataset, not simulate it.
set.seed(1)
nsamp &lt;- 10
ngene &lt;- 1000
Y &lt;- matrix(stats::rpois(nsamp * ngene, lambda = 100), nrow = ngene)
X &lt;- matrix(rep(c(0, 1), length.out = nsamp))
B &lt;- matrix(seq(3, 0, length.out = ngene))
Ynew &lt;- thin_base(mat = Y, designmat = X, coefmat = B)

## Demonstrate how the log2 effect size is B
Bhat &lt;- coefficients(lm(t(log2(Ynew)) ~ X))["X", ]
plot(B, Bhat, xlab = "Coefficients", ylab = "Coefficient Estimates")
abline(0, 1, col = 2, lwd = 2)

</code></pre>

<hr>
<h2 id='thin_diff'>Binomial thinning for differential expression analysis.</h2><span id='topic+thin_diff'></span>

<h3>Description</h3>

<p>Given a matrix of real RNA-seq counts, this function will add a known
amount of signal to the count matrix. This signal is given in the form
of a Poisson / negative binomial / mixture of negative binomials
generalized linear model with a log (base 2) link. The user may
specify any arbitrary design matrix and coefficient matrix. The user
may also control for the amount of correlation between the observed
covariates and any unobserved surrogate variables. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_diff(
  mat,
  design_fixed = NULL,
  coef_fixed = NULL,
  design_perm = NULL,
  coef_perm = NULL,
  target_cor = NULL,
  use_sva = FALSE,
  design_obs = NULL,
  relative = TRUE,
  change_colnames = TRUE,
  permute_method = c("hungarian", "marriage"),
  type = c("thin", "mult")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_diff_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_design_fixed">design_fixed</code></td>
<td>
<p>A numeric design matrix whose rows are fixed and not
to be permuted. The rows index the samples and the columns index the
variables. The intercept should <em>not</em> be included
(though see Section &quot;Unestimable Components&quot;).</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_coef_fixed">coef_fixed</code></td>
<td>
<p>A numeric matrix. The coefficients corresponding to
<code>design_fixed</code>. The rows index the genes and the columns index
the variables.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_design_perm">design_perm</code></td>
<td>
<p>A numeric design matrix whose rows are to be permuted
(thus controlling the amount by which they are correlated with the
surrogate variables). The rows index the samples and the columns index
the variables. The intercept should <em>not</em> be included
(though see Section &quot;Unestimable Components&quot;).</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_coef_perm">coef_perm</code></td>
<td>
<p>A numeric matrix. The coefficients corresponding to
<code>design_perm</code>. The rows index the genes and the columns index
the variables.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_target_cor">target_cor</code></td>
<td>
<p>A numeric matrix of target correlations between the
variables in <code>design_perm</code> and the surrogate variables. The
rows index the observed covariates and the columns index the surrogate
variables. That is, <code>target_cor[i, j]</code> specifies the target
correlation between the <code>i</code>th column of <code>design_perm</code> and the
<code>j</code>th surrogate variable. The surrogate variables are estimated
either using factor analysis or surrogate variable analysis (see the
parameter <code>use_sva</code>).
The number of columns in <code>target_cor</code> specifies the number of
surrogate variables. Set <code>target_cor</code> to <code>NULL</code> to indicate
that <code>design_perm</code> and the surrogate variables are independent.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_use_sva">use_sva</code></td>
<td>
<p>A logical. Should we use surrogate variable analysis
(Leek and Storey, 2008) using <code>design_obs</code>
to estimate the hidden covariates (<code>TRUE</code>)
or should we just do an SVD on <code>log2(mat + 0.5)</code> after
regressing out <code>design_obs</code> (<code>FALSE</code>)? Setting this to
<code>TRUE</code> allows the surrogate variables to be correlated with the
observed covariates, while setting this to <code>FALSE</code> assumes that
the surrogate variables are orthogonal to the observed covariates. This
option only matters if <code>design_obs</code> is not <code>NULL</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_design_obs">design_obs</code></td>
<td>
<p>A numeric matrix of observed covariates that are NOT to
be a part of the signal generating process. Only used in estimating the
surrogate variables (if <code>target_cor</code> is not <code>NULL</code>).
The intercept should <em>not</em> be included (it will sometimes
produce an error if it is included).</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_relative">relative</code></td>
<td>
<p>A logical. Should we apply relative thinning (<code>TRUE</code>)
or absolute thinning (<code>FALSE</code>). Only experts should change
the default.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_change_colnames">change_colnames</code></td>
<td>
<p>A logical. Should we change the column-names
of the design matrices (<code>TRUE</code>) or not (<code>FALSE</code>)?
Each new column name begins with either &quot;O&quot; (observed), &quot;P&quot; (permuted),
or &quot;F&quot; (fixed), followed by a number. The letters correspond to
whether the variables come from <code>design_obs</code>, <code>design_perm</code>,
or <code>design_fixed</code>. Setting this to <code>TRUE</code>
also changes the column-names of the corresponding coefficient matrices.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_permute_method">permute_method</code></td>
<td>
<p>Should we use the Gale-Shapley algorithm
for stable marriages (<code>"marriage"</code>) (Gale and Shapley, 1962)
as implemented in the matchingR package, or the Hungarian algorithm
(Papadimitriou and Steiglitz, 1982) (<code>"hungarian"</code>)
as implemented in the clue package (Hornik, 2005)? The
Hungarian method almost always works better, so is the default.</p>
</td></tr>
<tr><td><code id="thin_diff_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-like S3 object of class <code>ThinData</code>.
Components include some or all of the following:
</p>

<dl>
<dt><code>mat</code></dt><dd><p>The modified matrix of counts.</p>
</dd>
<dt><code>designmat</code></dt><dd><p>The design matrix of variables used to simulate
signal. This is made by column-binding <code>design_fixed</code> and the
permuted version of <code>design_perm</code>.</p>
</dd>
<dt><code>coefmat</code></dt><dd><p>A matrix of coefficients corresponding to
<code>designmat</code>.</p>
</dd>
<dt><code>design_obs</code></dt><dd><p>Additional variables that should be included in
your design matrix in downstream fittings. This is made by
column-binding the vector of 1's with <code>design_obs</code>.</p>
</dd>
<dt><code>sv</code></dt><dd><p>A matrix of estimated surrogate variables. In simulation
studies you would probably leave this out and estimate your own
surrogate variables.</p>
</dd>
<dt><code>cormat</code></dt><dd><p>A matrix of target correlations between the
surrogate variables and the permuted variables in the design matrix.
This might be different from the <code>target_cor</code> you input because
we pass it through <code><a href="#topic+fix_cor">fix_cor</a></code> to ensure
positive semi-definiteness of the resulting covariance matrix.</p>
</dd>
<dt><code>matching_var</code></dt><dd><p>A matrix of simulated variables used to
permute <code>design_perm</code> if the <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
</dl>



<h3>Mathematical Formulation</h3>

<p>Let
</p>

<dl>
<dt><code class="reqn">N</code></dt><dd><p>Be the number of samples.</p>
</dd>
<dt><code class="reqn">G</code></dt><dd><p>Be the number of genes.</p>
</dd>
<dt><code class="reqn">Y</code></dt><dd><p>Be an <code class="reqn">G</code> by <code class="reqn">N</code> matrix of real RNA-seq counts.
This is <code>mat</code>.</p>
</dd>
<dt><code class="reqn">X_1</code></dt><dd><p>Be an <code class="reqn">N</code> by <code class="reqn">P_1</code> user-provided design matrix.
This is <code>design_fixed</code>.</p>
</dd>
<dt><code class="reqn">X_2</code></dt><dd><p>Be an <code class="reqn">N</code> by <code class="reqn">P_2</code> user-provided design matrix.
This is <code>design_perm</code>.</p>
</dd>
<dt><code class="reqn">X_3</code></dt><dd><p>Be an <code class="reqn">N</code> by <code class="reqn">P_3</code> matrix of known covariates.
This is <code>design_obs</code>.</p>
</dd>
<dt><code class="reqn">Z</code></dt><dd><p>Be an <code class="reqn">N</code> by <code class="reqn">K</code> matrix of unobserved surrogate
variables. This is estimated when <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
<dt><code class="reqn">M</code></dt><dd><p>Be a <code class="reqn">G</code> by <code class="reqn">N</code> of additional (unknown)
unwanted variation.</p>
</dd>
</dl>

<p>We assume that <code class="reqn">Y</code> is Poisson distributed given <code class="reqn">X_3</code> and
<code class="reqn">Z</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\log_2(EY) = \mu 1_N' + B_3X_3' + AZ' + M.</code>
</p>

<p><code>thin_diff()</code> will take as input <code class="reqn">X_1</code>, <code class="reqn">X_2</code>, <code class="reqn">B_1</code>,
<code class="reqn">B_2</code>, and will output a <code class="reqn">\tilde{Y}</code> and <code class="reqn">W</code> such that
<code class="reqn">\tilde{Y}</code> is Poisson distributed given <code class="reqn">X_1</code>, <code class="reqn">X_2</code>, <code class="reqn">X_3</code>,
<code class="reqn">W</code>, <code class="reqn">Z</code>, and <code class="reqn">M</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\log_2(E\tilde{Y}) \approx \tilde{\mu}1_N' + B_1X_1' + B_2X_2'W' + B_3X_3' + AZ' + M,</code>
</p>

<p>where <code class="reqn">W</code> is an <code class="reqn">N</code> by <code class="reqn">N</code> permutation matrix. <code class="reqn">W</code> is randomly
drawn so that <code class="reqn">WX_2</code> and <code class="reqn">Z</code> are correlated approximately according
to the target correlation matrix.
</p>
<p>The Poisson assumption may be generalized to a mixture of negative binomials.
</p>


<h3>Unestimable Components</h3>

<p>It is possible to include an intercept term or a column from
<code>design_obs</code> into either <code>design_fixed</code> or <code>design_perm</code>.
This will not produce an error and the specified thinning will be applied.
However, If any column of <code>design_fixed</code> or
<code>design_perm</code> is a vector of ones or contains a column from
<code>design_obs</code>, then the corresponding columns in <code>coef_fixed</code>
or <code>coef_perm</code> cannot be estimated by <em>any</em> method. This is
represented in the output by having duplicate columns in
<code>designmat</code> and <code>design_obs</code>.
</p>
<p>Including duplicate columns in <code>design_fixed</code> and <code>design_perm</code>
is also allowed but, again, will produce unestimable coefficients.
</p>
<p>Including an intercept term in <code>design_obs</code> will produce an error if
you are specifying correlated surrogate variables.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gale, David, and Lloyd S. Shapley. &quot;College admissions and the stability of marriage.&quot; <em>The American Mathematical Monthly</em> 69, no. 1 (1962): 9-15. <a href="https://doi.org/10.1080/00029890.1962.11989827">doi:10.1080/00029890.1962.11989827</a>.
</p>
</li>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li>
<li><p>Hornik K (2005). &quot;A CLUE for CLUster Ensembles.&quot; <em>Journal of Statistical Software</em>, 14(12). <a href="https://doi.org/10.18637/jss.v014.i12">doi:10.18637/jss.v014.i12</a>.
</p>
</li>
<li><p>Leek, Jeffrey T., and John D. Storey. &quot;A general framework for multiple testing dependence.&quot; <em>Proceedings of the National Academy of Sciences</em> 105, no. 48 (2008): 18718-18723. <a href="https://doi.org/10.1073/pnas.0808709105">doi:10.1073/pnas.0808709105</a>.
</p>
</li>
<li><p>C. Papadimitriou and K. Steiglitz (1982), Combinatorial Optimization: Algorithms and Complexity. Englewood Cliffs: Prentice Hall.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_2group">thin_2group</a></code></dt><dd><p>For the specific application of
<code>thin_diff</code> to the two-group model.</p>
</dd>
<dt><code><a href="#topic+thin_lib">thin_lib</a></code></dt><dd><p>For the specific application of
<code>thin_diff</code> to library size thinning.</p>
</dd>
<dt><code><a href="#topic+thin_gene">thin_gene</a></code></dt><dd><p>For the specific application of
<code>thin_diff</code> to total gene expression thinning.</p>
</dd>
<dt><code><a href="#topic+thin_all">thin_all</a></code></dt><dd><p>For the specific application of
<code>thin_diff</code> to thinning all counts uniformly.</p>
</dd>
<dt><code><a href="#topic+thin_base">thin_base</a></code></dt><dd><p>For the underlying thinning function
used in <code>thin_diff</code>.</p>
</dd>
<dt><code><a href="sva.html#topic+sva">sva</a></code></dt><dd><p>For the implementation of surrogate
variable analysis.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a></code></dt><dd><p>For converting a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a></code></dt><dd><p>For converting a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate simulated data with surrogate variables
## In practice, you would obtain mat from a real dataset, not simulate it.
set.seed(1)
n &lt;- 10
p &lt;- 1000
Z &lt;- matrix(abs(rnorm(n, sd = 4)))
alpha &lt;- matrix(abs(rnorm(p, sd = 1)))
mat &lt;- round(2^(alpha %*% t(Z) + abs(matrix(rnorm(n * p, sd = 5),
                                            nrow = p,
                                            ncol = n))))

## Choose simulation parameters
design_perm &lt;- cbind(rep(c(0, 1), length.out = n), runif(n))
coef_perm &lt;- matrix(rnorm(p * ncol(design_perm), sd = 6), nrow = p)

## Specify one surrogate variable (number of columns in taget_cor),
## highly correlated with first observed covariate and uncorrelated
## with second observed covariate
target_cor &lt;- matrix(c(0.9, 0))

## Thin
thout &lt;- thin_diff(mat = mat,
                   design_perm = design_perm,
                   coef_perm = coef_perm,
                   target_cor = target_cor)

## target_cor approximates correlation between estimated surrogate variable
## and matching variable.
cor(thout$matching_var, thout$sv)

## Estimated surrogate variable is associated with true surrogate variable
## (because the signal is strong in this case)
plot(Z, thout$sv, xlab = "True SV", ylab = "Estimated SV")

## So target_cor approximates correlation between surrogate variable and
## matching variables
cor(thout$matching_var, Z)

## Correlation between permuted covariates and surrogate variables are less
## close to target_cor
cor(thout$designmat, Z)

## Estimated signal is correlated to true single. First variable is slightly
## biased because the surrogate variable is not included.
Ynew &lt;- log2(t(thout$mat) + 0.5)
X &lt;- thout$designmat
coef_est &lt;- t(coef(lm(Ynew ~ X))[2:3, ])

plot(thout$coefmat[, 1], coef_est[, 1],
     main = "First Variable",
     xlab = "Coefficient",
     ylab = "Estimated Coefficient")
abline(0, 1, col = 2, lwd = 2)

plot(thout$coefmat[, 2], coef_est[, 2],
     main = "Second Variable",
     xlab = "Coefficient",
     ylab = "Estimated Coefficient")
abline(0, 1, col = 2, lwd = 2)

## But estimated coefficient of the first variable is slightly closer when
## the surrogate variable is included.
Ynew &lt;- log2(t(thout$mat) + 0.5)
X &lt;- cbind(thout$designmat, thout$sv)
coef_est &lt;- t(coef(lm(Ynew ~ X))[2:3, ])

plot(thout$coefmat[, 1], coef_est[, 1],
     main = "First Variable",
     xlab = "Coefficient",
     ylab = "Estimated Coefficient")
abline(0, 1, col = 2, lwd = 2)

plot(thout$coefmat[, 2], coef_est[, 2],
     main = "Second Variable",
     xlab = "Coefficient",
     ylab = "Estimated Coefficient")
abline(0, 1, col = 2, lwd = 2)

</code></pre>

<hr>
<h2 id='thin_gene'>Binomial thinning for altering total gene expression levels</h2><span id='topic+thin_gene'></span>

<h3>Description</h3>

<p>Given a matrix of real RNA-seq counts, this function will apply a
separate, user-provided thinning factor to each gene. This uniformly
lowers the counts for all samples in a gene. The thinning factor
should be provided on the log2-scale. This is a specific application
of the binomial thinning approach in <code><a href="#topic+thin_diff">thin_diff</a></code>. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_gene(mat, thinlog2, relative = FALSE, type = c("thin", "mult"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_gene_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_gene_+3A_thinlog2">thinlog2</code></td>
<td>
<p>A vector of numerics. Element i is the amount to thin
(on the log2 scale) for gene i. For
example, a value of 0 means that we do not thin, a value of 1 means
that we thin by a factor of 2, a value of 2 means we thin by a factor
of 4, etc.</p>
</td></tr>
<tr><td><code id="thin_gene_+3A_relative">relative</code></td>
<td>
<p>A logical. Should we apply relative thinning (<code>TRUE</code>)
or absolute thinning (<code>FALSE</code>). Only experts should change
the default.</p>
</td></tr>
<tr><td><code id="thin_gene_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-like S3 object of class <code>ThinData</code>.
Components include some or all of the following:
</p>

<dl>
<dt><code>mat</code></dt><dd><p>The modified matrix of counts.</p>
</dd>
<dt><code>designmat</code></dt><dd><p>The design matrix of variables used to simulate
signal. This is made by column-binding <code>design_fixed</code> and the
permuted version of <code>design_perm</code>.</p>
</dd>
<dt><code>coefmat</code></dt><dd><p>A matrix of coefficients corresponding to
<code>designmat</code>.</p>
</dd>
<dt><code>design_obs</code></dt><dd><p>Additional variables that should be included in
your design matrix in downstream fittings. This is made by
column-binding the vector of 1's with <code>design_obs</code>.</p>
</dd>
<dt><code>sv</code></dt><dd><p>A matrix of estimated surrogate variables. In simulation
studies you would probably leave this out and estimate your own
surrogate variables.</p>
</dd>
<dt><code>cormat</code></dt><dd><p>A matrix of target correlations between the
surrogate variables and the permuted variables in the design matrix.
This might be different from the <code>target_cor</code> you input because
we pass it through <code><a href="#topic+fix_cor">fix_cor</a></code> to ensure
positive semi-definiteness of the resulting covariance matrix.</p>
</dd>
<dt><code>matching_var</code></dt><dd><p>A matrix of simulated variables used to
permute <code>design_perm</code> if the <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a></code></dt><dd><p>For the more general thinning approach.</p>
</dd>
<dt><code><a href="#topic+thin_lib">thin_lib</a></code></dt><dd><p>For thinning sample-wise instead of
gene-wise.</p>
</dd>
<dt><code><a href="#topic+thin_all">thin_all</a></code></dt><dd><p>For thinning all counts uniformly.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a></code></dt><dd><p>For converting a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a></code></dt><dd><p>For converting a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate count data and thinning factors
## In practice, you would obtain mat from a real dataset, not simulate it.
set.seed(1)
n &lt;- 10
p &lt;- 1000
lambda &lt;- 1000
mat &lt;- matrix(lambda, ncol = n, nrow = p)
thinlog2 &lt;- rexp(n = p, rate = 1)

## Thin total gene expressions
thout &lt;- thin_gene(mat = mat, thinlog2 = thinlog2)

## Compare empirical thinning proportions to specified thinning proportions
empirical_propvec &lt;- rowMeans(thout$mat) / lambda
specified_propvec &lt;- 2 ^ (-thinlog2)
plot(empirical_propvec, specified_propvec,
     xlab = "Empirical Thinning Proportion",
     ylab = "Specified Thinning Proportion")
abline(0, 1, col = 2, lwd = 2)

</code></pre>

<hr>
<h2 id='thin_lib'>Binomial thinning for altering library size.</h2><span id='topic+thin_lib'></span>

<h3>Description</h3>

<p>Given a matrix of real RNA-seq counts, this function will apply a
separate, user-provided thinning factor to each sample. This uniformly
lowers the counts for all genes in a sample. The thinning factor
should be provided on the log2-scale. This is a specific application
of the binomial thinning approach in <code><a href="#topic+thin_diff">thin_diff</a></code>. The method is
described in detail in Gerard (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin_lib(mat, thinlog2, relative = FALSE, type = c("thin", "mult"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_lib_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix of RNA-seq counts. The rows index the genes and
the columns index the samples.</p>
</td></tr>
<tr><td><code id="thin_lib_+3A_thinlog2">thinlog2</code></td>
<td>
<p>A vector of numerics. Element i is the amount to thin
(on the log2-scale) for sample i. For
example, a value of 0 means that we do not thin, a value of 1 means
that we thin by a factor of 2, a value of 2 means we thin by a factor
of 4, etc.</p>
</td></tr>
<tr><td><code id="thin_lib_+3A_relative">relative</code></td>
<td>
<p>A logical. Should we apply relative thinning (<code>TRUE</code>)
or absolute thinning (<code>FALSE</code>). Only experts should change
the default.</p>
</td></tr>
<tr><td><code id="thin_lib_+3A_type">type</code></td>
<td>
<p>Should we apply binomial thinning (<code>type = "thin"</code>) or
just naive multiplication of the counts (<code>type = "mult"</code>).
You should always have this set to <code>"thin"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-like S3 object of class <code>ThinData</code>.
Components include some or all of the following:
</p>

<dl>
<dt><code>mat</code></dt><dd><p>The modified matrix of counts.</p>
</dd>
<dt><code>designmat</code></dt><dd><p>The design matrix of variables used to simulate
signal. This is made by column-binding <code>design_fixed</code> and the
permuted version of <code>design_perm</code>.</p>
</dd>
<dt><code>coefmat</code></dt><dd><p>A matrix of coefficients corresponding to
<code>designmat</code>.</p>
</dd>
<dt><code>design_obs</code></dt><dd><p>Additional variables that should be included in
your design matrix in downstream fittings. This is made by
column-binding the vector of 1's with <code>design_obs</code>.</p>
</dd>
<dt><code>sv</code></dt><dd><p>A matrix of estimated surrogate variables. In simulation
studies you would probably leave this out and estimate your own
surrogate variables.</p>
</dd>
<dt><code>cormat</code></dt><dd><p>A matrix of target correlations between the
surrogate variables and the permuted variables in the design matrix.
This might be different from the <code>target_cor</code> you input because
we pass it through <code><a href="#topic+fix_cor">fix_cor</a></code> to ensure
positive semi-definiteness of the resulting covariance matrix.</p>
</dd>
<dt><code>matching_var</code></dt><dd><p>A matrix of simulated variables used to
permute <code>design_perm</code> if the <code>target_cor</code> is not
<code>NULL</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>References</h3>


<ul>
<li><p>Gerard, D (2020). &quot;Data-based RNA-seq simulations by binomial thinning.&quot; <em>BMC Bioinformatics</em>. 21(1), 206. <a href="https://doi.org/10.1186/s12859-020-3450-9">doi:10.1186/s12859-020-3450-9</a>.
</p>
</li></ul>



<h3>See Also</h3>


<dl>
<dt><code><a href="#topic+select_counts">select_counts</a></code></dt><dd><p>For subsampling the rows and columns
of your real RNA-seq count matrix prior to applying binomial thinning.</p>
</dd>
<dt><code><a href="#topic+thin_diff">thin_diff</a></code></dt><dd><p>For the more general thinning approach.</p>
</dd>
<dt><code><a href="#topic+thin_gene">thin_gene</a></code></dt><dd><p>For thinning gene-wise instead of
sample-wise.</p>
</dd>
<dt><code><a href="#topic+thin_all">thin_all</a></code></dt><dd><p>For thinning all counts uniformly.</p>
</dd>
<dt><code><a href="#topic+ThinDataToSummarizedExperiment">ThinDataToSummarizedExperiment</a></code></dt><dd><p>For converting a
ThinData object to a SummarizedExperiment object.</p>
</dd>
<dt><code><a href="#topic+ThinDataToDESeqDataSet">ThinDataToDESeqDataSet</a></code></dt><dd><p>For converting a
ThinData object to a DESeqDataSet object.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate count data and thinning factors
## In practice, you would obtain mat from a real dataset, not simulate it.
set.seed(1)
n &lt;- 10
p &lt;- 1000
lambda &lt;- 1000
mat &lt;- matrix(lambda, ncol = n, nrow = p)
thinlog2 &lt;- rexp(n = n, rate = 1)

## Thin library sizes
thout &lt;- thin_lib(mat = mat, thinlog2 = thinlog2)

## Compare empirical thinning proportions to specified thinning proportions
empirical_propvec &lt;- colMeans(thout$mat) / lambda
specified_propvec &lt;- 2 ^ (-thinlog2)
empirical_propvec
specified_propvec

</code></pre>

<hr>
<h2 id='ThinDataToDESeqDataSet'>Converts a ThinData S3 object into a DESeqDataSet S4 object.</h2><span id='topic+ThinDataToDESeqDataSet'></span>

<h3>Description</h3>

<p>The design formula in the resulting DESeqDataSet is just the sum of all
variables in <code>designmat</code> from the ThinData object (except the
intercept term). You should change this design formula if you want to
study other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThinDataToDESeqDataSet(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThinDataToDESeqDataSet_+3A_obj">obj</code></td>
<td>
<p>A ThinData S3 object. This is generally output by either
<code><a href="#topic+thin_diff">thin_diff</a></code>, <code><a href="#topic+thin_2group">thin_2group</a></code>,
<code><a href="#topic+thin_lib">thin_lib</a></code>, <code><a href="#topic+thin_gene">thin_gene</a></code>, or
<code><a href="#topic+thin_all">thin_all</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="DESeq2.html#topic+DESeqDataSet">DESeqDataSet</a></code> S4
object. This will allow you to insert the simulated
data directly into DESeq2.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate simulated data and modify using thin_diff().
## In practice, you would use real data, not simulated.
set.seed(1)
n &lt;- 10
p &lt;- 1000
Z &lt;- matrix(abs(rnorm(n, sd = 4)))
alpha &lt;- matrix(abs(rnorm(p, sd = 1)))
mat &lt;- round(2^(alpha %*% t(Z) + abs(matrix(rnorm(n * p, sd = 5),
                                            nrow = p,
                                            ncol = n))))
design_perm &lt;- cbind(rep(c(0, 1), length.out = n), runif(n))
coef_perm   &lt;- matrix(rnorm(p * ncol(design_perm), sd = 6), nrow = p)
design_obs  &lt;- matrix(rnorm(n), ncol = 1)
target_cor &lt;- matrix(c(0.9, 0))
thout &lt;- thin_diff(mat            = mat,
                   design_perm    = design_perm,
                   coef_perm      = coef_perm,
                   target_cor     = target_cor,
                   design_obs     = design_obs,
                   permute_method = "hungarian")

## Convert ThinData object to DESeqDataSet object.
seobj &lt;- ThinDataToDESeqDataSet(thout)
class(seobj)

## The "O1" variable in the colData corresponds to design_obs.
## The "P1" and "P2" variables in colData correspond to design_perm.
seobj


</code></pre>

<hr>
<h2 id='ThinDataToSummarizedExperiment'>Converts a ThinData S3 object into a SummarizedExperiment S4 object.</h2><span id='topic+ThinDataToSummarizedExperiment'></span>

<h3>Description</h3>

<p>This only keeps the <code>mat</code>, <code>design_obs</code>, <code>designmat</code>,
and <code>coefmat</code> elements of the ThinData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThinDataToSummarizedExperiment(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThinDataToSummarizedExperiment_+3A_obj">obj</code></td>
<td>
<p>A ThinData S3 object. This is generally output by either
<code><a href="#topic+thin_diff">thin_diff</a></code>, <code><a href="#topic+thin_2group">thin_2group</a></code>,
<code><a href="#topic+thin_lib">thin_lib</a></code>, <code><a href="#topic+thin_gene">thin_gene</a></code>, or
<code><a href="#topic+thin_all">thin_all</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code> S4
object. This is often used in Bioconductor when performing
differential expression analysis.
</p>


<h3>Author(s)</h3>

<p>David Gerard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate simulated data and modify using thin_diff().
## In practice, you would use real data, not simulated.
set.seed(1)
n &lt;- 10
p &lt;- 1000
Z &lt;- matrix(abs(rnorm(n, sd = 4)))
alpha &lt;- matrix(abs(rnorm(p, sd = 1)))
mat &lt;- round(2^(alpha %*% t(Z) + abs(matrix(rnorm(n * p, sd = 5),
                                            nrow = p,
                                            ncol = n))))
design_perm &lt;- cbind(rep(c(0, 1), length.out = n), runif(n))
coef_perm   &lt;- matrix(rnorm(p * ncol(design_perm), sd = 6), nrow = p)
design_obs  &lt;- matrix(rnorm(n), ncol = 1)
target_cor &lt;- matrix(c(0.9, 0))
thout &lt;- thin_diff(mat            = mat,
                   design_perm    = design_perm,
                   coef_perm      = coef_perm,
                   target_cor     = target_cor,
                   design_obs     = design_obs,
                   permute_method = "hungarian")

## Convert ThinData object to SummarizedExperiment object.
seobj &lt;- ThinDataToSummarizedExperiment(thout)
class(seobj)

## The "O1" variable in the colData corresponds to design_obs.
## The "P1" and "P2" variables in colData correspond to design_perm.
seobj


</code></pre>

<hr>
<h2 id='uncorassign'>Group assignment independent of anything.</h2><span id='topic+uncorassign'></span>

<h3>Description</h3>

<p>Group assignment independent of anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncorassign(n, return = c("group", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncorassign_+3A_n">n</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="uncorassign_+3A_return">return</code></td>
<td>
<p>Should we just return a list with just the
vector of assignment (<code>"group"</code>)
or a list with the vector of assignments and the vector of latent
variables (<code>"full"</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with some or all of the following elements.
</p>

<dl>
<dt><code>x</code></dt><dd><p>The group assignment. <code>1L</code> for one group and
<code>0L</code> for the other group.</p>
</dd>
<dt><code>w</code></dt><dd><p>The latent assignment vector (only returned if
<code>return = "full"</code>). Negative corresponds to one group
and positive corresponds to the other group.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Gerard
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
