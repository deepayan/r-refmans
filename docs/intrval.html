<!DOCTYPE html><html lang="en"><head><title>Help for package intrval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {intrval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#intrval-package'>
<p>Relational Operators for Intervals</p></a></li>
<li><a href='#+25+5Bc+5D+25'>
<p>Dividing a Range Into 3 Intervals</p></a></li>
<li><a href='#+25ni+25'>
<p>Negated Value Matching</p></a></li>
<li><a href='#intrval'>
<p>Relational Operators Comparing Values to Intervals</p></a></li>
<li><a href='#ovrlap'>
<p>Relational Operators Comparing Two Intervals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Relational Operators for Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluating if values
  of vectors are within different open/closed intervals
  ('x %[]% c(a, b)'), or if two closed
  intervals overlap ('c(a1, b1) %[]o[]% c(a2, b2)').
  Operators for negation and directional relations also implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/intrval">https://github.com/psolymos/intrval</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/intrval/issues">https://github.com/psolymos/intrval/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-20 04:59:01 UTC; Peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-20 12:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='intrval-package'>
Relational Operators for Intervals
</h2><span id='topic+intrval-package'></span>

<h3>Description</h3>

<p>Evaluating if values
  of vectors are within different open/closed intervals
  ('x %[]% c(a, b)'), or if two closed
  intervals overlap ('c(a1, b1) %[]o[]% c(a2, b2)').
  Operators for negation and directional relations also implemented.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> intrval</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Relational Operators for Intervals</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-05-19</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Peter Solymos</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Evaluating if values
  of vectors are within different open/closed intervals
  (`x %[]% c(a, b)`), or if two closed
  intervals overlap (`c(a1, b1) %[]o[]% c(a2, b2)`).
  Operators for negation and directional relations also implemented.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/psolymos/intrval</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/psolymos/intrval/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>


intrval                 Relational Operators Comparing Values to
                        Intervals
intrval-package         Relational Operators for Intervals
ovrlap                  Relational Operators Comparing Two Intervals
</pre>
<p>Relational operators for value-to-interval comparisons:
<code><a href="#topic++25+5B+5D+25">%[]%</a></code> and alikes.
</p>
<p>Relational operators for interval-to-interval comparisons:
<code><a href="#topic++25+5Bo+5D+25">%[o]%</a></code> and alikes.
</p>
<p>Negated value matching: <code><a href="#topic++25ni+25">%ni%</a></code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos
</p>
<p>Maintainer: Peter Solymos &lt;psolymos@gmail.com&gt;
</p>

<hr>
<h2 id='+25+5Bc+5D+25'>
Dividing a Range Into 3 Intervals
</h2><span id='topic++25+5Bc+5D+25'></span><span id='topic++25+5Bc+29+25'></span><span id='topic++25+28c+5D+25'></span><span id='topic++25+28c+29+25'></span>

<h3>Description</h3>

<p>Functions for evaluating if values of vectors are within intervals,
or less than or higher than interval endpoints.
The <code>c</code> within the brackets refer to <code><a href="base.html#topic+cut">cut</a></code>,
a similar function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %[c]% interval
x %[c)% interval
x %(c]% interval
x %(c)% interval
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B5Bc+2B5D+2B25_+3A_x">x</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be compared to interval endpoints.
</p>
</td></tr>
<tr><td><code id="+2B25+2B5Bc+2B5D+2B25_+3A_interval">interval</code></td>
<td>

<p>vector, 2-column matrix, list, or <code>NULL</code>: the interval end points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Values of <code>x</code> are compared to <code>interval</code> endpoints
a and b (a &lt;= b) (see <code><a href="#topic++25+5B+5D+25">%[]%</a></code> for details).
The functions return an integer vector taking values
<code>-1L</code> (value of <code>x</code> is less than or equal to a,
depending on the interval type),
<code>0L</code> (value of <code>x</code> is inside the interval), or
<code>1L</code> (value of <code>x</code> is greater than or equal to b,
depending on the interval type).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>Similar functions (but not quite): <code><a href="base.html#topic+sign">sign</a></code>,
<code><a href="base.html#topic+cut">cut</a></code>, <code><a href="base.html#topic+.bincode">.bincode</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>.
</p>
<p>See relational operators for intervals: <code><a href="#topic++25+5B+5D+25">%[]%</a></code>.
</p>
<p>See <code><a href="base.html#topic+Syntax">Syntax</a></code> for operator precedence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
x %[c]% c(2,4)
x %[c)% c(2,4)
x %(c]% c(2,4)
x %(c)% c(2,4)
</code></pre>

<hr>
<h2 id='+25ni+25'>
Negated Value Matching
</h2><span id='topic++25ni+25'></span><span id='topic++25nin+25'></span><span id='topic++25notin+25'></span>

<h3>Description</h3>

<p><code>%ni%</code> is the negation of <code><a href="base.html#topic++25in+25">%in%</a></code>,
which returns a logical vector indicating if there is a non-match or not
for its left operand. <code>%nin%</code> and <code>%notin%</code> are aliases for
better code readability (<code>%in%</code> can look very much like <code>%ni%</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %ni% table
x %nin% table
x %notin% table
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25ni+2B25_+3A_x">x</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be matched.
</p>
</td></tr>
<tr><td><code id="+2B25ni+2B25_+3A_table">table</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be matched against.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, indicating if a non-match was located for each element of
<code>x</code>: thus the values are <code>TRUE</code> or <code>FALSE</code> and never <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>All the opposite of what is written for <code><a href="base.html#topic++25in+25">%in%</a></code>.
</p>
<p>See relational operators for intervals: <code><a href="#topic++25+5B+5D+25">%[]%</a></code>.
</p>
<p>See <code><a href="base.html#topic+Syntax">Syntax</a></code> for operator precedence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1:10 %ni% c(1,3,5,9)
1:10 %nin% c(1,3,5,9)
1:10 %notin% c(1,3,5,9)

sstr &lt;- c("c","ab","B","bba","c",NA,"@","bla","a","Ba","%")
sstr[sstr %ni% c(letters, LETTERS)]
</code></pre>

<hr>
<h2 id='intrval'>
Relational Operators Comparing Values to Intervals
</h2><span id='topic+intrval'></span><span id='topic+interval'></span><span id='topic++25+5B+5D+25'></span><span id='topic++25+5B+29+25'></span><span id='topic++25+28+5D+25'></span><span id='topic++25+28+29+25'></span><span id='topic++25+5D+5B+25'></span><span id='topic++25+5D+28+25'></span><span id='topic++25+29+5B+25'></span><span id='topic++25+29+28+25'></span><span id='topic++25+5B+3C+5D+25'></span><span id='topic++25+5B+3C+29+25'></span><span id='topic++25+28+3C+5D+25'></span><span id='topic++25+28+3C+29+25'></span><span id='topic++25+5B+3E+5D+25'></span><span id='topic++25+5B+3E+29+25'></span><span id='topic++25+28+3E+5D+25'></span><span id='topic++25+28+3E+29+25'></span><span id='topic+intrval_types'></span>

<h3>Description</h3>

<p>Functions for evaluating if values of vectors are within intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %[]% interval
x %)(% interval
x %[&lt;]% interval
x %[&gt;]% interval

x %[)% interval
x %)[% interval
x %[&lt;)% interval
x %[&gt;)% interval

x %(]% interval
x %](% interval
x %(&lt;]% interval
x %(&gt;]% interval

x %()% interval
x %][% interval
x %(&lt;)% interval
x %(&gt;)% interval

intrval_types(type = NULL, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intrval_+3A_x">x</code></td>
<td>

<p>vector or <code>NULL</code>: the values to be compared to interval endpoints.
</p>
</td></tr>
<tr><td><code id="intrval_+3A_interval">interval</code></td>
<td>

<p>vector, 2-column matrix, list, or <code>NULL</code>: the interval end points.
</p>
</td></tr>
<tr><td><code id="intrval_+3A_type">type</code></td>
<td>

<p>character, type of operator for subsetting the results. The default <code>NULL</code>
means that all types will be displayed.
</p>
</td></tr>
<tr><td><code id="intrval_+3A_plot">plot</code></td>
<td>

<p>logical, whether to plot the results, or print a table to the console instead.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of <code>x</code> are compared to <code>interval</code> endpoints
a and b (a &lt;= b).
Endpoints can be defined as a vector with two values
(<code>c(a, b)</code>): these values will be compared as a single
interval with each value in <code>x</code>.
If endpoints are stored in a matrix-like object or a list,
comparisons are made element-wise. If lengths do not match,
shorter objects are recycled.
These value-to-interval operators work for numeric (integer, real)
and ordered vectors, and object types which are measured at
least on ordinal scale (e.g. dates), see Examples.
Note: interval endpoints are sorted internally thus ensuring the condition
a &lt;= b is not necessary.
</p>
<p>The <code>type</code> argument or the specification of the special function
determines the open (<code>(</code> and <code>)</code>) or
closed (<code>[</code> and <code>]</code>) endpoints and relations.
</p>
<p>There are four types of intervals (<code>[]</code>, <code>[)</code>, <code>(]</code>, <code>()</code>),
their negation (<code>)(</code>, <code>)[</code>, <code>](</code>, <code>][</code>, respectively),
less than (<code>[&lt;]</code>, <code>[&lt;)</code>, <code>(&lt;]</code>, <code>(&lt;)</code>),
and greater than (<code>[&gt;]</code>, <code>[&gt;)</code>, <code>(&gt;]</code>, <code>(&gt;)</code>) relations.
</p>
<p>Note that some operators return identical results but
are syntactically different:
<code>%[&lt;]%</code> and <code>%[&lt;)%</code> both evaluate <code>x &lt; a</code>;
<code>%[&gt;]%</code> and <code>%(&gt;]%</code> both evaluate <code>x &gt; b</code>;
<code>%(&lt;]%</code> and <code>%(&lt;)%</code> evaluate <code>x &lt;= a</code>;
<code>%[&gt;)%</code> and <code>%(&gt;)%</code> both evaluate <code>x &gt;= b</code>.
This is so because we evaluate only one end of the interval
but still conceptually referring to the relationship
defined by the right-hand-side <code>interval</code> object
and given that a &lt;= b.
This implies 2 conditional logical evaluations
instead of treating it as a single 3-level ordered factor.
</p>


<h3>Value</h3>

<p>A logical vector, indicating if <code>x</code> is in the specified interval.
Values are <code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>
(when any of the 3 values (<code>x</code> or endpoints in <code>interval</code>)
are <code>NA</code>).
</p>
<p>The helper function <code>intrval_types</code>
can be used to understand and visualize the operators' effects.
It returns a matrix explaining the properties of the operators.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>See help page for relational operators: <code><a href="base.html#topic+Comparison">Comparison</a></code>.
</p>
<p>See <code><a href="#topic++25+5Bo+5D+25">%[o]%</a></code> for relational operators for
interval-to-interval comparisons.
</p>
<p>See <code><a href="base.html#topic+factor">factor</a></code> for the behavior with factor arguments.
See also <code><a href="base.html#topic++25in+25">%in%</a></code> for value matching
and <code><a href="#topic++25ni+25">%ni%</a></code> for negated value matching
for factors.
</p>
<p>See <code><a href="base.html#topic+Syntax">Syntax</a></code> for operator precedence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## motivating example from example(lm)

## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
## Page 9: Plant Weight Data.
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
lm.D9 &lt;- lm(weight ~ group)
## compare 95% confidence intervals with 0
(CI.D9 &lt;- confint(lm.D9))
0 %[]% CI.D9

## comparing dates

DATE &lt;- as.Date(c("2000-01-01","2000-02-01", "2000-03-31"))
DATE %[&lt;]% as.Date(c("2000-01-151", "2000-03-15"))
DATE %[]% as.Date(c("2000-01-151", "2000-03-15"))
DATE %[&gt;]% as.Date(c("2000-01-151", "2000-03-15"))

## interval formats

x &lt;- rep(4, 5)
a &lt;- 1:5
b &lt;- 3:7
cbind(x=x, a=a, b=b)
x %[]% cbind(a, b) # matrix
x %[]% data.frame(a=a, b=b) # data.frame
x %[]% list(a, b) # list

## helper functions

intrval_types() # print
intrval_types(plot = TRUE) # plot

## graphical examples

## bounding box
set.seed(1)
n &lt;- 10^4
x &lt;- runif(n, -2, 2)
y &lt;- runif(n, -2, 2)
iv1 &lt;- x %[]% c(-1, 1) &amp; y %[]% c(-1, 1)
plot(x, y, pch = 19, cex = 0.25, col = iv1 + 1, main = "Bounding box")

## time series filtering
x &lt;- seq(0, 4*24*60*60, 60*60)
dt &lt;- as.POSIXct(x, origin="2000-01-01 00:00:00")
f &lt;- as.POSIXlt(dt)$hour %[]% c(0, 11)
plot(sin(x) ~ dt, type="l", col="grey",
    main = "Filtering date/time objects")
points(sin(x) ~ dt, pch = 19, col = f + 1)

## watch precedence
(2 * 1:5) %[]% (c(2, 3) * 2)
2 * 1:5 %[]% (c(2, 3) * 2)
(2 * 1:5) %[]% c(2, 3) * 2
2 * 1:5 %[]% c(2, 3) * 2
</code></pre>

<hr>
<h2 id='ovrlap'>
Relational Operators Comparing Two Intervals
</h2><span id='topic+ovrlap'></span><span id='topic+overlap'></span><span id='topic++25+5Bo+5D+25'></span><span id='topic++25+29o+28+25'></span><span id='topic++25+5B+3Co+5D+25'></span><span id='topic++25+5Bo+3E+5D+25'></span><span id='topic++25+28o+29+25'></span><span id='topic++25+5Do+5B+25'></span><span id='topic++25+28+3Co+29+25'></span><span id='topic++25+28o+3E+29+25'></span><span id='topic++25+5B+5Do+5B+5D+25'></span><span id='topic++25+5B+5Do+5B+29+25'></span><span id='topic++25+5B+5Do+28+5D+25'></span><span id='topic++25+5B+5Do+28+29+25'></span><span id='topic++25+5B+29o+5B+5D+25'></span><span id='topic++25+5B+29o+5B+29+25'></span><span id='topic++25+5B+29o+28+5D+25'></span><span id='topic++25+5B+29o+28+29+25'></span><span id='topic++25+28+5Do+5B+5D+25'></span><span id='topic++25+28+5Do+5B+29+25'></span><span id='topic++25+28+5Do+28+5D+25'></span><span id='topic++25+28+5Do+28+29+25'></span><span id='topic++25+28+29o+5B+5D+25'></span><span id='topic++25+28+29o+5B+29+25'></span><span id='topic++25+28+29o+28+5D+25'></span><span id='topic++25+28+29o+28+29+25'></span>

<h3>Description</h3>

<p>Functions for evaluating if two intervals overlap or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval1 %[o]% interval2
interval1 %)o(% interval2
interval1 %[&lt;o]% interval2
interval1 %[o&gt;]% interval2

interval1 %(o)% interval2
interval1 %]o[% interval2
interval1 %(&lt;o)% interval2
interval1 %(o&gt;)% interval2

interval1 %[]o[]% interval2
interval1 %[]o[)% interval2
interval1 %[]o(]% interval2
interval1 %[]o()% interval2
interval1 %[)o[]% interval2
interval1 %[)o[)% interval2
interval1 %[)o(]% interval2
interval1 %[)o()% interval2
interval1 %(]o[]% interval2
interval1 %(]o[)% interval2
interval1 %(]o(]% interval2
interval1 %(]o()% interval2
interval1 %()o[]% interval2
interval1 %()o[)% interval2
interval1 %()o(]% interval2
interval1 %()o()% interval2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ovrlap_+3A_interval1">interval1</code>, <code id="ovrlap_+3A_interval2">interval2</code></td>
<td>

<p>vector, 2-column matrix, list, or <code>NULL</code>: the interval end points
of two (sets) of closed intervals to compare.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The operators define the open/closed nature of the lower/upper
limits of the intervals on the left and right hand side of the <code>o</code>
in the middle.
</p>
<p>The overlap of two closed intervals, [a1, b1] and [a2, b2],
is evaluated by the <code>%[o]%</code> (alias for <code>%[]o[]%</code>)
operator (a1 &lt;= b1, a2 &lt;= b2).
Endpoints can be defined as a vector with two values
(<code>c(a1, b1)</code>)or can be stored in matrix-like objects or a lists
in which case comparisons are made element-wise.
If lengths do not match, shorter objects are recycled.
These value-to-interval operators work for numeric (integer, real)
and ordered vectors, and object types which are measured at
least on ordinal scale (e.g. dates), see Examples.
Note: interval endpoints
are sorted internally thus ensuring the conditions
a1 &lt;= b1 and a2 &lt;= b2 is not necessary.
<code>%)o(%</code> is used for the negation of two closed interval overlap,
directional evaluation is done via the operators
<code>%[&lt;o]%</code> and <code>%[o&gt;]%</code>.
</p>
<p>The overlap of two open intervals
is evaluated by the <code>%(o)%</code> (alias for <code>%()o()%</code>).
<code>%]o[%</code> is used for the negation of two open interval overlap,
directional evaluation is done via the operators
<code>%(&lt;o)%</code> and <code>%(o&gt;)%</code>.
</p>
<p>Overlap operators with mixed endpoint do not have
negation and directional counterparts.
</p>


<h3>Value</h3>

<p>A logical vector, indicating if <code>interval1</code> overlaps <code>interval2</code>.
Values are <code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;solymos@ualberta.ca&gt;
</p>


<h3>See Also</h3>

<p>See help page for relational operators: <code><a href="base.html#topic+Comparison">Comparison</a></code>.
</p>
<p>See <code><a href="#topic++25+5B+5D+25">%[]%</a></code> for relational operators for
value-to-interval comparisons.
</p>
<p>See <code><a href="base.html#topic+factor">factor</a></code> for the behavior with factor arguments.
See also <code><a href="base.html#topic++25in+25">%in%</a></code> for value matching
and <code><a href="#topic++25ni+25">%ni%</a></code> for negated value matching
for factors.
</p>
<p>See <code><a href="base.html#topic+Syntax">Syntax</a></code> for operator precedence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## motivating examples from example(lm)

## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
## Page 9: Plant Weight Data.
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
lm.D90 &lt;- lm(weight ~ group - 1) # omitting intercept
## compare 95% confidence of the 2 groups to each other
(CI.D90 &lt;- confint(lm.D90))
CI.D90[1,] %[o]% CI.D90[2,]

## simple interval comparisons
c(2:3) %[o]% c(0:1)

## vectorized comparisons
c(2:3) %[o]% list(0:4, 1:5)
c(2:3) %[o]% cbind(0:4, 1:5)
c(2:3) %[o]% data.frame(a=0:4, b=1:5)
list(0:4, 1:5) %[o]% c(2:3)
cbind(0:4, 1:5) %[o]% c(2:3)
data.frame(a=0:4, b=1:5) %[o]% c(2:3)

list(0:4, 1:5) %[o]% cbind(rep(2,5), rep(3,5))
cbind(rep(2,5), rep(3,5)) %[o]% list(0:4, 1:5)

cbind(rep(3,5),rep(4,5)) %)o(% cbind(1:5, 2:6)
cbind(rep(3,5),rep(4,5)) %[&lt;o]% cbind(1:5, 2:6)
cbind(rep(3,5),rep(4,5)) %[o&gt;]% cbind(1:5, 2:6)

## open intervals

list(0:4, 1:5) %(o)% cbind(rep(2,5), rep(3,5))
cbind(rep(2,5), rep(3,5)) %(o)% list(0:4, 1:5)

cbind(rep(3,5),rep(4,5)) %]o[% cbind(1:5, 2:6)
cbind(rep(3,5),rep(4,5)) %(&lt;o)% cbind(1:5, 2:6)
cbind(rep(3,5),rep(4,5)) %(o&gt;)% cbind(1:5, 2:6)

dt1 &lt;- as.Date(c("2000-01-01", "2000-03-15"))
dt2 &lt;- as.Date(c("2000-03-15", "2000-06-07"))

dt1 %[]o[]% dt2
dt1 %[]o[)% dt2
dt1 %[]o(]% dt2
dt1 %[]o()% dt2
dt1 %[)o[]% dt2
dt1 %[)o[)% dt2
dt1 %[)o(]% dt2
dt1 %[)o()% dt2
dt1 %(]o[]% dt2
dt1 %(]o[)% dt2
dt1 %(]o(]% dt2
dt1 %(]o()% dt2
dt1 %()o[]% dt2
dt1 %()o[)% dt2
dt1 %()o(]% dt2
dt1 %()o()% dt2

## watch precedence
(2 * c(1, 3)) %[o]% (c(2, 4) * 2)
(2 * c(1, 3)) %[o]% c(2, 4) * 2
2 * c(1, 3) %[o]% (c(2, 4) * 2)
2 * c(1, 3) %[o]% c(2, 4) * 2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
