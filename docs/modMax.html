<!DOCTYPE html><html><head><title>Help for package modMax</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modMax}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modMax-package'>
<p>Calculate network modularity via maximization algorithms</p></a></li>
<li><a href='#extremalOptimization'>
<p>Extremal optimization (EO) algorithms</p></a></li>
<li><a href='#geneticAlgorithm'>
<p>Genetic algorithm</p></a></li>
<li><a href='#greedy'>
<p>Greedy algorithms</p></a></li>
<li><a href='#localModularity'>
<p>Algorithms using local modularity</p></a></li>
<li><a href='#simulatedAnnealing'>
<p>Simulated annealing algorithms</p></a></li>
<li><a href='#spectralOptimization'>
<p>Spectral optimization algorithms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Community Structure Detection via Modularity Maximization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Schelling, Cang Hui</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maria Schelling &lt;schelling.rmaintainer@vodafone.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>gtools, igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>The algorithms implemented here are used to detect the community structure of a network. 
            These algorithms follow different approaches, but are all based on the concept of modularity maximization.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-24 12:53:21 UTC; xxx</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-24 18:21:32</td>
</tr>
</table>
<hr>
<h2 id='modMax-package'>
Calculate network modularity via maximization algorithms
</h2><span id='topic+modMax-package'></span><span id='topic+modMax'></span>

<h3>Description</h3>

<p>Calcuation of modularity and detection of the community strcture of a given network depicted by an (nonnegative symmetric) adjacency matrix using different modularity maximization algorithms 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> modMax</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-02-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>modMax</code> package implements 38 algorithms of 6 major categories maximizing modularity, including the greedy approach, simulated annealing, extremal optimization, genetic algorithm, mathematical programming and the usage of local modularity.
</p>
<p>All algorithms work on connected (consisting of only one connected component), undirected graphs given by their adjacency matrix.
</p>
<p>Most algorithms also provide the possibility to compare the estimated modularity of the identified community structure with the modularity for random networks generated by null models with the number of vertices and edges conserved.
</p>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>
<p>Maintainer: Maria Schelling &lt;schelling.rmaintainer@vodafone.de&gt;
</p>

<hr>
<h2 id='extremalOptimization'>
Extremal optimization (EO) algorithms
</h2><span id='topic+extremalOptimization'></span><span id='topic+pcseoss'></span>

<h3>Description</h3>

<p><code>extremalOptimization</code> is a function executing the extremal optimization approach and its modifications for calculating modularity and detecting communities (modules of nodes) of a network via modularity maximization
</p>
<p><code>pcseoss</code> is a function which uses extremal optimization, but also considers pairwise constraints when calculating the fitness function and the modularity. The violation of constraints is punished, leading to smaller fitness and modularity values for community structures that violate many pairwise constraints. The constraints are predefined as two matrices separately for must-links and cannot-links with punishment for violation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extremalOptimization(adjacency, numRandom = 0, 
                      refine = c("none", "agents"), 
                      tau = FALSE, alpha_max = length(adjacency[1,]), steps = 3)
pcseoss(adjacency,constraints_ml,constraints_cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremalOptimization_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_refine">refine</code></td>
<td>

<p>Specify whether or not a refinement step is needed, the default option is <code>none</code>. See details below.
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_tau">tau</code></td>
<td>

<p>If <code>TRUE</code>, <code class="reqn">\tau</code>-EO is executed where the vertices are ranked according to their fitness values and chosen by a probability depending on this ranking.
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_alpha_max">alpha_max</code></td>
<td>

<p>It gives the maximum number of iteration steps. If the community structure could not be improved for this number of steps, the algorithm terminates. It is <code>1</code> for the normal EO-algorithm and <code>n</code> for the <code class="reqn">\tau</code>-EO where <code>n</code> is the number of vertices in the network
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_steps">steps</code></td>
<td>

<p>The number of iteration steps for the random local search agent algorithm. The algorithm terminates, if the clusters have not changed for this number of steps. Ignored if <code>refine</code> is <code>none</code>.
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_constraints_ml">constraints_ml</code></td>
<td>

<p>The matrix where each column is a must-link constraint given by two vertices in the first two rows which have to be in the same community and a punishment for the violation of the constraint in the third row
</p>
</td></tr>
<tr><td><code id="extremalOptimization_+3A_constraints_cl">constraints_cl</code></td>
<td>

<p>The matrix where each column is a cannot-link constraint given by two vertices in the first two rows which cannot be in the same community and a punishment for the violation of the constraint in the third row
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The EO algorithm can be run with a certain refinement step, the local random search agent algorithm, applied at the end of one round of extremal where all communities have been split once.
</p>
<p>This refinement algorithm is executed if <code>refine</code> equals <code>agent</code>, otherwise the generic EO algorithm is executed.
</p>


<h3>Value</h3>

<p>The result of the extremal optimization algorithms is a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Duch, J. and Arenas, A. Community detection in complex networks using extremal optimization. <em>Phys. Rev. E</em>, 72:027104, Aug 2005.
</p>
<p>Azizifard, N., Mahdavi, M. and Nasersharif, B. Modularity optimization for clustering in social networks. 2011.
</p>
<p>Li, L., Du, M., Liu, G., Hu, X. and Wu, G. Extremal optimization-based semi-supervised algorithm with conflict pairwise constraints for community detection. In <em>Advances in Social Network Analysis and Mining (ASONAM), 2014 IEEE/ACM International Conference
on</em>, 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#weighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)
graph &lt;- set.edge.attribute(graph, "weight", value=runif(ecount(graph),0,1))

adj &lt;- get.adjacency(graph, attr="weight")
result &lt;- extremalOptimization(adj)
</code></pre>

<hr>
<h2 id='geneticAlgorithm'>
Genetic algorithm
</h2><span id='topic+geneticAlgorithm'></span>

<h3>Description</h3>

<p><code>geneticAlgorithm</code> is a function executing the genetic algorithm and its modifications for identifying the community structure of a network via modularity maximization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneticAlgorithm(adjacency, numRandom = 0, 
                  initial = c("general", "cluster", "own"), p, g, 
                  mutRat = 0.5, crossOver = 0.2, beta = 0.1, alpha = 0.4, 
                  n_l = 4, local = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneticAlgorithm_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_initial">initial</code></td>
<td>

<p>Specify the community structure to use as initial partition in the algorithm. See details below.
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_p">p</code></td>
<td>

<p>Population size
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_g">g</code></td>
<td>

<p>Number of generations
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_mutrat">mutRat</code></td>
<td>

<p>Mutation rate. <code>Default</code> is <code>0.5</code>
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_crossover">crossOver</code></td>
<td>

<p>Crossing over rate. <code>Default</code> is <code>0.2</code>
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_beta">beta</code></td>
<td>

<p>The fraction of chromosomes to save. The top <code class="reqn">\beta</code><code class="reqn">p</code> chromosomes are saved in each generation to ensure that the fitness scores of the top <code class="reqn">\beta</code><code class="reqn">p</code> chromosomes of the child generation are at least as good as the parent population. <code>Default</code> is <code>0.1</code>
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_alpha">alpha</code></td>
<td>

<p>The fraction of repetitions for the identification of an initial partition according to <code>cluster</code>. <code>Default</code> is <code>0.4</code>. Ignored if <code>initial</code> is not <code>cluster</code>.
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_n_l">n_l</code></td>
<td>

<p>The number of copies of a chromosome made by the local search operator. <code>Default</code> is <code>4</code>. Ignored if <code>local</code> is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="geneticAlgorithm_+3A_local">local</code></td>
<td>

<p>If <code>TRUE</code>, local search operator is applied at the end of each iteration in the genetic algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the genetic algorithm can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be identified by randomly picking a vertex <code class="reqn">\alpha</code><code class="reqn">n</code> times and assigning its cluster to all its neighbours (<code>initial=cluster</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the genetic algorithm is a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Tasgin, M., Herdagdelen, A., and Bingol, H. Community detection
in complex networks using genetic algorithms. <em>arXiv preprint
arXiv:0711.0491</em>, 2007.
</p>
<p>Li, S., Chen, Y., Du, H., and Feldman, M. W. A genetic algorithm with local search strategy for improved detection of community
structure. <em>Complexity</em>, 15(4):53-60, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#unweighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)

adj &lt;- get.adjacency(graph)
result &lt;- geneticAlgorithm(adj, p=4, g=6)

</code></pre>

<hr>
<h2 id='greedy'>
Greedy algorithms
</h2><span id='topic+greedy'></span><span id='topic+rgplus'></span><span id='topic+msgvm'></span><span id='topic+cd'></span><span id='topic+louvain'></span><span id='topic+vertexSim'></span><span id='topic+mome'></span>

<h3>Description</h3>

<p><code>greedy</code> executes the general CNM algorithm and its modifications for modularity maximization.
</p>
<p><code>rgplus</code> uses the randomized greedy approach to identify core groups (vertices which are always placed into the same community) and uses these core groups as initial partition for the randomized greedy approach to identify the community structure and maximize the modularity.
</p>
<p><code>msgvm</code> is a greedy algorithm which performs more than one merge at one step and applies fast greedy refinement at the end of the algorithm to improve the modularity value.
</p>
<p><code>cd</code> iteratively performs complete greedy refinement on a certain partition and then, moves vertices with a probability <code class="reqn">p</code> to another community to avoid the greedy algorithm getting trapped in a local optimum.
</p>
<p><code>louvain</code> performs fast greedy refinement and uses the resulting community structure to build a new network where vertices in the new network are the communities in the original network. For this new network, all vertices are assigned to their own community, and the fast greedy refinement is applied again.
</p>
<p><code>vertexSim</code> uses a vertex similarity measure to identify the initial partition and further improves this community structure by merging neighbouring communities.
</p>
<p><code>mome</code> consists of the two phases of coarsening and uncoarsening with refinement. In the coarsening phase, two vertices are collapsed into one vertex for which the increase in modularity is maximal. In the uncoarsening phase, each intermediate graph of the coarsening phase is revisited and its community structure is refined by applying fast greedy refinement. After revisiting the different steps, the community structure for the original graph can be reconstructed from different coarsening levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedy(adjacency, numRandom = 0, 
        q = c("general", "danon", "wakita1", "wakita2", "wakita3"), 
        initial = c("general", "prior", "walkers", "subgraph", "adclust", "own"),
        randomized = 0, refine = c("none", "complete", "fast", "kernighan"), 
        coarse = 0)
rgplus(adjacency,numRandom=0,z,randomized)
msgvm(adjacency,numRandom=0,initial=c("general","own"), parL)
cd(adjacency, numRandom=0,initial=c("general","own"),maxC=length(adjacency[,1]),
  iter,p)
louvain(adjacency, numRandom=0, initial=c("general","own"))
vertexSim(adjacency, numRandom=0, frac=0.5)
mome(adjacency, numRandom=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedy_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="greedy_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td></tr>
<tr><td><code id="greedy_+3A_q">q</code></td>
<td>

<p>Specify whether the general <code class="reqn">\Delta</code><code class="reqn">Q</code> value or a modification should be used. See details below.
</p>
</td></tr>
<tr><td><code id="greedy_+3A_initial">initial</code></td>
<td>

<p>Specify the community structure to be used as initial partition in the algorithm. See details below.
</p>
</td></tr>
<tr><td><code id="greedy_+3A_z">z</code></td>
<td>

<p>The number of executions of the randomized greedy approach to identify the core groups.
</p>
</td></tr>
<tr><td><code id="greedy_+3A_randomized">randomized</code></td>
<td>

<p>The number of rows to use for the randomized greedy approach. Ignored when set to <code>0</code> (default)
</p>
</td></tr>
<tr><td><code id="greedy_+3A_refine">refine</code></td>
<td>

<p>specifies which refinement algorithm should be used. See details below.
</p>
</td></tr>
<tr><td><code id="greedy_+3A_coarse">coarse</code></td>
<td>

<p>Define the percentage by which the number of communities has to be decreased since the last coarsening level to consider the current clustering as a new coarsening level and apply refinement on this clustering
</p>
</td></tr>
<tr><td><code id="greedy_+3A_parl">parL</code></td>
<td>

<p>The number of merges at one step in the <code>msgvm</code> algorithm
</p>
</td></tr>
<tr><td><code id="greedy_+3A_maxc">maxC</code></td>
<td>

<p>The maximum number of communities for the initial partition used in the <code>cd</code> algorithm    
</p>
</td></tr>
<tr><td><code id="greedy_+3A_iter">iter</code></td>
<td>

<p>The number of iterations in the <code>cd</code> algorithm
</p>
</td></tr>
<tr><td><code id="greedy_+3A_p">p</code></td>
<td>

<p>The probability with which a vertex is moved into another community in the dilation step of the <code>cd</code> algorithm
</p>
</td></tr>
<tr><td><code id="greedy_+3A_frac">frac</code></td>
<td>

<p>The fraction of iteration steps for which &quot;pairwise&quot; merging is performed in the <code>vertexSim</code> algorithm. Remaining iteration steps are &quot;single neighbour&quot; merges.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>For the identification of the best merging event leading to a maximum increase in modularity, different values of the modularity were proposed. Which modularity value to use is specified by the parameter <code>q</code>. The options are <code>general</code> where the normal value for <code class="reqn">\Delta</code><code class="reqn">Q</code> is used, <code>danon</code> where <code class="reqn">\Delta</code><code class="reqn">Q</code> is normalized by the number of overall edges of vertices in a community and <code>wakita1</code>, <code>wakita2</code> and <code>wakita3</code> where <code class="reqn">\Delta</code><code class="reqn">Q</code> is multiplied by the consolidation ratio.
</p>
<p>The greedy algorithms can be run on different initial partitions. The used initial partition is specified by parameter <code>initial</code>. The options are <code>general</code> where all vertices are assigned to their own community, <code>prior</code> where the initial community structure is identified by using prior knowledge, <code>walkers</code> where the initial community structure is identified by using random walkers, <code>subgraph</code> where the initial community structure is identified by using subgraph similarity, <code>adclust</code> where the general initial partition is refined using fast greedy refinement and <code>own</code> where the user can specify an initial partition to use with the greedy approach. In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>
<p>The community structure identified by the CNM algorithm can be refined by applying a refinement step at the end of the algorithm. The used refinement algorithm is specified by the parameter <code>refine</code>. The options are <code>none</code> where no refinement algorithm is applied, <code>complete</code> where the complete greedy refinement is applied, <code>fast</code> where the fast greedy refinement is applied, <code>kernighan</code> where the adapted Kernighan-Lin refinement is applied. Besides, if <code>initial</code> is set to <code>adclust</code>, fast greedy refinement is applied to the community structure after each merging event.
If <code>coarse != 0</code>, the refinement algorithm specified by <code>refine</code> is not only applied at the end of the algorithm, but at each coarsening level where coarsening levels are defined according to <code>coarse</code>.
</p>


<h3>Value</h3>

<p>The result of the greedy algorithms is a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Clauset, A., Newman, M. and Moore, C. Finding community
structure in very large networks. <em>Phys. Rev. E</em>, 70:066111, Dec 2004.
</p>
<p>Danon, L., Daz-Guilera, A. and Arenas, A. The effect of size
heterogeneity on community identifcation in complex networks. <em>Journal
of Statistical Mechanics: Theory and Experiment</em>, 2006(11):P11010, 2006.
</p>
<p>Wakita, K. and Tsurumi, T. Finding community structure in
mega-scale social networks: [extended abstract]. In <em>Proceedings of the 16th
International Conference on World Wide Web</em>, WWW '07, pages 1275-
1276, New York, NY, USA, 2007. ACM.
</p>
<p>Ovelgonne, M. and Geyer-Schulz, A. Cluster cores and modularity maximization.
In <em>Data Mining Workshops (ICDMW), 2010 IEEE International
Conference on</em>, pages 1204-1213, Dec 2010.
</p>
<p>Du, H., Feldman, M. W., Li, S. and Jin, X. An algorithm
for detecting community structure of social networks based on prior
knowledge and modularity. <em>Complexity</em>, 12(3):53-60, 2007.
</p>
<p>Pujol, J., Bejar, J. and Delgado, J. Clustering algorithm for determining
community structure in large networks. <em>Phys. Rev. E</em>, 74:016107,
Jul 2006.
</p>
<p>Xiang, B., Chen, E.-H. and Zhou, T. Finding community structure
based on subgraph similarity. In Santo Fortunato, Giuseppe Mangioni,
Ronaldo Menezes, and Vincenzo Nicosia, editors, <em>Complex Networks</em>, volume
207 of <em>Studies in Computational Intelligence</em>, pages 73-81. Springer
Berlin Heidelberg, 2009.
</p>
<p>Noack, A. and Rotta, R. Multi-level algorithms for modularity
clustering. Technical report, 2008.
</p>
<p>Ye, Z., Hu, S. and Yu, J. Adaptive clustering algorithm for
community detection in complex networks. <em>Phys. Rev. E</em>, 78:046115, Oct
2008.
</p>
<p>Schuetz, P. and Caflisch, A. Efficient modularity optimization by multistep greedy algorithm and vertex mover refinement. <em>Phys. Rev. E</em>, 77:046112, Apr 2008.
</p>
<p>Mei, J., He, S., Shi, G., Wang, Z., and Li, W. Revealing network communities through modularity maximization by a contractiondilation method. <em>New Journal of Physics</em>, 11(4):043025, 2009.
</p>
<p>Blondel, V. D., Guillaume. J.-L., Lambiotte, R. and Lefebvre, E. Fast unfolding of communities in large networks. <em>Journal of Statistical Mechanics: Theory and Experiment</em>, 2008(10):P10008, 2008.
</p>
<p>Arab, M. and Afsharchi, M. A modularity maximization algorithm
for community detection in social networks with low time complexity.
In <em>Web Intelligence and Intelligent Agent Technology (WI-IAT), 2012
IEEE/WIC/ACM International Conferences on</em>, volume 1, pages 480-487,
Dec 2012.
</p>
<p>Zhu, Z., Wang, C., Ma, L., Pan, Y. and Ding, Z. Scalable community
discovery of large networks. In <em>Web-Age Information Management,
2008. WAIM '08. The Ninth International Conference on</em>, pages 381-388,
July 2008.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#unweighted network
randomgraph1 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices1 &lt;- which(clusters(randomgraph1)$membership==1)  
graph1 &lt;- induced.subgraph(randomgraph1,vertices1)

adj1 &lt;- get.adjacency(graph1)
result1 &lt;- greedy(adj1, refine = "fast")

#weighted network
randomgraph2 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices2 &lt;- which(clusters(randomgraph2)$membership==1)  
graph2 &lt;- induced.subgraph(randomgraph2,vertices2)
graph2 &lt;- set.edge.attribute(graph2, "weight", value=runif(ecount(graph2),0,1))

adj2 &lt;- get.adjacency(graph2, attr="weight")
result2 &lt;- louvain(adj2)
</code></pre>

<hr>
<h2 id='localModularity'>
Algorithms using local modularity
</h2><span id='topic+localModularity'></span><span id='topic+localModularityWang'></span>

<h3>Description</h3>

<p><code>localModularity</code> uses the local modularity to identify the local community structure around a certain vertex
</p>
<p><code>localModularityWang</code> uses the local modularity to identify the community structure of the entire network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localModularity(adjacency, srcV, k)
localModularityWang(adjacency,numRandom=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localModularity_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="localModularity_+3A_srcv">srcV</code></td>
<td>

<p>A given vertex whose local community structure should be determined by<br /> <code>localModularity</code>
</p>
</td></tr>
<tr><td><code id="localModularity_+3A_k">k</code></td>
<td>

<p>The maximum number of vertices to add to the local community of <code>srcV</code>
</p>
</td></tr>
<tr><td><code id="localModularity_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>


<h3>Value</h3>

<p>The result for <code>localModularity</code> is returned as a list with the following components
</p>
<table>
<tr><td><code>local community&lt;br /&gt; structure</code></td>
<td>

<p>Vertices assigned to the same community as the source vertex <code>srcV</code>
</p>
</td></tr>
<tr><td><code>local modularity</code></td>
<td>

<p>The local modularity value for the determined local community
</p>
</td></tr>
</table>
<p>The result for <code>localModularityWang</code> is returned as a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Clauset, A. Finding local community structure in networks. <em>Phys. Rev.
E</em>, 72:026132, Aug 2005.
</p>
<p>Wang, X., Chen, G. and Lu, H. A very fast algorithm for detecting community structures in complex networks. <em>Physica A: Statistical Mechanics and its Applications</em>, 384(2):667-674, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#unweighted network
randomgraph1 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices1 &lt;- which(clusters(randomgraph1)$membership==1)  
graph1 &lt;- induced.subgraph(randomgraph1,vertices1)

adj1 &lt;- get.adjacency(graph1)
result1 &lt;- localModularity(adj1, srcV=1, k=4)

#weighted network
randomgraph2 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices2 &lt;- which(clusters(randomgraph2)$membership==1)  
graph2 &lt;- induced.subgraph(randomgraph2,vertices2)
graph2 &lt;- set.edge.attribute(graph2, "weight", value=runif(ecount(graph2),0,1))

adj2 &lt;- get.adjacency(graph2, attr="weight")
result2 &lt;- localModularityWang(adj2)
</code></pre>

<hr>
<h2 id='simulatedAnnealing'>
Simulated annealing algorithms
</h2><span id='topic+simulatedAnnealing'></span><span id='topic+saIndividualCollectiveMoves'></span>

<h3>Description</h3>

<p>The functions presented here are based on simulated annealing and identify the community structure and maximize the modularity.
<code>simulatedAnnealing</code> is only based on moving a single vertex from one community to another, while <code>saIndividualCollectiveMoves</code> considers movements of vertices, merging of communities and splitting of communities as alternatives to increase the modularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatedAnnealing(adjacency, numRandom = 0, 
                    initial = c("general", "random","greedy", "own"), 
                    beta = length(adjacency[1, ])/2, alpha = 1.005, fixed)
saIndividualCollectiveMoves(adjacency,numRandom=0,initial=c("general","own"),
                            beta=length(adjacency[1,])/2,alpha=1.005,
                            fixed=25,numIter=1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatedAnnealing_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_initial">initial</code></td>
<td>

<p>Specify the community structure to use as the initial partition in the algorithm. See details below.
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_beta">beta</code></td>
<td>

<p>Define the initial inverse temperature. <code>Default</code> is <code>(network size)/2</code>
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_alpha">alpha</code></td>
<td>

<p>Define the cooling parameter. <code>Default</code> is <code>1.005</code>
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_fixed">fixed</code></td>
<td>

<p>If the community structure has not changed for this specified number of steps, the algorithm is terminated.  
</p>
</td></tr>
<tr><td><code id="simulatedAnnealing_+3A_numiter">numIter</code></td>
<td>

<p>Define the iteration factor. At each temperature, the algorithm performs <code class="reqn">fn^2</code> individual moves (movement of a single vertex) and <code class="reqn">fn</code> collective moves (merge or split of a community) where <code class="reqn">n</code> is the number of vertices in the network.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the simulated annealing algorithms can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be identified by randomly identifying the initial number of communities and randomly assigning the vertices to one of these communities (<code>initial=random</code>) or the initial partition can be the community structure identified by the greedy algorithm (<code>initial=greedy</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the simulated annealing algorithms is a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Medus, A., Acua, G. and Dorso, C.O. Detection of community structures
in networks via global optimization. <em>Physica A: Statistical Mechanics and
its Applications</em>, 358(24):593-604, 2005.
</p>
<p>Massen, C. and Doye, J. Identifying communities within energy landscapes. <em>Phys. Rev. E</em>, 71:046101, Apr 2005.
</p>
<p>Guimera, R. and Amaral, L. A. N. Nunes amaral. Functional cartography
of complex metabolic networks. <em>Nature</em>, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#unweighted network
randomgraph &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices &lt;- which(clusters(randomgraph)$membership==1)  
graph &lt;- induced.subgraph(randomgraph,vertices)

adj &lt;- get.adjacency(graph)
result &lt;- simulatedAnnealing(adj, fixed=10)

</code></pre>

<hr>
<h2 id='spectralOptimization'>
Spectral optimization algorithms
</h2><span id='topic+spectralOptimization'></span><span id='topic+multiWay'></span><span id='topic+spectral1'></span><span id='topic+spectral2'></span>

<h3>Description</h3>

<p><code>spectralOptimization</code> uses the leading eigenvector to recursively split the communities of a network into two until no further improvement of modularity is possible.
</p>
<p><code>multiWay</code>, <code>spectral1</code> and <code>spectral2</code> use <code class="reqn">k-1</code> leading eigenvectors to split the network into <code class="reqn">k</code> communities. The value for <code class="reqn">k</code> leading to the best community structure is chosen as the final number of communities and the resulting split of the network into <code class="reqn">k</code> communities as the final community structure. The 3 functions implement slightly different approaches leading to possibly different results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralOptimization(adjacency, numRandom = 0, initial = c("general", "own"),
                      refine = FALSE)
multiWay(adjacency, numRandom=0, maxComm=length(adjacency[1,]))
spectral1(adjacency, numRandom=0, maxComm=(length(adjacency[1,])-1))
spectral2(adjacency, numRandom=0, maxComm=(length(adjacency[1,])-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralOptimization_+3A_adjacency">adjacency</code></td>
<td>

<p>A nonnegative symmetric adjacency matrix of the network whose community structur will be analyzed
</p>
</td></tr>
<tr><td><code id="spectralOptimization_+3A_numrandom">numRandom</code></td>
<td>

<p>The number of random networks with which the modularity of the resulting community structure should be compared (default: no comparison). see details below for further explanation of the used null model.
</p>
</td></tr>
<tr><td><code id="spectralOptimization_+3A_initial">initial</code></td>
<td>

<p>Specify the community structure to use as initial partition in the algorithm. See details below.
</p>
</td></tr>
<tr><td><code id="spectralOptimization_+3A_refine">refine</code></td>
<td>

<p>If <code>TRUE</code>, Kernighan-Lin refinement is applied after splitting a community into two communities only on this part of the network.
</p>
</td></tr>
<tr><td><code id="spectralOptimization_+3A_maxcomm">maxComm</code></td>
<td>

<p>THe maximum number of communities that the network allows
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The used random networks have the same number of vertices and the same degree distribution as the original network.
</p>
<p>The initial partition used in the spectral optimization algorithm can either be the generic one where all vertices are put in their own community (<code>initial=general</code>) or the initial partition can be given by the user (<code>initial=own</code>). In this case, the user needs to add a last column to the adjacency matrix indicating the initial partition. Hence, the adjacency matrix has to have one column more than the network has vertices.
</p>


<h3>Value</h3>

<p>The result of the spectral optimization algorithms is a list with the following components
</p>
<table>
<tr><td><code>number of communities</code></td>
<td>

<p>The number of communities detected by the algorithm
</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>

<p>The modularity of the detected community structure
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>The mean of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>standard deviation</code></td>
<td>

<p>The standard deviation of the modularity values for random networks, only computed if <code>numRandom&gt;0</code> 
</p>
</td></tr>
<tr><td><code>community structure</code></td>
<td>

<p>The community structure of the examined network given by a vector assigning each vertex its community number
</p>
</td></tr>
<tr><td><code>random modularity values</code></td>
<td>

<p>The list of the modularity values for random networks, only computed if <br /><code>numRandom&gt;0</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maria Schelling, Cang Hui
</p>


<h3>References</h3>

<p>Newman, M. Finding community structure in networks using the eigenvectors
of matrices. <em>Phys. Rev. E</em>, 74:036104, Sep 2006.
</p>
<p>Newman, M. E. J. Modularity and community structure in networks.
<em>Proceedings of the National Academy of Sciences</em>, 103(23):8577-8582, 2006.
</p>
<p>Wang, G., Shen, Y., and Ouyang, M. A vector partitioning approach to detecting community structure in complex networks. <em>Computers and Mathematics with Applications</em>, 55(12):2746-2752, 2008.
</p>
<p>White, S. and Smyth, P. A spectral clustering approach to finding communities in graphs. In <em>In SIAM International Conference on Data Mining</em>, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#unweighted network
randomgraph1 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices1 &lt;- which(clusters(randomgraph1)$membership==1)  
graph1 &lt;- induced.subgraph(randomgraph1,vertices1)

adj1 &lt;- get.adjacency(graph1)
result1 &lt;- spectralOptimization(adj1, refine = TRUE)

#weighted network
randomgraph2 &lt;- erdos.renyi.game(10, 0.3, type="gnp",directed = FALSE, loops = FALSE)

#to ensure that the graph is connected
vertices2 &lt;- which(clusters(randomgraph2)$membership==1)  
graph2 &lt;- induced.subgraph(randomgraph2,vertices2)
graph2 &lt;- set.edge.attribute(graph2, "weight", value=runif(ecount(graph2),0,1))

adj2 &lt;- get.adjacency(graph2, attr="weight")
result2 &lt;- multiWay(adj2, maxComm=3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
