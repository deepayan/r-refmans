<!DOCTYPE html><html><head><title>Help for package tcpl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tcpl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.buildAssayQ'><p>Generate query for assay information</p></a></li>
<li><a href='#.convertNames'><p>Convert assay names to their abbreviations</p></a></li>
<li><a href='#.load6DR'><p>Load data for tcpl6</p></a></li>
<li><a href='#.plateHeat'><p>Plot plate heatmap</p></a></li>
<li><a href='#.prepField'><p>Paste appropriate table name to field name</p></a></li>
<li><a href='#blineShift'><p>Shift the baseline to 0</p></a></li>
<li><a href='#chdat'><p>Chemical library of tested chemicals in the example datasets with the corresponding sample IDs.</p></a></li>
<li><a href='#check_tcpl_db_schema'><p>Function that checks if the most recent v3 table schema is used in the database schema</p></a></li>
<li><a href='#Configure functions'><p>Functions for configuring the tcpl package</p></a></li>
<li><a href='#flareFunc'><p>Calculate the weighted mean of a square to detect plate flares</p></a></li>
<li><a href='#Hill model utilites'><p>Functions to solve the Hill model</p></a></li>
<li><a href='#interlaceFunc'><p>Calculate the weighted mean of a square to detect interlace effect</p></a></li>
<li><a href='#invitrodb_dd'><p>Short descriptions of fields for different tables are stored in a data dictionary.</p></a></li>
<li><a href='#is.odd'><p>Check for odd numbers</p></a></li>
<li><a href='#Load assay information'><p>Functions for loading assay information</p></a></li>
<li><a href='#lu'><p>Abbreviation for <code>length(unique(x))</code></p></a></li>
<li><a href='#lw'><p>Abbreviation for <code>length(which(x))</code></p></a></li>
<li><a href='#mc_vignette'><p>List with multi-concentration data for the vignette</p></a></li>
<li><a href='#mc1'><p>Perform level 1</p>
multiple-concentration processing</a></li>
<li><a href='#mc2'><p>Perform level 2</p>
multiple-concentration processing</a></li>
<li><a href='#MC2_Methods'><p>List of level 2 multiple-concentration correction functions</p></a></li>
<li><a href='#mc3'><p>Perform level 3</p>
multiple-concentration processing</a></li>
<li><a href='#MC3_Methods'><p>List of level 3 multiple-concentration normalization methods</p></a></li>
<li><a href='#mc4'><p>Perform level 4</p>
multiple-concentration processing</a></li>
<li><a href='#MC4_Methods'><p>List of level 4 multiple-concentration methods for calculating bmad</p></a></li>
<li><a href='#mc5'><p>Perform level 5</p>
multiple-concentration processing</a></li>
<li><a href='#MC5_Methods'><p>Load list of level 5 multiple-concentration cutoff methods</p></a></li>
<li><a href='#mc6'><p>Perform level 6</p>
multiple-concentration processing</a></li>
<li><a href='#MC6_Methods'><p>Load list of level 6 multiple-concentration flag methods</p></a></li>
<li><a href='#mcdat'><p>A subset of ToxCast data showing changes in the activity of the intracellular estrogen receptor.</p></a></li>
<li><a href='#Method functions'><p>Functions for managing processing methods</p></a></li>
<li><a href='#Models'><p>Model objective functions</p></a></li>
<li><a href='#Query functions'><p>Wrappers for sending queries and fetching results</p></a></li>
<li><a href='#Register/update annotation'><p>Functions for registering &amp; updating annotation information</p></a></li>
<li><a href='#registerMthd'><p>Add a new analysis method</p></a></li>
<li><a href='#sc_vignette'><p>List with single-concentration data for the vignette</p></a></li>
<li><a href='#sc1'><p>Perform level 1</p>
single-concentration processing</a></li>
<li><a href='#SC1_Methods'><p>List of level 1 single-concentration normalization functions</p></a></li>
<li><a href='#sc2'><p>Perform level 2</p>
single-concentration processing</a></li>
<li><a href='#SC2_Methods'><p>List of level 2 single-concentration hit-call functions</p></a></li>
<li><a href='#scdat'><p>A subset of ToxCast data showing changes in transcription factor activity for multiple targets.</p></a></li>
<li><a href='#sink.reset'><p>Reset all sinks</p></a></li>
<li><a href='#tcplAddModel'><p>Draw a tcpl Model onto an existing plot</p></a></li>
<li><a href='#tcplAICProb'><p>Calculate the AIC probabilities</p></a></li>
<li><a href='#tcplAppend'><p>Append rows to a table</p></a></li>
<li><a href='#tcplCascade'><p>Do a cascading delete on tcpl screening data</p></a></li>
<li><a href='#tcplCode2CASN'><p>Convert chemical code to CAS Registry Number</p></a></li>
<li><a href='#tcplCytoPt'><p>Calculate the cytotoxicity point based on the &quot;burst&quot; endpoints</p></a></li>
<li><a href='#tcpldbStats'><p>Get summary statistics for the database</p></a></li>
<li><a href='#tcplDefine'><p>Load data dictionary descriptions</p></a></li>
<li><a href='#tcplDelete'><p>Delete rows from tcpl databases</p></a></li>
<li><a href='#tcplFit'><p>Fit the data with the constant, hill, and gain-loss models</p></a></li>
<li><a href='#tcplFit2'><p>tcpl Wrapper for tcplfit2_core including additional calculations to fit into new schema</p></a></li>
<li><a href='#tcplFit2_nest'><p>Nest dataframe into a list that is readable by tcplfit2</p></a></li>
<li><a href='#tcplFit2_unnest'><p>Unnest tcplfit2 parameters into a dataframe</p></a></li>
<li><a href='#tcplGetAeid'><p>get Aeid for endpoint name</p></a></li>
<li><a href='#tcplggplot'><p>tcplggplot</p></a></li>
<li><a href='#tcplHit2'><p>Hitcalling with tcplfit2</p></a></li>
<li><a href='#tcplListFlds'><p>Load the field names for a table</p></a></li>
<li><a href='#tcplLoadChem'><p>Load sample/chemical information</p></a></li>
<li><a href='#tcplLoadClib'><p>Load chemical library information</p></a></li>
<li><a href='#tcplLoadConcUnit'><p>Load concentration units for assay endpoints</p></a></li>
<li><a href='#tcplLoadData'><p>Load tcpl data</p></a></li>
<li><a href='#tcplLoadUnit'><p>Load response units for assay endpoints</p></a></li>
<li><a href='#tcplLvlCount'><p>Load tcpl level counts</p></a></li>
<li><a href='#tcplMakeAeidMultiPlts'><p>Create a .pdf with all dose-response plots for a given aeid, 6 per page</p></a></li>
<li><a href='#tcplMakeAeidPlts'><p>Create a .pdf with dose-response plots</p></a></li>
<li><a href='#tcplMakeChidMultiPlts'><p>Create a .pdf with all dose-response plots for a given chid, 6 per page</p></a></li>
<li><a href='#tcplMultiplot'><p>Plot summary fits based on fit and dose-response data</p></a></li>
<li><a href='#tcplPlot'><p>#&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>
Generic Plotting Function for tcpl</a></li>
<li><a href='#tcplPlotFitc'><p>Plot the fit category tree</p></a></li>
<li><a href='#tcplPlotFits'><p>Plot summary fits based on fit and dose-response data</p></a></li>
<li><a href='#tcplPlotlyPlot'><p>tcplPlotlyPlot</p></a></li>
<li><a href='#tcplPlotM4ID'><p>Plot fit summary plot by m4id</p></a></li>
<li><a href='#tcplPlotPlate'><p>Plot plate heatmap</p></a></li>
<li><a href='#tcplPrepOtpt'><p>Map assay/chemical ID values to annotation information</p></a></li>
<li><a href='#tcplRun'><p>Perform data processing</p></a></li>
<li><a href='#tcplSubsetChid'><p>Subset level 5 data to a single sample per chemical</p></a></li>
<li><a href='#tcplVarMat'><p>Create chemical by assay matrices</p></a></li>
<li><a href='#tcplWriteData'><p>Write screening data into the tcpl databases</p></a></li>
<li><a href='#tcplWriteLvl0'><p>Write level 0 screening data into the tcpl databases</p></a></li>
<li><a href='#write_lvl_4'><p>Write level 4 with updated schema</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>ToxCast Data Analysis Pipeline</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for processing and modeling high-throughput and
    high-content chemical screening data. The package was developed for the
    the chemical screening data generated by the US EPA ToxCast program, but
    can be used for diverse chemical screening efforts.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USEPA/CompTox-ToxCast-tcpl">https://github.com/USEPA/CompTox-ToxCast-tcpl</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.9.4), DBI, RMariaDB, numDeriv, RColorBrewer,
utils, stats, methods, graphics, grDevices, sqldf, dplyr,
tidyr, plotly, tcplfit2, ggplot2, gridExtra, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, knitr, prettydoc, rmarkdown, htmlTable, testthat
(&ge; 3.0.0), reshape2, viridis, kableExtra, colorspace,
magrittr, vdiffr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-06 15:08:38 UTC; jbrown20</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard S Judson [ctb, ths],
  Dayne L Filer [aut],
  Jason Brown [cre],
  Sarah E Davidson-Fritz
    <a href="https://orcid.org/0000-0002-2891-9380"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Madison Feshuk <a href="https://orcid.org/0000-0002-1390-6405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Lori Kolaczkowski [ctb],
  Kurt Dunham [ctb],
  Carter Thunes [ctb],
  Ashley Ko [ctb],
  Todd Zurlinden [ctb],
  Parth Kothiya [ctb],
  Woodrow R Setzer [ctb],
  Matthew T Martin [ctb, ths],
  Katie Paul Friedman
    <a href="https://orcid.org/0000-0002-2710-1691"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Brown &lt;brown.jason@epa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.buildAssayQ'>Generate query for assay information</h2><span id='topic+.buildAssayQ'></span>

<h3>Description</h3>

<p><code>.buildAssayQ</code> generates a query string to load assay information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.buildAssayQ(out, tblo, fld = NULL, val = NULL, add.fld = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".buildAssayQ_+3A_out">out</code></td>
<td>
<p>Character, the default fields to include</p>
</td></tr>
<tr><td><code id=".buildAssayQ_+3A_tblo">tblo</code></td>
<td>
<p>Integer, the order to send the fields to prepOutput</p>
</td></tr>
<tr><td><code id=".buildAssayQ_+3A_fld">fld</code></td>
<td>
<p>Character, the field(s) to query/subset on</p>
</td></tr>
<tr><td><code id=".buildAssayQ_+3A_val">val</code></td>
<td>
<p>List, vectors of values for each field to query/subset on. Must 
be in the same order as 'fld'.</p>
</td></tr>
<tr><td><code id=".buildAssayQ_+3A_add.fld">add.fld</code></td>
<td>
<p>Character, additional field(s) to include, but not query/
subset on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character containing the query to send to tcplQuery
</p>

<hr>
<h2 id='.convertNames'>Convert assay names to their abbreviations</h2><span id='topic+.convertNames'></span>

<h3>Description</h3>

<p><code>.convertNames</code> converts the assay names as they appear in the tcpl
database to their respective abbreviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convertNames(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".convertNames_+3A_names">names</code></td>
<td>
<p>Character, strings to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same character vector given with any name strings converted to 
the abbreviated version
</p>

<hr>
<h2 id='.load6DR'>Load data for tcpl6</h2><span id='topic+.load6DR'></span>

<h3>Description</h3>

<p><code>.load6DR</code> loads dose-response data for tcpl6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.load6DR(ae)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".load6DR_+3A_ae">ae</code></td>
<td>
<p>String aeid to query on</p>
</td></tr>
</table>

<hr>
<h2 id='.plateHeat'>Plot plate heatmap</h2><span id='topic+.plateHeat'></span>

<h3>Description</h3>

<p>Plot plate heatmap, to be used with tcplPlotPlate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plateHeat(vals, rowi, coli, wllt, wllq, rown, coln, main, arng)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".plateHeat_+3A_vals">vals</code></td>
<td>
<p>Numeric, the well values</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_rowi">rowi</code></td>
<td>
<p>Integer, the row index</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_coli">coli</code></td>
<td>
<p>Integer, the column index</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_wllt">wllt</code></td>
<td>
<p>Character, the well type</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_wllq">wllq</code></td>
<td>
<p>Logical, the well quality</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_rown">rown</code></td>
<td>
<p>Integer, the number of rows on the plate</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_coln">coln</code></td>
<td>
<p>Integer, the number of columns on the plate</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_main">main</code></td>
<td>
<p>Character of length 1, the title/main</p>
</td></tr>
<tr><td><code id=".plateHeat_+3A_arng">arng</code></td>
<td>
<p>Numeric of length 2, the minimum and maximum values to constrain the color scale</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Optimized for an output with height = 20/3, width = 10, and 
pointsize = 10
</p>

<hr>
<h2 id='.prepField'>Paste appropriate table name to field name</h2><span id='topic+.prepField'></span>

<h3>Description</h3>

<p>Paste appropriate table name to field name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepField(fld, tbl, db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prepField_+3A_fld">fld</code></td>
<td>
<p>Character, the table fields</p>
</td></tr>
<tr><td><code id=".prepField_+3A_tbl">tbl</code></td>
<td>
<p>Character, the possible tables</p>
</td></tr>
<tr><td><code id=".prepField_+3A_db">db</code></td>
<td>
<p>Character, the database containing the tables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loops through the given tables, and for each field i it assigns
the last table containing i to i. ORDER OF FLD MATTERS!!
</p>

<hr>
<h2 id='blineShift'>Shift the baseline to 0</h2><span id='topic+blineShift'></span>

<h3>Description</h3>

<p><code>blineShift</code> Takes in dose-response data and shifts the baseline
to 0 based on the window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blineShift(resp, logc, wndw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blineShift_+3A_resp">resp</code></td>
<td>
<p>Numeric, the response values</p>
</td></tr>
<tr><td><code id="blineShift_+3A_logc">logc</code></td>
<td>
<p>Numeric, the log10 concentration values</p>
</td></tr>
<tr><td><code id="blineShift_+3A_wndw">wndw</code></td>
<td>
<p>Numeric, the threshold window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the shifted response values
</p>


<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc3_mthds">mc3_mthds</a></code>, <code><a href="#topic+mc3">mc3</a></code>
</p>

<hr>
<h2 id='chdat'>Chemical library of tested chemicals in the example datasets with the corresponding sample IDs.</h2><span id='topic+chdat'></span>

<h3>Description</h3>

<p>Chemical library of tested chemicals in the example datasets with the corresponding sample IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chdat
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 6 variables:
</p>

<dl>
<dt>spid</dt><dd><p>sample ID</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>chid</dt><dd><p>unique chemical ID number for tcpl</p>
</dd>
</dl>



<h3>Source</h3>

<p>ToxCast database
</p>

<hr>
<h2 id='check_tcpl_db_schema'>Function that checks if the most recent v3 table schema is used in the database schema</h2><span id='topic+check_tcpl_db_schema'></span>

<h3>Description</h3>

<p>Function that checks if the most recent v3 table schema is used in the database schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tcpl_db_schema()
</code></pre>


<h3>Value</h3>

<p>boolean TRUE if param tables are listed in schema FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#connect to database first with tcplConf
tcplConf(user=user,
 pass= pass,
 db=dbname,
 drvr='MySQL',
 host=hostname)
 
#check if it is part of the new schema
new_schema &lt;- check_tcpl_db_schema()

## End(Not run)
</code></pre>

<hr>
<h2 id='Configure+20functions'>Functions for configuring the tcpl package</h2><span id='topic+Configure+20functions'></span><span id='topic+tcplConf'></span><span id='topic+tcplConfDefault'></span><span id='topic+tcplConfExample'></span><span id='topic+tcplConfList'></span><span id='topic+tcplConfLoad'></span><span id='topic+tcplConfReset'></span><span id='topic+tcplConfSave'></span>

<h3>Description</h3>

<p>These functions are used to configure the tcpl settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplConf(drvr = NULL, user = NULL, pass = NULL, host = NULL, db = NULL, ...)

tcplConfDefault()

tcplConfExample()

tcplConfList(show.pass = FALSE)

tcplConfLoad(list.new = TRUE)

tcplConfReset()

tcplConfSave()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Configure+2B20functions_+3A_drvr">drvr</code></td>
<td>
<p>Character of length 1, which database driver to use</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_user">user</code></td>
<td>
<p>Character of length 1, the database server username</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_pass">pass</code></td>
<td>
<p>Character of length 1, the database server password</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_host">host</code></td>
<td>
<p>Character of length 1, the database server</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_db">db</code></td>
<td>
<p>Character of length 1, the name of the tcpl database</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_...">...</code></td>
<td>
<p>Additional arguments that should be passed to dbConnect function</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_show.pass">show.pass</code></td>
<td>
<p>Logical, should the password be returned</p>
</td></tr>
<tr><td><code id="Configure+2B20functions_+3A_list.new">list.new</code></td>
<td>
<p>Logical of length 1, should the new settings be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the tcpl package only supports the &quot;MySQL&quot; and &quot;tcplLite&quot; database
drivers.
</p>
<p>The settings can be stored in a configuration file to make the using the 
package more user-friendly. To create the configuration file, the user must
first create a system environment variable ('TCPL_CONF') that points to to 
the file. There is more information about system environment variables in
<code><a href="base.html#topic+Startup">Startup</a></code> and <code><a href="base.html#topic+Sys.getenv">Sys.getenv</a></code>. Briefly, the user 
needs to modify the '.Renviron' file in their home directory. If the file
does not exist, create it, and add the following line:
</p>
<p>TCPL_CONF=path/to/confFile.conf
</p>
<p>Here 'path/to/confFile.conf' can be any path to a file. One suggestion would
be to include .tcplConf in the home directory, e.g. TCPL_CONF=~/.tcplConf. 
Note, '~' may not indicate the home directory on every operating system.
Once the environment variable is added, the user can change the settings
using <code>tcplConf</code>, then save the settings to the file given by the
TCPL_CONF environment variable running <code>tcplConfSave()</code>. 
</p>
<p><code>tcplConf</code> changes <code>options</code> to set the tcpl-specific options, 
most importantly to configure the connection to the tcpl databases. 
<code>tcplConf</code> will only change non-null values, and can be used to 
change a single value if needed. 
</p>
<p><code>tcplConfSave</code> modifies the configuration file to reflect the current
tcpl settings.
</p>
<p><code>tcplConfList</code> lists the values assigned to the tcpl global options.
</p>
<p><code>tcplConfLoad</code> updates the tcpl settings to reflect the current 
configuration file.
</p>
<p><code>tcplConfDefault</code> changes the <code>options</code> to reflect the default
settings for the example tcplLite database, i.e. local directory, but does  
not alter the configuration file.
</p>
<p><code>tcplConfReset</code> is used to generate the initial configuration script,
and can be used to reset or regenerate the configuration script by the user.
</p>

<hr>
<h2 id='flareFunc'>Calculate the weighted mean of a square to detect plate flares</h2><span id='topic+flareFunc'></span>

<h3>Description</h3>

<p><code>flareFunc</code> calculates the weighted mean of square regions to detect
plate flares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flareFunc(val, coli, rowi, apid, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flareFunc_+3A_val">val</code></td>
<td>
<p>Numeric, the well values</p>
</td></tr>
<tr><td><code id="flareFunc_+3A_coli">coli</code></td>
<td>
<p>Integer, the well column index</p>
</td></tr>
<tr><td><code id="flareFunc_+3A_rowi">rowi</code></td>
<td>
<p>Integer, the well row index</p>
</td></tr>
<tr><td><code id="flareFunc_+3A_apid">apid</code></td>
<td>
<p>Character, the assay plate id</p>
</td></tr>
<tr><td><code id="flareFunc_+3A_r">r</code></td>
<td>
<p>Integer, the number of wells from the center well (in one 
direction) to make the square</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MC6_Methods">MC6_Methods</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code>, 
<code><a href="#topic+mc6">mc6</a></code>
</p>

<hr>
<h2 id='Hill+20model+20utilites'>Functions to solve the Hill model</h2><span id='topic+Hill+20model+20utilites'></span><span id='topic+tcplHillACXX'></span><span id='topic+tcplHillConc'></span><span id='topic+tcplHillVal'></span>

<h3>Description</h3>

<p>These functions solve for Hill model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplHillACXX(XX, tp, ga, gw, bt = 0)

tcplHillConc(val, tp, ga, gw, bt = 0)

tcplHillVal(logc, tp, ga, gw, bt = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_xx">XX</code></td>
<td>
<p>Numeric, the activity level (percentage of the top value)</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_tp">tp</code></td>
<td>
<p>Numeric, the top value from the Hill model</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_ga">ga</code></td>
<td>
<p>Numeric, the logAC50 value from the Hill model</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_gw">gw</code></td>
<td>
<p>Numeric, the Hill coefficient from the Hill model</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_bt">bt</code></td>
<td>
<p>Numeric, the bottom value from the Hill model</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_val">val</code></td>
<td>
<p>Numeric, the activity value</p>
</td></tr>
<tr><td><code id="Hill+2B20model+2B20utilites_+3A_logc">logc</code></td>
<td>
<p>Numeric, the log concentration</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplHillVal</code> computes the value of the Hill model for a given log 
concentration. 
</p>
<p><code>tcplHillACXX</code> computes the activity concentration for a Hill model for 
a given activity level.
</p>
<p><code>tcplHillConc</code> computes the Hill model concentration for a 
given value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following code gives examples for a Hill model with a top of 50, 
## bottom of 0, AC50 of 1 and Hill coefficient of 1.
## tcplHillVal calculates activity value given a concentration. tcplHillVal
## will return the tp/2 when logc equals ga:
tcplHillVal(logc = 1, tp = 50, ga = 1, gw = 1, bt = 0)

## Here, tcplHillConc returns the concentration where the value equals 20
tcplHillConc(val = 20, tp = 50, ga = 1, gw = 1, bt = 0)

## Note how this differs from tcplHillACXX:
tcplHillACXX(XX = 20, tp = 50, ga = 1, gw = 1, bt = 0)

## tcplHillACXX is based on the top value and allows the user to calculate 
## specifc activity concentrations based on a percentage of the top value

## For example, we can calculate the value for the concentration 0.25, then
## use that value to check the other two functions.

value &lt;- tcplHillVal(logc = 0.25, tp = 50, ga = 1, gw = 1, bt = 0)
c1 &lt;- tcplHillConc(val = value, tp = 50, ga = 1, gw = 1, bt = 0)
c2 &lt;- tcplHillACXX(XX = value/50*100, tp = 50, ga = 1, gw = 1, bt = 0)
all.equal(0.25, c1, c2)

## Notice, the value had to be transformed to a percentage of the top value
## when using tcplHillACXX
</code></pre>

<hr>
<h2 id='interlaceFunc'>Calculate the weighted mean of a square to detect interlace effect</h2><span id='topic+interlaceFunc'></span>

<h3>Description</h3>

<p><code>interlaceFunc</code> calculates the distance weighted mean of square regions
from a 384-well plate that is interlaced onto a 1536 well plate to detect
non-random signals coming from the source plate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interlaceFunc(val, intq, coli, rowi, apid, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interlaceFunc_+3A_val">val</code></td>
<td>
<p>Numeric, the well values</p>
</td></tr>
<tr><td><code id="interlaceFunc_+3A_intq">intq</code></td>
<td>
<p>Numeric, interlace quadrant</p>
</td></tr>
<tr><td><code id="interlaceFunc_+3A_coli">coli</code></td>
<td>
<p>Integer, the well column index</p>
</td></tr>
<tr><td><code id="interlaceFunc_+3A_rowi">rowi</code></td>
<td>
<p>Integer, the well row index</p>
</td></tr>
<tr><td><code id="interlaceFunc_+3A_apid">apid</code></td>
<td>
<p>Character, the assay plate id</p>
</td></tr>
<tr><td><code id="interlaceFunc_+3A_r">r</code></td>
<td>
<p>Integer, the number of wells from the center well (in one 
direction) to make the square</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MC6_Methods">MC6_Methods</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code>, 
<code><a href="#topic+mc6">mc6</a></code>
</p>

<hr>
<h2 id='invitrodb_dd'>Short descriptions of fields for different tables are stored in a data dictionary.</h2><span id='topic+invitrodb_dd'></span>

<h3>Description</h3>

<p>Short descriptions of fields for different tables are stored in a data dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invitrodb_dd
</code></pre>


<h3>Format</h3>

<p>A data frame with 44 rows and 3 variables:
</p>

<dl>
<dt>invitrodb_table</dt><dd><p>Table of the data dictionary</p>
</dd>
<dt>invitrodb_field</dt><dd><p>Field of the data dictionary</p>
</dd>
<dt>description</dt><dd><p>Description</p>
</dd>
</dl>



<h3>Source</h3>

<p>ToxCast database
</p>

<hr>
<h2 id='is.odd'>Check for odd numbers</h2><span id='topic+is.odd'></span>

<h3>Description</h3>

<p><code>is.odd</code> takes an integer vector, <code>x</code>, and returns TRUE for odd
integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.odd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.odd_+3A_x">x</code></td>
<td>
<p>An integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for odd integers and <code>FALSE</code> for even integers.
</p>


<h3>See Also</h3>

<p>Other tcpl abbreviations: 
<code><a href="#topic+lu">lu</a>()</code>,
<code><a href="#topic+lw">lw</a>()</code>,
<code><a href="#topic+sink.reset">sink.reset</a>()</code>
</p>

<hr>
<h2 id='Load+20assay+20information'>Functions for loading assay information</h2><span id='topic+Load+20assay+20information'></span><span id='topic+tcplLoadAcid'></span><span id='topic+tcplLoadAeid'></span><span id='topic+tcplLoadAid'></span><span id='topic+tcplLoadAsid'></span>

<h3>Description</h3>

<p>These functions query the tcpl databases and returns a data.table with 
assay ID and name information. More information about the assay
hierarchy is available in the overview vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadAcid(fld = NULL, val = NULL, add.fld = NULL)

tcplLoadAeid(fld = NULL, val = NULL, add.fld = NULL)

tcplLoadAid(fld = NULL, val = NULL, add.fld = NULL)

tcplLoadAsid(fld = NULL, val = NULL, add.fld = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Load+2B20assay+2B20information_+3A_fld">fld</code></td>
<td>
<p>Character, the field(s) to query/subset on</p>
</td></tr>
<tr><td><code id="Load+2B20assay+2B20information_+3A_val">val</code></td>
<td>
<p>List, vectors of values for each field to query/subset on. Must 
be in the same order as 'fld'.</p>
</td></tr>
<tr><td><code id="Load+2B20assay+2B20information_+3A_add.fld">add.fld</code></td>
<td>
<p>Character, additional field(s) to include, but not query/
subset on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element in the assay hierarchy has its own function, loading the ID and
name for the given assay element. For example, <code>tcplLoadAsid</code> will 
return the assay source ID (asid) and assay source name (asnm).
</p>


<h3>Value</h3>

<p>A data.table containing the ID, name, and any additional fields.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
TCPLlite &lt;- file.path(system.file(package = "tcpl"), "example")
tcplConf(db = TCPLlite, user = NA, host = NA, drvr = "tcplLite")

## The load assay functions can be used without any parameters to list the 
## full list of registered assay elements:
tcplLoadAsid()
tcplLoadAeid()

## Similarly, the user can add fields without doing any element selection:
tcplLoadAeid(add.fld = c("asid", "aid", "acid"))

## Or, the user can look only at a subset:
tcplLoadAeid(fld = "aeid", val = 1, add.fld = "asid")

## The field can be any value in one of the corresponding assay element
## tables, but the functions also recognize the abbreviated version of
## the name fields.
tcplListFlds("assay")
a1 &lt;- tcplLoadAeid(fld = "anm", val = "Steroidogenesis")
a2 &lt;- tcplLoadAeid(fld = "assay_name", val = "Steroidogenesis")
identical(a1, a2)

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='lu'>Abbreviation for <code>length(unique(x))</code></h2><span id='topic+lu'></span>

<h3>Description</h3>

<p><code>lu</code> takes a logical vector, <code>x</code>, and returns 
<code>length(unique(x))</code>.
</p>
<p><code>lu</code> takes a logical vector, <code>x</code>, and returns
<code>length(unique(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lu(x)

lu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu_+3A_x">x</code></td>
<td>
<p>A logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unique of the <code>TRUE</code> values in <code>x</code>
</p>
<p>The unique of the <code>TRUE</code> values in <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+which">which</a></code>
</p>
<p><code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+which">which</a></code>
</p>
<p>Other tcpl abbreviations: 
<code><a href="#topic+is.odd">is.odd</a>()</code>,
<code><a href="#topic+lw">lw</a>()</code>,
<code><a href="#topic+sink.reset">sink.reset</a>()</code>
</p>
<p>Other tcpl abbreviations: 
<code><a href="#topic+is.odd">is.odd</a>()</code>,
<code><a href="#topic+lw">lw</a>()</code>,
<code><a href="#topic+sink.reset">sink.reset</a>()</code>
</p>

<hr>
<h2 id='lw'>Abbreviation for <code>length(which(x))</code></h2><span id='topic+lw'></span>

<h3>Description</h3>

<p><code>lw</code> takes a logical vector, <code>x</code>, and returns 
<code>length(which(x))</code>.
</p>
<p><code>lw</code> takes a logical vector, <code>x</code>, and returns
<code>length(which(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lw(x)

lw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lw_+3A_x">x</code></td>
<td>
<p>A logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the <code>TRUE</code> values in <code>x</code>
</p>
<p>The length of the <code>TRUE</code> values in <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+length">length</a></code>, <code><a href="base.html#topic+which">which</a></code>
</p>
<p><code><a href="base.html#topic+length">length</a></code>, <code><a href="base.html#topic+which">which</a></code>
</p>
<p>Other tcpl abbreviations: 
<code><a href="#topic+is.odd">is.odd</a>()</code>,
<code><a href="#topic+lu">lu</a>()</code>,
<code><a href="#topic+sink.reset">sink.reset</a>()</code>
</p>
<p>Other tcpl abbreviations: 
<code><a href="#topic+is.odd">is.odd</a>()</code>,
<code><a href="#topic+lu">lu</a>()</code>,
<code><a href="#topic+sink.reset">sink.reset</a>()</code>
</p>

<hr>
<h2 id='mc_vignette'>List with multi-concentration data for the vignette</h2><span id='topic+mc_vignette'></span>

<h3>Description</h3>

<p>This dataset is a list with 6 data.tables (mc0,mc1,mc2,mc3,mc4,mc5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_vignette
</code></pre>


<h3>Format</h3>


<ol>
<li> <p><strong>mc0</strong> A data frame with 78 rows and 18 columns containing
level 0 formatted raw data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>acid</dt><dd><p>Assay Component ID</p>
</dd>
<dt>acnm</dt><dd><p>Assay Component Name</p>
</dd>
<dt>m0id</dt><dd><p>Level 0 (mc0) ID</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>wllq</dt><dd><p>Well Quality (0 or 1)</p>
</dd>
<dt>conc</dt><dd><p>Concentration in micromolar</p>
</dd>
<dt>rval</dt><dd><p>Raw assay component readout value</p>
</dd>
<dt>srcf</dt><dd><p>Source file containing the raw data</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>mc1</strong> A data frame with 78 rows and 21 columns containing
level 1 replicate and concentration level indicated data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>acid</dt><dd><p>Assay Component ID</p>
</dd>
<dt>acnm</dt><dd><p>Assay Component Name</p>
</dd>
<dt>m0id</dt><dd><p>Level 0 (mc0) ID</p>
</dd>
<dt>m1id</dt><dd><p>Level 1 (mc1) ID</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>wllq</dt><dd><p>Well Quality (0 or 1)</p>
</dd>
<dt>conc</dt><dd><p>Concentration in micromolar</p>
</dd>
<dt>rval</dt><dd><p>Raw assay component readout value</p>
</dd>
<dt>cndx</dt><dd><p>Concentration index defined by ranking the unique concentrations, with the lowest concentration starting at 1.</p>
</dd>
<dt>repi</dt><dd><p>Temporary replicate ID is defined, the data are scanned from top to bottom and increment the replicate index every time a replicate ID is duplicated</p>
</dd>
<dt>srcf</dt><dd><p>Source file containing the raw data</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>mc2</strong> A data frame with 78 rows and 20 columns containing
level 2 assay component-specific corrections.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>acid</dt><dd><p>Assay Component ID</p>
</dd>
<dt>acnm</dt><dd><p>Assay Component Name</p>
</dd>
<dt>m0id</dt><dd><p>Level 0 (mc0) ID</p>
</dd>
<dt>m1id</dt><dd><p>Level 1 (mc1) ID</p>
</dd>
<dt>m2id</dt><dd><p>Level 2 (mc2) ID</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>conc</dt><dd><p>Concentration in micromolar</p>
</dd>
<dt>cval</dt><dd><p>Corrected Value</p>
</dd>
<dt>cndx</dt><dd><p>Concentration index defined by ranking the unique concentrations, with the lowest concentration starting at 1.</p>
</dd>
<dt>repi</dt><dd><p>Temporary replicate ID is defined, the data are scanned from top to bottom and increment the replicate index every time a replicate ID is duplicated</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>mc3</strong> A data frame with 78 rows and 22 columns containing
level 3 assay endpoint normalized data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>aeid</dt><dd><p>Assay Component Endpoint ID</p>
</dd>
<dt>aenm</dt><dd><p>Assay endpoint name (i.e., assay_component_endpoint_name)</p>
</dd>
<dt>m0id</dt><dd><p>Level 0 (mc0) ID</p>
</dd>
<dt>m1id</dt><dd><p>Level 1 (mc1) ID</p>
</dd>
<dt>m2id</dt><dd><p>Level 2 (mc2) ID</p>
</dd>
<dt>m3id</dt><dd><p>Level 3 (mc3) ID</p>
</dd>
<dt>logc</dt><dd><p>Log base 10 concentration</p>
</dd>
<dt>resp</dt><dd><p>Normalized response value</p>
</dd>
<dt>cndx</dt><dd><p>Concentration index defined by ranking the unique concentrations, with the lowest concentration starting at 1.</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>repi</dt><dd><p>Temporary replicate ID is defined, the data are scanned from top to bottom and increment the replicate index every time a replicate ID is duplicated</p>
</dd>
<dt>resp_unit</dt><dd><p>Response Units</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>mc4</strong> A data frame with 5 rows and 149 columns containing
level 4 concentration-response fitting data (all fits).
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>aeid</dt><dd><p>Assay Component Endpoint ID</p>
</dd>
<dt>aenm</dt><dd><p>Assay endpoint name (i.e., assay_component_endpoint_name)</p>
</dd>
<dt>m4id</dt><dd><p>Level 4 (mc4) ID</p>
</dd>
<dt>bmad</dt><dd><p>The median absolute deviation of all treatment wells (default option) or blank wells</p>
</dd>
<dt>resp_max</dt><dd><p>Maximum observed response</p>
</dd>
<dt>resp_min</dt><dd><p>Minimum observed response</p>
</dd>
<dt>max_mean</dt><dd><p>Maximum mean response</p>
</dd>
<dt>max_mean_conc</dt><dd><p>Concentration of the maximum mean response</p>
</dd>
<dt>max_med</dt><dd><p>Maximum median response</p>
</dd>
<dt>max_med_conc</dt><dd><p>Concentration of the maximum median response</p>
</dd>
<dt>logc_max</dt><dd><p>Maximum concentration on the log scale</p>
</dd>
<dt>logc_min</dt><dd><p>Minimum concentration on the log scale</p>
</dd>
<dt>nconc</dt><dd><p>The total number of concentration groups</p>
</dd>
<dt>npts</dt><dd><p>Total number of observed responses (i.e. data points in the concentration series) </p>
</dd>
<dt>nrep</dt><dd><p>Number of replicates in concentration groups</p>
</dd>
<dt>nmed_gtbl</dt><dd><p>The number of median responses greater than 3BMAD</p>
</dd>
<dt>cnst_success</dt><dd><p>Success indicator for the Constant model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>cnst_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Constant model</p>
</dd>
<dt>cnst_rme</dt><dd><p>Root mean square error for the Constant model</p>
</dd>
<dt>cnst_er</dt><dd><p>Error term for the Constant model</p>
</dd>
<dt>hill_success</dt><dd><p>Success indicator for the Hill model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>hill_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Hill model</p>
</dd>
<dt>hill_cov</dt><dd><p>Success indicator for the Hill model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>hill_rme</dt><dd><p>Root mean square erro for the Hill model</p>
</dd>
<dt>hill_tp</dt><dd><p>The top parameter indicating the maximal estimated response</p>
</dd>
<dt>hill_ga</dt><dd><p>The gain parameter for the Hill model, gain AC50</p>
</dd>
<dt>hill_p</dt><dd><p>The power parameter for the Hill model</p>
</dd>
<dt>hill_er</dt><dd><p>Error term for the Hill model</p>
</dd>
<dt>hill_tp_sd</dt><dd><p>Standard deviation of the Hill model top parameter</p>
</dd>
<dt>hill_ga_sd</dt><dd><p>Standard deviation of the Hill model gain parameter</p>
</dd>
<dt>hill_p_sd</dt><dd><p>Standard deviation of the Hill model power parameter</p>
</dd>
<dt>hill_er_sd</dt><dd><p>Standard deviation of the Hill model error term</p>
</dd>
<dt>hill_top</dt><dd><p>The maximal response on the resulting Hill model fit</p>
</dd>
<dt>hill_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Hill model fit</p>
</dd>
<dt>gnls_success</dt><dd><p>Success indicator for the Gain-loss model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>gnls_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Gain-loss model</p>
</dd>
<dt>gnls_cov</dt><dd><p>Success indicator for the Gain-loss model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>gnls_rme</dt><dd><p>Root mean square erro for the Gain-loss model</p>
</dd>
<dt>gnls_tp</dt><dd><p>The top parameter indicating the maximal estimated response</p>
</dd>
<dt>gnls_ga</dt><dd><p>The gain parameter for the Gain-loss model, gain AC50</p>
</dd>
<dt>gnls_p</dt><dd><p>The gain power parameter for the Gain-loss model</p>
</dd>
<dt>gnls_la</dt><dd><p>The loss parameter for the Gain-loss model, loss AC50</p>
</dd>
<dt>gnls_q</dt><dd><p>The loss power parameter for the Gain-loss model</p>
</dd>
<dt>gnls_er</dt><dd><p>Error term for the Gain-loss model</p>
</dd>
<dt>gnls_tp_sd</dt><dd><p>Standard deviation of the Gain-loss model top parameter</p>
</dd>
<dt>gnls_ga_sd</dt><dd><p>Standard deviation of the Gain-loss model gain parameter</p>
</dd>
<dt>gnls_p_sd</dt><dd><p>Standard deviation of the Gain-loss model gain power parameter</p>
</dd>
<dt>gnls_la_sd</dt><dd><p>Standard deviation of the Gain-loss model loss parameter</p>
</dd>
<dt>gnls_q_sd</dt><dd><p>Standard deviation of the Gain-loss model loss power parameter</p>
</dd>
<dt>gnls_er_sd</dt><dd><p>Standard deviation of the Gain-loss model error term</p>
</dd>
<dt>gnls_top</dt><dd><p>The maximal response on the resulting Gain-loss model fit</p>
</dd>
<dt>gnls_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Gain-loss model fit, gain AC50</p>
</dd>
<dt>gnls_ac50_loss</dt><dd><p>Concentration at 50% of the maximal response on the Gain-loss model fit, loss AC50</p>
</dd>
<dt>poly1_success</dt><dd><p>Success indicator for the Polynomial 1 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>poly1_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Polynomial 1 model</p>
</dd>
<dt>poly1_cov</dt><dd><p>Success indicator for the Polynomial 1 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>poly1_rme</dt><dd><p>Root mean square erro for the Polynomial 1 model</p>
</dd>
<dt>poly1_a</dt><dd><p>The y-scale parameter for the Polynomial 1 model</p>
</dd>
<dt>poly1_er</dt><dd><p>Error term for the Polynomial 1 model</p>
</dd>
<dt>poly1_a_sd</dt><dd><p>Standard deviation of the Polynomial 1 model y-scale parameter</p>
</dd>
<dt>poly1_er_sd</dt><dd><p>Standard deviation of the Polynomial 1 model error term</p>
</dd>
<dt>poly1_top</dt><dd><p>The maximal response on the resulting Polynomial 1 model fit</p>
</dd>
<dt>poly1_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Polynomial 1 model fit</p>
</dd>
<dt>poly2_success</dt><dd><p>Success indicator for the Polynomial 2 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>poly2_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Polynomial 2 model</p>
</dd>
<dt>poly2_cov</dt><dd><p>Success indicator for the Polynomial 2 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>poly2_rme</dt><dd><p>Root mean square erro for the Polynomial 2 model</p>
</dd>
<dt>poly2_a</dt><dd><p>The y-scale parameter for the Polynomial 2 model</p>
</dd>
<dt>poly2_b</dt><dd><p>The x-scale parameter for the Polynomial 2 model</p>
</dd>
<dt>poly2_er</dt><dd><p>Error term for the Polynomial 2 model</p>
</dd>
<dt>poly2_a_sd</dt><dd><p>Standard deviation of the Polynomial 2 model y-scale parameter</p>
</dd>
<dt>poly2_b_sd</dt><dd><p>Standard deviation of the Polynomial 2 model x-scale parameter</p>
</dd>
<dt>poly2_er_sd</dt><dd><p>Standard deviation of the Polynomial 2 model error term</p>
</dd>
<dt>poly2_top</dt><dd><p>The maximal response on the resulting Polynomial 2 model fit</p>
</dd>
<dt>poly2_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Polynomial 2 model fit</p>
</dd>
<dt>pow_success</dt><dd><p>Success indicator for the Power model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>pow_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Power model</p>
</dd>
<dt>pow_cov</dt><dd><p>Success indicator for the Power model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>pow_rme</dt><dd><p>Root mean square erro for the Power model</p>
</dd>
<dt>pow_a</dt><dd><p>The y-scale parameter for the Power model</p>
</dd>
<dt>pow_p</dt><dd><p>The power parameter for the Power model</p>
</dd>
<dt>pow_er</dt><dd><p>Error term for the Power model</p>
</dd>
<dt>pow_a_sd</dt><dd><p>Standard deviation of the Power model y-scale parameter</p>
</dd>
<dt>pow_p_sd</dt><dd><p>Standard deviation of the Power model power parameter</p>
</dd>
<dt>pow_er_sd</dt><dd><p>Standard deviation of the Power model error term</p>
</dd>
<dt>pow_top</dt><dd><p>The maximal response on the resulting Power model fit</p>
</dd>
<dt>pow_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Power model fit</p>
</dd>
<dt>exp2_success</dt><dd><p>Success indicator for the Exponential 2 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>exp2_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Exponential 2 model</p>
</dd>
<dt>exp2_cov</dt><dd><p>Success indicator for the Exponential 2 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>exp2_rme</dt><dd><p>Root mean square erro for the Exponential 2 model</p>
</dd>
<dt>exp2_a</dt><dd><p>The y-scale parameter for the Exponential 2 model</p>
</dd>
<dt>exp2_b</dt><dd><p>The x-scale parameter for the Exponential 2 model</p>
</dd>
<dt>exp2_er</dt><dd><p>Error term for the Exponential 2 model</p>
</dd>
<dt>exp2_a_sd</dt><dd><p>Standard deviation of the Exponential 2 model y-scale parameter</p>
</dd>
<dt>exp2_b_sd</dt><dd><p>Standard deviation of the Exponential 2 model x-scale parameter</p>
</dd>
<dt>exp2_er_sd</dt><dd><p>Standard deviation of the Exponential 2 model error term</p>
</dd>
<dt>exp2_top</dt><dd><p>The maximal response on the resulting Exponential 2 model fit</p>
</dd>
<dt>exp2_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Exponential 2 model fit</p>
</dd>
<dt>exp3_success</dt><dd><p>Success indicator for the Exponential 3 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>exp3_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Exponential 3 model</p>
</dd>
<dt>exp3_cov</dt><dd><p>Success indicator for the Exponential 3 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>exp3_rme</dt><dd><p>Root mean square erro for the Exponential 3 model</p>
</dd>
<dt>exp3_a</dt><dd><p>The y-scale parameter for the Exponential 3 model</p>
</dd>
<dt>exp3_b</dt><dd><p>The x-scale parameter for the Exponential 3 model</p>
</dd>
<dt>exp3_p</dt><dd><p>The power parameter for the Exponential 3 model</p>
</dd>
<dt>exp3_er</dt><dd><p>Error term for the Exponential 3 model</p>
</dd>
<dt>exp3_a_sd</dt><dd><p>Standard deviation of the Exponential 3 model y-scale parameter</p>
</dd>
<dt>exp3_b_sd</dt><dd><p>Standard deviation of the Exponential 3 model x-scale parameter</p>
</dd>
<dt>exp3_p_sd</dt><dd><p>Standard deviation of the Exponential 3 model power parameter</p>
</dd>
<dt>exp3_er_sd</dt><dd><p>Standard deviation of the Exponential 3 model error term</p>
</dd>
<dt>exp3_top</dt><dd><p>The maximal response on the resulting Exponential 3 model fit</p>
</dd>
<dt>exp3_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Exponential 3 model fit</p>
</dd>
<dt>exp4_success</dt><dd><p>Success indicator for the Exponential 4 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>exp4_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Exponential 4 model</p>
</dd>
<dt>exp4_cov</dt><dd><p>Success indicator for the Exponential 4 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>exp4_rme</dt><dd><p>Root mean square erro for the Exponential 4 model</p>
</dd>
<dt>exp4_tp</dt><dd><p>The top parameter indicating the maximal estimated response</p>
</dd>
<dt>exp4_ga</dt><dd><p>The gain parameter for the Exponential 4 model, gain AC50</p>
</dd>
<dt>exp4_er</dt><dd><p>Error term for the Exponential 4 model</p>
</dd>
<dt>exp4_tp_sd</dt><dd><p>Standard deviation of the Exponential 4 model top parameter</p>
</dd>
<dt>exp4_ga_sd</dt><dd><p>Standard deviation of the Exponential 4 model gain parameter</p>
</dd>
<dt>exp4_er_sd</dt><dd><p>Standard deviation of the Exponential 4 model error term</p>
</dd>
<dt>exp4_top</dt><dd><p>The maximal response on the resulting Exponential 4 model fit</p>
</dd>
<dt>exp4_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Exponential 4 model fit</p>
</dd>
<dt>exp5_success</dt><dd><p>Success indicator for the Exponential 5 model; 1 if the optimization was successful, otherwise 0</p>
</dd>
<dt>exp5_aic</dt><dd><p>Akaike Information Criteria (AIC) for the Exponential 5 model</p>
</dd>
<dt>exp5_cov</dt><dd><p>Success indicator for the Exponential 5 model covariance calculation; 1 if the Hessian matrix inversion is successful, otherwise 0</p>
</dd>
<dt>exp5_rme</dt><dd><p>Root mean square erro for the Exponential 5 model</p>
</dd>
<dt>exp5_tp</dt><dd><p>The top parameter indicating the maximal estimated response</p>
</dd>
<dt>exp5_ga</dt><dd><p>The gain parameter for the Exponential 5 model, gain AC50</p>
</dd>
<dt>exp5_p</dt><dd><p>The power parameter for the Exponential 5 model</p>
</dd>
<dt>exp5_er</dt><dd><p>Error term for the Exponential 5 model</p>
</dd>
<dt>exp5_tp_sd</dt><dd><p>Standard deviation of the Exponential 5 model top parameter</p>
</dd>
<dt>exp5_ga_sd</dt><dd><p>Standard deviation of the Exponential 5 model gain parameter</p>
</dd>
<dt>exp5_p_sd</dt><dd><p>Standard deviation of the Exponential 5 model power parameter</p>
</dd>
<dt>exp5_er_sd</dt><dd><p>Standard deviation of the Exponential 5 model error term</p>
</dd>
<dt>exp5_top</dt><dd><p>The maximal response on the resulting Exponential 5 model fit</p>
</dd>
<dt>exp5_ac50</dt><dd><p>Concentration at 50% of the maximal response on the Exponential 5 model fit</p>
</dd>
<dt>all_onesd</dt><dd><p>Standard deviation of the baseline response for all models</p>
</dd>
<dt>all_bmed</dt><dd><p>Median noise estimation of the baseline response for all models</p>
</dd>
<dt>resp_unit</dt><dd><p>Response Units</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>mc5</strong> A data frame with 5 rows and 54 columns containing
level 5 best curve-fit and hitcall data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>aeid</dt><dd><p>Assay Component Endpoint ID</p>
</dd>
<dt>aenm</dt><dd><p>Assay endpoint name (i.e., assay_component_endpoint_name)</p>
</dd>
<dt>m5id</dt><dd><p>Level 5 (mc5) ID</p>
</dd>
<dt>m4id</dt><dd><p>Level 4 (mc4) ID</p>
</dd>
<dt>bmad</dt><dd><p>The median absolute deviation of all treatment wells (default option) or blank wells </p>
</dd>
<dt>resp_max</dt><dd><p>Maximum observed response</p>
</dd>
<dt>resp_min</dt><dd><p>Minimum observed response</p>
</dd>
<dt>max_mean</dt><dd><p>Maximum mean response</p>
</dd>
<dt>max_mean_conc</dt><dd><p>Concentration of the maximum mean response</p>
</dd>
<dt>max_med</dt><dd><p>Maximum median response</p>
</dd>
<dt>max_med_conc</dt><dd><p>Concentration of the maximum median response</p>
</dd>
<dt>logc_max</dt><dd><p>Maximum concentration on the log scale</p>
</dd>
<dt>logc_min</dt><dd><p>Minimum concentration on the log scale</p>
</dd>
<dt>nconc</dt><dd><p>The total number of concentration groups</p>
</dd>
<dt>npts</dt><dd><p>Total number of observed responses (i.e. data points in the concentration series)</p>
</dd>
<dt>nrep</dt><dd><p>Number of replicates in concentration groups</p>
</dd>
<dt>nmed_gtbl</dt><dd><p>The number of median responses greater than 3BMAD</p>
</dd>
<dt>hitc</dt><dd><p>Hitcall</p>
</dd>
<dt>modl</dt><dd><p>Best model fit from tcplFit2 curve-fitting</p>
</dd>
<dt>fitc</dt><dd><p>Fit category</p>
</dd>
<dt>coff</dt><dd><p>Cutoff</p>
</dd>
<dt>top_over_cutoff</dt><dd><p>Ratio of the top of the best model fit curve and the cutoff</p>
</dd>
<dt>rmse</dt><dd><p>Root mean squared error</p>
</dd>
<dt>a</dt><dd><p>The y-scale parameter for poly1, poly2, pow, exp2, or exp3 model</p>
</dd>
<dt>er</dt><dd><p>Error term</p>
</dd>
<dt>bmr</dt><dd><p>Benchmark response</p>
</dd>
<dt>bmdl</dt><dd><p>Lower 95% confidence bound on the benchmark dose/concentration estimate</p>
</dd>
<dt>caikwt</dt><dd><p>Akaike Information Criteria weight of constant model relative to the best model fit</p>
</dd>
<dt>mll</dt><dd><p>Maximum log-likelihood of the best model fit</p>
</dd>
<dt>hitcall</dt><dd><p>Continuous hitcall</p>
</dd>
<dt>ac50</dt><dd><p>Concentration where 50% of the maximal response occurs - if 'modl' is the Hill or Gain-loss model this is for the &quot;gain&quot; side of the response</p>
</dd>
<dt>top</dt><dd><p>The maximal response on the best model curve fit - i.e. top of the curve fit</p>
</dd>
<dt>ac5</dt><dd><p>Concentration where 5% of the maximal response occurs</p>
</dd>
<dt>ac10</dt><dd><p>Concentration where 10% of the maximal response occurs</p>
</dd>
<dt>ac20</dt><dd><p>Concentration where 20% of the maximal response occurs</p>
</dd>
<dt>acc</dt><dd><p>Concentration where the efficacy cutoff response occurs</p>
</dd>
<dt>ac1sd</dt><dd><p>Concentration where one standard deviation of the background response occurs</p>
</dd>
<dt>bmd</dt><dd><p>Benchmark response/concentration estimate - concentration where the benchmark response occurs</p>
</dd>
<dt>bmdu</dt><dd><p>Upper 95% confidence bound on the benchmark dose/concentration estimate</p>
</dd>
<dt>tp</dt><dd><p>The top curve parameter for the exp4, exp5, hill, or gnls model</p>
</dd>
<dt>ga</dt><dd><p>The gain parameter for the hill or gnls model - gain AC50</p>
</dd>
<dt>p</dt><dd><p>The power parameter for the pow, exp3, exp5, gnls, or hill model - for gnls this is the gain power parameter</p>
</dd>
<dt>q</dt><dd><p>The loss power parameter for the gnls model</p>
</dd>
<dt>la</dt><dd><p>The loss parameter for the gnls model, loss AC50</p>
</dd>
<dt>ac50_loss</dt><dd><p>Concentration where 50% of the maximal response occurs - if 'modl' is the Hill or Gain-loss model this is for the &quot;loss&quot; side of the response</p>
</dd>
<dt>b</dt><dd><p>The x-scale parameter for poly2, exp2, or exp3 model</p>
</dd>
<dt>resp_unit</dt><dd><p>Response Units</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li></ol>


<hr>
<h2 id='mc1'>Perform level 1  
multiple-concentration processing</h2><span id='topic+mc1'></span>

<h3>Description</h3>

<p><code>mc1</code> loads level 0 data from the tcpl 
database for the given id and performs level 1 
multiple-concentration processing. 
The processed data is then loaded into the mc1 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc1(ac, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc1_+3A_ac">ac</code></td>
<td>
<p>Integer of length 1, assay component id (acid) for processing.</p>
</td></tr>
<tr><td><code id="mc1_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 processing includes defining the concentration and replicate index, 
cndx and repi, respectively.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p>Other multiple-concentration: 
<code><a href="#topic+mc2">mc2</a>()</code>,
<code><a href="#topic+mc3">mc3</a>()</code>,
<code><a href="#topic+mc4">mc4</a>()</code>,
<code><a href="#topic+mc5">mc5</a>()</code>,
<code><a href="#topic+mc6">mc6</a>()</code>
</p>

<hr>
<h2 id='mc2'>Perform level 2  
multiple-concentration processing</h2><span id='topic+mc2'></span>

<h3>Description</h3>

<p><code>mc2</code> loads level 1 data from the tcpl 
database for the given id and performs level 2 
multiple-concentration processing. 
The processed data is then loaded into the mc2 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc2(ac, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc2_+3A_ac">ac</code></td>
<td>
<p>Integer of length 1, assay component id (acid) for processing.</p>
</td></tr>
<tr><td><code id="mc2_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 2 multiple-concentration processing includes defining the
corrected value, cval, based on the correction methods listed in the
mc2_acid and mc2_methods tables.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+MC2_Methods">MC2_Methods</a></code>
</p>
<p>Other multiple-concentration: 
<code><a href="#topic+mc1">mc1</a>()</code>,
<code><a href="#topic+mc3">mc3</a>()</code>,
<code><a href="#topic+mc4">mc4</a>()</code>,
<code><a href="#topic+mc5">mc5</a>()</code>,
<code><a href="#topic+mc6">mc6</a>()</code>
</p>

<hr>
<h2 id='MC2_Methods'>List of level 2 multiple-concentration correction functions</h2><span id='topic+MC2_Methods'></span><span id='topic+mc2_mthds'></span>

<h3>Description</h3>

<p><code>mc2_mthds</code> returns a list of correction/transformation functions 
to be used during level 2 multiple-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc2_mthds()
</code></pre>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>mc2_mthds</code> return
a list of expressions to be executed in the <code>mc2</code> (not exported) 
function environment. The functions are described here for reference 
purposes, The <code>mc2_mthds</code> function is not exported, nor is it 
intended for use.
</p>
<p>All available methods are described in the Available Methods section, listed
by the function/method name.
</p>


<h3>Value</h3>

<p>A list functions
</p>


<h3>Available Methods</h3>

<p>More information about the level 2 multiple-concentration processing is 
available in the package vignette, &quot;Data_processing.&quot;
</p>


<h4>Correction Methods</h4>


<dl>
<dt>log2</dt><dd><p>Transform the corrected response value (cval) to log-scale (base 2).</p>
</dd>
<dt>log10</dt><dd><p>Transform the corrected response value (cval) to log-scale (base 10).</p>
</dd>
<dt>rmneg</dt><dd><p>Exclude wells with negative corrected response values (cval) and downgrading 
their well quality (wllq); if <code class="reqn">cval&lt;0, wllq=0</code>.</p>
</dd>
<dt>rmzero</dt><dd><p>Exclude wells with corrected response values (cval) equal to zero and 
downgrading their well quality (wllq); if <code class="reqn">cval=0, wllq=0</code>.</p>
</dd>
<dt>mult25</dt><dd><p>Multiply corrected response value (cval) by 25; <code class="reqn">25*cval</code>.</p>
</dd>
<dt>mult100</dt><dd><p>Multiply corrected response value (cval) by 100; <code class="reqn">100*cval</code>.</p>
</dd>
<dt>negshift</dt><dd><p>Shift corrected response values (cval) by subtracting the minimum cval and 
adding 1, such that the new minimum is 1; <code class="reqn">cval-min+1</code>.</p>
</dd>
<dt>mult2.5</dt><dd><p>Multiply corrected response value (cval) by 2.5; <code class="reqn">2.5*cval</code>.</p>
</dd>
<dt>mult3</dt><dd><p>Multiply corrected response value (cval) by 3; <code class="reqn">3*cval</code>.</p>
</dd>
<dt>mult6</dt><dd><p>Multiply corrected response value (cval) by 6; <code class="reqn">6*cval</code>.</p>
</dd>
<dt>sub100</dt><dd><p>Center data around zero by subtracting the corrected response value (cval) from 
100; <code class="reqn">100-cval</code>. Typically used if data was pre-normalized around 100 with 
responses decreasing to 0.</p>
</dd>
<dt>zscore.npwlls</dt><dd><p>Convert the corrected response value (cval) to an absolute Z-Score based 
on the neutral and positive control wells (wllts = n and p), by assay plate ID (apid); 
<code class="reqn">cval=|(cval-mean(cval~for~wllt~=~n~and~p)/sd(cval~for~wllt~=~n~and~p)|</code>.</p>
</dd>
<dt>sub1</dt><dd><p>Center data around zero by subtracting the corrected response value (cval) from 1; 
<code class="reqn">1-cval</code>. Typically used if data was pre-normalized around 1 with responses 
decreasing to 0.</p>
</dd>
</dl>




<h4>Aggregation Methods</h4>


<dl>
<dt>agg.mean.rep.apid</dt><dd><p>Aggregate technical test replicates (wllt=t) by taking the plate-wise mean per sample id (spid), assay plate (apid), and concentration index (cndx).</p>
</dd>
<dt>agg.median.rep.apid</dt><dd><p>Aggregate technical test replicates (wllt=t) by taking the plate-wise median per sample id (spid), assay plate (apid), and concentration index (cndx).</p>
</dd>
<dt>agg.percent.rep.spid</dt><dd><p>Use for binary data. Aggregate technical replicates as percentage by taking the sum of hits relative to total replicates per sample id (spid) and concentration index (cndx); cval = (sum(rval)/.N)*100.</p>
</dd>
<dt>agg.percent.rep.spid.min1</dt><dd><p>Use for binary data. Aggregate technical replicates as percentage by taking the sum of hits relative to total replicates per per sample id (spid) and concentration index (cndx), where there is more than one replicate; cval = (sum(rval)/.N)*100, where .N&gt;1.</p>
</dd>
<dt>agg.mean.rep.apid</dt><dd><p>Aggregate technical replicates by taking the plate-wise mean per 
sample id (spid), assay plate (apid), and concentration index (cndx).</p>
</dd>
<dt>agg.median.rep.apid</dt><dd><p>Aggregate technical replicates by taking the plate-wise median per 
sample id (spid), assay plate (apid), and concentration index (cndx).</p>
</dd>
<dt>agg.percent.rep.spid</dt><dd><p>Use for binary data. Aggregate technical replicates as percentage 
by taking the sum of hits relative to total replicates per sample id (spid) and concentration 
index (cndx); <code class="reqn">cval = (sum(rval)/.N)*100</code>.</p>
</dd>
<dt>agg.percent.rep.spid.min1</dt><dd><p>Use for binary data. Aggregate technical replicates as 
percentage by taking the sum of hits relative to total replicates per per sample id (spid) and 
concentration index (cndx), where there is more than one replicate; 
<code class="reqn">cval=(sum(rval)/.N)*100,~where~.N&gt;1</code>.</p>
</dd>
</dl>




<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc2">mc2</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what
methods get applied to each acid
</p>

<hr>
<h2 id='mc3'>Perform level 3  
multiple-concentration processing</h2><span id='topic+mc3'></span>

<h3>Description</h3>

<p><code>mc3</code> loads level 2 data from the tcpl 
database for the given id and performs level 3 
multiple-concentration processing. 
The processed data is then loaded into the mc3 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc3(ac, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc3_+3A_ac">ac</code></td>
<td>
<p>Integer of length 1, assay component id (acid) for processing.</p>
</td></tr>
<tr><td><code id="mc3_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 3 multiple-concentration processing includes mapping assay component
to assay endpoint, duplicating the data when the assay component has
multiple assay endpoints, and any normalization of the data. Data
normalization based on methods listed in mc3_aeid and mc3_methods tables.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+MC3_Methods">MC3_Methods</a></code>
</p>
<p>Other multiple-concentration: 
<code><a href="#topic+mc1">mc1</a>()</code>,
<code><a href="#topic+mc2">mc2</a>()</code>,
<code><a href="#topic+mc4">mc4</a>()</code>,
<code><a href="#topic+mc5">mc5</a>()</code>,
<code><a href="#topic+mc6">mc6</a>()</code>
</p>

<hr>
<h2 id='MC3_Methods'>List of level 3 multiple-concentration normalization methods</h2><span id='topic+MC3_Methods'></span><span id='topic+mc3_mthds'></span>

<h3>Description</h3>

<p><code>mc3_mthds</code> returns a list of normalization methods to be used 
during level 3 multiple-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc3_mthds()
</code></pre>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>mc3_mthds</code> take 
<code>aeids</code> (a numeric vector of aeid values) and returns a list of expressions 
to be executed in the <code>mc3</code> (not exported) function environment. The 
functions are described here for reference purposes, The 
<code>mc3_mthds</code> function is not exported, nor is it intended for use.
</p>
<p>All available methods are described in the Available Methods section, listed
by the type of function and the function/method name.
</p>


<h3>Value</h3>

<p>A list of functions
</p>


<h3>Available Methods</h3>

<p>The methods are broken into three types, based on what fields they define. 
Different methods are used to define &quot;bval&quot; (the baseline value), &quot;pval&quot;
(the positive control value), and &quot;resp&quot; (the final response value). 
</p>
<p>Although it does not say so specifically in each description, all methods 
are applied by aeid.
</p>
<p>More information about the level 3 multiple-concentration processing is 
available in the package vignette, &quot;Data_processing.&quot;
</p>


<h4>bval Methods</h4>


<dl>
<dt>bval.apid.nwlls.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median, by 
assay plate ID (apid), of the corrected values (cval) for neutral control wells (wllt = n).</p>
</dd>
<dt>bval.apid.lowconc.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median, 
by assay plate ID (apid), of the corrected values (cval) for test compound wells (wllt = t) 
with a concentration index (cndx) of 1 or 2.</p>
</dd>
<dt>bval.apid.twlls.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median, by 
assay plate ID (apid), of the corrected values (cval) of test compound wells (wllt = t).</p>
</dd>
<dt>bval.apid.tn.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median, by 
assay plate ID (apid), of the corrected values (cval) for test compound wells (wllt = t) and 
neutral control wells (wllt = n).</p>
</dd>
<dt>bval.apid.nwllslowconc.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise 
median, by assay plate ID (apid), of the corrected values (cval) of test compound wells 
(wllt = t) with a concentration index (cndx) of 1 or 2 or neutral control wells (wllt = n).</p>
</dd>
<dt>bval.spid.lowconc.med</dt><dd><p>Calculate the baseline value (bval) as the sample-wise median, 
by sample ID (spid), of the corrected values (cval) of the three lowest concentration test 
compound wells (wllt = t and cndx =  1, 2, &amp; 3).</p>
</dd>
<dt>bval.apid.nwllstcwllslowconc.med</dt><dd><p>Calculate the baseline value (bval) as the 
plate-wise median, by assay plate ID (apid), of the corrected values (cval) for neutral 
control wells (wllt = n) or wells with a concentration index (cndx) of 1 or 2 and well 
type of test compound (wllt = t) or gain-of-signal control in multiple concentrations 
(wllt = c).</p>
</dd>
<dt>bval.aeid.nwlls.med</dt><dd><p>Calculate the baseline value (bval) as the endpoint-wise median, 
by assay component endpoint ID (aeid), corrected value (cval) for neutral control wells 
(wllt = n).</p>
</dd>
</dl>

 


<h4>pval Methods</h4>


<dl>
<dt>pval.apid.pwlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the corrected values (cval) for single-concentration 
gain-of-signal positive control wells (wllt = p).</p>
</dd>
<dt>pval.apid.mwlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the corrected values (cval) for multiple-concentration 
loss-of-signal negative control wells (wllt = m).</p>
</dd>
<dt>pval.apid.medpcbyconc.max</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise maximum, by assay plate ID (apid), of the medians of the corrected values (cval) 
for gain-of-signal single- or multiple-concentration negative control wells (wllt = m or o) 
by apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.medpcbyconc.min</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise minimum, by assay plate ID (apid), of the medians of corrected value (cval) of 
gain-of-signal single- or multiple-concentration positive control wells (wllt = p or c) by 
apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.medncbyconc.min</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise minimum, by assay plate ID (apid), of the medians of the corrected values (cval) 
for gain-of-signal single- or multiple-concentration negative control wells (wllt = m or o) 
by apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.pmv.min</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
minimum, by assay plate ID (apid), of the medians of the corrected values (cval) for 
single-concentration gain-of-signal, multiple-concentration loss-of-signal, or viability 
control wells (wllt = p, m, or v) by apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.pmv.max</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
maximum, by assay plate ID (apid), of the medians of the corrected values (cval) for 
single-concentration gain-of-signal, multiple-concentration loss-of-signal, or viability 
control wells (wllt = p, m, or v) by apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.f.max</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
maximum, by assay plate ID (apid), of the medians of important reference wells (wllt = f) 
values by apid and concentration.</p>
</dd>
<dt>pval.apid.f.min</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
minimum, by assay plate ID (apid), of the medians of important reference wells (wllt = f) 
values by apid and concentration.</p>
</dd>
<dt>pval.apid.p.max</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
maximum, by assay plate ID (apid), of the medians of the corrected values (cval) for 
single-concentration gain-of-signal control wells (wllt = p) by apid.</p>
</dd>
<dt>pval.apid.p.min</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
minimum, by assay plate ID (apid), of the medians of corrected values (cval) for 
single-concentration gain-of-signal control wells (wllt = p) by apid.</p>
</dd>
<dt>pval.apid.v.min</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
minimum, by assay plate ID (apid), of the medians of the corrected values (cval) for 
viability control wells (wllt = v) by apid and concentration.</p>
</dd>
<dt>pval.zero</dt><dd><p>Set the positive control value (pval) to 0; <code class="reqn">pval = 0</code>.</p>
</dd>
<dt>pval.apid.owlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the corrected values (cval) for single-concentration 
negative control wells (wllt = o).</p>
</dd>
<dt>pval.2bval</dt><dd><p>Calculate the positive control value (pval) as the plate-wise median, by 
assay plate ID (apid), of the corrected values (cval) for neutral control wells (wllt = n) 
multiplied by 2.</p>
</dd>
<dt>pval.maxp</dt><dd><p>Calculate the positive control value (pval) as the endpoint-wise maximum, 
by assay component ID (aeid), of the corrected values for single-concentration 
gain-of-signal wells (wllt = p).</p>
</dd>
<dt>pval.apid.bwlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the corrected values (cval) for blank wells (wllt= b).</p>
</dd>
<dt>pval.twlls.99pct</dt><dd><p>Calculate positive control value (pval) as the 99th percentile of 
all corrected value (cvals) of the test compound wells (wllt = t).</p>
</dd>
<dt>pval.neg.100</dt><dd><p>Calculate positive control value (pval) as -100 for endpoints in the 
down direction; <code class="reqn">pval = -100</code>.</p>
</dd>
</dl>

 


<h4>resp Methods</h4>


<dl>
<dt>resp.pc</dt><dd><p>Calculate the normalized response (resp) as a percent of control, i.e. the 
ratio of the difference between the corrected (cval) and baseline (bval) values divided the 
difference between the positive control (pval) and baseline (bval) values multiplied by 100; 
<code class="reqn">resp = (cval-bval)/(pval-bval)*100</code>.</p>
</dd>
<dt>resp.pc.pval.cor</dt><dd><p>Calculate the normalized response (resp) as a percent of control, 
i.e. the ratio of the difference between the corrected (cval) and baseline (bval) values 
divided the positive control (pval) value multiplied by 100; 
<code class="reqn">resp = (cval-bval)/pval*100</code>.</p>
</dd>
<dt>resp.fc</dt><dd><p>Calculate the normalized response (resp) as the fold change, i.e. the ratio 
of the corrected (cval) and baseline (bval) values; <code class="reqn">resp = cval/bal</code>.</p>
</dd>
<dt>resp.logfc</dt><dd><p>Calculate the normalized response (resp) as the fold change of logged,
i.e. the difference between corrected (cval) and baseline (bval) log-scale values.</p>
</dd>
<dt>resp.log2</dt><dd><p>Transform the response values to log-scale (base 2).</p>
</dd>
<dt>resp.mult25</dt><dd><p>Multiply the normalized response value (resp) by 25; 
<code class="reqn">25*resp</code>.</p>
</dd>
<dt>resp.scale.mad.log2fc</dt><dd><p>Scale the normalized response value (resp) by the ratio of 
log2(1.2) and 3 multiplied by the baseline median absolute deviation (bmad) of the unscaled 
normalized response values (resp); <code class="reqn">(\log_{2}{1.2})/3*bmad*resp</code>.</p>
</dd>
<dt>resp.scale.quant.log2fc</dt><dd><p>Scale the normalized response value (resp). First, determine 
the maximum difference (md) by finding the maximum between the absolute difference of the 
1st percentile minus the 50th percentile and the absolute difference of the 99th percentile 
minus the 50th percentile. Then multiply resp by log2(1.2) divided by 20 percent of md; 
<code class="reqn">(\log_{2}{1.2})/0.2*md*resp</code>.</p>
</dd>
<dt>resp.multneg1</dt><dd><p>Multiply the normalized response value (resp) by -1; 
<code class="reqn">-1*resp</code>.</p>
</dd>
<dt>resp.shiftneg.3bmad</dt><dd><p>Shift all the normalized response values (resp) less than -3 
multiplied by the baseline median absolute deviation (bmad) to 0; if 
<code class="reqn">resp &lt; -3*bmad,~resp = 0</code>.</p>
</dd>
<dt>resp.shiftneg.6bmad</dt><dd><p>Shift all the normalized response values (resp) less than -6 
multiplied by the baseline median absolute deviation (bmad) to 0; if 
<code class="reqn">resp &lt; -6*bmad,~resp = 0</code>.</p>
</dd>
<dt>resp.shiftneg.10bmad</dt><dd><p>Shift all the normalized response values (resp) less than 10 
multiplied by the baseline median absolute deviation (bmad) to 0; if 
<code class="reqn">resp &lt; -10*bmad,~resp = 0</code>.</p>
</dd>
<dt>resp.blineshift.3bmad.repi</dt><dd><p>Shift the normalized response value (resp) with a baseline 
correction, by replicate index (repi), with a window of 3 multiplied by the baseline median 
absolute deviation (bmad).</p>
</dd>
<dt>resp.blineshift.50.repi</dt><dd><p>Shift the normalized response value (resp) with a baseline 
correction, by replicate index (repi), with a window of 50.</p>
</dd>
<dt>resp.blineshift.3bmad.spid</dt><dd><p>Shift the normalized response value (resp) with a baseline 
correction, by sample ID (spid), with a window of 3 multiplied by the baseline median 
absolute deviation (bmad).</p>
</dd>
<dt>resp.blineshift.50.spid</dt><dd><p>Shift the normalized response value (resp) with a baseline 
correction, by sample ID (spid), with a window of 50.</p>
</dd>
<dt>none</dt><dd><p>Set the corrected response value (cval) as the normalized response value (resp); 
<code class="reqn">cval = resp</code>. No additional mc3 methods needed for endpoint-specific 
normalization.</p>
</dd>
<dt>resp.zerocenter.fc</dt><dd><p>Calculate the normalized response (resp) as a zero center fold 
change, i.e. 1 minus the ratio of corrected (cval) and baseline (bval) values; 
<code class="reqn">resp=1-cval/bval</code>. Typically used for increasing responses.</p>
</dd>
<dt>resp.incr.zerocenter.fc</dt><dd><p>Calculate the normalized response (resp) as a zero center 
fold change, i.e. the ratio of the the corrected (cval) and baseline (bval) values minus 1; 
<code class="reqn">resp=cval/bval-1</code>. Typically used for increasing responses.</p>
</dd>
<dt>resp.mult100</dt><dd><p>Multiply the normalized response value (resp) by 100; 
<code class="reqn">100*resp</code>.</p>
</dd>
</dl>




<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc3">mc3</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what 
methods get applied to each aeid
</p>

<hr>
<h2 id='mc4'>Perform level 4  
multiple-concentration processing</h2><span id='topic+mc4'></span>

<h3>Description</h3>

<p><code>mc4</code> loads level 3 data from the tcpl 
database for the given id and performs level 4 
multiple-concentration processing. 
The processed data is then loaded into the mc4 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc4(ae, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc4_+3A_ae">ae</code></td>
<td>
<p>Integer of length 1, assay endpoint id (aeid) for processing.</p>
</td></tr>
<tr><td><code id="mc4_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 4 multiple-concentration modeling takes the dose-response data for
chemical-assay pairs, and fits three models to the data: constant, hill,
and gain-loss. For more information about the models see
<code><a href="#topic+Models">Models</a></code>. When a chemical has more than one sample, the function
fits each sample separately.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplFit">tcplFit</a></code>, <code><a href="#topic+Models">Models</a></code>
</p>
<p>Other multiple-concentration: 
<code><a href="#topic+mc1">mc1</a>()</code>,
<code><a href="#topic+mc2">mc2</a>()</code>,
<code><a href="#topic+mc3">mc3</a>()</code>,
<code><a href="#topic+mc5">mc5</a>()</code>,
<code><a href="#topic+mc6">mc6</a>()</code>
</p>

<hr>
<h2 id='MC4_Methods'>List of level 4 multiple-concentration methods for calculating bmad</h2><span id='topic+MC4_Methods'></span><span id='topic+mc4_mthds'></span>

<h3>Description</h3>

<p><code>mc4_mthds</code> returns a list of methods to be used 
during level 4 multiple-concentration processing for calculating bmad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc4_mthds()
</code></pre>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>mc4_mthds</code> take 
<code>aeids</code> (a numeric vector of aeid values) and returns a list of expressions 
to be executed in the <code>mc4</code> (not exported) function environment. The 
functions are described here for reference purposes, The 
<code>mc4_mthds</code> function is not exported, nor is it intended for use.
</p>
<p>All available methods are described in the Available Methods section, listed
by the type of function and the function/method name.
</p>


<h3>Value</h3>

<p>A list of functions
</p>


<h3>Available Methods</h3>

<p>Although it does not say so specifically in each description, all methods 
are applied by aeid.
</p>
<p>More information about the level 4 multiple-concentration processing is 
available in the package vignette, &quot;Data_processing.&quot;
</p>

<dl>
<dt>bmad.aeid.lowconc.twells</dt><dd><p>Calculate the baseline median absolute value (bmad) as the 
median absolute deviation of normalized response values (rep) for test compound wells 
(wllt = t) with concentration index (cndx) equal to 1 or 2.</p>
</dd>
<dt>bmad.aeid.lowconc.nwells</dt><dd><p>Calculate the baseline median absolute value (bmad) as the 
median absolute deviation of normalized response values (resp) for neutral control wells 
(wllt = n).</p>
</dd>
<dt>onesd.aeid.lowconc.twells</dt><dd><p>Calculate one standard deviation of the normalized response 
for test compound wells (wllt = t) with a concentration index (cndx) of 1 or 2; 
<code class="reqn">onesd=\sqrt{\sum{(resp-mean(resp))^{2}}/(n-1)}</code>. Used to establish BMR and therefore required for tcplfit2 
processing.</p>
</dd>
<dt>bidirectional.false</dt><dd><p>Limits bidirectional fitting and processes data in positive 
analysis direction only. Use for gain-of-signal or inverted data.</p>
</dd>
<dt>bmad5.onesd16.static</dt><dd><p>Replace baseline median absolute deviation
(bmad) with 5 and one standard deviation (osd) of the normalized response
for test compound wells (wllt = t) with a concentration index (cndx) of 1
or 2 with 16. Typically used for binary data where values would otherwise
be 0; non-zero values are required for tcplfit2 processing.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc4">mc4</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what 
methods get applied to each aeid
</p>

<hr>
<h2 id='mc5'>Perform level 5  
multiple-concentration processing</h2><span id='topic+mc5'></span>

<h3>Description</h3>

<p><code>mc5</code> loads level 4 data from the tcpl 
database for the given id and performs level 5 
multiple-concentration processing. 
The processed data is then loaded into the mc5 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc5_+3A_ae">ae</code></td>
<td>
<p>Integer of length 1, assay endpoint id (aeid) for processing.</p>
</td></tr>
<tr><td><code id="mc5_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 5 multiple-concentration hit-calling uses the fit parameters and the 
activity cutoff methods from mc5_aeid and mc5_methods to make an activity 
call and identify the winning model for each fit.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+MC5_Methods">MC5_Methods</a></code>
</p>
<p>Other multiple-concentration: 
<code><a href="#topic+mc1">mc1</a>()</code>,
<code><a href="#topic+mc2">mc2</a>()</code>,
<code><a href="#topic+mc3">mc3</a>()</code>,
<code><a href="#topic+mc4">mc4</a>()</code>,
<code><a href="#topic+mc6">mc6</a>()</code>
</p>

<hr>
<h2 id='MC5_Methods'>Load list of level 5 multiple-concentration cutoff methods</h2><span id='topic+MC5_Methods'></span><span id='topic+mc5_mthds'></span>

<h3>Description</h3>

<p><code>mc5_mthds</code> returns a list of additional activity cutoff methods to be used during level 5 
multiple-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc5_mthds(ae)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MC5_Methods_+3A_ae">ae</code></td>
<td>
<p>Integer of length 1, the assay endpoint id</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>mc5_mthds</code> take <code>aeids</code> 
(a numeric vector of aeid values) and returns a list of expressions to be executed in the 
<code>mc5</code> (not exported) function environment. The functions are described here for reference 
purposes, The <code>mc5_mthds</code> function is not exported, nor is it intended for use.
</p>
<p>All available methods are described in the &quot;Available Methods&quot; section, listed
by the cutoff type in ascending order of cutoff value.
</p>


<h3>Value</h3>

<p>A list of functions
</p>


<h3>Available Methods</h3>

<p>The methods are broken down into five categories based on the type of cutoff they assign. 
Different methods are used to define cutoffs for &quot;bmad&quot; (baseline median absolute value), &quot;fc&quot; 
(fold change), &quot;log&quot; (<code class="reqn">\log_{2}</code> or <code class="reqn">\log_{10}</code>), &quot;pc&quot; (percent of 
control), and &quot;other&quot; (uncategorized cutoffs).
</p>
<p>All methods are applied by aeid.
</p>
<p>Although there are method exceptions (notably within the other category), only highest 
calculated cutoff value based on assigned methods will be selected for hitcalling. Therefore, 
only the largest cutoff method per method type should be assigned.
</p>
<p>More information about the level 5 multiple-concentration processing is available in the package 
vignette, &quot;Data_processing.&quot;
</p>


<h4>BMAD Methods</h4>


<dl>
<dt>bmad1</dt><dd><p>Add a cutoff value of 1 multiplied by baseline median absolute value (bmad). By 
default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad2</dt><dd><p>Add a cutoff value of 2 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad3</dt><dd><p>Add a cutoff value of 3 multiplied by the baseline median absolute deviation 
(bmad) as defined at Level 4.</p>
</dd>
<dt>bmad4</dt><dd><p>Add a cutoff value of 4 multiplied the baseline median absolute deviation (bmad). 
By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad5</dt><dd><p>Add a cutoff value of 5 multiplied the baseline median absolute deviation (bmad). 
By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad6</dt><dd><p>Add a cutoff value of 6 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad10</dt><dd><p>Add a cutoff value of 10 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
</dl>




<h4>Fold Change Methods</h4>


<dl>
<dt>fc0.2</dt><dd><p>Add a cutoff value of 0.2. Typically for zero centered fold change data.</p>
</dd>
<dt>fc0.3</dt><dd><p>Add a cutoff value of 0.3. Typically for zero centered fold change data.</p>
</dd>
</dl>




<h4>Log Methods</h4>

<p>Log Base 2
</p>

<dl>
<dt>neglog2_0.88</dt><dd><p>Add a cutoff value of <code class="reqn">-\log_{2}{0.88}</code>.</p>
</dd>
<dt>log2_1.2</dt><dd><p>Add a cutoff value of <code class="reqn">\log_{2}{1.2}</code>. Typically for fold 
change data.</p>
</dd>
<dt>log2_2</dt><dd><p>Add a cutoff value <code class="reqn">\log_{2}{2}</code>. Typically for fold change data.</p>
</dd>
</dl>

<p>Log Base 10
</p>

<dl>
<dt>log10_1.2</dt><dd><p>Add a cutoff value of <code class="reqn">\log_{10}{1.2}</code>. Typically for fold 
change data.</p>
</dd>
<dt>log10_2</dt><dd><p>Add a cutoff value of <code class="reqn">\log_{10}{2}</code>. Typically for fold change 
data.</p>
</dd>
</dl>




<h4>Percent of Control Methods</h4>


<dl>
<dt>pc05</dt><dd><p>Add a cutoff value of 5. Typically for percent of control data.</p>
</dd>
<dt>pc10</dt><dd><p>Add a cutoff value of 10. Typically for percent of control data.</p>
</dd>
<dt>pc20</dt><dd><p>Add a cutoff value of 20. Typically for percent of control data.</p>
</dd>
<dt>pc25</dt><dd><p>Add a cutoff value of 25. Typically for percent of control data.</p>
</dd>
<dt>pc30</dt><dd><p>Add a cutoff value of 30. Typically for percent of control data.</p>
</dd>
<dt>pc50</dt><dd><p>Add a cutoff value of 50. Typically for percent of control data.</p>
</dd>
<dt>pc70</dt><dd><p>Add a cutoff value of 70. Typically for percent of control data.</p>
</dd>
<dt>pc95</dt><dd><p>Add a cutoff value of 95. Typically for percent of control data.</p>
</dd>
</dl>




<h4>Other Methods</h4>


<dl>
<dt>maxmed20pct</dt><dd><p>Add a cutoff value of 20 percent of the maximum of all endpoint maximal 
average response values (max_med).</p>
</dd>
<dt>coff_2.32</dt><dd><p>Add a cutoff value of 2.32.</p>
</dd>
<dt>loec.coff</dt><dd><p>Method not yet updated for tcpl implementation. Identify the lowest observed 
effective concentration (loec) compared to baseline.</p>
</dd>
</dl>




<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc5">mc5</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what methods get applied to 
each aeid.
</p>

<hr>
<h2 id='mc6'>Perform level 6  
multiple-concentration processing</h2><span id='topic+mc6'></span>

<h3>Description</h3>

<p><code>mc6</code> loads level 5 data from the tcpl 
database for the given id and performs level 6 
multiple-concentration processing. 
The processed data is then loaded into the mc6 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc6(ae, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc6_+3A_ae">ae</code></td>
<td>
<p>Integer of length 1, assay endpoint id (aeid) for processing.</p>
</td></tr>
<tr><td><code id="mc6_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 6 multiple-concentration flagging uses both the plate level 
concentration-response data and the modeled parameters to flag potential 
false positives and false negative results.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+MC6_Methods">MC6_Methods</a></code>
</p>
<p>Other multiple-concentration: 
<code><a href="#topic+mc1">mc1</a>()</code>,
<code><a href="#topic+mc2">mc2</a>()</code>,
<code><a href="#topic+mc3">mc3</a>()</code>,
<code><a href="#topic+mc4">mc4</a>()</code>,
<code><a href="#topic+mc5">mc5</a>()</code>
</p>

<hr>
<h2 id='MC6_Methods'>Load list of level 6 multiple-concentration flag methods</h2><span id='topic+MC6_Methods'></span><span id='topic+mc6_mthds'></span>

<h3>Description</h3>

<p><code>mc6_mthds</code> returns a list of flag methods to be used 
during level 6 multiple-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc6_mthds()
</code></pre>


<h3>Value</h3>

<p>A list functions
</p>


<h3>Available Methods</h3>

<p>More information about the level 6 multiple-concentration processing is 
available in the package vignette, &quot;Data_processing.&quot;
</p>

<dl>
<dt>modl.directionality.fail</dt><dd><p>Flag series if model directionality is questionable, i.e. if 
the winning model direction was opposite, more responses (resp) would have exceeded the cutoff 
(coff). If loss was winning directionality (top &lt; 0), flag if 
<code class="reqn">count(resp&lt;-1*coff)&lt;2*count(resp&gt;coff)</code>. 
If gain was winning directionality (top &gt; 0), flag if 
<code class="reqn">count(resp&gt;coff)&lt;2*count(resp&lt;-1*coff)</code>.</p>
</dd>
<dt>low.nrep</dt><dd><p>Flag series if the average number of replicates per concentration is less than 
2; <code class="reqn">nrep &lt; 2</code>.</p>
</dd>
<dt>low.nconc</dt><dd><p>Flag series if 4 concentrations or less were tested; <code class="reqn">nconc&lt;=4</code>.
</p>
</dd>
<dt>bmd.high</dt><dd><p>Flag series if modeled benchmark dose (BMD) is greater than AC50 
(concentration at 50 percent maximal response). This is indicates high variability in baseline 
response in excess of more than half of the maximal response.</p>
</dd>
<dt>singlept.hit.high</dt><dd><p>Flag single-point hit that's only at the highest conc tested, where 
series is an active hit call (hitc &gt;= 0.9) with the median response observed above baseline 
occurring only at the highest tested concentration tested.</p>
</dd>
<dt>singlept.hit.mid</dt><dd><p>Flag single-point hit that's not at the highest conc tested, where 
series is an active hit call (hitc &gt;= 0.9) with the median response observed above baseline 
occurring only at one concentration and not the highest concentration tested.</p>
</dd>
<dt>multipoint.neg</dt><dd><p>Flag multi-point miss, where series is an inactive hit call (hitc &lt; 0.9) 
with multiple median responses observed above baseline.</p>
</dd>
<dt>gnls.lowconc</dt><dd><p>Flag series where winning model is gain-loss (gnls) and the gain AC50 is 
less than the minimum tested concentration, and the loss AC50 is less than the mean tested 
concentration.</p>
</dd>
<dt>noise</dt><dd><p>Flag series as noisy if the quality of fit as calculated by the root mean square 
error (rmse) for the series is greater than the cutoff (coff); <code class="reqn">rmse &gt; coff</code>.</p>
</dd>
<dt>border</dt><dd><p>Flag series if borderline activity is suspected based on modeled top parameter 
(top) relative to cutoff (coff); <code class="reqn">|top|&lt;=1.2*coff~or~|top|&gt;=0.8*coff</code>.</p>
</dd>
<dt>overfit.hit</dt><dd><p>Method not yet updated for tcpl implementation. Flag hit-calls that would 
get changed after doing the small N correction to the aic values.</p>
</dd>
<dt>efficacy.50</dt><dd><p>Flag low efficacy hits if series has an active hit call (hitc &gt;= 0.9) and 
efficacy values (e.g. top and maximum median response) less than 50 percent; intended for 
biochemical assays. If <code class="reqn">hitc&gt;=0.9</code> and <code class="reqn">coff&gt;=5</code>, then flag when 
<code class="reqn">top&lt;50</code> or <code class="reqn">maxmed &lt; 50</code>. If <code class="reqn">hitc&gt;=0.9</code> and 
<code class="reqn">coff&lt;5</code>, then flag when <code class="reqn">top&lt;\log_{2}{1.5}</code> or 
<code class="reqn">maxmed&lt;\log_{2}{1.5}</code>.</p>
</dd>
<dt>ac50.lowconc</dt><dd><p>Flag series with an active hit call (hitc &gt;= 0.9) if AC50 (concentration 
at 50 percent maximal response) is less than the lowest concentration tested; if 
<code class="reqn">hitc&gt;=0.9</code> and <code class="reqn">ac50&lt;10^{log_{c}{min}}</code>, then flag.</p>
</dd>
<dt>viability.gnls</dt><dd><p>Flag series with an active hit call (hitc &gt;= 0.9) if denoted as cell 
viability assay with winning model is gain-loss (gnls); if hitc &gt;= 0.9, modl = &quot;gnls&quot; and 
cell_viability_assay = 1, then flag.</p>
</dd>
<dt>no.med.gt.3bmad</dt><dd><p>Flag series where no median response values are greater than baseline as 
defined by 3 times the baseline median absolute deviation (bmad); nmed_gtbl = 0, where 
nmed_gtbl is the number of medians greater than 3 * bmad.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc6">mc6</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what
methods get applied to each aeid.
</p>

<hr>
<h2 id='mcdat'>A subset of ToxCast data showing changes in the activity of the intracellular estrogen receptor.</h2><span id='topic+mcdat'></span>

<h3>Description</h3>

<p>The example dataset is used to illustrate how the user can pipeline multiple-concentration
data from chemical screening using tcplLite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcdat
</code></pre>


<h3>Format</h3>

<p>A data frame with 14183 rows and 10 variables:
</p>

<dl>
<dt>spid</dt><dd><p>sample ID</p>
</dd>
<dt>apid</dt><dd><p>assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>well-plate row number</p>
</dd>
<dt>coli</dt><dd><p>well-plate column number</p>
</dd>
<dt>wllt</dt><dd><p>well type</p>
</dd>
<dt>wllq</dt><dd><p>well quality</p>
</dd>
<dt>conc</dt><dd><p>concentration in micromolar</p>
</dd>
<dt>rval</dt><dd><p>raw assay component readout value</p>
</dd>
<dt>srcf</dt><dd><p>source file containing the data</p>
</dd>
<dt>acsn</dt><dd><p>assay component source name</p>
</dd>
</dl>



<h3>Source</h3>

<p>ToxCast database
</p>

<hr>
<h2 id='Method+20functions'>Functions for managing processing methods</h2><span id='topic+Method+20functions'></span><span id='topic+tcplMthdAssign'></span><span id='topic+tcplMthdClear'></span><span id='topic+tcplMthdList'></span><span id='topic+tcplMthdLoad'></span>

<h3>Description</h3>

<p>These functions are used to manage which methods are used to process data.
They include methods for assigning, clearing, and loading the assigned 
methods. Also, <code>tcplMthdList</code> lists the available methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplMthdAssign(lvl, id, mthd_id, ordr = NULL, type)

tcplMthdClear(lvl, id, mthd_id = NULL, type)

tcplMthdList(lvl, type = "mc")

tcplMthdLoad(lvl, id = NULL, type = "mc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Method+2B20functions_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the method level</p>
</td></tr>
<tr><td><code id="Method+2B20functions_+3A_id">id</code></td>
<td>
<p>Integer, the assay component or assay endpoint id(s)</p>
</td></tr>
<tr><td><code id="Method+2B20functions_+3A_mthd_id">mthd_id</code></td>
<td>
<p>Integer, the method id(s)</p>
</td></tr>
<tr><td><code id="Method+2B20functions_+3A_ordr">ordr</code></td>
<td>
<p>Integer, the order in which to execute the analysis methods,
must be the same length as mthd_id, does not apply to levels 5 or 6</p>
</td></tr>
<tr><td><code id="Method+2B20functions_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplMthdLoad</code> loads the assigned methods for the given level and 
ID(s). Similarly, <code>tcplMthdList</code> displays the available methods for 
the given level. These two functions do not make any changes to the 
database.
</p>
<p>Unlike the <code>-Load</code> and <code>-List</code> functions, the <code>-Assign</code> and 
<code>-Clear</code> functions alter the database and trigger a delete cascade. 
<code>tcplMthdAssign</code> assigns methods to the given ID(s), and 
<code>tcplMthdClear</code> removes methods. In addition to the method ID 
('mthd_id'), assigning methods at some levels require an order ('ordr'). 
The 'ordr' parameter is necessary to allow progression of methods at level
one for single-concentration processing, and levels two and three for 
multiple-concentration processing. More information about method assignments 
and the delete cascade are available in the package vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfDefault()

## tcplListMthd allows the user to display the available methods for 
## a given level and data type
head(tcplMthdList(lvl = 2, type = "mc"))

## tcplLoadMthd shows which methods are assigned for the given ID, level,
## and data type. Here we will show how to register, load, and clear methods
## using an acid not in the example database. Note: There is no check for
## whether an ID exists before assigning/clearing methods. 
tcplMthdLoad(lvl = 2, id = 55, type = "mc")

## Not run: 
## ACID 55 does not have any methods. Assign methods from the list above. 
tcplMthdAssign(lvl = 2, 
               id = 55, 
               mthd_id = c(3, 4, 2), 
               ordr = 1:3, 
               type = "mc")
## Method assignment can be done for multiple assays, too. 
tcplMthdAssign(lvl = 2, 
               id = 53:54, 
               mthd_id = c(3, 4, 2), 
               ordr = 1:3, 
               type = "mc")
               
## Cleanup example method assigments
tcplMthdClear(lvl = 2, id = 53:55, type = "mc")

## End(Not run)
## Reset configuration
options(conf_store)
</code></pre>

<hr>
<h2 id='Models'>Model objective functions</h2><span id='topic+Models'></span><span id='topic+tcplObjCnst'></span><span id='topic+tcplObjGnls'></span><span id='topic+tcplObjHill'></span>

<h3>Description</h3>

<p>These functions take in the dose-response data and the model parameters, and
return a likelihood value. They are intended to be optimized using 
<code><a href="stats.html#topic+constrOptim">constrOptim</a></code> in the <code><a href="#topic+tcplFit">tcplFit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplObjCnst(p, resp)

tcplObjGnls(p, lconc, resp)

tcplObjHill(p, lconc, resp)

tcplObjCnst(p, resp)

tcplObjGnls(p, lconc, resp)

tcplObjHill(p, lconc, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Models_+3A_p">p</code></td>
<td>
<p>Numeric, the parameter values. See details for more information.</p>
</td></tr>
<tr><td><code id="Models_+3A_resp">resp</code></td>
<td>
<p>Numeric, the response values</p>
</td></tr>
<tr><td><code id="Models_+3A_lconc">lconc</code></td>
<td>
<p>Numeric, the log10 concentration values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions produce an estimated value based on the model and given 
parameters for each observation. Those estimated values are then used with 
the observed values and a scale term to calculate the log-likelihood.
</p>
<p>Let <code class="reqn">t(z,\nu)</code> be the Student's t-distribution with <code class="reqn">\nu</code> degrees of
freedom, <code class="reqn">y_{i}</code> be the observed response at the <code class="reqn">i^{th}</code> 
observation, and <code class="reqn">\mu_{i}</code> be the estimated response at the <code class="reqn">i^{th}</code> 
observation. We calculate <code class="reqn">z_{i}</code> as:
</p>
<p style="text-align: center;"><code class="reqn">
z_{i} = \frac{y_{i} - \mu_{i}}{e^\sigma}
</code>
</p>

<p>where <code class="reqn">\sigma</code> is the scale term. Then the log-likelihood is:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_{i=1}^{n} [ln(t(z_{i}, 4)) - \sigma]
</code>
</p>

<p>Where <code class="reqn">n</code> is the number of observations.
</p>


<h3>Value</h3>

<p>The log-likelihood.
</p>


<h3>Constant Model (cnst)</h3>

<p><code>tcplObjCnst</code> calculates the likelyhood for a constant model at 0. The
only parameter passed to <code>tcplObjCnst</code> by <code>p</code> is the scale term
<code class="reqn">\sigma</code>. The constant model value <code class="reqn">\mu_{i}</code> for the
<code class="reqn">i^{th}</code> observation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{i} = 0</code>
</p>

<p><code>tcplObjCnst</code> calculates the likelyhood for a constant model at 0. The 
only parameter passed to <code>tcplObjCnst</code> by <code>p</code> is the scale term 
<code class="reqn">\sigma</code>. The constant model value <code class="reqn">\mu_{i}</code> for the  
<code class="reqn">i^{th}</code> observation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{i} = 0</code>
</p>



<h3>Gain-Loss Model (gnls)</h3>

<p><code>tcplObjGnls</code> calculates the likelyhood for a 5 parameter model as the
product of two Hill models with the same top and both bottoms equal to 0.
The parameters passed to <code>tcplObjGnls</code> by <code>p</code> are (in order) top
(<code class="reqn">\mathit{tp}</code>), gain log AC50 (<code class="reqn">\mathit{ga}</code>), gain hill coefficient (<code class="reqn">gw</code>),
loss log AC50 <code class="reqn">\mathit{la}</code>, loss hill coefficient <code class="reqn">\mathit{lw}</code>, and the scale
term (<code class="reqn">\sigma</code>). The gain-loss model value <code class="reqn">\mu_{i}</code> for the
<code class="reqn">i^{th}</code> observation is given by:
</p>
<p style="text-align: center;"><code class="reqn">
g_{i} = \frac{1}{1 + 10^{(\mathit{ga} - x_{i})\mathit{gw}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
l_{i} = \frac{1}{1 + 10^{(x_{i} - \mathit{la})\mathit{lw}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_{i} = \mathit{tp}(g_{i})(l_{i})</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the log concentration for the <code class="reqn">i^{th}</code>
observation.
</p>
<p><code>tcplObjGnls</code> calculates the likelyhood for a 5 parameter model as the 
product of two Hill models with the same top and both bottoms equal to 0. 
The parameters passed to <code>tcplObjGnls</code> by <code>p</code> are (in order) top 
(<code class="reqn">\mathit{tp}</code>), gain log AC50 (<code class="reqn">\mathit{ga}</code>), gain hill coefficient (<code class="reqn">gw</code>), 
loss log AC50 <code class="reqn">\mathit{la}</code>, loss hill coefficient <code class="reqn">\mathit{lw}</code>, and the scale 
term (<code class="reqn">\sigma</code>). The gain-loss model value <code class="reqn">\mu_{i}</code> for the 
<code class="reqn">i^{th}</code> observation is given by:
</p>
<p style="text-align: center;"><code class="reqn">
g_{i} = \frac{1}{1 + 10^{(\mathit{ga} - x_{i})\mathit{gw}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
l_{i} = \frac{1}{1 + 10^{(x_{i} - \mathit{la})\mathit{lw}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu_{i} = \mathit{tp}(g_{i})(l_{i})</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the log concentration for the <code class="reqn">i^{th}</code> 
observation.
</p>


<h3>Hill Model (hill)</h3>

<p><code>tcplObjHill</code> calculates the likelyhood for a 3 parameter Hill model
with the bottom equal to 0. The parameters passed to <code>tcplObjHill</code> by
<code>p</code> are (in order) top (<code class="reqn">\mathit{tp}</code>), log AC50 (<code class="reqn">\mathit{ga}</code>), hill
coefficient (<code class="reqn">\mathit{gw}</code>), and the scale term (<code class="reqn">\sigma</code>). The hill model
value <code class="reqn">\mu_{i}</code> for the <code class="reqn">i^{th}</code> observation is given
by:
</p>
<p style="text-align: center;"><code class="reqn">
\mu_{i} = \frac{tp}{1 + 10^{(\mathit{ga} - x_{i})\mathit{gw}}}
</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the log concentration for the <code class="reqn">i^{th}</code>
observation.
</p>
<p><code>tcplObjHill</code> calculates the likelyhood for a 3 parameter Hill model
with the bottom equal to 0. The parameters passed to <code>tcplObjHill</code> by 
<code>p</code> are (in order) top (<code class="reqn">\mathit{tp}</code>), log AC50 (<code class="reqn">\mathit{ga}</code>), hill 
coefficient (<code class="reqn">\mathit{gw}</code>), and the scale term (<code class="reqn">\sigma</code>). The hill model 
value <code class="reqn">\mu_{i}</code> for the <code class="reqn">i^{th}</code> observation is given 
by:
</p>
<p style="text-align: center;"><code class="reqn">
\mu_{i} = \frac{tp}{1 + 10^{(\mathit{ga} - x_{i})\mathit{gw}}}
</code>
</p>

<p>where <code class="reqn">x_{i}</code> is the log concentration for the <code class="reqn">i^{th}</code> 
observation.
</p>

<hr>
<h2 id='Query+20functions'>Wrappers for sending queries and fetching results</h2><span id='topic+Query+20functions'></span><span id='topic+tcplQuery'></span><span id='topic+tcplSendQuery'></span>

<h3>Description</h3>

<p>These functions send a query to the given database, and are the access point
for all tcpl functions that query or update the tcpl database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplQuery(
  query,
  db = getOption("TCPL_DB"),
  drvr = getOption("TCPL_DRVR"),
  tbl = NULL
)

tcplSendQuery(
  query,
  db = getOption("TCPL_DB"),
  drvr = getOption("TCPL_DRVR"),
  tbl = NULL,
  delete = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Query+2B20functions_+3A_query">query</code></td>
<td>
<p>Character of length 1, the query string</p>
</td></tr>
<tr><td><code id="Query+2B20functions_+3A_db">db</code></td>
<td>
<p>Character of length 1, the name of the tcpl database</p>
</td></tr>
<tr><td><code id="Query+2B20functions_+3A_drvr">drvr</code></td>
<td>
<p>Character of length 1, which database driver to use</p>
</td></tr>
<tr><td><code id="Query+2B20functions_+3A_tbl">tbl</code></td>
<td>
<p>Tables to be read queried</p>
</td></tr>
<tr><td><code id="Query+2B20functions_+3A_delete">delete</code></td>
<td>
<p>Logical of length 1, execute delete on queried table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the tcpl package only supports the &quot;MySQL&quot; and &quot;tcplLite&quot; database
drivers.
</p>
<p><code>tcplQuery</code> returns a data.table object with the query results.
<code>tcplSendQuery</code> sends a query, but does not fetch any results, and 
returns 'TRUE' or the error message given by the database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
TCPLlite &lt;- file.path(system.file(package = "tcpl"), "example")
tcplConf(db = TCPLlite, user = NA, host = NA, drvr = "tcplLite")

tcplQuery("SELECT 'Hello World';")

## When using tcplLite, name of table must be passed into tcplQuery
if (conf_store$TCPL_DRVR == 'MySQL') {
  tcplQuery("SELECT * FROM assay;")
} else {
  tcplQuery("SELECT * FROM assay;", tbl='assay')
}
 
## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='Register+2Fupdate+20annotation'>Functions for registering &amp; updating annotation information</h2><span id='topic+Register+2Fupdate+20annotation'></span><span id='topic+tcplRegister'></span><span id='topic+tcplUpdate'></span>

<h3>Description</h3>

<p>These functions are used to register and update the chemical and assay 
annotation information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplRegister(what, flds)

tcplUpdate(what, id, flds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Register+2B2Fupdate+2B20annotation_+3A_what">what</code></td>
<td>
<p>Character of length 1, the name of the ID to register or update</p>
</td></tr>
<tr><td><code id="Register+2B2Fupdate+2B20annotation_+3A_flds">flds</code></td>
<td>
<p>Named list, the other fields and their values</p>
</td></tr>
<tr><td><code id="Register+2B2Fupdate+2B20annotation_+3A_id">id</code></td>
<td>
<p>Integer, the ID value(s) to update</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used to populate the tcpl database with the necessary
annotation information to complete the processing. As shown in the package
vignette, the package requires some information about the samples and assays
before data can be loaded into the tcpl database. 
</p>
<p>Depending on what is being registered, different information is required. 
The following table lists the fields that can be registered/updated by these
functions, and the minimal fields required for registering a new ID. (The
database table affected is in parentheses.) 
</p>

<ul>
<li><p> asid (assay_source): assay_source_name
</p>
</li>
<li><p> aid (assay): asid, assay_name, assay_footprint
</p>
</li>
<li><p> acid (assay_component): aid, assay_component_name
</p>
</li>
<li><p> aeid (assay_component_endpoint): acid, assay_component_endpoint_name,
normalized_data_type
</p>
</li>
<li><p> acsn (assay_component_map): acid, acsn
</p>
</li>
<li><p> spid (sample): spid, chid
</p>
</li>
<li><p> chid (chemical): chid, casn
</p>
</li>
<li><p> clib (chemical_library): chid, clib
</p>
</li></ul>
 
<p>Note: The functions accept the abbreviated forms of the names, ie. &quot;aenm&quot; 
rather than the full &quot;assay_component_endpoint_name.&quot; More information about
the registration process and all of the fields is available in the vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfDefault()

## Load current ASID information
tcplLoadAsid()

## Register a new assay source
tcplRegister(what = "asid", flds = list(asnm = "example_asid"))

## Show the newly registered ASID
tcplLoadAsid(add.fld = "assay_source_desc")

## Notice that the newly created ASID does not have an assay_source_desc.
## The field could have been defined during the registration process, but
## can also be updated using tcplUpdate
i1 &lt;- tcplLoadAsid()[asnm == "example_asid", asid]
tcplUpdate(what = "asid", 
           id = i1, 
           flds = list(assay_source_desc = "example asid description"))
tcplLoadAsid(add.fld = "assay_source_desc")

## Remove the created ASID. Note: Manually deleting primary keys can cause
## serious database problems and should not generally be done. 

## If using the tcplLite DRVR, must specify table name
if (conf_store$TCPL_DRVR == 'MySQL') {
  tcplSendQuery(paste0("DELETE FROM assay_source WHERE asid = ", i1, ";"))
} else {
  qy &lt;- paste0("SELECT * FROM assay_source WHERE NOT asid = ", i1, ";")
  tcplSendQuery(qy, tbl='assay_source', delete=TRUE)
}

## Reset configuration
options(conf_store)

## End(Not run)

</code></pre>

<hr>
<h2 id='registerMthd'>Add a new analysis method</h2><span id='topic+registerMthd'></span>

<h3>Description</h3>

<p><code>registerMthd</code> registers a new analysis method to the tcpl 
databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerMthd(lvl, mthd, desc, nddr = 0L, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerMthd_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the level for the analysis method</p>
</td></tr>
<tr><td><code id="registerMthd_+3A_mthd">mthd</code></td>
<td>
<p>Character, the name of the method</p>
</td></tr>
<tr><td><code id="registerMthd_+3A_desc">desc</code></td>
<td>
<p>Character, same length as mthd, the method description</p>
</td></tr>
<tr><td><code id="registerMthd_+3A_nddr">nddr</code></td>
<td>
<p>Integer, 0 or 1, 1 if the method requires loading the dose-
response data</p>
</td></tr>
<tr><td><code id="registerMthd_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'mthd' must match a corresponding function name in the functions that load
the methods, ie. <code>mc2_mthds</code>. 'nddr' only applies to level 6 
methods.
</p>

<hr>
<h2 id='sc_vignette'>List with single-concentration data for the vignette</h2><span id='topic+sc_vignette'></span>

<h3>Description</h3>

<p>This dataset is a list with 3 data.tables (sc0,sc1,sc2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_vignette
</code></pre>


<h3>Format</h3>


<ol>
<li> <p><strong>sc0</strong> A data frame with 10 rows and 18 columns containing
level 0 formatted raw data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>acid</dt><dd><p>Assay Component ID</p>
</dd>
<dt>acnm</dt><dd><p>Assay Component Name</p>
</dd>
<dt>s0id</dt><dd><p>Level 0 (sc0) ID</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>wllq</dt><dd><p>Well Quality (0 or 1)</p>
</dd>
<dt>conc</dt><dd><p>Concentration in micromolar</p>
</dd>
<dt>rval</dt><dd><p>Raw assay component readout value</p>
</dd>
<dt>srcf</dt><dd><p>Source file containing the raw data</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>sc1</strong> A data frame with 10 rows and 20 columns containing
level 1 normalized data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>aeid</dt><dd><p>Assay Component Endpoint ID</p>
</dd>
<dt>aenm</dt><dd><p>Assay endpoint name (i.e., assay_component_endpoint_name)</p>
</dd>
<dt>acid</dt><dd><p>Assay Component ID</p>
</dd>
<dt>acnm</dt><dd><p>Assay Component Name</p>
</dd>
<dt>s0id</dt><dd><p>Level 0 (sc0) ID</p>
</dd>
<dt>s1id</dt><dd><p>Level 1 (sc1) ID</p>
</dd>
<dt>apid</dt><dd><p>Assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>Row Index</p>
</dd>
<dt>coli</dt><dd><p>Column Index</p>
</dd>
<dt>wllt</dt><dd><p>Well Type</p>
</dd>
<dt>logc</dt><dd><p>Log base 10 concentration</p>
</dd>
<dt>resp</dt><dd><p>Normalized response value</p>
</dd>
<dt>resp_unit</dt><dd><p>Response Units</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li>
<li> <p><strong>sc2</strong> A data frame with 10 rows and 15 columns containing
level 2 efficacy/hit designation data.
</p>

<dl>
<dt>spid</dt><dd><p>Sample ID</p>
</dd>
<dt>chid</dt><dd><p>Unique chemical ID number for tcpl</p>
</dd>
<dt>casn</dt><dd><p>Chemical Abstract Service(CAS) number</p>
</dd>
<dt>chnm</dt><dd><p>Chemical name</p>
</dd>
<dt>dsstox_substance_id</dt><dd><p>Chemical-specific DTXSID</p>
</dd>
<dt>code</dt><dd><p>CAS number compressed into numeric string</p>
</dd>
<dt>aeid</dt><dd><p>Assay Component Endpoint ID</p>
</dd>
<dt>aenm</dt><dd><p>Assay endpoint name (i.e., assay_component_endpoint_name)</p>
</dd>
<dt>s2id</dt><dd><p>Level 2 (sc2) ID</p>
</dd>
<dt>bmad</dt><dd><p>The median absolute deviation of all treatment wells (default option) or blank wells </p>
</dd>
<dt>max_med</dt><dd><p>Maximum median response</p>
</dd>
<dt>hitc</dt><dd><p>Hitcall</p>
</dd>
<dt>coff</dt><dd><p>Cutoff</p>
</dd>
<dt>resp_unit</dt><dd><p>Response Units</p>
</dd>
<dt>conc_unit</dt><dd><p>Concentration Units</p>
</dd>
</dl>

</li></ol>


<hr>
<h2 id='sc1'>Perform level 1  
single-concentration processing</h2><span id='topic+sc1'></span>

<h3>Description</h3>

<p><code>sc1</code> loads level 0 data from the tcpl 
database for the given id and performs level 1 
single-concentration processing. 
The processed data is then loaded into the sc1 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc1(ac, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc1_+3A_ac">ac</code></td>
<td>
<p>Integer of length 1, assay component id (acid) for processing.</p>
</td></tr>
<tr><td><code id="sc1_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 1 single-concentration processing includes mapping assay component 
to assay endpoint, duplicating the data when the assay component has 
multiple assay endpoints, and any normalization of the data. Data 
normalization based on methods listed in sc1_aeid and sc1_methods tables.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+SC1_Methods">SC1_Methods</a></code>
</p>
<p>Other single-concentration: 
<code><a href="#topic+sc2">sc2</a>()</code>
</p>

<hr>
<h2 id='SC1_Methods'>List of level 1 single-concentration normalization functions</h2><span id='topic+SC1_Methods'></span><span id='topic+sc1_mthds'></span>

<h3>Description</h3>

<p><code>sc1_mthds</code> returns a list of functions to be used during level 1 
single-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc1_mthds()
</code></pre>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>sc1_mthds</code> return
a list of expressions to be executed in the <code>sc2</code> (not exported) 
function environment. The functions are described here for reference 
purposes, The <code>sc1_mthds</code> function is not exported, nor is it 
intended for use.
</p>
<p>All available methods are described in the Available Methods section, listed
by the function/method name.
</p>


<h3>Value</h3>

<p>A list functions
</p>


<h3>Available Methods</h3>

<p>The methods are broken into three types, based on what fields they define. 
Different methods are used to define &quot;bval&quot; (the baseline value), &quot;pval&quot;
(the positive control value), and &quot;resp&quot; (the final response value). 
</p>
<p>Although it does not say so specifically in each description, all methods 
are applied by acid.
</p>
<p>More information about the level 3 single-concentration processing is 
available in the package vignette, &quot;Data_processing.&quot;
</p>


<h4>bval Methods</h4>


<dl>
<dt>bval.apid.nwlls.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median,
by assay plate ID (apid), of the raw values (rval) for neutral control wells (wllt = n).</p>
</dd>
<dt>bval.apid.twlls.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median,
by assay plate ID (apid), of the raw values (rval) for test compound wells (wllt = t).</p>
</dd>
<dt>bval.apid.tn.med</dt><dd><p>Calculate the baseline value (bval) as the plate-wise median,
by assay plate ID (apid), of the raw values (rval) for test compound wells (wllt = t)
and neutral control wells (wllt = n).</p>
</dd>
</dl>

 


<h4>pval Methods</h4>


<dl>
<dt>pval.apid.pwlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the raw values (rval) for single-concentration 
gain-of-signal positive control wells (wllt = p).</p>
</dd>
<dt>pval.apid.mwlls.med</dt><dd><p>Calculate the positive control value (pval) as the plate-wise 
median, by assay plate ID (apid), of the raw values (rval) for multiple-concentration 
loss-of-signal negative control wells (wllt = m).</p>
</dd>
<dt>pval.apid.medpcbyconc.max</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise maximum, by assay plate ID (apid), of the medians of the raw values (rval) for 
gain-of-signal single- or multiple-concentration positive control wells (wllt = p or c) by 
apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.medpcbyconc.min</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise minimum, by assay plate ID (apid), of the medians of the raw values (rval) for 
gain-of-signal single- or multiple-concentration positive control wells (wllt = p or c) by 
apid, well type, and concentration.</p>
</dd>
<dt>pval.apid.medncbyconc.min</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise minimum, by assay plate ID (apid), of the medians of the raw values (rval) for 
gain-of-signal single- or multiple-concentration negative control wells (wllt = m or o) by 
apid, well type, and concentration.</p>
</dd>
<dt>pval.zero</dt><dd><p>Set the positive control value (pval) to 0; pval = 0.</p>
</dd>
<dt>pval.apid.or.aeid.pwlls.med</dt><dd><p>Calculate the positive control value (pval) as the 
plate-wise median, by assay plate ID (apid), of the raw values (rval) for 
single-concentration gain-of-signal positive control wells (wllt = p). For plates without p 
wells, set the pval as the median pval calculated from all plates.</p>
</dd>
</dl>

 


<h4>resp Methods</h4>


<dl>
<dt>resp.pc</dt><dd><p>Calculate the normalized response (resp) as a percent of control, i.e. the 
ratio of the difference between the raw (rval) and baseline (bval) values divided by the 
difference between positive control (pval) and baseline (bval) values multiplied by 100; 
<code class="reqn">resp=(rval-bval)/(pval-bval)*100</code>.</p>
</dd>
<dt>resp.fc</dt><dd><p>Calculate the normalized response (resp) as fold change, i.e. the ratio of 
the raw (rval) and baseline (bval) values; <code class="reqn">resp = rval/bval</code>.</p>
</dd>
<dt>resp.logfc</dt><dd><p>Calculate the normalized response (resp) as the fold change of logged,
i.e. the difference between raw (rval) and baseline (bval) log-scale values.</p>
</dd>
<dt>resp.log2</dt><dd><p>Transform the response values to log-scale (base 2).</p>
</dd>
<dt>resp.multneg1</dt><dd><p>Multiply the normalized response value (resp) by -1; 
<code class="reqn">-1*resp</code>.</p>
</dd>
<dt>none</dt><dd><p>Use raw value (rval) as is. This may be necessary for additional 
endpoint-specific adjustments, or where no additional sc1 methods are needed.</p>
</dd>
<dt>resp.incr.zerocenter.fc</dt><dd><p>Calculate the normalized response (resp) as a zero center 
fold change, i.e. the ratio of the raw (rval) and baseline (bval) values minus 1; 
<code class="reqn">resp=rval/bval-1</code>. Typically used for increasing responses.</p>
</dd>
</dl>




<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sc1">sc1</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what
methods get applied to each acid
</p>

<hr>
<h2 id='sc2'>Perform level 2  
single-concentration processing</h2><span id='topic+sc2'></span>

<h3>Description</h3>

<p><code>sc2</code> loads level 1 data from the tcpl 
database for the given id and performs level 2 
single-concentration processing. 
The processed data is then loaded into the sc2 table and 
all subsequent data is deleted with <code><a href="#topic+tcplCascade">tcplCascade</a></code>. See details 
for more information.
</p>
<p>The individual processing functions are no longer exported, as it is 
typically more convenient and suggested to use the <code><a href="#topic+tcplRun">tcplRun</a></code> 
wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc2(ae, wr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc2_+3A_ae">ae</code></td>
<td>
<p>Integer of length 1, assay endpoint id (aeid) for processing.</p>
</td></tr>
<tr><td><code id="sc2_+3A_wr">wr</code></td>
<td>
<p>Logical, whether the processed data should be written to the tcpl
database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Level 2 single-concentration processing defines the bmad value, and uses the
activity cutoff methods from sc2_aeid and sc2_methods to make an activity
call.
</p>


<h3>Value</h3>

<p>A boolean of length 1, indicating the success of the processing, or 
when 'wr' is FALSE, a list where the first element is a boolean indicating 
the success of processing and the second element is a data.table containing 
the processed data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Method+20functions">Method functions</a></code>, <code><a href="#topic+SC2_Methods">SC2_Methods</a></code>
</p>
<p>Other single-concentration: 
<code><a href="#topic+sc1">sc1</a>()</code>
</p>

<hr>
<h2 id='SC2_Methods'>List of level 2 single-concentration hit-call functions</h2><span id='topic+SC2_Methods'></span><span id='topic+sc2_mthds'></span>

<h3>Description</h3>

<p><code>sc2_mthds</code> returns a list of functions to be used during level 2 
single-concentration processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc2_mthds()
</code></pre>


<h3>Details</h3>

<p>The functions contained in the list returned by <code>sc2_mthds</code> return
a list of expressions to be executed in the <code>sc2</code> (not exported) 
function environment. The functions are described here for reference 
purposes, The <code>sc2_mthds</code> function is not exported, nor is it 
intended for use.
</p>
<p>All available methods are described in the Available Methods section, listed
by the function/method name.
</p>


<h3>Value</h3>

<p>A list functions
</p>


<h3>Available Methods</h3>

<p>The methods are broken down into four categories based on the type of cutoff they assign. 
Different methods are used to define cutoffs for &quot;bmad&quot; (baseline median absolute value), &quot;pc&quot; 
(percent of control), &quot;pc or bmad&quot;, &quot;log&quot; (<code class="reqn">\log_{2}</code> or <code class="reqn">\log_{10}</code>), and 
&quot;other&quot; (uncategorized methods).
</p>
<p>All methods are applied by aeid.
</p>
<p>Although there are method exceptions (notably within the other category), only highest 
calculated cutoff value based on assigned methods will be selected for hitcalling. Therefore, 
only the largest cutoff method per method type should be assigned.
</p>
<p>More information about the level 2 single-concentration processing is available in the package 
vignette, &quot;Data_processing.&quot;
</p>


<h4>BMAD Methods</h4>


<dl>
<dt>bmad1</dt><dd><p>Add a cutoff value of 1 multiplied by baseline median absolute deviation (bmad). 
By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad1.5</dt><dd><p>Add a cutoff value of 1.5 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad2</dt><dd><p>Add a cutoff value of 2 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad3</dt><dd><p>Add a cutoff value of 3 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad5</dt><dd><p>Add a cutoff value of 5 multiplied the baseline median absolute deviation (bmad). 
By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad6</dt><dd><p>Add a cutoff value of 6 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
<dt>bmad10</dt><dd><p>Add a cutoff value of 10 multiplied by the baseline median absolute deviation 
(bmad). By default, bmad is calculated using test compound wells (wllt = t) for the endpoint.</p>
</dd>
</dl>




<h4>Percent of Control Methods</h4>


<dl>
<dt>pc0.88</dt><dd><p>Add a cutoff value of 0.88. Typically for percent of control data.</p>
</dd>
<dt>pc20</dt><dd><p>Add a cutoff value of 20. Typically for percent of control data.</p>
</dd>
<dt>pc25</dt><dd><p>Add a cutoff value of 25. Typically for percent of control data.</p>
</dd>
<dt>pc30</dt><dd><p>Add a cutoff value of 30. Typically for percent of control data.</p>
</dd>
</dl>




<h4>Percent of Control or BMAD Methods</h4>


<dl>
<dt>pc30orbmad3</dt><dd><p>Add a cutoff value of either 30 or 3 multiplied by the baseline median 
absolute deviation (bmad), whichever is less. By default, bmad is calculated using test 
compound wells (wllt = t) for the endpoint.</p>
</dd>
</dl>




<h4>Log Methods</h4>

<p>Log Base 2
</p>

<dl>
<dt>log2_0.76</dt><dd><p>Add a cutoff value of 0.76 for log2-transformed data. This was a custom 
threshold value set for endpoint id 1690 (formerly aeid 1691).</p>
</dd>
<dt>log2_1.2</dt><dd><p>Add a cutoff value of <code class="reqn">log_{2}{1.2}</code>. Typically for fold change 
data.</p>
</dd>
<dt>log2_1.5</dt><dd><p>Add a cutoff value of <code class="reqn">log_{2}{1.5}</code>. Typically for fold change 
data.</p>
</dd>
</dl>

<p>Log Base 10
</p>

<dl>
<dt>log10_1.2</dt><dd><p>Add a cutoff value of <code class="reqn">log_{10}{1.2}</code>. Typically for fold 
change data.</p>
</dd>
</dl>




<h4>Other Methods</h4>


<dl>
<dt>ow_bmad_nwells</dt><dd><p>Overwrite the default baseline median absolute value (bmad) with a bmad 
calculated using neutral control wells (wllt = n).</p>
</dd>
<dt>ow_bidirectional_false</dt><dd><p>Overwrite the max_med and max_tmp values, which were calculated 
using absolute value, to a calculation not using absolute value for non-bidirectional data.</p>
</dd>
</dl>




<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sc2">sc2</a></code>, <code><a href="#topic+Method+20functions">Method functions</a></code> to query what
methods get applied to each acid
</p>

<hr>
<h2 id='scdat'>A subset of ToxCast data showing changes in transcription factor activity for multiple targets.</h2><span id='topic+scdat'></span>

<h3>Description</h3>

<p>The example dataset is used to illustrate how the user can pipeline single-concentration
data from chemical screening using tcplLite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdat
</code></pre>


<h3>Format</h3>

<p>A data frame with 320 rows and 10 variables:
</p>

<dl>
<dt>spid</dt><dd><p>sample ID</p>
</dd>
<dt>apid</dt><dd><p>assay plate ID</p>
</dd>
<dt>rowi</dt><dd><p>well-plate row number (N/A)</p>
</dd>
<dt>coli</dt><dd><p>well-plate column number (N/A)</p>
</dd>
<dt>wllt</dt><dd><p>well type (N/A)</p>
</dd>
<dt>wllq</dt><dd><p>well quality (N/A)</p>
</dd>
<dt>conc</dt><dd><p>concentration in micromolar</p>
</dd>
<dt>rval</dt><dd><p>raw assay component readout value</p>
</dd>
<dt>srcf</dt><dd><p>source file containing the data</p>
</dd>
<dt>acsn</dt><dd><p>assay component source name</p>
</dd>
</dl>



<h3>Source</h3>

<p>ToxCast database
</p>

<hr>
<h2 id='sink.reset'>Reset all sinks</h2><span id='topic+sink.reset'></span>

<h3>Description</h3>

<p><code>sink.reset</code> resets all sinks and returns all output to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sink.reset()
</code></pre>


<h3>Details</h3>

<p><code>sink.reset</code> identifies all sinks with <code>sink.number</code> then returns
all output and messages back to the console.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sink">sink</a></code>, <code><a href="base.html#topic+sink.number">sink.number</a></code>
</p>
<p>Other tcpl abbreviations: 
<code><a href="#topic+is.odd">is.odd</a>()</code>,
<code><a href="#topic+lu">lu</a>()</code>,
<code><a href="#topic+lw">lw</a>()</code>
</p>

<hr>
<h2 id='tcplAddModel'>Draw a tcpl Model onto an existing plot</h2><span id='topic+tcplAddModel'></span>

<h3>Description</h3>

<p><code>tcplAddModel</code> draws a a line for one of the tcpl Models (see 
<code><a href="#topic+Models">Models</a></code> for more information) onto an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplAddModel(pars, modl = NULL, adj = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplAddModel_+3A_pars">pars</code></td>
<td>
<p>List of parameters from level 4 or 5 output</p>
</td></tr>
<tr><td><code id="tcplAddModel_+3A_modl">modl</code></td>
<td>
<p>Character of length 1, the model to plot: 'cnst,' 'hill,' or 
'gnls'</p>
</td></tr>
<tr><td><code id="tcplAddModel_+3A_adj">adj</code></td>
<td>
<p>Numeric of length 1, an adjustment factor, see details for more
information</p>
</td></tr>
<tr><td><code id="tcplAddModel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>curve</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplAddModel</code> draws the model line assuming the x-axis represents log
base 10 concentration.
</p>
<p>If <code>modl</code> is NULL, the function checks <code>pars$modl</code> and will return 
an error if <code>pars$modl</code> is also NULL.
</p>
<p><code>adj</code> is intended to scale the models, so that models with different 
response units can be visualized on a single plot. The recommended value for 
<code>adl</code> is <code>1/(3*bmad)</code> for level 4 data and <code>1/coff</code> for level 
5 data. If <code>adj</code> is NULL the function will check <code>pars$adj</code> and 
set <code>adj</code> to 1 if <code>pars$adj</code> is also NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Models">Models</a></code>, <code><a href="#topic+tcplPlotFits">tcplPlotFits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create some dummy data to plot
logc &lt;- 1:10
r1 &lt;- sapply(logc, tcplHillVal, ga = 5, tp = 50, gw = 0.5)
r2 &lt;- log2(sapply(logc, tcplHillVal, ga = 4, tp = 30, gw = 0.5))
p1 &lt;- tcplFit(logc = logc, resp = r1, bmad = 10)
p2 &lt;- tcplFit(logc = logc, resp = r2, bmad = log2(1.5))

## In the dummy data above, the two plots are on very different scales
plot(r1 ~ logc, pch = 16, ylab = "raw response")
tcplAddModel(pars = p1, modl = "hill")
points(r2 ~ logc)
tcplAddModel(pars = p2, modl = "hill", lty = "dashed")

## To visualize the two curves on the same plot for comparison, we can 
## scale the values to the bmad, such that a scaled response of 1 will equal
## the bmad for each curve.
plot(r1/10 ~ logc, pch = 16, ylab = "scaled response")
tcplAddModel(pars = p1, modl = "hill", adj = 1/10)
points(r2/log2(5) ~ logc)
tcplAddModel(pars = p2, modl = "hill", adj = 1/log2(5), lty = "dashed")

</code></pre>

<hr>
<h2 id='tcplAICProb'>Calculate the AIC probabilities</h2><span id='topic+tcplAICProb'></span>

<h3>Description</h3>

<p><code>tcplAICProb</code> Calculates the probability that the model best represents 
the data based on the AIC value for each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplAICProb(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplAICProb_+3A_...">...</code></td>
<td>
<p>Numeric vectors of AIC values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes vectors of AIC values. Each vector represents the model
AIC values for multiple observation sets. Each vector must contain the same 
number and order of observation sets. The calculation assumes every possible
model is accounted for, and the results should be interpreted accordingly.
</p>


<h3>Value</h3>

<p>A vector of probability values for each model given, as a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplFit">tcplFit</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code> for more information 
about AIC values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Returns the probability for each model, given models with AIC values 
## ranging from 80 to 100
tcplAICProb(80, 85, 90, 95, 100)

## Also works for vectors
m1 &lt;- c(95, 195, 300) ## model 1 for three different observations
m2 &lt;- c(100, 200, 295) ## model 2 for three different observations
tcplAICProb(m1, m2)

</code></pre>

<hr>
<h2 id='tcplAppend'>Append rows to a table</h2><span id='topic+tcplAppend'></span>

<h3>Description</h3>

<p><code>tcplAppend</code> takes a data.table (dat) and appends the data.table into 
a database table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplAppend(dat, tbl, db, lvl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplAppend_+3A_dat">dat</code></td>
<td>
<p>data.table, the data to append to a table</p>
</td></tr>
<tr><td><code id="tcplAppend_+3A_tbl">tbl</code></td>
<td>
<p>Character of length 1, the table to append to</p>
</td></tr>
<tr><td><code id="tcplAppend_+3A_db">db</code></td>
<td>
<p>Character of length 1, the database containing <code>tbl</code></p>
</td></tr>
<tr><td><code id="tcplAppend_+3A_lvl">lvl</code></td>
<td>
<p>Usually Integer to indicate what level to auto-increment</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not exported and not intended to be used by the user.
</p>

<hr>
<h2 id='tcplCascade'>Do a cascading delete on tcpl screening data</h2><span id='topic+tcplCascade'></span>

<h3>Description</h3>

<p><code>tcplCascade</code> deletes the data for the given id(s) starting at 
the processing level given. The delete will cascade through all subsequent 
tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplCascade(lvl, type, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplCascade_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the first level to delete from</p>
</td></tr>
<tr><td><code id="tcplCascade_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
<tr><td><code id="tcplCascade_+3A_id">id</code></td>
<td>
<p>Integer, the id(s) to delete. See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data type can be either 'mc' for multiple concentration data, or 'sc'
for single concentration data. Multiple concentration data will be loaded
into the level tables, whereas the single concentration will be loaded into
the single tables. 
</p>
<p>If lvl is less than 3, id is interpreted as acid(s) and if lvl is greater 
than or equal to 3, id is interpreted as aeid(s).
</p>


<h3>Note</h3>

<p>This function is not exported and not intended to be used by the user.
</p>

<hr>
<h2 id='tcplCode2CASN'>Convert chemical code to CAS Registry Number</h2><span id='topic+tcplCode2CASN'></span>

<h3>Description</h3>

<p><code>tcplCode2CASN</code> takes a code and converts it CAS Registry Number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplCode2CASN(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplCode2CASN_+3A_code">code</code></td>
<td>
<p>Character of length 1, a chemical code</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks for the validity of the CAS Registry Number. Also, 
the ToxCast data includes chemicals for which there is no CASRN. The 
convention for these chemicals is to give them a CASRN as NOCAS_chid; the
code for these compounds is CNOCASchid. The function handles the NOCAS 
compounds as they are stored in the database, as shown in the example below.
</p>


<h3>Value</h3>

<p>A CAS Registry Number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tcplCode2CASN("C80057")
tcplCode2CASN("C09812420") ## Invalid CASRN will give a warning
tcplCode2CASN("CNOCAS0015") ## The underscore is reinserted for NOCAS codes

</code></pre>

<hr>
<h2 id='tcplCytoPt'>Calculate the cytotoxicity point based on the &quot;burst&quot; endpoints</h2><span id='topic+tcplCytoPt'></span>

<h3>Description</h3>

<p><code>tcplCytoPt</code> calculates the cytotoxicity point and average cytotoxicity 
distribution based on the activity in the &quot;burst&quot; assay endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplCytoPt(
  chid = NULL,
  aeid = NULL,
  flag = TRUE,
  min.test = TRUE,
  default.pt = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplCytoPt_+3A_chid">chid</code></td>
<td>
<p>Integer, chemical ID values to subset on</p>
</td></tr>
<tr><td><code id="tcplCytoPt_+3A_aeid">aeid</code></td>
<td>
<p>Integer, assay endpoint ID values to override the &quot;burst assay&quot;
definitions</p>
</td></tr>
<tr><td><code id="tcplCytoPt_+3A_flag">flag</code></td>
<td>
<p>Integer, mc6_mthd_id values to be passed to 
<code><a href="#topic+tcplSubsetChid">tcplSubsetChid</a></code></p>
</td></tr>
<tr><td><code id="tcplCytoPt_+3A_min.test">min.test</code></td>
<td>
<p>Integer or Boolean, the number of tested assay endpoints
required for a chemical to be used in calculating the &quot;global MAD.&quot;</p>
</td></tr>
<tr><td><code id="tcplCytoPt_+3A_default.pt">default.pt</code></td>
<td>
<p>Numeric of length 1, the default cytotoxicity point value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplCytoPt</code> provides estimates for chemical-specific cytotoxicity 
distributions (more information available in the vignette.) Before 
calculating the cytotoxicity distributions, the level 5 data is subsetted
by the <code><a href="#topic+tcplSubsetChid">tcplSubsetChid</a></code> function. 
</p>
<p>The 'chid' parameter specifies a subset of chemicals to use in the 
calculations, given by chemical ID (chid). The 'aeid' parameter specifies
which assays to use in calculating the cytotoxicity point and distribution.
By default <code>tcplCytoPt</code> will use all available chemicals and the 
assay endpoints defined by the 'burst_assay' field in the 
&quot;assay_component_endpoint&quot; table. The examples show how to identify the 
&quot;burst&quot; endpoints.
</p>
<p><code>tcplCytoPt</code> returns the cytotoxicity point (the AC50 values of the 
active &quot;burst&quot; endpoints), the corresponding MAD, and the global MAD (median
of the calculated MAD values). Not every chemical must be tested in every
&quot;burst&quot; endpoint. The 'min.test' parameter allows the user to specify a 
minimum number of tested assay endpoints as a requirement for MAD values to 
be included in the global MAD calculation. For example, suppose the user 
supplies 10 &quot;burst&quot; assays. The user can choose to require a chemical to be
tested in at least 5 of those assays for it's MAD value to be included in 
the global MAD calculation. Having chemicals with many less &quot;burst&quot; endpoints
tested may inflate or deflate the global MAD calculation. By default (values 
of <code>TRUE</code> or <code>NULL</code>), <code>tcplCytoPt</code> requires a chemical to be 
tested in at least 80% of the given &quot;burst&quot; assays. The user can also 
provide 'min.test' values of <code>FALSE</code> (indicating to include all MAD 
values), or a number (indicating a specific number of endpoints). 
</p>
<p>Chemicals without at least 2 active &quot;burst&quot; assays do not have a MAD value, 
and the cytotoxicity point is defined by the 'default.pt' parameter. The
default value for 'default.pt' is 3.
</p>
<p>The resulting data.table has the following fields:
</p>

<ol>
<li><p> &quot;chid&quot; &ndash; The chemical ID.
</p>
</li>
<li><p> &quot;code&quot; &ndash; The chemical code.
</p>
</li>
<li><p> &quot;chnm&quot; &ndash; The chemical name.
</p>
</li>
<li><p> &quot;casn&quot; &ndash; The chemical CASRN.
</p>
</li>
<li><p> &quot;med&quot; &ndash; The median of the &quot;burst&quot; endpoint log(AC50)
</p>
</li>
<li><p> &quot;mad&quot; &ndash; The MAD of the &quot;burst&quot; endpoint log(AC50) values.
</p>
</li>
<li><p> &quot;ntst&quot; &ndash; The number of &quot;burst&quot; endpoints tested.
</p>
</li>
<li><p> &quot;nhit&quot; &ndash; The number of active &quot;burst&quot; endpoints.
</p>
</li>
<li><p> &quot;used_in_global_mad_calc&quot; &ndash; TRUE/FALSE, whether the mad value was used in the
global MAD calculation.
</p>
</li>
<li><p> &quot;global_mad&quot; &ndash; The median of the &quot;mad&quot; values where &quot;used_in_global_mad_calc&quot; 
is TRUE.
</p>
</li>
<li><p> &quot;cyto_pt&quot; &ndash; The cytotoxicity point, or the value in &quot;med&quot; when 
&quot;nhit&quot; is at least 2.
</p>
</li>
<li><p> &quot;cyto_pt_um&quot; &ndash; <code class="reqn">10^\mathit{cyto\_pt}</code>  
</p>
</li>
<li><p> &quot;lower_bnd_um&quot; &ndash; <code class="reqn">10^{\mathit{cyto\_pt} - 3\mathit{global\_mad}}</code>
</p>
</li></ol>



<h3>Value</h3>

<p>A data.table with the cytotoxicity distribution for each chemical.
The definition of the field names are listed under &quot;details.&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfDefault()

## Can only calculate the cytotox burst if using the MySQL database and
## TCPL_DRVR == 'MySQL'

if (getOption("TCPL_DRVR") == "MySQL") {

## Load the "burst" endpoints -- none are defined in the example dataset
tcplLoadAeid(fld = "burst_assay", val = 1)

## Calculate the cytotoxicity distributions using both example endpoints
tcplCytoPt(aeid = 1:2)

## The above example does not calculate a global MAD, because no chemical
## hit both endpoints. (This makes sense, because both endpoints are 
## derived from one component, where one endpoint is acitivity in the
## up direction, and the other is activity in the down direction.)
## Note, the cyto_pt is also 3 for all chemicals, because the function
## requires at least two endpoints to calculate a cytotoxicity point. If 
## the user wishes to use one assay, this function is not necessary. 

## Changing 'default.pt' will change cyto_pt in the resulting data.table
tcplCytoPt(aeid = 1:2, default.pt = 6)
}

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcpldbStats'>Get summary statistics for the database</h2><span id='topic+tcpldbStats'></span>

<h3>Description</h3>

<p><code>tcpldbStats</code> takes a string(type) and an optional parameter(val) to return the summary statistics on the entire tcplLite database
When type = &quot;all&quot; the val is ignored. the function returns the number of distinct spid and aeids in the database at each level
When type = &quot;aeid&quot;, the val parameter has to be a valid aeid in the database. The function returns a 
table consisting of the number of distinct spids at each level of processing for the aeid given in 'val'
When type = &quot;spid&quot;, the val parameter has to be a valid spid in the database. The function returns a 
table consisting of the number of distinct aeids at each level of processing for the given spid in 'val'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcpldbStats(type = "all", val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcpldbStats_+3A_type">type</code></td>
<td>
<p>String either &quot;all&quot;, &quot;aeid&quot; or &quot;spid&quot;</p>
</td></tr>
<tr><td><code id="tcpldbStats_+3A_val">val</code></td>
<td>
<p>integer if type = &quot;aeid&quot; , string if type  = &quot;spid&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='tcplDefine'>Load data dictionary descriptions</h2><span id='topic+tcplDefine'></span>

<h3>Description</h3>

<p><code>tcplDefine</code> queries the tcpl databases and returns field descriptions 
from the data dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplDefine(val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplDefine_+3A_val">val</code></td>
<td>
<p>The values to query on. Can be any combination of table names
(to return all of its field descriptions) and field names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Short descriptions of fields for different tables are stored in a data
dictionary. Query by table name to retrieve descriptions of each field in
the given table, and/or query by field name to retrieve descriptions on
every field with the given name, regardless of which table they belong to.
</p>


<h3>Value</h3>

<p>A data.table with the data dictionary information for the given
parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConf(drvr = "example")

## Passing no parameters returns all of the fields described in the data
## dictionary
tcplDefine()

## Specifying table names of 'chemical' and 'sample' yields all of the
## fields from the 'chemical' and 'sample' tables
tcplDefine(c("chemical", "sample"))

## Specifying a field of 'wllt' yields all of the fields from any table that
## contains 'wllt' as a field
tcplDefine("wllt")

## Specifying a combination of table and field names results in all of the
## fields which are contained in the given tables and all of the given fields
## found in any table
tcplDefine(c("chemical", "spid", "wllt"))

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplDelete'>Delete rows from tcpl databases</h2><span id='topic+tcplDelete'></span>

<h3>Description</h3>

<p><code>tcplDelete</code> deletes rows from the given table and database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplDelete(tbl, fld, val, db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplDelete_+3A_tbl">tbl</code></td>
<td>
<p>Character, length 1, the table to delete from</p>
</td></tr>
<tr><td><code id="tcplDelete_+3A_fld">fld</code></td>
<td>
<p>Character, the field(s) to query on</p>
</td></tr>
<tr><td><code id="tcplDelete_+3A_val">val</code></td>
<td>
<p>List, vectors of values for each field to query on. Must be in 
the same order as 'fld'.</p>
</td></tr>
<tr><td><code id="tcplDelete_+3A_db">db</code></td>
<td>
<p>Character, the database containing the table</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is not exported and not intended to be used by the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplSendQuery">tcplSendQuery</a></code>
</p>

<hr>
<h2 id='tcplFit'>Fit the data with the constant, hill, and gain-loss models</h2><span id='topic+tcplFit'></span>

<h3>Description</h3>

<p><code>tcplFit</code> fits the constant, hill, and gain-loss models to the given data
and returns some summary statistics and the fit parameters in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplFit(
  logc,
  resp,
  bmad,
  force.fit = FALSE,
  bidirectional = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplFit_+3A_logc">logc</code></td>
<td>
<p>Numeric, log concentration values</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_resp">resp</code></td>
<td>
<p>Numeric, normalized response values</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_bmad">bmad</code></td>
<td>
<p>Numeric, the baseline median absolute deviation for the entire
assay</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_force.fit">force.fit</code></td>
<td>
<p>Logical, TRUE indicates to attempt fitting every
concentration series</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_bidirectional">bidirectional</code></td>
<td>
<p>Boolean If TRUE, bidirectional negative data before fitting (default=FALSE)
The original version of the code required the data to start at small
values and rise, so that negative curves had to be bidirectionalped outside
the function, and TOP was always positive. Setting bidirectional to TRUE
allows both rising and falling curves</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_verbose">verbose</code></td>
<td>
<p>Boolean If TRUE print warning messages</p>
</td></tr>
<tr><td><code id="tcplFit_+3A_...">...</code></td>
<td>
<p>Any other data to be included in list output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when at least one median value is greater than 3*bmad.
</p>


<h3>Value</h3>

<p>List of summary values and fit parameters for the given data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplObjCnst">tcplObjCnst</a></code>, <code><a href="#topic+tcplObjHill">tcplObjHill</a></code>,
<code><a href="#topic+tcplObjGnls">tcplObjGnls</a></code>, <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logc &lt;- 1:10
resp &lt;- sapply(1:10, tcplHillVal, ga = 5, tp = 50, gw = 0.5)
params &lt;- tcplFit(logc = logc, resp = resp, bmad = 10)
plot(resp ~ logc)
tcplAddModel(pars = params, modl = "hill")

</code></pre>

<hr>
<h2 id='tcplFit2'>tcpl Wrapper for tcplfit2_core including additional calculations to fit into new schema</h2><span id='topic+tcplFit2'></span>

<h3>Description</h3>

<p>tcpl Wrapper for tcplfit2_core including additional calculations to fit into new schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplFit2(
  dat,
  fitmodels = c("cnst", "hill", "gnls", "poly1", "poly2", "pow", "exp2", "exp3", "exp4",
    "exp5"),
  bmed = NULL,
  bidirectional = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplFit2_+3A_dat">dat</code></td>
<td>
<p>output from level 3 processing</p>
</td></tr>
<tr><td><code id="tcplFit2_+3A_fitmodels">fitmodels</code></td>
<td>
<p>list of the models that should be fit with the data</p>
</td></tr>
<tr><td><code id="tcplFit2_+3A_bmed">bmed</code></td>
<td>
<p>baseline value, typically should be 0</p>
</td></tr>
<tr><td><code id="tcplFit2_+3A_bidirectional">bidirectional</code></td>
<td>
<p>boolean, default is TRUE (bidirectional fitting)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.table with an additional column fitparams that includes all of the fitting parameters
</p>

<hr>
<h2 id='tcplFit2_nest'>Nest dataframe into a list that is readable by tcplfit2</h2><span id='topic+tcplFit2_nest'></span>

<h3>Description</h3>

<p>Nest dataframe into a list that is readable by tcplfit2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplFit2_nest(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplFit2_nest_+3A_dat">dat</code></td>
<td>
<p>a dataframe that has all of the fitting parameters in the style of tcplloaddata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of fitting parameters that can be consumed by tcplfit2
</p>

<hr>
<h2 id='tcplFit2_unnest'>Unnest tcplfit2 parameters into a dataframe</h2><span id='topic+tcplFit2_unnest'></span>

<h3>Description</h3>

<p>Unnest tcplfit2 parameters into a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplFit2_unnest(output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplFit2_unnest_+3A_output">output</code></td>
<td>
<p>list of output from tcplfit2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of parameters unnested and compiled into a dataframe
</p>

<hr>
<h2 id='tcplGetAeid'>get Aeid for endpoint name</h2><span id='topic+tcplGetAeid'></span>

<h3>Description</h3>

<p><code>tcplGetAeid</code> takes a string(name) and finds the assay component endpoint names that match the string and the 
aeids associated with those names.The function performs a regular expression like matching for strings in the 
assay component endpoint name column in the assay component endpoint table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplGetAeid(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplGetAeid_+3A_name">name</code></td>
<td>
<p>A string that will be matched to the assay component endpoint name</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples 
conf_store &lt;- tcplConfList()
tcplConfExample()

## Search for aenm (assay name) case insensitive
tcplGetAeid("TOX21")
tcplGetAeid("tox21")

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplggplot'>tcplggplot</h2><span id='topic+tcplggplot'></span>

<h3>Description</h3>

<p>tcplggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplggplot(dat, lvl = 5, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplggplot_+3A_dat">dat</code></td>
<td>
<p>data table with all required conc/resp data</p>
</td></tr>
<tr><td><code id="tcplggplot_+3A_lvl">lvl</code></td>
<td>
<p>integer level of data that should be plotted
level 4 - all fit models
level 5 - all fit models and winning model with hitcall
level 6 - include all flags</p>
</td></tr>
<tr><td><code id="tcplggplot_+3A_verbose">verbose</code></td>
<td>
<p>boolean should plotting include table of values next to the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object or grob with accompanied table depending on verbose option
</p>

<hr>
<h2 id='tcplHit2'>Hitcalling with tcplfit2</h2><span id='topic+tcplHit2'></span>

<h3>Description</h3>

<p>Hitcalling with tcplfit2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplHit2(mc4, coff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplHit2_+3A_mc4">mc4</code></td>
<td>
<p>data.table with level 4 data</p>
</td></tr>
<tr><td><code id="tcplHit2_+3A_coff">coff</code></td>
<td>
<p>cutoff value for hitcalling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.table with key value pairs of hitcalling parameters
</p>

<hr>
<h2 id='tcplListFlds'>Load the field names for a table</h2><span id='topic+tcplListFlds'></span>

<h3>Description</h3>

<p><code>tcplListFlds</code> loads the column names for the given table and database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplListFlds(tbl, db = getOption("TCPL_DB"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplListFlds_+3A_tbl">tbl</code></td>
<td>
<p>Character of length 1, the tcpl database table</p>
</td></tr>
<tr><td><code id="tcplListFlds_+3A_db">db</code></td>
<td>
<p>Character of length 1, the tcpl database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be particularly useful in defining the 'fld' param in the
tcplLoad- functions.
</p>


<h3>Value</h3>

<p>A string of field names for the given table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gives the fields in the mc1 table
tcplListFlds("mc1")

</code></pre>

<hr>
<h2 id='tcplLoadChem'>Load sample/chemical information</h2><span id='topic+tcplLoadChem'></span>

<h3>Description</h3>

<p><code>tcplLoadChem</code> queries the tcpl database and returns the chemical 
information for the given field and values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadChem(field = NULL, val = NULL, exact = TRUE, include.spid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLoadChem_+3A_field">field</code></td>
<td>
<p>Character of length 1, the field to query on</p>
</td></tr>
<tr><td><code id="tcplLoadChem_+3A_val">val</code></td>
<td>
<p>Vector of values to subset on</p>
</td></tr>
<tr><td><code id="tcplLoadChem_+3A_exact">exact</code></td>
<td>
<p>Logical, should chemical names be considered exact?</p>
</td></tr>
<tr><td><code id="tcplLoadChem_+3A_include.spid">include.spid</code></td>
<td>
<p>Logical, should spid be included?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'field' parameter is named differently from the 'fld' parameter seen
in other functions because it only takes one input.
</p>
<p>In the MySQL environment the user should be able to give partial
chemical name strings, to find chemicals with similar names. For example,
setting 'val' to &quot;phenol&quot; when 'field' is &quot;chnm&quot; and 'exact' is
<code>FALSE</code> might pull up the chemicals &quot;Bisphenol A&quot; and
&quot;4-Butylphenol&quot;. More technically, setting 'exact' to <code>FALSE</code> passes
the string in 'val' to an RLIKE statement within the MySQL query.
</p>


<h3>Value</h3>

<p>A data.table with the chemical information for the given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

## Passing no parameters gives all of the registered chemicals with their
## sample IDs
tcplLoadChem()

## Or the user can exclude spid and get a unique list of chemicals
tcplLoadChem(include.spid = FALSE)

## In addition, the user can retrieve only the registered chemicals from the chemical table
tcplLoadChem(field = 'chem.only')

## Other examples:
tcplLoadChem(field = "chnm", val = "Bisphenol A")
tcplLoadChem(field = "chid", val = 20182)

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplLoadClib'>Load chemical library information</h2><span id='topic+tcplLoadClib'></span>

<h3>Description</h3>

<p><code>tcplLoadClib</code> queries the tcpl databases and returns information 
about the chemical library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadClib(field = NULL, val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLoadClib_+3A_field">field</code></td>
<td>
<p>Character of length 1, <code>'chid'</code> or <code>'clib'</code>, whether 
to search by chemical id (chid), or chemical library (clib)</p>
</td></tr>
<tr><td><code id="tcplLoadClib_+3A_val">val</code></td>
<td>
<p>The values to query on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chemicals are stored in different libraries by chemical ID. Therefore, it 
is not possible to delineate samples with the same chemical ID into two 
distinct chemical libraries. However, it is possible for a chemical ID to 
belong to more than one (or no) chemical libraries. 
</p>
<p>When chemicals belong to more than one library, the chemical is listed 
multiple times (one for each distinct library).
</p>


<h3>Value</h3>

<p>A data.table with the chemical library information for the given
parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

## Passing no parameters gives all of the chemical ISs that have a chemical
## library registered
clib &lt;- tcplLoadClib()

## Notice there are more rows in tcplLoadClib than in tcplLoadChem, 
## indicating some chemicals must belong to more than library.
chem &lt;- tcplLoadChem(include.spid = FALSE)
nrow(chem)
nrow(clib)

## It is possible that some chemicals do not have a chemical library 
## registered, although this is not the case in the example data.
all(chem$chid %in% clib$chid)

## Show the unique chemical libraries
clib[ , unique(clib)]

## Specifying a chemical library will not show what other libraries a 
## chemical might belong to.
tcplLoadClib(field = "clib", val = "TOXCAST")
tcplLoadClib(field = "chid", val = 20182)

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplLoadConcUnit'>Load concentration units for assay endpoints</h2><span id='topic+tcplLoadConcUnit'></span>

<h3>Description</h3>

<p><code>tcplLoadUnit</code> queries the tcpl databases and returns a data.table
with the concentration units for the given assay endpoint ids (spid).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadConcUnit(spid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLoadConcUnit_+3A_spid">spid</code></td>
<td>
<p>Integer, assay endpoint ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing level 3 correction methods for the given
spids.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplQuery">tcplQuery</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>

<hr>
<h2 id='tcplLoadData'>Load tcpl data</h2><span id='topic+tcplLoadData'></span>

<h3>Description</h3>

<p><code>tcplLoadData</code> queries the tcpl databases and returns a data.table with
data for the given level and data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadData(lvl, fld = NULL, val = NULL, type = "mc", add.fld = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLoadData_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the level of data to load</p>
</td></tr>
<tr><td><code id="tcplLoadData_+3A_fld">fld</code></td>
<td>
<p>Character, the field(s) to query on</p>
</td></tr>
<tr><td><code id="tcplLoadData_+3A_val">val</code></td>
<td>
<p>List, vectors of values for each field to query on. Must be in
the same order as 'fld'.</p>
</td></tr>
<tr><td><code id="tcplLoadData_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
<tr><td><code id="tcplLoadData_+3A_add.fld">add.fld</code></td>
<td>
<p>Boolean if true we want to return 
the additional parameters fit with tcplfit2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data type can be either 'mc' for mutliple concentration data, or 'sc'
for single concentration data. Multiple concentration data will be loaded
into the 'mc' tables, whereas the single concentration will be loaded into
the 'sc' tables.
</p>
<p>Setting 'lvl' to &quot;agg&quot; will return an aggregate table containing the m4id
with the concentration-response data and m3id to map back to well-level
information.
</p>
<p>Leaving <code>fld</code> NULL will return all data.
</p>
<p>Valid <code>fld</code> inputs are based on the data level and type:
</p>

<table>
<tr>
 <td style="text-align: center;">
type </td><td style="text-align: center;"> lvl </td><td style="text-align: left;">  Queried tables </td>
</tr>
<tr>
 <td style="text-align: center;">
sc </td><td style="text-align: center;"> 0 </td><td style="text-align: left;"> sc0 </td>
</tr>
<tr>
 <td style="text-align: center;">
sc </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> sc0, sc1 </td>
</tr>
<tr>
 <td style="text-align: center;">
sc </td><td style="text-align: center;"> agg </td><td style="text-align: left;"> sc1, sc2_agg </td>
</tr>
<tr>
 <td style="text-align: center;">
sc </td><td style="text-align: center;"> 2 </td><td style="text-align: left;"> sc2 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 0 </td><td style="text-align: left;"> mc0 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> mc0, mc1 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 2 </td><td style="text-align: left;"> mc0, mc1, mc2 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 3 </td><td style="text-align: left;"> mc0, mc1, mc3 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> agg </td><td style="text-align: left;"> mc3, mc4_agg </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 4 </td><td style="text-align: left;"> mc4 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 5 </td><td style="text-align: left;"> mc4, mc5 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 6 </td><td style="text-align: left;"> mc4, mc6 </td>
</tr>
<tr>
 <td style="text-align: center;">
mc </td><td style="text-align: center;"> 7 </td><td style="text-align: left;"> mc4, mc7
</td>
</tr>

</table>



<h3>Value</h3>

<p>A data.table containing data for the given fields.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplQuery">tcplQuery</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

## Load all of level 0 for multiple-concentration data, note 'mc' is the
## default value for type
tcplLoadData(lvl = 0)

## Load all of level 1 for single-concentration
tcplLoadData(lvl = 1, type = "sc")

## List the fields available for level 1, coming from tables mc0 and mc1
tcplListFlds(tbl = "mc0")
tcplListFlds(tbl = "mc1")

## Load level 0 data where the well type is "t" and the concentration
## index is 3 or 4
tcplLoadData(lvl = 1, fld = c("wllt", "cndx"), val = list("t", c(3:4)))

## Reset configuration
options(conf_store)
</code></pre>

<hr>
<h2 id='tcplLoadUnit'>Load response units for assay endpoints</h2><span id='topic+tcplLoadUnit'></span>

<h3>Description</h3>

<p><code>tcplLoadUnit</code> queries the tcpl databases and returns a data.table
with the response units for the given assay endpoint ids (aeid).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLoadUnit(aeid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLoadUnit_+3A_aeid">aeid</code></td>
<td>
<p>Integer, assay endpoint ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing level 3 correction methods for the given
aeids.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplQuery">tcplQuery</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>

<hr>
<h2 id='tcplLvlCount'>Load tcpl level counts</h2><span id='topic+tcplLvlCount'></span>

<h3>Description</h3>

<p><code>tcplLvlCount</code> queries the tcpl databases and returns a data frame with
count totals for the given levels and data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplLvlCount(lvls = NULL, type = "mc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplLvlCount_+3A_lvls">lvls</code></td>
<td>
<p>Integer or list of Integers, The levels of data to load</p>
</td></tr>
<tr><td><code id="tcplLvlCount_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data type can be either 'mc' for mutliple concentration data, or 'sc'
for single concentration data.
</p>
<p>Leaving <code>lvls</code> NULL will return all data.
</p>


<h3>Value</h3>

<p>A data.table containing data for the given fields.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplQuery">tcplQuery</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
TCPLlite &lt;- file.path(system.file(package = "tcpl"), "example")
tcplConf(db = TCPLlite, user = NA, host = NA, drvr = "tcplLite")
 
## Get all counts for level 1 for multiple-concentration
tcplLvlCount(lvls = 1)

## Not run: 
## Get all counts for levels 4 through 7 for multiple-concentration
tcplLvlCount(lvls = 4:7)

## Get all counts for multiple-concentration data, note 'mc' is the 
## default value for type
tcplLvlCount()

## End(Not run)

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplMakeAeidMultiPlts'>Create a .pdf with all dose-response plots for a given aeid, 6 per page</h2><span id='topic+tcplMakeAeidMultiPlts'></span>

<h3>Description</h3>

<p><code>tcplMakeAeidMultiPlts</code> Create a .pdf with all dose-response plots for a given aeid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplMakeAeidMultiPlts(
  aeid,
  lvl = 4L,
  fname = NULL,
  odir = getwd(),
  clib = NULL,
  hitc.all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_aeid">aeid</code></td>
<td>
<p>Integer of length 1, the assay endpoint id</p>
</td></tr>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the data level to use (4-7)</p>
</td></tr>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_fname">fname</code></td>
<td>
<p>Character, the filename</p>
</td></tr>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_odir">odir</code></td>
<td>
<p>The directory to save the .pdf file in</p>
</td></tr>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_clib">clib</code></td>
<td>
<p>Character, the chemical library to subset on, see 
<code><a href="#topic+tcplLoadClib">tcplLoadClib</a></code> for more information.</p>
</td></tr>
<tr><td><code id="tcplMakeAeidMultiPlts_+3A_hitc.all">hitc.all</code></td>
<td>
<p>If FALSE, only plots with hitc==1 will be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplMakeAeidMultiPlts</code> provides a wrapper for <code><a href="#topic+tcplMultiplot">tcplMultiplot</a></code>,
allowing the user to produce PDFs with the curve plots without having to 
separately load all of the data and establish the PDF device.
</p>
<p>If 'fname' is <code>NULL</code>, a default name is given by concatenating together
assay information.
</p>

<hr>
<h2 id='tcplMakeAeidPlts'>Create a .pdf with dose-response plots</h2><span id='topic+tcplMakeAeidPlts'></span>

<h3>Description</h3>

<p><code>tcplMakeAeidPlts</code> creates a .pdf file with the dose-response plots for 
the given aeid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplMakeAeidPlts(
  aeid,
  compare = F,
  lvl = 4L,
  fname = NULL,
  odir = getwd(),
  ordr.fitc = TRUE,
  clib = NULL,
  cnst = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplMakeAeidPlts_+3A_aeid">aeid</code></td>
<td>
<p>Integer of length 1 or 2, the assay endpoint id</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_compare">compare</code></td>
<td>
<p>Boolean to for comparison of aeids if length(aeid)&gt;1</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the data level to use (4-7). Only level 5-6 valid for compare aeids.</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_fname">fname</code></td>
<td>
<p>Character, the filename</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_odir">odir</code></td>
<td>
<p>The directory to save the .pdf file in</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_ordr.fitc">ordr.fitc</code></td>
<td>
<p>Logical, should the fits be ordered by fit category?</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_clib">clib</code></td>
<td>
<p>Character, the chemical library to subset on, see</p>
</td></tr>
<tr><td><code id="tcplMakeAeidPlts_+3A_cnst">cnst</code></td>
<td>
<p>Constant hline to draw on plot
<code><a href="#topic+tcplLoadClib">tcplLoadClib</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplMakeAeidPlts</code> provides a wrapper for <code><a href="#topic+tcplPlotFits">tcplPlotFits</a></code>,
allowing the user to produce PDFs with the curve plots without having to 
separately load all of the data and establish the PDF device.
</p>
<p>If 'fname' is <code>NULL</code>, a default name is given by concatenating together
assay information. 
</p>
<p>Note, the default value for ordr.fitc is <code>TRUE</code> in 
<code>tcplMakeAeidPlts</code>, but <code>FALSE</code> in <code>tcplPlotFits</code>
</p>
<p>Note, only level 5 or level 6 is valid for comparing 2 aeids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Will produce the same result as the example for tcplPlotFits
tcplMakeAeidPlts(aeid = 1, lvl = 6, ordr.fitc = FALSE)

## End(Not run)

## Not run: 
## Compare two aeids on same plots
tcplMakeAeidPlts(aeid = c(1,2), compare=T, lvl = 6)

## End(Not run)

</code></pre>

<hr>
<h2 id='tcplMakeChidMultiPlts'>Create a .pdf with all dose-response plots for a given chid, 6 per page</h2><span id='topic+tcplMakeChidMultiPlts'></span>

<h3>Description</h3>

<p><code>tcplMakeChidMultiPlts</code> Create a .pdf with all dose-response plots for a given chid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplMakeChidMultiPlts(
  chid,
  lvl = 4L,
  fname = NULL,
  odir = getwd(),
  clib = NULL,
  hitc.all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_chid">chid</code></td>
<td>
<p>Integer of length 1, the chemical id</p>
</td></tr>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the data level to use (4-7)</p>
</td></tr>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_fname">fname</code></td>
<td>
<p>Character, the filename</p>
</td></tr>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_odir">odir</code></td>
<td>
<p>The directory to save the .pdf file in</p>
</td></tr>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_clib">clib</code></td>
<td>
<p>Character, the chemical library to subset on, see 
<code><a href="#topic+tcplLoadClib">tcplLoadClib</a></code> for more information.</p>
</td></tr>
<tr><td><code id="tcplMakeChidMultiPlts_+3A_hitc.all">hitc.all</code></td>
<td>
<p>If FALSE, only plots with hitc==1 will be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplMakeChidMultiPlts</code> provides a wrapper for <code><a href="#topic+tcplMultiplot">tcplMultiplot</a></code>,
allowing the user to produce PDFs with the curve plots without having to 
separately load all of the data and establish the PDF device.
</p>
<p>If 'fname' is <code>NULL</code>, a default name is given by concatenating together
assay information.
</p>

<hr>
<h2 id='tcplMultiplot'>Plot summary fits based on fit and dose-response data</h2><span id='topic+tcplMultiplot'></span>

<h3>Description</h3>

<p><code>tcplMultiplot</code> takes the dose-response and fit data and produces
summary plot figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplMultiplot(dat, agg, flg = NULL, boot = NULL, browse = FALSE, hitc.all)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplMultiplot_+3A_dat">dat</code></td>
<td>
<p>data.table, level 4 or level 5 data, see details.</p>
</td></tr>
<tr><td><code id="tcplMultiplot_+3A_agg">agg</code></td>
<td>
<p>data.table, concentration-response aggregate data, see details.</p>
</td></tr>
<tr><td><code id="tcplMultiplot_+3A_flg">flg</code></td>
<td>
<p>data.table, level 6 data, see details.</p>
</td></tr>
<tr><td><code id="tcplMultiplot_+3A_boot">boot</code></td>
<td>
<p>data.table, level 7 data, see details.</p>
</td></tr>
<tr><td><code id="tcplMultiplot_+3A_browse">browse</code></td>
<td>
<p>Logical, should <code>browser()</code> be called after every plot?</p>
</td></tr>
<tr><td><code id="tcplMultiplot_+3A_hitc.all">hitc.all</code></td>
<td>
<p>Logical, if FALSE, only plots with hitc==1 will be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data for 'dat', 'agg', and 'flg' should be loaded using the 
<code><a href="#topic+tcplLoadData">tcplLoadData</a></code> function with the appropriate 'lvl' parameter.
See help page for <code>tcplLoadData</code> for more information.
</p>
<p>If dat contains only one aeid, plots will be ordered by chemical name (chnm). 
Otherwise, plots are ordered by assay endpoint name (aenm).
## While it is most likely the user will want to just save all of the plots 
## to view in a PDF, the 'browse' parameter can be used to quickly view 
## some plots.
</p>

<hr>
<h2 id='tcplPlot'>#&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
Generic Plotting Function for tcpl</h2><span id='topic+tcplPlot'></span>

<h3>Description</h3>

<p><code>tcplLoadData</code> queries the tcpl databases and returns a plot
for the given level and data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlot(
  lvl = 5,
  fld = "m4id",
  val = NULL,
  type = "mc",
  by = NULL,
  output = c("console", "pdf", "png", "jpg", "svg", "tiff"),
  fileprefix = paste0("tcplPlot_", Sys.Date()),
  multi = NULL,
  verbose = FALSE,
  nrow = NULL,
  ncol = NULL,
  dpi = 600
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlot_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the level of data to load.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_fld">fld</code></td>
<td>
<p>Character, the field(s) to query on.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_val">val</code></td>
<td>
<p>List, vectors of values for each field to query on. Must be in
the same order as 'fld'.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_by">by</code></td>
<td>
<p>Parameter to divide files into e.g. &quot;aeid&quot;.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_output">output</code></td>
<td>
<p>How should the plot be presented. To view the plot in application,
use &quot;console&quot;, or to save as a file type, use &quot;pdf&quot;, &quot;jpg&quot;, &quot;png&quot;, &quot;svg&quot;, or &quot;tiff&quot;.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_fileprefix">fileprefix</code></td>
<td>
<p>Prefix of file when saving.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_multi">multi</code></td>
<td>
<p>Boolean, by default TRUE for &quot;pdf&quot;. If multi is TRUE, output
by  default 4 plots per page for 'verbose' = TRUE and 6 plots per page for
'verbose' = FALSE.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, by default FALSE. If TRUE, a table with fitting parameters
is included with the plot.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_nrow">nrow</code></td>
<td>
<p>Integer, number of rows in multiplot. By default 2.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_ncol">ncol</code></td>
<td>
<p>Integer, number of columns in multiplot. By default 3, 2 if verbose.</p>
</td></tr>
<tr><td><code id="tcplPlot_+3A_dpi">dpi</code></td>
<td>
<p>Integer, image print resolution. By default 600.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data type can be either 'mc' for mutliple concentration data, or 'sc'
for single concentration data. Multiple concentration data will be loaded
into the 'mc' tables, whereas the single concentration will be loaded into
the 'sc' tables.
</p>
<p>Setting 'lvl' to &quot;agg&quot; will return an aggregate table containing the m4id
with the concentration-response data and m3id to map back to well-level
information.
</p>
<p>Leaving <code>fld</code> NULL will return all data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

tcplPlot(lvl = 4, fld = "m4id", val = c(18609966)) ## Create a level 4 plot

## Reset configuration
options(conf_store)
</code></pre>

<hr>
<h2 id='tcplPlotFitc'>Plot the fit category tree</h2><span id='topic+tcplPlotFitc'></span>

<h3>Description</h3>

<p><code>tcplPlotFitc</code> makes a plot showing the level 5 fit categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlotFitc(fitc = NULL, main = NULL, fitc_sub = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlotFitc_+3A_fitc">fitc</code></td>
<td>
<p>Integer, the fit categories</p>
</td></tr>
<tr><td><code id="tcplPlotFitc_+3A_main">main</code></td>
<td>
<p>Character of length 1, the title (optional)</p>
</td></tr>
<tr><td><code id="tcplPlotFitc_+3A_fitc_sub">fitc_sub</code></td>
<td>
<p>Integer, a subset of fit categories to plot</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Suggested device size (inches): width = 10, height = 7.5, pointsize = 9
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Plot visualization of fit categories for all level 5 data
tcplPlotFitc(fitc = tcplLoadData(5)$fitc)

## End(Not run)

</code></pre>

<hr>
<h2 id='tcplPlotFits'>Plot summary fits based on fit and dose-response data</h2><span id='topic+tcplPlotFits'></span>

<h3>Description</h3>

<p><code>tcplPlotFits</code> takes the dose-response and fit data and produces
summary plot figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlotFits(
  dat,
  agg,
  flg = NULL,
  boot = NULL,
  ordr.fitc = FALSE,
  browse = FALSE,
  cnst = NULL,
  orig.aeid = NULL,
  compare = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlotFits_+3A_dat">dat</code></td>
<td>
<p>data.table, level 4 or level 5 data, see details.</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_agg">agg</code></td>
<td>
<p>data.table, concentration-response aggregate data, see details.</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_flg">flg</code></td>
<td>
<p>data.table, level 6 data, see details.</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_boot">boot</code></td>
<td>
<p>data.table, level 7 data, see details.</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_ordr.fitc">ordr.fitc</code></td>
<td>
<p>Logical, should the fits be ordered by fit category?</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_browse">browse</code></td>
<td>
<p>Logical, should <code>browser()</code> be called after every plot?</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_cnst">cnst</code></td>
<td>
<p>Constant hline to draw on plot</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_orig.aeid">orig.aeid</code></td>
<td>
<p>Original aeid list from tcplMakeAeidPlts to maintain order</p>
</td></tr>
<tr><td><code id="tcplPlotFits_+3A_compare">compare</code></td>
<td>
<p>boolean to determine if aeids should be compared on same plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data for 'dat', 'agg', and 'flg' should be loaded using the 
<code><a href="#topic+tcplLoadData">tcplLoadData</a></code> function with the appropriate 'lvl' parameter.
See help page for <code>tcplLoadData</code> for more information.
</p>
<p>Supplying level 4 data for the 'dat' parameter will result in level 4 plots. 
Similarly, supp
</p>
<p>If fits are not ordered by fit category, they will be ordered by chemical 
ID. Inputs with multiple assay endpoints will first be ordered by assay 
endpoint ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfDefault()

## tcplPlotFits needs data.tables supplying the concentration/response
## data stored in mc4_agg, as well as the fit information from mc4 or mc5.
## Additionally, tcplPlotFits can take level 6 data from mc6 and add the
## flag information to the plots. The following shows how to make level 5
## plots. Adding the 'flg' parameter would result in level 6 plots, and 
## loading level 4, rather than level 5 data, would result in level 4 plots.
 
l5 &lt;- tcplLoadData(lvl = 5, fld = "m4id", val = 18609966)
l4_agg &lt;- tcplLoadData(lvl = "agg", fld = "m4id", val = 18609966)

## Not run: 
pdf(file = "tcplPlotFits.pdf", height = 6, width = 10, pointsize = 10)
tcplPlotFits(dat = l5, agg = l4_agg)
graphics.off()

## End(Not run)

## While it is most likely the user will want to just save all of the plots 
## to view in a PDF, the 'browse' parameter can be used to quickly view 
## some plots. 

## Start by identifying some sample IDs to plot, then call tcplPlotFits with
## a subset of the data. This browse function is admittedly clunky. 
bpa &lt;- tcplLoadChem(field = "chnm", val = "Bisphenol A")[ , spid]
l5_sub &lt;- l5[spid %in% bpa] 
## Not run: 
tcplPlotFits(dat = l5_sub, 
             agg = l4_agg[m4id %in% l5_sub$m4id], 
             browse = TRUE)

## End(Not run)

## Reset configuration
options(conf_store)
 
</code></pre>

<hr>
<h2 id='tcplPlotlyPlot'>tcplPlotlyPlot</h2><span id='topic+tcplPlotlyPlot'></span>

<h3>Description</h3>

<p>tcplPlotlyPlot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlotlyPlot(dat, lvl = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlotlyPlot_+3A_dat">dat</code></td>
<td>
<p>data table with all required conc/resp data</p>
</td></tr>
<tr><td><code id="tcplPlotlyPlot_+3A_lvl">lvl</code></td>
<td>
<p>integer level of data that should be plotted
level 4 - all fit models
level 5 - all fit models and winning model with hitcall
level 6 - include all flags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly plot
</p>

<hr>
<h2 id='tcplPlotM4ID'>Plot fit summary plot by m4id</h2><span id='topic+tcplPlotM4ID'></span>

<h3>Description</h3>

<p><code>tcplPlotM4ID</code> creates a summary plots for the given m4id(s) by loading
the appropriate data from the tcpl databases and sending it to 
<code><a href="#topic+tcplPlotFits">tcplPlotFits</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlotM4ID(m4id, lvl = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlotM4ID_+3A_m4id">m4id</code></td>
<td>
<p>Integer, m4id(s) to plot</p>
</td></tr>
<tr><td><code id="tcplPlotM4ID_+3A_lvl">lvl</code></td>
<td>
<p>Integer, the level of data to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A level 4 plot ('lvl' = 4) will plot the concentration series and the 
applicable curves, without an indication of the activity call or the 
winning model. Level 4 plots can be created without having done subsequent
processing.
</p>
<p>Level 5 plots include the level 4 information with the activity call and 
model selection. The winning model will be highlighted red in the side panel
containing the summary statistics. Level 6 plots, in addition the all of the 
level 4 and 5 information, include the positive flag IDs. If the flag has 
an associated value, the value will be in parentheses following the flag ID.
Level 7 plots in addition to all of the level 4, 5, and 6 information, include
the AC50 confidence interval and hit percentage information from bootstrapping.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplPlotFits">tcplPlotFits</a></code>, <code><a href="#topic+tcplMakeAeidPlts">tcplMakeAeidPlts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

tcplPlotM4ID(m4id = 18609966, lvl = 4) ## Create a level 4 plot
tcplPlotM4ID(m4id = 18609966, lvl = 5) ## Create a level 5 plot
tcplPlotM4ID(m4id = 18609966, lvl = 6) ## Create a level 6 plot

#' ## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplPlotPlate'>Plot plate heatmap</h2><span id='topic+tcplPlotPlate'></span>

<h3>Description</h3>

<p><code>tcplPlotPlate</code> generates a heatmap of assay plate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPlotPlate(dat, apid, id = NULL, quant = c(0.001, 0.999))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPlotPlate_+3A_dat">dat</code></td>
<td>
<p>data.table containing tcpl data</p>
</td></tr>
<tr><td><code id="tcplPlotPlate_+3A_apid">apid</code></td>
<td>
<p>Character of length 1, the apid to plot</p>
</td></tr>
<tr><td><code id="tcplPlotPlate_+3A_id">id</code></td>
<td>
<p>Integer of length 1, the assay component id (acid) or assay
endpoint id (aeid), depending on level. Only need to specify for multiplexed
assays when more than one acid/aeid share an apid.</p>
</td></tr>
<tr><td><code id="tcplPlotPlate_+3A_quant">quant</code></td>
<td>
<p>Numeric vector, the range of data to include in the legend</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The legend represents the range of the data supplied to dat, for the 
applicable ID. The additional horizontal lines on the legend indicate the
range of the plotted plate, to show the relation of the plate to the assay
as a whole. A plot with a legend specific for the given apid can be created
by only supplying the data for the apid of interest to 'dat'.
</p>
<p>The quant parameter, by default including 99.8
allows for extreme outliers without losing resolution. Outliers in either
direction will be highlighted with a dark ring, as seen in the example. 
A NULL value for 'quant' will not restrict the data at all, and will use 
the full range for the legend. 
</p>
<p>Wells with a well quality of 0 (only applicable for level 1 plots), will 
have an &quot;X&quot; through their center.
</p>


<h3>Note</h3>

<p>For the optimal output size, use width = 10, height = 10*(2/3), 
pointsize = 10, units = &quot;in&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfDefault()
 
d1 &lt;- tcplLoadData(lvl = 1, fld = "acid", val = 1)
## Not run: 
tcplPlotPlate(dat = d1, apid = "09Apr2014.Plate.17")

## End(Not run)

## Reset configuration
options(conf_store)
 
</code></pre>

<hr>
<h2 id='tcplPrepOtpt'>Map assay/chemical ID values to annotation information</h2><span id='topic+tcplPrepOtpt'></span>

<h3>Description</h3>

<p><code>tcplPrepOtpt</code> queries the chemical and assay information from the tcpl
database, and maps the annotation information to the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplPrepOtpt(dat, ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplPrepOtpt_+3A_dat">dat</code></td>
<td>
<p>data.table, output from <code><a href="#topic+tcplLoadData">tcplLoadData</a></code></p>
</td></tr>
<tr><td><code id="tcplPrepOtpt_+3A_ids">ids</code></td>
<td>
<p>Character, (optional) a subset of ID fields to map</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplPrepOtpt</code> is used to map chemical and assay identifiers to their
respective names and annotation information to create a human-readable table
that is more suitable for an export/output.
</p>
<p>By default the function will map sample ID (spid), assay component id (acid),
and assay endpoint ID (aeid) values. However, if 'ids' is not null, the 
function will only attempt to map the ID fields given by 'ids.'
</p>


<h3>Value</h3>

<p>The given data.table with chemical and assay information mapped
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

## Load some example data
d1 &lt;- tcplLoadData(1)

## Check for chemical name in 'dat'
"chnm" %in% names(d1) ## FALSE

#' ## Map all annotations 
d2 &lt;- tcplPrepOtpt(d1) ##
"chnm" %in% names(d2) ## TRUE
"acnm" %in% names(d2) ## TRUE
 
## Map chemical annotation only
d3 &lt;- tcplPrepOtpt(d1, ids = "spid")
"chnm" %in% names(d3) ## TRUE
"acnm" %in% names(d3) ## FALSE

## Reset configuration
options(conf_store)


</code></pre>

<hr>
<h2 id='tcplRun'>Perform data processing</h2><span id='topic+tcplRun'></span>

<h3>Description</h3>

<p><code>tcplRun</code> is the function for performing the data processing, for both
single-concentration and multiple-concentration formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplRun(
  asid = NULL,
  slvl,
  elvl,
  id = NULL,
  type = "mc",
  mc.cores = NULL,
  outfile = NULL,
  runname = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplRun_+3A_asid">asid</code></td>
<td>
<p>Integer, assay source id</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_slvl">slvl</code></td>
<td>
<p>Integer of length 1, the starting level to process</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_elvl">elvl</code></td>
<td>
<p>Integer of length 1, the ending level to process</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_id">id</code></td>
<td>
<p>Integer, rather than assay source id, the specific assay 
component or assay endpoint id(s) (optional)</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Integer of length 1, the number of cores to use, set to 1 
when using Windows operating system</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_outfile">outfile</code></td>
<td>
<p>Character of length 1, the name of the log file (optional)</p>
</td></tr>
<tr><td><code id="tcplRun_+3A_runname">runname</code></td>
<td>
<p>Character of length 1, the name of the run to be used in the 
outfile (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tcplRun</code> function is the core processing function within the 
package. The function acts as a wrapper for individual processing functions, 
(ie. <code>mc1</code>, <code>sc1</code>, etc.) that are not exported. If possible, the
processing is done in parallel by 'id' by utilizing the 
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> function within the parallel package. 
</p>
<p>If slvl is less than 4, 'id' is interpreted as acid and if slvl is 4 or 
greater 'id' is interpreted as aeid. Must give either 'asid' or 'id'. If an 
id fails no results get loaded into the database, and the id does not get 
placed into the cue for subsequent level processing.
</p>
<p>The 'type' parameter specifies what type of processing to complete: &quot;mc&quot; for
multiple-concentration processing, and &quot;sc&quot; for single-concentration 
processing.
</p>


<h3>Value</h3>

<p>A list containing the results from each level of processing. Each 
level processed will return a named logical vector, indicating the success 
of the processing for the id.
</p>

<hr>
<h2 id='tcplSubsetChid'>Subset level 5 data to a single sample per chemical</h2><span id='topic+tcplSubsetChid'></span>

<h3>Description</h3>

<p><code>tcplSubsetChid</code> subsets level 5 data to a single tested sample per
chemical. In other words, if a chemical is tested more than once (a chid
has more than one spid) for a given assay endpoint, the function uses a
series of logic to select a single &quot;representative&quot; sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplSubsetChid(dat, flag = TRUE, type = "mc", export_ready = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplSubsetChid_+3A_dat">dat</code></td>
<td>
<p>data.table, a data.table with level 5 data</p>
</td></tr>
<tr><td><code id="tcplSubsetChid_+3A_flag">flag</code></td>
<td>
<p>Integer, the mc6_mthd_id values to go into the flag count, see
details for more information</p>
</td></tr>
<tr><td><code id="tcplSubsetChid_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
<tr><td><code id="tcplSubsetChid_+3A_export_ready">export_ready</code></td>
<td>
<p>Boolean, default TRUE, should only export ready 1 values be included in calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tcplSubsetChid</code> is intended to work with level 5 data that has
chemical and assay information mapped with <code><a href="#topic+tcplPrepOtpt">tcplPrepOtpt</a></code>.
</p>
<p>To select a single sample, first a &quot;consensus hit-call&quot; is made by majority
rule, with ties defaulting to active. After the chemical-wise hit call is
made, the samples corresponding to to chemical-wise hit call are logically
ordered using the fit category, the number of the flags, and the modl_ga,
then the first sample for every chemical is selected.
</p>
<p>The <code>flag</code> param can be used to specify a subset of flags to be used in
the flag count. Leaving <code>flag</code> TRUE utilize all the available flags.
Setting <code>flag</code> to <code>FALSE</code> will do the subsetting without
considering any flags.
</p>


<h3>Value</h3>

<p>A data.table with a single sample for every given chemical-assay
pair.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplPrepOtpt">tcplPrepOtpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end
## of the examples
conf_store &lt;- tcplConfList()
tcplConfExample()

## Load the example level 5 data
d1 &lt;- tcplLoadData(lvl = 5, fld = "aeid", val = 797)
d1 &lt;- tcplPrepOtpt(d1)

## Subset to an example of a duplicated chid
d2 &lt;- d1[chid == 20182]
d2[, list(m4id, hitc, fitc, modl_ga)]

## Here the consensus hit-call is 1 (active), and the fit categories are
## all equal. Therefore, if the flags are ignored, the selected sample will
## be the sample with the lowest modl_ga.
tcplSubsetChid(dat = d2, flag = FALSE)[, list(m4id, modl_ga)]

## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplVarMat'>Create chemical by assay matrices</h2><span id='topic+tcplVarMat'></span>

<h3>Description</h3>

<p><code>tcplVarMat</code> creates chemical by assay matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplVarMat(
  chid = NULL,
  aeid = NULL,
  add.vars = NULL,
  row.id = "code",
  flag = TRUE,
  cyto.pars = list(),
  include.na.chid = FALSE,
  odir = NULL,
  file.prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplVarMat_+3A_chid">chid</code></td>
<td>
<p>Integer, chemical ID values to subset on</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_aeid">aeid</code></td>
<td>
<p>Integer, assay endpoint ID values to subset on</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_add.vars">add.vars</code></td>
<td>
<p>Character, mc4 or mc5 field(s) not included in the standard
list to add additional matrices</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_row.id">row.id</code></td>
<td>
<p>Character, the chemical identifier to use in the output</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_flag">flag</code></td>
<td>
<p>Integer or Logical of length 1, passed to 
<code><a href="#topic+tcplSubsetChid">tcplSubsetChid</a></code></p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_cyto.pars">cyto.pars</code></td>
<td>
<p>List, named list of arguments passed to 
<code><a href="#topic+tcplCytoPt">tcplCytoPt</a></code></p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_include.na.chid">include.na.chid</code></td>
<td>
<p>Logical of length 1, whether to include the chemicals
not listed in the tcpl databases (ie. controls)</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_odir">odir</code></td>
<td>
<p>Directory to write comma separated file(s)</p>
</td></tr>
<tr><td><code id="tcplVarMat_+3A_file.prefix">file.prefix</code></td>
<td>
<p>Character of length 1, prefix to the file name when odir
is not NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tcplVarMat</code> function is used to create chemical by assay matrices
for different parameters. The standard list of matrices returned includes:
</p>

<ol>
<li><p> &quot;modl_ga&quot; &ndash; The logAC50 (in the gain direction) for the winning 
model. 
</p>
</li>
<li><p> &quot;hitc&quot; &ndash; The hit-call for the winning model.
</p>
</li>
<li><p> &quot;m4id&quot; &ndash; The m4id, listing the concentration series selected by 
<code>tcplSubsetChid</code>.
</p>
</li>
<li><p> &quot;zscore&quot; &ndash; The z-score based on the output from <code>tcplCytoPt</code>. 
The formula used for calculating the z-score is 
<code class="reqn">-(\mathit{modl\_ga} - \mathit{cyto\_pt})/\mathit{global\_mad}</code>
</p>
</li>
<li><p> &quot;tested&quot; &ndash; 1 or 0, 1 indicating the chemical/assay pair
was tested in either the single- or multiple-concentration format
</p>
</li>
<li><p> &quot;tested_sc&quot; &ndash; 1 or 0, 1 indicating the chemical/assay pair
was tested in the single-concentration format
</p>
</li>
<li><p> &quot;tested_mc&quot; &ndash; 1 or 0, 1 indicating the chemical/assay pair
was tested in the multiple-concentration format
</p>
</li>
<li><p> &quot;ac50&quot; &ndash; a modified AC50 table (in non-log units) where 
assay/chemical pairs that were not tested, or tested and had a hitcall of 0
or -1 have the value 1e6. 
</p>
</li>
<li><p> &quot;neglogac50&quot; &ndash; -log(AC50/1e6) where assay/chemical pairs that were 
not tested, or tested and had a hitcall of 0 or -1 have the value 0. 
</p>
</li></ol>

<p>To add additional matrices, the 'add.vars' parameter can be used to specify
the fields from the mc4 or mc5 tables to create matrices for.
</p>
<p>When more than one sample is included for a chemical/assay pair, 
<code>tcplVarMat</code> aggregates multiple samples to a chemical level call 
utilizing <code><a href="#topic+tcplSubsetChid">tcplSubsetChid</a></code>. 
</p>
<p>By setting <code>odir</code> the function will write out a csv with, naming the 
file with the convention: &quot;var_Matrix_date.csv&quot; where 'var' is the name 
of the matrix. A prefix can be added to the output files using the 
'file.prefix' parameter. 
</p>
<p>When a concentration series has a sample id not listed in the <code>tcpl</code> 
database, and 'include.na.chid' is TRUE, the rowname for that series will 
be the concatenation of &quot;SPID_&quot; and the spid. Note, if the user gives a 
subset of chid values to the 'chid' parameter, 'include.na.chid' will be 
set to FALSE with a warning.
</p>
<p>The tcplVarMat function calls both <code>tcplSubsetChid</code> and 
<code>tcplCytoPt</code> (which separately calls <code>tcplSubsetChid</code>). The input
for the <code>tcplVarMat</code> 'flag' parameter is passed to the 
<code>tcplSubsetChid</code> call used to parse down the data to create the 
matrices. The <code>tcplSubsetChid</code> called within <code>tcplCytoPt</code> (to 
parse down the cytotoxicity data used to define the &quot;zscore&quot; matrix) can 
be modified by passing a separate 'flag' element in the list defined by the 
'cyto.pars' parameter.
</p>


<h3>Value</h3>

<p>A list of chemical by assay matrices where the rownames are given by
the 'row.id' parameter, and the colnames are given by assay endpoint name 
(aenm).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplSubsetChid">tcplSubsetChid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Store the current config settings, so they can be reloaded at the end 
## of the examples
conf_store &lt;- tcplConfList()
TCPLlite &lt;- file.path(system.file(package = "tcpl"), "example")
tcplConf(db = TCPLlite, user = NA, host = NA, drvr = "tcplLite")
## Not run: 
## Demonstrate the returned values. Note with no "burst" assays defined in
## the example database, the user must provide which aeid values to use 
## in calculating the cytotoxicity distributions for the 'zscore' matrix.
tcplVarMat(chid = 1:5, cyto.pars = list(aeid = 1:2))

## Other changes can be made
tcplVarMat(chid = 1:5, row.id = "chnm", cyto.pars = list(aeid = 1:2))
tcplVarMat(chid = 1:5, add.vars = "max_med", cyto.pars = list(aeid = 1:2))

## End(Not run)
## Reset configuration
options(conf_store)

</code></pre>

<hr>
<h2 id='tcplWriteData'>Write screening data into the tcpl databases</h2><span id='topic+tcplWriteData'></span>

<h3>Description</h3>

<p><code>tcplWriteData</code> takes a data.table with screening data and writes the
data into the given level table in the tcpl databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplWriteData(dat, lvl, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplWriteData_+3A_dat">dat</code></td>
<td>
<p>data.table, the screening data to load</p>
</td></tr>
<tr><td><code id="tcplWriteData_+3A_lvl">lvl</code></td>
<td>
<p>Integer of length 1, the data processing level</p>
</td></tr>
<tr><td><code id="tcplWriteData_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends data onto the existing table. It also deletes all the
data for any acids or aeids dat contains from the given and all downstream
tables.
</p>
<p>The data type can be either 'mc' for mutliple concentration data, or 'sc'
for single concentration data. Multiple concentration data will be loaded
into the level tables, whereas the single concentration will be loaded into
the single tables.
</p>


<h3>Note</h3>

<p>This function is not exported and is not intended to be used by the user.
The user should only write level 0 data, which is written with
<code><a href="#topic+tcplWriteLvl0">tcplWriteLvl0</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplCascade">tcplCascade</a></code>, <code><a href="#topic+tcplAppend">tcplAppend</a></code>,
<code><a href="#topic+tcplWriteLvl0">tcplWriteLvl0</a></code>
</p>

<hr>
<h2 id='tcplWriteLvl0'>Write level 0 screening data into the tcpl databases</h2><span id='topic+tcplWriteLvl0'></span>

<h3>Description</h3>

<p><code>tcplWriteLvl0</code> takes a data.table with level 0 screening data and 
writes the data into the level 0 tables in the tcpl databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplWriteLvl0(dat, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplWriteLvl0_+3A_dat">dat</code></td>
<td>
<p>data.table, the screening data to load</p>
</td></tr>
<tr><td><code id="tcplWriteLvl0_+3A_type">type</code></td>
<td>
<p>Character of length 1, the data type, &quot;sc&quot; or &quot;mc&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends data onto the existing table. It also deletes all the 
data for any acids or aeids dat contains from the given and all downstream 
tables.
</p>
<p>Before writing any data the function maps the assay component source name(s)
(acsn) to assay component id (acid), ensures the proper class on each field
and checks for every test compound sample id (spid where wllt == &quot;t&quot;) in the
tcpl chemical database. If field types get changed a warning is given 
listing the affected fields and they type they were coerced to. If the 
acsn(s) or spid(s) do not map to the tcpl databases the function will return
an error and the data will not be written.
</p>
<p>The data type can be either 'mc' for mutliple concentration data, or 'sc'
for single concentration data. Multiple concentration data will be loaded
into the level tables, whereas the single concentration will be loaded into
the single tables.
</p>


<h3>Note</h3>

<p>This function should only be used to load level 0 data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tcplCascade">tcplCascade</a></code>, <code><a href="#topic+tcplAppend">tcplAppend</a></code>
</p>

<hr>
<h2 id='write_lvl_4'>Write level 4 with updated schema</h2><span id='topic+write_lvl_4'></span>

<h3>Description</h3>

<p>Write level 4 with updated schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_lvl_4(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_lvl_4_+3A_dat">dat</code></td>
<td>
<p>output of tcplfit2 that has been unnested into a data.table</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
