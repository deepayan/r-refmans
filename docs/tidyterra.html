<!DOCTYPE html><html lang="en"><head><title>Help for package tidyterra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyterra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyterra-package'><p>tidyterra: 'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#arrange.SpatVector'><p>Order a <code>SpatVector</code> using column values</p></a></li>
<li><a href='#as_coordinates'><p>Get cell number, row and column from a <code>SpatRaster</code></p></a></li>
<li><a href='#as_sf'><p>Coerce a <code>SpatVector</code> to a <code>sf</code> object</p></a></li>
<li><a href='#as_spatraster'><p>Coerce a data frame to <code>SpatRaster</code></p></a></li>
<li><a href='#as_spatvector'><p>Method for coercing objects to <code>SpatVector</code></p></a></li>
<li><a href='#as_tibble.Spat'><p>Coerce a <code>SpatVector</code> or <code>SpatRaster</code> object to data frames</p></a></li>
<li><a href='#autoplot.Spat'><p>Create a complete ggplot for <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</p></a></li>
<li><a href='#bind_cols.SpatVector'><p>Bind multiple <code>SpatVector</code> <code>sf</code> and data frames objects by column</p></a></li>
<li><a href='#bind_rows.SpatVector'><p>Bind multiple <code>SpatVector</code>, <code>sf/sfc</code> and data frames objects by row</p></a></li>
<li><a href='#compare_spatrasters'><p>Compare attributes of two <code>SpatRaster</code> objects</p></a></li>
<li><a href='#count.SpatVector'><p>Count the observations in each <code>SpatVector</code> group</p></a></li>
<li><a href='#cross_blended_hypsometric_tints_db'><p>Cross-blended hypsometric tints</p></a></li>
<li><a href='#distinct.SpatVector'><p>Keep distinct/unique rows and geometries of <code>SpatVector</code> objects</p></a></li>
<li><a href='#drop_na.Spat'><p>Drop attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects containing missing values</p></a></li>
<li><a href='#fill.SpatVector'><p>Fill in missing values with previous or next value on a <code>SpatVector</code></p></a></li>
<li><a href='#filter-joins.SpatVector'><p>Filtering joins for <code>SpatVector</code> objects</p></a></li>
<li><a href='#filter.Spat'><p>Subset cells/geometries of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</p></a></li>
<li><a href='#fortify.Spat'><p>Fortify <code style="white-space: pre;">&#8288;Spat*&#8288;</code> Objects</p></a></li>
<li><a href='#geom_spat_contour'><p>Plot <code>SpatRaster</code> contours</p></a></li>
<li><a href='#geom_spatraster'><p>Visualise <code>SpatRaster</code> objects</p></a></li>
<li><a href='#geom_spatraster_rgb'><p>Visualise <code>SpatRaster</code> objects as images</p></a></li>
<li><a href='#ggspatvector'><p>Visualise <code>SpatVector</code> objects</p></a></li>
<li><a href='#glimpse.Spat'><p>Get a nice glimpse of your <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</p></a></li>
<li><a href='#grass_db'><p>GRASS color tables</p></a></li>
<li><a href='#group_data.SpatVector'><p>Grouping metadata for <code>SpatVector</code> objects</p></a></li>
<li><a href='#group-by.SpatVector'><p>Group a <code>SpatVector</code> by one or more variables</p></a></li>
<li><a href='#hypsometric_tints_db'><p>Hypsometric palettes database</p></a></li>
<li><a href='#is_grouped_spatvector'><p>A grouped <code>SpatVector</code></p></a></li>
<li><a href='#is_regular_grid'><p>Check if x and y positions conforms a regular grid</p></a></li>
<li><a href='#mutate-joins.SpatVector'><p>Mutating joins for <code>SpatVector</code> objects</p></a></li>
<li><a href='#mutate.Spat'><p>Create, modify, and delete cell values/layers/attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</p></a></li>
<li><a href='#pivot_longer.SpatVector'><p>Pivot <code>SpatVector</code> from wide to long</p></a></li>
<li><a href='#pivot_wider.SpatVector'><p>Pivot <code>SpatVector</code> from long to wide</p></a></li>
<li><a href='#princess_db'><p>Princess palettes database</p></a></li>
<li><a href='#pull_crs'><p>Extract CRS on WKT format</p></a></li>
<li><a href='#pull.Spat'><p>Extract a single layer/attribute</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relocate.Spat'><p>Change layer/attribute order</p></a></li>
<li><a href='#rename.Spat'><p>Rename layers/attributes</p></a></li>
<li><a href='#replace_na.Spat'><p>Replace <code>NA</code>s with specified values</p></a></li>
<li><a href='#rowwise.SpatVector'><p>Group <code>SpatVector</code> objects by rows</p></a></li>
<li><a href='#scale_color_coltab'><p>Gradient scales from <strong>Wikipedia</strong> color schemes</p></a></li>
<li><a href='#scale_coltab'><p>Discrete scales based in the color table of a <code>SpatRaster</code></p></a></li>
<li><a href='#scale_cross_blended'><p>Cross blended hypsometric tints scales</p></a></li>
<li><a href='#scale_grass'><p>GRASS scales</p></a></li>
<li><a href='#scale_hypso'><p>Gradient scales for representing hypsometry and bathymetry</p></a></li>
<li><a href='#scale_princess'><p>Gradient scales from princess color schemes</p></a></li>
<li><a href='#scale_terrain'><p>Terrain colour scales from <span class="pkg">grDevices</span></p></a></li>
<li><a href='#scale_whitebox'><p>Gradient scales from <strong>WhiteboxTools</strong> color schemes</p></a></li>
<li><a href='#select.Spat'><p>Subset layers/attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</p></a></li>
<li><a href='#slice.Spat'><p>Subset cells/rows/columns/geometries using their positions</p></a></li>
<li><a href='#stat_spat_coordinates'><p>Extract coordinates from <code>SpatVector</code> objects</p></a></li>
<li><a href='#summarise.SpatVector'><p>Summarise each group of a <code>SpatVector</code> down to one geometry</p></a></li>
<li><a href='#volcano2'><p>Updated topographic information on Auckland's Maungawhau volcano</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Extension of the 'tidyverse' for 'SpatRaster' and
    'SpatVector' objects of the 'terra' package. It includes also new
    'geom_' functions that provide a convenient way of visualizing 'terra'
    objects with 'ggplot2'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dieghernan.github.io/tidyterra/">https://dieghernan.github.io/tidyterra/</a>,
<a href="https://github.com/dieghernan/tidyterra">https://github.com/dieghernan/tidyterra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.0), data.table, dplyr (&ge; 1.0.0), ggplot2 (&ge;
3.5.0), magrittr, rlang, scales, sf (&ge; 1.0.0), terra (&ge;
1.8-10), tibble (&ge; 3.0.0), tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hexbin, isoband, knitr, lifecycle, maptiles, rmarkdown, s2,
testthat (&ge; 3.0.0), vctrs, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>geodata, dieghernan/gitdevr, ragg, styler, metR,
ggspatial, cpp11, remotes, gganimate, gifski</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>r, terra, ggplot-extension, r-spatial, rspatial,
cran, cran-r, r-package, rstats, rstats-package</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 20:05:29 UTC; diego</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego Hernangómez <a href="https://orcid.org/0000-0001-8457-4658"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (for ggspatial code),
  ggplot2 authors [cph] (for contour code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diego Hernangómez &lt;diego.hernangomezherrero@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyterra-package'>tidyterra: 'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</h2><span id='topic+tidyterra'></span><span id='topic+tidyterra-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Extension of the 'tidyverse' for 'SpatRaster' and 'SpatVector' objects of the 'terra' package. It includes also new 'geom_' functions that provide a convenient way of visualizing 'terra' objects with 'ggplot2'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Diego Hernangómez <a href="mailto:diego.hernangomezherrero@gmail.com">diego.hernangomezherrero@gmail.com</a> (<a href="https://orcid.org/0000-0001-8457-4658">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Dewey Dunnington (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>) (for ggspatial code) [contributor]
</p>
</li>
<li><p> ggplot2 authors (for contour code) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dieghernan.github.io/tidyterra/">https://dieghernan.github.io/tidyterra/</a>
</p>
</li>
<li> <p><a href="https://github.com/dieghernan/tidyterra">https://github.com/dieghernan/tidyterra</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='arrange.SpatVector'>Order a <code>SpatVector</code> using column values</h2><span id='topic+arrange.SpatVector'></span>

<h3>Description</h3>

<p><code>arrange.SpatVector()</code> orders the geometries of a <code>SpatVector</code> by the
values of selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
arrange(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatVector</code> created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="arrange.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in
descending order.</p>
</td></tr>
<tr><td><code id="arrange.SpatVector_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped <code>SpatVector</code> only (see <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+sort">terra::sort()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> function for
<code>SpatVector</code> class.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on rows:
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
library(dplyr)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))


# Single variable

v %&gt;%
  arrange(desc(iso2))


# Two variables
v %&gt;%
  mutate(even = as.double(cpro) %% 2 == 0, ) %&gt;%
  arrange(desc(even), desc(iso2))


# With new variables
v %&gt;%
  mutate(area_geom = terra::expanse(v)) %&gt;%
  arrange(area_geom)
</code></pre>

<hr>
<h2 id='as_coordinates'>Get cell number, row and column from a <code>SpatRaster</code></h2><span id='topic+as_coordinates'></span>

<h3>Description</h3>

<p><code>as_coordinates()</code> can be used to obtain the position of each cell on the
<code>SpatRaster</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coordinates(x, as.raster = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_coordinates_+3A_x">x</code></td>
<td>
<p>A <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="as_coordinates_+3A_as.raster">as.raster</code></td>
<td>
<p>If <code>TRUE</code>, the result is a <code>SpatRaster</code> object with three
layers indicating the position of each cell (cell number, row and column).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> or a <code>SpatRaster</code> (if <code>as.raster = TRUE</code>) with
the same number of rows (or cells) than the number of cells in <code>x</code>.
</p>
<p>When <code>as.raster = TRUE</code> the resulting <code>SpatRaster</code> has the same crs,
extension and resolution than <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice.SpatRaster">slice.SpatRaster()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

r &lt;- rast(f)

as_coordinates(r)
as_coordinates(r, as.raster = TRUE)

as_coordinates(r, as.raster = TRUE) %&gt;% plot()

</code></pre>

<hr>
<h2 id='as_sf'>Coerce a <code>SpatVector</code> to a <code><a href="sf.html#topic+sf">sf</a></code> object</h2><span id='topic+as_sf'></span>

<h3>Description</h3>

<p><code><a href="#topic+as_sf">as_sf()</a></code> turns a <code>SpatVector</code> to <code><a href="sf.html#topic+sf">sf</a></code> object. This is a wrapper
of <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code> with the particularity that the groups created with
<code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code> are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sf_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="as_sf_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="sf.html#topic+sf">sf</a></code> object object with an additional <code>tbl_df</code> class, for
pretty printing method.
</p>


<h3>See Also</h3>

<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- terra::vect(f)

# This is ungrouped
v
is_grouped_spatvector(v)

# Get an ungrouped data
a_sf &lt;- as_sf(v)

dplyr::is_grouped_df(a_sf)

# Grouped

v$gr &lt;- c("C", "A", "A", "B", "A", "B", "B")
v$gr2 &lt;- rep(c("F", "G", "F"), 3)

gr_v &lt;- group_by(v, gr, gr2)

gr_v
is_grouped_spatvector(gr_v)

group_data(gr_v)

# A sf

a_gr_sf &lt;- as_sf(gr_v)

dplyr::is_grouped_df(a_gr_sf)

group_data(a_gr_sf)

</code></pre>

<hr>
<h2 id='as_spatraster'>Coerce a data frame to <code>SpatRaster</code></h2><span id='topic+as_spatraster'></span>

<h3>Description</h3>

<p><code>as_spatraster()</code> turns an existing  data frame or <code><a href="tibble.html#topic+tibble">tibble</a></code>
into a <code>SpatRaster</code>. This is a wrapper of <code><a href="terra.html#topic+rast">terra::rast()</a></code> S4 method for
signature <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_spatraster(x, ..., xycols = 1:2, crs = "", digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_spatraster_+3A_x">x</code></td>
<td>
<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> or data frame.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="terra.html#topic+rast">terra::rast()</a></code>.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_xycols">xycols</code></td>
<td>
<p>A vector of integers of length 2 determining the position of
the columns that hold the x and y coordinates.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_crs">crs</code></td>
<td>
<p>A crs on several formats (PROJ.4, WKT, EPSG code, ..) or
and spatial object from <strong><a href="sf.html#topic+st_crs">sf</a></strong> or
<strong><a href="terra.html#topic+crs">terra</a></strong>.
that includes the target coordinate reference system. See <code><a href="#topic+pull_crs">pull_crs()</a></code> and
<strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_digits">digits</code></td>
<td>
<p>integer to set the precision for detecting whether points are
on a regular grid (a low number of digits is a low precision).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no <code>crs</code> is provided and the tibble has been created with the method
<code><a href="#topic+as_tibble.SpatRaster">as_tibble.SpatRaster()</a></code>, the <code>crs</code> is inferred from
<code><a href="base.html#topic+attr">attr(x, &quot;crs&quot;)</a></code>.
</p>


<h3>Value</h3>

<p>A <code>SpatRaster</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code> (see S4 method for signature <code>data.frame</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_crs">pull_crs()</a></code> for retrieving crs, and the corresponding utils <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
and <code><a href="terra.html#topic+crs">terra::crs()</a></code>.
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

r &lt;- rast(matrix(1:90, ncol = 3), crs = "EPSG:3857")

r

# Create tibble
as_tbl &lt;- as_tibble(r, xy = TRUE)

as_tbl

# From tibble
newrast &lt;- as_spatraster(as_tbl, crs = "EPSG:3857")
newrast

</code></pre>

<hr>
<h2 id='as_spatvector'>Method for coercing objects to <code>SpatVector</code></h2><span id='topic+as_spatvector'></span><span id='topic+as_spatvector.data.frame'></span><span id='topic+as_spatvector.sf'></span><span id='topic+as_spatvector.sfc'></span><span id='topic+as_spatvector.SpatVector'></span>

<h3>Description</h3>

<p><code>as_spatvector()</code> turns an existing  object into a <code>SpatVector</code>. This is a
wrapper of <code><a href="terra.html#topic+vect">terra::vect()</a></code> S4 method for signature <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_spatvector(x, ...)

## S3 method for class 'data.frame'
as_spatvector(x, ..., geom = c("lon", "lat"), crs = "")

## S3 method for class 'sf'
as_spatvector(x, ...)

## S3 method for class 'sfc'
as_spatvector(x, ...)

## S3 method for class 'SpatVector'
as_spatvector(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_spatvector_+3A_x">x</code></td>
<td>
<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code>, data frame or <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> object of
class <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_geom">geom</code></td>
<td>
<p>character. The field name(s) with the geometry data. Either
two names for x and y coordinates of points, or a single name for a single
column with WKT geometries.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_crs">crs</code></td>
<td>
<p>A crs on several formats (PROJ.4, WKT, EPSG code, ..) or
and spatial object from <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> or <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> that includes the
target coordinate reference system. See <code><a href="#topic+pull_crs">pull_crs()</a></code> and <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code><a href="terra.html#topic+vect">terra::vect()</a></code> on the following:
</p>

<ul>
<li><p> geometries with <code>NA</code> or <code>""</code> values are removed prior to conversion
</p>
</li>
<li><p> If <code>x</code> is a grouped data frame (see <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>) the grouping
vars are transferred and a &quot;grouped&quot; <code>SpatVector</code> is created (see
<code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>).
</p>
</li>
<li><p> If no <code>crs</code> is provided and the tibble has been created with the method
<code><a href="#topic+as_tibble.SpatVector">as_tibble.SpatVector()</a></code>, the <code>crs</code> is inferred from
<code><a href="base.html#topic+attr">attr(x, &quot;crs&quot;)</a></code>.
</p>
</li>
<li><p> Handles correctly the conversion of <code>EMPTY</code> geometries between
<a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> and <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>SpatVector</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+vect">terra::vect()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_crs">pull_crs()</a></code> for retrieving crs, and the corresponding utils <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
and <code><a href="terra.html#topic+crs">terra::crs()</a></code>.
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

v &lt;- vect(matrix(1:80, ncol = 2), crs = "EPSG:3857")

v$cat &lt;- sample(LETTERS[1:4], size = nrow(v), replace = TRUE)

v

# Create tibble
as_tbl &lt;- as_tibble(v, geom = "WKT")

as_tbl

# From tibble
newvect &lt;- as_spatvector(as_tbl, geom = "geometry", crs = "EPSG:3857")
newvect

</code></pre>

<hr>
<h2 id='as_tibble.Spat'>Coerce a <code>SpatVector</code> or <code>SpatRaster</code> object to data frames</h2><span id='topic+as_tibble.Spat'></span><span id='topic+as_tibble.SpatRaster'></span><span id='topic+as_tibble.SpatVector'></span>

<h3>Description</h3>

<p><code><a href="#topic+as_tibble">as_tibble()</a></code> methods for <code>SpatRaster</code> and <code>SpatVector</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
as_tibble(x, ..., xy = FALSE, na.rm = FALSE, .name_repair = "unique")

## S3 method for class 'SpatVector'
as_tibble(x, ..., geom = NULL, .name_repair = "unique")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tibble.Spat_+3A_x">x</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, the coordinates of each raster cell are included</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that have a <code>NA</code> value in at least one layer are removed. If the argument is set to <code>NA</code> only cells that have <code>NA</code> values in all layers are removed</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence.
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty.
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>.
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic.
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base <strong>R</strong>).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_geom">geom</code></td>
<td>
<p>character or NULL. If not NULL, either &quot;WKT&quot; or &quot;HEX&quot;, to get the geometry included in Well-Known-Text or hexadecimal notation. If <code>x</code> has point geometry, it can also be &quot;XY&quot; to add the coordinates of each point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> function.
</p>


<h4><code>SpatRaster</code> and <code>SpatVector</code></h4>

<p>The tibble is returned with an attribute including the crs of the initial
object in WKT format (see <code><a href="#topic+pull_crs">pull_crs()</a></code>).
</p>



<h3>About layer/column names</h3>

<p>When coercing <code>SpatRaster</code> objects to data frames, <code>x</code> and <code>y</code> names are
reserved for geographic coordinates of each cell of the <code>SpatRaster</code> It
should be also noted that <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> allows layers with duplicated
names.
</p>
<p>In the process of coercing a <code>SpatRaster</code> to a tibble, <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a>
may rename the layers of your <code>SpatRaster</code> for overcoming this issue.
Specifically, layers may be renamed on the following cases:
</p>

<ul>
<li><p> Layers with duplicated names.
</p>
</li>
<li><p> When coercing to a tibble, if <code>xy = TRUE</code>, layers named <code>x</code> or <code>y</code> would be
renamed.
</p>
</li>
<li><p> When working with tidyverse methods (i.e. <code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code>), the
latter would happen as well.
</p>
</li></ul>

<p><a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> would display a message informing of the changes on the
names of the layer.
</p>
<p>The same issue happens for <code>SpatVector</code> with names <code>geometry</code> (when
<code>geom = c("WKT", "HEX")</code>) and <code>x</code>, <code>y</code> (when <code>geom = "XY"</code>). These are
reserved names representing the geometry of the <code>SpatVector</code> (see
<code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>). If <code>geom</code> is not <code>NULL</code> then the logic described
for <code>SpatRaster</code> would apply as well for the columns of the <code>SpatVector</code>.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code>, <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
# SpatRaster
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

as_tibble(r, na.rm = TRUE)

as_tibble(r, xy = TRUE)

# SpatVector

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- vect(f)

as_tibble(v)

</code></pre>

<hr>
<h2 id='autoplot.Spat'>Create a complete ggplot for <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</h2><span id='topic+autoplot.Spat'></span><span id='topic+autoplot.SpatRaster'></span><span id='topic+autoplot.SpatVector'></span>

<h3>Description</h3>

<p><code>autoplot()</code> uses <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> to draw plots as the ones produced by
<code><a href="terra.html#topic+plot">terra::plot()</a></code>/<code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code> in a single command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
autoplot(
  object,
  ...,
  rgb = NULL,
  use_coltab = NULL,
  facets = NULL,
  nrow = NULL,
  ncol = 2
)

## S3 method for class 'SpatVector'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.Spat_+3A_object">object</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code> or <code><a href="#topic+geom_spatvector">geom_spatvector()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_rgb">rgb</code></td>
<td>
<p>Logical. Should be plotted as a RGB image? If <code>NULL</code> (the default)
<code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would try to guess.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_use_coltab">use_coltab</code></td>
<td>
<p>Logical. Should be plotted with the corresponding
<code><a href="terra.html#topic+colors">terra::coltab()</a></code>? If <code>NULL</code> (the default) <code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would
try to guess. See also <code><a href="#topic+scale_fill_coltab">scale_fill_coltab()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_facets">facets</code></td>
<td>
<p>Logical. Should facets be displayed? If <code>NULL</code> (the default)
<code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would try to guess.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_nrow">nrow</code>, <code id="autoplot.Spat_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns on the facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation of <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code> method.
</p>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>Uses <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code> or <code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code>.
</p>



<h4><code>SpatVector</code></h4>

<p>Uses <code><a href="#topic+geom_spatvector">geom_spatvector()</a></code>. Labels can be placed with <code><a href="#topic+geom_spatvector_text">geom_spatvector_text()</a></code>
or <code><a href="#topic+geom_spatvector_label">geom_spatvector_label()</a></code>.
</p>



<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> methods:
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

file_path &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

library(terra)
temp &lt;- rast(file_path)

library(ggplot2)
autoplot(temp)


# With a tile

tile &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra") %&gt;%
  rast()

autoplot(tile)

# With coltabs

ctab &lt;- system.file("extdata/cyl_era.tif", package = "tidyterra") %&gt;%
  rast()

autoplot(ctab)

#  With vectors
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
autoplot(v)

v %&gt;% autoplot(aes(fill = cpro)) +
  geom_spatvector_text(aes(label = iso2)) +
  coord_sf(crs = 25829)

</code></pre>

<hr>
<h2 id='bind_cols.SpatVector'>Bind multiple <code>SpatVector</code> <code>sf</code> and data frames objects by column</h2><span id='topic+bind_cols.SpatVector'></span><span id='topic+bind_spat_cols'></span>

<h3>Description</h3>

<p>Bind any number of <code>SpatVector</code>, data frames and <code>sf</code> object by column,
making a wider result. This is similar to <code>do.call(cbind, dfs)</code>.
</p>
<p>Where possible prefer using a <a href="#topic+mutate-joins.SpatVector">join</a> to combine
<code>SpatVector</code> and data frames objects. <code>bind_spat_cols()</code> binds the rows in
order in which they appear so it is easy to create meaningless results
without realizing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_spat_cols(
  ...,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_cols.SpatVector_+3A_...">...</code></td>
<td>
<p>Objects to combine. The first argument should be a <code>SpatVector</code>
and each of the subsequent arguments can either be a <code>SpatVector</code>, a <code>sf</code>
object or a data frame. Inputs are <a href="dplyr.html#topic+bind_cols">recycled</a> to the
same length, then matched by position.</p>
</td></tr>
<tr><td><code id="bind_cols.SpatVector_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or <code>"check_unique"</code>.
See <code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code> for <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> with the corresponding columns. The geometry and CRS
would correspond to the the first <code>SpatVector</code> of <code>...</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>cbind()</code> method
</p>


<h3>Methods</h3>

<p>Implementation of the <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> function for
<code>SpatVector</code> objects. Note that for the second and subsequent arguments on
<code>...</code> the geometry would not be <code>cbind</code>ed, and only the data frame (-ish)
columns would be kept.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on pairs <code>Spat*</code>/data.frame:
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
sv &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
df2 &lt;- data.frame(letters = letters[seq_len(nrow(sv))])

# Data frame
bind_spat_cols(sv, df2)


# Another SpatVector
bind_spat_cols(sv[1:2, ], sv[3:4, ])

# sf objects
sfobj &lt;- sf::read_sf(system.file("shape/nc.shp", package = "sf"))

bind_spat_cols(sv[1:9, ], sfobj[1:9, ])

# Mixed

end &lt;- bind_spat_cols(sv, sfobj[seq_len(nrow(sv)), 1:2], df2)

end
glimpse(end)

# Row sizes must be compatible when column-binding
try(bind_spat_cols(sv, sfobj))
</code></pre>

<hr>
<h2 id='bind_rows.SpatVector'>Bind multiple <code>SpatVector</code>, <code>sf/sfc</code> and data frames objects by row</h2><span id='topic+bind_rows.SpatVector'></span><span id='topic+bind_spat_rows'></span><span id='topic+bind.Spat'></span>

<h3>Description</h3>

<p>Bind any number of <code>SpatVector</code>, data frames and <code>sf/sfc</code> objects by row,
making a longer result. This is similar to <code>do.call(rbind, dfs)</code>, but the
output will contain all columns that appear in any of the inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_spat_rows(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_rows.SpatVector_+3A_...">...</code></td>
<td>
<p>Objects to combine. The first argument should be a <code>SpatVector</code>
and each of the subsequent arguments can either be a <code>SpatVector</code>, a
<code>sf/sfc</code> object or a data frame. Columns are matched by name, and any
missing columns will be filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bind_rows.SpatVector_+3A_.id">.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> of the same type as the first element of <code>...</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>rbind()</code> method
</p>


<h3>Methods</h3>

<p>Implementation of the <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> function for
<code>SpatVector</code> objects.
</p>
<p>The first element of <code>...</code> should be a <code>SpatVector</code>. Subsequent elements may
be <code>SpatVector</code>, <code>sf/sfc</code> objects or data frames:
</p>

<ul>
<li><p> If subsequent <code>SpatVector/sf/sfc</code> objects present a different CRS than the
first element, those elements would be reprojected to the CRS of the first
element with a message.
</p>
</li>
<li><p> If any element of <code>...</code> is a tibble/data frame the rows would be
<code>cbind</code>ed with empty geometries with a message.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on pairs <code>Spat*</code>/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

v1 &lt;- v[1, "cpro"]
v2 &lt;- v[3:5, c("name", "iso2")]

# You can supply individual SpatVector as arguments:
bind_spat_rows(v1, v2)

# When you supply a column name with the `.id` argument, a new
# column is created to link each row to its original data frame
bind_spat_rows(v1, v2, .id = "id")


# Use with sf
sfobj &lt;- sf::st_as_sf(v2[1, ])

sfobj

bind_spat_rows(v1, sfobj)

# Would reproject with a message on different CRS
sfobj_3857 &lt;- as_spatvector(sfobj) %&gt;% project("EPSG:3857")

bind_spat_rows(v1, sfobj_3857)

# And with data frames with a message
data("mtcars")
bind_spat_rows(v1, sfobj, mtcars, .id = "id2")


# Use lists
bind_spat_rows(list(v1[1, ], sfobj[1:2, ]))

# Or named list combined with .id
bind_spat_rows(list(
  SpatVector = v1[1, ], sf = sfobj[1, ],
  mtcars = mtcars[1, ]
), .id = "source")

</code></pre>

<hr>
<h2 id='compare_spatrasters'>Compare attributes of two <code>SpatRaster</code> objects</h2><span id='topic+compare_spatrasters'></span>

<h3>Description</h3>

<p>Two <code>SpatRaster</code> objects are compatible (in terms of combining layers) if the
crs, extent and resolution are similar. In those cases you can combine the
objects simply as <code>c(x, y)</code>.
</p>
<p>This function compares those attributes informing of the results. See
<strong>Solving issues</strong> section for minimal guidance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_spatrasters(x, y, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_spatrasters_+3A_x">x</code>, <code id="compare_spatrasters_+3A_y">y</code></td>
<td>
<p><code>SpatRaster</code> objects</p>
</td></tr>
<tr><td><code id="compare_spatrasters_+3A_digits">digits</code></td>
<td>
<p>Integer to set the precision for comparing the extent and
the resolution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A invisible logical <code>TRUE/FALSE</code> indicating if the <code>SpatRaster</code> objects are
compatible, plus an informative message flagging the issues found (if any).
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+identical">terra::identical()</a></code>
</p>


<h3>Solving issues</h3>


<ul>
<li><p> On <strong>non-equal crs</strong>, try <code><a href="terra.html#topic+project">terra::project()</a></code>.
</p>
</li>
<li><p> On <strong>non-equal extent</strong> try <code><a href="terra.html#topic+resample">terra::resample()</a></code>.
</p>
</li>
<li><p> On <strong>non-equal resolution</strong> you can try <code><a href="terra.html#topic+resample">terra::resample()</a></code>,
<code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code> or <code><a href="terra.html#topic+disaggregate">terra::disagg()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="terra.html#topic+identical">terra::identical()</a></code>
</p>
<p>Other helpers: 
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

x &lt;- rast(matrix(1:90, ncol = 3), crs = "EPSG:3857")

# Nothing
compare_spatrasters(x, x)

# Different crs
y_nocrs &lt;- x
crs(y_nocrs) &lt;- NA

compare_spatrasters(x, y_nocrs)

# Different extent
compare_spatrasters(x, x[1:10, , drop = FALSE])

# Different resolution
y_newres &lt;- x

res(y_newres) &lt;- res(x) / 2
compare_spatrasters(x, y_newres)

# Everything

compare_spatrasters(x, project(x, "epsg:3035"))

</code></pre>

<hr>
<h2 id='count.SpatVector'>Count the observations in each <code>SpatVector</code> group</h2><span id='topic+count.SpatVector'></span><span id='topic+tally.SpatVector'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables:
</p>

<ul>
<li> <p><code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
</p>
</li>
<li> <p><code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent
to <code>df %&gt;% summarise(n = n())</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x),
  .dissolve = TRUE
)

## S3 method for class 'SpatVector'
tally(x, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.SpatVector_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_wt">wt</code></td>
<td>
<p>Not implemented on this method</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_.dissolve">.dissolve</code></td>
<td>
<p>logical. Should borders between aggregated geometries
be dissolved?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object with an additional attribute.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+count">dplyr::count()</a></code> family functions for
<code>SpatVector</code> objects.
</p>
<p><code><a href="#topic+tally">tally()</a></code> will always return a disaggregated geometry while <code><a href="#topic+count">count()</a></code> can
handle this. See also <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">dplyr::count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on group of rows:
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)
f &lt;- system.file("ex/lux.shp", package = "terra")
p &lt;- vect(f)


p %&gt;% count(NAME_1, sort = TRUE)

p %&gt;% count(NAME_1, sort = TRUE)

p %&gt;% count(pop = ifelse(POP &lt; 20000, "A", "B"))

# tally() is a lower-level function that assumes you've done the grouping
p %&gt;% tally()

p %&gt;%
  group_by(NAME_1) %&gt;%
  tally()

# Dissolve geometries by default

library(ggplot2)
p %&gt;%
  count(NAME_1) %&gt;%
  ggplot() +
  geom_spatvector(aes(fill = n))

# Opt out
p %&gt;%
  count(NAME_1, .dissolve = FALSE, sort = TRUE) %&gt;%
  ggplot() +
  geom_spatvector(aes(fill = n))

</code></pre>

<hr>
<h2 id='cross_blended_hypsometric_tints_db'>Cross-blended hypsometric tints</h2><span id='topic+cross_blended_hypsometric_tints_db'></span>

<h3>Description</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> including the color map of
4 gradient palettes.
All the palettes includes also a definition of colors limits in terms of
elevation (meters), that can be used with <code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>.
</p>


<h3>Format</h3>

<p>A tibble of 41 rows and
6 columns. with the following
fields:
</p>

<dl>
<dt>pal</dt><dd><p> Name of the palette.</p>
</dd>
<dt>limit</dt><dd><p>Recommended elevation limit (in meters) for each color.</p>
</dd>
<dt>r</dt><dd><p>Value of the red channel (RGB color mode).</p>
</dd>
<dt>g</dt><dd><p>Value of the green channel (RGB color mode).</p>
</dd>
<dt>b</dt><dd><p>Value of the blue channel (RGB color mode).</p>
</dd>
<dt>hex</dt><dd><p> Hex code of the color.</p>
</dd>
</dl>



<h3>Details</h3>

<p>From Patterson &amp; Jenny (2011):
</p>
<p><em>More recently, the role and design of hypsometric tints have come under
scrutiny. One reason for this is the concern that people misread
elevation colors as climate or vegetation information. Cross-blended
hypsometric tints, introduced in 2009, are a partial solution to this
problem. They use variable lowland colors customized to match the
differing natural environments of world regions, which merge into
one another.</em>
</p>


<h3>Source</h3>

<p>Derived from:
</p>

<ul>
<li><p> Patterson, T., &amp; Jenny, B. (2011). The Development and Rationale of
Cross-blended Hypsometric Tints. <em>Cartographic Perspectives,</em> (69),
31 - 46. <a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_cross_blended_c">scale_fill_cross_blended_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+grass_db">grass_db</a></code>,
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>,
<code><a href="#topic+princess_db">princess_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("cross_blended_hypsometric_tints_db")

cross_blended_hypsometric_tints_db

# Select a palette
warm &lt;- cross_blended_hypsometric_tints_db %&gt;%
  filter(pal == "warm_humid")

f &lt;- system.file("extdata/asia.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = warm$hex)

# Use with limits
p +
  scale_fill_gradientn(
    colors = warm$hex,
    values = scales::rescale(warm$limit),
    limit = range(warm$limit),
    na.value = "lightblue"
  )

</code></pre>

<hr>
<h2 id='distinct.SpatVector'>Keep distinct/unique rows and geometries of <code>SpatVector</code> objects</h2><span id='topic+distinct.SpatVector'></span>

<h3>Description</h3>

<p>Keep only unique/distinct rows and geometries from a <code>SpatVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatVector</code> created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="distinct.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame. There is a reserved variable
name, <code>geometry</code>, that would remove duplicate geometries. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="distinct.SpatVector_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+unique">terra::unique()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code> function.
</p>


<h4><code>SpatVector</code></h4>

<p>It is possible to remove duplicate geometries including the geometry
variable explicitly in the <code>...</code> call. See <strong>Examples</strong>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>, <code><a href="terra.html#topic+unique">terra::unique()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

v &lt;- vect(system.file("ex/lux.shp", package = "terra"))

# Create a vector with dups
v &lt;- v[sample(seq_len(nrow(v)), 100, replace = TRUE), ]
v$gr &lt;- sample(LETTERS[1:3], 100, replace = TRUE)

# All duplicates
ex1 &lt;- distinct(v)
ex1

nrow(ex1)

# Duplicates by NAME_1
ex2 &lt;- distinct(v, gr)
ex2
nrow(ex2)

# Same but keeping all cols
ex2b &lt;- distinct(v, gr, .keep_all = TRUE)
ex2b
nrow(ex2b)


# Unique geometries
ex3 &lt;- distinct(v, geometry)

ex3
nrow(ex3)
# Same as terra::unique()
terra::unique(ex3)

# Unique keeping info
distinct(v, geometry, .keep_all = TRUE)
</code></pre>

<hr>
<h2 id='drop_na.Spat'>Drop attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects containing missing values</h2><span id='topic+drop_na.Spat'></span><span id='topic+drop_na.SpatVector'></span><span id='topic+drop_na.SpatRaster'></span>

<h3>Description</h3>


<ul>
<li> <p><code>SpatVector</code>: <code>drop_na()</code> method drops geometries where any attribute
specified by <code>...</code> contains a missing value.
</p>
</li>
<li> <p><code>SpatRaster</code>: <code>drop_na()</code> method drops cells where any layer specified by
<code>...</code> contains a missing value.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
drop_na(data, ...)

## S3 method for class 'SpatRaster'
drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_na.Spat_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> created with <code><a href="terra.html#topic+vect">terra::vect()</a></code> or a <code>SpatRaster</code>
<code><a href="terra.html#topic+rast">terra::rast()</a></code>.</p>
</td></tr>
<tr><td><code id="drop_na.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt;  Attributes to inspect
for missing values. If empty, all attributes are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object of the same class than <code>data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+trim">terra::trim()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code> function.
</p>


<h4><code>SpatVector</code></h4>

<p>The implementation of this method is performed on a <code>by-attribute</code> basis,
meaning that <code>NAs</code> are assessed on the attributes (columns) of each vector
(rows). The result is a <code>SpatVector</code> with potentially less geometries than
the input.
</p>



<h4><code>SpatRaster</code></h4>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>Actual implementation of <code style="white-space: pre;">&#8288;drop_na().SpatRaster&#8288;</code> can be understood as a
masking method based on the values of the layers (see <code><a href="terra.html#topic+mask">terra::mask()</a></code>).
</p>
<p><code>SpatRaster</code> layers are considered as columns and <code>SpatRaster</code> cells as rows,
so rows (cells) with any <code>NA</code> value on any layer would get a <code>NA</code> value. It
is possible also to mask the cells (rows) based on the values of specific
layers (columns).
</p>
<p><code>drop_na()</code> would effectively remove outer cells that are <code>NA</code> (see
<code><a href="terra.html#topic+trim">terra::trim()</a></code>), so the extent of the resulting object may differ of the
extent of the input (see <code><a href="terra.html#topic+resample">terra::resample()</a></code> for more info).
</p>
<p>Check the <strong>Examples</strong> to have a better understanding of this method.
</p>


<h5>Feedback needed!</h5>

<p>Visit <a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a>. The implementation
of this method for <code>SpatRaster</code> may change in the future.
</p>




<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> verbs for handling missing values:
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> methods:
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>,
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector</a>()</code>,
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector</a>()</code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

v &lt;- terra::vect(f)

# Add NAs
v &lt;- v %&gt;% mutate(iso2 = ifelse(cpro &lt;= "09", NA, cpro))

# Init
plot(v, col = "red")

# Mask with lyr.1
v %&gt;%
  drop_na(iso2) %&gt;%
  plot(col = "red")
# SpatRaster method


r &lt;- rast(
  crs = "EPSG:3857",
  extent = c(0, 10, 0, 10),
  nlyr = 3,
  resolution = c(2.5, 2.5)
)
terra::values(r) &lt;- seq_len(ncell(r) * nlyr(r))



# Add NAs
r[r &gt; 13 &amp; r &lt; 22 | r &gt; 31 &amp; r &lt; 45] &lt;- NA

# Init
plot(r, nc = 3)

# Mask with lyr.1
r %&gt;%
  drop_na(lyr.1) %&gt;%
  plot(nc = 3)

# Mask with lyr.2
r %&gt;%
  drop_na(lyr.2) %&gt;%
  plot(nc = 3)

# Mask with lyr.3
r %&gt;%
  drop_na(lyr.3) %&gt;%
  plot(nc = 3)

# Auto-mask all layers
r %&gt;%
  drop_na() %&gt;%
  plot(nc = 3)

</code></pre>

<hr>
<h2 id='fill.SpatVector'>Fill in missing values with previous or next value on a <code>SpatVector</code></h2><span id='topic+fill.SpatVector'></span>

<h3>Description</h3>

<p>Fills missing values in selected columns using the next or previous entry.
This is useful in the common output format where values are not repeated,
and are only recorded when they change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
fill(data, ..., .direction = c("down", "up", "downup", "updown"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill.SpatVector_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="fill.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to fill.</p>
</td></tr>
<tr><td><code id="fill.SpatVector_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently
either &quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (i.e. first down and then up)
or &quot;updown&quot; (first up and then down).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+fill">tidyr::fill()</a></code> function for <code>SpatVector</code>.
</p>


<h3>Grouped <code>SpatVector</code></h3>

<p>With grouped <code>SpatVector</code> created by <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>, <code>fill()</code> will
be applied <em>within</em> each group, meaning that it won't fill across group
boundaries.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+fill">tidyr::fill()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> verbs for handling missing values:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> methods:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector</a>()</code>,
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector</a>()</code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

lux &lt;- terra::vect(system.file("ex/lux.shp", package = "terra"))

# Leave some blanks for demo purporses

lux_blnk &lt;- lux %&gt;%
  mutate(NAME_1 = if_else(NAME_1 != NAME_2, NA, NAME_2))


as_tibble(lux_blnk)

# `fill()` defaults to replacing missing data from top to bottom
lux_blnk %&gt;%
  fill(NAME_1) %&gt;%
  as_tibble()


# direction = "up"
lux_blnk %&gt;%
  fill(NAME_1, .direction = "up") %&gt;%
  as_tibble()

# Grouping and downup - will restore the initial state
lux_blnk %&gt;%
  group_by(ID_1) %&gt;%
  fill(NAME_1, .direction = "downup") %&gt;%
  as_tibble()

</code></pre>

<hr>
<h2 id='filter-joins.SpatVector'>Filtering joins for <code>SpatVector</code> objects</h2><span id='topic+filter-joins.SpatVector'></span><span id='topic+semi_join.SpatVector'></span><span id='topic+anti_join.SpatVector'></span>

<h3>Description</h3>

<p>Filtering joins filter rows from <code>x</code> based on the presence or absence of
matches in <code>y</code>:
</p>

<ul>
<li> <p><code><a href="#topic+semi_join">semi_join()</a></code> return all rows from <code>x</code> with a match in <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+anti_join">anti_join()</a></code> return all rows from <code>x</code> without a match in <code>y</code>.
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
semi_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'SpatVector'
anti_join(x, y, by = NULL, copy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter-joins.SpatVector_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code> created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_y">y</code></td>
<td>
<p>A data frame or other object coercible to a data frame. <strong>If a
<code>SpatVector</code> of <code>sf</code> object</strong> is provided it would return an error (see
<code><a href="terra.html#topic+intersect">terra::intersect()</a></code> for performing spatial joins).</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> family
</p>


<h4><code>SpatVector</code></h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>x</code> for the records that matches the join
conditions.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code>, <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>, <code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on pairs <code>Spat*</code>/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

# Vector
v &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# A data frame
df &lt;- data.frame(
  cpro = sprintf("%02d", 1:10),
  x = runif(10),
  y = runif(10),
  letter = rep_len(LETTERS[1:3], length.out = 10)
)

v

# Semi join
semi &lt;- v %&gt;% semi_join(df)

semi

autoplot(semi, aes(fill = iso2)) + ggtitle("Semi Join")


# Anti join

anti &lt;- v %&gt;% anti_join(df)

anti

autoplot(anti, aes(fill = iso2)) + ggtitle("Anti Join")

</code></pre>

<hr>
<h2 id='filter.Spat'>Subset cells/geometries of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</h2><span id='topic+filter.Spat'></span><span id='topic+filter.SpatRaster'></span><span id='topic+filter.SpatVector'></span>

<h3>Description</h3>

<p>The <code>filter()</code> function is used to subset <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects, retaining all
cells/geometries that satisfy your conditions. To be retained, the
cell/geometry must produce a value of <code>TRUE</code> for all conditions.
</p>
<p><strong>It is possible to filter a <code>SpatRaster</code> by its geographic coordinates</strong>.
You need to use <code>filter(.data, x &gt; 42)</code>. Note that <code>x</code> and <code>y</code> are reserved
names on <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a>, since they refer to the geographic coordinates of
the layer.
</p>
<p>See <strong>Examples</strong> and section <strong>About layer names</strong> on <code><a href="#topic+as_tibble.Spat">as_tibble.Spat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
filter(.data, ..., .preserve = FALSE, .keep_extent = TRUE)

## S3 method for class 'SpatVector'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the layers/attributes
in <code>.data</code>. If multiple expressions are included, they are combined with
the <code>&amp;</code> operator. Only cells/geometries for which all conditions evaluate
to <code>TRUE</code> are kept. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored for <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_.keep_extent">.keep_extent</code></td>
<td>
<p>Should the extent of the resulting <code>SpatRaster</code> be kept?
On <code>FALSE</code>, <code><a href="terra.html#topic+trim">terra::trim()</a></code> is called so the extent of the result may be
different of the extent of the output. See also <code><a href="#topic+drop_na.SpatRaster">drop_na.SpatRaster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>Cells that do not fulfill the conditions on <code>...</code> are returned with value
<code>NA</code>. On a multi-layer <code>SpatRaster</code> the <code>NA</code> is propagated across all the
layers.
</p>
<p>If <code>.keep_extent = TRUE</code> the returning <code>SpatRaster</code> has the same crs, extent,
resolution and hence the same number of cells than <code>.data</code>. If
<code>.keep_extent = FALSE</code> the outer <code>NA</code> cells are trimmed with <code><a href="terra.html#topic+trim">terra::trim()</a></code>,
so the extent and number of cells may differ. The output would present in
any case the same crs and resolution than <code>.data</code>.
</p>
<p><code>x</code> and <code>y</code> variables (i.e. the longitude and latitude of the <code>SpatRaster</code>)
are also available internally for filtering. See <strong>Examples</strong>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> with all the geometries that produce a value of
<code>TRUE</code> for all conditions.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

r &lt;- rast(f) %&gt;% select(tavg_04)

plot(r)


# Filter temps
r_f &lt;- r %&gt;% filter(tavg_04 &gt; 11.5)

# Extent is kept
plot(r_f)


# Filter temps and extent
r_f2 &lt;- r %&gt;% filter(tavg_04 &gt; 11.5, .keep_extent = FALSE)

# Extent has changed
plot(r_f2)


# Filter by geographic coordinates
r2 &lt;- project(r, "epsg:4326")

r2 %&gt;% plot()

r2 %&gt;%
  filter(
    x &gt; -4,
    x &lt; -2,
    y &gt; 42
  ) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='fortify.Spat'>Fortify <code style="white-space: pre;">&#8288;Spat*&#8288;</code> Objects</h2><span id='topic+fortify.Spat'></span><span id='topic+fortify.SpatRaster'></span><span id='topic+fortify.SpatVector'></span><span id='topic+fortify.SpatGraticule'></span>

<h3>Description</h3>

<p>Fortify <code>SpatRaster</code> and <code>SpatVector</code> objects to data frames. This provide
native compatibility with <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
fortify(
  model,
  data,
  ...,
  .name_repair = "unique",
  maxcell = terra::ncell(model) * 1.1,
  pivot = FALSE
)

## S3 method for class 'SpatVector'
fortify(model, data, ...)

## S3 method for class 'SpatGraticule'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fortify.Spat_+3A_model">model</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_data">data</code></td>
<td>
<p>Not used by this method.</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence.
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty.
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>.
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic.
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base <strong>R</strong>).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_pivot">pivot</code></td>
<td>
<p>Logical. When <code>TRUE</code> the <code>SpatRaster</code> would be fortified on
<a href="tidyr.html#topic+pivot_longer">long format</a>. When <code>FALSE</code> (the default) it would
be fortified as a data frame with a column for each layer. See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+fortify.SpatVector">fortify.SpatVector()</a></code> returns a <code><a href="sf.html#topic+sf">sf</a></code> object and
<code><a href="#topic+fortify.SpatRaster">fortify.SpatRaster()</a></code> returns a <code><a href="tibble.html#topic+tibble">tibble</a></code>. See <strong>Methods</strong>.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> method.
</p>


<h4><code>SpatRaster</code></h4>

<p>Return a tibble than can be used with <code style="white-space: pre;">&#8288;ggplot2::geom_*&#8288;</code> like
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>, <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, etc.
</p>
<p>The resulting tibble includes the coordinates on the columns <code style="white-space: pre;">&#8288;x, y&#8288;</code>. The
values of each layer are included as additional columns named as per the
name of the layer on the <code>SpatRaster</code>.
</p>
<p>The CRS of the <code>SpatRaster</code> can be retrieved with
<code>attr(fortifiedSpatRaster, "crs")</code>.
</p>
<p>It is possible to convert the fortified object onto a <code>SpatRaster</code> again with
<code><a href="#topic+as_spatraster">as_spatraster()</a></code>.
</p>
<p>When <code>pivot = TRUE</code> the <code>SpatRaster</code> is fortified in a &quot;long&quot; format (see
<code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code>). The fortified object would have the following
columns:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;x,y&#8288;</code>: Coordinates (center) of the cell on the corresponding CRS.
</p>
</li>
<li> <p><code>lyr</code>: Indicating the name of the <code>SpatRaster</code> layer of <code>value</code>.
</p>
</li>
<li> <p><code>value</code>: The value of the <code>SpatRaster</code> in the corresponding <code>lyr</code>.
</p>
</li></ul>

<p>This option may be useful when using several <code style="white-space: pre;">&#8288;geom_*&#8288;</code> and for faceting, see
<strong>Examples</strong>.
</p>



<h4><code>SpatVector</code> and <code>SpatGraticule</code></h4>

<p>Return a <code><a href="sf.html#topic+sf">sf</a></code> object than can be used with <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>.
</p>



<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>, <code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>, <code><a href="#topic+as_spatraster">as_spatraster()</a></code>,
<code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code>.
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> methods:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Get a SpatRaster
r &lt;- system.file("extdata/volcano2.tif", package = "tidyterra") %&gt;%
  terra::rast() %&gt;%
  terra::project("EPSG:4326")

fortified &lt;- ggplot2::fortify(r)

fortified

# The crs is an attribute of the fortified SpatRaster

attr(fortified, "crs")

# Back to a SpatRaster with
as_spatraster(fortified)

# You can now use a SpatRaster with any geom
library(ggplot2)

ggplot(r) +
  geom_histogram(aes(x = elevation),
    bins = 20, fill = "lightblue",
    color = "black"
  )


# Create a SpatVector
extfile &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
cyl &lt;- terra::vect(extfile)

cyl

# To sf
ggplot2::fortify(cyl)

# Now you can use geom_sf() straight away thanks to fortify::SpatVector()

library(ggplot2)

ggplot(cyl) +
  geom_sf()


</code></pre>

<hr>
<h2 id='geom_spat_contour'>Plot <code>SpatRaster</code> contours</h2><span id='topic+geom_spat_contour'></span><span id='topic+geom_spatraster_contour'></span><span id='topic+geom_spatraster_contour_text'></span><span id='topic+geom_spatraster_contour_filled'></span>

<h3>Description</h3>

<p>These geoms create contours of <code>SpatRaster</code> objects.  To specify a valid
surface, you should specify the layer on <code>aes(z = layer_name)</code>, otherwise all
the layers would be consider for creating contours. See also <strong>Facets</strong>
section.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> <code>geom_spatraster_contour_text()</code> creates
labeled contours and it is implemented on top of <code><a href="isoband.html#topic+isolines_grob">isoband::isolines_grob()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster_contour(
  mapping = NULL,
  data,
  ...,
  maxcell = 5e+05,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_spatraster_contour_text(
  mapping = NULL,
  data,
  ...,
  maxcell = 5e+05,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  size.unit = "mm",
  label_format = scales::label_number(),
  label_placer = isoband::label_placer_minmax(),
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_spatraster_contour_filled(
  mapping = NULL,
  data,
  ...,
  maxcell = 5e+05,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_spat_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>. See
<strong>Aesthetics</strong> specially in the use of <code>fill</code> aesthetic.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_data">data</code></td>
<td>
<p>A <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_bins">bins</code></td>
<td>
<p>Number of contour bins. Overridden by <code>breaks</code>.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the contour bins. Overridden by <code>bins</code>.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Numeric vector to set the contour breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output. A function can be created from a formula
(e.g. ~ fullseq(.x, .y)).
</p>
</li></ul>

<p>Overrides <code>binwidth</code> and <code>bins</code>. By default, this is a vector of length
ten with <code><a href="base.html#topic+pretty">pretty()</a></code> breaks.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are silently removed. If
<code>FALSE</code>, missing values are removed with a warning.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_size.unit">size.unit</code></td>
<td>
<p>How the <code>size</code> aesthetic is interpreted: as millimetres
(<code>"mm"</code>, default), points (<code>"pt"</code>), centimetres (<code>"cm"</code>), inches (<code>"in"</code>),
or picas (<code>"pc"</code>).</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_label_format">label_format</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels. This produced the same result than
<code>geom_spatraster_contour()</code>.
</p>
</li>
<li><p> A character vector giving labels (must be same length as the breaks
produced by <code>bins</code>, <code>binwidth</code>, or <code>breaks</code>).
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels as output,
as the default setup (<code><a href="scales.html#topic+label_number">scales::label_number()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_label_placer">label_placer</code></td>
<td>
<p>Function that controls how labels are placed along
the isolines. Uses <code><a href="isoband.html#topic+label_placer_minmax">label_placer_minmax()</a></code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+contour">terra::contour()</a></code>
</p>


<h3>Aesthetics</h3>

<p><code>geom_spatraster_contour()</code> / <code>geom_spatraster_contour_text()</code> understands
the following aesthetics:
</p>

<ul>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">colour</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_group_order">group</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_linetype_size_shape">linetype</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_linetype_size_shape">linewidth</a></code>
<code>geom_spatraster_contour_text()</code> understands also:
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_linetype_size_shape">size</a></code>
</p>
</li>
<li> <p><code>label</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li></ul>

<p>Additionally, <code>geom_spatraster_contour_filled()</code> understands also the
following aesthetics, as well as the ones listed above:
</p>

<ul>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code>subgroup</code>
</p>
</li></ul>

<p>Check <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code> for more info on contours and
<code>vignette("ggplot2-specs", package = "ggplot2")</code> for an overview of the
aesthetics.
</p>


<h3>Computed variables</h3>

<p>These geom computes internally some variables that are available for use as
aesthetics, using (for example) <code style="white-space: pre;">&#8288;aes(color = after_stat(&lt;computed&gt;))&#8288;</code> (see
<code><a href="ggplot2.html#topic+aes_eval">ggplot2::after_stat()</a></code>).
</p>

<ul>
<li> <p><code>after_stat(lyr)</code>: Name of the layer.
</p>
</li>
<li> <p><code>after_stat(level)</code>: Height of contour. For contour lines, this is numeric
vector that represents bin boundaries. For contour bands, this is an
ordered factor that represents bin ranges.
</p>
</li>
<li> <p><code>after_stat(nlevel)</code>: Height of contour, scaled to maximum of 1.
</p>
</li>
<li> <p><code>after_stat(level_low)</code>, <code>after_stat(level_high)</code>,
<code>after_stat(level_mid)</code>: (contour bands only) Lower and upper bin
boundaries for each band, as well the mid point between the boundaries.
</p>
</li></ul>



<h3>Dropped variables</h3>


<ul>
<li> <p><code>z</code>: After contouring, the <code>z</code> values of individual data points are no
longer available.
</p>
</li></ul>



<h3>Coords</h3>

<p>When the <code>SpatRaster</code> does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On <code>SpatRaster</code> that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to
adjust the scales. That means that also the
<strong><code>SpatRaster</code> may be reprojected</strong>.
</p>


<h3>Facets</h3>

<p>You can use <code> facet_wrap(~lyr)</code> for creating a faceted plot by each layer of
the <code>SpatRaster</code> object. See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.
</p>
<p>The <a href="https://CRAN.R-project.org/package=metR"><span class="pkg">metR</span></a> package also provides a set of alternative functions:
</p>

<ul>
<li> <p><code>metR::geom_contour2()</code>.
</p>
</li>
<li> <p><code>metR::geom_text_contour()</code> and <code>metR::geom_label_contour()</code>.
</p>
</li>
<li> <p><code>metR::geom_contour_tanaka()</code>.
</p>
</li></ul>

<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)

# Raster
f &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")
r &lt;- rast(f)

library(ggplot2)

ggplot() +
  geom_spatraster_contour(data = r)


# Labelled
ggplot() +
  geom_spatraster_contour_text(
    data = r, breaks = c(110, 130, 160, 190),
    color = "grey10", family = "serif"
  )


ggplot() +
  geom_spatraster_contour(
    data = r, aes(color = after_stat(level)),
    binwidth = 1,
    linewidth = 0.4
  ) +
  scale_color_gradientn(
    colours = hcl.colors(20, "Inferno"),
    guide = guide_coloursteps()
  ) +
  theme_minimal()

# Filled with breaks
ggplot() +
  geom_spatraster_contour_filled(data = r, breaks = seq(80, 200, 10)) +
  scale_fill_hypso_d()

# Both lines and contours
ggplot() +
  geom_spatraster_contour_filled(
    data = r, breaks = seq(80, 200, 10),
    alpha = .7
  ) +
  geom_spatraster_contour(
    data = r, breaks = seq(80, 200, 2.5),
    color = "grey30",
    linewidth = 0.1
  ) +
  scale_fill_hypso_d()


</code></pre>

<hr>
<h2 id='geom_spatraster'>Visualise <code>SpatRaster</code> objects</h2><span id='topic+geom_spatraster'></span><span id='topic+stat_spatraster'></span>

<h3>Description</h3>

<p>This geom is used to visualise <code>SpatRaster</code> objects (see <code><a href="terra.html#topic+rast">terra::rast()</a></code>).
The geom is designed for visualise the object by layers, as <code><a href="terra.html#topic+plot">terra::plot()</a></code>
does.
</p>
<p>For plotting <code>SpatRaster</code> objects as map tiles (i.e. RGB <code>SpatRaster</code>), use
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code>.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>.
</p>
<p><code>stat_spatraster()</code> is provided as a complementary function, so the <code>geom</code>
can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster(
  mapping = aes(),
  data,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = FALSE,
  interpolate = FALSE,
  maxcell = 5e+05,
  use_coltab = TRUE,
  ...
)

stat_spatraster(
  mapping = aes(),
  data,
  geom = "raster",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = FALSE,
  maxcell = 5e+05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_spatraster_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>. See
<strong>Aesthetics</strong> specially in the use of <code>fill</code> aesthetic.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_data">data</code></td>
<td>
<p>A <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are silently removed. If
<code>FALSE</code>, missing values are removed with a warning.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_use_coltab">use_coltab</code></td>
<td>
<p>Logical. Only applicable to <code>SpatRaster</code> objects that have
an associated <a href="terra.html#topic+colors">coltab</a>. Should the coltab be used on the
plot? See also <code><a href="#topic+scale_fill_coltab">scale_fill_coltab()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data. Recommended <code>geom</code>
for <code>SpatRaster</code> are <code>"raster"</code> (the default), <code>"point"</code>,<code>"text"</code> and
<code>"label"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>
</p>


<h3>Coords</h3>

<p>When the <code>SpatRaster</code> does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On <code>SpatRaster</code> that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to
adjust the scales. That means that also the
<strong><code>SpatRaster</code> may be reprojected</strong>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_spatraster()</code> understands the following aesthetics:
</p>

<ul>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li></ul>

<p>If <code>fill</code> is not provided, <code>geom_spatraster()</code> creates a <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a>
layer with all the layers of the <code>SpatRaster</code> object. Use <code>facet_wrap(~lyr)</code>
to display properly the <code>SpatRaster</code> layers.
</p>
<p>If <code>fill</code> is used, it should contain the name of one layer that is present
on the <code>SpatRaster</code> (i.e.
<code style="white-space: pre;">&#8288;geom_spatraster(data = rast, aes(fill = &lt;name_of_lyr&gt;)&#8288;</code>). Names of the
layers can be retrieved using <code>names(rast)</code>.
</p>
<p>Using <code>geom_spatraster(..., mapping = aes(fill = NULL))</code> or
<code style="white-space: pre;">&#8288;geom_spatraster(..., fill = &lt;color value(s)&gt;)&#8288;</code> would create a layer with no
mapped <code>fill</code> aesthetic.
</p>
<p><code>fill</code> can use computed variables.
</p>
<p>For <code>alpha</code> use computed variable. See section <strong>Computed variables</strong>.
</p>


<h4><code>stat_spatraster()</code></h4>

<p><code>stat_spatraster()</code> understands the same aesthetics than <code>geom_spatraster()</code>
when using <code>geom = "raster"</code> (the default):
</p>

<ul>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">fill</a></code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+aes_colour_fill_alpha">alpha</a></code>
</p>
</li></ul>

<p>When <code>geom = "raster"</code> the <code>fill</code> parameter would behave as in
<code>geom_spatraster()</code>. If another <code>geom</code> is used <code>stat_spatraster()</code> would
understand the aesthetics of the required <code>geom</code> and
<code style="white-space: pre;">&#8288;aes(fill = &lt;name_of_lyr&gt;)&#8288;</code> would not be applicable.
</p>
<p>Note also that mapping of aesthetics <code>x</code> and <code>y</code> is provided by default,
so the user does not need to add those aesthetics on <code>aes()</code>. In all the
cases the aesthetics should be mapped by using computed variables. See
section <strong>Computed variables</strong> and <strong>Examples</strong>.
</p>



<h3>Facets</h3>

<p>You can use <code> facet_wrap(~lyr)</code> for creating a faceted plot by each layer of
the <code>SpatRaster</code> object. See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> for details.
</p>


<h3>Computed variables</h3>

<p>This geom computes internally some variables that are available for use as
aesthetics, using (for example) <code>aes(alpha = after_stat(value))</code> (see
<code><a href="ggplot2.html#topic+aes_eval">ggplot2::after_stat()</a></code>).
</p>

<ul>
<li> <p><code>after_stat(value)</code>: Values of the <code>SpatRaster.</code>
</p>
</li>
<li> <p><code>after_stat(lyr)</code>: Name of the layer.
</p>
</li></ul>



<h3>Source</h3>

<p>Based on the <code>layer_spatial()</code> implementation on <a href="https://CRAN.R-project.org/package=ggspatial"><span class="pkg">ggspatial</span></a> package.
Thanks to <a href="https://github.com/paleolimbot">Dewey Dunnington</a> and <a href="https://github.com/paleolimbot/ggspatial/graphs/contributors">ggspatial contributors</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>,
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>
</p>
<p>Recommended <code>geoms</code>:
</p>

<ul>
<li> <p><code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label()</a></code>.
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code>.
</p>
</li></ul>

<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Avg temperature on spring in Castille and Leon (Spain)
file_path &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

library(terra)
temp_rast &lt;- rast(file_path)

library(ggplot2)

# Display a single layer
names(temp_rast)

ggplot() +
  geom_spatraster(data = temp_rast, aes(fill = tavg_04)) +
  # You can use coord_sf
  coord_sf(crs = 3857) +
  scale_fill_grass_c(palette = "celsius")

# Display facets
ggplot() +
  geom_spatraster(data = temp_rast) +
  facet_wrap(~lyr, ncol = 2) +
  scale_fill_grass_b(palette = "celsius", breaks = seq(0, 20, 2.5))

# Non spatial rasters

no_crs &lt;- rast(crs = NA, extent = c(0, 100, 0, 100), nlyr = 1)
values(no_crs) &lt;- seq_len(ncell(no_crs))


ggplot() +
  geom_spatraster(data = no_crs)

# Downsample

ggplot() +
  geom_spatraster(data = no_crs, maxcell = 25)



# Using stat_spatraster
# Default
ggplot() +
  stat_spatraster(data = temp_rast) +
  facet_wrap(~lyr)

# Using points
ggplot() +
  stat_spatraster(
    data = temp_rast,
    aes(color = after_stat(value)),
    geom = "point", maxcell = 250
  ) +
  scale_colour_viridis_c(na.value = "transparent") +
  facet_wrap(~lyr)

# Using points and labels

r_single &lt;- temp_rast %&gt;% select(1)

ggplot() +
  stat_spatraster(
    data = r_single,
    aes(color = after_stat(value)),
    geom = "point",
    maxcell = 2000
  ) +
  stat_spatraster(
    data = r_single,
    aes(label = after_stat(round(value, 2))),
    geom = "label",
    alpha = 0.85,
    maxcell = 20
  ) +
  scale_colour_viridis_c(na.value = "transparent")

</code></pre>

<hr>
<h2 id='geom_spatraster_rgb'>Visualise <code>SpatRaster</code> objects as images</h2><span id='topic+geom_spatraster_rgb'></span>

<h3>Description</h3>

<p>This geom is used to visualise <code>SpatRaster</code> objects (see <code><a href="terra.html#topic+rast">terra::rast()</a></code>) as
RGB images. The layers are combined such that they represent the red,
green and blue channel.
</p>
<p>For plotting <code>SpatRaster</code> objects by layer values use <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code>.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster_rgb(
  mapping = aes(),
  data,
  interpolate = TRUE,
  r = 1,
  g = 2,
  b = 3,
  alpha = 1,
  maxcell = 5e+05,
  max_col_value = 255,
  ...,
  stretch = NULL,
  zlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_spatraster_rgb_+3A_mapping">mapping</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_data">data</code></td>
<td>
<p>A <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_r">r</code>, <code id="geom_spatraster_rgb_+3A_g">g</code>, <code id="geom_spatraster_rgb_+3A_b">b</code></td>
<td>
<p>Integer representing the number of layer of <code>data</code> to be
considered as the red (<code>r</code>), green (<code>g</code>) and blue (<code>b</code>) channel.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_max_col_value">max_col_value</code></td>
<td>
<p>Number giving the maximum of the color values range.
When this is <code>255</code> (the default), the result is computed most efficiently.
See <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_stretch">stretch</code></td>
<td>
<p>character. Option to stretch the values to increase contrast: &quot;lin&quot; (linear) or &quot;hist&quot; (histogram). The linear stretch uses <code><a href="terra.html#topic+stretch">stretch</a></code> with arguments <code>minq=0.02</code> and <code>maxq=0.98</code></p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_zlim">zlim</code></td>
<td>
<p>numeric vector of length 2. Range of values to plot (optional). If this is set, and <code>stretch="lin"</code> is used, then the values are stretched within the range of <code>zlim</code>. This allows creating consistent coloring between SpatRasters with different cell-value ranges, even when stretching the colors for improved contrast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code>
</p>


<h3>Aesthetics</h3>

<p>No <code>aes()</code> is required. In fact, <code>aes()</code> will be ignored.
</p>


<h3>Coords</h3>

<p>When the <code>SpatRaster</code> does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On <code>SpatRaster</code> that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to
adjust the scales. That means that also the
<strong><code>SpatRaster</code> may be reprojected</strong>.
</p>


<h3>Source</h3>

<p>Based on the <code>layer_spatial()</code> implementation on <a href="https://CRAN.R-project.org/package=ggspatial"><span class="pkg">ggspatial</span></a> package.
Thanks to <a href="https://github.com/paleolimbot">Dewey Dunnington</a> and <a href="https://github.com/paleolimbot/ggspatial/graphs/contributors">ggspatial contributors</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>, <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code>.
</p>
<p>You can get also RGB tiles from the <a href="https://CRAN.R-project.org/package=maptiles"><span class="pkg">maptiles</span></a> package,
see <code><a href="maptiles.html#topic+get_tiles">maptiles::get_tiles()</a></code>.
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Tile of Castille and Leon (Spain) from OpenStreetMap
file_path &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")

library(terra)
tile &lt;- rast(file_path)

library(ggplot2)


ggplot() +
  geom_spatraster_rgb(data = tile) +
  # You can use coord_sf
  coord_sf(crs = 3035)

# Combine with sf objects
vect_path &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

cyl_sf &lt;- sf::st_read(vect_path)

ggplot(cyl_sf) +
  geom_spatraster_rgb(data = tile) +
  geom_sf(aes(fill = iso2)) +
  coord_sf(crs = 3857) +
  scale_fill_viridis_d(alpha = 0.7)

</code></pre>

<hr>
<h2 id='ggspatvector'>Visualise <code>SpatVector</code> objects</h2><span id='topic+ggspatvector'></span><span id='topic+geom_spatvector'></span><span id='topic+geom_spatvector_label'></span><span id='topic+geom_spatvector_text'></span><span id='topic+stat_spatvector'></span>

<h3>Description</h3>

<p>Wrappers of <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> family used to visualise <code>SpatVector</code>
objects (see <code><a href="terra.html#topic+vect">terra::vect()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatvector(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...
)

geom_spatvector_label(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...,
  nudge_x = 0,
  nudge_y = 0,
  label.size = 0.25,
  inherit.aes = TRUE
)

geom_spatvector_text(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  inherit.aes = TRUE
)

stat_spatvector(
  mapping = NULL,
  data = NULL,
  geom = "rect",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggspatvector_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> object, see <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> functions.
These are often aesthetics, used to set an aesthetic to a fixed value,
like <code>colour = "red"</code> or <code>linewidth = 3</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_nudge_x">nudge_x</code>, <code id="ggspatvector_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ggspatvector_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers of <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> functions. Since a
<code><a href="#topic+fortify.SpatVector">fortify.SpatVector()</a></code> method is provided, <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> treat a
<code>SpatVector</code> in the same way that a <code><a href="sf.html#topic+sf">sf</a></code> object. A side effect
is that you can use <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> directly with <code>SpatVector</code> objects.
</p>
<p>See <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> for details on aesthetics, etc.
</p>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a SpatVector
extfile &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

cyl &lt;- terra::vect(extfile)
class(cyl)

library(ggplot2)

ggplot(cyl) +
  geom_spatvector()


# With params

ggplot(cyl) +
  geom_spatvector(aes(fill = name), color = NA) +
  scale_fill_viridis_d() +
  coord_sf(crs = 3857)

# Add labels
ggplot(cyl) +
  geom_spatvector(aes(fill = name), color = NA) +
  geom_spatvector_text(aes(label = iso2),
    fontface = "bold",
    color = "red"
  ) +
  scale_fill_viridis_d(alpha = 0.4) +
  coord_sf(crs = 3857)

# You can use now geom_sf with SpatVectors!



ggplot(cyl) +
  geom_sf() +
  labs(
    title = paste("cyl is", as.character(class(cyl))),
    subtitle = "With geom_sf()"
  )

</code></pre>

<hr>
<h2 id='glimpse.Spat'>Get a nice glimpse of your <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</h2><span id='topic+glimpse.Spat'></span><span id='topic+glimpse.SpatRaster'></span><span id='topic+glimpse.SpatVector'></span>

<h3>Description</h3>

<p><code>glimpse()</code> is like a transposed version of <code><a href="base.html#topic+print">print()</a></code>: layers/columns run
down the  page, and data runs across. This makes it possible to see every
layer/column in a <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
glimpse(x, width = NULL, ..., n = 10, max_extra_cols = 20)

## S3 method for class 'SpatVector'
glimpse(x, width = NULL, ..., n = 10, max_extra_cols = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glimpse.Spat_+3A_x">x</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_width">width</code></td>
<td>
<p>Width of output: defaults to the setting of the width option
(if finite) or the width of the console. See <code><a href="dplyr.html#topic+glimpse">dplyr::glimpse()</a></code>.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+as_tibble.Spat">as_tibble()</a></code> methods
for <code>SpatRaster</code> and <code>SpatVector</code>. See <code><a href="#topic+as_tibble.SpatRaster">as_tibble.SpatRaster()</a></code>.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_n">n</code></td>
<td>
<p>Maximum number of rows to show.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_max_extra_cols">max_extra_cols</code></td>
<td>
<p>Number of extra columns or layers to print abbreviated
information for, if <code>n</code> is too small for the <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original <code>x</code> is (invisibly) returned, allowing <code>glimpse()</code> to
be used within a data pipeline.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>print()</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+glimpse">dplyr::glimpse()</a></code> function for
<code style="white-space: pre;">&#8288;Spat*&#8288;</code>. objects.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+formatting">tibble::print.tbl_df()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatVector
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

v %&gt;% glimpse(n = 2)

# Use on a pipeline
v %&gt;%
  glimpse() %&gt;%
  mutate(a = 30) %&gt;%
  # with options
  glimpse(geom = "WKT")

# SpatRaster
r &lt;- rast(system.file("extdata/cyl_elev.tif", package = "tidyterra"))

r %&gt;% glimpse()

# Use on a pipeline
r %&gt;%
  glimpse() %&gt;%
  mutate(b = elevation_m / 100) %&gt;%
  # With options
  glimpse(xy = TRUE)
</code></pre>

<hr>
<h2 id='grass_db'>GRASS color tables</h2><span id='topic+grass_db'></span>

<h3>Description</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> including the color map of
51 gradient palettes. Some palettes includes
also a definition of colors limits that can be used with
<code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>.
</p>


<h3>Format</h3>

<p>A tibble of 2920 rows and 6 columns. with
the following fields:
</p>

<dl>
<dt>pal</dt><dd><p> Name of the palette.</p>
</dd>
<dt>limit</dt><dd><p>(Optional) limit for each color.</p>
</dd>
<dt>r</dt><dd><p>Value of the red channel (RGB color mode).</p>
</dd>
<dt>g</dt><dd><p>Value of the green channel (RGB color mode).</p>
</dd>
<dt>b</dt><dd><p>Value of the blue channel (RGB color mode).</p>
</dd>
<dt>hex</dt><dd><p> Hex code of the color.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Summary of palettes provided, description and recommended use:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>palette</strong> </td><td style="text-align: left;"> <strong>use</strong> </td><td style="text-align: left;"> <strong>description</strong> </td><td style="text-align: left;"> <strong>range</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>aspect</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> aspect oriented grey colors </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>aspectcolr</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> aspect oriented rainbow colors </td><td style="text-align: left;"> 0 to 360 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>bcyr</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> blue through cyan through yellow to red </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>bgyr</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> blue through green through yellow to red </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>blues</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> white to blue </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>byg</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> blue through yellow to green </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>byr</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> blue through yellow to red </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>celsius</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> blue to red for degree Celsius temperature </td><td style="text-align: left;"> -80 to 80 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>corine</code> </td><td style="text-align: left;"> Land Cover </td><td style="text-align: left;"> EU Corine land cover colors </td><td style="text-align: left;"> 111 to 995 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>curvature</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> for terrain curvatures </td><td style="text-align: left;"> -0.1 to 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>differences</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> differences oriented colors </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>elevation</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> maps relative ranges of raster values to elevation color ramp </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>etopo2</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> colors for ETOPO2 worldwide bathymetry/topography </td><td style="text-align: left;"> -11000 to 8850 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>evi</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> enhanced vegetative index colors </td><td style="text-align: left;"> -1 to 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>fahrenheit</code> </td><td style="text-align: left;"> Temperature </td><td style="text-align: left;"> blue to red for Fahrenheit temperature </td><td style="text-align: left;"> -112 to 176 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>forest_cover</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> percentage of forest cover </td><td style="text-align: left;"> 0 to 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>gdd</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> accumulated growing degree days </td><td style="text-align: left;"> 0 to 6000 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>grass</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> GRASS GIS green (perceptually uniform) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>greens</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> white to green </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>grey</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> grey scale </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>gyr</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> green through yellow to red </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>haxby</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> relative colors for bathymetry or topography </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>inferno</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> perceptually uniform sequential color table inferno </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>kelvin</code> </td><td style="text-align: left;"> Temperature </td><td style="text-align: left;"> blue to red for temperature in Kelvin scale </td><td style="text-align: left;"> 193.15 to 353.15 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>magma</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> perceptually uniform sequential color table magma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ndvi</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> Normalized Difference Vegetation Index colors </td><td style="text-align: left;"> -1 to 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ndwi</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> Normalized Difference Water Index colors </td><td style="text-align: left;"> -200 to 200 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>nlcd</code> </td><td style="text-align: left;"> Land Cover </td><td style="text-align: left;"> US National Land Cover Dataset colors </td><td style="text-align: left;"> 0 to 95 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>oranges</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> white to orange </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>plasma</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> perceptually uniform sequential color table plasma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>population</code> </td><td style="text-align: left;"> Human </td><td style="text-align: left;"> color table covering human population classification breaks </td><td style="text-align: left;"> 0 to 1000000 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>population_dens</code> </td><td style="text-align: left;"> Human </td><td style="text-align: left;"> color table covering human population density classification breaks </td><td style="text-align: left;"> 0 to 1000 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>precipitation</code> </td><td style="text-align: left;"> Climate </td><td style="text-align: left;"> precipitation color table (0..2000mm) </td><td style="text-align: left;"> 0 to 7000 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>precipitation_daily</code> </td><td style="text-align: left;"> Climate </td><td style="text-align: left;"> precipitation color table (0..1000mm) </td><td style="text-align: left;"> 0 to 100 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>precipitation_monthly</code> </td><td style="text-align: left;"> Climate </td><td style="text-align: left;"> precipitation color table (0..1000mm) </td><td style="text-align: left;"> 0 to 1000 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rainbow</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> rainbow color table </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ramp</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> color ramp </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>reds</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> white to red </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>roygbiv</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rstcurv</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> terrain curvature (from r.resamp.rst) </td><td style="text-align: left;"> -0.1 to 0.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ryb</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> red through yellow to blue </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>ryg</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> red through yellow to green </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>sepia</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> yellowish-brown through to white </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>slope</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> r.slope.aspect-type slope colors for raster values 0-90 </td><td style="text-align: left;"> 0 to 90 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>soilmoisture</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> soil moisture color table (0.0-1.0) </td><td style="text-align: left;"> 0 to 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>srtm</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> color palette for Shuttle Radar Topography Mission elevation </td><td style="text-align: left;"> -11000 to 8850 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>srtm_plus</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> color palette for Shuttle Radar Topography Mission elevation (with seafloor colors) </td><td style="text-align: left;"> -11000 to 8850 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>terrain</code> </td><td style="text-align: left;"> Topography </td><td style="text-align: left;"> global elevation color table covering -11000 to +8850m </td><td style="text-align: left;"> -11000 to 8850 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>viridis</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> perceptually uniform sequential color table viridis </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>water</code> </td><td style="text-align: left;"> Natural </td><td style="text-align: left;"> water depth </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>wave</code> </td><td style="text-align: left;"> General </td><td style="text-align: left;"> color wave </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+mappal">terra::map.pal()</a></code>
</p>


<h3>Source</h3>

<p>Derived from <a href="https://github.com/OSGeo/grass/tree/main/lib/gis/colors">https://github.com/OSGeo/grass/tree/main/lib/gis/colors</a>. See
also <a href="https://grass.osgeo.org/grass83/manuals/r.colors.html">r.color - GRASS GIS Manual</a>.
</p>


<h3>References</h3>

<p>GRASS Development Team (2024). <em>Geographic Resources Analysis Support System
(GRASS) Software, Version 8.3.2</em>. Open Source Geospatial Foundation, USA.
<a href="https://grass.osgeo.org">https://grass.osgeo.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_grass_c">scale_fill_grass_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>,
<code><a href="#topic+princess_db">princess_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("grass_db")

grass_db
# Select a palette

srtm_plus &lt;- grass_db %&gt;%
  filter(pal == "srtm_plus")

f &lt;- system.file("extdata/asia.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = srtm_plus$hex)

# Use with limits
p +
  scale_fill_gradientn(
    colors = srtm_plus$hex,
    values = scales::rescale(srtm_plus$limit),
    limit = range(srtm_plus$limit),
    na.value = "lightblue"
  )

</code></pre>

<hr>
<h2 id='group_data.SpatVector'>Grouping metadata for <code>SpatVector</code> objects</h2><span id='topic+group_data.SpatVector'></span><span id='topic+group_keys.SpatVector'></span><span id='topic+group_indices.SpatVector'></span><span id='topic+group_vars.SpatVector'></span><span id='topic+groups.SpatVector'></span><span id='topic+group_size.SpatVector'></span><span id='topic+n_groups.SpatVector'></span>

<h3>Description</h3>

<p>This collection of functions accesses data about grouped <code>SpatVector</code> objects
in various ways:
</p>

<ul>
<li> <p><code><a href="#topic+group_data">group_data()</a></code> returns a tibble that defines the grouping structure.
The columns give the values of the grouping variables. The last column,
always called <code>.rows</code>, is a list of integer vectors that gives the
location of the rows in each group.
</p>
</li>
<li> <p><code><a href="#topic+group_keys">group_keys()</a></code> returns a tibble describing the groups.
</p>
</li>
<li> <p><code><a href="#topic+group_rows">group_rows()</a></code> returns a list of integer vectors giving the rows that
each group contains.
</p>
</li>
<li> <p><code><a href="#topic+group_indices">group_indices()</a></code> returns an integer vector the same length as <code>.data</code>
that gives the group that each row belongs to.
</p>
</li>
<li> <p><code><a href="#topic+group_vars">group_vars()</a></code> gives names of grouping variables as character vector.
</p>
</li>
<li> <p><code><a href="#topic+groups">groups()</a></code> gives the names of the grouping variables as a list of symbols.
</p>
</li>
<li> <p><code><a href="#topic+group_size">group_size()</a></code> gives the size of each group.
</p>
</li>
<li> <p><code><a href="#topic+n_groups">n_groups()</a></code> gives the total number of groups.
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+group_data">dplyr::group_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
group_data(.data)

## S3 method for class 'SpatVector'
group_keys(.tbl, ...)

## S3 method for class 'SpatVector'
group_indices(.data, ...)

## S3 method for class 'SpatVector'
group_vars(x)

## S3 method for class 'SpatVector'
groups(x)

## S3 method for class 'SpatVector'
group_size(x)

## S3 method for class 'SpatVector'
n_groups(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_data.SpatVector_+3A_.data">.data</code>, <code id="group_data.SpatVector_+3A_.tbl">.tbl</code>, <code id="group_data.SpatVector_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="group_data.SpatVector_+3A_...">...</code></td>
<td>
<p>Use of <code>...</code> is now deprecated; please use <code>group_by()</code> first
instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the description of the function. The results are usually tibbles,
lists or vectors. These functions does not return <code>SpatVector</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
v$gr_1 &lt;- rep_len(c("A", "A", "B"), length.out = nrow(v))
v$gr_2 &lt;- rep_len(c("C", "D"), length.out = nrow(v))

# Ungrouped

n_groups(v)

group_vars(v)

group_keys(v)

group_size(v)

groups(v)

group_rows(v)

group_data(v)

group_indices(v)

# Grouped by one var
gv &lt;- group_by(v, gr_1)

n_groups(gv)

group_vars(gv)

group_keys(gv)

group_size(gv)

groups(gv)

group_rows(gv)

group_data(gv)

group_indices(gv)

# Grouped by several vars

gv2 &lt;- group_by(v, gr_1, gr_2)

n_groups(gv2)

group_vars(gv2)

group_keys(gv2)

group_size(gv2)

groups(gv2)

group_rows(gv2)

group_data(gv2)

group_indices(gv2)
</code></pre>

<hr>
<h2 id='group-by.SpatVector'>Group a <code>SpatVector</code> by one or more variables</h2><span id='topic+group-by.SpatVector'></span><span id='topic+group_by.SpatVector'></span><span id='topic+ungroup.SpatVector'></span>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables.
<code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code> adds new attributes to an existing <code>SpatVector</code>
indicating the corresponding groups. See <strong>Methods</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))

## S3 method for class 'SpatVector'
ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group-by.SpatVector_+3A_.data">.data</code>, <code id="group-by.SpatVector_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code> object. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> on <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>SpatVector</code> object with an additional attribute.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> family functions for
<code>SpatVector</code> objects.
</p>
<p><strong>When mixing</strong> <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> <strong>and</strong> <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> <strong>syntax</strong> on a
grouped <code>SpatVector</code> (i.e, subsetting a <code>SpatVector</code> like <code>v[1:3,1:2]</code>) the
<code>groups</code> attribute can be corrupted. <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> would try to
re-group the <code>SpatVector</code>. This would be triggered the next time you use a
<a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verb on your <code>SpatVector</code>.
</p>
<p>Note also that some operations (as <code>terra::spatSample()</code>) would create a new
<code>SpatVector</code>. In these cases, the result won't preserve the <code>groups</code>
attribute. Use <code><a href="#topic+group_by">group_by()</a></code> to re-group.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)
f &lt;- system.file("ex/lux.shp", package = "terra")
p &lt;- vect(f)


by_name1 &lt;- p %&gt;% group_by(NAME_1)

# grouping doesn't change how the SpatVector looks
by_name1

# But add metadata for grouping: See the coercion to tibble

# Not grouped
p_tbl &lt;- as_tibble(p)
class(p_tbl)
head(p_tbl, 3)

# Grouped
by_name1_tbl &lt;- as_tibble(by_name1)
class(by_name1_tbl)
head(by_name1_tbl, 3)


# It changes how it acts with the other dplyr verbs:
by_name1 %&gt;% summarise(
  pop = mean(POP),
  area = sum(AREA)
)

# Each call to summarise() removes a layer of grouping
by_name2_name1 &lt;- p %&gt;% group_by(NAME_2, NAME_1)

by_name2_name1
group_data(by_name2_name1)

by_name2 &lt;- by_name2_name1 %&gt;% summarise(n = dplyr::n())
by_name2
group_data(by_name2)

# To removing grouping, use ungroup
by_name2 %&gt;%
  ungroup() %&gt;%
  summarise(n = sum(n))

# By default, group_by() overrides existing grouping
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2) %&gt;%
  group_vars()


# Use add = TRUE to instead append
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2, .add = TRUE) %&gt;%
  group_vars()

# You can group by expressions: this is a short-hand
# for a mutate() followed by a group_by()
p %&gt;%
  group_by(ID_COMB = ID_1 * 100 / ID_2) %&gt;%
  relocate(ID_COMB, .before = 1)

</code></pre>

<hr>
<h2 id='hypsometric_tints_db'>Hypsometric palettes database</h2><span id='topic+hypsometric_tints_db'></span>

<h3>Description</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> including the color map of
33 gradient palettes. All the
palettes includes also a definition of colors limits in terms of elevation
(meters), that can be used with <code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>.
</p>


<h3>Format</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> of 1102 rows and
6 columns. with the following fields:
</p>

<dl>
<dt>pal</dt><dd><p> Name of the palette.</p>
</dd>
<dt>limit</dt><dd><p>Recommended elevation limit (in meters) for each color.</p>
</dd>
<dt>r</dt><dd><p>Value of the red channel (RGB color mode).</p>
</dd>
<dt>g</dt><dd><p>Value of the green channel (RGB color mode).</p>
</dd>
<dt>b</dt><dd><p>Value of the blue channel (RGB color mode).</p>
</dd>
<dt>hex</dt><dd><p> Hex code of the color.</p>
</dd>
</dl>



<h3>Source</h3>

<p>cpt-city: <a href="http://seaviewsensing.com/pub/cpt-city/">http://seaviewsensing.com/pub/cpt-city/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_hypso_c">scale_fill_hypso_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+grass_db">grass_db</a></code>,
<code><a href="#topic+princess_db">princess_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("hypsometric_tints_db")

hypsometric_tints_db

# Select a palette
wikicols &lt;- hypsometric_tints_db %&gt;%
  filter(pal == "wiki-2.0")

f &lt;- system.file("extdata/asia.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = wikicols$hex)

# Use with limits
p +
  scale_fill_gradientn(
    colors = wikicols$hex,
    values = scales::rescale(wikicols$limit),
    limit = range(wikicols$limit)
  )

</code></pre>

<hr>
<h2 id='is_grouped_spatvector'>A grouped <code>SpatVector</code></h2><span id='topic+is_grouped_spatvector'></span>

<h3>Description</h3>

<p>The easiest way to create a grouped <code>SpatVector</code> is to call the
<code>group_by()</code> method on a <code>SpatVector</code>: this will take care of capturing
the unevaluated expressions for you. See <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code> for details.
</p>
<p>This function is the adapted version of <code><a href="dplyr.html#topic+grouped_df">dplyr::is_grouped_df()</a></code>.
</p>
<p>See also <code><a href="#topic+group_data.SpatVector">group_data.SpatVector()</a></code> for the accessory functions that retrieve
various metadata from a grouped <code>SpatVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_grouped_spatvector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_grouped_spatvector_+3A_x">x</code></td>
<td>
<p>a <code>SpatVector</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>

<hr>
<h2 id='is_regular_grid'>Check if x and y positions conforms a regular grid</h2><span id='topic+is_regular_grid'></span>

<h3>Description</h3>

<p>Assess if the coordinates x,y of an object conforms a regular grid. This
function is called by its side effects.
</p>
<p>This function is internally called by <code><a href="#topic+as_spatraster">as_spatraster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_regular_grid(xy, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_regular_grid_+3A_xy">xy</code></td>
<td>
<p>A matrix, data frame or tibble of at least two columns representing
x and y coordinates.</p>
</td></tr>
<tr><td><code id="is_regular_grid_+3A_digits">digits</code></td>
<td>
<p>integer to set the precision for detecting whether points are
on a regular grid (a low number of digits is a low precision).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible()</code> if is regular or an error message otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_spatraster">as_spatraster()</a></code>
</p>
<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- matrix(1:90, nrow = 45, ncol = 2)

is_regular_grid(p)


# Jitter location
set.seed(1234)
jitter &lt;- runif(length(p)) / 10e4
p_jitter &lt;- p + jitter

# Need to adjust digits
is_regular_grid(p_jitter, digits = 4)

</code></pre>

<hr>
<h2 id='mutate-joins.SpatVector'>Mutating joins for <code>SpatVector</code> objects</h2><span id='topic+mutate-joins.SpatVector'></span><span id='topic+inner_join.SpatVector'></span><span id='topic+left_join.SpatVector'></span><span id='topic+right_join.SpatVector'></span><span id='topic+full_join.SpatVector'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>
<p>See <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate-joins.SpatVector_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code> created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_y">y</code></td>
<td>
<p>A data frame or other object coercible to a data frame. <strong>If a
<code>SpatVector</code> of <code>sf</code> object</strong> is provided it would return an error (see
<code><a href="terra.html#topic+intersect">terra::intersect()</a></code> for performing spatial joins).</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> family
</p>


<h4><code>SpatVector</code></h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>x</code> for the records that matches the join
conditions.
</p>
<p>Note that for <code><a href="#topic+right_join">right_join()</a></code> and <code><a href="#topic+full_join">full_join()</a></code> it is possible to return
empty geometries (since <code>y</code> is expected to be a data frame with no
geometries). Although this kind of joining operations may not be common on
spatial manipulation, it is possible that the function crashes, since
handling of <code>EMPTY</code> geometries differs on <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> and <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code>, <code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on pairs <code>Spat*</code>/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)
# Vector
v &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# A data frame
df &lt;- data.frame(
  cpro = sprintf("%02d", 1:10),
  x = runif(10),
  y = runif(10),
  letter = rep_len(LETTERS[1:3], length.out = 10)
)

# Inner join
inner &lt;- v %&gt;% inner_join(df)

nrow(inner)
autoplot(inner, aes(fill = letter)) + ggtitle("Inner Join")


# Left join

left &lt;- v %&gt;% left_join(df)
nrow(left)

autoplot(left, aes(fill = letter)) + ggtitle("Left Join")


# Right join
right &lt;- v %&gt;% right_join(df)
nrow(right)

autoplot(right, aes(fill = letter)) + ggtitle("Right Join")

# There are empty geometries, check with data from df
ggplot(right, aes(x, y)) +
  geom_point(aes(color = letter))


# Full join
full &lt;- v %&gt;% full_join(df)
nrow(full)

autoplot(full, aes(fill = letter)) + ggtitle("Full Join")

# Check with data from df
ggplot(full, aes(x, y)) +
  geom_point(aes(color = letter))

</code></pre>

<hr>
<h2 id='mutate.Spat'>Create, modify, and delete cell values/layers/attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</h2><span id='topic+mutate.Spat'></span><span id='topic+mutate.SpatRaster'></span><span id='topic+transmute.Spat'></span><span id='topic+mutate.SpatVector'></span><span id='topic+transmute.SpatRaster'></span><span id='topic+transmute.SpatVector'></span>

<h3>Description</h3>

<p><code>mutate()</code> adds new layers/attributes and preserves existing ones on a
<code style="white-space: pre;">&#8288;Spat*&#8288;</code> object. <code>transmute()</code> adds new layers/attributes and drops existing
ones. New variables overwrite existing variables of the same name. Variables
can be removed by setting their value to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
mutate(.data, ...)

## S3 method for class 'SpatVector'
mutate(.data, ...)

## S3 method for class 'SpatRaster'
transmute(.data, ...)

## S3 method for class 'SpatVector'
transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the layer/attribute in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p>Some <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> methods for modifying cell values:
<code><a href="terra.html#topic+ifelse">terra::ifel()</a></code>, <code><a href="terra.html#topic+classify">terra::classify()</a></code>, <code><a href="terra.html#topic+clamp">terra::clamp()</a></code>, <code><a href="terra.html#topic+app">terra::app()</a></code>,
<code><a href="terra.html#topic+lapp">terra::lapp()</a></code>, <code><a href="terra.html#topic+tapp">terra::tapp()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>
functions.
</p>


<h4><code>SpatRaster</code></h4>

<p>Add new layers and preserves existing ones. The result is a
<code>SpatRaster</code> with the same extent, resolution and crs than <code>.data</code>. Only the
values (and possibly the number) of layers is modified.
</p>
<p><code>transmute()</code> would keep only the layers created with <code>...</code>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> with the modified (and possibly renamed)
attributes on the function call.
</p>
<p><code>transmute()</code> would keep only the attributes created with <code>...</code>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code> methods.
</p>
<p><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> provides several ways to modify <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects:
</p>

<ul>
<li> <p><code><a href="terra.html#topic+ifelse">terra::ifel()</a></code>.
</p>
</li>
<li> <p><code><a href="terra.html#topic+classify">terra::classify()</a></code>.
</p>
</li>
<li> <p><code><a href="terra.html#topic+clamp">terra::clamp()</a></code>.
</p>
</li>
<li> <p><code><a href="terra.html#topic+app">terra::app()</a></code>, <code><a href="terra.html#topic+lapp">terra::lapp()</a></code>, <code><a href="terra.html#topic+tapp">terra::tapp()</a></code>.
</p>
</li></ul>

<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatRaster method
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
spatrast &lt;- rast(f)

mod &lt;- spatrast %&gt;%
  mutate(exp_lyr1 = exp(tavg_04 / 10)) %&gt;%
  select(tavg_04, exp_lyr1)

mod
plot(mod)

# SpatVector method
f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- vect(f)

v %&gt;%
  mutate(cpro2 = paste0(cpro, "-CyL")) %&gt;%
  select(cpro, cpro2)
</code></pre>

<hr>
<h2 id='pivot_longer.SpatVector'>Pivot <code>SpatVector</code> from wide to long</h2><span id='topic+pivot_longer.SpatVector'></span>

<h3>Description</h3>

<p><code>pivot_longer()</code> &quot;lengthens&quot; data, increasing the number of rows and
decreasing the number of columns. The inverse transformation is
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector()</a></code>
</p>
<p>Learn more in <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
pivot_longer(
  data,
  cols,
  ...,
  cols_vary = "fastest",
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = NULL,
  names_transform = NULL,
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = NULL,
  values_transform = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_longer.SpatVector_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> to pivot.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_cols_vary">cols_vary</code></td>
<td>
<p>When pivoting <code>cols</code> into longer format, how should the
output rows be arranged relative to their original row number?
</p>

<ul>
<li> <p><code>"fastest"</code>, the default, keeps individual rows from <code>cols</code> close
together in the output. This often produces intuitively ordered output
when you have at least one key column from <code>data</code> that is not involved in
the pivoting process.
</p>
</li>
<li> <p><code>"slowest"</code> keeps individual columns from <code>cols</code> close together in the
output. This often produces intuitively ordered output when you utilize
all of the columns from <code>data</code> in the pivoting process.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_sep">names_sep</code>, <code id="pivot_longer.SpatVector_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer.SpatVector_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_transform">names_transform</code>, <code id="pivot_longer.SpatVector_+3A_values_transform">values_transform</code></td>
<td>
<p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer.SpatVector_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code> function.
</p>


<h4><code>SpatVector</code></h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>data</code>.
</p>



<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> verbs for pivoting:
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> methods:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>,
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector</a>()</code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(dplyr)
library(tidyr)
library(ggplot2)
library(terra)

temp &lt;- rast((system.file("extdata/cyl_temp.tif", package = "tidyterra")))
cyl &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra")) %&gt;%
  project(temp)

# Add average temp

temps &lt;- terra::extract(temp, cyl, fun = "mean", na.rm = TRUE, xy = TRUE)
cyl_temp &lt;- cbind(cyl, temps) %&gt;%
  glimpse()

# And pivot long for plot
cyl_temp %&gt;%
  pivot_longer(
    cols = tavg_04:tavg_06,
    names_to = "label",
    values_to = "temp"
  ) %&gt;%
  ggplot() +
  geom_spatvector(aes(fill = temp)) +
  facet_wrap(~label, ncol = 1) +
  scale_fill_whitebox_c(palette = "muted")

</code></pre>

<hr>
<h2 id='pivot_wider.SpatVector'>Pivot <code>SpatVector</code> from long to wide</h2><span id='topic+pivot_wider.SpatVector'></span>

<h3>Description</h3>

<p><code><a href="#topic+pivot_wider">pivot_wider()</a></code> &quot;widens&quot; a <code>SpatVector</code>, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
pivot_wider(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = "name",
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = "value",
  values_fill = NULL,
  values_fn = NULL,
  unused_fn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_wider.SpatVector_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> to pivot.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_id_cols">id_cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns
that uniquely identify each observation. Typically used when you have
redundant variables, i.e. variables whose values are perfectly correlated
with existing variables.
</p>
<p>Defaults to all columns in <code>data</code> except for the columns specified through
<code>names_from</code> and <code>values_from</code>. If a
<code><a href="tidyr.html#topic+tidyr_tidy_select">tidyselect</a></code> expression is supplied, it
will be evaluated on <code>data</code> after removing the columns specified through
<code>names_from</code> and <code>values_from</code>.
</p>
<p>Note that &quot;<code>geometry</code>&quot; columns is sticky, hence it would be
removed from <code>names_from</code> and <code>values_from</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_id_expand">id_expand</code></td>
<td>
<p>Should the values in the <code>id_cols</code> columns be expanded by
<code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more rows, the output will
contain a complete expansion of all possible values in <code>id_cols</code>. Implicit
factor levels that aren't represented in the data will become explicit.
Additionally, the row values corresponding to the expanded <code>id_cols</code> will
be sorted.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_from">names_from</code>, <code id="pivot_wider.SpatVector_+3A_values_from">values_from</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_vary">names_vary</code></td>
<td>
<p>When <code>names_from</code> identifies a column (or columns) with
multiple unique values, and multiple <code>values_from</code> columns are provided,
in what order should the resulting column names be combined?
</p>

<ul>
<li> <p><code>"fastest"</code> varies <code>names_from</code> values fastest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value1_name2, value2_name1, value2_name2&#8288;</code>. This is the default.
</p>
</li>
<li> <p><code>"slowest"</code> varies <code>names_from</code> values slowest, resulting in a column
naming scheme of the form: <code style="white-space: pre;">&#8288;value1_name1, value2_name1, value1_name2, value2_name2&#8288;</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_expand">names_expand</code></td>
<td>
<p>Should the values in the <code>names_from</code> columns be expanded
by <code><a href="tidyr.html#topic+expand">expand()</a></code> before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in <code>names_from</code>. Implicit factor levels that aren't
represented in the data will become explicit. Additionally, the column
names will be sorted, identical to what <code>names_sort</code> would produce.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_values_fn">values_fn</code></td>
<td>
<p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</td></tr>
<tr><td><code id="pivot_wider.SpatVector_+3A_unused_fn">unused_fn</code></td>
<td>
<p>Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by <code>id_cols</code>,
<code>names_from</code>, or <code>values_from</code>).
</p>
<p>The default drops all unused columns from the result.
</p>
<p>This can be a named list if you want to apply different aggregations
to different unused columns.
</p>
<p><code>id_cols</code> must be supplied for <code>unused_fn</code> to be useful, since otherwise
all unspecified columns will be considered <code>id_cols</code>.
</p>
<p>This is similar to grouping by the <code>id_cols</code> then summarizing the
unused columns using <code>unused_fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code> object.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code> function.
</p>


<h4><code>SpatVector</code></h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>data</code>.
</p>



<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> verbs for pivoting:
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> methods:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>,
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector</a>()</code>,
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tidyr)
library(ggplot2)

cyl &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# Add extra row with info
xtra &lt;- cyl %&gt;%
  slice(c(2, 3)) %&gt;%
  mutate(
    label = "extra",
    value = TRUE
  ) %&gt;%
  rbind(cyl, .) %&gt;%
  glimpse()

# Pivot by geom
xtra %&gt;%
  pivot_wider(
    id_cols = iso2:name, values_from = value,
    names_from = label
  )

</code></pre>

<hr>
<h2 id='princess_db'>Princess palettes database</h2><span id='topic+princess_db'></span>

<h3>Description</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> including the color map of
15 gradient palettes.
</p>


<h3>Format</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> of 75 rows and
5 columns. with the following fields:
</p>

<dl>
<dt>pal</dt><dd><p> Name of the palette.</p>
</dd>
<dt>r</dt><dd><p>Value of the red channel (RGB color mode).</p>
</dd>
<dt>g</dt><dd><p>Value of the green channel (RGB color mode).</p>
</dd>
<dt>b</dt><dd><p>Value of the blue channel (RGB color mode).</p>
</dd>
<dt>hex</dt><dd><p> Hex code of the color.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://leahsmyth.github.io/Princess-Colour-Schemes/index.html">https://leahsmyth.github.io/Princess-Colour-Schemes/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_princess_c">scale_fill_princess_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+grass_db">grass_db</a></code>,
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("princess_db")

princess_db

# Select a palette
maori &lt;- princess_db %&gt;%
  filter(pal == "maori")

f &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = maori$hex)

</code></pre>

<hr>
<h2 id='pull_crs'>Extract CRS on WKT format</h2><span id='topic+pull_crs'></span>

<h3>Description</h3>

<p>Extract the WKT version of the CRS associated to a string, number of
sf/Spat* object.
</p>
<p>The
<a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems">Well-known text (WKT)</a>
representation of coordinate reference systems (CRS) is a character string
that identifies precisely the parameters of each CRS. This is the current
standard used on <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> and <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_crs(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull_crs_+3A_.data">.data</code></td>
<td>
<p>Input potentially including or representing a CRS. It could be
a <code>sf/sfc</code> object, a <code>SpatRaster/SpatVector</code> object, a <code>crs</code> object from
<code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>, a character (for example a <a href="https://proj.org/en/9.3/operations/projections/index.html">proj4 string</a>) or a
integer (representing an <a href="https://epsg.io/">EPSG</a> code).</p>
</td></tr>
<tr><td><code id="pull_crs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the WKT representation is the same, <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> and <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a>
API slightly differs. For example, <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> can do:
</p>
<p><code>sf::st_transform(x, 25830)</code>
</p>
<p>While <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> equivalent is:
</p>
<p><code>terra::project(bb, "epsg:25830")</code>
</p>
<p>Knowing the WKT would help to smooth workflows when working with different
packages and object types.
</p>


<h3>Value</h3>

<p>A WKT representation of the corresponding CRS.
</p>


<h3>Internals</h3>

<p>This is a thin wrapper of <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> and <code><a href="terra.html#topic+crs">terra::crs()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">terra::crs()</a></code>, <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> for knowing how these packages handle
CRS definitions.
</p>
<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sf objects

sfobj &lt;- sf::st_as_sfc("MULTIPOINT ((0 0), (1 1))", crs = 4326)

fromsf1 &lt;- pull_crs(sfobj)
fromsf2 &lt;- pull_crs(sf::st_crs(sfobj))

# terra

v &lt;- terra::vect(sfobj)
r &lt;- terra::rast(v)

fromterra1 &lt;- pull_crs(v)
fromterra2 &lt;- pull_crs(r)

# integers
fromint &lt;- pull_crs(4326)

# Characters
fromchar &lt;- pull_crs("epsg:4326")


all(
  fromsf1 == fromsf2,
  fromsf2 == fromterra1,
  fromterra1 == fromterra2,
  fromterra2 == fromint,
  fromint == fromchar
)

cat(fromsf1)
</code></pre>

<hr>
<h2 id='pull.Spat'>Extract a single layer/attribute</h2><span id='topic+pull.Spat'></span><span id='topic+pull.SpatRaster'></span><span id='topic+pull.SpatVector'></span>

<h3>Description</h3>

<p><code>pull()</code> is similar to <code>$</code> on a data frame. It's mostly useful because it
looks a little nicer in pipes and it can optionally name the output.
</p>
<p><strong>It is possible to extract the geographic coordinates of a <code>SpatRaster</code></strong>.
You need to use <code>pull(.data, x, xy = TRUE)</code>. <code>x</code> and <code>y</code> are reserved
names on terra, since they refer to the geographic coordinates of the layer.
</p>
<p>See <strong>Examples</strong> and section <strong>About layer names</strong> on <code><a href="#topic+as_tibble.Spat">as_tibble.Spat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
pull(.data, var = -1, name = NULL, ...)

## S3 method for class 'SpatVector'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal layer/attribute name.
</p>
</li>
<li><p> a positive integer, giving the position counting from the left.
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last layer/attribute (on the assumption that's the
column you've created most recently).</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used as
names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+as_tibble.Spat">as_tibble.Spat()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same number of cells/geometries as <code>.data</code>.
</p>
<p>On <code>SpatRaster</code> objects, note that the default (<code>na.rm = FALSE</code>) would remove
empty cells, so you may need to pass (<code>na.rm = FALSE</code>) to <code>...</code>. See
<code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+values">terra::values()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> function. This is done
by coercing the <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object to a tibble first (see <a href="#topic+as_tibble.Spat">as_tibble.Spat</a>) and
then using <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> method over the tibble.
</p>


<h4><code>SpatRaster</code></h4>

<p>When passing option <code>na.rm = TRUE</code> to <code>...</code>, only cells with a value
distinct to <code>NA</code> are extracted. See <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>.
</p>
<p>If <code>xy = TRUE</code> option is passed to <code>...</code>, two columns names <code>x</code> and <code>y</code>
(corresponding to the geographic coordinates of each cell) are available
in position <code>1</code> and <code>2</code>. Hence, <code>pull(.data, 1)</code> and
<code>pull(.data, 1, xy = TRUE)</code> return different result.
</p>



<h4><code>SpatVector</code></h4>

<p>When passing <code>geom = "WKT"/geom = "HEX"</code> to <code>...</code>,  the geometry of the
<code>SpatVector</code> can be pulled passing <code>var = geometry</code>. Similarly to
<code>SpatRaster</code> method, when using <code>geom = "XY"</code> the <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates can be
pulled with <code>var = x/var = y</code>. See  <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code> options.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
r &lt;- rast(f)

# Extract second layer
r %&gt;%
  pull(2) %&gt;%
  head()

# With xy the first two cols are `x` (longitude) and `y` (latitude)

r %&gt;%
  pull(2, xy = TRUE) %&gt;%
  head()

# With renaming

r %&gt;%
  mutate(cat = cut(cyl_tile_3, c(0, 100, 300))) %&gt;%
  pull(cyl_tile_3, name = cat) %&gt;%
  head()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+arrange'></span><span id='topic+as_tibble'></span><span id='topic+autoplot'></span><span id='topic+count'></span><span id='topic+tally'></span><span id='topic+distinct'></span><span id='topic+drop_na'></span><span id='topic+fill'></span><span id='topic+filter'></span><span id='topic+fortify'></span><span id='topic+glimpse'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+group_by_drop_default'></span><span id='topic+group_data'></span><span id='topic+group_keys'></span><span id='topic+group_rows'></span><span id='topic+group_indices'></span><span id='topic+group_vars'></span><span id='topic+groups'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+full_join'></span><span id='topic+semi_join'></span><span id='topic+anti_join'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+pivot_longer'></span><span id='topic+pivot_wider'></span><span id='topic+pull'></span><span id='topic+relocate'></span><span id='topic+rename'></span><span id='topic+rename_with'></span><span id='topic+replace_na'></span><span id='topic+rowwise'></span><span id='topic+select'></span><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_max'></span><span id='topic+slice_min'></span><span id='topic+slice_tail'></span><span id='topic+slice_sample'></span><span id='topic+summarise'></span><span id='topic+summarize'></span><span id='topic+aes'></span><span id='topic+after_stat'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="dplyr.html#topic+distinct">distinct</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+glimpse">glimpse</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default</a></code>, <code><a href="dplyr.html#topic+group_data">group_data</a></code>, <code><a href="dplyr.html#topic+group_data">group_indices</a></code>, <code><a href="dplyr.html#topic+group_data">group_keys</a></code>, <code><a href="dplyr.html#topic+group_data">group_rows</a></code>, <code><a href="dplyr.html#topic+group_data">group_size</a></code>, <code><a href="dplyr.html#topic+group_data">group_vars</a></code>, <code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+group_data">n_groups</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+relocate">relocate</a></code>, <code><a href="dplyr.html#topic+rename">rename</a></code>, <code><a href="dplyr.html#topic+rename">rename_with</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+rowwise">rowwise</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+slice">slice_head</a></code>, <code><a href="dplyr.html#topic+slice">slice_max</a></code>, <code><a href="dplyr.html#topic+slice">slice_min</a></code>, <code><a href="dplyr.html#topic+slice">slice_sample</a></code>, <code><a href="dplyr.html#topic+slice">slice_tail</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+count">tally</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+aes_eval">after_stat</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+fortify">fortify</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+drop_na">drop_na</a></code>, <code><a href="tidyr.html#topic+fill">fill</a></code>, <code><a href="tidyr.html#topic+pivot_longer">pivot_longer</a></code>, <code><a href="tidyr.html#topic+pivot_wider">pivot_wider</a></code>, <code><a href="tidyr.html#topic+replace_na">replace_na</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relocate.Spat'>Change layer/attribute order</h2><span id='topic+relocate.Spat'></span><span id='topic+relocate.SpatRaster'></span><span id='topic+relocate.SpatVector'></span>

<h3>Description</h3>

<p>Use <code>relocate()</code> to change layer/attribute positions, using the same syntax
as <code><a href="#topic+select.Spat">select.Spat</a></code> to make it easy to move blocks of
layers/attributes at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
relocate(.data, ..., .before = NULL, .after = NULL)

## S3 method for class 'SpatVector'
relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relocate.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="relocate.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; layers/attributes to
move.</p>
</td></tr>
<tr><td><code id="relocate.Spat_+3A_.before">.before</code>, <code id="relocate.Spat_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination
of layers/attributes selected by <code>...</code>. Supplying neither will move
layers/attributes to the left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>terra::subset(data, c("name_layer", "name_other_layer"))</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>Relocate layers of a <code>SpatRaster</code>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> with the attributes on a different order.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)


f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
spatrast &lt;- rast(f) %&gt;% mutate(aa = 1, bb = 2, cc = 3)

names(spatrast)


spatrast %&gt;%
  relocate(bb, .before = cyl_tile_3) %&gt;%
  relocate(cyl_tile_1, .after = last_col())

</code></pre>

<hr>
<h2 id='rename.Spat'>Rename layers/attributes</h2><span id='topic+rename.Spat'></span><span id='topic+rename.SpatRaster'></span><span id='topic+rename_with.SpatRaster'></span><span id='topic+rename.SpatVector'></span><span id='topic+rename_with.SpatVector'></span>

<h3>Description</h3>

<p><code>rename()</code> changes the names of individual layers/attributes using
<code>new_name = old_name</code> syntax; <code>rename_with()</code> renames layers/attributes
using a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
rename(.data, ...)

## S3 method for class 'SpatRaster'
rename_with(.data, .fn, .cols = everything(), ...)

## S3 method for class 'SpatVector'
rename(.data, ...)

## S3 method for class 'SpatVector'
rename_with(.data, .fn, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="rename.Spat_+3A_...">...</code></td>
<td>
<p>Depending on the function:
</p>

<ul>
<li><p> For <code style="white-space: pre;">&#8288;rename.Spat*()&#8288;</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;.
Use <code>new_name = old_name</code> to rename selected variables.
</p>
</li>
<li><p> For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rename.Spat_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="rename.Spat_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code style="white-space: pre;">&#8288;names(Spat*) &lt;- c("a", "b", "c")&#8288;</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>Rename layers of a <code>SpatRaster</code>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> with the renamed attributes on the function
call.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
spatrast &lt;- rast(f) %&gt;% mutate(aa = 1, bb = 2, cc = 3)

spatrast

spatrast %&gt;% rename(
  this_first = cyl_tile_1,
  this_second = cyl_tile_2
)

spatrast %&gt;% rename_with(
  toupper,
  .cols = starts_with("c")
)
</code></pre>

<hr>
<h2 id='replace_na.Spat'>Replace <code>NA</code>s with specified values</h2><span id='topic+replace_na.Spat'></span><span id='topic+replace_na.SpatRaster'></span><span id='topic+replace_na.SpatVector'></span>

<h3>Description</h3>

<p>Replace <code>NA</code> values on layers/attributes with specified values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
replace_na(data, replace = list(), ...)

## S3 method for class 'SpatVector'
replace_na(data, replace, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_na.Spat_+3A_data">data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="replace_na.Spat_+3A_replace">replace</code></td>
<td>
<p>list of values, with one value for each layer/attribute that
has <code>NA</code> values to be replaced.</p>
</td></tr>
<tr><td><code id="replace_na.Spat_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>data</code>. Geometries and
spatial attributes are preserved.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p>Use <code style="white-space: pre;">&#8288;r[is.na(r)] &lt;- &lt;replacement&gt;&#8288;</code>
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> verbs for handling missing values:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=tidyr"><span class="pkg">tidyr</span></a> methods:
<code><a href="#topic+drop_na.Spat">drop_na.Spat</a></code>,
<code><a href="#topic+fill.SpatVector">fill.SpatVector</a>()</code>,
<code><a href="#topic+pivot_longer.SpatVector">pivot_longer.SpatVector</a>()</code>,
<code><a href="#topic+pivot_wider.SpatVector">pivot_wider.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

r %&gt;% plot()

r %&gt;%
  replace_na(list(tavg_04 = 6, tavg_06 = 20)) %&gt;%
  plot()

</code></pre>

<hr>
<h2 id='rowwise.SpatVector'>Group <code>SpatVector</code> objects by rows</h2><span id='topic+rowwise.SpatVector'></span>

<h3>Description</h3>

<p><code>rowwise()</code> allows you to compute on a <code>SpatVector</code> a row-at-a-time.
This is most useful when a vectorised function doesn't exist.
</p>
<p>Most <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs implementation in <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> preserve
row-wise grouping, with the exception of <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>. You can
explicitly ungroup with <code><a href="#topic+ungroup.SpatVector">ungroup.SpatVector()</a></code> or <code><a href="#topic+as_tibble">as_tibble()</a></code>, or convert
to a grouped <code>SpatVector</code> with <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
rowwise(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowwise.SpatVector_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> object. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="rowwise.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to be
preserved when calling <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>. This is typically a set
of variables whose combination uniquely identify each row. See
<code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> on <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>.
</p>


<h3>Value</h3>

<p>The same <code>SpatVector</code> object with an additional attribute.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code> function for
<code>SpatVector</code> objects.
</p>
<p><strong>When mixing</strong> <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> <strong>and</strong> <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> <strong>syntax</strong> on a
row-wise <code>SpatVector</code> (i.e, subsetting a <code>SpatVector</code> like <code>v[1:3,1:2]</code>) the
<code>groups</code> attribute can be corrupted. <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> would try to
re-generate the <code>SpatVector</code>. This would be triggered the next time you use
a <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verb on your <code>SpatVector</code>.
</p>
<p>Note also that some operations (as <code>terra::spatSample()</code>) would create a new
<code>SpatVector</code>. In these cases, the result won't preserve the <code>groups</code>
attribute. Use <code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector()</a></code> to re-group.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(dplyr)

v &lt;- terra::vect(system.file("shape/nc.shp", package = "sf"))

# Select new births
nb &lt;- v %&gt;%
  select(starts_with("NWBIR")) %&gt;%
  glimpse()

# Compute the mean of NWBIR on each geometry
nb %&gt;%
  rowwise() %&gt;%
  mutate(nb_mean = mean(c(NWBIR74, NWBIR79)))

# Additional examples

# use c_across() to more easily select many variables
nb %&gt;%
  rowwise() %&gt;%
  mutate(m = mean(c_across(NWBIR74:NWBIR79)))

# Compute the minimum of x and y in each row

nb %&gt;%
  rowwise() %&gt;%
  mutate(min = min(c_across(NWBIR74:NWBIR79)))

# Summarising
v %&gt;%
  rowwise() %&gt;%
  summarise(mean_bir = mean(BIR74, BIR79)) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = mean_bir))

# Supply a variable to be kept
v %&gt;%
  mutate(id2 = as.integer(CNTY_ID / 100)) %&gt;%
  rowwise(id2) %&gt;%
  summarise(mean_bir = mean(BIR74, BIR79)) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = as.factor(id2)))

</code></pre>

<hr>
<h2 id='scale_color_coltab'>Gradient scales from <strong>Wikipedia</strong> color schemes</h2><span id='topic+scale_color_coltab'></span><span id='topic+scale_wiki'></span><span id='topic+scale_fill_wiki_d'></span><span id='topic+scale_colour_wiki_d'></span><span id='topic+scale_color_wiki_d'></span><span id='topic+scale_fill_wiki_c'></span><span id='topic+scale_colour_wiki_c'></span><span id='topic+scale_color_wiki_c'></span><span id='topic+scale_fill_wiki_b'></span><span id='topic+scale_colour_wiki_b'></span><span id='topic+scale_color_wiki_b'></span><span id='topic+wiki.colors'></span>

<h3>Description</h3>

<p>Implementation based on the
<a href="https://en.wikipedia.org/wiki/Wikipedia:WikiProject_Maps/Conventions/Topographic_maps">Wikipedia Colorimetric conventions for topographic maps</a>.
</p>
<p>Three scales are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additionally, a color palette <code>wiki.colors()</code> is provided. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_wiki_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_wiki_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_wiki_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_wiki_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_wiki_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_wiki_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

wiki.colors(n, alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_color_coltab_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = wiki.colors(100))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_wiki_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_wiki_b(breaks = seq(70, 200, 10))

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_wiki_d(na.value = "gray10")

</code></pre>

<hr>
<h2 id='scale_coltab'>Discrete scales based in the color table of a <code>SpatRaster</code></h2><span id='topic+scale_coltab'></span><span id='topic+scale_fill_coltab'></span><span id='topic+scale_colour_coltab'></span><span id='topic+get_coltab_pal'></span>

<h3>Description</h3>

<p>Some categorical <code>SpatRaster</code> objects may have an associated color table.
This function extract those values. These functions generates scales and
vector of colors based on the color table <code><a href="terra.html#topic+colors">terra::coltab()</a></code> associated to a
<code>SpatRaster</code>.
</p>
<p>You can also get a vector of colors named with the corresponding
factor with <code><a href="#topic+get_coltab_pal">get_coltab_pal()</a></code>.
</p>
<p>Additional parameters <code>...</code> would be passed on to
<code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code> to see the full
range of parameters accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_coltab(
  data,
  ...,
  alpha = 1,
  na.translate = FALSE,
  na.value = "transparent",
  drop = TRUE
)

scale_colour_coltab(
  data,
  ...,
  alpha = 1,
  na.translate = FALSE,
  na.value = "transparent",
  drop = TRUE
)

get_coltab_pal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_coltab_+3A_data">data</code>, <code id="scale_coltab_+3A_x">x</code></td>
<td>
<p>A <code>SpatRaster</code> with one or several color tables.
See <code><a href="terra.html#topic+colors">terra::has.colors()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_coltab_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+colors">terra::coltab()</a></code>, <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>,
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_fill_manual()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
# Geological Eras
# Spanish Geological Survey (IGME)

r &lt;- rast(system.file("extdata/cyl_era.tif", package = "tidyterra"))

plot(r)

# Get coltab
coltab_pal &lt;- get_coltab_pal(r)

coltab_pal


# With ggplot2 + tidyterra
library(ggplot2)

gg &lt;- ggplot() +
  geom_spatraster(data = r)


# Default plot
gg

# With coltabs
gg +
  scale_fill_coltab(data = r)

</code></pre>

<hr>
<h2 id='scale_cross_blended'>Cross blended hypsometric tints scales</h2><span id='topic+scale_cross_blended'></span><span id='topic+scale_fill_cross_blended_d'></span><span id='topic+scale_colour_cross_blended_d'></span><span id='topic+scale_fill_cross_blended_c'></span><span id='topic+scale_colour_cross_blended_c'></span><span id='topic+scale_fill_cross_blended_b'></span><span id='topic+scale_colour_cross_blended_b'></span><span id='topic+cross_blended.colors'></span><span id='topic+scale_fill_cross_blended_tint_d'></span><span id='topic+scale_colour_cross_blended_tint_d'></span><span id='topic+scale_fill_cross_blended_tint_c'></span><span id='topic+scale_colour_cross_blended_tint_c'></span><span id='topic+scale_fill_cross_blended_tint_b'></span><span id='topic+scale_colour_cross_blended_tint_b'></span><span id='topic+cross_blended.colors2'></span><span id='topic+scale_color_cross_blended_d'></span><span id='topic+scale_color_cross_blended_tint_d'></span><span id='topic+scale_color_cross_blended_c'></span><span id='topic+scale_color_cross_blended_tint_c'></span><span id='topic+scale_color_cross_blended_b'></span><span id='topic+scale_color_cross_blended_tint_b'></span>

<h3>Description</h3>

<p>Implementation of the cross blended hypsometric gradients presented on
<a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>. The following fill scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>cross_blended.colors()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>An additional set of scales is provided. These scales can act as
<a href="https://en.wikipedia.org/wiki/Hypsometric_tints">hypsometric (or bathymetric) tints</a>.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>cross_blended.colors2()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>See <strong>Details</strong>.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_cross_blended_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_cross_blended_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_cross_blended_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_cross_blended_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_cross_blended_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_cross_blended_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

cross_blended.colors(n, palette = "cold_humid", alpha = 1, rev = FALSE)

scale_fill_cross_blended_tint_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_cross_blended_tint_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_cross_blended_tint_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_cross_blended_tint_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_cross_blended_tint_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_cross_blended_tint_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

cross_blended.colors2(n, palette = "cold_humid", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_cross_blended_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
<a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a> for more info. Values available are:
<code>"arid"</code>, <code>"cold_humid"</code>, <code>"polar"</code>, <code>"warm_humid"</code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>On <code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_*&#8288;</code> palettes, the position of the gradients
and the limits of the palette are redefined. Instead of treating the color
palette as a continuous gradient, they are rescaled to act as a hypsometric
tint. A rough description of these tints are:
</p>

<ul>
<li><p> Blue colors: Negative values.
</p>
</li>
<li><p> Green colors: 0 to 1.000 values.
</p>
</li>
<li><p> Browns: 1000 to 4.000 values.
</p>
</li>
<li><p> Whites: Values higher than 4.000.
</p>
</li></ul>

<p>The following orientation would vary depending on the palette definition
(see <a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a> for an example on how this could
be achieved).
</p>
<p>Note that the setup of the palette may not be always suitable for your
specific data. For example, a <code>SpatRaster</code> of small parts of the globe (and
with a limited range of elevations) may not be well represented. As an
example, a <code>SpatRaster</code> with a range of values on <code style="white-space: pre;">&#8288;[100, 200]&#8288;</code> would appear
almost as an uniform color. This could be adjusted using the
<code>limits</code>/<code>values</code> parameters.
</p>
<p>When passing <code>limits</code> parameter to <code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_*&#8288;</code> the
colors would be restricted of those specified by this parameter, keeping the
distribution of the tint. You can combine this with <code>oob</code> (i.e.
<code>oob = scales::oob_squish</code>) to avoid blank pixels in the plot.
</p>
<p><code>cross_blended.colors2()</code> provides a gradient color palette where the
distance between colors is different depending of the type of color.
In contrast, <code>cross_blended.colors()</code> provides an uniform gradient across
colors. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>


<ul>
<li><p> Patterson, T., &amp; Jenny, B. (2011). The Development and Rationale of
Cross-blended Hypsometric Tints. <em>Cartographic Perspectives,</em> (69), 31 -
46. <a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>.
</p>
</li>
<li><p> Patterson, T. (2004). <em>Using Cross-blended Hypsometric Tints for
Generalized Environmental Mapping.</em> Accessed June 10, 2022.
<a href="https://www.shadedrelief.com/hypso/hypso.html">https://www.shadedrelief.com/hypso/hypso.html</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a>, <code><a href="terra.html#topic+plot">terra::plot()</a></code>,
<code><a href="terra.html#topic+minmax">terra::minmax()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>.
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = cross_blended.colors(100, palette = "arid"))

# Palette with uneven colors
plot(volcano2_rast, col = cross_blended.colors2(100, palette = "arid"))


library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_c(palette = "cold_humid")


# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_cross_blended_tint_c(
    palette = "warm_humid",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = TRUE)
  ) +
  labs(fill = "elevation (m)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top",
    legend.key.width = rel(3),
    legend.ticks = element_line(colour = "black", linewidth = 0.3),
    legend.direction = "horizontal"
  )

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_b(breaks = seq(70, 200, 25), palette = "arid")

# With breaks
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_b(
    breaks = seq(75, 200, 25),
    palette = "arid"
  )

# With discrete values
factor &lt;- volcano2_rast %&gt;%
  mutate(cats = cut(elevation,
    breaks = c(100, 120, 130, 150, 170, 200),
    labels = c(
      "Very Low", "Low", "Average", "High",
      "Very High"
    )
  ))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_cross_blended_d(na.value = "gray10", palette = "cold_humid")


# Tint version
ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_cross_blended_tint_d(
    na.value = "gray10",
    palette = "cold_humid"
  )

# Display all the cross-blended palettes

pals &lt;- unique(cross_blended_hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = cross_blended.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
# Display all the cross-blended palettes on version 2

pals &lt;- unique(cross_blended_hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = cross_blended.colors2(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_grass'>GRASS scales</h2><span id='topic+scale_grass'></span><span id='topic+scale_fill_grass_d'></span><span id='topic+scale_colour_grass_d'></span><span id='topic+scale_color_grass_d'></span><span id='topic+scale_fill_grass_c'></span><span id='topic+scale_colour_grass_c'></span><span id='topic+scale_color_grass_c'></span><span id='topic+scale_fill_grass_b'></span><span id='topic+scale_colour_grass_b'></span><span id='topic+scale_color_grass_b'></span><span id='topic+grass.colors'></span>

<h3>Description</h3>

<p>Implementation of <a href="https://grass.osgeo.org/grass83/manuals/r.colors.html">GRASS color tables</a>. The
following fill scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_grass_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_grass_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_grass_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>grass.colors()</code>: Gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>
<p>These palettes are an implementation of <code><a href="terra.html#topic+mappal">terra::map.pal()</a></code>, that is the
default color palettes provided by <code><a href="terra.html#topic+plot">terra::plot()</a></code> (<a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a>
<code style="white-space: pre;">&#8288;&gt; 1.7.78&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_grass_d(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_grass_d(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_grass_c(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_grass_c(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_grass_b(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_grass_b(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "coloursteps"
)

grass.colors(n, palette = "viridis", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_grass_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
<a href="#topic+grass_db">grass_db</a> for more info.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_grass_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_grass_+3A_use_grass_range">use_grass_range</code></td>
<td>
<p>Logical. Should the scale use the suggested range
when plotting? See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_grass_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some palettes are mapped by default to a specific range of values (see
<a href="#topic+grass_db">grass_db</a>). However, it is possible to modify this behaviour with the
<code>use_grass_range</code> argument, When <code>FALSE</code> the color scales would be mapped
to the range of values of the <code>color/fill</code> aesthethics, See <strong>Examples</strong>.
</p>
<p>When passing <code>limits</code> parameter the colors would be restricted of those
specified by this parameter, keeping the distribution of the palette. You can
combine this with <code>oob</code> (i.e. <code>oob = scales::oob_squish</code>) to avoid blank
pixels in the plot.
</p>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> <code>aes()</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+mappal">terra::map.pal()</a></code>
</p>


<h3>Source</h3>

<p>Derived from <a href="https://github.com/OSGeo/grass/tree/main/lib/gis/colors">https://github.com/OSGeo/grass/tree/main/lib/gis/colors</a>. See
also <a href="https://grass.osgeo.org/grass83/manuals/r.colors.html">r.color - GRASS GIS Manual</a>.
</p>


<h3>References</h3>

<p>GRASS Development Team (2024). <em>Geographic Resources Analysis Support System
(GRASS) Software, Version 8.3.2</em>. Open Source Geospatial Foundation, USA.
<a href="https://grass.osgeo.org">https://grass.osgeo.org</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+grass_db">grass_db</a>, <code><a href="terra.html#topic+plot">terra::plot()</a></code>,
<code><a href="terra.html#topic+minmax">terra::minmax()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>.
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters:
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = grass.colors(100, palette = "haxby"))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_c(palette = "terrain")

# Use with no default limits
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_c(palette = "terrain", use_grass_range = FALSE)

# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_grass_c(
    palette = "srtm_plus",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = FALSE)
  ) +
  labs(fill = "elevation (m)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top",
    legend.key.width = rel(3),
    legend.ticks = element_line(colour = "black", linewidth = 0.3),
    legend.direction = "horizontal"
  )

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_b(breaks = seq(70, 200, 25), palette = "sepia")


# With discrete values
factor &lt;- volcano2_rast %&gt;%
  mutate(cats = cut(elevation,
    breaks = c(100, 120, 130, 150, 170, 200),
    labels = c(
      "Very Low", "Low", "Average", "High",
      "Very High"
    )
  ))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_grass_d(palette = "soilmoisture")


# Display all the GRASS palettes
data("grass_db")

pals_all &lt;- unique(grass_db$pal)

# In batches
pals &lt;- pals_all[c(1:25)]
# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = grass.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)

# Second batch
pals &lt;- pals_all[-c(1:25)]

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = grass.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_hypso'>Gradient scales for representing hypsometry and bathymetry</h2><span id='topic+scale_hypso'></span><span id='topic+scale_fill_hypso_d'></span><span id='topic+scale_colour_hypso_d'></span><span id='topic+scale_fill_hypso_c'></span><span id='topic+scale_colour_hypso_c'></span><span id='topic+scale_fill_hypso_b'></span><span id='topic+scale_colour_hypso_b'></span><span id='topic+hypso.colors'></span><span id='topic+scale_fill_hypso_tint_d'></span><span id='topic+scale_colour_hypso_tint_d'></span><span id='topic+scale_fill_hypso_tint_c'></span><span id='topic+scale_colour_hypso_tint_c'></span><span id='topic+scale_fill_hypso_tint_b'></span><span id='topic+scale_colour_hypso_tint_b'></span><span id='topic+hypso.colors2'></span><span id='topic+scale_color_hypso_d'></span><span id='topic+scale_color_hypso_tint_d'></span><span id='topic+scale_color_hypso_c'></span><span id='topic+scale_color_hypso_tint_c'></span><span id='topic+scale_color_hypso_b'></span><span id='topic+scale_color_hypso_tint_b'></span>

<h3>Description</h3>

<p>Implementation of a selection of gradient palettes available in
<a href="http://seaviewsensing.com/pub/cpt-city/">cpt-city</a>.
</p>
<p>The following scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>hypso.colors()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>An additional set of scales is provided. These scales can act as
<a href="https://en.wikipedia.org/wiki/Hypsometric_tints">hypsometric (or bathymetric) tints</a>.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>hypso.colors2()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>See <strong>Details</strong>.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_hypso_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_hypso_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_hypso_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_hypso_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_hypso_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_hypso_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

hypso.colors(n, palette = "etopo1_hypso", alpha = 1, rev = FALSE)

scale_fill_hypso_tint_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_hypso_tint_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_hypso_tint_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_hypso_tint_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_hypso_tint_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_hypso_tint_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

hypso.colors2(n, palette = "etopo1_hypso", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_hypso_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
<a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a> for more info. Values available are:
<code>"arctic"</code>, <code>"arctic_bathy"</code>, <code>"arctic_hypso"</code>, <code>"c3t1"</code>, <code>"colombia"</code>, <code>"colombia_bathy"</code>, <code>"colombia_hypso"</code>, <code>"dem_poster"</code>, <code>"dem_print"</code>, <code>"dem_screen"</code>, <code>"etopo1"</code>, <code>"etopo1_bathy"</code>, <code>"etopo1_hypso"</code>, <code>"gmt_globe"</code>, <code>"gmt_globe_bathy"</code>, <code>"gmt_globe_hypso"</code>, <code>"meyers"</code>, <code>"meyers_bathy"</code>, <code>"meyers_hypso"</code>, <code>"moon"</code>, <code>"moon_bathy"</code>, <code>"moon_hypso"</code>, <code>"nordisk-familjebok"</code>, <code>"nordisk-familjebok_bathy"</code>, <code>"nordisk-familjebok_hypso"</code>, <code>"pakistan"</code>, <code>"spain"</code>, <code>"usgs-gswa2"</code>, <code>"utah_1"</code>, <code>"wiki-2.0"</code>, <code>"wiki-2.0_bathy"</code>, <code>"wiki-2.0_hypso"</code>, <code>"wiki-schwarzwald-cont"</code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_hypso_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>On <code style="white-space: pre;">&#8288;scale_*_hypso_tint_*&#8288;</code> palettes, the position of the gradients and
the limits of the palette are redefined. Instead of treating the color
palette as a continuous gradient, they are rescaled to act as a hypsometric
tint. A rough description of these tints are:
</p>

<ul>
<li><p> Blue colors: Negative values.
</p>
</li>
<li><p> Green colors: 0 to 1.000 values.
</p>
</li>
<li><p> Browns: 1000 to 4.000 values.
</p>
</li>
<li><p> Whites: Values higher than 4.000.
</p>
</li></ul>

<p>The following orientation would vary depending on the palette definition
(see <a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a> for an example on how this could be achieved).
</p>
<p>Note that the setup of the palette may not be always suitable for your
specific data. For example, a <code>SpatRaster</code> of small parts of the globe (and
with a limited range of elevations) may not be well represented. As an
example, a <code>SpatRaster</code> with a range of values on <code style="white-space: pre;">&#8288;[100, 200]&#8288;</code> would appear
almost as an uniform color. This could be adjusted using the
<code>limits</code>/<code>values</code> parameters.
</p>
<p>When passing <code>limits</code> parameter to <code style="white-space: pre;">&#8288;scale_*_hypso_tint_*&#8288;</code> the colors would
be restricted of those specified by this parameter, keeping the distribution
of the tint. You can combine this with <code>oob</code> (i.e.
<code>oob = scales::oob_squish</code>) to avoid blank pixels in the plot.
</p>
<p><code>hypso.colors2()</code> provides a gradient color palette where the distance
between colors is different depending of the type of color. In contrast,
<code>hypso.colors()</code> provides an uniform gradient across colors. See
<strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p>cpt-city: <a href="http://seaviewsensing.com/pub/cpt-city/">http://seaviewsensing.com/pub/cpt-city/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a>, <code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="terra.html#topic+minmax">terra::minmax()</a></code>,
<code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = hypso.colors(100, palette = "wiki-2.0_hypso"))

# Palette with uneven colors
plot(volcano2_rast, col = hypso.colors2(100, palette = "wiki-2.0_hypso"))


library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_c(palette = "colombia_hypso")


# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_hypso_tint_c(
    palette = "etopo1",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = TRUE)
  ) +
  labs(fill = "elevation (m)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top",
    legend.key.width = rel(3),
    legend.ticks = element_line(colour = "black", linewidth = 0.3),
    legend.direction = "horizontal"
  )

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_b(breaks = seq(70, 200, 25), palette = "wiki-2.0_hypso")

# With breaks
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_b(
    breaks = seq(75, 200, 25),
    palette = "wiki-2.0_hypso"
  )

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_hypso_d(na.value = "gray10", palette = "dem_poster")


# Tint version
ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_hypso_tint_d(na.value = "gray10", palette = "dem_poster")

# Display all the cpl_city palettes

pals &lt;- unique(hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = hypso.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
# Display all the cpl_city palettes on version 2

pals &lt;- unique(hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = hypso.colors2(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_princess'>Gradient scales from princess color schemes</h2><span id='topic+scale_princess'></span><span id='topic+scale_fill_princess_d'></span><span id='topic+scale_colour_princess_d'></span><span id='topic+scale_fill_princess_c'></span><span id='topic+scale_colour_princess_c'></span><span id='topic+scale_fill_princess_b'></span><span id='topic+scale_colour_princess_b'></span><span id='topic+princess.colors'></span><span id='topic+scale_color_princess_d'></span><span id='topic+scale_color_princess_c'></span><span id='topic+scale_color_princess_b'></span>

<h3>Description</h3>

<p>Implementation of the gradient palettes presented in
<a href="https://leahsmyth.github.io/Princess-Colour-Schemes/index.html">https://leahsmyth.github.io/Princess-Colour-Schemes/index.html</a>. Three
scales are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_princess_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_princess_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_princess_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additionally, a color palette <code>princess.colors()</code> is provided. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_princess_d(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_princess_d(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_princess_c(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_princess_c(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_princess_b(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_princess_b(
  palette = "snow",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

princess.colors(n, palette = "snow", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_princess_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. Values available are:
<code>"snow"</code>, <code>"ella"</code>, <code>"bell"</code>, <code>"aura"</code>, <code>"denmark"</code>, <code>"france"</code>, <code>"arabia"</code>, <code>"america"</code>, <code>"asia"</code>, <code>"neworleans"</code>, <code>"punz"</code>, <code>"scotland"</code>, <code>"cold"</code>, <code>"norge"</code>, <code>"maori"</code>.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_princess_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_princess_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p><a href="https://github.com/LeahSmyth/Princess-Colour-Schemes">https://github.com/LeahSmyth/Princess-Colour-Schemes</a>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = princess.colors(100))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_princess_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_princess_b(breaks = seq(70, 200, 10), palette = "denmark")

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_princess_d(na.value = "gray10", palette = "maori")


# Display all the princess palettes

pals &lt;- unique(princess_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = princess.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_terrain'>Terrain colour scales from <span class="pkg">grDevices</span></h2><span id='topic+scale_terrain'></span><span id='topic+scale_fill_terrain_d'></span><span id='topic+scale_colour_terrain_d'></span><span id='topic+scale_fill_terrain_c'></span><span id='topic+scale_colour_terrain_c'></span><span id='topic+scale_fill_terrain_b'></span><span id='topic+scale_colour_terrain_b'></span><span id='topic+scale_color_terrain_d'></span><span id='topic+scale_color_terrain_c'></span><span id='topic+scale_color_terrain_b'></span>

<h3>Description</h3>

<p>Implementation of the classic color palette <code><a href="grDevices.html#topic+terrain.colors">terrain.colors()</a></code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_terrain_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_terrain_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_terrain_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_terrain_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_terrain_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_terrain_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_terrain_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_terrain_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code> and <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs
on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_terrain_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_terrain_b(breaks = seq(70, 200, 10))

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_terrain_d(na.value = "gray10")

</code></pre>

<hr>
<h2 id='scale_whitebox'>Gradient scales from <strong>WhiteboxTools</strong> color schemes</h2><span id='topic+scale_whitebox'></span><span id='topic+scale_fill_whitebox_d'></span><span id='topic+scale_colour_whitebox_d'></span><span id='topic+scale_fill_whitebox_c'></span><span id='topic+scale_colour_whitebox_c'></span><span id='topic+scale_fill_whitebox_b'></span><span id='topic+scale_colour_whitebox_b'></span><span id='topic+whitebox.colors'></span><span id='topic+scale_color_whitebox_d'></span><span id='topic+scale_color_whitebox_c'></span><span id='topic+scale_color_whitebox_b'></span>

<h3>Description</h3>

<p>Implementation of the gradient palettes provided by
<a href="https://github.com/jblindsay/whitebox-tools">WhiteboxTools</a>. Three
scales are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additionally, a color palette <code>whitebox.colors()</code> is provided. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>.
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>.
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_whitebox_d(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_whitebox_d(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_whitebox_c(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_whitebox_c(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_whitebox_b(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_whitebox_b(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

whitebox.colors(n, palette = "high_relief", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_whitebox_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. Values available are:
<code>"atlas"</code>, <code>"high_relief"</code>, <code>"arid"</code>, <code>"soft"</code>, <code>"muted"</code>, <code>"purple"</code>, <code>"viridi"</code>, <code>"gn_yl"</code>, <code>"pi_y_g"</code>, <code>"bl_yl_rd"</code>, <code>"deep"</code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p><a href="https://github.com/jblindsay/whitebox-tools">https://github.com/jblindsay/whitebox-tools</a>, under
MIT License. Copyright (c) 2017-2021 John Lindsay.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters.
</p>
<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_grass">scale_grass</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_princess">scale_princess</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = whitebox.colors(100))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_whitebox_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_whitebox_b(breaks = seq(70, 200, 10), palette = "atlas")

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_whitebox_d(na.value = "gray10", palette = "soft")


# Display all the whitebox palettes

pals &lt;- c(
  "atlas", "high_relief", "arid", "soft", "muted", "purple",
  "viridi", "gn_yl", "pi_y_g", "bl_yl_rd", "deep"
)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = whitebox.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='select.Spat'>Subset layers/attributes of <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects</h2><span id='topic+select.Spat'></span><span id='topic+select.SpatRaster'></span><span id='topic+select.SpatVector'></span>

<h3>Description</h3>

<p>Select (and optionally rename) attributes/layers in <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects, using a
concise mini-language. See <strong>Methods</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
select(.data, ...)

## S3 method for class 'SpatVector'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="select.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Layer/attribute names can be used as if
they were positions in the <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object, so expressions like <code>x:y</code> can
be used to select a range of layers/attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+subset">terra::subset()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>Select (and rename) layers of a <code>SpatRaster</code>. The result is a <code>SpatRaster</code>
with the same extent, resolution and crs than <code>.data</code>. Only the number (and
possibly the name) of layers is modified.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> with the selected (and possibly renamed)
attributes on the function call.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="terra.html#topic+subset">terra::subset()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatRaster method

spatrast &lt;- rast(
  crs = "EPSG:3857",
  nrows = 10,
  ncols = 10,
  extent = c(100, 200, 100, 200),
  nlyr = 6,
  vals = seq_len(10 * 10 * 6)
)

spatrast %&gt;% select(1)

# By name
spatrast %&gt;% select(lyr.1:lyr.4)

# Rename
spatrast %&gt;% select(a = lyr.1, c = lyr.6)

# SpatVector method

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

v &lt;- vect(f)

v

v %&gt;% select(1, 3)

v %&gt;% select(iso2, name2 = cpro)
</code></pre>

<hr>
<h2 id='slice.Spat'>Subset cells/rows/columns/geometries using their positions</h2><span id='topic+slice.Spat'></span><span id='topic+slice.SpatRaster'></span><span id='topic+slice.SpatVector'></span><span id='topic+slice_head.SpatRaster'></span><span id='topic+slice_head.SpatVector'></span><span id='topic+slice_tail.SpatRaster'></span><span id='topic+slice_tail.SpatVector'></span><span id='topic+slice_min.SpatRaster'></span><span id='topic+slice_min.SpatVector'></span><span id='topic+slice_max.SpatRaster'></span><span id='topic+slice_max.SpatVector'></span><span id='topic+slice_sample.SpatRaster'></span><span id='topic+slice_sample.SpatVector'></span><span id='topic+slice_rows'></span><span id='topic+slice_rows.SpatRaster'></span><span id='topic+slice_cols'></span><span id='topic+slice_cols.SpatRaster'></span><span id='topic+slice_colrows'></span><span id='topic+slice_colrows.SpatRaster'></span>

<h3>Description</h3>

<p><code>slice()</code> methods lets you index cells/rows/columns/geometries by their
(integer) locations. It allows you to select, remove, and duplicate those
dimensions of a <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object.
</p>
<p><strong>If you want to slice your <code>SpatRaster</code> by geographic coordinates</strong> use
<code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code> method.
</p>
<p>It is accompanied by a number of helpers for common use cases:
</p>

<ul>
<li> <p><code>slice_head()</code> and <code>slice_tail()</code> select the first or last
cells/geometries.
</p>
</li>
<li> <p><code>slice_sample()</code> randomly selects cells/geometries.
</p>
</li>
<li> <p><code>slice_rows()</code> and <code>slice_cols()</code> allow to subset entire rows or columns,
of a <code>SpatRaster</code>.
</p>
</li>
<li> <p><code>slice_colrows()</code> subsets regions of the <code>SpatRaster</code> by row and column
position of a <code>SpatRaster</code>.
</p>
</li></ul>

<p>You can get a skeleton of your <code>SpatRaster</code> with the cell, column and row
index with <code><a href="#topic+as_coordinates">as_coordinates()</a></code>.
</p>
<p>See <strong>Methods</strong> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
slice(.data, ..., .preserve = FALSE, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice(.data, ..., .preserve = FALSE)

## S3 method for class 'SpatRaster'
slice_head(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_head(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_tail(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_tail(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_min(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_max(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_sample(
  .data,
  ...,
  n,
  prop,
  weight_by = NULL,
  replace = FALSE,
  .keep_extent = FALSE
)

## S3 method for class 'SpatVector'
slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)

slice_rows(.data, ...)

## S3 method for class 'SpatRaster'
slice_rows(.data, ..., .keep_extent = FALSE)

slice_cols(.data, ...)

## S3 method for class 'SpatRaster'
slice_cols(.data, ..., .keep_extent = FALSE)

slice_colrows(.data, ...)

## S3 method for class 'SpatRaster'
slice_colrows(.data, ..., cols, rows, .keep_extent = FALSE, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice.Spat_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a <code>SpatVector</code>
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Integer row values.
Provide either positive values to keep, or negative values to drop.
</p>
<p>The values provided must be either all positive or all negative. Indices
beyond the number of rows in the input are silently ignored. See
<strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored for <code style="white-space: pre;">&#8288;Spat*&#8288;</code> objects.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_.keep_extent">.keep_extent</code></td>
<td>
<p>Should the extent of the resulting <code>SpatRaster</code> be kept?
See also <code><a href="terra.html#topic+trim">terra::trim()</a></code>, <code><a href="terra.html#topic+extend">terra::extend()</a></code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_n">n</code>, <code id="slice.Spat_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_order_by">order_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, should cells that present a value of <code>NA</code> removed when
computing <code>slice_min()/slice_max()</code>?. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_weight_by">weight_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_cols">cols</code>, <code id="slice.Spat_+3A_rows">rows</code></td>
<td>
<p>Integer col/row values of the <code>SpatRaster</code></p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_inverse">inverse</code></td>
<td>
<p>If <code>TRUE</code>, <code>.data</code> is inverse-masked to the given selection.
See <code><a href="terra.html#topic+mask">terra::mask()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Spat*&#8288;</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+subset">terra::subset()</a></code>, <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>The result is a <code>SpatRaster</code> with the crs and resolution of the input and
where cell values of the selected cells/columns/rows are preserved.
</p>
<p>Use <code>.keep_extent = TRUE</code> to preserve the extent of <code>.data</code> on the output.
The non-selected cells would present a value of <code>NA</code>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> where the attributes of the selected
geometries are preserved. If <code>.data</code> is a
<a href="#topic+is_grouped_spatvector">grouped</a> <code>SpatVector</code>, the operation will be
performed on each group, so that (e.g.) <code>slice_head(df, n = 5)</code> will select
the first five rows in each group.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>.
</p>
<p>You can get a skeleton of your <code>SpatRaster</code> with the cell, column and row
index with <code><a href="#topic+as_coordinates">as_coordinates()</a></code>.
</p>
<p>If you want to slice by geographic coordinates use <code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code>.
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

# Slice first 100 cells
r %&gt;%
  slice(1:100) %&gt;%
  plot()

# Rows
r %&gt;%
  slice_rows(1:30) %&gt;%
  plot()

# Cols
r %&gt;%
  slice_cols(-(20:50)) %&gt;%
  plot()

# Spatial sample
r %&gt;%
  slice_sample(prop = 0.2) %&gt;%
  plot()


# Slice regions
r %&gt;%
  slice_colrows(
    cols = c(20:40, 60:80),
    rows = -c(1:20, 30:50)
  ) %&gt;%
  plot()

# Group wise operation with SpatVectors--------------------------------------
v &lt;- terra::vect(system.file("ex/lux.shp", package = "terra"))


glimpse(v) %&gt;% autoplot(aes(fill = NAME_1))

gv &lt;- v %&gt;% group_by(NAME_1)
# All slice helpers operate per group, silently truncating to the group size
gv %&gt;%
  slice_head(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_tail(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_min(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_max(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))

</code></pre>

<hr>
<h2 id='stat_spat_coordinates'>Extract coordinates from <code>SpatVector</code> objects</h2><span id='topic+stat_spat_coordinates'></span>

<h3>Description</h3>

<p><code>stat_spat_coordinates()</code> extracts the coordinates from <code>SpatVector</code> objects
and summarises them to one pair of coordinates (x and y) per geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_spat_coordinates(
  mapping = aes(),
  data = NULL,
  geom = "point",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_spat_coordinates_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_data">data</code></td>
<td>
<p>A <code>SpatVector</code> object, see <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms. The
<code>geom</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Geom</code> ggproto subclass, for example <code>GeomPoint</code>.
</p>
</li>
<li><p> A string naming the geom. To give the geom as a string, strip the
function name of the <code>geom_</code> prefix. For example, to use <code>geom_point()</code>,
give the geom as <code>"point"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the geom, see the
<a href="ggplot2.html#topic+layer_geoms">layer geom</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper of <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code>.
</p>
<p>See <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code> for details.
</p>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3>See Also</h3>

<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cyl &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

library(ggplot2)

ggplot(cyl) +
  stat_spat_coordinates()

ggplot(cyl) +
  geom_errorbarh(
    aes(
      geometry = geometry,
      xmin = after_stat(x) - 50000,
      xmax = after_stat(x) + 50000,
      y = after_stat(y),
      height = 10000
    ),
    stat = "sf_coordinates"
  )


</code></pre>

<hr>
<h2 id='summarise.SpatVector'>Summarise each group of a <code>SpatVector</code> down to one geometry</h2><span id='topic+summarise.SpatVector'></span><span id='topic+summarize.SpatVector'></span>

<h3>Description</h3>

<p><code>summarise()</code> creates a new <code>SpatVector</code>. It returns one geometry for each
combination of grouping variables; if there are no grouping variables, the
output will have a single geometry summarising all observations in the input
and combining all the geometries of the <code>SpatVector</code>. It will contain one
column for each grouping variable and one column for each of
the summary statistics that you have specified.
</p>
<p><code>summarise.SpatVector()</code> and <code>summarize.SpatVector()</code> are synonyms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
summarise(.data, ..., .by = NULL, .groups = NULL, .dissolve = TRUE)

## S3 method for class 'SpatVector'
summarize(.data, ..., .by = NULL, .groups = NULL, .dissolve = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.by">.by</code></td>
<td>
<p>Ignored on this method (<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
on <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a>).</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.groups">.groups</code></td>
<td>
<p>See <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code></p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.dissolve">.dissolve</code></td>
<td>
<p>logical. Should borders between aggregated geometries
be dissolved?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatVector</code>.
</p>


<h3><a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> function.
</p>


<h4><code>SpatVector</code></h4>

<p>Similarly to the implementation on <a href="https://CRAN.R-project.org/package=sf"><span class="pkg">sf</span></a> this function can be used to
dissolve geometries (with <code>.dissolve = TRUE</code>) or create <code>MULTI</code> versions of
geometries (with <code>.dissolve = FALSE</code>). See <strong>Examples</strong>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>, <code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# Grouped
gr_v &lt;- v %&gt;%
  mutate(start_with_s = substr(name, 1, 1) == "S") %&gt;%
  group_by(start_with_s)


# Dissolving
diss &lt;- gr_v %&gt;%
  summarise(n = dplyr::n(), mean = mean(as.double(cpro)))

diss

autoplot(diss, aes(fill = start_with_s)) + ggplot2::ggtitle("Dissolved")

# Not dissolving
no_diss &lt;- gr_v %&gt;%
  summarise(n = dplyr::n(), mean = mean(as.double(cpro)), .dissolve = FALSE)

# Same statistic
no_diss

autoplot(no_diss, aes(fill = start_with_s)) +
  ggplot2::ggtitle("Not Dissolved")
</code></pre>

<hr>
<h2 id='volcano2'>Updated topographic information on Auckland's Maungawhau volcano</h2><span id='topic+volcano2'></span>

<h3>Description</h3>

<p>Probably you already know the <a href="datasets.html#topic+volcano">volcano</a> dataset. This dataset provides
updated information of Maungawhau (Mt. Eden) from
<a href="https://data.linz.govt.nz/">Toitu Te Whenua Land Information New Zealand</a>,
the Government's agency that provides free online access to New Zealand’s
most up-to-date land and seabed data.
</p>


<h3>Format</h3>

<p>A matrix of 174 rows and 122 columns. Each
value is the corresponding altitude in meters.
</p>


<h3>Note</h3>

<p>Information needed for regenerating the original <code>SpatRaster</code> file:
</p>

<ul>
<li><p> resolution: <code>c(5, 5)</code>
</p>
</li>
<li><p> extent: <code style="white-space: pre;">&#8288;1756969, 1757579, 5917003, 5917873&#8288;</code>  (xmin, xmax, ymin, ymax)
</p>
</li>
<li><p> coord. ref. : NZGD2000 / New Zealand Transverse Mercator 2000
(<code>EPSG:2193</code>)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.linz.govt.nz/layer/53405-auckland-lidar-1m-dem-2013/">Auckland LiDAR 1m DEM (2013)</a>.
</p>
<p>DEM for LiDAR data from the Auckland region captured in 2013. The original
data has been downsampled to a resolution of 5m due to disk space constrains.
</p>
<p>Data License: <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>


<h3>See Also</h3>

<p><a href="datasets.html#topic+volcano">volcano</a>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+grass_db">grass_db</a></code>,
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>,
<code><a href="#topic+princess_db">princess_db</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("volcano2")
filled.contour(volcano2, color.palette = hypso.colors, asp = 1)
title(main = "volcano2 data: filled contour map")

# Geo-tag
# Empty raster

volcano2_raster &lt;- terra::rast(volcano2)
terra::crs(volcano2_raster) &lt;- pull_crs(2193)
terra::ext(volcano2_raster) &lt;- c(1756968, 1757576, 5917000, 5917872)
names(volcano2_raster) &lt;- "volcano2"

library(ggplot2)

ggplot() +
  geom_spatraster(data = volcano2_raster) +
  scale_fill_hypso_c() +
  labs(
    title = "volcano2 SpatRaster",
    subtitle = "Georeferenced",
    fill = "Elevation (m)"
  )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
