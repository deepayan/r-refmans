<!DOCTYPE html><html><head><title>Help for package tidyterra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyterra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#arrange.SpatVector'><p>Order SpatVectors using column values</p></a></li>
<li><a href='#as_coordinates'><p>Get cell number, row and column from a SpatRaster</p></a></li>
<li><a href='#as_sf'><p>Coerce a SpatVector to a sf object</p></a></li>
<li><a href='#as_spatraster'><p>Coerce a data frame to SpatRaster</p></a></li>
<li><a href='#as_spatvector'><p>Method for coercing objects to to SpatVector</p></a></li>
<li><a href='#as_tibble.Spat'><p>Coerce a Spat* object to data frames</p></a></li>
<li><a href='#autoplot.Spat'><p>Create a complete ggplot for Spat* objects</p></a></li>
<li><a href='#bind_cols.SpatVector'><p>Bind multiple SpatVectors and data frames by column</p></a></li>
<li><a href='#bind_rows.SpatVector'><p>Bind multiple SpatVectors and data frames by row</p></a></li>
<li><a href='#compare_spatrasters'><p>Compare attributes of two SpatRasters</p></a></li>
<li><a href='#count.SpatVector'><p>Count the observations in each SpatVector group</p></a></li>
<li><a href='#cross_blended_hypsometric_tints_db'><p>Cross-blended Hypsometric Tints</p></a></li>
<li><a href='#distinct.SpatVector'><p>Keep distinct/unique rows and geometries of SpatVector objects</p></a></li>
<li><a href='#drop_na.SpatRaster'><p>Drop cells of SpatRaster objects containing missing values</p></a></li>
<li><a href='#drop_na.SpatVector'><p>Drop attributes of SpatVector objects containing missing values</p></a></li>
<li><a href='#filter-joins.SpatVector'><p>Filtering joins for SpatVectors</p></a></li>
<li><a href='#filter.Spat'><p>Subset cells/geometries of Spat* objects</p></a></li>
<li><a href='#fortify.Spat'><p>Fortify Spat* Objects</p></a></li>
<li><a href='#geom_spat_contour'><p>Plot SpatRaster contours</p></a></li>
<li><a href='#geom_spatraster'><p>Visualise SpatRaster objects</p></a></li>
<li><a href='#geom_spatraster_rgb'><p>Visualise SpatRaster objects as images</p></a></li>
<li><a href='#ggspatvector'><p>Visualise SpatVector objects</p></a></li>
<li><a href='#glimpse.Spat'><p>Get a glimpse of your Spat* objects</p></a></li>
<li><a href='#group_data.SpatVector'><p>Grouping metadata for SpatVectors</p></a></li>
<li><a href='#group-by.SpatVector'><p>Group a SpatVector by one or more variables</p></a></li>
<li><a href='#hypsometric_tints_db'><p>Hypsometric palettes database</p></a></li>
<li><a href='#is_grouped_spatvector'><p>A grouped SpatVector.</p></a></li>
<li><a href='#is_regular_grid'><p>Check if x and y positions conforms a regular grid</p></a></li>
<li><a href='#mutate-joins.SpatVector'><p>Mutating joins for SpatVectors</p></a></li>
<li><a href='#mutate.Spat'><p>Create, modify, and delete cell values/layers/attributes of Spat* objects</p></a></li>
<li><a href='#pull_crs'><p>Extract CRS on WKT format</p></a></li>
<li><a href='#pull.Spat'><p>Extract a single layer/attribute</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relocate.Spat'><p>Change layer/attribute order</p></a></li>
<li><a href='#rename.Spat'><p>Rename layers/attributes</p></a></li>
<li><a href='#replace_na.Spat'><p>Replace NAs with specified values</p></a></li>
<li><a href='#rowwise.SpatVector'><p>Group SpatVector by rows</p></a></li>
<li><a href='#scale_color_coltab'><p>Gradient scales from Wikipedia color schemes</p></a></li>
<li><a href='#scale_coltab'><p>Discrete scales based in the color table of a SpatRaster</p></a></li>
<li><a href='#scale_cross_blended'><p>Cross blended Hypsometric Tints scales</p></a></li>
<li><a href='#scale_hypso'><p>Gradient scales for representing hypsometry and bathymetry</p></a></li>
<li><a href='#scale_terrain'><p>Terrain colour scales from grDevices</p></a></li>
<li><a href='#scale_whitebox'><p>Gradient scales from WhiteboxTools color schemes</p></a></li>
<li><a href='#select.Spat'><p>Subset layers/attributes of Spat* objects</p></a></li>
<li><a href='#slice.Spat'><p>Subset cells/rows/columns/geometries using their positions</p></a></li>
<li><a href='#stat_spat_coordinates'><p>Extract coordinates from SpatVector objects</p></a></li>
<li><a href='#summarise.SpatVector'><p>Summarise each group of a SpatVector down to one geometry</p></a></li>
<li><a href='#tidyterra-package'><p>tidyterra: 'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</p></a></li>
<li><a href='#volcano2'><p>Updated Topographic Information on Auckland's Maungawhau Volcano</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Extension of the 'tidyverse' for 'SpatRaster' and
    'SpatVector' objects of the 'terra' package. It includes also new
    'geom_' functions that provide a convenient way of visualizing 'terra'
    objects with 'ggplot2'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dieghernan.github.io/tidyterra/">https://dieghernan.github.io/tidyterra/</a>,
<a href="https://github.com/dieghernan/tidyterra">https://github.com/dieghernan/tidyterra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.0), data.table, dplyr (&ge; 1.0.0), ggplot2 (&ge;
3.1.0), magrittr, rlang, scales, sf (&ge; 1.0.0), terra (&ge;
1.5-12), tibble (&ge; 3.0.0), tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>isoband, knitr, lifecycle, maptiles, rmarkdown, s2, testthat
(&ge; 3.0.0), vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>geodata, metR, dieghernan/gitdevr, ragg, styler,
Nowosad/spDataLarge, ggspatial</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>r, terra, ggplot-extension, r-spatial, rspatial</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-19 11:52:38 UTC; diego</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego Hernangómez <a href="https://orcid.org/0000-0001-8457-4658"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Dewey Dunnington <a href="https://orcid.org/0000-0002-9415-4582"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (for ggspatial code),
  ggplot2 authors [cph] (for contour code)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diego Hernangómez &lt;diego.hernangomezherrero@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-19 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='arrange.SpatVector'>Order SpatVectors using column values</h2><span id='topic+arrange.SpatVector'></span>

<h3>Description</h3>

<p><code>arrange()</code> orders the geometries of a SpatVector by the values of
selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
arrange(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A SpatVector created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="arrange.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+arrange">data-masking</a></code>&gt; Variables, or functions of
variables. Use <code><a href="dplyr.html#topic+desc">dplyr::desc()</a></code> to sort a variable in descending order.</p>
</td></tr>
<tr><td><code id="arrange.SpatVector_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped SpatVectors only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+sort">terra::sort()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> function for
SpatVectors.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on rows:
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
library(dplyr)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))


# Single variable

v %&gt;%
  arrange(desc(iso2))


# Two variables
v %&gt;%
  mutate(even = as.double(cpro) %% 2 == 0, ) %&gt;%
  arrange(desc(even), desc(iso2))


# With new variables
v %&gt;%
  mutate(area_geom = terra::expanse(v)) %&gt;%
  arrange(area_geom)
</code></pre>

<hr>
<h2 id='as_coordinates'>Get cell number, row and column from a SpatRaster</h2><span id='topic+as_coordinates'></span>

<h3>Description</h3>

<p><code>as_coordinates()</code> can be used to obtain the position of each cell on the
SpatRaster matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_coordinates(x, as.raster = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_coordinates_+3A_x">x</code></td>
<td>
<p>A SpatRaster object</p>
</td></tr>
<tr><td><code id="as_coordinates_+3A_as.raster">as.raster</code></td>
<td>
<p>If <code>TRUE</code>, the result is a SpatRaster object with three
layers indicating the position of each cell (cell number, row and column).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble or a SpatRaster (if <code>as.raster = TRUE</code>) with the same number of
rows (or cells) than the number of cells in <code>x</code>.
</p>
<p>When <code>as.raster = TRUE</code> the resulting SpatRaster has the same crs, extension
and resolution than <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice.SpatRaster">slice.SpatRaster()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

r &lt;- rast(f)

as_coordinates(r)
as_coordinates(r, as.raster = TRUE)

as_coordinates(r, as.raster = TRUE) %&gt;% plot()

</code></pre>

<hr>
<h2 id='as_sf'>Coerce a SpatVector to a sf object</h2><span id='topic+as_sf'></span>

<h3>Description</h3>

<p><code>as_sf()</code> turns a SpatVector to sf. This is a wrapper of <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>
with the particularity that the groups created with <code><a href="#topic+group_by">group_by()</a></code> are
preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sf_+3A_x">x</code></td>
<td>
<p>A SpatVector.</p>
</td></tr>
<tr><td><code id="as_sf_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf object.
</p>


<h3>See Also</h3>

<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- terra::vect(f)

# This is ungrouped
v
is_grouped_spatvector(v)

# Get an ungrouped data
a_sf &lt;- as_sf(v)

dplyr::is_grouped_df(a_sf)

# Grouped

v$gr &lt;- c("C", "A", "A", "B", "A", "B", "B")
v$gr2 &lt;- rep(c("F", "G", "F"), 3)

gr_v &lt;- group_by(v, gr, gr2)

gr_v
is_grouped_spatvector(gr_v)

group_data(gr_v)

# A sf

a_gr_sf &lt;- as_sf(gr_v)

dplyr::is_grouped_df(a_gr_sf)

group_data(a_gr_sf)

</code></pre>

<hr>
<h2 id='as_spatraster'>Coerce a data frame to SpatRaster</h2><span id='topic+as_spatraster'></span>

<h3>Description</h3>

<p><code>as_spatraster()</code> turns an existing  data frame or tibble, into a SpatRaster.
This is a wrapper of <code><a href="terra.html#topic+rast">terra::rast()</a></code> S4 method for <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_spatraster(x, ..., xycols = 1:2, crs = "", digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_spatraster_+3A_x">x</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="terra.html#topic+rast">terra::rast()</a></code>.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_xycols">xycols</code></td>
<td>
<p>A vector of integers of length 2 determining the position of
the columns that hold the x and y coordinates.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_crs">crs</code></td>
<td>
<p>A crs on several formats (PROJ.4, WKT, EPSG code, ..) or
and spatial object from sf or terra that includes the target coordinate
reference system. See <code><a href="#topic+pull_crs">pull_crs()</a></code>. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="as_spatraster_+3A_digits">digits</code></td>
<td>
<p>integer to set the precision for detecting whether points are
on a regular grid (a low number of digits is a low precision).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a> If no <code>crs</code> is provided and the tibble
has been created with the method <code><a href="#topic+as_tibble.SpatRaster">as_tibble.SpatRaster()</a></code>, the <code>crs</code> is
inferred from <code>attr(x, "crs")</code>.
</p>


<h3>Value</h3>

<p>A SpatRaster.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_crs">pull_crs()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

r &lt;- rast(matrix(1:90, ncol = 3), crs = "EPSG:3857")

r

# Create tibble
as_tbl &lt;- as_tibble(r, xy = TRUE)

as_tbl

# From tibble
newrast &lt;- as_spatraster(as_tbl, crs = "EPSG:3857")
newrast

</code></pre>

<hr>
<h2 id='as_spatvector'>Method for coercing objects to to SpatVector</h2><span id='topic+as_spatvector'></span><span id='topic+as_spatvector.data.frame'></span><span id='topic+as_spatvector.sf'></span><span id='topic+as_spatvector.sfc'></span><span id='topic+as_spatvector.SpatVector'></span>

<h3>Description</h3>

<p><code>as_spatvector()</code> turns an existing  object into a SpatVector. This is a
wrapper of <code><a href="terra.html#topic+vect">terra::vect()</a></code> S4 method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_spatvector(x, ...)

## S3 method for class 'data.frame'
as_spatvector(x, ..., geom = c("lon", "lat"), crs = "")

## S3 method for class 'sf'
as_spatvector(x, ...)

## S3 method for class 'sfc'
as_spatvector(x, ...)

## S3 method for class 'SpatVector'
as_spatvector(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_spatvector_+3A_x">x</code></td>
<td>
<p>A tibble, data frame, sf or sfc object.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_geom">geom</code></td>
<td>
<p>character. The field name(s) with the geometry data. Either
two names for x and y coordinates of points, or a single name for a single
column with WKT geometries.</p>
</td></tr>
<tr><td><code id="as_spatvector_+3A_crs">crs</code></td>
<td>
<p>A crs on several formats (PROJ.4, WKT, EPSG code, ..) or
and spatial object from sf or terra that includes the target coordinate
reference system. See <code><a href="#topic+pull_crs">pull_crs()</a></code>. See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code><a href="terra.html#topic+vect">terra::vect()</a></code> on the following:
</p>

<ul>
<li><p> geometries with <code>NA/""</code> values are removed prior to conversion
</p>
</li>
<li><p> If <code>x</code> is a grouped data frame (see <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>) the grouping
vars are transferred and a &quot;grouped&quot; SpatVector is created (see
<code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>).
</p>
</li>
<li><p> If no <code>crs</code> is provided and the tibble has been created with the method
<code><a href="#topic+as_tibble.SpatVector">as_tibble.SpatVector()</a></code>, the <code>crs</code> is inferred from <code>attr(x, "crs")</code>.
</p>
</li>
<li><p> Handles correctly the conversion of <code>EMPTY</code> geometries between <span class="pkg">sf</span>
and <span class="pkg">terra</span>.
</p>
</li></ul>



<h3>Value</h3>

<p>A SpatVector.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+vect">terra::vect()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_crs">pull_crs()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

v &lt;- vect(matrix(1:80, ncol = 2), crs = "EPSG:3857")

v$cat &lt;- sample(LETTERS[1:4], size = nrow(v), replace = TRUE)

v

# Create tibble
as_tbl &lt;- as_tibble(v, geom = "WKT")

as_tbl

# From tibble
newvect &lt;- as_spatvector(as_tbl, geom = "geometry", crs = "EPSG:3857")
newvect

</code></pre>

<hr>
<h2 id='as_tibble.Spat'>Coerce a Spat* object to data frames</h2><span id='topic+as_tibble.Spat'></span><span id='topic+as_tibble.SpatRaster'></span><span id='topic+as_tibble.SpatVector'></span>

<h3>Description</h3>

<p><code>as_tibble()</code> method for SpatRaster and SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
as_tibble(x, ..., xy = FALSE, na.rm = FALSE, .name_repair = "unique")

## S3 method for class 'SpatVector'
as_tibble(x, ..., geom = NULL, .name_repair = "unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.Spat_+3A_x">x</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code></p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, the coordinates of each raster cell are included</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that have a <code>NA</code> value in at least one layer are removed. If the argument is set to <code>NA</code> only cells that have <code>NA</code> values in all layers are removed</p>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_tibble.Spat_+3A_geom">geom</code></td>
<td>
<p>character or NULL. If not NULL, either &quot;WKT&quot; or &quot;HEX&quot;, to get the geometry included in Well-Known-Text or hexadecimal notation. If <code>x</code> has point geometry, it can also be &quot;XY&quot; to add the coordinates of each point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> function.
</p>


<h4>SpatRaster and SpatVector</h4>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a> The tibble is returned with an attribute
including the crs of the initial object in WKT format (see <code><a href="#topic+pull_crs">pull_crs()</a></code>).
</p>



<h3>About layer/column names</h3>

<p>When coercing SpatRaster objects to data frames, <code>x</code> and <code>y</code> names are
reserved for geographic coordinates of each cell of the raster. It should be
also noted that terra allows layers with duplicated names.
</p>
<p>In the process of coercing a SpatRaster to a tibble, tidyterra may rename
the layers of your SpatRaster for overcoming this issue. Specifically, layers
may be renamed on the following cases:
</p>

<ul>
<li><p> Layers with duplicated names
</p>
</li>
<li><p> When coercing to a tibble, if <code>xy = TRUE</code>, layers named <code>x</code> or <code>y</code> would be
renamed.
</p>
</li>
<li><p> When working with tidyverse methods (i.e. <code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code>), the
latter would happen as well.
</p>
</li></ul>

<p>tidyterra would display a message informing of the changes on the names of
the layer.
</p>
<p>The same issue happens for SpatVector with names <code>geometry</code> (when
<code>geom = c("WKT", "HEX")</code>) and <code>x</code>, <code>y</code> (when <code>geom = "XY"</code>). These are
reserved names representing the geometry of the SpatVector (see
<code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>). If <code>geom</code> is not <code>NULL</code> then the logic described
for SpatRaster would apply as well for the columns of the SpatVector.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code>, <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
# SpatRaster
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

as_tibble(r, na.rm = TRUE)

as_tibble(r, xy = TRUE)

# SpatVector

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- vect(f)

as_tibble(v)

</code></pre>

<hr>
<h2 id='autoplot.Spat'>Create a complete ggplot for Spat* objects</h2><span id='topic+autoplot.Spat'></span><span id='topic+autoplot.SpatRaster'></span><span id='topic+autoplot.SpatVector'></span>

<h3>Description</h3>

<p><code>autoplot()</code> uses ggplot2 to draw plots as the ones produced by
<code><a href="terra.html#topic+plot">terra::plot()</a></code>/<code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code> in a single command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
autoplot(
  object,
  ...,
  rgb = NULL,
  use_coltab = NULL,
  facets = NULL,
  nrow = NULL,
  ncol = 2
)

## S3 method for class 'SpatVector'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.Spat_+3A_object">object</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code> or <code><a href="#topic+geom_spatvector">geom_spatvector()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_rgb">rgb</code></td>
<td>
<p>Logical. Should be plotted as a RGB image? If <code>NULL</code> (the default)
<code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would try to guess.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_use_coltab">use_coltab</code></td>
<td>
<p>Logical. Should be plotted with the corresponding
<code><a href="terra.html#topic+colors">terra::coltab()</a></code>? If <code>NULL</code> (the default) <code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would
try to guess. See also <code><a href="#topic+scale_fill_coltab">scale_fill_coltab()</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_facets">facets</code></td>
<td>
<p>Logical. Should facets be displayed? If <code>NULL</code> (the default)
<code><a href="#topic+autoplot.SpatRaster">autoplot.SpatRaster()</a></code> would try to guess.</p>
</td></tr>
<tr><td><code id="autoplot.Spat_+3A_nrow">nrow</code>, <code id="autoplot.Spat_+3A_ncol">ncol</code></td>
<td>
<p>Number of rows and columns on the facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation of <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code>.
</p>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Uses <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code> or <code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code>.
</p>



<h4>SpatVector</h4>

<p>Uses <code><a href="#topic+geom_spatvector">geom_spatvector()</a></code>. Labels can be placed with <code><a href="#topic+geom_spatvector_text">geom_spatvector_text()</a></code>
or <code><a href="#topic+geom_spatvector_label">geom_spatvector_label()</a></code>
</p>



<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code>
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>
<p>Other ggplot2 methods:
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

file_path &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

library(terra)
temp &lt;- rast(file_path)

library(ggplot2)
autoplot(temp)


# With a tile

tile &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra") %&gt;%
  rast()

autoplot(tile)

# With coltabs

ctab &lt;- system.file("extdata/cyl_era.tif", package = "tidyterra") %&gt;%
  rast()

autoplot(ctab)

#  With vectors
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
autoplot(v)

v %&gt;% autoplot(aes(fill = cpro)) +
  geom_spatvector_text(aes(label = iso2)) +
  coord_sf(crs = 25829)

</code></pre>

<hr>
<h2 id='bind_cols.SpatVector'>Bind multiple SpatVectors and data frames by column</h2><span id='topic+bind_cols.SpatVector'></span><span id='topic+bind_spat_cols'></span>

<h3>Description</h3>

<p>Bind any number of SpatVector, data frames and sf object by column, making a
wider result. This is similar to <code>do.call(cbind, dfs)</code>.
</p>
<p>Where possible prefer using a <a href="#topic+mutate-joins.SpatVector">join</a> to combine
SpatVectors and data frames. <code>bind_spat_cols()</code> binds the rows in order in
which they appear so it is easy to create meaningless results without
realizing it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_spat_cols(
  ...,
  .name_repair = c("unique", "universal", "check_unique", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_cols.SpatVector_+3A_...">...</code></td>
<td>
<p>SpatVector to combine. The first argument should be a SpatVector
and each of the subsequent arguments can either be a SpatVector, a sf object
or a data frame. Inputs are <a href="dplyr.html#topic+bind_cols">recycled</a> to the same
length, then matched by position.</p>
</td></tr>
<tr><td><code id="bind_cols.SpatVector_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, or <code>"check_unique"</code>.
See <code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code> for Details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector with the corresponding cols. The geometry and CRS
would correspond to the the first SpatVector of <code>...</code>.
</p>


<h3>terra equivalent</h3>

<p><code>cbind()</code> method
</p>


<h3>Methods</h3>

<p>Implementation of the <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> function for
SpatVectors. Note that for the second and subsequent arguments on <code>...</code> the
geometry would not be <code>cbind</code>ed, and only the data frame (-ish) columns
would be kept.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+bind_cols">dplyr::bind_cols()</a></code>
</p>
<p>Other dplyr verbs that operate on pairs Spat*/data.frame:
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
sv &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
df2 &lt;- data.frame(letters = letters[seq_len(nrow(sv))])

# Data frame
bind_spat_cols(sv, df2)


# Another SpatVector
bind_spat_cols(sv[1:2, ], sv[3:4, ])

# sf objects
sfobj &lt;- sf::read_sf(system.file("shape/nc.shp", package = "sf"))

bind_spat_cols(sv[1:9, ], sfobj[1:9, ])

# Mixed

end &lt;- bind_spat_cols(sv, sfobj[seq_len(nrow(sv)), 1:2], df2)

end
glimpse(end)

# Row sizes must be compatible when column-binding
try(bind_spat_cols(sv, sfobj))
</code></pre>

<hr>
<h2 id='bind_rows.SpatVector'>Bind multiple SpatVectors and data frames by row</h2><span id='topic+bind_rows.SpatVector'></span><span id='topic+bind_spat_rows'></span><span id='topic+bind.Spat'></span>

<h3>Description</h3>

<p>Bind any number of SpatVector, data frames and sf object by row, making a
longer result. This is similar to <code>do.call(rbind, dfs)</code>, but the output
will contain all columns that appear in any of the inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_spat_rows(..., .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_rows.SpatVector_+3A_...">...</code></td>
<td>
<p>SpatVector to combine. The first argument should be a SpatVector
and each of the subsequent arguments can either be a SpatVector, a sf object
or a data frame. Columns are matched by name, and any missing columns will
be filled with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="bind_rows.SpatVector_+3A_.id">.id</code></td>
<td>
<p>The name of an optional identifier column. Provide a string to
create an output column that identifies each input. The column will use
names if available, otherwise it will use positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector of the same type as the first element of <code>...</code>.
</p>


<h3>terra equivalent</h3>

<p><code>rbind()</code> method
</p>


<h3>Methods</h3>

<p>Implementation of the <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> function for
SpatVectors.
</p>
<p>The first element of <code>...</code> should be a SpatVector. Subsequent elements may
be SpatVector, sf/sfc objects or data frames:
</p>

<ul>
<li><p> If subsequent SpatVector/sf/sfc present a different CRS than the first
element, those elements would be reprojected to the CRS of the first
element with a message.
</p>
</li>
<li><p> If any element of <code>...</code> is a tibble/data frame the rows would be
<code>cbind</code>ed with empty geometries with a message.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>
</p>
<p>Other dplyr verbs that operate on pairs Spat*/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

v1 &lt;- v[1, "cpro"]
v2 &lt;- v[3:5, c("name", "iso2")]

# You can supply individual SpatVector as arguments:
bind_spat_rows(v1, v2)

# When you supply a column name with the `.id` argument, a new
# column is created to link each row to its original data frame
bind_spat_rows(v1, v2, .id = "id")


# Use with sf
sfobj &lt;- sf::st_as_sf(v2[1, ])

sfobj

bind_spat_rows(v1, sfobj)

# Would reproject with a message on different CRS
sfobj_3857 &lt;- as_spatvector(sfobj) %&gt;% project("EPSG:3857")

bind_spat_rows(v1, sfobj_3857)

# And with data frames with a message
data("mtcars")
bind_spat_rows(v1, sfobj, mtcars, .id = "id2")


# Use lists
bind_spat_rows(list(v1[1, ], sfobj[1:2, ]))

# Or named list combined with .id
bind_spat_rows(list(
  SpatVector = v1[1, ], sf = sfobj[1, ],
  mtcars = mtcars[1, ]
), .id = "source")

</code></pre>

<hr>
<h2 id='compare_spatrasters'>Compare attributes of two SpatRasters</h2><span id='topic+compare_spatrasters'></span>

<h3>Description</h3>

<p>Two SpatRasters are compatible (in terms of combining layers) if the
crs, extent and resolution are similar. In those cases you can combine
the SpatRasters simply as <code>c(x, y)</code>.
</p>
<p>This function compares those attributes informing of the results. See
<strong>Solving issues</strong> section for minimal guidance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_spatrasters(x, y, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_spatrasters_+3A_x">x</code>, <code id="compare_spatrasters_+3A_y">y</code></td>
<td>
<p>SpatRaster objects</p>
</td></tr>
<tr><td><code id="compare_spatrasters_+3A_digits">digits</code></td>
<td>
<p>Integer to set the precision for comparing the extent and
the resolution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A invisible logical <code>TRUE/FALSE</code> indicating if the SpatRasters are
compatible, plus an informative message flagging the issues found (if any).
</p>


<h3>Solving issues</h3>

<p>On <strong>non-equal crs</strong>, try <code><a href="terra.html#topic+project">terra::project()</a></code>. On <strong>non-equal extent</strong> try
<code><a href="terra.html#topic+resample">terra::resample()</a></code>. On <strong>non-equal resolution</strong> you can try
<code><a href="terra.html#topic+resample">terra::resample()</a></code>, <code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code> or <code><a href="terra.html#topic+disaggregate">terra::disagg()</a></code>.
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

x &lt;- rast(matrix(1:90, ncol = 3), crs = "EPSG:3857")

# Nothing
compare_spatrasters(x, x)

# Different crs
y_nocrs &lt;- x
crs(y_nocrs) &lt;- NA

compare_spatrasters(x, y_nocrs)

# Different extent
compare_spatrasters(x, x[1:10, , drop = FALSE])

# Different resolution
y_newres &lt;- x

res(y_newres) &lt;- res(x) / 2
compare_spatrasters(x, y_newres)

# Everything

compare_spatrasters(x, project(x, "epsg:3035"))
</code></pre>

<hr>
<h2 id='count.SpatVector'>Count the observations in each SpatVector group</h2><span id='topic+count.SpatVector'></span><span id='topic+tally.SpatVector'></span>

<h3>Description</h3>

<p><code>count()</code> lets you quickly count the unique values of one or more variables:
<code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
<code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent
to <code>df %&gt;% summarise(n = n())</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x),
  .dissolve = TRUE
)

## S3 method for class 'SpatVector'
tally(x, wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.SpatVector_+3A_x">x</code></td>
<td>
<p>A SpatVector.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_wt">wt</code></td>
<td>
<p>Not implemented on this method</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
<tr><td><code id="count.SpatVector_+3A_.dissolve">.dissolve</code></td>
<td>
<p>logical. Should borders between aggregated geometries
be dissolved?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object with an additional attribute.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+count">dplyr::count()</a></code> family functions for
SpatVectors.
</p>
<p><code><a href="#topic+tally">tally()</a></code> will always return a disaggregated geometry while <code><a href="#topic+count">count()</a></code> can
handle this. See also <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">dplyr::count()</a></code>, <code><a href="dplyr.html#topic+count">dplyr::tally()</a></code>
</p>
<p>Other dplyr verbs that operate on group of rows:
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)
f &lt;- system.file("ex/lux.shp", package = "terra")
p &lt;- vect(f)


p %&gt;% count(NAME_1, sort = TRUE)

p %&gt;% count(NAME_1, sort = TRUE)

p %&gt;% count(pop = ifelse(POP &lt; 20000, "A", "B"))

# tally() is a lower-level function that assumes you've done the grouping
p %&gt;% tally()

p %&gt;%
  group_by(NAME_1) %&gt;%
  tally()

# Dissolve geometries by default

library(ggplot2)
p %&gt;%
  count(NAME_1) %&gt;%
  ggplot() +
  geom_spatvector(aes(fill = n))

# Opt out
p %&gt;%
  count(NAME_1, .dissolve = FALSE, sort = TRUE) %&gt;%
  ggplot() +
  geom_spatvector(aes(fill = n))

</code></pre>

<hr>
<h2 id='cross_blended_hypsometric_tints_db'>Cross-blended Hypsometric Tints</h2><span id='topic+cross_blended_hypsometric_tints_db'></span>

<h3>Description</h3>

<p>A tibble including the color map of
4 gradient palettes.
All the palettes includes also a definition of colors limits in terms of
elevation (meters), that can be used with <code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>.
</p>


<h3>Format</h3>

<p>A tibble of 41 rows and
6 columns. with the following
fields:
</p>

<ul>
<li> <p><strong>pal</strong>: Name of the palette.
</p>
</li>
<li> <p><strong>limit</strong>: Recommended elevation limit (in meters) for each color.
</p>
</li>
<li> <p><strong>r</strong>,<strong>g</strong>,<strong>b</strong>: Value of the red, green and blue channel (RGB color
mode).
</p>
</li>
<li> <p><strong>hex</strong>: Hex code of the color.
</p>
</li></ul>



<h3>Details</h3>

<p>From Patterson &amp; Jenny (2011):
</p>
<p><em>More recently, the role and design of hypsometric tints have come under
scrutiny. One reason for this is the concern that people misread
elevation colors as climate or vegetation information. Cross-blended
hypsometric tints, introduced in 2009, are a partial solution to this
problem. They use variable lowland colors customized to match the
differing natural environments of world regions, which merge into
one another.</em>
</p>


<h3>Source</h3>

<p>Derived from Patterson, T., &amp; Jenny, B. (2011). The Development and
Rationale of Cross-blended Hypsometric Tints. <em>Cartographic Perspectives,</em>
(69), 31 - 46. <a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_cross_blended_c">scale_fill_cross_blended_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("cross_blended_hypsometric_tints_db")

cross_blended_hypsometric_tints_db

# Select a palette
warm &lt;- cross_blended_hypsometric_tints_db %&gt;%
  filter(pal == "warm_humid")

f &lt;- system.file("extdata/asia.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = warm$hex)

# Use with limits
p +
  scale_fill_gradientn(
    colors = warm$hex,
    values = scales::rescale(warm$limit),
    limit = range(warm$limit),
    na.value = "lightblue"
  )

</code></pre>

<hr>
<h2 id='distinct.SpatVector'>Keep distinct/unique rows and geometries of SpatVector objects</h2><span id='topic+distinct.SpatVector'></span>

<h3>Description</h3>

<p>Keep only unique/distinct rows and geometries from a SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A SpatVector created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="distinct.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+distinct">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame. There is a reserved variable
name, <code>geometry</code>, that would remove duplicate geometries. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="distinct.SpatVector_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+unique">terra::unique()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code> function.
</p>


<h4>SpatVector</h4>

<p>It is possible to remove duplicate geometries including the <code>geometry</code>
variable explicitly in the <code>...</code> call. See <strong>Examples</strong>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>, <code><a href="terra.html#topic+unique">terra::unique()</a></code>
</p>
<p>Other dplyr verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

v &lt;- vect(system.file("ex/lux.shp", package = "terra"))

# Create a vector with dups
v &lt;- v[sample(seq_len(nrow(v)), 100, replace = TRUE), ]
v$gr &lt;- sample(LETTERS[1:3], 100, replace = TRUE)

# All duplicates
ex1 &lt;- distinct(v)
ex1

nrow(ex1)

# Duplicates by NAME_1
ex2 &lt;- distinct(v, gr)
ex2
nrow(ex2)

# Same but keeping all cols
ex2b &lt;- distinct(v, gr, .keep_all = TRUE)
ex2b
nrow(ex2b)


# Unique geometries
ex3 &lt;- distinct(v, geometry)

ex3
nrow(ex3)
# Same as terra::unique()
terra::unique(ex3)

# Unique keeping info
distinct(v, geometry, .keep_all = TRUE)
</code></pre>

<hr>
<h2 id='drop_na.SpatRaster'>Drop cells of SpatRaster objects containing missing values</h2><span id='topic+drop_na.SpatRaster'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>. See <strong>Methods</strong>.
</p>
<p><code>drop_na()</code> method drops cells where any layer specified by <code>...</code> contains
a missing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na.SpatRaster_+3A_data">data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code>.</p>
</td></tr>
<tr><td><code id="drop_na.SpatRaster_+3A_...">...</code></td>
<td>
<p><code><a href="tidyr.html#topic+drop_na">tidy-select</a></code>  Layers to inspect
for missing values. If empty, all layers are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>Feedback needed!</h3>

<p>Visit <a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a>. The implementation
of this method for SpatRaster may change in the future.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+trim">terra::trim()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>
<p>Actual implementation of <code style="white-space: pre;">&#8288;drop_na().SpatRaster&#8288;</code> can be understood as a
masking method based on the values of the layers (see <code><a href="terra.html#topic+mask">terra::mask()</a></code>).
</p>
<p>Raster layers are considered as columns and raster cells as rows, so rows
(cells) with any <code>NA</code> value on any layer would get a <code>NA</code> value. It is
possible also to mask the cells (rows) based on the values of specific
layers (columns).
</p>
<p><code>drop_na()</code> would effectively remove outer cells that are <code>NA</code> (see
<code><a href="terra.html#topic+trim">terra::trim()</a></code>), so the extent of the resulting object may differ of the
extent of the input (see <code><a href="terra.html#topic+resample">terra::resample()</a></code> for more info).
</p>
<p>Check the <strong>Examples</strong> to have a better understanding of this method.
</p>



<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code>, <code><a href="#topic+drop_na">drop_na()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)


r &lt;- rast(
  crs = "EPSG:3857",
  extent = c(0, 10, 0, 10),
  nlyr = 3,
  resolution = c(2.5, 2.5)
)
terra::values(r) &lt;- seq_len(ncell(r) * nlyr(r))



# Add NAs
r[r &gt; 13 &amp; r &lt; 22 | r &gt; 31 &amp; r &lt; 45] &lt;- NA

# Init
plot(r, nc = 3)

# Mask with lyr.1
r %&gt;%
  drop_na(lyr.1) %&gt;%
  plot(nc = 3)

# Mask with lyr.2
r %&gt;%
  drop_na(lyr.2) %&gt;%
  plot(nc = 3)

# Mask with lyr.3
r %&gt;%
  drop_na(lyr.3) %&gt;%
  plot(nc = 3)

# Auto-mask all layers
r %&gt;%
  drop_na() %&gt;%
  plot(nc = 3)

</code></pre>

<hr>
<h2 id='drop_na.SpatVector'>Drop attributes of SpatVector objects containing missing values</h2><span id='topic+drop_na.SpatVector'></span>

<h3>Description</h3>

<p><code>drop_na()</code> method drops geometries where any attribute specified by <code>...</code>
contains a missing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
drop_na(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na.SpatVector_+3A_data">data</code></td>
<td>
<p>A SpatVector created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="drop_na.SpatVector_+3A_...">...</code></td>
<td>
<p><code><a href="tidyr.html#topic+drop_na">tidy-select</a></code>  Attributes to inspect for
missing values. If empty, all attributes are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code> function.
</p>


<h4>SpatVector</h4>

<p>The implementation of this method is performed on a <code>by-attribute</code> basis,
meaning that <code>NAs</code> are assessed on the attributes (columns) of each vector
(rows). The result is a SpatVector with potentially less geometries than the
input
</p>



<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code>. <a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a> A method for
SpatRaster is also available, see <code><a href="#topic+drop_na.SpatRaster">drop_na.SpatRaster()</a></code>.
</p>
<p>Other tidyr.methods: 
<code><a href="#topic+replace_na.Spat">replace_na.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

v &lt;- terra::vect(f)

# Add NAs
v &lt;- v %&gt;% mutate(iso2 = ifelse(cpro &lt;= "09", NA, cpro))

# Init
plot(v, col = "red")

# Mask with lyr.1
v %&gt;%
  drop_na(iso2) %&gt;%
  plot(col = "red")
</code></pre>

<hr>
<h2 id='filter-joins.SpatVector'>Filtering joins for SpatVectors</h2><span id='topic+filter-joins.SpatVector'></span><span id='topic+semi_join.SpatVector'></span><span id='topic+anti_join.SpatVector'></span>

<h3>Description</h3>

<p>Filtering joins filter rows from <code>x</code> based on the presence or absence of
matches in <code>y</code>:
</p>

<ul>
<li> <p><code><a href="#topic+semi_join">semi_join()</a></code> return all rows from <code>x</code> with a match in <code>y</code>.
</p>
</li>
<li> <p><code><a href="#topic+anti_join">anti_join()</a></code> return all rows from <code>x</code> without a match in <code>y</code>.
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
semi_join(x, y, by = NULL, copy = FALSE, ...)

## S3 method for class 'SpatVector'
anti_join(x, y, by = NULL, copy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter-joins.SpatVector_+3A_x">x</code></td>
<td>
<p>A SpatVector created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_y">y</code></td>
<td>
<p>A data frame or other object coercible to a data frame. <strong>If a
SpatVector of sf object</strong> is provided it would return an error (see
<code><a href="terra.html#topic+intersect">terra::intersect()</a></code> for performing spatial joins).</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="filter-joins.SpatVector_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> family
</p>


<h4>SpatVector</h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>x</code> for the records that matches the join
conditions.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code>, <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>, <code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>
<p>Other dplyr verbs that operate on pairs Spat*/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

# Vector
v &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# A data frame
df &lt;- data.frame(
  cpro = sprintf("%02d", 1:10),
  x = runif(10),
  y = runif(10),
  letter = rep_len(LETTERS[1:3], length.out = 10)
)

v

# Semi join
semi &lt;- v %&gt;% semi_join(df)

semi

autoplot(semi, aes(fill = iso2)) + ggtitle("Semi Join")


# Anti join

anti &lt;- v %&gt;% anti_join(df)

anti

autoplot(anti, aes(fill = iso2)) + ggtitle("Anti Join")

</code></pre>

<hr>
<h2 id='filter.Spat'>Subset cells/geometries of Spat* objects</h2><span id='topic+filter.Spat'></span><span id='topic+filter.SpatRaster'></span><span id='topic+filter.SpatVector'></span>

<h3>Description</h3>

<p>The <code>filter()</code> function is used to subset Spat* objects, retaining all
cells/geometries that satisfy your conditions. To be retained, the
cell/geometry must produce a value of <code>TRUE</code> for all conditions.
</p>
<p><strong>It is possible to filter a SpatRaster by its geographic coordinates</strong>.
You need to use <code>filter(.data, x &gt; 42)</code>. Note that <code>x</code> and <code>y</code> are reserved
names on terra, since they refer to the geographic coordinates of the layer.
</p>
<p>See <strong>Examples</strong> and section <strong>About layer names</strong> on <code><a href="#topic+as_tibble.Spat">as_tibble.Spat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
filter(.data, ..., .preserve = FALSE, .keep_extent = TRUE)

## S3 method for class 'SpatVector'
filter(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+filter">data-masking</a></code> Expressions that return a logical
value, and are defined in terms of the layers/attributes in <code>.data</code>. If
multiple expressions are included, they are combined with the <code>&amp;</code> operator.
Only cells/geometries for which all conditions evaluate to <code>TRUE</code> are kept.
See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored for Spat* objects.</p>
</td></tr>
<tr><td><code id="filter.Spat_+3A_.keep_extent">.keep_extent</code></td>
<td>
<p>Should the extent of the resulting SpatRaster be kept? On
<code>FALSE</code>, <code><a href="terra.html#topic+trim">terra::trim()</a></code> is called so the extent of the result may be
different of the extent of the output. See also <code><a href="#topic+drop_na.SpatRaster">drop_na.SpatRaster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Cells that do not fulfill the conditions on <code>...</code> are returned with value
<code>NA</code>. On a multi-layer SpatRaster the <code>NA</code> is propagated across all the
layers.
</p>
<p>If <code>.keep_extent = TRUE</code> the returning SpatRaster has the same crs, extent,
resolution and hence the same number of cells than <code>.data</code>. If
<code>.keep_extent = FALSE</code> the outer <code>NA</code> cells are trimmed with <code><a href="terra.html#topic+trim">terra::trim()</a></code>,
so the extent and number of cells may differ. The output would present in
any case the same crs and resolution than <code>.data</code>.
</p>
<p><code>x</code> and <code>y</code> variables (i.e. the longitude and latitude of the SpatRaster)
are also available internally for filtering. See <strong>Examples</strong>.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector with all the geometries that produce a value of
<code>TRUE</code> for all conditions.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

r &lt;- rast(f) %&gt;% select(tavg_04)

plot(r)


# Filter temps
r_f &lt;- r %&gt;% filter(tavg_04 &gt; 11.5)

# Extent is kept
plot(r_f)


# Filter temps and extent
r_f2 &lt;- r %&gt;% filter(tavg_04 &gt; 11.5, .keep_extent = FALSE)

# Extent has changed
plot(r_f2)


# Filter by geographic coordinates
r2 &lt;- project(r, "epsg:4326")

r2 %&gt;% plot()

r2 %&gt;%
  filter(
    x &gt; -4,
    x &lt; -2,
    y &gt; 42
  ) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='fortify.Spat'>Fortify Spat* Objects</h2><span id='topic+fortify.Spat'></span><span id='topic+fortify.SpatRaster'></span><span id='topic+fortify.SpatVector'></span>

<h3>Description</h3>

<p>Fortify SpatRasters and SpatVectors to data frames for compatibility with
<code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
fortify(
  model,
  data,
  ...,
  .name_repair = "unique",
  maxcell = terra::ncell(model) * 1.1
)

## S3 method for class 'SpatVector'
fortify(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.Spat_+3A_model">model</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_data">data</code></td>
<td>
<p>Not used by this method.</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="fortify.Spat_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+fortify.SpatVector">fortify.SpatVector()</a></code> returns a <code>sf</code> object and
<code><a href="#topic+fortify.SpatRaster">fortify.SpatRaster()</a></code> returns a tibble. See <strong>Methods</strong>.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Return a tibble than can be used with <code style="white-space: pre;">&#8288;ggplot2::geom_*&#8288;</code> like
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>, <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, etc.
</p>
<p>The resulting tibble includes the coordinates on the columns <code style="white-space: pre;">&#8288;x,y&#8288;</code>. The
values of each layer are included as additional columns named as per the
name of the layer on the SpatRaster.
</p>
<p>The CRS of the SpatRaster can be retrieved with
<code style="white-space: pre;">&#8288;attr(&lt;fortifiedSpatRaster&gt;, "crs")&#8288;</code>.
</p>
<p>It is possible to convert the fortified object onto a SpatRaster again with
<code><a href="#topic+as_spatraster">as_spatraster()</a></code>.
</p>



<h4>SpatVector</h4>

<p>Return a <code>sf</code> object than can be used with <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>.
</p>



<h3>See Also</h3>

<p><code><a href="sf.html#topic+st_as_sf">sf::st_as_sf()</a></code>, <a href="#topic+as_tibble.Spat">as_tibble.Spat</a>, <code><a href="#topic+as_spatraster">as_spatraster()</a></code>,
<code><a href="ggplot2.html#topic+fortify">ggplot2::fortify()</a></code>.
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>
<p>Other ggplot2 methods:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>
</p>
<p>Coercing objects:
<code><a href="#topic+as_coordinates">as_coordinates</a>()</code>,
<code><a href="#topic+as_sf">as_sf</a>()</code>,
<code><a href="#topic+as_spatraster">as_spatraster</a>()</code>,
<code><a href="#topic+as_spatvector">as_spatvector</a>()</code>,
<code><a href="#topic+as_tibble.Spat">as_tibble.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Get a SpatRaster
r &lt;- system.file("extdata/volcano2.tif", package = "tidyterra") %&gt;%
  terra::rast()

fortified &lt;- ggplot2::fortify(r)

fortified

# The crs is an attribute of the fortified SpatRaster

attr(fortified, "crs")

# Back to a SpatRaster with
as_spatraster(fortified)

# You can now use a SpatRaster with raster, contours, etc.
library(ggplot2)

# Use here the raster with resample
ggplot(r, maxcell = 10000) +
  # Need the aes parameters
  geom_raster(aes(x, y, fill = elevation)) +
  # Adjust the coords
  coord_equal()

# Or any other geom
ggplot(r) +
  geom_histogram(aes(x = elevation),
    bins = 20, fill = "lightblue",
    color = "black"
  )

# Create a SpatVector
extfile &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
cyl &lt;- terra::vect(extfile)

cyl

# To sf
ggplot2::fortify(cyl)

# Now you can use geom_sf()

library(ggplot2)

ggplot(cyl) +
  geom_sf()


</code></pre>

<hr>
<h2 id='geom_spat_contour'>Plot SpatRaster contours</h2><span id='topic+geom_spat_contour'></span><span id='topic+geom_spatraster_contour'></span><span id='topic+geom_spatraster_contour_filled'></span>

<h3>Description</h3>

<p>These geoms create contours of SpatRaster objects.  To specify a valid
surface, you should specify the layer on <code>aes(z = layer_name)</code>, otherwise all
the layers would be consider for creating contours. See also <strong>Facets</strong>
section.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster_contour(
  mapping = NULL,
  data,
  ...,
  maxcell = 5e+05,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_spatraster_contour_filled(
  mapping = NULL,
  data,
  ...,
  maxcell = 5e+05,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spat_contour_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. See <strong>Aesthetics</strong> specially in the use of <code>fill</code>
aesthetic.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_data">data</code></td>
<td>
<p>A SpatRaster object.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_bins">bins</code></td>
<td>
<p>Number of contour bins. Overridden by <code>binwidth</code>.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the contour bins. Overridden by <code>breaks</code>.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Numeric vector to set the contour breaks
</p>
</li>
<li><p> A function that takes the range of the data and binwidth as input
and returns breaks as output. A function can be created from a formula
(e.g. ~ fullseq(.x, .y)).
</p>
</li></ul>

<p>Overrides <code>binwidth</code> and <code>bins</code>. By default, this is a vector of length
ten with <code><a href="base.html#topic+pretty">pretty()</a></code> breaks.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are silently removed.
If <code>FALSE</code>, missing values are removed with a warning.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spat_contour_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+contour">terra::contour()</a></code>
</p>


<h3>Aesthetics</h3>

<p><code>geom_spatraster_contour</code>() understands the following aesthetics:
</p>

<ul>
<li><p> alpha
</p>
</li>
<li><p> colour
</p>
</li>
<li><p> group
</p>
</li>
<li><p> linetype
</p>
</li>
<li><p> linewidth
</p>
</li>
<li><p> weight
</p>
</li></ul>

<p>Additionally, <code>geom_spatraster_contour_filled()</code> understands also the
following aesthetics, as well as the ones listed above:
</p>

<ul>
<li><p> fill
</p>
</li>
<li><p> subgroup
</p>
</li></ul>

<p>Check <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code> for more info.
</p>


<h3>Computed variables</h3>

<p>This geom computes internally some variables that are available for use as
aesthetics, using (for example) <code style="white-space: pre;">&#8288;aes(color = after_stat(&lt;computed&gt;))&#8288;</code> (see
<code><a href="ggplot2.html#topic+aes_eval">ggplot2::after_stat()</a></code>).
</p>

<dl>
<dt><code>level</code></dt><dd><p>Height of contour. For contour lines, this is numeric vector
that represents bin boundaries. For contour bands, this is an ordered
factor that represents bin ranges.</p>
</dd>
<dt><code>nlevel</code></dt><dd><p>Height of contour, scaled to maximum of 1.</p>
</dd>
<dt><code>lyr</code></dt><dd><p>Name of the layer.</p>
</dd>
<dt><code>level_low</code>, <code>level_high</code>, <code>level_mid</code></dt><dd><p>(contour bands only) Lower
and upper bin boundaries for each band, as well the mid point between
the boundaries.</p>
</dd>
</dl>



<h3>Coords</h3>

<p>When the SpatRaster does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On SpatRaster that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to adjust
the scales. That means that also the <strong>SpatRaster may be reprojected</strong>.
</p>


<h3>Facets</h3>

<p>You can use <code> facet_wrap(~lyr)</code> for creating a faceted plot by each layer of
the SpatRaster object. See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)

# Raster
f &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")
r &lt;- rast(f)

library(ggplot2)

ggplot() +
  geom_spatraster_contour(data = r)


ggplot() +
  geom_spatraster_contour(
    data = r, aes(color = after_stat(level)),
    binwidth = 1,
    linewidth = 0.4
  ) +
  scale_color_gradientn(
    colours = hcl.colors(20, "Inferno"),
    guide = guide_coloursteps()
  ) +
  theme_minimal()

# Filled with breaks
ggplot() +
  geom_spatraster_contour_filled(data = r, breaks = seq(80, 200, 10)) +
  scale_fill_hypso_d()

# Both lines and contours
ggplot() +
  geom_spatraster_contour_filled(
    data = r, breaks = seq(80, 200, 10),
    alpha = .7
  ) +
  geom_spatraster_contour(
    data = r, breaks = seq(80, 200, 2.5),
    color = "grey30",
    linewidth = 0.1
  ) +
  scale_fill_hypso_d()


</code></pre>

<hr>
<h2 id='geom_spatraster'>Visualise SpatRaster objects</h2><span id='topic+geom_spatraster'></span><span id='topic+stat_spatraster'></span>

<h3>Description</h3>

<p>This geom is used to visualise SpatRaster objects (see <code><a href="terra.html#topic+rast">terra::rast()</a></code>). The
geom is designed for visualise the object by layers, as <code><a href="terra.html#topic+plot">terra::plot()</a></code> does.
</p>
<p>For plotting SpatRaster objects as map tiles (i.e. RGB SpatRaster), use
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb()</a></code>.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>.
</p>
<p><code>stat_spatraster()</code> is provided as a complementary function, so the <code>geom</code>
can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster(
  mapping = aes(),
  data,
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = FALSE,
  interpolate = FALSE,
  maxcell = 5e+05,
  use_coltab = TRUE,
  ...
)

stat_spatraster(
  mapping = aes(),
  data,
  geom = "raster",
  na.rm = TRUE,
  show.legend = NA,
  inherit.aes = FALSE,
  maxcell = 5e+05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spatraster_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">ggplot2::aes_()</a></code>. See <strong>Aesthetics</strong> specially in the use of <code>fill</code>
aesthetic.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_data">data</code></td>
<td>
<p>A SpatRaster object.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, the default, missing values are silently removed.
If <code>FALSE</code>, missing values are removed with a warning.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_use_coltab">use_coltab</code></td>
<td>
<p>Logical. Only applicable to SpatRasters that have a coltab
(<code><a href="terra.html#topic+colors">terra::coltab()</a></code>). Should the coltab be used on the plot? See also
<code><a href="#topic+scale_fill_coltab">scale_fill_coltab()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spatraster_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data. Recommended <code>geom</code>
for SpatRaster are <code>"raster"</code> (the default), <code>"point"</code>,<code>"text"</code> and
<code>"label"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>
</p>


<h3>Coords</h3>

<p>When the SpatRaster does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On SpatRaster that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to adjust
the scales. That means that also the <strong>SpatRaster may be reprojected</strong>.
</p>


<h3>Aesthetics</h3>

<p><code>geom_spatraster()</code> understands the following aesthetics:
</p>

<ul>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li></ul>

<p>If <code>fill</code> is not provided, <code>geom_spatraster()</code> creates a ggplot2 layer with
all the layers of the SpatRaster object. Use <code>facet_wrap(~lyr)</code> to display
properly the SpatRaster layers.
</p>
<p>If <code>fill</code> is used, it should contain the name of one layer that is present
on the SpatRaster (i.e.
<code style="white-space: pre;">&#8288;geom_spatraster(data = rast, aes(fill = &lt;name_of_lyr&gt;)&#8288;</code>). Names of the
layers can be retrieved using <code>names(rast)</code>.
</p>
<p>Using <code>geom_spatraster(..., mapping = aes(fill = NULL))</code> or
<code style="white-space: pre;">&#8288;geom_spatraster(..., fill = &lt;color value(s)&gt;)&#8288;</code> would create a layer with no
mapped <code>fill</code> aesthetic.
</p>
<p><code>fill</code> can use computed variables.
</p>
<p>For <code>alpha</code> use computed variable. See section <strong>Computed variables</strong>.
</p>


<h4>stat_spatraster()</h4>

<p><code>stat_spatraster()</code> understands the same aesthetics than <code>geom_spatraster()</code>
when using <code>geom = "raster"</code> (the default):
</p>

<ul>
<li> <p><code>fill</code>
</p>
</li>
<li> <p><code>alpha</code>
</p>
</li></ul>

<p>When <code>geom = "raster"</code> the <code>fill</code> parameter would behave as in
<code>geom_spatraster()</code>. If another <code>geom</code> is used <code>stat_spatraster()</code> would
understand the aesthetics of the required <code>geom</code> and
<code style="white-space: pre;">&#8288;aes(fill = &lt;name_of_lyr&gt;)&#8288;</code> would not be applicable.
</p>
<p>Note also that mapping of aesthetics <code>x</code> and <code>y</code> is provided by default,
so the user does not need to add those aesthetics on <code>aes()</code>. In all the
cases the aesthetics should be mapped by using computed variables. See
section <strong>Computed variables</strong> and <strong>Examples</strong>.
</p>



<h3>Facets</h3>

<p>You can use <code> facet_wrap(~lyr)</code> for creating a faceted plot by each layer of
the SpatRaster object. See <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> for details.
</p>


<h3>Computed variables</h3>

<p>This geom computes internally some variables that are available for use as
aesthetics, using (for example) <code>aes(alpha = after_stat(value))</code> (see
<code><a href="ggplot2.html#topic+aes_eval">ggplot2::after_stat()</a></code>).
</p>

<dl>
<dt><code>value</code></dt><dd><p>Values of the SpatRaster.</p>
</dd>
<dt><code>lyr</code></dt><dd><p>Name of the layer.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Based on the <code>layer_spatial()</code> implementation on ggspatial package.
Thanks to <a href="https://github.com/paleolimbot">Dewey Dunnington</a> and
<a href="https://github.com/paleolimbot/ggspatial/graphs/contributors">ggspatial contributors</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>,
<code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code>
</p>
<p>Alternative geoms: <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>, <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_label()</a></code>,
<code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code>.
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Avg temperature on spring in Castille and Leon (Spain)
file_path &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")

library(terra)
temp_rast &lt;- rast(file_path)

library(ggplot2)

# Display a single layer
names(temp_rast)

ggplot() +
  geom_spatraster(data = temp_rast, aes(fill = tavg_04)) +
  # You can use coord_sf
  coord_sf(crs = 3857) +
  scale_fill_hypso_c()

# Display facets
ggplot() +
  geom_spatraster(data = temp_rast) +
  facet_wrap(~lyr, ncol = 2) +
  scale_fill_hypso_b()


# Non spatial rasters

no_crs &lt;- rast(crs = NA, extent = c(0, 100, 0, 100), nlyr = 1)
values(no_crs) &lt;- seq_len(ncell(no_crs))


ggplot() +
  geom_spatraster(data = no_crs)

# Downsample

ggplot() +
  geom_spatraster(data = no_crs, maxcell = 25)



# Using stat_spatraster
# Default
ggplot() +
  stat_spatraster(data = temp_rast) +
  facet_wrap(~lyr)

# Using points
ggplot() +
  stat_spatraster(
    data = temp_rast,
    aes(color = after_stat(value)),
    geom = "point", maxcell = 250
  ) +
  scale_colour_viridis_c(na.value = "transparent") +
  facet_wrap(~lyr)

# Using points and labels

r_single &lt;- temp_rast %&gt;% select(1)

ggplot() +
  stat_spatraster(
    data = r_single,
    aes(color = after_stat(value)),
    geom = "point",
    maxcell = 2000
  ) +
  stat_spatraster(
    data = r_single,
    aes(label = after_stat(round(value, 2))),
    geom = "label",
    alpha = 0.85,
    maxcell = 20
  ) +
  scale_colour_viridis_c(na.value = "transparent")

</code></pre>

<hr>
<h2 id='geom_spatraster_rgb'>Visualise SpatRaster objects as images</h2><span id='topic+geom_spatraster_rgb'></span>

<h3>Description</h3>

<p>This geom is used to visualise SpatRaster objects (see <code><a href="terra.html#topic+rast">terra::rast()</a></code>) as
RGB images. The layers are combined such that they represent the red,
green and blue channel.
</p>
<p>For plotting SpatRaster objects by layer values use <code><a href="#topic+geom_spatraster">geom_spatraster()</a></code>.
</p>
<p>The underlying implementation is based on <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatraster_rgb(
  mapping = aes(),
  data,
  interpolate = TRUE,
  r = 1,
  g = 2,
  b = 3,
  alpha = 1,
  maxcell = 5e+05,
  max_col_value = 255,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_spatraster_rgb_+3A_mapping">mapping</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_data">data</code></td>
<td>
<p>A SpatRaster object.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_r">r</code>, <code id="geom_spatraster_rgb_+3A_g">g</code>, <code id="geom_spatraster_rgb_+3A_b">b</code></td>
<td>
<p>Integer representing the number of layer of <code>data</code> to be
considered as the red (<code>r</code>), green (<code>g</code>) and blue (<code>b</code>) channel.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_max_col_value">max_col_value</code></td>
<td>
<p>Number giving the maximum of the color values range.
When this is <code>255</code> (the default), the result is computed most efficiently.
See <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatraster_rgb_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code>
</p>


<h3>Coords</h3>

<p>When the SpatRaster does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On SpatRaster that have a crs, the geom uses <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> to adjust
the scales. That means that also the SpatRaster may be reprojected.
</p>


<h3>Aesthetics</h3>

<p>No <code>aes()</code> is required. In fact, <code>aes()</code> will be ignored.
</p>


<h3>Source</h3>

<p>Based on the <code>layer_spatial()</code> implementation on ggspatial package.
Thanks to <a href="https://github.com/paleolimbot">Dewey Dunnington</a> and
<a href="https://github.com/paleolimbot/ggspatial/graphs/contributors">ggspatial contributors</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>, <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>, <code><a href="grDevices.html#topic+rgb">grDevices::rgb()</a></code>.
You can get also RGB tiles from the <a href="https://CRAN.R-project.org/package=maptiles"><span class="pkg">maptiles</span></a> package,
see <code><a href="maptiles.html#topic+get_tiles">maptiles::get_tiles()</a></code>.
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Tile of Castille and Leon (Spain) from OpenStreetMap
file_path &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")

library(terra)
tile &lt;- rast(file_path)

library(ggplot2)


ggplot() +
  geom_spatraster_rgb(data = tile) +
  # You can use coord_sf
  coord_sf(crs = 3035)

# Combine with sf objects
vect_path &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

cyl_sf &lt;- sf::st_read(vect_path)

ggplot(cyl_sf) +
  geom_spatraster_rgb(data = tile) +
  geom_sf(aes(fill = iso2)) +
  coord_sf(crs = 3857) +
  scale_fill_viridis_d(alpha = 0.7)

</code></pre>

<hr>
<h2 id='ggspatvector'>Visualise SpatVector objects</h2><span id='topic+ggspatvector'></span><span id='topic+geom_spatvector'></span><span id='topic+geom_spatvector_label'></span><span id='topic+geom_spatvector_text'></span><span id='topic+stat_spatvector'></span>

<h3>Description</h3>

<p>Wrappers of <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> family used to visualise SpatVector objects
(see <code><a href="terra.html#topic+vect">terra::vect()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatvector(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...
)

geom_spatvector_label(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...,
  nudge_x = 0,
  nudge_y = 0,
  label.size = 0.25,
  inherit.aes = TRUE
)

geom_spatvector_text(
  mapping = aes(),
  data = NULL,
  na.rm = FALSE,
  show.legend = NA,
  ...,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  inherit.aes = TRUE
)

stat_spatvector(
  mapping = NULL,
  data = NULL,
  geom = "rect",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggspatvector_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_data">data</code></td>
<td>
<p>A SpatVector object, see <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> functions.
These are often aesthetics, used to set an aesthetic to a fixed value,
like <code>colour = "red"</code> or <code>linewidth = 3</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_nudge_x">nudge_x</code>, <code id="ggspatvector_+3A_nudge_y">nudge_y</code></td>
<td>
<p>Horizontal and vertical adjustment to nudge labels by.
Useful for offsetting text from points, particularly on discrete scales.
Cannot be jointly specified with <code>position</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_label.size">label.size</code></td>
<td>
<p>Size of label border, in mm.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_check_overlap">check_overlap</code></td>
<td>
<p>If <code>TRUE</code>, text that overlaps previous text in the
same layer will not be plotted. <code>check_overlap</code> happens at draw time and in
the order of the data. Therefore data should be arranged by the label
column before calling <code>geom_text()</code>. Note that this argument is not
supported by <code>geom_label()</code>.</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="ggspatvector_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers of <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> functions. Since a
<code><a href="#topic+fortify.SpatVector">fortify.SpatVector()</a></code> method is provided, <strong>ggplot2</strong> treat a SpatVector
in the same way that a <code>sf</code> object. A side effect is that you can use
<code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> directly with SpatVectors.
</p>
<p>See <code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code> for details on aesthetics, etc.
</p>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf()</a></code>
</p>
<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+stat_spat_coordinates">stat_spat_coordinates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a SpatVector
extfile &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

cyl &lt;- terra::vect(extfile)
class(cyl)

library(ggplot2)

ggplot(cyl) +
  geom_spatvector()


# With params

ggplot(cyl) +
  geom_spatvector(aes(fill = name), color = NA) +
  scale_fill_viridis_d() +
  coord_sf(crs = 3857)

# Add labels
ggplot(cyl) +
  geom_spatvector(aes(fill = name), color = NA) +
  geom_spatvector_text(aes(label = iso2),
    fontface = "bold",
    color = "red"
  ) +
  scale_fill_viridis_d(alpha = 0.4) +
  coord_sf(crs = 3857)

# You can use now geom_sf with SpatVectors!



ggplot(cyl) +
  geom_sf() +
  labs(
    title = paste("cyl is", as.character(class(cyl))),
    subtitle = "With geom_sf()"
  )

</code></pre>

<hr>
<h2 id='glimpse.Spat'>Get a glimpse of your Spat* objects</h2><span id='topic+glimpse.Spat'></span><span id='topic+glimpse.SpatRaster'></span><span id='topic+glimpse.SpatVector'></span>

<h3>Description</h3>

<p><code>glimpse()</code> is like a transposed version of <code><a href="base.html#topic+print">print()</a></code>: layers/columns run
down the  page, and data runs across. This makes it possible to see every
layer/column in a Spat* object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
glimpse(x, width = NULL, ...)

## S3 method for class 'SpatVector'
glimpse(x, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glimpse.Spat_+3A_x">x</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_width">width</code></td>
<td>
<p>Width of output: defaults to the setting of the
<code>width</code> if finite (see <code><a href="dplyr.html#topic+glimpse">dplyr::glimpse()</a></code>) or the width of the console.</p>
</td></tr>
<tr><td><code id="glimpse.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+as_tibble.Spat">as_tibble()</a></code> Spat
methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original <code>x</code> is (invisibly) returned, allowing <code>glimpse()</code> to
be used within a data pipeline.
</p>


<h3>terra equivalent</h3>

<p><code>print()</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+glimpse">dplyr::glimpse()</a></code> function for
Spat*. objects.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+glimpse">dplyr::glimpse()</a></code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatVector
v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

v %&gt;% glimpse(width = 200)

# Use on a pipeline
v %&gt;%
  glimpse() %&gt;%
  mutate(a = 30) %&gt;%
  # with options
  glimpse(geom = "WKT")

# SpatRaster
r &lt;- rast(system.file("extdata/cyl_elev.tif", package = "tidyterra"))

r %&gt;% glimpse()

# Use on a pipeline
r %&gt;%
  glimpse() %&gt;%
  mutate(b = elevation_m / 100) %&gt;%
  # With options
  glimpse(xy = TRUE)
</code></pre>

<hr>
<h2 id='group_data.SpatVector'>Grouping metadata for SpatVectors</h2><span id='topic+group_data.SpatVector'></span><span id='topic+group_keys.SpatVector'></span><span id='topic+group_indices.SpatVector'></span><span id='topic+group_vars.SpatVector'></span><span id='topic+groups.SpatVector'></span><span id='topic+group_size.SpatVector'></span><span id='topic+n_groups.SpatVector'></span>

<h3>Description</h3>

<p>This collection of functions accesses data about grouped SpatVectors in
various ways:
</p>

<ul>
<li> <p><code><a href="#topic+group_data">group_data()</a></code> returns a tibble that defines the grouping structure.
The columns give the values of the grouping variables. The last column,
always called <code>.rows</code>, is a list of integer vectors that gives the
location of the rows in each group.
</p>
</li>
<li> <p><code><a href="#topic+group_keys">group_keys()</a></code> returns a tibble describing the groups.
</p>
</li>
<li> <p><code><a href="#topic+group_rows">group_rows()</a></code> returns a list of integer vectors giving the rows that
each group contains.
</p>
</li>
<li> <p><code><a href="#topic+group_indices">group_indices()</a></code> returns an integer vector the same length as <code>.data</code>
that gives the group that each row belongs to.
</p>
</li>
<li> <p><code><a href="#topic+group_vars">group_vars()</a></code> gives names of grouping variables as character vector.
</p>
</li>
<li> <p><code><a href="#topic+groups">groups()</a></code> gives the names of the grouping variables as a list of symbols.
</p>
</li>
<li> <p><code><a href="#topic+group_size">group_size()</a></code> gives the size of each group.
</p>
</li>
<li> <p><code><a href="#topic+n_groups">n_groups()</a></code> gives the total number of groups.
</p>
</li></ul>

<p>See <code><a href="dplyr.html#topic+group_data">dplyr::group_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
group_data(.data)

## S3 method for class 'SpatVector'
group_keys(.tbl, ...)

## S3 method for class 'SpatVector'
group_indices(.data, ...)

## S3 method for class 'SpatVector'
group_vars(x)

## S3 method for class 'SpatVector'
groups(x)

## S3 method for class 'SpatVector'
group_size(x)

## S3 method for class 'SpatVector'
n_groups(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_data.SpatVector_+3A_.data">.data</code>, <code id="group_data.SpatVector_+3A_.tbl">.tbl</code>, <code id="group_data.SpatVector_+3A_x">x</code></td>
<td>
<p>A SpatVector.</p>
</td></tr>
<tr><td><code id="group_data.SpatVector_+3A_...">...</code></td>
<td>
<p>Use of <code>...</code> is now deprecated; please use <code>group_by()</code> first
instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See the description of the function. The results are usually tibbles,
lists or vectors. These functions does not return SpatVector objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))
v$gr_1 &lt;- rep_len(c("A", "A", "B"), length.out = nrow(v))
v$gr_2 &lt;- rep_len(c("C", "D"), length.out = nrow(v))

# Ungrouped

n_groups(v)

group_vars(v)

group_keys(v)

group_size(v)

groups(v)

group_rows(v)

group_data(v)

group_indices(v)

# Grouped by one var
gv &lt;- group_by(v, gr_1)

n_groups(gv)

group_vars(gv)

group_keys(gv)

group_size(gv)

groups(gv)

group_rows(gv)

group_data(gv)

group_indices(gv)

# Grouped by several vars

gv2 &lt;- group_by(v, gr_1, gr_2)

n_groups(gv2)

group_vars(gv2)

group_keys(gv2)

group_size(gv2)

groups(gv2)

group_rows(gv2)

group_data(gv2)

group_indices(gv2)
</code></pre>

<hr>
<h2 id='group-by.SpatVector'>Group a SpatVector by one or more variables</h2><span id='topic+group-by.SpatVector'></span><span id='topic+group_by.SpatVector'></span><span id='topic+ungroup.SpatVector'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Most data operations are done on groups defined by variables. <code><a href="#topic+group_by">group_by()</a></code>
adds new attributes to an existing SpatVector indicating the
corresponding groups. See <strong>Methods</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))

## S3 method for class 'SpatVector'
ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group-by.SpatVector_+3A_.data">.data</code>, <code id="group-by.SpatVector_+3A_x">x</code></td>
<td>
<p>A SpatVector object. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group-by.SpatVector_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> on <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.
</p>


<h3>Value</h3>

<p>A SpatVector object with an additional attribute.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> family functions for
SpatVectors.
</p>
<p><strong>When mixing</strong> <span class="pkg">terra</span> <strong>and</strong> <span class="pkg">dplyr</span> <strong>syntax</strong> on a grouped
SpatVector (i.e, subsetting a SpatVector like <code>v[1:3,1:2]</code>) the <code>groups</code>
attribute can be corrupted. <span class="pkg">tidyterra</span> would try to re-group the
SpatVector. This would be triggered the next time you use a dplyr verb on
your SpatVector.
</p>
<p>Note also that some operations (as <code>terra::spatSample()</code>) would create a new
SpatVector. In these cases, the result won't preserve the <code>groups</code> attribute.
Use <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code> to re-group.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>, <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>
</p>
<p>Other dplyr verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)
f &lt;- system.file("ex/lux.shp", package = "terra")
p &lt;- vect(f)


by_name1 &lt;- p %&gt;% group_by(NAME_1)

# grouping doesn't change how the SpatVector looks
by_name1

# But add metadata for grouping: See the coercion to tibble

# Not grouped
p_tbl &lt;- as_tibble(p)
class(p_tbl)
head(p_tbl, 3)

# Grouped
by_name1_tbl &lt;- as_tibble(by_name1)
class(by_name1_tbl)
head(by_name1_tbl, 3)


# It changes how it acts with the other dplyr verbs:
by_name1 %&gt;% summarise(
  pop = mean(POP),
  area = sum(AREA)
)

# Each call to summarise() removes a layer of grouping
by_name2_name1 &lt;- p %&gt;% group_by(NAME_2, NAME_1)

by_name2_name1
group_data(by_name2_name1)

by_name2 &lt;- by_name2_name1 %&gt;% summarise(n = dplyr::n())
by_name2
group_data(by_name2)

# To removing grouping, use ungroup
by_name2 %&gt;%
  ungroup() %&gt;%
  summarise(n = sum(n))

# By default, group_by() overrides existing grouping
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2) %&gt;%
  group_vars()


# Use add = TRUE to instead append
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2, .add = TRUE) %&gt;%
  group_vars()

# You can group by expressions: this is a short-hand
# for a mutate() followed by a group_by()
p %&gt;%
  group_by(ID_COMB = ID_1 * 100 / ID_2) %&gt;%
  relocate(ID_COMB, .before = 1)

</code></pre>

<hr>
<h2 id='hypsometric_tints_db'>Hypsometric palettes database</h2><span id='topic+hypsometric_tints_db'></span>

<h3>Description</h3>

<p>A tibble including the color map of
33 gradient palettes. All the
palettes includes also a definition of colors limits in terms of elevation
(meters), that can be used with <code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>.
</p>


<h3>Format</h3>

<p>A tibble of 1102 rows and
6 columns. with the following fields:
</p>

<ul>
<li> <p><strong>pal</strong>: Name of the palette.
</p>
</li>
<li> <p><strong>limit</strong>: Recommended elevation limit (in meters) for each color.
</p>
</li>
<li> <p><strong>r</strong>,<strong>g</strong>,<strong>b</strong>: Value of the red, green and blue channel (RGB color
mode).
</p>
</li>
<li> <p><strong>hex</strong>: Hex code of the color.
</p>
</li></ul>



<h3>Source</h3>

<p>cpt-city: <a href="http://soliton.vm.bytemark.co.uk/pub/cpt-city/">http://soliton.vm.bytemark.co.uk/pub/cpt-city/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_fill_hypso_c">scale_fill_hypso_c()</a></code>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+volcano2">volcano2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("hypsometric_tints_db")

hypsometric_tints_db

# Select a palette
wikicols &lt;- hypsometric_tints_db %&gt;%
  filter(pal == "wiki-2.0")

f &lt;- system.file("extdata/asia.tif", package = "tidyterra")
r &lt;- terra::rast(f)

library(ggplot2)

p &lt;- ggplot() +
  geom_spatraster(data = r) +
  labs(fill = "elevation")

p +
  scale_fill_gradientn(colors = wikicols$hex)

# Use with limits
p +
  scale_fill_gradientn(
    colors = wikicols$hex,
    values = scales::rescale(wikicols$limit),
    limit = range(wikicols$limit)
  )

</code></pre>

<hr>
<h2 id='is_grouped_spatvector'>A grouped SpatVector.</h2><span id='topic+is_grouped_spatvector'></span>

<h3>Description</h3>

<p>The easiest way to create a grouped SpatVector is to call the
<code>group_by()</code> method on a Spatvector: this will take care of capturing
the unevaluated expressions for you. See <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code> for details.
</p>
<p>This function is the adapted version of <code><a href="dplyr.html#topic+grouped_df">dplyr::is_grouped_df()</a></code>.
</p>
<p>See also <code><a href="#topic+group_data.SpatVector">group_data.SpatVector()</a></code> for the accessor functions that retrieve
various metadata from a grouped SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_grouped_spatvector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_grouped_spatvector_+3A_x">x</code></td>
<td>
<p>a SpatVector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>

<hr>
<h2 id='is_regular_grid'>Check if x and y positions conforms a regular grid</h2><span id='topic+is_regular_grid'></span>

<h3>Description</h3>

<p>Assess if the coordinates x,y of an object conforms a regular grid. This
function is called by its side effects.
</p>
<p>This function is internally called by <code><a href="#topic+as_spatraster">as_spatraster()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_regular_grid(xy, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_regular_grid_+3A_xy">xy</code></td>
<td>
<p>A matrix, data frame or tibble of at least two columns representing
x and y coordinates.</p>
</td></tr>
<tr><td><code id="is_regular_grid_+3A_digits">digits</code></td>
<td>
<p>integer to set the precision for detecting whether points are
on a regular grid (a low number of digits is a low precision).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible()</code> if is regular or an error message otherwise
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_spatraster">as_spatraster()</a></code>
</p>
<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+pull_crs">pull_crs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- matrix(1:90, nrow = 45, ncol = 2)

is_regular_grid(p)


# Jitter location
set.seed(1234)
jitter &lt;- runif(length(p)) / 10e4
p_jitter &lt;- p + jitter

# Need to adjust digits
is_regular_grid(p_jitter, digits = 4)

</code></pre>

<hr>
<h2 id='mutate-joins.SpatVector'>Mutating joins for SpatVectors</h2><span id='topic+mutate-joins.SpatVector'></span><span id='topic+inner_join.SpatVector'></span><span id='topic+left_join.SpatVector'></span><span id='topic+right_join.SpatVector'></span><span id='topic+full_join.SpatVector'></span>

<h3>Description</h3>

<p>Mutating joins add columns from <code>y</code> to <code>x</code>, matching observations based on
the keys. There are four mutating joins: the inner join, and the three outer
joins.
</p>
<p>See <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)

## S3 method for class 'SpatVector'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate-joins.SpatVector_+3A_x">x</code></td>
<td>
<p>A SpatVector created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_y">y</code></td>
<td>
<p>A data frame or other object coercible to a data frame. <strong>If a
SpatVector of sf object</strong> is provided it would return an error (see
<code><a href="terra.html#topic+intersect">terra::intersect()</a></code> for performing spatial joins).</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="mutate-joins.SpatVector_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector object.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> family
</p>


<h4>SpatVector</h4>

<p>The geometry column has a sticky behavior. This means that the result would
have always the geometry of <code>x</code> for the records that matches the join
conditions.
</p>
<p>Note that for <code><a href="#topic+right_join">right_join()</a></code> and <code><a href="#topic+full_join">full_join()</a></code> it is possible to return
empty geometries (since <code>y</code> is expected to be a data frame with no
geometries). Although this kind of joining operations may not be common on
spatial manipulation, it is possible that the function crashes, since
handling of <code>EMPTY</code> geometries differs on <span class="pkg">terra</span> and <span class="pkg">sf</span> (the
backend of <code style="white-space: pre;">&#8288;*_join.SpatVector()&#8288;</code> is the implementation made on <span class="pkg">sf</span>).
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code>, <code><a href="terra.html#topic+merge">terra::merge()</a></code>
</p>
<p>Other dplyr verbs that operate on pairs Spat*/data.frame:
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)
# Vector
v &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# A data frame
df &lt;- data.frame(
  cpro = sprintf("%02d", 1:10),
  x = runif(10),
  y = runif(10),
  letter = rep_len(LETTERS[1:3], length.out = 10)
)

# Inner join
inner &lt;- v %&gt;% inner_join(df)

nrow(inner)
autoplot(inner, aes(fill = letter)) + ggtitle("Inner Join")


# Left join

left &lt;- v %&gt;% left_join(df)
nrow(left)

autoplot(left, aes(fill = letter)) + ggtitle("Left Join")


# Right join
right &lt;- v %&gt;% right_join(df)
nrow(right)

autoplot(right, aes(fill = letter)) + ggtitle("Right Join")

# There are empty geometries, check with data from df
ggplot(right, aes(x, y)) +
  geom_point(aes(color = letter))


# Full join
full &lt;- v %&gt;% full_join(df)
nrow(full)

autoplot(full, aes(fill = letter)) + ggtitle("Full Join")

# Check with data from df
ggplot(full, aes(x, y)) +
  geom_point(aes(color = letter))

</code></pre>

<hr>
<h2 id='mutate.Spat'>Create, modify, and delete cell values/layers/attributes of Spat* objects</h2><span id='topic+mutate.Spat'></span><span id='topic+mutate.SpatRaster'></span><span id='topic+transmute.Spat'></span><span id='topic+mutate.SpatVector'></span><span id='topic+transmute.SpatRaster'></span><span id='topic+transmute.SpatVector'></span>

<h3>Description</h3>

<p><code>mutate()</code> adds new layers/attributes and preserves existing ones on a
Spat* object. <code>transmute()</code> adds new layers/attributes and drops existing
ones. New variables overwrite existing variables of the same name. Variables
can be removed by setting their value to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
mutate(.data, ...)

## S3 method for class 'SpatVector'
mutate(.data, ...)

## S3 method for class 'SpatRaster'
transmute(.data, ...)

## S3 method for class 'SpatVector'
transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="mutate.Spat_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+mutate">data-masking</a></code> Name-value pairs. The name gives
the name of the layer/attribute in the output. See <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>terra equivalent</h3>

<p>Some terra methods for modifying cell values:
<code><a href="terra.html#topic+ifelse">terra::ifel()</a></code>, <code><a href="terra.html#topic+classify">terra::classify()</a></code>, <code><a href="terra.html#topic+clamp">terra::clamp()</a></code>, <code><a href="terra.html#topic+app">terra::app()</a></code>,
<code><a href="terra.html#topic+lapp">terra::lapp()</a></code>, <code><a href="terra.html#topic+tapp">terra::tapp()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generics</strong> <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>
functions.
</p>


<h4>SpatRaster</h4>

<p>Add new layers and preserves existing ones. The result is a
SpatRaster with the same extent, resolution and crs than <code>.data</code>. Only the
values (and possibly the number) of layers is modified.
</p>
<p><code>transmute()</code> would keep only the layers created with <code>...</code>.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector with the modified (and possibly renamed)
attributes on the function call.
</p>
<p><code>transmute()</code> would keep only the attributes created with <code>...</code>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatRaster method
f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
spatrast &lt;- rast(f)

mod &lt;- spatrast %&gt;%
  mutate(exp_lyr1 = exp(tavg_04 / 10)) %&gt;%
  select(tavg_04, exp_lyr1)

mod
plot(mod)

# SpatVector method
f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")
v &lt;- vect(f)

v %&gt;%
  mutate(cpro2 = paste0(cpro, "-CyL")) %&gt;%
  select(cpro, cpro2)
</code></pre>

<hr>
<h2 id='pull_crs'>Extract CRS on WKT format</h2><span id='topic+pull_crs'></span>

<h3>Description</h3>

<p>Extract the WKT version of the CRS associated to a string, number of
sf/Spat* object.
</p>
<p>The <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_coordinate_reference_systems">Well-known text (WKT)</a>
representation of coordinate reference systems (CRS) is a character string
that identifies precisely the parameters of each CRS. This is the current
standard used on sf and terra packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_crs(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_crs_+3A_.data">.data</code></td>
<td>
<p>Input potentially including or representing a CRS. It could be
a <code>sf/sfc</code> object, a <code>SpatRaster/SpatVector</code> object, a <code>crs</code> object from
<code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>, a character (for example a proj4 string) or a integer
(representing an EPSG code).</p>
</td></tr>
<tr><td><code id="pull_crs_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although the WKT representation is the same, sf and terra slightly differs.
For example, a sf user could do:
</p>
<p><code>sf::st_transform(x, 25830)</code>
</p>
<p>While a terra user needs to:
</p>
<p><code>terra::project(bb, "epsg:25830")</code>
</p>
<p>Knowing the WKT would help to smooth workflows when working with different
packages and object types.
</p>


<h3>Value</h3>

<p>A WKT representation of the corresponding CRS.
</p>


<h3>Internals</h3>

<p>This is a thin wrapper of <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> and <code><a href="terra.html#topic+crs">terra::crs()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">terra::crs()</a></code>, <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code>
</p>
<p>Other helpers: 
<code><a href="#topic+compare_spatrasters">compare_spatrasters</a>()</code>,
<code><a href="#topic+is_grouped_spatvector">is_grouped_spatvector</a>()</code>,
<code><a href="#topic+is_regular_grid">is_regular_grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sf objects

sfobj &lt;- sf::st_as_sfc("MULTIPOINT ((0 0), (1 1))", crs = 4326)

fromsf1 &lt;- pull_crs(sfobj)
fromsf2 &lt;- pull_crs(sf::st_crs(sfobj))

# terra

v &lt;- terra::vect(sfobj)
r &lt;- terra::rast(v)

fromterra1 &lt;- pull_crs(v)
fromterra2 &lt;- pull_crs(r)

# integers
fromint &lt;- pull_crs(4326)

# Characters
fromchar &lt;- pull_crs("epsg:4326")


all(
  fromsf1 == fromsf2,
  fromsf2 == fromterra1,
  fromterra1 == fromterra2,
  fromterra2 == fromint,
  fromint == fromchar
)

cat(fromsf1)
</code></pre>

<hr>
<h2 id='pull.Spat'>Extract a single layer/attribute</h2><span id='topic+pull.Spat'></span><span id='topic+pull.SpatRaster'></span><span id='topic+pull.SpatVector'></span>

<h3>Description</h3>

<p><code>pull()</code> is similar to $ on a data frame. It's mostly useful because it
looks a little nicer in pipes and it can optionally name the output.
</p>
<p><strong>It is possible to extract the geographic coordinates of a SpatRaster</strong>.
You need to use <code>pull(.data, x, xy = TRUE)</code>. <code>x</code> and <code>y</code> are reserved
names on terra, since they refer to the geographic coordinates of the layer.
</p>
<p>See <strong>Examples</strong> and section <strong>About layer names</strong> on <code><a href="#topic+as_tibble.Spat">as_tibble.Spat()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
pull(.data, var = -1, name = NULL, ...)

## S3 method for class 'SpatVector'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal layer/attribute name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last layer/attribute (on the assumption that's the
column you've created most recently).</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used as
names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull.Spat_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+as_tibble">as_tibble()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same number of cells/geometries as <code>.data</code>.
</p>
<p>On SpatRasters, note that the default (<code>na.rm = FALSE</code>) would remove
empty cells, so you may need to pass (<code>na.rm = FALSE</code>) to <code>...</code>. See
<code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+values">terra::values()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> function. This is done
by coercing the Spat* object to a tibble first (see <a href="#topic+as_tibble.Spat">as_tibble.Spat</a>) and
then using <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> method over the tibble.
</p>


<h4>SpatRaster</h4>

<p>When passing option <code>na.rm = TRUE</code> to <code>...</code>, only cells with a value
distinct to <code>NA</code> are extracted. See <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code>.
</p>
<p>If <code>xy = TRUE</code> option is passed to <code>...</code>, two columns names <code>x</code> and <code>y</code>
(corresponding to the geographic coordinates of each cell) are available
in position <code>1</code> and <code>2</code>. Hence, <code>pull(.data, 1)</code> and
<code>pull(.data, 1, xy = TRUE)</code> return different result.
</p>



<h4>SpatVector</h4>

<p>When passing <code>geom = "WKT"/geom = "HEX"</code> to <code>...</code>,  the geometry of the
SpatVector can be pulled passing <code>var = geometry</code>. Similarly to SpatRaster
method, when using <code>geom = "XY"</code> the <code style="white-space: pre;">&#8288;x,y&#8288;</code> coordinates can be pulled with
<code>var = x/var = y</code>. See  <code><a href="terra.html#topic+as.data.frame">terra::as.data.frame()</a></code> options.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
r &lt;- rast(f)

# Extract second layer
r %&gt;%
  pull(2) %&gt;%
  head()

# With xy the first two cols are `x` (longitude) and `y` (latitude)

r %&gt;%
  pull(2, xy = TRUE) %&gt;%
  head()

# With renaming

r %&gt;%
  mutate(cat = cut(cyl_tile_3, c(0, 100, 300))) %&gt;%
  pull(cyl_tile_3, name = cat) %&gt;%
  head()

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+arrange'></span><span id='topic+as_tibble'></span><span id='topic+autoplot'></span><span id='topic+count'></span><span id='topic+tally'></span><span id='topic+distinct'></span><span id='topic+drop_na'></span><span id='topic+filter'></span><span id='topic+fortify'></span><span id='topic+glimpse'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+group_by_drop_default'></span><span id='topic+group_data'></span><span id='topic+group_keys'></span><span id='topic+group_rows'></span><span id='topic+group_indices'></span><span id='topic+group_vars'></span><span id='topic+groups'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+full_join'></span><span id='topic+semi_join'></span><span id='topic+anti_join'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+pull'></span><span id='topic+relocate'></span><span id='topic+rename'></span><span id='topic+rename_with'></span><span id='topic+replace_na'></span><span id='topic+rowwise'></span><span id='topic+select'></span><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_max'></span><span id='topic+slice_min'></span><span id='topic+slice_tail'></span><span id='topic+slice_sample'></span><span id='topic+summarise'></span><span id='topic+summarize'></span><span id='topic+aes'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="dplyr.html#topic+distinct">distinct</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+glimpse">glimpse</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default</a></code>, <code><a href="dplyr.html#topic+group_data">group_data</a></code>, <code><a href="dplyr.html#topic+group_data">group_indices</a></code>, <code><a href="dplyr.html#topic+group_data">group_keys</a></code>, <code><a href="dplyr.html#topic+group_data">group_rows</a></code>, <code><a href="dplyr.html#topic+group_data">group_size</a></code>, <code><a href="dplyr.html#topic+group_data">group_vars</a></code>, <code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+group_data">n_groups</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+relocate">relocate</a></code>, <code><a href="dplyr.html#topic+rename">rename</a></code>, <code><a href="dplyr.html#topic+rename">rename_with</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+rowwise">rowwise</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+slice">slice_head</a></code>, <code><a href="dplyr.html#topic+slice">slice_max</a></code>, <code><a href="dplyr.html#topic+slice">slice_min</a></code>, <code><a href="dplyr.html#topic+slice">slice_sample</a></code>, <code><a href="dplyr.html#topic+slice">slice_tail</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+count">tally</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+fortify">fortify</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+drop_na">drop_na</a></code>, <code><a href="tidyr.html#topic+replace_na">replace_na</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relocate.Spat'>Change layer/attribute order</h2><span id='topic+relocate.Spat'></span><span id='topic+relocate.SpatRaster'></span><span id='topic+relocate.SpatVector'></span>

<h3>Description</h3>

<p>Use <code>relocate()</code> to change layer/attribute positions, using the same syntax
as <code><a href="#topic+select">select()</a></code> to make it easy to move blocks of layers/attributes at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
relocate(.data, ..., .before = NULL, .after = NULL)

## S3 method for class 'SpatVector'
relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="relocate.Spat_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+relocate">tidy-select</a></code> layers/attributes to move.</p>
</td></tr>
<tr><td><code id="relocate.Spat_+3A_.before">.before</code>, <code id="relocate.Spat_+3A_.after">.after</code></td>
<td>
<p><code><a href="dplyr.html#topic+relocate">tidy-select</a></code> Destination of
layers/attributes selected by <code>...</code>. Supplying neither will move
layers/attributes to the left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>terra equivalent</h3>

<p><code>terra::subset(data, c("name_layer", "name_other_layer"))</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Relocate layers of a SpatRaster.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector with the attributes on a different order.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)


f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
spatrast &lt;- rast(f) %&gt;% mutate(aa = 1, bb = 2, cc = 3)

names(spatrast)


spatrast %&gt;%
  relocate(bb, .before = cyl_tile_3) %&gt;%
  relocate(cyl_tile_1, .after = last_col())

</code></pre>

<hr>
<h2 id='rename.Spat'>Rename layers/attributes</h2><span id='topic+rename.Spat'></span><span id='topic+rename.SpatRaster'></span><span id='topic+rename_with.SpatRaster'></span><span id='topic+rename.SpatVector'></span><span id='topic+rename_with.SpatVector'></span>

<h3>Description</h3>

<p><code>rename()</code> changes the names of individual layers/attributes using
<code>new_name = old_name</code> syntax; <code>rename_with()</code> renames layers/attributes
using a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
rename(.data, ...)

## S3 method for class 'SpatRaster'
rename_with(.data, .fn, .cols = everything(), ...)

## S3 method for class 'SpatVector'
rename(.data, ...)

## S3 method for class 'SpatVector'
rename_with(.data, .fn, .cols = everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="rename.Spat_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: <code>tidy-select</code> Use <code style="white-space: pre;">&#8288;new_name = old_name to rename&#8288;</code>
selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="rename.Spat_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="rename.Spat_+3A_.cols">.cols</code></td>
<td>
<p><code>tidy-select</code> Columns to rename; defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>terra equivalent</h3>

<p><code style="white-space: pre;">&#8288;names(Spat*) &lt;- c("a", "b", "c")&#8288;</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Rename layers of a SpatRaster.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector with the renamed attributes on the function call.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
f &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")
spatrast &lt;- rast(f) %&gt;% mutate(aa = 1, bb = 2, cc = 3)

spatrast

spatrast %&gt;% rename(
  this_first = cyl_tile_1,
  this_second = cyl_tile_2
)

spatrast %&gt;% rename_with(
  toupper,
  .cols = starts_with("c")
)
</code></pre>

<hr>
<h2 id='replace_na.Spat'>Replace NAs with specified values</h2><span id='topic+replace_na.Spat'></span><span id='topic+replace_na.SpatRaster'></span><span id='topic+replace_na.SpatVector'></span>

<h3>Description</h3>

<p>Replace <code>NAs</code> on layers/attributes with specified values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
replace_na(data, replace = list(), ...)

## S3 method for class 'SpatVector'
replace_na(data, replace, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na.Spat_+3A_data">data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="replace_na.Spat_+3A_replace">replace</code></td>
<td>
<p>list of values, with one value for each layer/attribute that
has <code>NA</code> values to be replaced.</p>
</td></tr>
<tr><td><code id="replace_na.Spat_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>data</code>. Geometries and
spatial attributes are preserved.
</p>


<h3>terra equivalent</h3>

<p>Use <code style="white-space: pre;">&#8288;r[is.na(r)] &lt;- &lt;replacement&gt;&#8288;</code>
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code>
</p>
<p>Other tidyr.methods: 
<code><a href="#topic+drop_na.SpatVector">drop_na.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

r %&gt;% plot()

r %&gt;%
  replace_na(list(tavg_04 = 6, tavg_06 = 20)) %&gt;%
  plot()

</code></pre>

<hr>
<h2 id='rowwise.SpatVector'>Group SpatVector by rows</h2><span id='topic+rowwise.SpatVector'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>rowwise()</code> allows you to compute on a SpatVector a row-at-a-time.
This is most useful when a vectorised function doesn't exist.
</p>
<p>Most dplyr verbs implementation in <span class="pkg">tidyterra</span> preserve row-wise
grouping, with the exception of <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>. You can explicitly
ungroup with <code><a href="#topic+ungroup.SpatVector">ungroup.SpatVector()</a></code> or <code><a href="#topic+as_tibble">as_tibble()</a></code>, or convert to a
grouped SpatVector with <code><a href="#topic+group_by.SpatVector">group_by.SpatVector()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
rowwise(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise.SpatVector_+3A_data">data</code></td>
<td>
<p>A SpatVector object. See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="rowwise.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to be
preserved when calling <code><a href="#topic+summarise.SpatVector">summarise.SpatVector()</a></code>. This is typically a set
of variables whose combination uniquely identify each row. See
<code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <strong>Details</strong> on <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>.
</p>


<h3>Value</h3>

<p>A SpatVector object with an additional attribute.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code> function for
SpatVectors.
</p>
<p><strong>When mixing</strong> <span class="pkg">terra</span> <strong>and</strong> <span class="pkg">dplyr</span> <strong>syntax</strong> on a row-wise
SpatVector (i.e, subsetting a SpatVector like <code>v[1:3,1:2]</code>) the <code>groups</code>
attribute can be corrupted. <span class="pkg">tidyterra</span> would try to re-generate the
SpatVector. This would be triggered the next time you use a dplyr verb on
your SpatVector.
</p>
<p>Note also that some operations (as <code>terra::spatSample()</code>) would create a new
SpatVector. In these cases, the result won't preserve the <code>groups</code> attribute.
Use <code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector()</a></code> to re-group.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>
</p>
<p>Other dplyr verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(dplyr)

v &lt;- terra::vect(system.file("shape/nc.shp", package = "sf"))

# Select new births
nb &lt;- v %&gt;%
  select(starts_with("NWBIR")) %&gt;%
  glimpse()

# Compute the mean of NWBIR on each geometry
nb %&gt;%
  rowwise() %&gt;%
  mutate(nb_mean = mean(c(NWBIR74, NWBIR79)))

# Additional examples

# use c_across() to more easily select many variables
nb %&gt;%
  rowwise() %&gt;%
  mutate(m = mean(c_across(NWBIR74:NWBIR79)))

# Compute the minimum of x and y in each row

nb %&gt;%
  rowwise() %&gt;%
  mutate(min = min(c_across(NWBIR74:NWBIR79)))

# Summarising
v %&gt;%
  rowwise() %&gt;%
  summarise(mean_bir = mean(BIR74, BIR79)) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = mean_bir))

# Supply a variable to be kept
v %&gt;%
  mutate(id2 = as.integer(CNTY_ID / 100)) %&gt;%
  rowwise(id2) %&gt;%
  summarise(mean_bir = mean(BIR74, BIR79)) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = as.factor(id2)))

</code></pre>

<hr>
<h2 id='scale_color_coltab'>Gradient scales from Wikipedia color schemes</h2><span id='topic+scale_color_coltab'></span><span id='topic+scale_wiki'></span><span id='topic+scale_fill_wiki_d'></span><span id='topic+scale_colour_wiki_d'></span><span id='topic+scale_color_wiki_d'></span><span id='topic+scale_fill_wiki_c'></span><span id='topic+scale_colour_wiki_c'></span><span id='topic+scale_color_wiki_c'></span><span id='topic+scale_fill_wiki_b'></span><span id='topic+scale_colour_wiki_b'></span><span id='topic+scale_color_wiki_b'></span><span id='topic+wiki.colors'></span>

<h3>Description</h3>

<p>Implementation based on the
<a href="https://en.wikipedia.org/wiki/Wikipedia:WikiProject_Maps/Conventions/Topographic_maps">Wikipedia Colorimetric conventions for topographic maps</a>.
Three scales are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_wiki_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additionally, a color palette <code>wiki.colors()</code> is provided. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p>Note that <span class="pkg">tidyterra</span> just documents a selection of these additional
parameters, check the previous links to see the full range of parameters
accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_wiki_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_wiki_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_wiki_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_wiki_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_wiki_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_wiki_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

wiki.colors(n, alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_color_coltab_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_color_coltab_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <span class="pkg">ggplot2</span> docs on additional <code>...</code> parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = wiki.colors(100))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_wiki_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_wiki_b(breaks = seq(70, 200, 10))

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_wiki_d(na.value = "gray10")

</code></pre>

<hr>
<h2 id='scale_coltab'>Discrete scales based in the color table of a SpatRaster</h2><span id='topic+scale_coltab'></span><span id='topic+scale_fill_coltab'></span><span id='topic+scale_colour_coltab'></span><span id='topic+get_coltab_pal'></span>

<h3>Description</h3>

<p>Some categorical SpatRaster may have an associated color table. This
function extract those values. These functions generates scales and vector
of colors based on the color table <code><a href="terra.html#topic+colors">terra::coltab()</a></code> associated to a
SpatRaster.
</p>
<p>You can also get a vector of colors named with the corresponding
factor with <code><a href="#topic+get_coltab_pal">get_coltab_pal()</a></code>.
</p>
<p>Additional parameters <code>...</code> would be passed on to
<code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>. Note that <span class="pkg">tidyterra</span> just documents a
selection of these additional parameters, check the previous link to see the
full range of parameters accepted by this scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_coltab(
  data,
  ...,
  alpha = 1,
  na.translate = FALSE,
  na.value = "transparent",
  drop = TRUE
)

scale_colour_coltab(
  data,
  ...,
  alpha = 1,
  na.translate = FALSE,
  na.value = "transparent",
  drop = TRUE
)

get_coltab_pal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_coltab_+3A_data">data</code>, <code id="scale_coltab_+3A_x">x</code></td>
<td>
<p>A SpatRaster with one or several color tables. See
<code><a href="terra.html#topic+colors">terra::has.colors()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_coltab_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_coltab_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+colors">terra::coltab()</a></code>, <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>,
<code><a href="ggplot2.html#topic+scale_manual">ggplot2::scale_fill_manual()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
# Geological Eras
# Spanish Geological Survey (IGME)

r &lt;- rast(system.file("extdata/cyl_era.tif", package = "tidyterra"))

plot(r)

# Get coltab
coltab_pal &lt;- get_coltab_pal(r)

coltab_pal


# With ggplot2 + tidyterra
library(ggplot2)

gg &lt;- ggplot() +
  geom_spatraster(data = r)


# Default plot
gg

# With coltabs
gg +
  scale_fill_coltab(data = r)

</code></pre>

<hr>
<h2 id='scale_cross_blended'>Cross blended Hypsometric Tints scales</h2><span id='topic+scale_cross_blended'></span><span id='topic+scale_fill_cross_blended_d'></span><span id='topic+scale_colour_cross_blended_d'></span><span id='topic+scale_fill_cross_blended_c'></span><span id='topic+scale_colour_cross_blended_c'></span><span id='topic+scale_fill_cross_blended_b'></span><span id='topic+scale_colour_cross_blended_b'></span><span id='topic+cross_blended.colors'></span><span id='topic+scale_fill_cross_blended_tint_d'></span><span id='topic+scale_colour_cross_blended_tint_d'></span><span id='topic+scale_fill_cross_blended_tint_c'></span><span id='topic+scale_colour_cross_blended_tint_c'></span><span id='topic+scale_fill_cross_blended_tint_b'></span><span id='topic+scale_colour_cross_blended_tint_b'></span><span id='topic+cross_blended.colors2'></span><span id='topic+scale_color_cross_blended_d'></span><span id='topic+scale_color_cross_blended_tint_d'></span><span id='topic+scale_color_cross_blended_c'></span><span id='topic+scale_color_cross_blended_tint_c'></span><span id='topic+scale_color_cross_blended_b'></span><span id='topic+scale_color_cross_blended_tint_b'></span>

<h3>Description</h3>

<p>Implementation of the cross blended hypsometric gradients presented on
<a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>. The following fill scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>cross_blended.colors()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>An additional set of scales is provided. These scales can act as
<a href="https://en.wikipedia.org/wiki/Hypsometric_tints">hypsometric (or bathymetric) tints</a>.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>cross_blended.colors2()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>See <strong>Details</strong>.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p>Note that <span class="pkg">tidyterra</span> just documents a selection of these additional
parameters, check the previous links to see the full range of parameters
accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_cross_blended_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_cross_blended_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_cross_blended_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_cross_blended_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_cross_blended_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_cross_blended_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

cross_blended.colors(n, palette = "cold_humid", alpha = 1, rev = FALSE)

scale_fill_cross_blended_tint_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_cross_blended_tint_d(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_cross_blended_tint_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_cross_blended_tint_c(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_cross_blended_tint_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_cross_blended_tint_b(
  palette = "cold_humid",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

cross_blended.colors2(n, palette = "cold_humid", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_cross_blended_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
<a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a> for more info. Values available are:
<code>"arid"</code>, <code>"cold_humid"</code>, <code>"polar"</code>, <code>"warm_humid"</code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_cross_blended_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>On <code style="white-space: pre;">&#8288;scale_*_cross_blended_tint_*&#8288;</code> palettes, the position of the gradients
and the limits of the palette are redefined. Instead of treating the color
palette as a continuous gradient, they are rescaled to act as a hypsometric
tint. A rough description of these tints are:
</p>

<ul>
<li><p> Blue colors: Negative values.
</p>
</li>
<li><p> Green colors: 0 to 1.000 values.
</p>
</li>
<li><p> Browns: 1000 to 4.000 values.
</p>
</li>
<li><p> Whites: Values higher than 4.000.
</p>
</li></ul>

<p>The following orientation would vary depending on the palette definition
(see <a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a> for an example on how this could
be achieved).
</p>
<p>Note that the setup of the palette may not be always suitable for your
specific data. For example, raster of small parts of the globe (and with a
limited range of elevations) may not be well represented. As an example, a
raster with a range of values on <code style="white-space: pre;">&#8288;[100, 200]&#8288;</code> would appear almost as an
uniform color.
</p>
<p>This could be adjusted using the <code>limits</code>/<code>values</code> provided by <strong>ggplot2</strong>.
</p>
<p><code>cross_blended.colors2()</code> provides a gradient color palette where the
distance between colors is different depending of the type of color.
In contrast, <code>cross_blended.colors()</code> provides an uniform gradient across
colors. See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p>Patterson, T., &amp; Jenny, B. (2011). The Development and
Rationale of Cross-blended Hypsometric Tints. <em>Cartographic Perspectives,</em>
(69), 31 - 46. <a href="https://doi.org/10.14714/CP69.20">doi:10.14714/CP69.20</a>.
</p>
<p>Patterson, T. (2004). <em>Using Cross-blended Hypsometric Tints for Generalized
Environmental Mapping.</em> Accessed June 10, 2022.
<a href="http://www.shadedrelief.com/hypso/hypso.html">http://www.shadedrelief.com/hypso/hypso.html</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a>, <code><a href="terra.html#topic+plot">terra::plot()</a></code>,
<code><a href="terra.html#topic+minmax">terra::minmax()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>.
</p>
<p>See also <span class="pkg">ggplot2</span> docs on additional <code>...</code> parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = cross_blended.colors(100, palette = "arid"))

# Palette with uneven colors
plot(volcano2_rast, col = cross_blended.colors2(100, palette = "arid"))


library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_c(palette = "cold_humid")

# Use hypsometric  tint version...
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_tint_c(palette = "cold_humid")

# ...but not suitable for the range of the raster: adjust
my_lims &lt;- minmax(volcano2_rast) %&gt;% as.integer() + c(-2, 2)

ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_tint_c(
    palette = "cold_humid",
    limits = my_lims
  )

# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_cross_blended_tint_c(
    palette = "warm_humid",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = TRUE)
  ) +
  labs(fill = "elevation (m)") +
  theme_minimal()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_b(breaks = seq(70, 200, 25), palette = "arid")

# With limits and breaks
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_cross_blended_tint_b(
    breaks = seq(75, 200, 25),
    palette = "arid",
    limits = my_lims
  )

# With discrete values
factor &lt;- volcano2_rast %&gt;%
  mutate(cats = cut(elevation,
    breaks = c(100, 120, 130, 150, 170, 200),
    labels = c(
      "Very Low", "Low", "Average", "High",
      "Very High"
    )
  ))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_cross_blended_d(na.value = "gray10", palette = "cold_humid")


# Tint version
ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_cross_blended_tint_d(
    na.value = "gray10",
    palette = "cold_humid"
  )

# Display all the cross-blended palettes

pals &lt;- unique(cross_blended_hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = cross_blended.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
# Display all the cross-blended palettes on version 2

pals &lt;- unique(cross_blended_hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = cross_blended.colors2(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_hypso'>Gradient scales for representing hypsometry and bathymetry</h2><span id='topic+scale_hypso'></span><span id='topic+scale_fill_hypso_d'></span><span id='topic+scale_colour_hypso_d'></span><span id='topic+scale_fill_hypso_c'></span><span id='topic+scale_colour_hypso_c'></span><span id='topic+scale_fill_hypso_b'></span><span id='topic+scale_colour_hypso_b'></span><span id='topic+hypso.colors'></span><span id='topic+scale_fill_hypso_tint_d'></span><span id='topic+scale_colour_hypso_tint_d'></span><span id='topic+scale_fill_hypso_tint_c'></span><span id='topic+scale_colour_hypso_tint_c'></span><span id='topic+scale_fill_hypso_tint_b'></span><span id='topic+scale_colour_hypso_tint_b'></span><span id='topic+hypso.colors2'></span><span id='topic+scale_color_hypso_d'></span><span id='topic+scale_color_hypso_tint_d'></span><span id='topic+scale_color_hypso_c'></span><span id='topic+scale_color_hypso_tint_c'></span><span id='topic+scale_color_hypso_b'></span><span id='topic+scale_color_hypso_tint_b'></span>

<h3>Description</h3>

<p>Implementation of a selection of gradient palettes available in
<a href="http://soliton.vm.bytemark.co.uk/pub/cpt-city/">cpt-city</a>.
</p>
<p>The following scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>hypso.colors()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>An additional set of scales is provided. These scales can act as
<a href="https://en.wikipedia.org/wiki/Hypsometric_tints">hypsometric (or bathymetric) tints</a>.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_hypso_tint_b()&#8288;</code>: For binning continuous values.
</p>
</li>
<li> <p><code>hypso.colors2()</code>: A gradient color palette. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
</li></ul>

<p>See <strong>Details</strong>.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p>Note that <span class="pkg">tidyterra</span> just documents a selection of these additional
parameters, check the previous links to see the full range of parameters
accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_hypso_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_hypso_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_hypso_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_hypso_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_hypso_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_hypso_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

hypso.colors(n, palette = "etopo1_hypso", alpha = 1, rev = FALSE)

scale_fill_hypso_tint_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_hypso_tint_d(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_hypso_tint_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_hypso_tint_c(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_hypso_tint_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_hypso_tint_b(
  palette = "etopo1_hypso",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  na.value = "transparent",
  guide = "coloursteps"
)

hypso.colors2(n, palette = "etopo1_hypso", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_hypso_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
<a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a> for more info. Values available are:
<code>"arctic"</code>, <code>"arctic_bathy"</code>, <code>"arctic_hypso"</code>, <code>"c3t1"</code>, <code>"colombia"</code>, <code>"colombia_bathy"</code>, <code>"colombia_hypso"</code>, <code>"dem_poster"</code>, <code>"dem_print"</code>, <code>"dem_screen"</code>, <code>"etopo1"</code>, <code>"etopo1_bathy"</code>, <code>"etopo1_hypso"</code>, <code>"gmt_globe"</code>, <code>"gmt_globe_bathy"</code>, <code>"gmt_globe_hypso"</code>, <code>"meyers"</code>, <code>"meyers_bathy"</code>, <code>"meyers_hypso"</code>, <code>"moon"</code>, <code>"moon_bathy"</code>, <code>"moon_hypso"</code>, <code>"nordisk-familjebok"</code>, <code>"nordisk-familjebok_bathy"</code>, <code>"nordisk-familjebok_hypso"</code>, <code>"pakistan"</code>, <code>"spain"</code>, <code>"usgs-gswa2"</code>, <code>"utah_1"</code>, <code>"wiki-2.0"</code>, <code>"wiki-2.0_bathy"</code>, <code>"wiki-2.0_hypso"</code>, <code>"wiki-schwarzwald-cont"</code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_hypso_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_values">values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code><a href="scales.html#topic+rescale">rescale()</a></code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td></tr>
<tr><td><code id="scale_hypso_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>On <code style="white-space: pre;">&#8288;scale_*_hypso_tint_*&#8288;</code> palettes, the position of the gradients and
the limits of the palette are redefined. Instead of treating the color
palette as a continuous gradient, they are rescaled to act as a hypsometric
tint. A rough description of these tints are:
</p>

<ul>
<li><p> Blue colors: Negative values.
</p>
</li>
<li><p> Green colors: 0 to 1.000 values.
</p>
</li>
<li><p> Browns: 1000 to 4.000 values.
</p>
</li>
<li><p> Whites: Values higher than 4.000.
</p>
</li></ul>

<p>The following orientation would vary depending on the palette definition
(see <a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a> for an example on how this could be achieved).
</p>
<p>Note that the setup of the palette may not be always suitable for your
specific data. For example, raster of small parts of the globe (and with a
limited range of elevations) may not be well represented. As an example, a
raster with a range of values on <code style="white-space: pre;">&#8288;[100, 200]&#8288;</code> would appear almost as an
uniform color.
</p>
<p>This could be adjusted using the <code>limits</code>/<code>values</code> provided by <strong>ggplot2</strong>.
</p>
<p><code>hypso.colors2()</code> provides a gradient color palette where the distance
between colors is different depending of the type of color. In contrast,
<code>hypso.colors()</code> provides an uniform gradient across colors.
See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p>cpt-city: <a href="http://soliton.vm.bytemark.co.uk/pub/cpt-city/">http://soliton.vm.bytemark.co.uk/pub/cpt-city/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a>, <code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="terra.html#topic+minmax">terra::minmax()</a></code>,
<code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <span class="pkg">ggplot2</span> docs on additional <code>...</code> parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = hypso.colors(100, palette = "wiki-2.0_hypso"))

# Palette with uneven colors
plot(volcano2_rast, col = hypso.colors2(100, palette = "wiki-2.0_hypso"))


library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_c(palette = "colombia_hypso")

# Use hypsometric  tint version...
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_tint_c(palette = "colombia_hypso")

# ...but not suitable for the range of the raster: adjust
my_lims &lt;- minmax(volcano2_rast) %&gt;% as.integer() + c(-2, 2)

ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_tint_c(
    palette = "colombia_hypso",
    limits = my_lims
  )

# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_hypso_tint_c(
    palette = "etopo1",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = TRUE)
  ) +
  labs(fill = "elevation (m)") +
  theme_minimal()


# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_b(breaks = seq(70, 200, 25), palette = "wiki-2.0_hypso")

# With limits and breaks
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_hypso_tint_b(
    breaks = seq(75, 200, 25),
    palette = "wiki-2.0_hypso",
    limits = my_lims
  )

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_hypso_d(na.value = "gray10", palette = "dem_poster")


# Tint version
ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_hypso_tint_d(na.value = "gray10", palette = "dem_poster")

# Display all the cpl_city palettes

pals &lt;- unique(hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = hypso.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
# Display all the cpl_city palettes on version 2

pals &lt;- unique(hypsometric_tints_db$pal)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = hypso.colors2(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='scale_terrain'>Terrain colour scales from grDevices</h2><span id='topic+scale_terrain'></span><span id='topic+scale_fill_terrain_d'></span><span id='topic+scale_colour_terrain_d'></span><span id='topic+scale_fill_terrain_c'></span><span id='topic+scale_colour_terrain_c'></span><span id='topic+scale_fill_terrain_b'></span><span id='topic+scale_colour_terrain_b'></span><span id='topic+scale_color_terrain_d'></span><span id='topic+scale_color_terrain_c'></span><span id='topic+scale_color_terrain_b'></span>

<h3>Description</h3>

<p>Implementation of the classic color palettes used by default by the
terra package (see <code><a href="terra.html#topic+plot">terra::plot()</a></code>):
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p>Note that <span class="pkg">tidyterra</span> just documents a selection of these additional
parameters, check the previous links to see the full range of parameters
accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_terrain_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_terrain_d(
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_terrain_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_terrain_c(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_terrain_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_terrain_b(
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_terrain_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_terrain_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_terrain_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/color</code> aesthetics.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code> and <span class="pkg">ggplot2</span> docs on
additional <code>...</code> parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_whitebox">scale_whitebox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_terrain_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_terrain_b(breaks = seq(70, 200, 10))

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_terrain_d(na.value = "gray10")

</code></pre>

<hr>
<h2 id='scale_whitebox'>Gradient scales from WhiteboxTools color schemes</h2><span id='topic+scale_whitebox'></span><span id='topic+scale_fill_whitebox_d'></span><span id='topic+scale_colour_whitebox_d'></span><span id='topic+scale_fill_whitebox_c'></span><span id='topic+scale_colour_whitebox_c'></span><span id='topic+scale_fill_whitebox_b'></span><span id='topic+scale_colour_whitebox_b'></span><span id='topic+whitebox.colors'></span><span id='topic+scale_color_whitebox_d'></span><span id='topic+scale_color_whitebox_c'></span><span id='topic+scale_color_whitebox_b'></span>

<h3>Description</h3>

<p>Implementation of the gradient palettes provided by
<a href="https://github.com/jblindsay/whitebox-tools">WhiteboxTools</a>. Three
scales are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_whitebox_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Additionally, a color palette <code>whitebox.colors()</code> is provided. See also
<code><a href="grDevices.html#topic+palettes">grDevices::terrain.colors()</a></code> for details.
</p>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li><p> Discrete values: <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code>
</p>
</li>
<li><p> Continuous values: <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale()</a></code>
</p>
</li>
<li><p> Binned continuous values: <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale()</a></code>.
</p>
</li></ul>

<p>Note that <span class="pkg">tidyterra</span> just documents a selection of these additional
parameters, check the previous links to see the full range of parameters
accepted by these scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_fill_whitebox_d(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_whitebox_d(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_whitebox_c(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_whitebox_c(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_whitebox_b(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_whitebox_b(
  palette = "high_relief",
  ...,
  alpha = 1,
  direction = 1,
  na.value = "transparent",
  guide = "coloursteps"
)

whitebox.colors(n, palette = "high_relief", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_whitebox_+3A_palette">palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. Values available are:
<code>"atlas"</code>, <code>"high_relief"</code>, <code>"arid"</code>, <code>"soft"</code>, <code>"muted"</code>, <code>"purple"</code>, <code>"viridi"</code>, <code>"gn_yl"</code>, <code>"pi_y_g"</code>, <code>"bl_yl_rd"</code>, <code>"deep"</code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale</a></code>, <code><a href="ggplot2.html#topic+continuous_scale">ggplot2::continuous_scale</a></code>, <code><a href="ggplot2.html#topic+binned_scale">ggplot2::binned_scale</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li><p> A character vector of breaks
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>labels</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>limits</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale values
</p>
</li>
<li><p> A character vector that defines possible values of the scale and their
order
</p>
</li>
<li><p> A function that accepts the existing (automatic) values and returns
new ones. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</dd>
<dt><code>expand</code></dt><dd><p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt><dd><p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</dd>
<dt><code>n.breaks</code></dt><dd><p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt><dd><p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_alpha">alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_direction">direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_na.translate">na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_drop">drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_n">n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td></tr>
<tr><td><code id="scale_whitebox_+3A_rev">rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corresponding ggplot2 layer with the values applied to the
<code>fill/colour</code> aesthetics.
</p>


<h3>Source</h3>

<p><a href="https://github.com/jblindsay/whitebox-tools">https://github.com/jblindsay/whitebox-tools</a>, under
MIT License. Copyright (c) 2017-2021 John Lindsay.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+plot">terra::plot()</a></code>, <code><a href="ggplot2.html#topic+scale_viridis">ggplot2::scale_fill_viridis_c()</a></code>
</p>
<p>See also <span class="pkg">ggplot2</span> docs on additional <code>...</code> parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_d()&#8288;</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_c()&#8288;</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;scale_*_terrain_b()&#8288;</code>: For binning continuous values.
</p>
</li></ul>

<p>Other gradient scales and palettes for hypsometry:
<code><a href="#topic+scale_color_coltab">scale_color_coltab</a>()</code>,
<code><a href="#topic+scale_cross_blended">scale_cross_blended</a></code>,
<code><a href="#topic+scale_hypso">scale_hypso</a></code>,
<code><a href="#topic+scale_terrain">scale_terrain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = whitebox.colors(100))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_whitebox_c()

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_whitebox_b(breaks = seq(70, 200, 10), palette = "atlas")

# With discrete values
factor &lt;- volcano2_rast %&gt;% mutate(cats = cut(elevation,
  breaks = c(100, 120, 130, 150, 170, 200),
  labels = c(
    "Very Low", "Low", "Average", "High",
    "Very High"
  )
))


ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_whitebox_d(na.value = "gray10", palette = "soft")


# Display all the whitebox palettes

pals &lt;- c(
  "atlas", "high_relief", "arid", "soft", "muted", "purple",
  "viridi", "gn_yl", "pi_y_g", "bl_yl_rd", "deep"
)

# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = whitebox.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>

<hr>
<h2 id='select.Spat'>Subset layers/attributes of Spat* objects</h2><span id='topic+select.Spat'></span><span id='topic+select.SpatRaster'></span><span id='topic+select.SpatVector'></span>

<h3>Description</h3>

<p>Select (and optionally rename) attributes/layers in Spat* objects, using a
concise mini-language. See <strong>Methods</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
select(.data, ...)

## S3 method for class 'SpatVector'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="select.Spat_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+select">tidy-select</a></code> One or more unquoted expressions
separated by commas. Layer/attribute names can be used as if they were
positions in the Spat* object, so expressions like x:y can be used to
select a range of layers/attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+subset">terra::subset()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>Select (and rename) layers of a SpatRaster. The result is a
SpatRaster with the same extent, resolution and crs than <code>.data</code>. Only the
number (and possibly the name) of layers is modified.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector with the selected (and possibly renamed)
attributes on the function call.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="terra.html#topic+subset">terra::subset()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on columns:
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

# SpatRaster method

spatrast &lt;- rast(
  crs = "EPSG:3857",
  nrows = 10,
  ncols = 10,
  extent = c(100, 200, 100, 200),
  nlyr = 6,
  vals = seq_len(10 * 10 * 6)
)

spatrast %&gt;% select(1)

# By name
spatrast %&gt;% select(lyr.1:lyr.4)

# Rename
spatrast %&gt;% select(a = lyr.1, c = lyr.6)

# SpatVector method

f &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

v &lt;- vect(f)

v

v %&gt;% select(1, 3)

v %&gt;% select(iso2, name2 = cpro)
</code></pre>

<hr>
<h2 id='slice.Spat'>Subset cells/rows/columns/geometries using their positions</h2><span id='topic+slice.Spat'></span><span id='topic+slice.SpatRaster'></span><span id='topic+slice.SpatVector'></span><span id='topic+slice_head.SpatRaster'></span><span id='topic+slice_head.SpatVector'></span><span id='topic+slice_tail.SpatRaster'></span><span id='topic+slice_tail.SpatVector'></span><span id='topic+slice_min.SpatRaster'></span><span id='topic+slice_min.SpatVector'></span><span id='topic+slice_max.SpatRaster'></span><span id='topic+slice_max.SpatVector'></span><span id='topic+slice_sample.SpatRaster'></span><span id='topic+slice_sample.SpatVector'></span><span id='topic+slice_rows'></span><span id='topic+slice_rows.SpatRaster'></span><span id='topic+slice_cols'></span><span id='topic+slice_cols.SpatRaster'></span><span id='topic+slice_colrows'></span><span id='topic+slice_colrows.SpatRaster'></span>

<h3>Description</h3>

<p><code>slice()</code> lets you index cells/rows/columns/geometries by their (integer)
locations. It allows you to select, remove, and duplicate those dimensions
of a Spat* object.
</p>
<p><strong>If you want to slice your SpatRaster by geographic coordinates</strong> use
<code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code> method.
</p>
<p>It is accompanied by a number of helpers for common use cases:
</p>

<ul>
<li> <p><code>slice_head()</code> and <code>slice_tail()</code> select the first or last
cells/geometries.
</p>
</li>
<li> <p><code>slice_sample()</code> randomly selects cells/geometries.
</p>
</li>
<li> <p><code>slice_rows()</code> and <code>slice_cols()</code> allow to subset entire rows or columns,
of a SpatRaster.
</p>
</li>
<li> <p><code>slice_colrows()</code> subsets regions of the raster by row and column position
of a SpatRaster.
</p>
</li></ul>

<p>You can get a skeleton of your SpatRaster with the cell, column and row
index with <code><a href="#topic+as_coordinates">as_coordinates()</a></code>.
</p>
<p>See <strong>Methods</strong> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
slice(.data, ..., .preserve = FALSE, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice(.data, ..., .preserve = FALSE)

## S3 method for class 'SpatRaster'
slice_head(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_head(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_tail(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_tail(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_min(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_max(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_sample(
  .data,
  ...,
  n,
  prop,
  weight_by = NULL,
  replace = FALSE,
  .keep_extent = FALSE
)

## S3 method for class 'SpatVector'
slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)

slice_rows(.data, ...)

## S3 method for class 'SpatRaster'
slice_rows(.data, ..., .keep_extent = FALSE)

slice_cols(.data, ...)

## S3 method for class 'SpatRaster'
slice_cols(.data, ..., .keep_extent = FALSE)

slice_colrows(.data, ...)

## S3 method for class 'SpatRaster'
slice_colrows(.data, ..., cols, rows, .keep_extent = FALSE, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice.Spat_+3A_.data">.data</code></td>
<td>
<p>A SpatRaster created with <code><a href="terra.html#topic+rast">terra::rast()</a></code> or a SpatVector
created with <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_...">...</code></td>
<td>
<p><code><a href="dplyr.html#topic+slice">data-masking</a></code> Integer row values. Provide
either positive values to keep, or negative values to drop.
</p>
<p>The values provided must be either all positive or all negative. Indices
beyond the number of rows in the input are silently ignored.
See <strong>Methods</strong>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored for Spat* objects</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_.keep_extent">.keep_extent</code></td>
<td>
<p>Should the extent of the resulting SpatRaster be kept?
See also <code><a href="terra.html#topic+trim">terra::trim()</a></code>, <code><a href="terra.html#topic+extend">terra::extend()</a></code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_n">n</code>, <code id="slice.Spat_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_order_by">order_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, should cells that present a value of <code>NA</code> removed when
computing <code>slice_min()/slice_max()</code>?. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code><a href="dplyr.html#topic+arrange">arrange()</a></code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_weight_by">weight_by</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_cols">cols</code>, <code id="slice.Spat_+3A_rows">rows</code></td>
<td>
<p>Integer col/row values of the SpatRaster</p>
</td></tr>
<tr><td><code id="slice.Spat_+3A_inverse">inverse</code></td>
<td>
<p>If <code>TRUE</code>, <code>.data</code> is inverse-masked to the given selection.
See <code><a href="terra.html#topic+mask">terra::mask()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Spat* object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+subset">terra::subset()</a></code>, <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code> function.
</p>


<h4>SpatRaster</h4>

<p>The result is a SpatRaster with the crs and resolution of the input and
where cell values of the selected cells/columns/rows are preserved.
</p>
<p>Use <code>.keep_extent = TRUE</code> to preserve the extent of <code>.data</code> on the output.
The non-selected cells would present a value of <code>NA</code>.
</p>



<h4>SpatVector</h4>

<p>The result is a SpatVector where the attributes of the selected
geometries are preserved. If <code>.data</code> is a
<a href="#topic+is_grouped_spatvector">grouped SpatVector</a>, the operation will be performed
on each group, so that (e.g.) <code>slice_head(df, n = 5)</code> will select the first
five rows in each group.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>, <code><a href="terra.html#topic+sample">terra::spatSample()</a></code>.
</p>
<p>You can get a skeleton of your SpatRaster with the cell, column and row
index with <code><a href="#topic+as_coordinates">as_coordinates()</a></code>.
</p>
<p>If you want to slice by geographic coordinates use <code><a href="#topic+filter.SpatRaster">filter.SpatRaster()</a></code>.
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>
<p>Other dplyr verbs that operate on rows:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+summarise.SpatVector">summarise.SpatVector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

# Slice first 100 cells
r %&gt;%
  slice(1:100) %&gt;%
  plot()

# Rows
r %&gt;%
  slice_rows(1:30) %&gt;%
  plot()

# Cols
r %&gt;%
  slice_cols(-(20:50)) %&gt;%
  plot()

# Spatial sample
r %&gt;%
  slice_sample(prop = 0.2) %&gt;%
  plot()


# Slice regions
r %&gt;%
  slice_colrows(
    cols = c(20:40, 60:80),
    rows = -c(1:20, 30:50)
  ) %&gt;%
  plot()

# Group wise operation with SpatVectors--------------------------------------
v &lt;- terra::vect(system.file("ex/lux.shp", package = "terra"))


glimpse(v) %&gt;% autoplot(aes(fill = NAME_1))

gv &lt;- v %&gt;% group_by(NAME_1)
# All slice helpers operate per group, silently truncating to the group size
gv %&gt;%
  slice_head(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_tail(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_min(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_max(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))

</code></pre>

<hr>
<h2 id='stat_spat_coordinates'>Extract coordinates from SpatVector objects</h2><span id='topic+stat_spat_coordinates'></span>

<h3>Description</h3>

<p><code>stat_spat_coordinates()</code> extracts the coordinates from SpatVector objects
and summarises them to one pair of coordinates (x and y) per geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_spat_coordinates(
  mapping = aes(),
  data = NULL,
  geom = "point",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_spat_coordinates_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_data">data</code></td>
<td>
<p>A SpatVector object, see <code><a href="terra.html#topic+vect">terra::vect()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
</p>
<p>You can also set this to one of &quot;polygon&quot;, &quot;line&quot;, and &quot;point&quot; to
override the default legend.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_spat_coordinates_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper of <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code>.
</p>
<p>See <code><a href="ggplot2.html#topic+stat_sf_coordinates">ggplot2::stat_sf_coordinates()</a></code> for details.
</p>


<h3>Value</h3>

<p>A ggplot2 layer
</p>


<h3>See Also</h3>

<p>Other ggplot2 utils:
<code><a href="#topic+autoplot.Spat">autoplot.Spat</a></code>,
<code><a href="#topic+fortify.Spat">fortify.Spat</a></code>,
<code><a href="#topic+geom_spat_contour">geom_spat_contour</a></code>,
<code><a href="#topic+geom_spatraster_rgb">geom_spatraster_rgb</a>()</code>,
<code><a href="#topic+geom_spatraster">geom_spatraster</a>()</code>,
<code><a href="#topic+ggspatvector">ggspatvector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cyl &lt;- terra::vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

library(ggplot2)

ggplot(cyl) +
  stat_spat_coordinates()

ggplot(cyl) +
  geom_errorbarh(
    aes(
      geometry = geometry,
      xmin = after_stat(x) - 50000,
      xmax = after_stat(x) + 50000,
      y = after_stat(y),
      height = 10000
    ),
    stat = "sf_coordinates"
  )


</code></pre>

<hr>
<h2 id='summarise.SpatVector'>Summarise each group of a SpatVector down to one geometry</h2><span id='topic+summarise.SpatVector'></span><span id='topic+summarize.SpatVector'></span>

<h3>Description</h3>

<p><code>summarise()</code> creates a new SpatVector. It returns one geometry for each
combination of grouping variables; if there are no grouping variables, the
output will have a single geometry summarising all observations in the input
and combining all the geometries of the SpatVector. It will contain one
column for each grouping variable and one column for each of
the summary statistics that you have specified.
</p>
<p><code>summarise.SpatVector()</code> and <code>summarize.SpatVector()</code> are synonyms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatVector'
summarise(.data, ..., .by = NULL, .groups = NULL, .dissolve = TRUE)

## S3 method for class 'SpatVector'
summarize(.data, ..., .by = NULL, .groups = NULL, .dissolve = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise.SpatVector_+3A_.data">.data</code></td>
<td>
<p>A SpatVector</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.by">.by</code></td>
<td>
<p>Ignored on this method. <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
on <span class="pkg">dplyr</span>.</p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.groups">.groups</code></td>
<td>
<p>See <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code></p>
</td></tr>
<tr><td><code id="summarise.SpatVector_+3A_.dissolve">.dissolve</code></td>
<td>
<p>logical. Should borders between aggregated geometries
be dissolved?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatVector.
</p>


<h3>terra equivalent</h3>

<p><code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> function.
</p>


<h4>SpatVector</h4>

<p>Similarly to the implementation on <span class="pkg">sf</span> this function can be used to
dissolve geometries (with <code>.dissolve = TRUE</code>) or create <code>MULTI</code> versions of
geometries (with <code>.dissolve = FALSE</code>). See <strong>Examples</strong>.
</p>



<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>, <code><a href="terra.html#topic+aggregate">terra::aggregate()</a></code>
</p>
<p>Other single table verbs: 
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>
<p>Other dplyr verbs that operate on group of rows:
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>
</p>
<p>Other dplyr methods:
<code><a href="#topic+arrange.SpatVector">arrange.SpatVector</a>()</code>,
<code><a href="#topic+bind_cols.SpatVector">bind_cols.SpatVector</a></code>,
<code><a href="#topic+bind_rows.SpatVector">bind_rows.SpatVector</a></code>,
<code><a href="#topic+count.SpatVector">count.SpatVector</a>()</code>,
<code><a href="#topic+distinct.SpatVector">distinct.SpatVector</a>()</code>,
<code><a href="#topic+filter-joins.SpatVector">filter-joins.SpatVector</a></code>,
<code><a href="#topic+filter.Spat">filter.Spat</a></code>,
<code><a href="#topic+glimpse.Spat">glimpse.Spat</a></code>,
<code><a href="#topic+group-by.SpatVector">group-by.SpatVector</a></code>,
<code><a href="#topic+mutate-joins.SpatVector">mutate-joins.SpatVector</a></code>,
<code><a href="#topic+mutate.Spat">mutate.Spat</a></code>,
<code><a href="#topic+pull.Spat">pull.Spat</a></code>,
<code><a href="#topic+relocate.Spat">relocate.Spat</a></code>,
<code><a href="#topic+rename.Spat">rename.Spat</a></code>,
<code><a href="#topic+rowwise.SpatVector">rowwise.SpatVector</a>()</code>,
<code><a href="#topic+select.Spat">select.Spat</a></code>,
<code><a href="#topic+slice.Spat">slice.Spat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

v &lt;- vect(system.file("extdata/cyl.gpkg", package = "tidyterra"))

# Grouped
gr_v &lt;- v %&gt;%
  mutate(start_with_s = substr(name, 1, 1) == "S") %&gt;%
  group_by(start_with_s)


# Dissolving
diss &lt;- gr_v %&gt;%
  summarise(n = dplyr::n(), mean = mean(as.double(cpro)))

diss

autoplot(diss, aes(fill = start_with_s)) + ggplot2::ggtitle("Dissolved")

# Not dissolving
no_diss &lt;- gr_v %&gt;%
  summarise(n = dplyr::n(), mean = mean(as.double(cpro)), .dissolve = FALSE)

# Same statistic
no_diss

autoplot(no_diss, aes(fill = start_with_s)) +
  ggplot2::ggtitle("Not Dissolved")
</code></pre>

<hr>
<h2 id='tidyterra-package'>tidyterra: 'tidyverse' Methods and 'ggplot2' Helpers for 'terra' Objects</h2><span id='topic+tidyterra'></span><span id='topic+tidyterra-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Extension of the 'tidyverse' for 'SpatRaster' and 'SpatVector' objects of the 'terra' package. It includes also new 'geom_' functions that provide a convenient way of visualizing 'terra' objects with 'ggplot2'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Diego Hernangómez <a href="mailto:diego.hernangomezherrero@gmail.com">diego.hernangomezherrero@gmail.com</a> (<a href="https://orcid.org/0000-0001-8457-4658">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Dewey Dunnington (<a href="https://orcid.org/0000-0002-9415-4582">ORCID</a>) (for ggspatial code) [contributor]
</p>
</li>
<li><p> ggplot2 authors (for contour code) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dieghernan.github.io/tidyterra/">https://dieghernan.github.io/tidyterra/</a>
</p>
</li>
<li> <p><a href="https://github.com/dieghernan/tidyterra">https://github.com/dieghernan/tidyterra</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dieghernan/tidyterra/issues">https://github.com/dieghernan/tidyterra/issues</a>
</p>
</li></ul>


<hr>
<h2 id='volcano2'>Updated Topographic Information on Auckland's Maungawhau Volcano</h2><span id='topic+volcano2'></span>

<h3>Description</h3>

<p>Probably you already know the <a href="datasets.html#topic+volcano">volcano</a> dataset. This dataset provides
updated information of Maungawhau (Mt. Eden) from
<a href="https://data.linz.govt.nz/">Toitu Te Whenua Land Information New Zealand</a>,
the Government's agency that provides free online access to New Zealand’s
most up-to-date land and seabed data.
</p>


<h3>Format</h3>

<p>A matrix of 174 rows and 122 columns. Each
value is the corresponding altitude in meters.
</p>


<h3>Note</h3>

<p>Information needed for regenerating the original raster file:
</p>

<ul>
<li><p> resolution: <code>c(5, 5)</code>
</p>
</li>
<li><p> extent: <code style="white-space: pre;">&#8288;1756969, 1757579, 5917003, 5917873&#8288;</code>  (xmin, xmax, ymin, ymax)
</p>
</li>
<li><p> coord. ref. : NZGD2000 / New Zealand Transverse Mercator 2000
(<code>EPSG:2193</code>)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.linz.govt.nz/layer/53405-auckland-lidar-1m-dem-2013/">Auckland LiDAR 1m DEM (2013)</a>
</p>
<p>DEM for LiDAR data from the Auckland region captured in 2013. The original
data has been downsampled to a resolution of 5m due to disk space constrains.
</p>
<p>Data License: <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
</p>


<h3>See Also</h3>

<p><a href="datasets.html#topic+volcano">volcano</a>
</p>
<p>Other datasets: 
<code><a href="#topic+cross_blended_hypsometric_tints_db">cross_blended_hypsometric_tints_db</a></code>,
<code><a href="#topic+hypsometric_tints_db">hypsometric_tints_db</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("volcano2")
filled.contour(volcano2, color.palette = hypso.colors, asp = 1)
title(main = "volcano2 data: filled contour map")

# Geo-tag
# Empty raster

volcano2_raster &lt;- terra::rast(volcano2)
terra::crs(volcano2_raster) &lt;- pull_crs(2193)
terra::ext(volcano2_raster) &lt;- c(1756968, 1757576, 5917000, 5917872)
names(volcano2_raster) &lt;- "volcano2"

library(ggplot2)

ggplot() +
  geom_spatraster(data = volcano2_raster) +
  scale_fill_hypso_c() +
  labs(
    title = "volcano2 SpatRaster",
    subtitle = "Georeferenced",
    fill = "Elevation (m)"
  )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
