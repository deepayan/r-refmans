<!DOCTYPE html><html lang="en"><head><title>Help for package paramix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paramix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#paramix-package'><p>paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models</p></a></li>
<li><a href='#alembic'><p>Create the Blending and Distilling Object</p></a></li>
<li><a href='#blend'><p>Blend Parameters</p></a></li>
<li><a href='#distill'><p>Distill Outcomes</p></a></li>
<li><a href='#distill_summary'><p>Distillation Calculation Comparison Summary</p></a></li>
<li><a href='#interpolate_opts'><p>Interpolation Options</p></a></li>
<li><a href='#make_partition'><p>Create a Least-Common-Interval Partition</p></a></li>
<li><a href='#make_weight'><p>Compose Parameter &amp; Density Functions</p></a></li>
<li><a href='#parameter_summary'><p>Parameter Calculation Comparison Summary</p></a></li>
<li><a href='#to_function'><p>Internal Conversion of Data to Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Aggregate and Disaggregate Continuous Parameters for
Compartmental Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A convenient framework for aggregating and disaggregating continuously
    varying parameters (for example, case fatality ratio, with age) for proper
    parametrization of lower-resolution compartmental models (for example, with
    broad age categories) and subsequent upscaling of model outputs to high resolution
    (for example, as needed when calculating age-sensitive measures like years-life-lost).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lintr, knitr, rmarkdown, ggplot2, roxygen2, wpp2019, testthat
(&ge; 3.0.0), patchwork</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cmmid.github.io/paramix/">https://cmmid.github.io/paramix/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-06 20:06:24 UTC; holism</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Pearson <a href="https://orcid.org/0000-0003-0701-7860"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Simon Proctor <a href="https://orcid.org/0000-0002-0380-1503"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lucy Goodfellow <a href="https://orcid.org/0009-0004-0434-5863"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Pearson &lt;carl.ab.pearson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-09 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='paramix-package'>paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models</h2><span id='topic+paramix'></span><span id='topic+paramix-package'></span>

<h3>Description</h3>

<p>A convenient framework for aggregating and disaggregating continuously varying parameters (for example, case fatality ratio, with age) for proper parametrization of lower-resolution compartmental models (for example, with broad age categories) and subsequent upscaling of model outputs to high resolution (for example, as needed when calculating age-sensitive measures like years-life-lost).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Carl Pearson <a href="mailto:carl.ab.pearson@gmail.com">carl.ab.pearson@gmail.com</a> (<a href="https://orcid.org/0000-0003-0701-7860">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Simon Proctor <a href="mailto:simon.procter@lshtm.ac.uk">simon.procter@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0002-0380-1503">ORCID</a>)
</p>
</li>
<li><p> Lucy Goodfellow <a href="mailto:lucy.goodfellow@lshtm.ac.uk">lucy.goodfellow@lshtm.ac.uk</a> (<a href="https://orcid.org/0009-0004-0434-5863">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://cmmid.github.io/paramix/">https://cmmid.github.io/paramix/</a>
</p>
</li></ul>


<hr>
<h2 id='alembic'>Create the Blending and Distilling Object</h2><span id='topic+alembic'></span>

<h3>Description</h3>

<p>Create the Blending and Distilling Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alembic(
  f_param,
  f_pop,
  model_partition,
  output_partition,
  pars_interp_opts = interpolate_opts(fun = stats::splinefun, kind = "point", method =
    "natural"),
  pop_interp_opts = interpolate_opts(fun = stats::approxfun, kind = "integral", method =
    "constant", yleft = 0, yright = 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alembic_+3A_f_param">f_param</code></td>
<td>
<p>a function, <code>f(x)</code> which transforms the feature (e.g. age),
to yield the parameter values. Alternatively, a <code>data.frame</code> where the first
column is the feature and the second is the parameter; see
<code><a href="grDevices.html#topic+xy.coords">xy.coords()</a></code> for details. If the latter, combined with <code>pars_interp_opts</code>,
and defaulting to spline interpolation.</p>
</td></tr>
<tr><td><code id="alembic_+3A_f_pop">f_pop</code></td>
<td>
<p>like <code>f_param</code>, either a density function (though it does
not have to integrate to 1 like a pdf) or a <code>data.frame</code> of values. If the
latter, it is treated as a series of populations within intervals, and
then interpolated with <code>pop_interp_opts</code> to create a density function.</p>
</td></tr>
<tr><td><code id="alembic_+3A_model_partition">model_partition</code></td>
<td>
<p>a numeric vector of cut points, which define the
partitioning that will be used in the model</p>
</td></tr>
<tr><td><code id="alembic_+3A_output_partition">output_partition</code></td>
<td>
<p>the partition of the underlying feature</p>
</td></tr>
<tr><td><code id="alembic_+3A_pars_interp_opts">pars_interp_opts</code></td>
<td>
<p>a list, minimally with an element <code>fun</code>,
corresponding to an interpolation function. Defaults to <code><a href="stats.html#topic+splinefun">splinefun()</a></code>
&quot;natural&quot; interpolation.</p>
</td></tr>
<tr><td><code id="alembic_+3A_pop_interp_opts">pop_interp_opts</code></td>
<td>
<p>ibid, but for density. Defaults to <code><a href="stats.html#topic+approxfun">approxfun()</a></code>
&quot;constant&quot; interpolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> with columns <code>model_partition</code>, <code>output_partition</code>, <code>weight</code> and
<code>relpop</code>. The first two columns identify partition lower bounds, for both the model
and output, the other values are associated with; the combination of
<code>model_partition</code> and <code>output_partition</code> forms a unique identifier, but individually they
may appear multiple times. Generally, this object is only useful as an input
to the <code><a href="#topic+blend">blend()</a></code> and <code><a href="#topic+distill">distill()</a></code> tools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ifr_levin &lt;- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}
age_limits &lt;- c(seq(0, 69, by = 5), 70, 80, 101)
age_pyramid &lt;- data.frame(
  from = 0:101, weight = ifelse(0:101 &lt; 65, 1, .99^(0:101-64))
)
age_pyramid$weight[102] &lt;- 0
# flat age distribution, then 1% annual deaths, no one lives past 101
ifr_alembic &lt;- alembic(ifr_levin, age_pyramid, age_limits, 0:101)

</code></pre>

<hr>
<h2 id='blend'>Blend Parameters</h2><span id='topic+blend'></span>

<h3>Description</h3>

<p><code>blend</code> extracts aggregate parameters from an <code>alembic</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blend(alembic_dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blend_+3A_alembic_dt">alembic_dt</code></td>
<td>
<p>an <code><a href="#topic+alembic">alembic()</a></code> return value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code> of with two columns: <code>model_partition</code> (partition lower
bounds) and <code>value</code> (parameter values for those partitions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ifr_levin &lt;- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}

age_limits &lt;- c(seq(0, 69, by = 5), 70, 80, 101)
age_pyramid &lt;- data.frame(
  from = 0:101, weight = ifelse(0:101 &lt; 65, 1, .99^(0:101-64))
)
age_pyramid$weight[102] &lt;- 0
# flat age distribution, then 1% annual deaths, no one lives past 101

alembic_dt &lt;- alembic(ifr_levin, age_pyramid, age_limits, 0:101)

ifr_blend &lt;- blend(alembic_dt)
# the actual function
plot(
  60:100, ifr_levin(60:100),
  xlab = "age (years)", ylab = "IFR", type = "l"
)
# the properly aggregated blocks
lines(
  age_limits, c(ifr_blend$value, tail(ifr_blend$value, 1)),
  type = "s", col = "dodgerblue"
)
# naively aggregated blocks
ifr_naive &lt;- ifr_levin(head(age_limits, -1) + diff(age_limits)/2)
lines(
  age_limits, c(ifr_naive, tail(ifr_naive, 1)),
  type = "s", col = "firebrick"
)
# properly aggregated, but not accounting for age distribution
bad_alembic_dt &lt;- alembic(
  ifr_levin,
  within(age_pyramid, weight &lt;- c(rep(1, 101), 0)), age_limits, 0:101
)
ifr_unif &lt;- blend(bad_alembic_dt)
lines(
  age_limits, c(ifr_unif$value, tail(ifr_unif$value, 1)),
  type = "s", col = "darkgreen"
)
</code></pre>

<hr>
<h2 id='distill'>Distill Outcomes</h2><span id='topic+distill'></span>

<h3>Description</h3>

<p><code>distill</code> takes a low-age resolution outcome, for example deaths,
and proportionally distributes that outcome into a higher age resolution for
use in subsequent analyses like years-life-lost style calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distill(alembic_dt, outcomes_dt, groupcol = names(outcomes_dt)[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distill_+3A_alembic_dt">alembic_dt</code></td>
<td>
<p>an <code><a href="#topic+alembic">alembic()</a></code> return value</p>
</td></tr>
<tr><td><code id="distill_+3A_outcomes_dt">outcomes_dt</code></td>
<td>
<p>a long-format <code>data.frame</code> with a column either named
<code>from</code> or <code>model_from</code> and a column <code>value</code> (other columns will be silently
ignored)</p>
</td></tr>
<tr><td><code id="distill_+3A_groupcol">groupcol</code></td>
<td>
<p>a string, the name of the outcome model group column. The
<code>outcomes_dt[[groupcol]]</code> column must match the <code>model_partition</code> lower
bounds, as provided when constructing the <code>alembic_dt</code> with <code><a href="#topic+alembic">alembic()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>value</code> column is re-calculated, note that it will aggregate all
rows with matching <code>groupcol</code> entries in <code>outcomes_dt</code>. If you need to group
by other features in your input data (e.g. if you need to distill outcomes
across multiple simulation outputs or at multiple time points), that has to
be done by external grouping then calling <code>distill()</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code>, with <code>output_partition</code> and recalculated <code>value</code> column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

ifr_levin &lt;- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}

age_limits &lt;- c(seq(0, 69, by = 5), 70, 80, 101)
age_pyramid &lt;- data.frame(
  from = 0:101, weight = ifelse(0:101 &lt; 65, 1, .99^(0:101-64))
)
age_pyramid$weight[102] &lt;- 0
# flat age distribution, then 1% annual deaths, no one lives past 101

alembic_dt &lt;- alembic(ifr_levin, age_pyramid, age_limits, 0:101)

results &lt;- data.frame(model_partition = head(age_limits, -1))
results$value &lt;- 10
distill(alembic_dt, results)

</code></pre>

<hr>
<h2 id='distill_summary'>Distillation Calculation Comparison Summary</h2><span id='topic+distill_summary'></span>

<h3>Description</h3>

<p>Implements several approaches to imputing higher resolution outcomes, then
tables them up for convenient plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distill_summary(alembic_dt, outcomes_dt, groupcol = names(outcomes_dt)[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distill_summary_+3A_alembic_dt">alembic_dt</code></td>
<td>
<p>an <code><a href="#topic+alembic">alembic()</a></code> return value</p>
</td></tr>
<tr><td><code id="distill_summary_+3A_outcomes_dt">outcomes_dt</code></td>
<td>
<p>a long-format <code>data.frame</code> with a column either named
<code>from</code> or <code>model_from</code> and a column <code>value</code> (other columns will be silently
ignored)</p>
</td></tr>
<tr><td><code id="distill_summary_+3A_groupcol">groupcol</code></td>
<td>
<p>a string, the name of the outcome model group column. The
<code>outcomes_dt[[groupcol]]</code> column must match the <code>model_partition</code> lower
bounds, as provided when constructing the <code>alembic_dt</code> with <code><a href="#topic+alembic">alembic()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>, columns:
</p>

<ul>
<li> <p><code>partition</code>, the feature point corresponding to the value
</p>
</li>
<li> <p><code>value</code>, the translated <code>outcomes_dt$value</code>
</p>
</li>
<li> <p><code>method</code>, a factor with levels indicating how feature points are selected,
and how <code>value</code> is weighted to those features:
</p>

<ul>
<li> <p><code>f_mid</code>: features at the <code>alembic_dt</code> outcome partitions, each with
value corresponding to the total value of the corresponding model
partition, divided by the number of outcome partitions in that model
partition
</p>
</li>
<li> <p><code>f_mean</code>: the features at the model partition means
</p>
</li>
<li> <p><code>mean_f</code>: the features distributed according to the relative density in
the outcome partitions
</p>
</li>
<li> <p><code>wm_f</code>: the <code><a href="#topic+alembic">alembic()</a></code> approach
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(data.table)
f_param &lt;- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}

model_partition &lt;- c(0, 5, 20, 65, 101)
density_dt &lt;- data.table(
  from = 0:101, weight = c(rep(1, 66), exp(-0.075 * 1:35), 0)
)
alembic_dt &lt;- alembic(
  f_param, density_dt, model_partition, seq(0, 101, by = 1L)
)

# for simplicity, assume a uniform force-of-infection across ages =&gt;
# infections proportion to population density.
model_outcomes_dt &lt;- density_dt[from != max(from), .(value = sum(f_param(from) * weight)),
  by = .(model_from = model_partition[findInterval(from, model_partition)])
]

ds_dt &lt;- distill_summary(alembic_dt, model_outcomes_dt)

</code></pre>

<hr>
<h2 id='interpolate_opts'>Interpolation Options</h2><span id='topic+interpolate_opts'></span>

<h3>Description</h3>

<p>Creates and interpolation options object for use with <code><a href="#topic+alembic">alembic()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_opts(fun, kind = c("point", "integral"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_opts_+3A_fun">fun</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="interpolate_opts_+3A_kind">kind</code></td>
<td>
<p>a string; either &quot;point&quot; or &quot;integral&quot;. How to interpret the
x, y values being interpolated. Either as point observations of a function OR
as the integral of the function over the interval.</p>
</td></tr>
<tr><td><code id="interpolate_opts_+3A_...">...</code></td>
<td>
<p>arbitrary other arguments, but checked against signature of <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method creates the interpolation object for use with <code><a href="#topic+alembic">alembic()</a></code>; this
is a convenience method, which does basic validation on arguments and ensures
the information used in <code><a href="#topic+alembic">alembic()</a></code> to do interpolation is available.
</p>
<p>The <code>...</code> arguments will be provided to <code>fun</code> when it is invoked to
interpolate the tabular &quot;functional&quot; form of arguments to <code><a href="#topic+alembic">alembic()</a></code>. If
<code>fun</code> has an argument <code>kind</code>, that parameter will also be passed when
invoking the function; if not, then the input data will be transformed to
<code class="reqn">\{x, z\}</code> pairs, such that <code class="reqn">x_{i+1}-x_{i} * z_i = y_i</code> - i.e., transforming to
a point value and a functional form which is assumed constant until the next
partition.
</p>


<h3>Value</h3>

<p>a list, with <code>fun</code> and <code>kind</code> keys, as well as whatever other valid
keys appear in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>interpolate_opts(
  fun = stats::splinefun, method = "natural", kind = "point"
)
interpolate_opts(
  fun = stats::approxfun, method = "constant", yleft = 0, yright = 0,
  kind = "integral"
)
</code></pre>

<hr>
<h2 id='make_partition'>Create a Least-Common-Interval Partition</h2><span id='topic+make_partition'></span>

<h3>Description</h3>

<p>Internal utility method for creating partitions, possibly from multiple
distinct partitions. Validates inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_partition(model_partition = numeric(0), output_partition = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_partition_+3A_model_partition">model_partition</code></td>
<td>
<p>the model partition</p>
</td></tr>
<tr><td><code id="make_partition_+3A_output_partition">output_partition</code></td>
<td>
<p>the output partition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted numeric vector with unique values
</p>

<hr>
<h2 id='make_weight'>Compose Parameter &amp; Density Functions</h2><span id='topic+make_weight'></span>

<h3>Description</h3>

<p>Purely internal, called after <code>to_function</code>, so no direct user arguments.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_weight(f_param, f_pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_weight_+3A_f_param">f_param</code></td>
<td>
<p>a function; the parameter function, varying with the aggregate</p>
</td></tr>
<tr><td><code id="make_weight_+3A_f_pop">f_pop</code></td>
<td>
<p>a function; the density function, varying with the aggregate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new function, f(x) = f_param(x)*f_pop(x)
</p>

<hr>
<h2 id='parameter_summary'>Parameter Calculation Comparison Summary</h2><span id='topic+parameter_summary'></span>

<h3>Description</h3>

<p>Implements several approaches to computing partition-aggregated parameters,
then tables them up for convenient plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_summary(f_param, f_pop, model_partition, resolution = 101L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_summary_+3A_f_param">f_param</code></td>
<td>
<p>a function, <code>f(x)</code> which transforms the feature (e.g. age),
to yield the parameter values. Alternatively, a <code>data.frame</code> where the first
column is the feature and the second is the parameter; see
<code><a href="grDevices.html#topic+xy.coords">xy.coords()</a></code> for details. If the latter, combined with <code>pars_interp_opts</code>,
and defaulting to spline interpolation.</p>
</td></tr>
<tr><td><code id="parameter_summary_+3A_f_pop">f_pop</code></td>
<td>
<p>like <code>f_param</code>, either a density function (though it does
not have to integrate to 1 like a pdf) or a <code>data.frame</code> of values. If the
latter, it is treated as a series of populations within intervals, and
then interpolated with <code>pop_interp_opts</code> to create a density function.</p>
</td></tr>
<tr><td><code id="parameter_summary_+3A_model_partition">model_partition</code></td>
<td>
<p>a numeric vector of cut points, which define the
partitioning that will be used in the model</p>
</td></tr>
<tr><td><code id="parameter_summary_+3A_resolution">resolution</code></td>
<td>
<p>the number of points to calculate for the underlying
<code>f_param</code> function. The default 101 points means 100 partitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.table</code>, columns:
</p>

<ul>
<li> <p><code>model_category</code>, a integer corresponding to which of the intervals of
<code>model_partition</code> the <code>x</code> value is in
</p>
</li>
<li> <p><code>x</code>, a numeric series from the first to last elements of <code>model_partition</code>
with length <code>resolution</code>
</p>
</li>
<li> <p><code>method</code>, a factor with levels:
</p>

<ul>
<li> <p><code>f_val</code>: <code>f_param(x)</code>
</p>
</li>
<li> <p><code>f_mid</code>: <code>f_param(x_mid)</code>, where <code>x_mid</code> is the midpoint x of the
<code>model_category</code>
</p>
</li>
<li> <p><code>f_mean</code>: <code>f_param(weighted.mean(x, w))</code>, where <code>w</code> defined by
<code>densities</code> and <code>model_category</code>
</p>
</li>
<li> <p><code>mean_f</code>: <code>weighted.mean(f_param(x), w)</code>, same as previous
</p>
</li>
<li> <p><code>wm_f</code>: the result as if having used <code>paramix::blend()</code>; this should be
very similar to <code>mean_f</code>, though will be slightly different since <code>blend</code>
uses <code>integrate()</code>
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># COVID IFR from Levin et al 2020 https://doi.org/10.1007/s10654-020-00698-1
f_param &lt;- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}

densities &lt;- data.frame(
  from = 0:101,
  weight = c(rep(1, 66), exp(-0.075 * 1:35), 0)
)

model_partition &lt;- c(0, 5, 20, 65, 101)

ps_dt &lt;- parameter_summary(f_param, densities, model_partition)
ps_dt


ggplot(ps_dt) + aes(x, y = value, color = method) +
  geom_line(data = \(dt) subset(dt, method == "f_val")) +
  geom_step(data = \(dt) subset(dt, method != "f_val")) +
  theme_bw() + theme(
    legend.position = "inside", legend.position.inside = c(0.05, 0.95),
    legend.justification = c(0, 1)
  ) + scale_color_discrete(
    "Method", labels = c(
      f_val = "f(x)", f_mid = "f(mid(x))", f_mean = "f(E[x])",
      mean_f = "discrete E[f(x)]", wm_f = "integrated E[f(x)]"
    )
  ) +
  scale_x_continuous("Age", breaks = seq(0, 100, by = 10)) +
  scale_y_log10("IFR", breaks = 10^c(-6, -4, -2, 0), limits = 10^c(-6, 0))

</code></pre>

<hr>
<h2 id='to_function'>Internal Conversion of Data to Function</h2><span id='topic+to_function'></span>

<h3>Description</h3>

<p>Internal Conversion of Data to Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_function(x, bounds, interp_opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_function_+3A_x">x</code></td>
<td>
<p>a function or the single argument version of <code>x</code> in
<code><a href="grDevices.html#topic+xy.coords">xy.coords()</a></code> (as per <code><a href="stats.html#topic+approxfun">approxfun()</a></code> or <code><a href="stats.html#topic+splinefun">splinefun()</a></code> inputs). Pass through
from user input, must be checked</p>
</td></tr>
<tr><td><code id="to_function_+3A_bounds">bounds</code></td>
<td>
<p>numeric vector, length 2: the partition lower bound; not checked,
result of <code>range(make_partition(...))</code>.</p>
</td></tr>
<tr><td><code id="to_function_+3A_interp_opts">interp_opts</code></td>
<td>
<p>if <code>x</code> is function, ignored. Otherwise,
an interpolating function and its arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
