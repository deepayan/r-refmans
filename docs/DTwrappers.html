<!DOCTYPE html><html><head><title>Help for package DTwrappers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DTwrappers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.backtick'><p>Add backtick</p></a></li>
<li><a href='#dt.calculate'><p>dt.calculate</p></a></li>
<li><a href='#dt.choose.cols'><p>dt.choose.cols</p></a></li>
<li><a href='#dt.choose.rows'><p>dt.choose.rows</p></a></li>
<li><a href='#dt.count.rows'><p>dt.count.rows</p></a></li>
<li><a href='#dt.define.variable'><p>dt.define.variable</p></a></li>
<li><a href='#dt.first.k.rows'><p>dt.first.k.rows</p></a></li>
<li><a href='#dt.last.k.rows'><p>dt.last.k.rows</p></a></li>
<li><a href='#dt.remove.variables'><p>dt.remove.variables</p></a></li>
<li><a href='#dt.sort'><p>dt.sort</p></a></li>
<li><a href='#reduce.vector.expression'><p>Takes a numeric vector and produces a statement with a more compact representation.  For instance, c(1,2,3,4) would become '1:4' and c(1:3, 4:6) could become '1:6'.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simplified Data Analysis with Wrapper Functions for the
'Data.Table' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for users who are learning R or the techniques of data analysis.  Written as a collection of wrapper functions, the 'DTwrapper' package facilitates many core operations of data processing.  This is achieved with relatively few requirements about the order of the processing steps or knowledge of specialized syntax.  'DTwrappers' creates coding results along with translations to data.table's code.  This enables users to benefit from the speed and efficiency of data.table's calculations.  Furthermore, the package also provides the translated code for educational purposes so that users can review working examples of coding syntax and calculations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, covr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-21 06:07:38 UTC; mayurbansal</td>
</tr>
<tr>
<td>Author:</td>
<td>David Shilane [aut],
  Mayur Bansal [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mayur Bansal &lt;mb4511@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-21 06:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.backtick'>Add backtick</h2><span id='topic+add.backtick'></span>

<h3>Description</h3>

<p>Function that add backticks to the input variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.backtick(x, include.backtick = "as.needed", dat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.backtick_+3A_x">x</code></td>
<td>
<p>Character value specifying the name of input parameters.</p>
</td></tr>
<tr><td><code id="add.backtick_+3A_include.backtick">include.backtick</code></td>
<td>
<p>specifies whether a backtick should be added. Parameter values should be either 'all' or 'as.needed'</p>
</td></tr>
<tr><td><code id="add.backtick_+3A_dat">dat</code></td>
<td>
<p>the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='dt.calculate'>dt.calculate</h2><span id='topic+dt.calculate'></span>

<h3>Description</h3>

<p>This function allows a user to apply one or more functions to all of the specified variables in a data.frame or data.table object.  It is built as a wrapper function of data.table's method of applying functions to variables while allowing for filtering and grouping steps.  This allows a user to easily calculate many results, e.g. the.functions = c(&quot;mean&quot;, &quot;median&quot;, &quot;sd&quot;) on multiple columns, e.g. the.variables = c(&quot;Age&quot;, &quot;Income&quot;) while also filtering and grouping the data.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.calculate(
  dt.name,
  the.functions,
  the.variables = ".",
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  other.params = "",
  table.format = "long",
  add.function.name = TRUE,
  individual.variables = TRUE,
  output.as.table = TRUE,
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.calculate_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_the.functions">the.functions</code></td>
<td>
<p>A character vector specifying the name of the functions to apply to the.variables.  Each function included in the.functions will be separately applied to each variable in the.variables.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_the.variables">the.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.  Other values in sorting.variables that do not correspond to a defined column will be excluded from the calculation.  When the.variables includes &quot;.&quot;, then all values in names(dat) will be selected.  Values of the.variables that also exist in grouping.variables will be excluded from the.variables (but grouped by these values).</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, numeric vector, logical vector, or expression stating the logical operations used to filter the data.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.  Logical vectors will be converted to a numeric filter, e.g. c(TRUE, TRUE, FALSE) will become 1:2 to signify which rows should be selected.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, the values may be either column names of the data or calculations based upon them (see the vignette for examples).  For numeric vectors, only the values of unique(floor(grouping.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be mapped to the corresponding column names from the data.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_sortby.group">sortby.group</code></td>
<td>
<p>A logical value specifying whether the grouping should be sorted (TRUE, the default value) or as is (FALSE).</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_other.params">other.params</code></td>
<td>
<p>A character value specifying any additional parameters needed to call the.functions.
For instance, if the.functions = &quot;mean&quot;, and you would like to remove missing values, then specifying
other.params = &quot;na.rm = TRUE&quot; as a character would suffice.  Multiple parameters can be specified with comma
separation, e.g. other.params = &quot;trim = 1, na.rm = TRUE&quot;.  Note that all of the parameters supplied must
apply to all of the.functions</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_table.format">table.format</code></td>
<td>
<p>specify the format of the table depending on the desired output i.e. &quot;long&quot; or &quot;wide&quot;</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_add.function.name">add.function.name</code></td>
<td>
<p>A logical value specifying whether the name of the function applied should be appended to
the column names in the resulting table.  Only applies if the.functions is of length 1.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_individual.variables">individual.variables</code></td>
<td>
<p>a logical variable specifying if variables are grouped or individual</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_output.as.table">output.as.table</code></td>
<td>
<p>a logical variable to specify if output should be a table or not</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the table of counts.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the table of counts.  return.as = &quot;all&quot; provides a list containing both the resulting table and the code.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
<tr><td><code id="dt.calculate_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>
<p>DTwrappers::add.backtick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.calculate(dt.name = "dat", the.variables = c("Sepal.Length"),
the.functions = c("mean", "sd"), return.as = "all")

</code></pre>

<hr>
<h2 id='dt.choose.cols'>dt.choose.cols</h2><span id='topic+dt.choose.cols'></span>

<h3>Description</h3>

<p>This function selects columns from a data.frame or data.table.  It is built as a wrapper function of data.table's selection step (using .SD in the j step while specifying the .SDcols argument).  Selections may also be supplied to limit the rows to consider, with options for the first or last k rows or a subset based upon a vector like c(3:5, 9:10).  Filtering of the rows (e.g. Age &lt; 50) may also be applied using the.filter.  Grouped operations may be used to make these selections of columns and rows in each category.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.choose.cols(
  dt.name,
  the.variables = ".",
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  first.k = NULL,
  last.k = NULL,
  row.indices = NULL,
  return.as = "result",
  envir = .GlobalEnv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.choose.cols_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_the.variables">the.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables that we want to select.  For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.  Only values that exist in the names of the data will be used; other values in the.variables will be excluded from the calculation.  When the.variables includes &quot;.&quot;, then all of the variables will be selected.  Values of the.variables that also exist in grouping.variables will be excluded from the.variables (but grouped by these values).</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, numeric vector, logical vector, or expression stating the logical operations used to filter the data.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.  Character values such as 'Age &lt; 50' or 'c(1:3, 7:10)' may be used.  Numeric vectors such as c(1:3, 7:10) that specify the row indices may be used.  Logical vectors will be converted to a numeric filter, e.g. c(TRUE, TRUE, FALSE) will become 1:2 to signify which rows should be selected.  Expressions may be used to specify a logical operation such as expression(Age &lt; 50) as well.  Defaults to NULL to indicate that no filtering of the data should be applied.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, the values may be either column names of the data or calculations based upon them (see the vignette for examples).  For numeric vectors, only the values of unique(floor(grouping.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be mapped to the corresponding column names from the data.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_sortby.group">sortby.group</code></td>
<td>
<p>A character value specifying whether the grouping should be sorted (keyby) or as is (by).  Defaults to keyby unless &quot;by&quot; is specified.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_first.k">first.k</code></td>
<td>
<p>An integer indicating how many rows to select starting from the first row.  Note that grouping statements will select up to this number of rows in each group.  Additionally, if first.k is larger than the number of records in a group, then the maximum number of records will be selected.  When non-integer or non-positive values of first.k are selected, the algorithm will select first.k = max(c(1, round(first.k))).  If first.k is not a numeric or integer value, then by default first.k is set to select all of the rows.  Specifying row.indices takes precedence to specifying the parameter first.k; if row.indices is not NULL, then row.indices will be used, and first.k will not. Meanwhile, first.k takes precedence to last.k when both are specified.  See below.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_last.k">last.k</code></td>
<td>
<p>An integer indicating how many rows to select starting from the last row.  Note that grouping statements will select up to this number of rows in each group.  Additionally, if last.k is larger than the number of records in a group, then the maximum number of records will be selected.  When non-integer or non-positive values of last.k are selected, the algorithm will select last.k = max(c(1, round(last.k))).  If last.k is not a numeric or integer value, then by default last.k is set to select all of the rows.  Specifying row.indices takes precedence to specifying the parameter last.k (see below); if row.indices is not NULL, then it will be used, and last.k will not.  Meanwhile, first.k takes precedence to last.k when both are specified.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_row.indices">row.indices</code></td>
<td>
<p>An integer vector specifying the row indices to return.  When grouping.variables is specified, these indices will be applied to each group.  Note that specifications outside of the range from 1 to the number of rows will be limited to existing rows from the data and group.  Specifying row.indices takes precedence to specifying the parameters first.k and last.k.  If row.indices is not NULL, it will be used.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the table of counts.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the table of counts.  return.as = &quot;all&quot; provides a list containing both the resulting table and the code.</p>
</td></tr>
<tr><td><code id="dt.choose.cols_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>

<hr>
<h2 id='dt.choose.rows'>dt.choose.rows</h2><span id='topic+dt.choose.rows'></span>

<h3>Description</h3>

<p>This function filters the rows of a data.table or data.frame object.  It is built as a wrapper function of data.table's filtering method (the i step).  A series of logical tests on variables within the data may be specified.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.choose.rows(
  dt.name,
  the.filter = NULL,
  return.as = "result",
  envir = .GlobalEnv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.choose.rows_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.choose.rows_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, numeric vector, logical vector, or expression stating the logical operations used to filter the data.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.  Character values such as 'Age &lt; 50' or 'c(1:3, 7:10)' may be used.  Numeric vectors such as c(1:3, 7:10) that specify the row indices may be used.  Logical vectors will be converted to a numeric filter, e.g. c(TRUE, TRUE, FALSE) will become 1:2 to signify which rows should be selected.  Expressions may be used to specify a logical operation such as expression(Age &lt; 50) as well.  Defaults to NULL to indicate that no filtering of the data should be applied.</p>
</td></tr>
<tr><td><code id="dt.choose.rows_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the table of counts.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the table of counts.  return.as = &quot;all&quot; provides both the resulting table and the code.  If the coding statement was specified using calls to get() or eval(), then both an original.statement and the resulting code (a translated statement from the getDTeval package) will be provided.</p>
</td></tr>
<tr><td><code id="dt.choose.rows_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Note</h3>

<p>the data.frame dat will be converted to a data.table object to facilitate efficient counting of the rows.
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.count.rows(dt.name = "dat", count.name = "Total Rows", return.as = "all")
</code></pre>

<hr>
<h2 id='dt.count.rows'>dt.count.rows</h2><span id='topic+dt.count.rows'></span>

<h3>Description</h3>

<p>This function counts the number of qualifying rows in a data.table or data.frame object.  It is built as a wrapper function of data.table's filter (the i step).  These counts may be comprehensive for the entire table or conducted in groups.  The full data can also be filtered for qualifying cases prior to conducting the counts.  This function returns a data.table object that shows the counts in one column along with additional columns for any specified grouping variables.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.count.rows(
  dt.name,
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  count.name = "N",
  return.as = "result",
  envir = .GlobalEnv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.count.rows_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, numeric vector, logical vector, or expression stating the logical operations used to filter the data.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.  Character values such as 'Age &lt; 50' or 'c(1:3, 7:10)' may be used.  Numeric vectors such as c(1:3, 7:10) that specify the row indices may be used.  Logical vectors will be converted to a numeric filter, e.g. c(TRUE, TRUE, FALSE) will become 1:2 to signify which rows should be selected.  Expressions may be used to specify a logical operation such as expression(Age &lt; 50) as well.  Defaults to NULL to indicate that no filtering of the data should be applied.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, the values may be either column names of the data or calculations based upon them (see the vignette for examples).  For numeric vectors, only the values of unique(floor(grouping.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be mapped to the corresponding column names from the data.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_sortby.group">sortby.group</code></td>
<td>
<p>a character value specifying whether the table of counts should be sorted by group (&quot;sorted&quot;) or as is (any other selected value).  Defaults to &quot;sorted&quot;.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_count.name">count.name</code></td>
<td>
<p>a character value specifying the name of the column of counts in the resulting table.  This value defaults to &quot;N&quot; unless otherwise specified.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the table of counts.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the table of counts.  return.as = &quot;all&quot; provides both the resulting table and the code.  If the coding statement was specified using calls to get() or eval(), then both an original.statement and the resulting code (a translated statement from the getDTeval package) will be provided.</p>
</td></tr>
<tr><td><code id="dt.count.rows_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Note</h3>

<p>the data.frame dat will be converted to a data.table object to facilitate efficient selection.
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.count.rows(dt.name = "dat", return.as = "all")

</code></pre>

<hr>
<h2 id='dt.define.variable'>dt.define.variable</h2><span id='topic+dt.define.variable'></span>

<h3>Description</h3>

<p>This method allows a user to add a new variable to an existing data.frame or data.table.  It can also be used to update previously defined variables.  It is built as a wrapper function of data.table's method of defining new variables by reference.  The new values can be stated either through a statement of the calculation or by directly providing a vector of values.  These updates can also be performed on a subset of the data by incorporating a filter.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.define.variable(
  dt.name,
  variable.name,
  the.values,
  specification = "by.expression",
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.define.variable_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_variable.name">variable.name</code></td>
<td>
<p>a character value specifying the name of the new column.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_the.values">the.values</code></td>
<td>
<p>a vector or character value.  When specified as a vector, this should contain the values of the new column.  When specified as a character value, it should include a functional form that specifies how to calculate the new values.  See the specification parameter for more details.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_specification">specification</code></td>
<td>
<p>A character value.  When specification = &quot;by.value&quot;, the new variable will be defined in terms of the vector the.values.  Otherwise the new variable is specified in a functional form, e.g. the.values = &quot;rnorm(n = 3)&quot;.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, logical vector, or expression stating the logical operations used to filter the data.  See create.filter.expression for details.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, the values may be either column names of the data or calculations based upon them (see the vignette for examples).  For numeric vectors, only the values of unique(floor(grouping.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be mapped to the corresponding column names from the data.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_sortby.group">sortby.group</code></td>
<td>
<p>A logical value specifying whether the grouping should be sorted (TRUE, the default value) or as is (FALSE).</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the table of counts.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the table of counts.  return.as = &quot;all&quot; provides both the resulting table and the code.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
<tr><td><code id="dt.define.variable_+3A_...">...</code></td>
<td>
<p>other additional arguments if needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Note</h3>

<p>the data.frame dat will be converted to a data.table object to facilitate adding the new column by reference (e.g. efficiently with regard to the usage of memory)
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>

<hr>
<h2 id='dt.first.k.rows'>dt.first.k.rows</h2><span id='topic+dt.first.k.rows'></span>

<h3>Description</h3>

<p>This function returns the first k rows from the given data.  It is built as a wrapper function of data.table's filter (the i step).  This calculation can be specified either overall or in groups.  A filter can also be applied so that only qualifying values would be considered.  A subset of the variables may also be selected.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>
<p>#' @param dt.name a character value specifying the name of a data.frame or data.table object to select data from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.first.k.rows(
  dt.name,
  k = NULL,
  the.variables = ".",
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.first.k.rows_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_k">k</code></td>
<td>
<p>A numeric variable specifying the number of rows to select</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_the.variables">the.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.  Other values in sorting.variables that do not correspond to a defined column will be excluded from the calculation.  When the.variables includes &quot;.&quot;, then all values in names(dat) will be selected.  Values of the.variables that also exist in grouping.variables will be excluded from the.variables (but grouped by these values).</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, logical vector, or expression stating the logical operations used to filter the data.  See create.filter.expression for details.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>a character vector specifying the variables to group by in the calculation.  Only variables in the data will be used.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_sortby.group">sortby.group</code></td>
<td>
<p>A logical value specifying whether the grouping should be sorted (TRUE, the default value) or as is (FALSE).</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the resulting table.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the resulting table.  return.as = &quot;all&quot; provides both the resulting table and the code.  If the coding statement was specified using calls to get() or eval(), then both an original.statement and the resulting code (a translated statement from the getDTeval package) will be provided.</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
<tr><td><code id="dt.first.k.rows_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Note</h3>

<p>Calls dt.choose.cols.R with first.k = k.
</p>


<h3>Source</h3>

<p>DTwrappers::dt.choose.cols
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.first.k.rows(dt.name = "dat", k = 2, the.variables = c("Sepal.Length", "Sepal.Width"),
grouping.variables = "Species", return.as = "all")


</code></pre>

<hr>
<h2 id='dt.last.k.rows'>dt.last.k.rows</h2><span id='topic+dt.last.k.rows'></span>

<h3>Description</h3>

<p>This function returns the last k rows from the given data.  It is built as a wrapper function of data.table's filter (the i step).  This calculation can be specified either overall or in groups.  A filter can also be applied so that only qualifying values would be considered.  A subset of the variables may also be selected.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.last.k.rows(
  dt.name,
  k = NULL,
  the.variables = ".",
  the.filter = NULL,
  grouping.variables = NULL,
  sortby.group = TRUE,
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.last.k.rows_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_k">k</code></td>
<td>
<p>A numeric variable specifying the number of rows to select</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_the.variables">the.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables to perform the calculations on. For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.  Other values in sorting.variables that do not correspond to a defined column will be excluded from the calculation.  When the.variables includes &quot;.&quot;, then all values in names(dat) will be selected.  Values of the.variables that also exist in grouping.variables will be excluded from the.variables (but grouped by these values).</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_the.filter">the.filter</code></td>
<td>
<p>a character value, logical vector, or expression stating the logical operations used to filter the data.  See create.filter.expression for details.  The filtering step will be applied prior to generating the counts.  Defaults to NULL unless otherwise specified.</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_grouping.variables">grouping.variables</code></td>
<td>
<p>a character vector specifying the variables to group by in the calculation.  Only variables in the data will be used.  When NULL, no grouping will be performed.</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_sortby.group">sortby.group</code></td>
<td>
<p>A logical value specifying whether the grouping should be sorted (TRUE, the default value) or as is (FALSE).</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the resulting table.  return.as = &quot;code&quot; provides a data.table coding statement that can generate the resulting table.  return.as = &quot;all&quot; provides both the resulting table and the code.  If the coding statement was specified using calls to get() or eval(), then both an original.statement and the resulting code (a translated statement from the getDTeval package) will be provided.</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code would be evaluated; .GlobalEnv by default.</p>
</td></tr>
<tr><td><code id="dt.last.k.rows_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Note</h3>

<p>Calls dt.choose.cols.R with last.k = k.
</p>


<h3>Source</h3>

<p>DTwrappers::dt.choose.cols
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])

dt.last.k.rows(dt.name = "dat", k = 2, the.variables = c("Sepal.Width"),
grouping.variables = "Species", return.as = "all")

</code></pre>

<hr>
<h2 id='dt.remove.variables'>dt.remove.variables</h2><span id='topic+dt.remove.variables'></span>

<h3>Description</h3>

<p>A function to remove selected columns from a data.frame or data.table object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.remove.variables(
  dt.name,
  the.variables,
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.remove.variables_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.remove.variables_+3A_the.variables">the.variables</code></td>
<td>
<p>A character or numeric vector specifying the variables that we want to remove. For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.</p>
</td></tr>
<tr><td><code id="dt.remove.variables_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the updated data.  return.as = &quot;code&quot; provides a data.table coding statement.  return.as = &quot;all&quot; provides a list object including both the resulting output and the code.</p>
</td></tr>
<tr><td><code id="dt.remove.variables_+3A_envir">envir</code></td>
<td>
<p>a specification of the environment in which the data (referenced by dt.name) exists, with the global environment as the default value.#'</p>
</td></tr>
<tr><td><code id="dt.remove.variables_+3A_...">...</code></td>
<td>
<p>additional arguments if required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'data.table' object.
</p>


<h3>Source</h3>

<p>DTwrappers::create.dt.statement
</p>
<p>DTwrappers::eval.dt.statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.remove.variables(dt.name = "dat", the.variables = c("Category", "setosa_sl_below_5"),
return.as = "all")


</code></pre>

<hr>
<h2 id='dt.sort'>dt.sort</h2><span id='topic+dt.sort'></span>

<h3>Description</h3>

<p>This function sorts the rows of a data.frame or data.table based on selected columns.  It is built as a light wrapper function of data.table's setorderv() function.  Options also exist to return a data.table coding statement (result = &quot;code&quot;) for educational purposes or both the result and the code together (result = &quot;all&quot;).  For examples, please see the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt.sort(
  dt.name,
  sorting.variables,
  sort.increasing = TRUE,
  missing.variables = c("first", "last"),
  return.as = "result",
  envir = .GlobalEnv,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt.sort_+3A_dt.name">dt.name</code></td>
<td>
<p>a character value specifying the name of a data.frame or data.table object to select data from.  A variable called dat should be referred to with dt.name = &quot;dat&quot; when using the function.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_sorting.variables">sorting.variables</code></td>
<td>
<p>A vector specifying the variables that we want to sort by. For character vectors, only values that exist in the names of the data will be used.  For numeric vectors, only the values of unique(floor(sorting.variables)) that are in 1:ncol() of your data will be used.  Then these indices will be used to select column names from the data.  Other values in sorting.variables that do not correspond to a defined column will be excluded from the calculation.  The sorting proceeds in the order that sorting.variables is specified.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_sort.increasing">sort.increasing</code></td>
<td>
<p>A logical vector or numeric vector specifying whether the sorting should be increasing (TRUE or 1) or decreasing (FALSE or not 1) for each variable in sorting.variables.  A vector such as c(TRUE, FALSE) would sort the first variable in increasing order and the second in decreasing order.  If only a single value is provided (either TRUE or FALSE), then all of the.variables will be sorted in the specified ordering.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_missing.variables">missing.variables</code></td>
<td>
<p>a character value of either &quot;first&quot; or &quot;last&quot; specifying where rows with missing values in the.variables should be included.  Using &quot;first&quot; will place those rows at the beginning of the table, while &quot;last&quot; would place them in the end of the table.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_return.as">return.as</code></td>
<td>
<p>a character value specifying what output should be returned.  return.as = &quot;result&quot; provides the updated data.  return.as = &quot;code&quot; provides a data.table coding statement.  return.as = &quot;all&quot; provides a list object including both the resulting output and the code.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_envir">envir</code></td>
<td>
<p>a specification of the environment in which the data (referenced by dt.name) exists, with the global environment as the default value.</p>
</td></tr>
<tr><td><code id="dt.sort_+3A_...">...</code></td>
<td>
<p>additional arguments if required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the value of return.as, the output will be a) a character value (return.as = 'code'), b) a coding output, typically a data.table (return.as = 'result'), or c) a list containing both the code and output (return.as = 'all')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
dat &lt;- data.table::as.data.table(x = iris[sample(x = 1:n, size = n, replace = FALSE),])
dt.sort(dt.name = "dat", sorting.variables = c("Species", "Sepal.Length"),
sort.increasing = TRUE, return.as = "all")
</code></pre>

<hr>
<h2 id='reduce.vector.expression'>Takes a numeric vector and produces a statement with a more compact representation.  For instance, c(1,2,3,4) would become '1:4' and c(1:3, 4:6) could become '1:6'.</h2><span id='topic+reduce.vector.expression'></span>

<h3>Description</h3>

<p>Takes a numeric vector and produces a statement with a more compact representation.  For instance, c(1,2,3,4) would become '1:4' and c(1:3, 4:6) could become '1:6'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.vector.expression(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.vector.expression_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
