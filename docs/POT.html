<!DOCTYPE html><html><head><title>Help for package POT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {POT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#POT-package'><p>Overview of the <span class="pkg">POT</span> package</p></a></li>
<li><a href='#anova.bvpot'><p>Anova Tables: Bivariate Case</p></a></li>
<li><a href='#anova.uvpot'><p>Anova Tables: Univariate Case</p></a></li>
<li><a href='#bvgpd'><p>Parametric Bivariate GPD</p></a></li>
<li><a href='#chimeas'><p>Dependence Measures For Extreme Values Analysis</p></a></li>
<li><a href='#clust'><p>Identify Extreme Clusters within a Time Series</p></a></li>
<li><a href='#Clusters'><p>Extremal Index Plot</p></a></li>
<li><a href='#coef.pot'><p>Extract model coefficients of a <code>'pot'</code> model</p></a></li>
<li><a href='#confint.uvpot'><p>Generic Function to Compute (Profile) Confidence Intervals</p></a></li>
<li><a href='#convassess'><p>Convergence Assessment for Fitted Objects</p></a></li>
<li><a href='#dens'><p>Density Plot: Univariate Case</p></a></li>
<li><a href='#dexi'><p>Compute the Density of the Extremal Index</p></a></li>
<li><a href='#diplot'><p>Threshold Selection: The Dispersion Index Plot</p></a></li>
<li><a href='#Fisher Confidence Interval'><p>Fisher Based Confidence Interval for the GP Distribution</p></a></li>
<li><a href='#Fit the GP Distribution'><p>Fitting a GPD to Peaks Over a Threshold</p></a></li>
<li><a href='#fitbvgpd'><p>Fitting Bivariate Peaks Over a Threshold Using Bivariate</p>
Extreme Value Distributions</a></li>
<li><a href='#fitexi'><p>Extremal Index Estimation</p></a></li>
<li><a href='#fitmcgpd'><p>Fitting Markov Chain Models to Peaks Over a Threshold</p></a></li>
<li><a href='#fitpp'><p>Fitting the point process characterisation to exceedances above a</p>
threshold</a></li>
<li><a href='#Flood Flows'><p>High Flood Flows of the Ardieres River at Beaujeu</p></a></li>
<li><a href='#Generalized Pareto'><p>The Generalized Pareto Distribution</p></a></li>
<li><a href='#gpd2frech'><p>Transforms GPD Observations to Unit Frechet Ones and Vice Versa</p></a></li>
<li><a href='#Internal functions and methods'><p>Internal functions and methods for the POT package.</p></a></li>
<li><a href='#L-moments'><p>Compute Sample L-moments</p></a></li>
<li><a href='#lmomplot'><p>Threshold Selection: The L-moments Plot</p></a></li>
<li><a href='#logLik.pot'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#mrlplot'><p>Threshold Selection: The Empirical Mean Residual Life Plot</p></a></li>
<li><a href='#pickdep'><p>The Pickands' Dependence Function</p></a></li>
<li><a href='#plot.bvpot'><p>Graphical Diagnostics: the Bivariate Extreme Value</p>
Distribution Model.</a></li>
<li><a href='#plot.mcpot'><p>Graphical Diagnostics: Markov Chains for All Exceedances.</p></a></li>
<li><a href='#plot.uvpot'><p>Graphical Diagnostic: the Univariate GPD Model</p></a></li>
<li><a href='#pp'><p>Probability Probability Plot</p></a></li>
<li><a href='#print.bvpot'><p>Printing bvpot objects</p></a></li>
<li><a href='#print.mcpot'><p>Printing mcpot objects</p></a></li>
<li><a href='#print.uvpot'><p>Printing uvpot objects</p></a></li>
<li><a href='#Profiled Confidence Intervals'><p>Profiled Confidence interval for the GP Distribution</p></a></li>
<li><a href='#qq'><p>Quantile Quantile Plot</p></a></li>
<li><a href='#retlev'><p>Return Level Plot</p></a></li>
<li><a href='#retlev.bvpot'><p>Return Level Plot: Bivariate Case</p></a></li>
<li><a href='#Return Periods Tools'><p>Converts Return Periods to Probability and Vice Versa</p></a></li>
<li><a href='#simmc'><p>Simulate Markov Chains With Extreme Value</p>
Dependence Structures</a></li>
<li><a href='#simmcpot'><p>Simulate an Markov Chain with a Fixed Extreme Value Dependence</p>
from a Fitted mcpot Object</a></li>
<li><a href='#specdens'><p>Spectral Density Plot</p></a></li>
<li><a href='#summary.pot'><p>Compactly display the structure</p></a></li>
<li><a href='#tailind.test'><p>Testing for Tail Independence in Extreme Value Models</p></a></li>
<li><a href='#tcplot'><p>Threshold Selection: The Threshold Choice Plot</p></a></li>
<li><a href='#ts2tsd'><p>Mobile Window on a Time Series</p></a></li>
<li><a href='#tsdep.plot'><p>Diagnostic for Dependence within Time Series Extremes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Pareto Distribution and Peaks Over Threshold</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathieu Ribatet [aut], Christophe Dutang [ctb,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Dutang &lt;christophe.dutang@ensimag.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Some functions useful to perform a Peak Over Threshold
        analysis in univariate and bivariate cases, see Beirlant et al. (2004)
        &lt;<a href="https://doi.org/10.1002%2F0470012382">doi:10.1002/0470012382</a>&gt;. A user guide is available in the vignette.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pot.r-forge.r-project.org/">https://pot.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-13 19:45:11 UTC; dutang</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-14 10:12:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='POT-package'>Overview of the <span class="pkg">POT</span> package</h2><span id='topic+POT'></span><span id='topic+POT-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">POT</span> package aims to provide operational tools to analyze peak over threshold. 
This package relies on the extreme value theory (EVT) to model the tail of any continuous distribution.
Tail modelling, in particular POT modelling, is of great importance for many financial 
and environmental applications.
</p>
<p>The <span class="pkg">POT</span> package was first committed to the CRAN in April 2005 and is 
still in development. 
The package is hosted in <a href="https://pot.r-forge.r-project.org/">R-forge</a>.
Since November 2016, the package has a new maintainer.
</p>
<p>The main motivation was to provide practical tools for 
probabilistic modelling of high flood flows. However, the strength of the EVT is 
that results do not depend on the process to be modelled. 
Thus, one can use the <span class="pkg">POT</span> package to analyze precipitations, 
floods, financial times series, earthquakes and so on... 
</p>
<p>The <span class="pkg">POT</span> package can perform univariate and bivariate extreme value analysis; 
first order Markov chains can also be considered. 
For instance, the (univariate) GPD is currently fitted using 18 estimators. 
These estimators rely on three different techniques:
</p>

<ul>
<li><p> Likelihood maximization: MLE, LME, MPLE
</p>
</li>
<li><p> Moment Approaches: MOM, PWM, MED
</p>
</li>
<li><p> Distance Minimization: MDPD and MGF estimators.
</p>
</li></ul>

<p>Contrary to the univariate case, there is no finite parametrisation to model bivariate 
exceedances over thresholds. The POT packages allows 6 parametrisation for the 
bivariate GPD: the logistic, negative logistic and mixed models - 
with their respective asymmetric counterparts.
</p>
<p>Lastly, first order Markov chains can be fitted using the bivariate GPD for the joint distribution of two consecutive observations. 
</p>
<p>We have written a package <a href="../doc/POT.pdf">vignette</a> to help new users. 
This users guide is a part of the package - just run <code>vignette("POT")</code> 
once the package is loaded.
</p>


<h3>Author(s)</h3>

 
<p>Mathieu Ribatet and Christophe Dutang.
</p>

<hr>
<h2 id='anova.bvpot'>Anova Tables: Bivariate Case</h2><span id='topic+anova.bvpot'></span>

<h3>Description</h3>

<p>Computes analysis of deviance for &ldquo;bvpot&rdquo; object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvpot'
anova(object, object2, ..., half = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.bvpot_+3A_object">object</code>, <code id="anova.bvpot_+3A_object2">object2</code></td>
<td>
<p>Two objects of class &ldquo;bvpot&rdquo;, most often return of the
<code><a href="#topic+fitbvgpd">fitbvgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="anova.bvpot_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="stats.html#topic+anova">anova</a></code>
function.</p>
</td></tr>
<tr><td><code id="anova.bvpot_+3A_half">half</code></td>
<td>
<p>Logical. For some non-regular testing problems the deviance
difference is known to be one half of a chi-squared random
variable. Set half to <code>TRUE</code> in these cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class anova. These objects
represent analysis-of-deviance tables.  
</p>


<h3>Warning</h3>

<p>Circumstances may arise such that the asymptotic distribution of the
test statistic is not chi-squared. In particular, this occurs when the
smaller model is constrained at the edge of the parameter space. It is
up to the user recognize this, and to interpret the output correctly. 
</p>
<p>In some cases the asymptotic distribution is known to be one half of a
chi-squared; you can set <code>half = TRUE</code> in these cases.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet (Alec Stephenson for the &ldquo;Warning&rdquo; case)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="#topic+anova.uvpot">anova.uvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(1000, 0, 1, -0.25)
y &lt;- rgpd(1000, 2, 0.5, 0)
M0 &lt;- fitbvgpd(cbind(x,y), c(0, 2))
M1 &lt;- fitbvgpd(cbind(x,y), c(0,2), model = "alog")
anova(M0, M1)

##Non regular case
M0 &lt;- fitbvgpd(cbind(x,y), c(0, 2))
M1 &lt;- fitbvgpd(cbind(x,y), c(0, 2), alpha = 1)
anova(M0, M1, half = TRUE)
</code></pre>

<hr>
<h2 id='anova.uvpot'>Anova Tables: Univariate Case</h2><span id='topic+anova.uvpot'></span>

<h3>Description</h3>

<p>Computes analysis of deviance for &ldquo;uvpot&rdquo; object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uvpot'
anova(object, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.uvpot_+3A_object">object</code>, <code id="anova.uvpot_+3A_object2">object2</code></td>
<td>
<p>Two objects of class &ldquo;uvpot&rdquo;, most often return of the
<code><a href="#topic+fitgpd">fitgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="anova.uvpot_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="stats.html#topic+anova">anova</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class anova. These objects
represent analysis-of-deviance tables.  
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="#topic+anova.bvpot">anova.bvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(1000, 0, 1, -0.15)
M0 &lt;- fitgpd(x, 0, shape = -0.15)
M1 &lt;- fitgpd(x, 0)
anova(M0, M1) 
</code></pre>

<hr>
<h2 id='bvgpd'>Parametric Bivariate GPD</h2><span id='topic+rbvgpd'></span><span id='topic+pbvgpd'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation for six different
parametric bivariate GPD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbvgpd(n, alpha, model = "log", asCoef, asCoef1, asCoef2, mar1 =
c(0,1,0), mar2 = mar1)
pbvgpd(q, alpha, model = "log", asCoef, asCoef1, asCoef2, mar1 =
c(0,1,0), mar2 = mar1, lower.tail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvgpd_+3A_n">n</code></td>
<td>
<p>The number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_q">q</code></td>
<td>
<p>A matrix or vector with two columns at which the distribution
is computed.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_alpha">alpha</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, negative logistic, asymmetric negative logistic, mixed and
asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"nlog"</code>,
<code>"anlog"</code>, <code>"mix"</code> or <code>"amix"</code>, for the logistic,
asymmetric logistic, negative logistic, asymmetric negative
logistic, mixed and asymmetric mixed models respectively.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_ascoef">asCoef</code>, <code id="bvgpd_+3A_ascoef1">asCoef1</code>, <code id="bvgpd_+3A_ascoef2">asCoef2</code></td>
<td>
<p>The asymmetric coefficients for the
asymmetric logistic, asymmetric negative logistic and asymmetric
mixed models.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_mar1">mar1</code>, <code id="bvgpd_+3A_mar2">mar2</code></td>
<td>
<p>Vectors of length 3 giving the marginal parameters.</p>
</td></tr>
<tr><td><code id="bvgpd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), P[X
<code class="reqn">\leq</code> x] is computed, else P[X <code class="reqn">\geq</code> x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logistic and asymmetric logistic models respectively are
simulated using bivariate versions of Algorithms 1.1 and 1.2 in
Stephenson(2003).
All other models are simulated using a root finding algorithm
to simulate from the conditional distributions.
</p>


<h3>Value</h3>

<p>Generate a random vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet (Alec Stephenson for the C codes)</p>


<h3>References</h3>

<p>Stephenson, A. G. (2003)
Simulating multivariate extreme value distributions of logistic type.
<em>Extremes</em>, <b>6</b>(1), 49&ndash;60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbvgpd(1000, alpha = 0.25, model = "log", mar1 = c(0,1,0.25), mar2
= c(2,0.5, -0.15))
y &lt;- rbvgpd(1000, alpha = 0.75, model = "nlog", mar1 = c(0,1,0.25), mar2
= c(2,0.5, -0.15))
par(mfrow=c(1,2))
plot(x);plot(y)
</code></pre>

<hr>
<h2 id='chimeas'>Dependence Measures For Extreme Values Analysis</h2><span id='topic+chimeas'></span>

<h3>Description</h3>

<p>Provide two measures to assess for asymptotic dependence or independence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chimeas(data, u.range, n.u = 500, xlab, ylabs, ci = 0.95,  boot = FALSE,
n.boot = 250, block.size = 50, show.bound = TRUE, which = 1:2, ask =
nb.fig &lt; length(which) &amp;&amp; dev.interactive(), ..., col.ci = "grey",
col.bound = "blue", lty.ci = 1, lty.bound = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chimeas_+3A_data">data</code></td>
<td>
<p>A matrix with 2 columns with the data.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_u.range">u.range</code></td>
<td>
<p>Numeric vection of length 2 (may be missing): the range
for the probabilities.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_n.u">n.u</code></td>
<td>
<p>The number of probabilities to be considered</p>
</td></tr>
<tr><td><code id="chimeas_+3A_xlab">xlab</code>, <code id="chimeas_+3A_ylabs">ylabs</code></td>
<td>
<p>The x-axis and ylabs labels. ylabs must be of length
2</p>
</td></tr>
<tr><td><code id="chimeas_+3A_ci">ci</code></td>
<td>
<p>The probability level for the confidence intervals</p>
</td></tr>
<tr><td><code id="chimeas_+3A_boot">boot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, confidence intervals are computed
by bootstraping contiguous blocks. This may be needed if there is
dependence between observations. If <code>FALSE</code> (the default),
confidence intervals are derived using the Delta method.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_n.boot">n.boot</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_block.size">block.size</code></td>
<td>
<p>The size of the &ldquo;contiguous&rdquo; blocks. See details.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_show.bound">show.bound</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the
theoretical bound for the two statistics are plotted.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_which">which</code></td>
<td>
<p>Which plot should be plotted? <code>1</code> for the
<code class="reqn">\chi</code> <code>2</code> for the <code class="reqn">\overline{\chi}</code>
statistic and <code>1:2</code> for both of them.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_ask">ask</code></td>
<td>
<p>Logical. Should user be asked before each plot is
computed?</p>
</td></tr>
<tr><td><code id="chimeas_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_col.ci">col.ci</code>, <code id="chimeas_+3A_col.bound">col.bound</code></td>
<td>
<p>The color for the confidence
intervals and theoretical bounds.</p>
</td></tr>
<tr><td><code id="chimeas_+3A_lty.ci">lty.ci</code>, <code id="chimeas_+3A_lty.bound">lty.bound</code></td>
<td>
<p>The line type for the confidence intervals and
theoretical bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These two plots help us to understand the dependence relationship
between the two data set. The sign of <code class="reqn">\chi(u)</code> determines
if the variables are positively or negatively correlated. Two variable
are asymptotically independent if <code class="reqn">\lim_{u\rightarrow1} \chi(u) =
    0</code>. For the independent case, <code class="reqn">\chi(u) =
    0</code> for all u in (0,1). For the perfect dependence case,
<code class="reqn">\chi(u) = 1</code> for all u in (0,1). Note that for a
bivariate extreme value model, <code class="reqn">\chi(u) = 2(1 - A(0.5))</code> for all u in (0,1).
</p>
<p>The measure <code class="reqn">\overline{\chi}</code> is only useful for
asymptotically independent variables. Indeed, for asymptotically
dependent variable, we have <code class="reqn">\lim_{u\rightarrow
      1}\overline{\chi}(u) = 1</code>. For
asymptotically independent variables, <code class="reqn">\lim_{u\rightarrow
      1}\overline{\chi}(u)</code> reflects the strength
of the dependence between variables. For independent variables,
<code class="reqn">\overline{\chi}(u) = 0</code> for all u in (0,1).
</p>
<p>If there is (short range) dependence between observations, users may
need to use bootstrap confidence intervals. Bootstrap series are
obtained by sampling contiguous blocks, of length <code>l</code> say,
uniformly with replacement from the original observations. The block
length <code>l</code> should be chosen to be much greater than the
short-range dependence and much smaller than the total number of
observations.
</p>


<h3>Value</h3>

<p>A graphic window.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Coles, S., Heffernan, J. and Tawn, J. (1999) Dependence measures for
extreme value analyses. <em>Extremes</em> <b>2</b> 339&ndash;365.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tailind.test">tailind.test</a></code>, <code><a href="#topic+specdens">specdens</a></code>,
<code><a href="#topic+tsdep.plot">tsdep.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc &lt;- simmc(200, alpha = 0.9)
mc2 &lt;- simmc(100, alpha = 0.2)
##An independent case
par(mfrow = c(1,2))
chimeas(cbind(mc[1:100], mc2))
##Asymptotic dependence
par(mfrow = c(1,2))
chimeas(cbind(mc[seq(1,200, by = 2)], mc[seq(2,200,by = 2)]))
##The same but with bootstrap ci
par(mfrow = c(1,2))
chimeas(cbind(mc[seq(1,200, by = 2)], mc[seq(2,200,by = 2)]), boot =
TRUE, n.boot=50)
</code></pre>

<hr>
<h2 id='clust'>Identify Extreme Clusters within a Time Series</h2><span id='topic+clust'></span>

<h3>Description</h3>

<p>A function to identify clusters of exceedances of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust(data, u, tim.cond = 1, clust.max = FALSE, plot = FALSE,
only.excess = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_+3A_data">data</code></td>
<td>
<p>A matrix/data.frame with two columns. Columns names <b>must
be</b> <code>obs</code> for observations and <code>time</code> for the associated date of
each observation.</p>
</td></tr>
<tr><td><code id="clust_+3A_u">u</code></td>
<td>
<p>Numeric. A value giving the threshold.</p>
</td></tr>
<tr><td><code id="clust_+3A_tim.cond">tim.cond</code></td>
<td>
<p>A time condition to ensure independence between
events. Should be in the same unit than <code>data[,"time"]</code>.</p>
</td></tr>
<tr><td><code id="clust_+3A_clust.max">clust.max</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), a list
containing the clusters of exceedances is returned. Else, a matrix
containing the cluster maxima and related dates is returned.</p>
</td></tr>
<tr><td><code id="clust_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, identified
clusters are displayed. Else (the default), no plot is produced.</p>
</td></tr>
<tr><td><code id="clust_+3A_only.excess">only.excess</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), only
exceedances are plotted. Else, all observations are displayed.</p>
</td></tr>
<tr><td><code id="clust_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed in <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clusters of exceedances are defined as follows:
</p>

<ul>
<li><p> The first exceedance initiates the first cluster;
</p>
</li>
<li><p> The first observation under the threshold <code>u</code> &ldquo;ends&rdquo; the
current cluster unless <code>tim.cond</code> does not hold;
</p>
</li>
<li><p> The next exceedance initiates a new cluster;
</p>
</li>
<li><p> The process is iterated as needed.
</p>
</li></ul>

<p>This function differs from the function <code>clusters</code> of <code>evd</code>
Package as independence condition i.e. <code>tim.cond</code> could be a
&ldquo;temporal&rdquo; condition. That is, two events are considered independent
if the inter-arrival time is greater than a fixed duration.
</p>
<p>However, it is also possible to used the &ldquo;index&rdquo; independence as in
<code><a href="#topic+clust">clust</a></code> by setting <code>data[,"time"] =
  1:length(data[,"obs"])</code>.
</p>


<h3>Value</h3>

<p>If <code>clust.max</code> is <code>FALSE</code>, a list containing the clusters of
exceedances is returned. Else, a matrix containing the cluster maxima,
related dates and indices are returned.
</p>
<p>In any case, the returned object has an attribute <code>exi</code> giving
an estimation of the Extremal Index, that is the inverse of the
average cluster size.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code>clusters</code> of package <code>evd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
par(mfrow=c(1,2))
clust(ardieres, 4, 10 / 365)
clust(ardieres, 4, 10 / 365, clust.max = TRUE)
clust(ardieres, 4, 10 / 365, clust.max = TRUE, plot = TRUE)
##The same but with optional arguments passed to function ``plot''
clust(ardieres, 4, 10 / 365, clust.max = TRUE, plot = TRUE,
xlab = "Time (Years)", ylab = "Flood discharges",
xlim = c(1972, 1980))
</code></pre>

<hr>
<h2 id='Clusters'>Extremal Index Plot</h2><span id='topic+exiplot'></span>

<h3>Description</h3>

<p>Plot estimates of the Extremal Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exiplot(data, u.range, tim.cond = 1, n.u = 50, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clusters_+3A_data">data</code></td>
<td>
<p>A matrix/data.frame with two columns. Columns names <b>must
be</b> <code>obs</code> for observations and <code>time</code> for the associated date of
each observation.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_u.range">u.range</code></td>
<td>
<p>A numeric vector of length 2. Specify the range of
threshold for which the Extremal Index is estimated.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_tim.cond">tim.cond</code></td>
<td>
<p>A time condition to ensure independence between
events. Should be in the same unit that <code>data[,"time"]</code>.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_n.u">n.u</code></td>
<td>
<p>Numeric. The number of thresholds at which the Extremal
Index is estimated.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_xlab">xlab</code>, <code id="Clusters_+3A_ylab">ylab</code></td>
<td>
<p>Optional character strings to label the x and y
axis.</p>
</td></tr>
<tr><td><code id="Clusters_+3A_...">...</code></td>
<td>
<p>Optional options to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns invisibly a matrix with two columns. The first one <code>thresh</code>
giving the threshold and the second one <code>exi</code> the related Extremal
Index estimate.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>
</p>

<hr>
<h2 id='coef.pot'>Extract model coefficients of a <code>'pot'</code> model</h2><span id='topic+coef.pot'></span>

<h3>Description</h3>

<p><code>coef</code> extracts model coefficients of an object of class <code>'pot'</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pot'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pot_+3A_object">object</code></td>
<td>
<p>An object of class <code>'pot'</code>. Most often, this is an
object return by the <code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+fitbvgpd">fitbvgpd</a></code>
and <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> functions.</p>
</td></tr>
<tr><td><code id="coef.pot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="utils.html#topic+str">str</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard <code>coef</code> object: see <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rgpd(500, 0, 1, -0.15)
fmle &lt;- fitgpd(x, 0)
coef(fmle)
</code></pre>

<hr>
<h2 id='confint.uvpot'>Generic Function to Compute (Profile) Confidence Intervals</h2><span id='topic+confint.uvpot'></span>

<h3>Description</h3>

<p>Compute (profile) confidence intervals for the scale, shape GPD
parameters and also for GPD quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uvpot'
confint(object, parm, level = 0.95, ..., range, prob,
 prof = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.uvpot_+3A_object">object</code></td>
<td>
<p><code>R</code> object given by function <code><a href="#topic+fitgpd">fitgpd</a></code>.</p>
</td></tr>
<tr><td><code id="confint.uvpot_+3A_parm">parm</code></td>
<td>
<p>Charater string specifies for which variable confidence
intervals are computed. One of <code>"quant"</code>, <code>"scale"</code> or
<code>"shape"</code>.</p>
</td></tr>
<tr><td><code id="confint.uvpot_+3A_level">level</code></td>
<td>
<p>Numeric. The confidence level.</p>
</td></tr>
<tr><td><code id="confint.uvpot_+3A_...">...</code></td>
<td>
<p>Optional parameters. See details.</p>
</td></tr>  
<tr><td><code id="confint.uvpot_+3A_range">range</code></td>
<td>
<p>Vector of dimension two. It gives the lower and upper
bound on which the profile likelihood is performed. Only required
when &quot;prof = TRUE&quot;.</p>
</td></tr>
<tr><td><code id="confint.uvpot_+3A_prob">prob</code></td>
<td>
<p>The probability of non exceedance.</p>
</td></tr>
<tr><td><code id="confint.uvpot_+3A_prof">prof</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), profile confidence
intervals are computed. Otherwise, it is Fisher ones.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Additional options can be passed using &quot;...&quot; in the function
call. Possibilites are related to the specific functions:
<code>link{gpd.fiscale}</code>, <code>link{gpd.fishape}</code>,
<code>link{gpd.firl}</code>, <code>link{gpd.pfscale}</code>,
<code>link{gpd.pfshape}</code>, <code>link{gpd.pfrl}</code>.
</p>


<h3>Value</h3>

<p>Returns a vector of the lower and upper bound for the (profile) confidence
interval.  Moreover, a graphic of the profile likelihood function is
displayed when <code>prof = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code>link{gpd.fiscale}</code>, <code>link{gpd.fishape}</code>,
<code>link{gpd.firl}</code>, <code>link{gpd.pfscale}</code>,
<code>link{gpd.pfshape}</code> and <code>link{gpd.pfrl}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(100, 0, 1, 0.25)
fmle &lt;- fitgpd(x, 0)
confint(fmle, prob = 0.2)
confint(fmle, parm = "shape")
</code></pre>

<hr>
<h2 id='convassess'>Convergence Assessment for Fitted Objects</h2><span id='topic+convassess'></span><span id='topic+convassess.uvpot'></span><span id='topic+convassess.bvpot'></span><span id='topic+convassess.mcpot'></span>

<h3>Description</h3>

<p><code>convassess</code> is a generic function used to assess the convergence of 
the estimation procedure to the global maximum. The function invokes particular <code>methods</code> 
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
This function uses several starting values to assess the sensitiveness of the
fitted object with respect to starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convassess(object, n = 50)
  
## S3 method for class 'uvpot'
convassess(object, n = 50)
## S3 method for class 'mcpot'
convassess(object, n = 50)
## S3 method for class 'bvpot'
convassess(object, n = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convassess_+3A_object">object</code></td>
<td>
<p>A fitted object. When using the POT package, an object 
of class <code>'uvpot'</code>, <code>'mcpot'</code>
or <code>'bvpot'</code>. Generally, an object return by <code>fitgpd</code>,
<code>fitmcgpd</code> or <code>fitbvgpd</code>.</p>
</td></tr>
<tr><td><code id="convassess_+3A_n">n</code></td>
<td>
<p>The number of starting values to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The starting values are defined using the unbiased probability
weighted moments fitted on <code>n</code> bootstrap samples. 
</p>


<h3>Value</h3>

<p>Graphics: the considered starting values, the objective values derived
from numerical optimizations and traceplots for all estimated
parameters. In addition, it returns invisibly all these informations.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+fitmcgpd">fitmcgpd</a></code>, <code><a href="#topic+fitbvgpd">fitbvgpd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
##Univariate Case
x &lt;- rgpd(30, 0, 1, 0.2)
fgpd1 &lt;- fitgpd(x, 0, "med")
convassess(fgpd1)

##Bivariate Case
x &lt;- rbvgpd(50, model = "log", alpha = 0.5, mar1 = c(0, 1, 0.2))
fgpd2 &lt;- fitbvgpd(x, c(0.5,0.5))
convassess(fgpd2)
</code></pre>

<hr>
<h2 id='dens'>Density Plot: Univariate Case</h2><span id='topic+dens'></span><span id='topic+dens.uvpot'></span>

<h3>Description</h3>

<p><code>dens</code> is a generic function used to plot the density. 
The function invokes particular <code>methods</code> 
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
So the function plots density for univariate POT models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens(object, ...)

## S3 method for class 'uvpot'
dens(object, main, xlab, ylab, dens.adj = 1,
kern.lty = 2, rug = TRUE, plot.kernel = TRUE, plot.hist = TRUE,
hist.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens_+3A_object">object</code></td>
<td>
<p>A fitted object. When using the POT package, an object 
of class <code>'uvpot'</code>. Most often, the
return of the <code><a href="#topic+fitgpd">fitgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="dens_+3A_main">main</code></td>
<td>
<p>The title of the graphic. If missing, the title is set to
<code>"Density Plot"</code>.</p>
</td></tr>
<tr><td><code id="dens_+3A_xlab">xlab</code>, <code id="dens_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the x and y axis. If missing, they are
set to <code>"Quantile"</code> and <code>"Density"</code> respectively.</p>
</td></tr>
<tr><td><code id="dens_+3A_dens.adj">dens.adj</code></td>
<td>
<p>Numeric. The adjustment for the kernel density
estimation in the <code><a href="stats.html#topic+density">density</a></code> function. The default is 1.</p>
</td></tr>
<tr><td><code id="dens_+3A_kern.lty">kern.lty</code></td>
<td>
<p>The line type for the kernel density estimation. This
corresponds to the <code>"lty"</code> option of the <code><a href="graphics.html#topic+lines">lines</a></code>
functions. The default is 2.</p>
</td></tr>
<tr><td><code id="dens_+3A_rug">rug</code></td>
<td>
<p>Logical. Should we call the <code><a href="graphics.html#topic+rug">rug</a></code> function?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dens_+3A_plot.kernel">plot.kernel</code></td>
<td>
<p>Logical. Should the kernel density estimate be
plotted?</p>
</td></tr>
<tr><td><code id="dens_+3A_plot.hist">plot.hist</code></td>
<td>
<p>Logical. Should the histogram be plotted?</p>
</td></tr>
<tr><td><code id="dens_+3A_hist.col">hist.col</code></td>
<td>
<p>The color to fill the histogram.</p>
</td></tr>
<tr><td><code id="dens_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density plot consists of plotting on the same windows the
theoretical density and a kernel estimation one. If the theoretical
model is correct, then the two densities should be &ldquo;similar&rdquo;.
</p>


<h3>Value</h3>

<p>A graphical window.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+dens">dens</a></code>, <code><a href="#topic+dens.uvpot">dens.uvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(75, 1, 2, 0.1)
pwmu &lt;- fitgpd(x, 1, "pwmu")
dens(pwmu)
</code></pre>

<hr>
<h2 id='dexi'>Compute the Density of the Extremal Index</h2><span id='topic+dexi'></span>

<h3>Description</h3>

<p>Compute the density of the extremal index using simulations from a
fitted markov chain model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dexi(x, n.sim = 1000, n.mc = length(x$data), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dexi_+3A_x">x</code></td>
<td>
<p>A object of class <code>'mcpot'</code> - most often the returned
object of the <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="dexi_+3A_n.sim">n.sim</code></td>
<td>
<p>The number of simulation of Markov chains.</p>
</td></tr>
<tr><td><code id="dexi_+3A_n.mc">n.mc</code></td>
<td>
<p>The length of the simulated Markov chains.</p>
</td></tr>
<tr><td><code id="dexi_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the density of the
extremal index is plotted.</p>
</td></tr>
<tr><td><code id="dexi_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the
<code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Markov chains are simulated using the <code><a href="#topic+simmc">simmc</a></code>
function to obtained dependent realisations <code class="reqn">u_i</code> of standard
uniform realizations. Then, they are transformed to correspond to the
parameter of the fitted markov chain model. Thus, if <code class="reqn">u, \sigma,
    \xi</code> is the location, scale and shape parameters ; and
<code class="reqn">\lambda</code> is the probability of exceedance of <code class="reqn">u</code>,
then by defining :
</p>
<p style="text-align: center;"><code class="reqn">\sigma_* = \xi \times \frac{u}{\lambda^{-\xi} - 1}</code>
</p>

<p>the realizations <code class="reqn">y_i = qgpd(u_i, 0, \sigma_*, \xi)</code> are distributed such as the probability
of exceedance of <code class="reqn">u</code> is equal to <code class="reqn">\lambda</code>.
</p>
<p>At last, the extremal index for each generated Markov chain is
estimated using the estimator of Ferro and Segers (2003) (and thus
avoid any declusterization).
</p>


<h3>Value</h3>

<p>The function returns a optionally plot of the kernel density estimate
of the extremal index. In addition, the vector of extremal index
estimations is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Fawcett L., and Walshaw D. (2006) Markov chain models for extreme wind
speed. Environmetrics, <b>17</b>:(8) 795&ndash;809.
</p>
<p>Ferro, C. and Segers, J. (2003) Inference for clusters of extreme
values. Journal of the Royal Statistical Society. Series B
<b>65</b>:(2)  545&ndash;556.
</p>
<p>Ledford A., and Tawn, J. (1996) Statistics for near Independence in
Multivariate Extreme Values. Biometrika, <b>83</b> 169&ndash;187.
</p>
<p>Smith, R., and Tawn, J., and Coles, S. (1997) Markov chain models for
threshold exceedances. Biometrika, <b>84</b> 249&ndash;268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simmc">simmc</a></code>, <code><a href="#topic+fitmcgpd">fitmcgpd</a></code>, <code><a href="#topic+fitexi">fitexi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc &lt;- simmc(100, alpha = 0.25)
mc &lt;- qgpd(mc, 0, 1, 0.25)
fgpd1 &lt;- fitmcgpd(mc, 2, shape = 0.25, scale = 1)
dexi(fgpd1, n.sim = 100)
</code></pre>

<hr>
<h2 id='diplot'>Threshold Selection: The Dispersion Index Plot</h2><span id='topic+diplot'></span>

<h3>Description</h3>

<p>The Dispersion Index Plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>diplot(data, u.range, main, xlab, ylab, nt = max(200, nrow(data)),
conf=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diplot_+3A_data">data</code></td>
<td>
<p>A matrix with two column. The first one represents the
date of events (in a numeric format) and the second the data
associated with those dates.</p>
</td></tr>
<tr><td><code id="diplot_+3A_u.range">u.range</code></td>
<td>
<p>A numeric vector of length two giving the limit of
threshold analyzed. If missing, default values are taken.</p>
</td></tr>
<tr><td><code id="diplot_+3A_main">main</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="diplot_+3A_xlab">xlab</code>, <code id="diplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="diplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the dispersion index plot
is evaluated.</p>
</td></tr>
<tr><td><code id="diplot_+3A_conf">conf</code></td>
<td>
<p>The confident coefficient for the plotted confidence intervals.</p>
</td></tr>
<tr><td><code id="diplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the Extreme Value Theory, the number of exceedance
over a high threshold in a fixed period - generally a year - must be
distributed as Poisson process.  As for a random variable Poisson
distributed, the ratio of the variance and the mean is equal to 1, one
can test if the ratio <code class="reqn">\code{DI} = var / mean</code> differs from
1.  Moreover, confidence levels for <code>DI</code> can be calculated by
testing against a <code class="reqn">\chi^2</code> distribution with <code>M</code>-1 degree of
freedom, <code>M</code> being the total number of fixed periods -generally
the total number of years in the sample.  So, the Poisson hypothesis is
not rejected if the estimated <code>DI</code> is within the range
</p>
<p style="text-align: center;"><code class="reqn">\left[ \frac{\chi^2_{\alpha/2, \code{M}-1}}{\code{M}-1},
    \frac{\chi^2_{1 - \alpha/2, \code{M}-1} }{\code{M} - 1} \right]</code>
</p>



<h3>Value</h3>

<p>It returns invisibly a list with two components. The first one
<code>'thresh'</code> gives the thresholds analyzed. The second <code>'DI'</code>
gives the dispersion index relative to the threshold.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Cunnane, C. (1979) Note on the poisson assumption in
partial duration series model. Water Resource Research, 15<b>(2)</b>
:489&ndash;494.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
diplot(ardieres)
</code></pre>

<hr>
<h2 id='Fisher+20Confidence+20Interval'>Fisher Based Confidence Interval for the GP Distribution</h2><span id='topic+gpd.fishape'></span><span id='topic+gpd.fiscale'></span><span id='topic+gpd.firl'></span>

<h3>Description</h3>

<p>Compute Fisher based confidence intervals on parameter and
return level for the GP distribution.  This is achieved through
asymptotic theory and the Observed information matrix of Fisher and
eventually the Delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.fishape(object, conf = 0.95)
gpd.fiscale(object, conf = 0.95)
gpd.firl(object, prob, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fisher+2B20Confidence+2B20Interval_+3A_object">object</code></td>
<td>
<p><code>R</code> object given by function <code><a href="#topic+fitgpd">fitgpd</a></code>.</p>
</td></tr>
<tr><td><code id="Fisher+2B20Confidence+2B20Interval_+3A_prob">prob</code></td>
<td>
<p>The probability of non exceedance.</p>
</td></tr>
<tr><td><code id="Fisher+2B20Confidence+2B20Interval_+3A_conf">conf</code></td>
<td>
<p>Numeric. The confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the lower and upper bound for the confidence
interval.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+rp2prob">rp2prob</a></code>, <code><a href="#topic+prob2rp">prob2rp</a></code>,
<code><a href="#topic+gpd.pfscale">gpd.pfscale</a></code>,
<code><a href="#topic+gpd.pfshape">gpd.pfshape</a></code>, <code><a href="#topic+gpd.pfrl">gpd.pfrl</a></code> and
<code><a href="stats.html#topic+confint">confint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
f1 &lt;- fitgpd(ardieres[,"obs"], 5, 'mle')
gpd.fishape(f1)
gpd.fiscale(f1)
</code></pre>

<hr>
<h2 id='Fit+20the+20GP+20Distribution'>Fitting a GPD to Peaks Over a Threshold</h2><span id='topic+fitgpd'></span>

<h3>Description</h3>

<p>Maximum (Penalized) Likelihood, Unbiased Probability
Weighted Moments,Biased Probability Weighted Moments, Moments,
Pickands', Minimum Density Power Divergence, Medians, Likelihood
Moment and Maximum Goodness-of-Fit Estimators to fit Peaks Over a
Threshold to a GP distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitgpd(data, threshold, est = "mle", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fit+2B20the+2B20GP+2B20Distribution_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Fit+2B20the+2B20GP+2B20Distribution_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value giving the threshold for the
GPD. The <code>'mle'</code> estimator allows varying threshold; so that threshold
could be for this case a numeric vector. Be careful, varying
thresholds are used cyclically if length doesn't match with
<code>data</code>.</p>
</td></tr>
<tr><td><code id="Fit+2B20the+2B20GP+2B20Distribution_+3A_est">est</code></td>
<td>
<p>A string giving the names of the estimator. It can be
<code>'mle'</code> (the default), <code>'mple'</code>, <code>'moments'</code>, <code>'pwmu'</code>,
<code>'pwmb'</code>, <code>'mdpd'</code>, <code>'med'</code>, <code>'pickands'</code>,
<code>'lme'</code> and <code>'mgf'</code> for the maximum likelihood, maximum
penalized likelihood, moments, unbiased
probability weighted moments, biased probability weigthed moments,
minimum density power divergence, medians, Pickands', likelihood
moment and maximum goodness-of-fit estimators respectively.</p>
</td></tr> 
<tr><td><code id="Fit+2B20the+2B20GP+2B20Distribution_+3A_...">...</code></td>
<td>
<p>Other optional arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function, allow hand fixed parameters (only
for the <code>mle</code>, <code>mple</code> and <code>mgf</code> estimators) or passed
several options to specific estimators - see the Note section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>"uvpot"</code> with components:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A vector containing the estimated parameters.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimized and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code> - for the <code>mle</code> method.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold passed to argument <code>threshold</code>.</p>
</td></tr>
<tr><td><code>nat</code>, <code>pat</code></td>
<td>
<p>The number and proportion of exceedances.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>data</code>.</p>
</td></tr>
<tr><td><code>exceed</code></td>
<td>
<p>The exceedances, or the maxima of the clusters of
exceedances.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scale parameter for the fitted generalized Pareto
distribution.</p>
</td></tr>
<tr><td><code>std.err.type</code></td>
<td>
<p>The standard error type - for <code>'mle'</code>
only. That is <code>Observed</code> or <code>Expected</code> Information matrix
of Fisher.</p>
</td></tr>
<tr><td><code>var.thresh</code></td>
<td>
<p>Logical. Specify if the threshold is a varying one -
<code>'mle'</code> only. For other methods, threshold is always constant
i.e. <code>var.thresh = FALSE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Maximum Likelihood estimator is obtained through a slightly
modified version of Alec Stephenson's <code>fpot.norm</code> function in the
<code>evd</code> package.
</p>
<p>For the <code>'mple'</code> estimator, the likelihood function is penalized
using the following function :
</p>
<p style="text-align: center;"><code class="reqn">P(\xi) = \left\{
    \begin{array}{ll}
    1, &amp; \xi \leq 0\\
    \exp\left[-\lambda \left(\frac{1}{1-\xi} - 1\right)^\alpha \right], &amp;
    0 &lt; \xi &lt;1\\
    0, &amp; \xi \geq 1
    \end{array}
  \right.</code>
</p>

<p>where <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code> are the penalizing
constants. Coles and Dixon (1999) suggest the use of
<code class="reqn">\alpha=\lambda=1</code>.
</p>
<p>The <code>'lme'</code> estimator has a special parameter <code>'r'</code>. Zhang
(2007) shows that a value of -0.5 should be accurate in most of the
cases. However, other values such as <code>r &lt; 0.5</code> can be
explored. In particular, if <code>r</code> is approximatively equal to the
opposite of the true shape parameter value, then the <code>lme</code>
estimate is equivalent to the <code>mle</code> estimate.
</p>
<p>The <code>'pwmb'</code> estimator has special parameters <code>'a'</code> and
<code>'b'</code>. These parameters are called the &quot;plotting-position&quot;
values. Hosking and Wallis (1987) recommend the use of <code>a = 0.35</code>
and <code>b = 0</code> (the default). However, different values can be
tested.
</p>
<p>For the <code>'pwmu'</code> and <code>'pwmb'</code> approaches, one can pass the
option <code>'hybrid = TRUE'</code> to use hybrid estimators as proposed by
Dupuis and Tsao (1998). Hybrid estimators avoid to have no feasible
points.
</p>
<p>The <code>mdpd</code> estimator has a special parameter <code>'a'</code>. This is
a parameter of the &quot;density power divergence&quot;. Juarez and Schucany
(2004) recommend the use of <code>a = 0.1</code>, but any value of
<code>a</code> such as <code>a &gt; 0</code> can be used (small values are recommend
yet).
</p>
<p>The <code>med</code> estimator admits two extra arguments <code>tol</code> and
<code>maxit</code> to control the &quot;stopping-rule&quot; of the optimization
process.
</p>
<p>The <code>mgf</code> approach uses goodness-of-fit statistics to estimate
the GPD parameters. There are currently 8 different statitics: the
Kolmogorov-Smirnov <code>"KS"</code>, Cramer von Mises <code>"CM"</code>, Anderson
Darling <code>"AD"</code>, right tail Anderson Darling <code>"ADR"</code>, left
tail Anderson Darling <code>"ADL"</code>, right tail Anderson Darling
(second degree) <code>"AD2R"</code>, left tail Anderson Darling (second
degree) <code>"AD2L"</code> and the Anderson Darling (second degree)
<code>"AD2"</code> statistics.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Coles, S. (2001) <em>An Introduction to Statistical
Modelling of Extreme Values</em>. Springer Series in Statistics. London.
</p>
<p>Coles, S. and Dixon, M. (1999) Likelihood-Based Inference for Extreme
Value Models. Extremes <b>2</b>(1):5&ndash;23.
</p>
<p>Dupuis, D. and Tsao (1998) M. A hybrid estimator for generalized
Pareto and extreme-value distributions. Communications in
Statistics-Theory and Methods <b>27</b>:925&ndash;941.
</p>
<p>Hosking, J. and Wallis, J. (1987) Parameters and Quantile Estimation
for the Generalized Pareto Distribution. Technometrics
<b>29</b>:339&ndash;349.
</p>
<p>Juarez, S. and Schucany, W. (2004) Robust and Efficient Estimation for
the Generalized Pareto Distribution. Extremes <b>7</b>:237&ndash;251.
</p>
<p>Luceno, A. (2006) Fitting the generalized Pareto distribution to data
using maximum goodness-of-fit estimators. Computational Statistics and
Data Analysis <b>51</b>:904&ndash;917.
</p>
<p>Peng, L. and Welsh, A. (2001) Robust Estimation of the Generalized
Pareto Distribution. Extremes <b>4</b>:53&ndash;65.
</p>
<p>Embrechts, P and Kluppelberg, C. and Mikosch, T (1997) <em>Modelling
Extremal Events for Insurance and Finance.</em> Springers.
</p>
<p>Pickands, J. (1975) Statistical Inference Using Extreme Order
Statistics. Annals of Statistics. <b>3</b>:119&ndash;131.
</p>
<p>Zhang, J. (2007) Likelihood Moment Estimation for the Generalized
Pareto Distribution. Australian and New Zealand Journal of
Statistics. <b>49</b>(1):69&ndash;77.
</p>


<h3>See Also</h3>

<p>The following usual generic functions are available 
<code><a href="#topic+print.uvpot">print</a></code>, 
<code><a href="#topic+plot.uvpot">plot</a></code>, 
<code><a href="#topic+confint.uvpot">confint</a></code> and
<code><a href="#topic+anova.uvpot">anova</a></code>
as well as new generic functions 
<code><a href="#topic+retlev.uvpot">retlev</a></code>, 
<code><a href="#topic+qq.uvpot">qq</a></code>, 
<code><a href="#topic+pp.uvpot">pp</a></code>, 
<code><a href="#topic+dens.uvpot">dens</a></code> and
<code><a href="#topic+convassess.uvpot">convassess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(200, 1, 2, 0.25)
mle &lt;- fitgpd(x, 1, "mle")$param
pwmu &lt;- fitgpd(x, 1, "pwmu")$param
pwmb &lt;- fitgpd(x, 1, "pwmb")$param
pickands &lt;- fitgpd(x, 1, "pickands")$param    ##Check if Pickands estimates
                                              ##are valid or not !!!
med &lt;- fitgpd(x, 1, "med",                    ##Sometimes the fitting algo is not
start = list(scale = 2, shape = 0.25))$param  ##accurate. So specify
                                              ##good starting values is
                                              ##a good idea.  
mdpd &lt;- fitgpd(x, 1, "mdpd")$param
lme &lt;- fitgpd(x, 1, "lme")$param
mple &lt;- fitgpd(x, 1, "mple")$param
ad2r &lt;- fitgpd(x, 1, "mgf", stat = "AD2R")$param

print(rbind(mle, pwmu, pwmb, pickands, med, mdpd, lme,
 mple, ad2r))

##Use PWM hybrid estimators
fitgpd(x, 1, "pwmu", hybrid = FALSE)

##Now fix one of the GPD parameters
##Only the MLE, MPLE and MGF estimators are allowed !
fitgpd(x, 1, "mle", scale = 2)
fitgpd(x, 1, "mple", shape = 0.25) 
</code></pre>

<hr>
<h2 id='fitbvgpd'>Fitting Bivariate Peaks Over a Threshold Using Bivariate
Extreme Value Distributions</h2><span id='topic+fitbvgpd'></span>

<h3>Description</h3>

<p>Fitting a bivariate extreme value distribution to bivariate
exceedances over thresholds using censored maximum likelihood
procedure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitbvgpd(data, threshold, model = "log", start, ..., cscale = FALSE,
cshape = FALSE, std.err.type = "observed", corr = FALSE, warn.inf = TRUE,
method = "BFGS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitbvgpd_+3A_data">data</code></td>
<td>
<p>A matrix with two columns which gives the observation
vector for margin 1 and 2 respectively. <code>NA</code> values are
considered to fall below the threshold.</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_threshold">threshold</code></td>
<td>
<p>A numeric vector for the threshold (of length 2).</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_model">model</code></td>
<td>
<p>A character string which specifies the model used. Must
be one of <code>log</code> (the default), <code>alog</code>, <code>nlog</code>,
<code>anlog</code>, <code>mix</code> and <code>amix</code> for the logistic, asymmetric
logistic, negative logistic, asymmetric negative logistic, mixed and
asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_start">start</code></td>
<td>
<p>Optional. A list for starting values in the fitting
procedure.</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function or to the bivariate model. In
particular, parameter of the model can be hand fixed.</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_cscale">cscale</code></td>
<td>
<p>Logical. Should the two scale parameters be equal?</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_cshape">cshape</code></td>
<td>
<p>Logical. Should the two shape parameters be equal?</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_std.err.type">std.err.type</code></td>
<td>
<p>The type of the standard error. Currently, one
must specify <code>"observed"</code> for observed Fisher information
matrix or <code>"none"</code> for no computations of the standard
errors.</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_corr">corr</code></td>
<td>
<p>Logical. Should the correlation matrix be computed?</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical. Should users be warned if likelihood is not
finite at starting values?</p>
</td></tr>
<tr><td><code id="fitbvgpd_+3A_method">method</code></td>
<td>
<p>The optimization method, see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate exceedances are fitted using censored likelihood
procedure. This methodology is fully described in Ledford (1996).
</p>
<p>Most of models are described in Kluppelberg (2006).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>c("bvpot","pot")</code>. As
usual, one can extract several features using <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="stats.html#topic+deviance">deviance</a></code>,
<code><a href="stats.html#topic+logLik">logLik</a></code> and <code><a href="stats.html#topic+AIC">AIC</a></code>  functions.  
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>The maximum likelihood estimates of the bivariate
extreme value distribution.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors - only present
when the observed information matrix is not singular.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The asymptotic variance covariance matrix - only
presents when the observed information matrix is not singular.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Informations taken from the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The marginal thresholds.</p>
</td></tr>
<tr><td><code>pat</code></td>
<td>
<p>The marginal proportion above the threshold.</p>
</td></tr>
<tr><td><code>nat</code></td>
<td>
<p>The marginal number above the threshold.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The bivariate matrix of observations.</p>
</td></tr>
<tr><td><code>exceed1</code>, <code>exceed2</code></td>
<td>
<p>The marginal exceedances.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model for the bivariate extreme value distribution.</p>
</td></tr>
<tr><td><code>chi</code></td>
<td>
<p>The chi statistic of Coles (1999). A value near 1 (resp. 0)
indicates perfect dependence (resp. independence).</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>Because of numerical problems, their exists artificial numerical
constraints imposed on each model. These are:
</p>

<ul>
<li><p> For the logistic and asymmetric logistic models: <code class="reqn">\alpha</code>
must lie in [0.05, 1] instead of [0,1];
</p>
</li>
<li><p> For the negative logistic model: <code class="reqn">\alpha</code> must lie in
[0.01, 15] instead of <code class="reqn">[0,\infty[</code>;
</p>
</li>
<li><p> For the asymmetric negative logistic model: <code class="reqn">\alpha</code> must
lie in [0.2, 15] instead of <code class="reqn">[0,\infty[</code>;
</p>
</li>
<li><p> For the mixed and asymmetric mixed models: None artificial numerical
constraints are imposed.
</p>
</li></ul>

<p>For this purpose, users must check if estimates are near these
artificial numerical constraints. Such cases may lead to substantial
biases on the GP parameter estimates. One way to detect quickly if
estimates are near the border constraints is to look at the standard
errors for the dependence parameters. Small values (i.e. &lt; 1e-5) often
indicates that numerical constraints have been reached.
</p>
<p>In addition, users must be aware that the mixed and asymmetric mixed
models can not deal with perfect dependence.
</p>
<p>Thus, user may want to plot the Pickands' dependence function to see
if variable are near independence or dependence cases using the
<code><a href="#topic+pickdep">pickdep</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Coles, S., Heffernan, J. and Tawn, J. (1999) Dependence Measure for
Extreme Value Analyses. Extremes, <b>2</b>:4 339&ndash;365.
</p>
<p>Kl\&quot;uppelberg, C., and May A. (2006) Bivariate extreme value
distributions based on polynomial dependence functions. Mathematical
Methods in the Applied Sciences, <b>29</b>: 1467&ndash;1480.
</p>
<p>Ledford A., and Tawn, J. (1996) Statistics for near Independence in
Multivariate Extreme Values. Biometrika, <b>83</b>: 169&ndash;187.
</p>


<h3>See Also</h3>

<p>The following usual generic functions are available 
<code><a href="#topic+print.bvpot">print</a></code>, 
<code><a href="#topic+plot.bvpot">plot</a></code> and
<code><a href="#topic+anova.bvpot">anova</a></code>
as well as new generic functions 
<code><a href="#topic+retlev.bvpot">retlev</a></code> and
<code><a href="#topic+convassess.bvpot">convassess</a></code>.
</p>
<p>See also <code><a href="#topic+pickdep">pickdep</a></code>, <code><a href="#topic+specdens">specdens</a></code>.
</p>
<p>For optimization in R, see <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(1000, 0, 1, 0.25)
y &lt;- rgpd(1000, 3, 1, -0.25)
ind &lt;- fitbvgpd(cbind(x, y), c(0, 3), "log")
ind
ind2 &lt;- fitbvgpd(cbind(x, y), c(0, 3), "log", alpha = 1)
ind2
ind3 &lt;- fitbvgpd(cbind(x, y), c(0, 3), cscale = TRUE)
ind3
##The mixed model can not deal with perfect dependent variables
##Thus, there is a substantial bias in GPD parameter estimates
dep &lt;- fitbvgpd(cbind(x, x + 3), c(0, 3), "mix")
dep
</code></pre>

<hr>
<h2 id='fitexi'>Extremal Index Estimation</h2><span id='topic+fitexi'></span>

<h3>Description</h3>

<p>Estimation of the extremal index using interexceedance times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitexi(data, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitexi_+3A_data">data</code></td>
<td>
<p>A matrix with two columns: <code>obs</code> for the
observations and <code>time</code> for the time.</p>
</td></tr>
<tr><td><code id="fitexi_+3A_threshold">threshold</code></td>
<td>
<p>The threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extremal index estimator proposed by Ferro and Segers
(2003) is based on interexceedance times. In particular, it does not
require a specific declusterization of the time series.
</p>
<p>The <code>tim.cond</code> gives an &ldquo;automatic&rdquo; procedure to decluster
the time series without any subjective choice to define the
independence condition between clusters.
</p>


<h3>Value</h3>

<p>This function returns a list with two components. The first one
<code>exi</code> gives the estimate of the extremal index; while the
second, <code>tim.cond</code> gives the time condition for independence
between events to be passed to the <code><a href="#topic+clust">clust</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ferro, C. and Segers, J. (2003) Inference for clusters of extreme
values. Journal of the Royal Statistical Society. Series B <b>65:2</b>
545&ndash;556.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.obs &lt;- 500
x &lt;- rexp(n.obs + 1)
y &lt;- pmax(x[-1], x[-(n.obs + 1)])## The extremal index is 0.5

u &lt;- quantile(y, 0.95)
fitexi(y, u)
</code></pre>

<hr>
<h2 id='fitmcgpd'>Fitting Markov Chain Models to Peaks Over a Threshold</h2><span id='topic+fitmcgpd'></span>

<h3>Description</h3>

<p>Fitting a Markov chain to cluster exceedances using a bivariate
extreme value distribution and a censored maximum likelihood
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitmcgpd(data, threshold, model = "log", start, ..., std.err.type =
"observed", corr = FALSE, warn.inf = TRUE, method = "BFGS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitmcgpd_+3A_data">data</code></td>
<td>
<p>A vector of observations.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_model">model</code></td>
<td>
<p>A character string which specifies the model used. Must
be one of <code>log</code> (the default), <code>alog</code>, <code>nlog</code>,
<code>anlog</code>, <code>mix</code> and <code>amix</code> for the logistic, asymmetric
logistic, negative logistic, asymmetric negative logistic, mixed and
asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_start">start</code></td>
<td>
<p>Optional. A list for starting values in the fitting
procedure.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function or to the bivariate model. In
particular, parameter of the model can be hand fixed.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_std.err.type">std.err.type</code></td>
<td>
<p>The type of the standard error. Currently, one
must specify <code>``observed''</code> for observed Fisher information
matrix or <code>``none''</code> for no computations of the standard
errors.</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_corr">corr</code></td>
<td>
<p>Logical. Should the correlation matrix be computed?</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical. Should users be warned if likelihood is not
finite at starting values?</p>
</td></tr>
<tr><td><code id="fitmcgpd_+3A_method">method</code></td>
<td>
<p>The optimization method, see <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Markov Chain model is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">L\left(y;\theta_1,\theta_2\right) = f\left(x_1; \theta_1\right)
    \prod_{i=2}^n f\left(y_i |
    y_{i-1};\theta_1,\theta_2\right)</code>
</p>

<p>As exceedances above a (high enough) threshold are of interest, it is
assumed that the marginal are GPD distributed, while the joint
distribution is represented by a bivariate extreme value
distribution. Smith et al. (1997) present theoretical results about
this Markov Chain model.
</p>
<p>The bivariate exceedances are fitted using censored likelihood
procedure. This methodology is fully described in Ledford (1996).
</p>
<p>Most of models are described in Kluppelberg (2006).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>c("mcpot", "uvpot",
    "pot")</code>.  As usual, one can extract several features using
<code><a href="stats.html#topic+fitted">fitted</a></code> (or <code><a href="stats.html#topic+fitted.values">fitted.values</a></code>),
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and <code><a href="stats.html#topic+AIC">AIC</a></code>
functions.
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>The maximum likelihood estimates of the Markov
chain including estimated parameters of the bivariate extreme value
distribution.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors - only present
when the observed information matrix is not singular.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The asymptotic variance covariance matrix - only
presents when the observed information matrix is not singular.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Informations taken from the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold.</p>
</td></tr>
<tr><td><code>pat</code></td>
<td>
<p>The proportion above the threshold.</p>
</td></tr>
<tr><td><code>nat</code></td>
<td>
<p>The number above the threshold.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The observations.</p>
</td></tr>
<tr><td><code>exceed</code></td>
<td>
<p>The exceedances.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The model for the bivariate extreme value distribution.</p>
</td></tr>
<tr><td><code>chi</code></td>
<td>
<p>The chi statistic of Coles (1999). A value near 1 (resp. 0)
indicates perfect dependence (resp. independence).</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>Because of numerical problems, there exists artificial numerical
constraints imposed on each model. These are:
</p>

<ul>
<li><p> For the logistic and asymmetric logistic models: <code class="reqn">\alpha</code>
must lie in [0.05, 1] instead of [0,1];
</p>
</li>
<li><p> For the negative logistic model: <code class="reqn">\alpha</code> must lie in
[0.01, 15] instead of <code class="reqn">[0,\infty[</code>;
</p>
</li>
<li><p> For the asymmetric negative logistic model: <code class="reqn">\alpha</code> must
lie in [0.2, 15] instead of <code class="reqn">[0,\infty[</code>;
</p>
</li>
<li><p> For the mixed and asymmetric mixed models: None artificial numerical
constraints are imposed.
</p>
</li></ul>

<p>For this purpose, users must check if estimates are near these
artificial numerical constraints. Such cases may lead to substantial
biases on the GP parameter estimates. One way to detect quickly if
estimates are near the border constraints is to look at the standard
errors for the dependence parameters. Small values (i.e. &lt; 1e-5) often
indicates that numerical constraints have been reached.
</p>
<p>In addition, users must be aware that the mixed and asymmetric mixed
models can not deal with perfect dependence.
</p>
<p>Thus, user may want to plot the Pickands' dependence function to see
if variable are near independence or dependence cases using the
<code><a href="#topic+pickdep">pickdep</a></code> function.
</p>
<p>In addition, we recommend to fix the marginal parameters. Indeed, even
this is a two steps optimization procedure, this avoid numerical
troubles - the likelihood function for the Markov chain model seems to
be problematic. Thus, estimates are often better using the two stages
approach.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Kl\&quot;uppelberg, C., and May A. (2006) Bivariate extreme value
distributions based on polynomial dependence functions. Mathematical
Methods in the Applied Sciences, <b>29</b> 1467&ndash;1480.
</p>
<p>Ledford A., and Tawn, J. (1996) Statistics for near Independence in
Multivariate Extreme Values. Biometrika, <b>83</b> 169&ndash;187.
</p>
<p>Smith, R., and Tawn, J., and Coles, S. (1997) Markov chain models for
threshold exceedances. Biometrika, <b>84</b> 249&ndash;268
</p>


<h3>See Also</h3>

<p>The following usual generic functions are available 
<code><a href="#topic+print.mcpot">print</a></code>, 
<code><a href="#topic+plot.mcpot">plot</a></code>
as well as new generic functions 
<code><a href="#topic+retlev.mcpot">retlev</a></code> and
<code><a href="#topic+convassess.mcpot">convassess</a></code>.
</p>
<p>See also <code><a href="#topic+pickdep">pickdep</a></code>.
</p>
<p>For optimization in R, see <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc &lt;- simmc(1000, alpha = 0.25)
mc &lt;- qgpd(mc, 0, 1, 0.25)
##A first application when marginal parameter are estimated
fitmcgpd(mc, 0)

##Another one where marginal parameters are fixed
fmle &lt;- fitgpd(mc, 0)
fitmcgpd(mc, 0, scale = fmle$param["scale"], shape = fmle$param["shape"])
</code></pre>

<hr>
<h2 id='fitpp'>Fitting the point process characterisation to exceedances above a
threshold</h2><span id='topic+fitpp'></span>

<h3>Description</h3>

<p>This function estimates the point process characterisation
from exceedances above a threshold.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitpp(data, threshold, noy = length(data) / 365.25, start, ...,
std.err.type = "observed", corr = FALSE, method = "BFGS", warn.inf = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitpp_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_threshold">threshold</code></td>
<td>
<p>A numeric value giving the threshold for the
GPD.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_noy">noy</code></td>
<td>
<p>Numeric. The number of year of observation.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_start">start</code></td>
<td>
<p>A named list that gives the starting values for the
optimization routine. Each list argument must correspond to one
parameter to be estimated. May be missing.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_...">...</code></td>
<td>
<p>Other optional arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function, allow hand fixed parameters (only
- see the Note section.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_std.err.type">std.err.type</code></td>
<td>
<p>A character string. If &quot;observed&quot;, the standard
errors are derived from the observed Fisher information matrix. If
&quot;none&quot;, standard errors are not computed.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_corr">corr</code></td>
<td>
<p>Logical. Does the asymptotic correlation matrix has to be
computed? Default is &quot;not computed&quot; - e.g. <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_method">method</code></td>
<td>
<p>A character string specifying which numerical
optimization procedure has to be used. See <code><a href="stats.html#topic+optim">optim</a></code> for
more details.</p>
</td></tr>
<tr><td><code id="fitpp_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), users will be
warned if the log-likelihood is not finite at starting values - as
it may cause some problem during the optimation stage.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>This function returns a list with  components:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A vector containing the estimated parameters.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimized and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code> - for the <code>mle</code> method.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold passed to argument <code>threshold</code>.</p>
</td></tr>
<tr><td><code>nat</code>, <code>pat</code></td>
<td>
<p>The number and proportion of exceedances.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>data</code>.</p>
</td></tr>
<tr><td><code>exceed</code></td>
<td>
<p>The exceedances, or the maxima of the clusters of
exceedances.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scale parameter for the fitted generalized Pareto
distribution.</p>
</td></tr>
<tr><td><code>std.err.type</code></td>
<td>
<p>The standard error type - for <code>'mle'</code>
only. That is <code>Observed</code> Information matrix of Fisher.</p>
</td></tr>
<tr><td><code>var.thresh</code></td>
<td>
<p>Logical. Specify if the threshold is a varying one -
<code>'mle'</code> only. For other methods, threshold is always constant
i.e. <code>var.thresh = FALSE</code>. Not implemented yet.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Coles, S. (2001) <em>An Introduction to Statistical
Modelling of Extreme Values</em>. Springer Series in Statistics. London.
</p>
<p>Embrechts, P and Kluppelberg, C. and Mikosch, T (1997) <em>Modelling
Extremal Events for Insurance and Finance.</em> Springers.
</p>
<p>Pickands, J. (1975) Statistical Inference Using Extreme Order
Statistics. Annals of Statistics. <b>3</b>:119&ndash;131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(1000, 0, 1, 0.2)
fitpp(x, 0)
</code></pre>

<hr>
<h2 id='Flood+20Flows'>High Flood Flows of the Ardieres River at Beaujeu</h2><span id='topic+ardieres'></span>

<h3>Description</h3>

<p>A data frame containing flood discharges, in units of cubic meters per
second, of the Ardieres River at Beaujeu (FRANCE), over a period of 33
years and the related date of those events.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ardieres)</code></pre>


<h3>Format</h3>

<p>A data frame with two columns: &quot;time&quot; and &quot;obs&quot;.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
plot(ardieres, xlab = "Time (Years)", ylab = expression(paste("Flood
discharges ", m^2/s, sep="")), type = "l")
</code></pre>

<hr>
<h2 id='Generalized+20Pareto'>The Generalized Pareto Distribution</h2><span id='topic+rgpd'></span><span id='topic+dgpd'></span><span id='topic+qgpd'></span><span id='topic+pgpd'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the GP distribution with location equal to 'loc',
scale equal to 'scale' and shape equal to 'shape'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgpd(n, loc = 0, scale = 1, shape = 0)
pgpd(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, lambda = 0)
qgpd(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, lambda = 0)
dgpd(x, loc = 0, scale = 1, shape = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generalized+2B20Pareto_+3A_x">x</code>, <code id="Generalized+2B20Pareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_loc">loc</code></td>
<td>
<p>vector of the location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_scale">scale</code></td>
<td>
<p>vector of the scale parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_shape">shape</code></td>
<td>
<p>a numeric of the shape parameter.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">\Pr[ X
      \le x]</code>, otherwise, <code class="reqn">\Pr[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto_+3A_lambda">lambda</code></td>
<td>
<p>a single probability - see the &quot;value&quot; section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'loc', 'scale' and 'shape' are not specified they assume the default
values of '0', '1' and '0', respectively.
</p>
<p>The GP distribution function for loc = <code class="reqn">u</code>, scale = <code class="reqn">\sigma</code>
and shape = <code class="reqn">\xi</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(x) = 1 - \left[ 1 + \frac{\xi (x - u )}{ \sigma } \right] ^ { - 1 /
      \xi}</code>
</p>

<p>for <code class="reqn">1 + \xi ( x - u ) / \sigma &gt; 0</code> and <code class="reqn">x &gt;
    u</code>, where <code class="reqn">\sigma &gt; 0</code>. If <code class="reqn">\xi = 0</code>, the distribution is defined by continuity corresponding to the
exponential distribution.
</p>
<p>By definition, the GP distribution models exceedances above a
threshold. In particular, the <code class="reqn">G</code> function is a suited
candidate to model
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[ X \geq x | X &gt; u \right] = 1 - G(x)</code>
</p>

<p>for <code class="reqn">u</code> large enough.
</p>
<p>However, it may be usefull to model the &quot;non conditional&quot; quantiles,
that is the ones related to <code class="reqn">\Pr[ X \leq x]</code>. Using
the conditional probability definition, one have :
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[ X \geq x \right] = \left(1 - \lambda\right) \left( 1 +
    \xi \frac{x - u}{\sigma}\right)^{-1/\xi}</code>
</p>

<p>where <code class="reqn">\lambda = \Pr[ X \leq u]</code>.
</p>
<p>When <code class="reqn">\lambda = 0</code>, the &quot;conditional&quot; distribution
is equivalent to the &quot;non conditional&quot; distribution. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgpd(0.1)
rgpd(100, 1, 2, 0.2)
qgpd(seq(0.1, 0.9, 0.1), 1, 0.5, -0.2)
pgpd(12.6, 2, 0.5, 0.1)
##for non conditional quantiles
qgpd(seq(0.9, 0.99, 0.01), 1, 0.5, -0.2, lambda = 0.9)
pgpd(2.6, 2, 2.5, 0.25, lambda = 0.5)
</code></pre>

<hr>
<h2 id='gpd2frech'>Transforms GPD Observations to Unit Frechet Ones and Vice Versa</h2><span id='topic+gpd2frech'></span><span id='topic+frech2gpd'></span>

<h3>Description</h3>

<p>Transforms GPD observations to unit Frechet ones and vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd2frech(x, loc = 0, scale = 1, shape = 0, pat = 1)
frech2gpd(z, loc = 0, scale = 1, shape = 0, pat = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd2frech_+3A_x">x</code>, <code id="gpd2frech_+3A_z">z</code></td>
<td>
<p>The vector of observations.</p>
</td></tr>
<tr><td><code id="gpd2frech_+3A_loc">loc</code>, <code id="gpd2frech_+3A_scale">scale</code>, <code id="gpd2frech_+3A_shape">shape</code></td>
<td>
<p>The location, scale and shape parameters
respectively.</p>
</td></tr>
<tr><td><code id="gpd2frech_+3A_pat">pat</code></td>
<td>
<p>The proportion above the threshold, i.e. Pr[X &gt; log] =
pat.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Let <code class="reqn">x_i</code>, <code class="reqn">i=1,\ldots,n</code> be the realisation
of a GPD random variable. Thus, the transformation to unit Frechet is
defined as:
</p>
<p style="text-align: center;"><code class="reqn">z_i = - \frac{1}{\log\left[1 - pat \left(1 + shape \frac{x_i -
	loc}{scale}\right)_+^{-1/shape}\right]}</code>
</p>



<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(10, 0, 1, 0.25)
z &lt;- gpd2frech(x, 0, 1, 0.25)
z
all(frech2gpd(z, 0, 1, 0.25) == x)
</code></pre>

<hr>
<h2 id='Internal+20functions+20and+20methods'>Internal functions and methods for the POT package.</h2><span id='topic+gpdmple'></span><span id='topic+gpdmgf'></span><span id='topic+gpdmoments'></span><span id='topic+gpdpwmu'></span><span id='topic+gpdpwmb'></span><span id='topic+gpdmle'></span><span id='topic+gpdpickands'></span><span id='topic+gpdmdpd'></span><span id='topic+gpdmed'></span><span id='topic+gpdlme'></span><span id='topic+rbvlog'></span><span id='topic+rbvalog'></span><span id='topic+rbvnlog'></span><span id='topic+rbvanlog'></span><span id='topic+rbvmix'></span><span id='topic+rbvamix'></span><span id='topic+pbvlog'></span><span id='topic+pbvalog'></span><span id='topic+pbvnlog'></span><span id='topic+pbvanlog'></span><span id='topic+pbvmix'></span><span id='topic+pbvamix'></span>

<h3>Description</h3>

<p>A set of functions that should not be used directly by the
user. For methods, user should usually used the generic functions which
calls the appropriate method.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>

<hr>
<h2 id='L-moments'>Compute Sample L-moments</h2><span id='topic+samlmu'></span>

<h3>Description</h3>

<p>Compute the sample L-moments - unbiased version.</p>


<h3>Usage</h3>

<pre><code class='language-R'>samlmu(x, nmom = 4, sort.data = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L-moments_+3A_x">x</code></td>
<td>
<p>a vector of data</p>
</td></tr>
<tr><td><code id="L-moments_+3A_nmom">nmom</code></td>
<td>
<p>a numeric value giving the number of sample L-moments to
be computed</p>
</td></tr>
<tr><td><code id="L-moments_+3A_sort.data">sort.data</code></td>
<td>
<p>a logical which specifies if the vector of data x
should be sorted or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector of length <code>nmom</code> corresponding to the
sample L-moments. Note that for orders greater or equal than 3 it is the L-moments
ratio that is sample L-coefficient of variation, sample L-skewness, sample L-kurtosis, ... 
</p>


<h3>References</h3>

<p>Hosking, J. R. M. (1990) L-moment analysis and estimation of
order statistics. Journal of the Royal Statistical Society Series
B, <b>52</b>: 105&ndash;124.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(50)
samlmu(x, nmom = 5)
</code></pre>

<hr>
<h2 id='lmomplot'>Threshold Selection: The L-moments Plot</h2><span id='topic+lmomplot'></span>

<h3>Description</h3>

<p>Plots of sample L-Skewness ans L-Kurtosis estimates at various
thresholds for peaks over threshold modelling, using the Generalized
Pareto parametrization.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmomplot(data, u.range, nt = max(50, length(data)), identify = TRUE,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmomplot_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="lmomplot_+3A_u.range">u.range</code></td>
<td>
<p>A numeric vector of length two, giving the limits for
the thresholds at which the model is fitted.</p>
</td></tr>
<tr><td><code id="lmomplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the sample L-moments are
evaluated.</p>
</td></tr>
<tr><td><code id="lmomplot_+3A_identify">identify</code></td>
<td>
<p>Logical. If <code>TRUE</code>, points on the plot are
identify using <code><a href="graphics.html#topic+identify">identify</a></code> function.</p>
</td></tr>
<tr><td><code id="lmomplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the model fit
function <code>fitgpd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each thresholds, sample L-skewness and L-kurtosis are computed. If
data are GP distributed, one have :
</p>
<p style="text-align: center;"><code class="reqn"> \tau_4 = \frac{\tau_3 \left( 1 + 5 \tau_3 \right)}{5 + \tau_3}
  </code>
</p>

<p>So, a threshold is acceptable if sample <code class="reqn">\left(\tau_3,
    \tau_4\right)</code> are near the theoretical curve.
</p>


<h3>Warnings</h3>

<p>L-moments plot are really difficult to interpret.  It can help us to
say if the GP distribution is suited to model data.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Hosking, J. R. M. and Wallis, J. R. (1997) <em>Regional
Frequency Analysis</em>. Cambridge University Press.
</p>
<p>Begueria, S. (2005) Uncertainties in partial duration series
modelling of extremes related to the choice of the threshold value.
Journal of Hydrology, 303<b>(1-4)</b>: 215&ndash;230.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+mrlplot">mrlplot</a></code>,
<code><a href="#topic+tcplot">tcplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
flows &lt;- ardieres[, "obs"]
lmomplot(flows, identify = FALSE)
</code></pre>

<hr>
<h2 id='logLik.pot'>Extract Log-Likelihood</h2><span id='topic+logLik.pot'></span>

<h3>Description</h3>

<p>Extract Log-Likelihood for object of class <code>'pot'</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pot'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.pot_+3A_object">object</code></td>
<td>
<p>An object of class <code>'pot'</code>. Most often, this is an
object return by the <code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+fitbvgpd">fitbvgpd</a></code>
and <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> functions.</p>
</td></tr>
<tr><td><code id="logLik.pot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="stats.html#topic+logLik">logLik</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard <code>logLik</code> object: see <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(500, 0, 1, -0.15)
fmle &lt;- fitgpd(x, 0)
logLik(fmle)
</code></pre>

<hr>
<h2 id='mrlplot'>Threshold Selection: The Empirical Mean Residual Life Plot</h2><span id='topic+mrlplot'></span>

<h3>Description</h3>

<p>The empirical mean residual life plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrlplot(data, u.range, main, xlab, ylab, nt = max(100, length(data)),
lty = rep(1,3), col = c('grey', 'black', 'grey'), conf = 0.95, lwd = c(1,
1.5, 1), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrlplot_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_u.range">u.range</code></td>
<td>
<p>A numeric vector of length two, giving the limits for
the thresholds at which the mean residual life plot is
evaluated. If <code>u.range</code> is not given, sensible defaults
are used.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_xlab">xlab</code>, <code id="mrlplot_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the mean residual life
plot is evaluated.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_lty">lty</code>, <code id="mrlplot_+3A_col">col</code>, <code id="mrlplot_+3A_lwd">lwd</code></td>
<td>
<p>Arguments passed to <code>matplot</code>. The first
and last elements of <code>lty</code> correspond to the lower and
upper confidence limits respectively. Use zero to supress.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_conf">conf</code></td>
<td>
<p>The (pointwise) confidence coefficient for the
plotted confidence intervals.</p>
</td></tr> 
<tr><td><code id="mrlplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>matplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical mean residual life plot is the locus of points
</p>
<p style="text-align: center;"><code class="reqn">\left(u,\frac{1}{n_u} \sum\nolimits_{i=1}^{n_u}
    (x_{(i)} - u) \right)</code>
</p>

<p>where <code class="reqn">x_{(1)}, \dots, x_{(n_u)}</code> are
the <code class="reqn">n_u</code> observations that exceed the threshold <code class="reqn">u</code>.  If the
exceedances of a threshold <code class="reqn">u_0</code> are generalized Pareto, the
empirical mean residual life plot should be approximately linear for
<code class="reqn">u &gt; u_0</code>.
</p>
<p>The confidence intervals within the plot are symmetric intervals
based on the approximate normality of sample means.
</p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code> is invisibly returned.
The components contain those objects that were passed to the formal
arguments <code>x</code> and <code>y</code> of <code>matplot</code> in order to create
the mean residual life plot.
</p>


<h3>Author(s)</h3>

<p>Stuart Coles and Alec Stephenson</p>


<h3>References</h3>

<p>Coles, S. (2001) <em>An Introduction to Statistical
Modelling of Extreme Values</em>. Springer Series in Statistics. London.
</p>
<p>Embrechts, P., Kl\&quot;uppelberg, C., and Mikosch, T. (1997)
<em>Modelling Extremal Events for Insurance and Finance.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>,
<code><a href="#topic+tcplot">tcplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
flows &lt;- ardieres[, "obs"]
mrlplot(flows)
</code></pre>

<hr>
<h2 id='pickdep'>The Pickands' Dependence Function</h2><span id='topic+pickdep'></span>

<h3>Description</h3>

<p>Return and optionally plot the Pickands' dependence function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickdep(object, main, bound = TRUE, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickdep_+3A_object">object</code></td>
<td>
<p>A object of class <code>bvpot</code>. Usually, <code>object</code>
is the return of function <code><a href="#topic+fitbvgpd">fitbvgpd</a></code>.</p>
</td></tr>
<tr><td><code id="pickdep_+3A_main">main</code></td>
<td>
<p>May be missing. If present, the plot title.</p>
</td></tr>
<tr><td><code id="pickdep_+3A_bound">bound</code></td>
<td>
<p>Logical. Should the perfect dependent and independent
case bounds be plotted?</p>
</td></tr>
<tr><td><code id="pickdep_+3A_plot">plot</code></td>
<td>
<p>Logical. Should the dependence function be plotted?</p>
</td></tr>
<tr><td><code id="pickdep_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is common to parametrize a bivariate extreme value distribution
according to the Pickands' representation (Pickands, 1981). That is,
if <code class="reqn">G</code> is any bivariate extreme value distribution, then it has
the following parametrization:
</p>
<p style="text-align: center;"><code class="reqn">G\left(y_1,y_2\right) = \exp\left[- \left(\frac{1}{z_1} +
    \frac{1}{z_2} \right) A\left( \frac{z_2}{z_1+z_2} \right)
    \right]</code>
</p>

<p>where <code class="reqn">z_i</code> are unit Frechet.
</p>
<p><code class="reqn">A</code> is the Pickands' dependence function. It has the following
properties:
</p>

<ul>
<li> <p><code class="reqn">A</code> is defined on [0,1];
</p>
</li>
<li> <p><code class="reqn">A(0)=A(1)=1</code>;
</p>
</li>
<li> <p><code class="reqn">\max \left(w, 1-w \right) \leq A(w) \leq 1, \quad \forall
      w</code>;
</p>
</li>
<li> <p><code class="reqn">A</code> is a convex function;
</p>
</li>
<li><p> For two independent (unit Frechet) random variables, <code class="reqn">A(w)
      = 1, \quad \forall w</code>;
</p>
</li>
<li><p> For two perfectly dependent (unit Frechet) random variables,
<code class="reqn">A(w) = \max (w, 1-w)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The function returns an invisible function: the Pickands' dependence
function. Moreover, the returned object has an attribute which
specifies the model for the bivariate extreme value distribution.
</p>
<p>If <code>plot = TRUE</code>, then the dependence function is plotted.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Pickands, J. (1981) Multivariate Extreme Value Distributions
<em>Proceedings 43rd Session International Statistical Institute</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbvgpd(1000, alpha = 0.9, model = "mix", mar1 = c(0,1,0.25),
 mar2 = c(2,0.5,0.1))
Mmix &lt;- fitbvgpd(x, c(0,2), "mix")
pickdep(Mmix)
</code></pre>

<hr>
<h2 id='plot.bvpot'>Graphical Diagnostics: the Bivariate Extreme Value
Distribution Model.</h2><span id='topic+plot.bvpot'></span>

<h3>Description</h3>

<p>Plot several graphics to judge goodness of fit of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvpot'
plot(x, mains, which = 1:3, ask = nb.fig &lt; length(which)
&amp;&amp; dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bvpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bvpot"</code>. Most often, the object
returned by the <code><a href="#topic+fitbvgpd">fitbvgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_mains">mains</code></td>
<td>
<p>May be missing. If present a 3&ndash;vector of character
strings which gives the titles of the plots.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_which">which</code></td>
<td>
<p>a numeric vector which specifies which plot must be drawn
: <code>'1'</code> for Pickands' Dependence Function plot, <code>'2'</code> for
a bivariate return level plot, <code>'3'</code> for the spectral density
plot.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several plots.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitbvgpd">fitbvgpd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbvgpd(1000, alpha = 0.55, mar1 = c(0,1,0.25), mar2 = c(2,0.5,0.1))
Mlog &lt;- fitbvgpd(x, c(0, 2), "log")
layout(matrix(c(1,1,2,2,0,3,3,0), 2, byrow = TRUE))
plot(Mlog)
</code></pre>

<hr>
<h2 id='plot.mcpot'>Graphical Diagnostics: Markov Chains for All Exceedances.</h2><span id='topic+plot.mcpot'></span>

<h3>Description</h3>

<p>Plot several graphics to judge goodness of fit of the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpot'
plot(x, opy, exi, mains, which = 1:4, ask = nb.fig &lt;
length(which) &amp;&amp; dev.interactive(), acf.type = "partial", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bvpot"</code>. Most often, the object
returned by the <code><a href="#topic+fitbvgpd">fitbvgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_opy">opy</code></td>
<td>
<p>Numeric. The number of <b>O</b>bservation <b>P</b>er
<b>Y</b>ear (or more generally per block). If missing, the function
warns and set it to 365.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_exi">exi</code></td>
<td>
<p>Numeric. The extremal index value. If missing, the
estimator of Ferro and Segers (2003) is used.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_mains">mains</code></td>
<td>
<p>May be missing. If present a 4&ndash;vector of character
strings which gives the titles of the plots.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_which">which</code></td>
<td>
<p>a numeric vector which specifies which plot must be
drawn: <code>'1'</code> for the auto correlation plot, <code>'2'</code> for
Pickands' Dependence Function plot, <code>'3'</code> for the spectral
density plot and <code>'4'</code> for a bivariate return level plot.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_acf.type">acf.type</code></td>
<td>
<p>The type of auto correlation to be plotted. Must be
one of <code>"correlation"</code>, <code>"covariance"</code> or <code>"partial"</code>
(the default). See the <code><a href="stats.html#topic+acf">acf</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.mcpot_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Several plots and returns invisibly the return level function.
</p>


<h3>Warning</h3>

<p>See the warning for the return level estimation in documentation of
the <code><a href="#topic+retlev.mcpot">retlev.mcpot</a></code> function.
</p>


<h3>Note</h3>

<p>For the return level plot, the observations are not plotted as these
are dependent realisations. In particular, the return periods computed
using the <code><a href="#topic+prob2rp">prob2rp</a></code> are inaccurate.  
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ferro, C. and Segers, J. (2003). Inference for clusters of extreme
values. Journal of the Royal Statistical Society B. <b>65</b>:
545&ndash;556.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmcgpd">fitmcgpd</a></code>, <code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="#topic+retlev">retlev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
mc &lt;- simmc(200, alpha = 0.5)
mc &lt;- qgpd(mc, 0, 1, 0.25)
Mclog &lt;- fitmcgpd(mc, 1)
par(mfrow=c(2,2))
rlMclog &lt;- plot(Mclog)
rlMclog(T = 3)
</code></pre>

<hr>
<h2 id='plot.uvpot'>Graphical Diagnostic: the Univariate GPD Model</h2><span id='topic+plot.uvpot'></span>

<h3>Description</h3>

<p>Produces QQ-plot, Probability Plot and a Density Plot of
the fitted model versus the empirical one.  Another function computes
the Return Level Plot of the fitted model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uvpot'
plot(x, npy, main, which = 1:4, ask = nb.fig &lt;
length(which) &amp;&amp; dev.interactive(),ci = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uvpot_+3A_x">x</code></td>
<td>
<p>A fitted object of class <code>'uvpot'</code>. Generally, an object
return by <code>fitgpd</code></p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_npy">npy</code></td>
<td>
<p>The mean <b>N</b>umber of events <b>P</b>er <b>Y</b>ear - or
more generally a block.</p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_main">main</code></td>
<td>
<p>optional. A string vector corresponding to the title of
each plot.</p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_which">which</code></td>
<td>
<p>a numeric vector which specifies which plot must be drawn
: <code>'1'</code> for Probability Plot, <code>'2'</code> for QQ-Plot,<code>'3'</code>
for Density Plot and <code>'4'</code> for a Return Level Plot.</p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>TRUE</code>, user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the simulated 95% confidence
interval is plotted.</p>
</td></tr>
<tr><td><code id="plot.uvpot_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
fgpd &lt;- fitgpd(ardieres[, "obs"], 6, 'mle')
npy &lt;- fgpd$nat / 33.4 ##33.4 is the total record length (in year)
par(mfrow=c(2,2))
plot(fgpd, npy = npy)
</code></pre>

<hr>
<h2 id='pp'>Probability Probability Plot</h2><span id='topic+pp'></span><span id='topic+pp.uvpot'></span>

<h3>Description</h3>

<p><code>pp</code> is a generic function used to show probability-probability plot. 
The function invokes particular <code>methods</code> 
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
So the function makes a probability probability plot for univariate POT models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp(object, ...)

## S3 method for class 'uvpot'
pp(object, main, xlab, ylab, ci = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_+3A_object">object</code></td>
<td>
<p>A fitted object. When using the POT package, an object 
of class <code>'uvpot'</code>. Most often, the
return of the <code><a href="#topic+fitgpd">fitgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="pp_+3A_main">main</code></td>
<td>
<p>The title of the graphic. If missing, the title is set to
<code>"Probability plot"</code>.</p>
</td></tr>
<tr><td><code id="pp_+3A_xlab">xlab</code>, <code id="pp_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the x and y axis. If missing, they are
set to <code>"Empirical"</code> and <code>"Model"</code> respectively.</p>
</td></tr>
<tr><td><code id="pp_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), 95% intervals are
plotted.</p>
</td></tr>
<tr><td><code id="pp_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability probability plot consists of plotting the theoretical
probabilities in function of the empirical model ones. The theoretical
probabilities are computed from the fitted GPD, while the empirical
ones are computing from a particular plotting position estimator. This
plotting position estimator is suited for the GPD case (Hosking,
1995) and are defined by:
</p>
<p style="text-align: center;"><code class="reqn">p_{j:n} = \frac{j - 0.35}{n}</code>
</p>

<p>where <code class="reqn">n</code> is the total number of observations.
</p>
<p>If the theoretical model is correct, then points should be &ldquo;near&rdquo;
the line <code class="reqn">y=x</code>.
</p>


<h3>Value</h3>

<p>A graphical window.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Hosking, J. R. M. and Wallis, J. R. (1995). A comparison of unbiased
and plotting-position estimators of L moments. Water Resources
Research. <b>31</b>(8): 2019&ndash;2025.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qq">qq</a></code>, <code><a href="#topic+qq.uvpot">qq.uvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(75, 1, 2, 0.1)
pwmb &lt;- fitgpd(x, 1, "pwmb")
pp(pwmb)
</code></pre>

<hr>
<h2 id='print.bvpot'>Printing bvpot objects</h2><span id='topic+print.bvpot'></span>

<h3>Description</h3>

<p>Print a &ldquo;bvpot&rdquo; object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvpot'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bvpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>'bvpot'</code>. Most often, returns of the
<code><a href="#topic+fitbvgpd">fitbvgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="print.bvpot_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.bvpot_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="base.html#topic+print">print</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print on screen.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.uvpot">print.uvpot</a></code>, <code><a href="#topic+print.mcpot">print.mcpot</a></code>,
<code><a href="base.html#topic+print">print</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rgpd(500, 0, 1, 0.2)
y &lt;- rgpd(500, 2, 0.5, -0.1)
Mlog &lt;- fitbvgpd(cbind(x, y), c(0, 2))
Mlog
</code></pre>

<hr>
<h2 id='print.mcpot'>Printing mcpot objects</h2><span id='topic+print.mcpot'></span>

<h3>Description</h3>

<p>Print an &ldquo;mcpot&rdquo; object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcpot'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>'mcpot'</code>. Most often, returns of the
<code><a href="#topic+fitmcgpd">fitmcgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="print.mcpot_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.mcpot_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="base.html#topic+print">print</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print on screen.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.uvpot">print.uvpot</a></code>, <code><a href="#topic+print.bvpot">print.bvpot</a></code>,
<code><a href="base.html#topic+print">print</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- simmc(1000, alpha = 0.5)
x &lt;- qgpd(x, 0, 1, 0.15)
Mc &lt;- fitmcgpd(x, 0)
Mc
</code></pre>

<hr>
<h2 id='print.uvpot'>Printing uvpot objects</h2><span id='topic+print.uvpot'></span>

<h3>Description</h3>

<p>Print an &ldquo;uvpot&rdquo; object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uvpot'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.uvpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>'uvpot'</code>. Most often, returns of the
<code><a href="#topic+fitgpd">fitgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="print.uvpot_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.uvpot_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="base.html#topic+print">print</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print on screen.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.bvpot">print.bvpot</a></code>, <code><a href="#topic+print.mcpot">print.mcpot</a></code>,
<code><a href="base.html#topic+print">print</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(500, 0, 1, 0.2)
MLE &lt;- fitgpd(x, 0)
MLE
</code></pre>

<hr>
<h2 id='Profiled+20Confidence+20Intervals'>Profiled Confidence interval for the GP Distribution</h2><span id='topic+gpd.pfshape'></span><span id='topic+gpd.pfscale'></span><span id='topic+gpd.pfrl'></span>

<h3>Description</h3>

<p>Compute profiled confidence intervals on parameter and
return level for the GP distribution.  This is achieved through the
profile likelihood procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.pfshape(object, range, xlab, ylab, conf = 0.95, nrang = 100,
vert.lines = TRUE, ...)
gpd.pfscale(object, range, xlab, ylab, conf = 0.95, nrang = 100,
vert.lines = TRUE, ...)
gpd.pfrl(object, prob, range, thresh, xlab, ylab, conf = 0.95, nrang =
100, vert.lines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_object">object</code></td>
<td>
<p><code>R</code> object given by function <code><a href="#topic+fitgpd">fitgpd</a></code>.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_prob">prob</code></td>
<td>
<p>The probability of non exceedance.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_range">range</code></td>
<td>
<p>Vector of dimension two. It gives the lower and upper
bound on which the profile likelihood is performed.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_thresh">thresh</code></td>
<td>
<p>Optional. The threshold. Only needed with non constant
threshold.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_xlab">xlab</code>, <code id="Profiled+2B20Confidence+2B20Intervals_+3A_ylab">ylab</code></td>
<td>
<p>Optional Strings. Allows to label the x-axis and
y-axis. If missing, default value are considered.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_conf">conf</code></td>
<td>
<p>Numeric. The confidence level.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_nrang">nrang</code></td>
<td>
<p>Numeric. It specifies the number of profile likelihood
computed on the whole range <code>range</code>.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_vert.lines">vert.lines</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), vertical
lines are plotted.</p>
</td></tr>
<tr><td><code id="Profiled+2B20Confidence+2B20Intervals_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the
<code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns a vector of the lower and upper bound for the profile confidence
interval.  Moreover, a graphic of the profile likelihood function is
displayed.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Coles, S. (2001). <em>An Introduction to Statistical
Modelling of Extreme Values</em>. Springer Series in Statistics. London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.fiscale">gpd.fiscale</a></code>, <code><a href="#topic+gpd.fishape">gpd.fishape</a></code>,
<code><a href="#topic+gpd.firl">gpd.firl</a></code> and <code><a href="stats.html#topic+confint">confint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
events &lt;- clust(ardieres, u = 4, tim.cond = 8 / 365,
clust.max = TRUE)
MLE &lt;- fitgpd(events[, "obs"], 4, 'mle')
gpd.pfshape(MLE, c(0, 0.8))
rp2prob(10, 2)
gpd.pfrl(MLE, 0.95, c(12, 25))
</code></pre>

<hr>
<h2 id='qq'>Quantile Quantile Plot</h2><span id='topic+qq'></span><span id='topic+qq.uvpot'></span>

<h3>Description</h3>

<p><code>qq</code> is a generic function used to show quantile-quantile plot. 
The function invokes particular <code>methods</code> 
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
So the function makes a quantile quantile plot for univariate POT models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq(object, ...)

## S3 method for class 'uvpot'
qq(object, main, xlab, ylab, ci = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_+3A_object">object</code></td>
<td>
<p>A fitted object. When using the POT package, an object 
of class <code>'uvpot'</code>. Most often, the
return of the <code><a href="#topic+fitgpd">fitgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="qq_+3A_main">main</code></td>
<td>
<p>The title of the graphic. If missing, the title is set to
<code>"QQ-plot"</code>.</p>
</td></tr>
<tr><td><code id="qq_+3A_xlab">xlab</code>, <code id="qq_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the x and y axis. If missing, they are
set to <code>"Model"</code> and <code>"Empirical"</code> respectively.</p>
</td></tr>
<tr><td><code id="qq_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), 95% intervals are
plotted.</p>
</td></tr>
<tr><td><code id="qq_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantile quantile plot consists of plotting the observed quantiles
in function of the theoretical ones. The theoretical quantiles
<code class="reqn">Q_{Theo, j}</code> are computed from the fitted GPD, that
is:
</p>
<p style="text-align: center;"><code class="reqn">Q_{Theo, j} = F^{-1}(p_j)</code>
</p>

<p>where <code class="reqn">F^{-1}</code> is the fitted quantile function and
<code class="reqn">p_j</code> are empirical probabilities defined by :
</p>
<p style="text-align: center;"><code class="reqn">p_{j:n} = \frac{j - 0.35}{n}</code>
</p>

<p>where <code class="reqn">n</code> is the total number of observations - see Hosking
(1995).
</p>
<p>If the theoretical model is correct, then points should be &ldquo;near&rdquo;
the line <code class="reqn">y=x</code>.
</p>


<h3>Value</h3>

<p>A graphical window.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Hosking, J. R. M. and Wallis, J. R. (1995). A comparison of unbiased
and plotting-position estimators of L moments. Water Resources
Research. <b>31</b>(8): 2019&ndash;2025.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qq">qq</a></code>, <code><a href="#topic+qq.uvpot">qq.uvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgpd(75, 1, 2, 0.1)
pwmu &lt;- fitgpd(x, 1, "pwmu")
qq(pwmu)
</code></pre>

<hr>
<h2 id='retlev'>Return Level Plot</h2><span id='topic+retlev'></span><span id='topic+retlev.mcpot'></span><span id='topic+retlev.uvpot'></span>

<h3>Description</h3>

<p><code>retlev</code> is a generic function used to show return level plot. 
The function invokes particular <code>methods</code> 
which depend on the <code><a href="base.html#topic+class">class</a></code> of the first argument.
So the function makes a return level plot for POT models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retlev(object, ...)

## S3 method for class 'uvpot'
retlev(object, npy, main, xlab, ylab, xlimsup,
ci = TRUE, points = TRUE, ...)
## S3 method for class 'mcpot'
retlev(object, opy, exi, main, xlab, ylab, xlimsup,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retlev_+3A_object">object</code></td>
<td>
<p>A fitted object. When using the POT package, an object 
of class <code>'uvpot'</code> or <code>'mcpot'</code>. Most often, the
return of  <code><a href="#topic+fitgpd">fitgpd</a></code> or <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> functions.</p>
</td></tr>
<tr><td><code id="retlev_+3A_npy">npy</code></td>
<td>
<p>The mean <b>N</b>umber of events <b>P</b>er <b>Y</b>ear (or
more generally per block).if missing, setting it to 1.</p>
</td></tr>
<tr><td><code id="retlev_+3A_main">main</code></td>
<td>
<p>The title of the graphic. If missing, the title is set to
<code>"Return Level Plot"</code>.</p>
</td></tr>
<tr><td><code id="retlev_+3A_xlab">xlab</code>, <code id="retlev_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the x and y axis. If missing, they are
set to <code>"Return Period (Years)"</code> and <code>"Return Level"</code> respectively.</p>
</td></tr>
<tr><td><code id="retlev_+3A_xlimsup">xlimsup</code></td>
<td>
<p>Numeric. The right limit for the x-axis. If missing, a
suited value is computed.</p>
</td></tr>
<tr><td><code id="retlev_+3A_ci">ci</code></td>
<td>
<p>Logical. Should the 95% pointwise confidence interval be
plotted?</p>
</td></tr>
<tr><td><code id="retlev_+3A_points">points</code></td>
<td>
<p>Logical. Should observations be plotted?</p>
</td></tr>
<tr><td><code id="retlev_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
<tr><td><code id="retlev_+3A_opy">opy</code></td>
<td>
<p>The number of <b>O</b>bservations <b>P</b>er <b>Y</b>ear (or
more generally per block). If missing, it is set it to 365 i.e. daily
values with a warning.</p>
</td></tr>
<tr><td><code id="retlev_+3A_exi">exi</code></td>
<td>
<p>Numeric. The extremal index. If missing, an estimate is
given using the <code><a href="#topic+fitexi">fitexi</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For class <code>"uvpot"</code>, the return level plot consists of plotting the theoretical quantiles
in function of the return period (with a logarithmic scale for the
x-axis). For the definition of the return period see the
<code><a href="#topic+prob2rp">prob2rp</a></code> function. Thus, the return level plot consists
of plotting the points defined by:
</p>
<p style="text-align: center;"><code class="reqn">(T(p), F^{-1}(p))</code>
</p>

<p>where <code class="reqn">T(p)</code> is the return period related to the non
exceedance probability <code class="reqn">p</code>, <code class="reqn">F^{-1}</code> is the
fitted quantile function.
</p>
<p>If <code>points = TRUE</code>, the probabilities <code class="reqn">p_j</code> related to
each observation are computed using the following plotting position
estimator proposed by Hosking (1995):
</p>
<p style="text-align: center;"><code class="reqn">p_j = \frac{j - 0.35}{n}</code>
</p>

<p>where <code class="reqn">n</code> is the total number of observations.
</p>
<p>If the theoretical model is correct, the points should be &ldquo;close&rdquo;
to the &ldquo;return level&rdquo; curve.
</p>
<p>For class <code>"mcpot"</code>, let <code class="reqn">X_1, \ldots,X_n</code> be the first <code class="reqn">n</code>
observations from a stationary sequence with marginal distribution
function <code class="reqn">F</code>. Thus, we can use the following (asymptotic)
approximation:
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[\max\left\{X_1,\ldots,X_n\right\} \leq x \right] =
    \left[ F(x) \right]^{n \theta}</code>
</p>

<p>where <code class="reqn">\theta</code> is the extremal index.
</p>
<p>Thus, to obtain the T-year return level, we equate this equation to
<code class="reqn">1 - 1/T</code> and solve for <code class="reqn">x</code>.  
</p>


<h3>Value</h3>

<p>A graphical window. In addition, it returns invisibly the return level
function.
</p>


<h3>Warning</h3>

<p>For class <code>"mcpot"</code>, though this is computationally expensive, we recommend to give the
extremal index estimate using the <code><a href="#topic+dexi">dexi</a></code> function. Indeed,
there is a severe bias when using the Ferro and Segers (2003)
estimator - as it is estimated using observation and not the Markov
chain model.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Hosking, J. R. M. and Wallis, J. R. (1995). A comparison of unbiased
and plotting-position estimators of L moments. Water Resources
Research. <b>31</b>(8): 2019&ndash;2025.
</p>
<p>Ferro, C. and Segers, J. (2003). Inference for clusters of extreme
values. Journal of the Royal Statistical Society B. <b>65</b>:
545&ndash;556.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob2rp">prob2rp</a></code>, <code><a href="#topic+fitexi">fitexi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#for uvpot class
x &lt;- rgpd(75, 1, 2, 0.1)
pwmu &lt;- fitgpd(x, 1, "pwmu")
rl.fun &lt;- retlev(pwmu)
rl.fun(100)

#for mcpot class
data(ardieres)
Mcalog &lt;- fitmcgpd(ardieres[,"obs"], 5, "alog")
retlev(Mcalog, opy = 990)
</code></pre>

<hr>
<h2 id='retlev.bvpot'>Return Level Plot: Bivariate Case</h2><span id='topic+retlev.bvpot'></span>

<h3>Description</h3>

<p>Plot return levels for a fitted bivariate extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvpot'
retlev(object, p = seq(0.75,0.95,0.05), main, n = 5000,
only.excess = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retlev.bvpot_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bvpot"</code>. Most often, the
return object of the <code><a href="#topic+fitbvgpd">fitbvgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="retlev.bvpot_+3A_p">p</code></td>
<td>
<p>A vector of probabilities for which return levels must be
drawn.</p>
</td></tr>
<tr><td><code id="retlev.bvpot_+3A_main">main</code></td>
<td>
<p>The title of the graphic window. May be missing.</p>
</td></tr>
<tr><td><code id="retlev.bvpot_+3A_n">n</code></td>
<td>
<p>The number (default: 5000) of points needed to draw return
levels lines.</p>
</td></tr>
<tr><td><code id="retlev.bvpot_+3A_only.excess">only.excess</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), all
observations are plotted, otherwise, only exceedances above at least
one of the two thresholds are plotted.</p>
</td></tr>
<tr><td><code id="retlev.bvpot_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any bivariate extreme value distribution has the Pickands'
representation form i.e.:
</p>
<p style="text-align: center;"><code class="reqn">G(y_1, y_2) = \exp\left[ - \left(\frac{1}{z_1} + \frac{1}{z_2}
    \right) A( w ) \right]</code>
</p>

<p>where <code class="reqn">z_i</code> corresponds to <code class="reqn">y_i</code> transformed to be
unit Frechet distributed and <code class="reqn">w = \frac{z_2}{z_1 + z_2}</code> which lies in <code class="reqn">[0,1]</code>.
</p>
<p>Thus, for a fixed probability <code class="reqn">p</code> and <code class="reqn">w</code>, we have the
corresponding <code class="reqn">z_1</code>, <code class="reqn">z_2</code> values:
</p>
<p style="text-align: center;"><code class="reqn">z_1 = - \frac{A(w)}{w \log(p)}</code>
</p>

<p style="text-align: center;"><code class="reqn">z_2 = \frac{z_1 w}{1 - w}</code>
</p>

<p>At last, the <code class="reqn">z_i</code> are transformed back to their original
scale.  
</p>


<h3>Value</h3>

<p>Plot return levels for a fitted bivariate extreme value
distribution. Moreover, an invisible list is return which gives the
points used to draw the current plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitbvgpd">fitbvgpd</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbvgpd(1000, alpha = 0.25, mar1 = c(0, 1, 0.25))
Mlog &lt;- fitbvgpd(x, c(0, 0), "log")
retlev(Mlog)
</code></pre>

<hr>
<h2 id='Return+20Periods+20Tools'>Converts Return Periods to Probability and Vice Versa</h2><span id='topic+rp2prob'></span><span id='topic+prob2rp'></span>

<h3>Description</h3>

<p>Compute return period from probability of non exceedance and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp2prob(retper, npy)
prob2rp(prob, npy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Return+2B20Periods+2B20Tools_+3A_retper">retper</code></td>
<td>
<p>The return period.</p>
</td></tr>
<tr><td><code id="Return+2B20Periods+2B20Tools_+3A_prob">prob</code></td>
<td>
<p>the probability of non exceedance.</p>
</td></tr>
<tr><td><code id="Return+2B20Periods+2B20Tools_+3A_npy">npy</code></td>
<td>
<p>The mean <b>N</b>umber of events <b>p</b>er <b>y</b>ear
(block).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return period is defined by:
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{1}{npy (1-p)}</code>
</p>

<p>where <code class="reqn">npy</code> is the mean number of events per year (block), <code class="reqn">p</code>
is the probability of non exceedance.
</p>


<h3>Value</h3>

<p>Returns a table with mean numbers of events per year, return periods
and probabilities of non exceedance associated.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>rp2prob(50, 1.8)
prob2rp(0.6, 2.2)
</code></pre>

<hr>
<h2 id='simmc'>Simulate Markov Chains With Extreme Value
Dependence Structures</h2><span id='topic+simmc'></span>

<h3>Description</h3>

<p>Simulation of first order Markov chains, such that each pair
of consecutive values has the dependence structure of one of
nine parametric bivariate extreme value distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simmc(n, alpha, model = "log", asCoef, asCoef1, asCoef2, margins =
"uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simmc_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="simmc_+3A_alpha">alpha</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, negative logistic, asymmetric negative logistic, mixed and
asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="simmc_+3A_ascoef">asCoef</code>, <code id="simmc_+3A_ascoef1">asCoef1</code>, <code id="simmc_+3A_ascoef2">asCoef2</code></td>
<td>
<p>The asymmetric coefficients for the
asymmetric logistic, asymmetric negative logistic and asymmetric
mixed models.</p>
</td></tr>
<tr><td><code id="simmc_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"nlog"</code>,
<code>"anlog"</code>, <code>"mix"</code> or <code>"amix"</code>, for the logistic, asymmetric logistic,
negative logistic, asymmetric negative logistic, mixed and asymmetric mixed
models respectively.</p>
</td></tr>
<tr><td><code id="simmc_+3A_margins">margins</code></td>
<td>
<p>The marginal distribution of each value; a
character string. Must be either <code>"uniform"</code> (the
default), <code>"rweibull"</code>, <code>"frechet"</code> or
<code>"gumbel"</code>, for the uniform, standard reversed Weibull,
standard Gumbel and standard Frechet distributions respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson (modified for the POT package by Mathieu
Ribatet)</p>


<h3>Examples</h3>

<pre><code class='language-R'>simmc(100, alpha = 0.1, model = "log")
simmc(100, alpha = 1.2, model = "nlog", margins = "gum")
</code></pre>

<hr>
<h2 id='simmcpot'>Simulate an Markov Chain with a Fixed Extreme Value Dependence
from a Fitted mcpot Object</h2><span id='topic+simmcpot'></span>

<h3>Description</h3>

<p>Simulate a synthetic Markov chain from a fitted <code>'mcpot'</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simmcpot(object, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simmcpot_+3A_object">object</code></td>
<td>
<p>An object of class <code>'mcpot'</code>; most often the returned
object of the <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="simmcpot_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the simulated
Markov chain is plotted.</p>
</td></tr>
<tr><td><code id="simmcpot_+3A_...">...</code></td>
<td>
<p>Other optional arguments to be passed to the
<code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulated Markov chain is computed as follows:
</p>

<ol>
<li><p> Simulate a Markov chain <code>prob</code> with uniform margins on
(0,1) and with the fixed extreme value dependence given by
<code>object</code>;
</p>
</li>
<li><p> For all <code>prob</code> such as <code class="reqn">prob \leq 1 - pat</code>, set <code class="reqn">mc = NA</code> (where <code>pat</code> is given by
<code>object$pat</code>);
</p>
</li>
<li><p> For all <code>prob</code> such as <code class="reqn">prob \geq 1 - pat</code>, set <code class="reqn">prob2 = \frac{prob - 1 + pat}{pat}</code>. Thus, <code>prob2</code> are uniformly distributed on
(0,1);
</p>
</li>
<li><p> For all <code>prob2</code>, set <code>mc = qgpd(prob2, thresh,
      scale, shape)</code>, where <code>thresh, scale, shape</code> are given by the
<code>object$threshold, object$param["scale"]</code> and
<code>object$param["shape"]</code> respectively.
</p>
</li></ol>



<h3>Value</h3>

<p>A Markov chain which has the same features as the fitted object. If
<code>plot = TRUE</code>, the Markov chain is plotted.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmcgpd">fitmcgpd</a></code>, <code><a href="#topic+simmc">simmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
flows &lt;- ardieres[,"obs"]

Mclog &lt;- fitmcgpd(flows, 5)
par(mfrow = c(1,2))
idx &lt;- which(flows &lt;= 5)
flows[idx] &lt;- NA
plot(flows, main = "Ardieres Data")
flowsSynth &lt;- simmcpot(Mclog, main = "Simulated Data")
</code></pre>

<hr>
<h2 id='specdens'>Spectral Density Plot</h2><span id='topic+specdens'></span>

<h3>Description</h3>

<p>Plot the spectral density for a bivariate extreme value distribution
or an extreme Markov chain model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specdens(object, main, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specdens_+3A_object">object</code></td>
<td>
<p>An object of class <code>'bvpot'</code> or
<code>'mcpot'</code>. Most often, the return object of the
<code><a href="#topic+fitbvgpd">fitbvgpd</a></code> or <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> function.</p>
</td></tr>
<tr><td><code id="specdens_+3A_main">main</code></td>
<td>
<p>The title of the graphic window. May be missing.</p>
</td></tr>
<tr><td><code id="specdens_+3A_plot">plot</code></td>
<td>
<p>Logical. Should the spectral density be plotted? The
default is to plot it.</p>
</td></tr>
<tr><td><code id="specdens_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any bivariate extreme value distribution has the following
representation:
</p>
<p style="text-align: center;"><code class="reqn">G(y_1, y_2) = \exp\left[ - \int_0^1 \max\left( \frac{q}{z_1},
    \frac{1-q}{z_2} \right) dH(q) \right]</code>
</p>

<p>where <code class="reqn">H</code> holds:
</p>
<p style="text-align: center;"><code class="reqn">\int_0^1 q dH(q) = \int_0^1 (1-q) dH(q) = 1</code>
</p>

<p><code class="reqn">H</code> is called the spectral measure with density
<code class="reqn">h</code>. Thus, <code class="reqn">h</code> is called the spectral density. In
addition, <code class="reqn">H</code> has a total mass of 2.
</p>
<p>For two independent random variables, the spectral measure consists of
two points of mass 1 at <code class="reqn">q =0,1</code>. For two perfect dependent
random variables, the spectral measure consists of a single point of
mass 2 at <code class="reqn">q=0.5</code>. 
</p>


<h3>Value</h3>

<p>Plot the spectral density for a fitted bivariate extreme value
distribution. Moreover, the spectral density is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+retlev.bvpot">retlev.bvpot</a></code>, <code><a href="#topic+pickdep">pickdep</a></code> and
<code><a href="#topic+plot.bvpot">plot.bvpot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow=c(1,2))
##Spectral density for a Markov Model
mc &lt;- simmc(1000, alpha = 0.25, model = "log")
mc &lt;- qgpd(mc, 0, 1, 0.1)
Mclog &lt;- fitmcgpd(mc, 0, "log")
specdens(Mclog)
##Spectral density for a bivariate POT model
x &lt;- rgpd(500, 5, 1, -0.1)
y &lt;- rgpd(500, 2, 0.2, -0.25)
Manlog &lt;- fitbvgpd(cbind(x,y), c(5,2), "anlog")
specdens(Manlog)
</code></pre>

<hr>
<h2 id='summary.pot'>Compactly display the structure</h2><span id='topic+summary.pot'></span>

<h3>Description</h3>

<p>Compactly display the structure of an object of class <code>'pot'</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pot'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pot_+3A_object">object</code></td>
<td>
<p>An object of class <code>'pot'</code>. Most often, this is an
object return by the <code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+fitbvgpd">fitbvgpd</a></code>
and <code><a href="#topic+fitmcgpd">fitmcgpd</a></code> functions.</p>
</td></tr>
<tr><td><code id="summary.pot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="utils.html#topic+str">str</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard <code>summary</code> object: see <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rgpd(500, 0, 1, -0.15)
fmle &lt;- fitgpd(x, 0)
summary(fmle)
</code></pre>

<hr>
<h2 id='tailind.test'>Testing for Tail Independence in Extreme Value Models</h2><span id='topic+tailind.test'></span>

<h3>Description</h3>

<p>Several tests for tail independence (e.g. asymptotic
independence) for a bivariate extreme value distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailind.test(data, c = -0.1, emp.trans = TRUE, chisq.n.class = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tailind.test_+3A_data">data</code></td>
<td>
<p>A matrix with two columns given the data.</p>
</td></tr>
<tr><td><code id="tailind.test_+3A_c">c</code></td>
<td>
<p>A negative numeric. Must be close to zero to approximate
accurately asymptotic results.</p>
</td></tr>
<tr><td><code id="tailind.test_+3A_emp.trans">emp.trans</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default),
<code>"data"</code> is transformed to reverse exponential using
empirical estimates. Otherwise, <code>"data"</code> is supposed to be
reverse exponential distributed.</p>
</td></tr>
<tr><td><code id="tailind.test_+3A_chisq.n.class">chisq.n.class</code></td>
<td>
<p>A numeric given the number of classes for the Chi
squared test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These tests are based on an asymptotic results shown by Falk and Michel
(2006). Let <code class="reqn">(X,Y)</code> be a random vector which follows in its
upper tail a bivariate extreme value distribution with reverse
exponential margins. The conditional distribution function of
<code class="reqn">X+Y</code>, given that <code class="reqn">X+Y&gt;c</code>, converges to
<code class="reqn">F(t)=t^2</code>, <code class="reqn">t \in[0,1]</code>, if <code class="reqn">c
    \rightarrow 0^{-}</code> iff <code class="reqn">X</code> and <code class="reqn">Y</code> are
asymptotically independent. Otherwise, the limit is <code class="reqn">F(t) =
    t</code>
</p>


<h3>Value</h3>

<p>This function returns a table with the Neymann-Pearson, Fisher,
Kolmogorov-Smirnov and Chi-Square statistics and the related
p-values.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Falk, M. and Michel, Rene(2006) Testing for tail independence in
extreme value models. <em>Annals of the Institute of Statistical
Mathematics</em> <b>58</b>: 261&ndash;290
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chimeas">chimeas</a></code>, <code><a href="#topic+specdens">specdens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##A total independence example
x &lt;- rbvgpd(7000, alpha = 1, mar1 = c(0, 1, 0.25))
tailind.test(x)

##An asymptotically dependent example
y &lt;- rbvgpd(7000, alpha = 0.75, model = "nlog", mar1 = c(0, 1, 0.25),
mar2 = c(2, 0.5, -0.15))
tailind.test(y)

##A perfect dependence example
z &lt;- rnorm(7000)
tailind.test(cbind(z, 2*z - 5))
</code></pre>

<hr>
<h2 id='tcplot'>Threshold Selection: The Threshold Choice Plot</h2><span id='topic+tcplot'></span>

<h3>Description</h3>

<p>Plots of parameter estimates at various thresholds for peaks
over threshold modelling, using the Generalized Pareto or Point
Process representation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplot(data, u.range, cmax = FALSE, r = 1,
    ulow = -Inf, rlow = 1, nt = 25, which = 1:npar, conf = 0.95,
    lty = 1, lwd = 1, type = "b", cilty = 1, ask = nb.fig &lt;
    length(which) &amp;&amp; dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplot_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_u.range">u.range</code></td>
<td>
<p>A numeric vector of length two, giving the limits for the
thresholds at which the model is fitted.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_cmax">cmax</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default), the models are
fitted using all exceedances over the thresholds. If <code>TRUE</code>,
the models are fitted using cluster maxima.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_r">r</code>, <code id="tcplot_+3A_ulow">ulow</code>, <code id="tcplot_+3A_rlow">rlow</code></td>
<td>
<p>Arguments used for the identification of clusters
of exceedances. Ignored if <code>cmax</code> is <code>FALSE</code> (the
default).</p>
</td></tr>
<tr><td><code id="tcplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the model is fitted.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a
subset of the numbers <code>1:npar</code>, where <code>npar</code> is
the number of parameters.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_conf">conf</code></td>
<td>
<p>The (pointwise) confidence coefficient for the
plotted confidence intervals. Use zero to suppress.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_lty">lty</code>, <code id="tcplot_+3A_lwd">lwd</code></td>
<td>
<p>The line type and width of the line connecting
the parameter estimates.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_type">type</code></td>
<td>
<p>The form taken by the line connecting the parameter
estimates and the points denoting these estimates. Possible
values include <code>"b"</code> (the default) for points joined by
lines, <code>"o"</code> for over plotted points and lines, and
<code>"l"</code> for an unbroken line with no points.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_cilty">cilty</code></td>
<td>
<p>The line type of the lines depicting the
confidence intervals.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the model fit
function <code>fitgpd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the <code>nt</code> thresholds a peaks over threshold model
is fitted using the function <code>fitgpd</code>.  The maximum likelihood
estimates for the shape and the modified scale parameter (modified by
subtracting the shape multiplied by the threshold) are plotted against
the thresholds.  If the threshold <code>u</code> is a valid threshold to be
used for peaks over threshold modelling, the parameter estimates
depicted should be approximately constant above <code>u</code>.
</p>


<h3>Value</h3>

<p>A list is invisibly returned.  Each component is a matrix with
three columns giving parameter estimates and confidence limits.
</p>


<h3>Author(s)</h3>

<p>Stuart Coles and Alec Stephenson</p>


<h3>References</h3>

<p>Coles, S. (2001) <em>An Introduction to Statistical
Modelling of Extreme Values</em>. Springer Series in Statistics. London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitgpd">fitgpd</a></code>, <code><a href="#topic+mrlplot">mrlplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
ardieres &lt;- clust(ardieres, 4, 10 / 365, clust.max = TRUE)
flows &lt;- ardieres[, "obs"]
par(mfrow=c(1,2))
tcplot(flows, u.range = c(0, 15) )
</code></pre>

<hr>
<h2 id='ts2tsd'>Mobile Window on a Time Series</h2><span id='topic+ts2tsd'></span>

<h3>Description</h3>

<p>This function performs a mobile average windows on the whole time
series. Thus, if the time series represents flood discharges, it
returns the averaged discharges over a specific duration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2tsd(ts, d, vol = FALSE, method = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts2tsd_+3A_ts">ts</code></td>
<td>
<p>The time series. It consists of two columns: one named
<code>"time"</code> and the second <code>"obs"</code>.</p>
</td></tr>
<tr><td><code id="ts2tsd_+3A_d">d</code></td>
<td>
<p>Numeric which corresponds of the duration for the mobile
window.</p>
</td></tr>
<tr><td><code id="ts2tsd_+3A_vol">vol</code></td>
<td>
<p>Logical. If <code>FALSE</code> -the default, average values are
computed, else volumes.</p>
</td></tr>
<tr><td><code id="ts2tsd_+3A_method">method</code></td>
<td>
<p>Specifies the interpolation method to be used.  Choices
are <code>"linear"</code> or <code>"constant"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mobile windows of length <code>d</code> is performed on the whole time
sire. The &ldquo;discrete&rdquo; time series in first transformed in a
function; interpolation are obtained using the <code><a href="stats.html#topic+approx">approx</a></code>
function. Thus, if f(t) is the function representing the time series,
volume over duration <code>d</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">vol(t) = \int_{t-d/2}^{t+d/2} f(u)du</code>
</p>

<p>while average values are:
</p>
<p style="text-align: center;"><code class="reqn">ave(t) = \frac{1}{d}\int_{t-d/2}^{t+d/2} f(u)du</code>
</p>



<h3>Value</h3>

<p>Returns a time series like object <code>ts</code>. In particular
<code>ts[,"time"]</code> and <code>tsd[,"time"]</code> are identical.
</p>


<h3>Warnings</h3>

<p>Please note that as the time series is interpolated, caution should be
taken if the method to interpolate is not efficient. 
</p>
<p>Note that object <code>d</code> should have the same unit than
<code>ts[,"time"]</code>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approx">approx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ardieres)
tsd &lt;- ts2tsd(ardieres, 3 / 365)
plot(ardieres, type = "l", col = "blue")
lines(tsd, col = "green")
</code></pre>

<hr>
<h2 id='tsdep.plot'>Diagnostic for Dependence within Time Series Extremes</h2><span id='topic+tsdep.plot'></span>

<h3>Description</h3>

<p>A diagnostic tool to assess for short range asymptotic dependence
within a stationary time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsdep.plot(data, u, ..., xlab, ylab, n.boot = 100, show.lines = TRUE,
lag.max, ci = 0.95, block.size = 5 * lag.max, angle = 90, arrow.length =
0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsdep.plot_+3A_data">data</code></td>
<td>
<p>The time series observations.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_u">u</code></td>
<td>
<p>The threshold.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="base.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_xlab">xlab</code>, <code id="tsdep.plot_+3A_ylab">ylab</code></td>
<td>
<p>The x and y-axis labels.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_n.boot">n.boot</code></td>
<td>
<p>Numeric. The number of replicates to compute the
bootstrap confidence interval.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_show.lines">show.lines</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the
theoretical lines for the asymptotic dependence and &ldquo;near&rdquo;
independence are drawn.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag to be explored - may be missing.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_ci">ci</code></td>
<td>
<p>The level for the bootstrap confidence interval. The default
is the 95% confidence interval.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_block.size">block.size</code></td>
<td>
<p>The size for the contiguous bootstrap approach.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_angle">angle</code></td>
<td>
<p>The angle at the end of the error bar. If <code>0</code>, error
bars are only segments.</p>
</td></tr>
<tr><td><code id="tsdep.plot_+3A_arrow.length">arrow.length</code></td>
<td>
<p>The length to be passed in the function
<code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Let <code>X_t</code> be a stationary sequence of unit Frechet random
variables. By stationarity, the joint survivor function
<code class="reqn">\overline{F}_\tau(\cdot, \cdot)</code> of <code class="reqn">(X_t,
    X_{t+\tau})</code> does not depend on <code class="reqn">t</code>.
</p>
<p>One parametric representation for <code class="reqn">\overline{F}_\tau(\cdot,
    \cdot)</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\overline{F}_\tau(s,s)=L_\tau(s) s^{-1/\eta_\tau}</code>
</p>

<p>for some parameter <code class="reqn">\eta_\tau \in (0,1]</code> and a
slowly varying function <code class="reqn">L_\tau</code>.
</p>
<p>The <code class="reqn">\Lambda_\tau</code> statistic is defined by
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_\tau = 2 \eta_\tau - 1</code>
</p>

<p>This statistic belongs to (-1,1] and is a measure of extremal
dependence. <code class="reqn">\Lambda_\tau = 1</code> corresponds to
asymptotic dependence, <code class="reqn">0 &lt; \Lambda_\tau &lt; 1</code>
to positive extremal association, <code class="reqn">\Lambda_\tau = 0</code> to &ldquo;near&rdquo; independence and <code class="reqn">\Lambda_\tau &lt; 0</code> to negative extremal association.
</p>


<h3>Value</h3>

<p>This function plot the <code class="reqn">\Lambda_\tau</code> statictics
against the lag. Bootstrap confidence intervals are also drawn. The
function returns invisibly this statistic and the confidence bounds.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ledford, A. and Tawn, J. (2003) Diagnostics for dependence within time
series extremes. <em>L. R. Statist. Soc. B.</em> <b>65</b>, Part 2,
521&ndash;543.
</p>
<p>Ledford, A. and Tawn, J (1996) Statistics for near independence in
multivariate extreme values. <em>Biometrika</em> <b>83</b> 169&ndash;187.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chimeas">chimeas</a></code>, <code><a href="#topic+tailind.test">tailind.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##An independent case
tsdep.plot(runif(5000), u = 0.95, lag.max = 5)

##Asymptotic dependence
mc &lt;- simmc(5000, alpha = 0.2)
tsdep.plot(mc, u = 0.95, lag.max = 5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
