<!DOCTYPE html><html><head><title>Help for package cartogramR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cartogramR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.sf'><p>Coerce an object to a sf object</p></a></li>
<li><a href='#as.sf.cartogramR'><p>Coerce a cartogramR to a sf object</p></a></li>
<li><a href='#as.sfc'><p>Coerce an object to a sfc object</p></a></li>
<li><a href='#as.sfc.cartogramR'><p>Coerce a cartogramR to a sfc object</p></a></li>
<li><a href='#as.sfmultipolygon'><p>Transform a sf object with several rows (polygons) by region to an</p>
sf object with one row by region and thus one multipolygon by region</a></li>
<li><a href='#cartogramR'><p>Make a continuous cartogram (density equalizing maps)</p></a></li>
<li><a href='#cartogramR_options'><p>Set the options of cartogramR in the correct format</p></a></li>
<li><a href='#check_ring_dir'><p>Polygon rings directions are checked and corrected if asked.</p></a></li>
<li><a href='#dist_between_vertices'><p>Analyse some of the grid options</p></a></li>
<li><a href='#france_dept'><p>Map of the population of mainland France (year 2018)</p></a></li>
<li><a href='#france_rivers'><p>Map of french rivers  of mainland France</p></a></li>
<li><a href='#from_coord_polygon'><p>Transform from coordinates system used in the polygons to coordinates</p>
system used in flow based cartogram</a></li>
<li><a href='#geom_cartogramR'><p>Apply the deformation used to build a cartogram to a set of</p>
simple geometry  coordinates</a></li>
<li><a href='#grid_analysis'><p>Analyse some of the grid options</p></a></li>
<li><a href='#make_layer'><p>Make a layer</p></a></li>
<li><a href='#plot.cartogramR'><p>Plot a cartogram object</p></a></li>
<li><a href='#plot.dbv.cartogramR'><p>Plot a dbv.cartogram object</p></a></li>
<li><a href='#plot.gridanalysis.cartogramR'><p>Plot a gridanalysis.cartogram object</p></a></li>
<li><a href='#precartogramR'><p>Make a pre cartogram analysis</p></a></li>
<li><a href='#print.cartogramR'><p>Print a cartogram object</p></a></li>
<li><a href='#print.summary.cartogramR'><p>Print a summary of a cartogram object</p></a></li>
<li><a href='#residuals.cartogramR'><p>Errors of a cartogram object</p></a></li>
<li><a href='#summary.cartogramR'><p>Summary of a cartogram object</p></a></li>
<li><a href='#summary.dbv.cartogramR'><p>Summary of a dbv.cartogram object</p></a></li>
<li><a href='#summary.gridanalysis.cartogramR'><p>Summary of a gridanalysis.cartogram object</p></a></li>
<li><a href='#to_coord_polygon'><p>Transform from coordinates system used in flow based cartogram to coordinates</p>
system used in the polygons</a></li>
<li><a href='#usa'><p>Map of the number of electors in each state of the USA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous Cartogram</td>
</tr>
<tr>
<td>Description:</td>
<td>Procedures for making continuous cartogram. Procedures available are:
     flow based cartogram (Gastner &amp; Newman (2004) &lt;<a href="https://doi.org/10.1073%2Fpnas.0400280101">doi:10.1073/pnas.0400280101</a>&gt;),
     fast flow based cartogram (Gastner, Seguy &amp; More (2018) &lt;<a href="https://doi.org/10.1073%2Fpnas.1712674115">doi:10.1073/pnas.1712674115</a>&gt;),
     rubber band based cartogram (Dougenik et al. (1985)
                        &lt;<a href="https://doi.org/10.1111%2Fj.0033-0124.1985.00075.x">doi:10.1111/j.0033-0124.1985.00075.x</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lwgeom</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>FFTW (&gt;=3.3.1); possible package: fftw-devel (rpm),
libfftw3-dev (deb) or fftw (brew).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 10:53:17 UTC; pac</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre-Andre Cornillon [aut, cre],
  Florent Demoraes [aut],
  Flow-Based-Cartograms [cph] (Author of core C code for gsm and gn
    procedures)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre-Andre Cornillon &lt;pierre-andre.cornillon@univ-rennes2.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 00:30:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.sf'>Coerce an object to a sf object</h2><span id='topic+as.sf'></span>

<h3>Description</h3>

<p>Coerce an object to a sf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sf_+3A_x">x</code></td>
<td>
<p>object to be coerced</p>
</td></tr>
<tr><td><code id="as.sf_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf object
</p>

<hr>
<h2 id='as.sf.cartogramR'>Coerce a cartogramR to a sf object</h2><span id='topic+as.sf.cartogramR'></span>

<h3>Description</h3>

<p>Coerce a cartogramR to a sf object returning the sf object used to
construct the cartogram with the cartogram as geometry and some
more attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
as.sf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sf.cartogramR_+3A_x">x</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="as.sf.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sf object including all the data (attributes) contained
in the original sf object used to construct the cartogram and
</p>

<ul>
<li><p> original areas of region (<code>orig_area</code>)
</p>
</li>
<li><p> final/deformed areas of region (<code>final_area</code>)
</p>
</li>
<li><p> target areas of region (<code>target_area</code>)
</p>
</li>
<li><p> original centers (<code>x_orig_centers</code> and <code>y_orig_centers</code>)
</p>
</li>
<li><p> final centers (<code>x_final_centers</code> and <code>y_final_centers</code>)
</p>
</li></ul>


<hr>
<h2 id='as.sfc'>Coerce an object to a sfc object</h2><span id='topic+as.sfc'></span>

<h3>Description</h3>

<p>Coerce an object to a sfc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sfc_+3A_x">x</code></td>
<td>
<p>object to be coerced</p>
</td></tr>
<tr><td><code id="as.sfc_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sfc object
</p>

<hr>
<h2 id='as.sfc.cartogramR'>Coerce a cartogramR to a sfc object</h2><span id='topic+as.sfc.cartogramR'></span>

<h3>Description</h3>

<p>Coerce a cartogramR to a  sfc object extracting the component cartogram of
the cartogramR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
as.sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sfc.cartogramR_+3A_x">x</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="as.sfc.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sfc object
</p>

<hr>
<h2 id='as.sfmultipolygon'>Transform a sf object with several rows (polygons) by region to an
sf object with one row by region and thus one multipolygon by region</h2><span id='topic+as.sfmultipolygon'></span>

<h3>Description</h3>

<p>Transform a sf object with several rows (polygons) by region to an
sf object with one row by region and thus one multipolygon by region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sfmultipolygon(data, idregion, closepolygon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sfmultipolygon_+3A_data">data</code></td>
<td>
<p>a sf object</p>
</td></tr>
<tr><td><code id="as.sfmultipolygon_+3A_idregion">idregion</code></td>
<td>
<p>a character string which indicates the name of the
column (in <code>data</code> object) which contains the region
identifier.</p>
</td></tr>
<tr><td><code id="as.sfmultipolygon_+3A_closepolygon">closepolygon</code></td>
<td>
<p>a boolean (default to <code>FALSE</code>) if <code>TRUE</code> it
controls if polygons are closed and if not add the first
vertice at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sf object with one row by region and one multipolygon by
region.
</p>

<hr>
<h2 id='cartogramR'>Make a continuous cartogram (density equalizing maps)</h2><span id='topic+cartogramR'></span>

<h3>Description</h3>

<p>Make a continuous cartogram (density equalizing maps)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartogramR(
  data,
  count,
  method = c("gsm", "gn", "dcn", "GastnerSeguyMore", "GastnerNewman",
    "DougenikChrismanNiemeyer"),
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cartogramR_+3A_data">data</code></td>
<td>
<p>a sf object which contains at least two columns:
obviously a geometry column (giving the map) and a column which
contains a count by region (leading to a density by region,
density to be equalized by deformation). Each row of <code>data</code> is a region and
contains the simple feature geometry of type <code>POLYGON</code> or
<code>MULTIPOLYGON</code>. Polygon ring directions are not checked but
exterior ring must counter clockwise and holes clockwise (use
option <code>check_ring_dir</code> of <a href="sf.html#topic+st_read">sf::st_read</a> to achieve the right
orientation of ring direction on import or use <a href="#topic+check_ring_dir">check_ring_dir</a>
function)</p>
</td></tr>
<tr><td><code id="cartogramR_+3A_count">count</code></td>
<td>
<p>a character string which indicates the name of the
column (in <code>data</code> object) which contains the count by
region.</p>
</td></tr>
<tr><td><code id="cartogramR_+3A_method">method</code></td>
<td>
<p>the method to be used, can be one of the following:
<code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code>, <code>dcn</code> or <code>DougenikChrismanNiemeyer</code>.</p>
</td></tr>
<tr><td><code id="cartogramR_+3A_options">options</code></td>
<td>
<p>a named list given to <a href="#topic+cartogramR_options">cartogramR_options</a> function
which process options see <a href="#topic+cartogramR_options">cartogramR_options</a> for
details. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li><p> cartogram: a sf object (in the same order of <code>data</code> or sorted by <code>idregion</code>
see reordered argument) which contains the cartogram
(ie the initial polygons after deformation)
</p>
</li>
<li><p> orig_area: original areas of regions
</p>
</li>
<li><p> final_area: final areas of regions in the cartogram
</p>
</li>
<li><p> orig_centers: the initial centers calculated with <a href="sf.html#topic+st_point_on_surface">st_point_on_surface</a>
</p>
</li>
<li><p> final_centers: the centers after deformation
</p>
</li>
<li><p> gridx: (for flow-based method) final grid (x-axis) if requested
(see <a href="#topic+cartogramR_options">cartogramR_options</a> for details).
</p>
</li>
<li><p> gridy: (for flow-based method) final grid (y-axis) if requested
(see <a href="#topic+cartogramR_options">cartogramR_options</a> for details).
</p>
</li>
<li><p> count: the count by region
</p>
</li>
<li><p> target_area: target areas of regions
</p>
</li>
<li><p> initial_data: the initial sf object
</p>
</li>
<li><p> details: names of original data, idcount variable, algorithm
</p>
</li>
<li><p> options: values of options
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Dougenik, J., Chrisman, R. &amp;  Niemeyer, D. (1985).
An algorithm to construct continuous area cartograms.
Professional Geographer <strong>37</strong>: 75-81.
</p>
</li>
<li><p> Gastner, M. &amp; Newman, M.E.J. (2004). Diffusion-based
method for producing density equalizing
maps. <em>Proc. Natl. Acad. Sci. USA</em>, <strong>101</strong>:7499-7504
</p>
</li>
<li><p> Gastner, M., Seguy, V. &amp; More, P. (2018). Fast flow-based
algorithm for creating density-equalizing map
projections. <em>Proceedings of the National Academy of Sciences
USA</em>, <strong>115</strong>:E2156-E2164, website:
<a href="https://go-cart.io/">go-cart</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  plot(carto)
  summary(carto)


</code></pre>

<hr>
<h2 id='cartogramR_options'>Set the options of <a href="#topic+cartogramR">cartogramR</a> in the correct format</h2><span id='topic+cartogramR_options'></span>

<h3>Description</h3>

<p>Set the options of <a href="#topic+cartogramR">cartogramR</a> in the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartogramR_options(
  options,
  method = c("gsm", "gn", "dcn", "GastnerSeguyMore", "GastnerNewman",
    "DougenikChrismanNiemeyer")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cartogramR_options_+3A_options">options</code></td>
<td>
<p>a named list with some (or all) the following components:
</p>

<ul>
<li><p> maxit:  (all method) the maximum number of iterations,
default to 50.
</p>
</li>
<li><p> absrel:  (all method)  boolean, if <code>TRUE</code> relative convergence
stopping criterion is used ; if <code>FALSE</code> absolute convergence
stopping criterion is used
(default to <code>TRUE</code>)
</p>
</li>
<li><p> abserror: (all method) Areas on cartogram differ at most by an
(absolute value of) error of <code>abserror</code>. That is,
<code class="reqn">\max_{p} |\hat A_p - A_p|
  \leq  abserror</code>.
The max is over all polygons <code class="reqn">p</code>, <code class="reqn">hat A_p</code>
is the area calculated by the cartogram for polygon <code class="reqn">p</code>
and  <code class="reqn">A_p</code> is the objective area,
(default to 10000)
</p>
</li>
<li><p> abstol:  (<code>"dcn"</code>) the absolute convergence error tolerance:
<code class="reqn">\max_{p} | \hat A_p(i) -
  \hat A_p(i-1)| \leq abstol</code>,
the max over all polygons <code class="reqn">p</code> of the difference of area
calculated by the cartogram at
step <code class="reqn">i</code> and those at step <code class="reqn">i-1</code>,
(default to 1000)
</p>
</li>
<li><p> relerror: (all method) Areas on cartogram differ at most by an
(absolute value of) relative error of <code>relerror</code>. That is,
<code class="reqn">\max_{p} |\hat A_p / A_p - 1|
  \leq  relerror</code>.
The max is over all polygons <code class="reqn">p</code>, <code class="reqn">hat A_p</code> is
the area calculated by the cartogram for polygon <code class="reqn">p</code> and
<code class="reqn">A_p</code> is the objective area,
(default to 0.01)
</p>
</li>
<li><p> reltol:  (<code>"dcn"</code>) the relative convergence tolerance:
<code class="reqn">\max_{p} |\hat A_p(i) - \hat A_p(i-1)|/\hat A_p(i-1)
  \leq reltol</code>
(default to 1e-3)
</p>
</li>
<li><p> L: (<code style="white-space: pre;">&#8288;"gsm" or "gn"&#8288;</code>) integer, gives the value of <code>L</code> (default
is 512), must be a power of two (for fftw)
</p>
</li>
<li><p> mp: (all method) if a region contains exactly zero population, it will be
replaced by mp times the smallest (strictly) positive population in any
region (default to 0.2)
</p>
</li>
<li><p> pf: (<code style="white-space: pre;">&#8288;"gsm" or "gn"&#8288;</code>) Determines space between map and boundary (default to 1.5)
</p>
</li>
<li><p> sigma: (<code style="white-space: pre;">&#8288;"gsm" or "gn"&#8288;</code>) Width of Gaussian blur to smoothen the density (default to 5)
</p>
</li>
<li><p> center: (<code style="white-space: pre;">&#8288;"gsm" or "gn"&#8288;</code>) either a character string
(only possible choices are <code>"centroid"</code>
or <code>"point_on_surface"</code>) or a function. If the
object is a function, it  will be used to
calculate the &quot;center&quot; of polygons; <code>"point_on_surface"</code>
will use the function <a href="sf.html#topic+geos_unary">sf::st_point_on_surface</a>
while <code>"centroid"</code> (the default) will use <a href="sf.html#topic+geos_unary">sf::st_centroid</a>.
</p>
</li>
<li><p> verbose: (all method) integer giving the verbosity level
(default to <code>0</code>, not verbose)
</p>
</li>
<li><p> grid: (<code style="white-space: pre;">&#8288;"gsm" or "gn"&#8288;</code>) boolean, if <code>TRUE</code> export the final
grid from flow algorithm (default to <code>TRUE</code>). Setting to <code>FALSE</code>
</p>
</li>
<li><p> check.ring.dir: (all method) boolean, if <code>TRUE</code> controls polygons orientation
(default to <code>TRUE</code>)
</p>
</li>
<li><p> check.only: (all method) boolean, if <code>TRUE</code> control only polygons orientation
and no replacement is done (default to <code>FALSE</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="cartogramR_options_+3A_method">method</code></td>
<td>
<p>the method to be used, can be one of the following:
<code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code>, <code>dcn</code> or <code>DougenikChrismanNiemeyer</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list to be processed by <a href="#topic+cartogramR">cartogramR</a>
</p>


<h3>References</h3>


<ul>
<li><p> Dougenik, J., Chrisman, R. &amp;  Niemeyer, D. (1985).
An algorithm to construct continuous area cartograms.
Professional Geographer <strong>37</strong>: 75-81.
</p>
</li>
<li><p> Gastner, M. &amp; Newman, M. E. J. (2004). Diffusion-based
method for producing density equalizing
maps. <em>Proc. Natl. Acad. Sci. USA</em>, <strong>101</strong>:7499-7504
</p>
</li>
<li><p> Gastner, M., Seguy, V. &amp; More, P. (2018). Fast flow-based
algorithm for creating density-equalizing map
projections. <em>Proceedings of the National Academy of Sciences
USA</em>, <strong>115</strong>:E2156-E2164
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto1 &lt;- cartogramR(usa, "electors64", options=list(verbose=1, L=256))
  plot(carto1)


</code></pre>

<hr>
<h2 id='check_ring_dir'>Polygon rings directions are checked and corrected if asked.</h2><span id='topic+check_ring_dir'></span>

<h3>Description</h3>

<p>Polygon ring are seen from above: exterior ring counter clockwise,
holes clockwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ring_dir(polygons, check.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ring_dir_+3A_polygons">polygons</code></td>
<td>
<p>a sfc object which contains simple feature geometry of
types <code>POLYGON</code> or <code>MULTIPOLYGON</code></p>
</td></tr>
<tr><td><code id="check_ring_dir_+3A_check.only">check.only</code></td>
<td>
<p>a boolean which indicates if the function only
checks the ring direction (<code>check.only=TRUE</code>) or checks and
corrects the polygon direction (<code>check.only=FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a logical vector which indicates if line i of polygons
is in the right direction (<code>TRUE</code>) or not or the corrected sfc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(usa)
  all(check_ring_dir(sf::st_geometry(usa), check.only=TRUE))


</code></pre>

<hr>
<h2 id='dist_between_vertices'>Analyse some of the grid options</h2><span id='topic+dist_between_vertices'></span>

<h3>Description</h3>

<p>Analyse some of the grid options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_between_vertices(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_between_vertices_+3A_data">data</code></td>
<td>
<p>a sf object to be used in cartogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'dbv.cartogramR' object which is a data-table 
which contains distance between vertices ('dbv') and polygons names
('L1', 'L2', 'L3') inherited from [sf::st_coordinates]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(usa)
  dbv &lt;- dist_between_vertices(data=usa)
  summary(dbv)
</code></pre>

<hr>
<h2 id='france_dept'>Map of the population of mainland France (year 2018)</h2><span id='topic+france_dept'></span>

<h3>Description</h3>

<p>This data set is a basemap of mainland France with the population in 2018 (<code>pop2018</code>), the number of physicians in 2018 (<code>n_physicians</code>), the number of general practitioner  in 2018 (<code>n_gp</code>)  and the number of general practitioner for 100000 inhabitants  in 2018 (<code>n_gp_per100000</code>) in each department (<code>dept_name</code> or <code>id</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(france_dept)</code></pre>


<h3>Format</h3>

<p>A sf object containing 8 columns of data and the geometry
Projected CRS: RGF93 / Lambert-93 (EPSG : 2154)</p>


<h3>Source</h3>

<p><a href="https://www.data.gouv.fr/fr/datasets/admin-express/#_">https://www.data.gouv.fr/fr/datasets/admin-express/#_</a></p>


<h3>References</h3>


<ul>
<li> <p><a href="https://www.insee.fr/fr/statistiques/2012713#tableau-TCRD_004_tab1_departements">https://www.insee.fr/fr/statistiques/2012713#tableau-TCRD_004_tab1_departements</a>
</p>
</li>
<li> <p><a href="https://www.insee.fr/fr/statistiques/2012677#tableau-TCRD_068_tab1_departements">https://www.insee.fr/fr/statistiques/2012677#tableau-TCRD_068_tab1_departements</a></p>
</li></ul>

<hr>
<h2 id='france_rivers'>Map of french rivers  of mainland France</h2><span id='topic+france_rivers'></span>

<h3>Description</h3>

<p>This data set is a basemap of mainland french rivers (<code>name</code> or <code>id</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(france_rivers)</code></pre>


<h3>Format</h3>

<p>A sf object containing 2 columns of data and the geometry
Projected CRS: RGF93 / Lambert-93 (EPSG : 2154)</p>


<h3>Source</h3>

<p><a href="https://geoservices.ign.fr/telechargement">https://geoservices.ign.fr/telechargement</a></p>

<hr>
<h2 id='from_coord_polygon'>Transform from coordinates system used in the polygons to coordinates
system used in flow based cartogram</h2><span id='topic+from_coord_polygon'></span>

<h3>Description</h3>

<p>Apply the mapping from the coordinates system used in the polygons
(caracterised by the CRS) to the coordinates system used in flow based cartogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_coord_polygon(coord, carto)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_coord_polygon_+3A_coord">coord</code></td>
<td>
<p>a vector of length 2 or a two columns matrix containing xy
coordinates to transform</p>
</td></tr>
<tr><td><code id="from_coord_polygon_+3A_carto">carto</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 2 or a two columns matrix containing xy
coordinates in the coordinate systems of polygons used to build
the cartogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  from_coord_polygon(c(-0.007, -0.348), carto)
 


</code></pre>

<hr>
<h2 id='geom_cartogramR'>Apply the deformation used to build a cartogram to a set of
simple geometry  coordinates</h2><span id='topic+geom_cartogramR'></span>

<h3>Description</h3>

<p>Apply the deformation used to build a cartogram to a set of
simple geometry coordinates. The resulting  simple geometry object can
be used to add geometry features on the cartogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_cartogramR(sfgeom, carto, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_cartogramR_+3A_sfgeom">sfgeom</code></td>
<td>
<p>a sf or a sfc object which contains simple feature geometry of
types in the following <code>POINT</code>, <code>MULTIPOINT</code>, <code>LINESTRING</code>,
<code>MULTILINESTRING</code>, <code>POLYGON</code>, 'MULTIPOLYGON</p>
</td></tr>
<tr><td><code id="geom_cartogramR_+3A_carto">carto</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="geom_cartogramR_+3A_verbose">verbose</code></td>
<td>
<p>a boolean object to set on verbose mode (default to <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sf or a sfc object which contains simple feature geometry transformed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  LA &lt;- sf::st_sfc(sf::st_point(c(-118.243685, 34.052234)))
  sf::st_crs(LA) &lt;- 4326
  moregeom &lt;- geom_cartogramR(LA, carto)
  plot(carto)
  plot(moregeom, add=TRUE, col=2, pch=15)


</code></pre>

<hr>
<h2 id='grid_analysis'>Analyse some of the grid options</h2><span id='topic+grid_analysis'></span>

<h3>Description</h3>

<p>Analyse some of the grid options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_analysis(data, gridpower2 = 8:11, pf = 1.5, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_analysis_+3A_data">data</code></td>
<td>
<p>a sf object to be used in cartogram.</p>
</td></tr>
<tr><td><code id="grid_analysis_+3A_gridpower2">gridpower2</code></td>
<td>
<p>a vector of exponent (to be raised at the power of 2) that
gives the log2(size) of the grid (default to '8:11')</p>
</td></tr>
<tr><td><code id="grid_analysis_+3A_pf">pf</code></td>
<td>
<p>Determines space between map and boundary (default to 1.5)</p>
</td></tr>
<tr><td><code id="grid_analysis_+3A_verbose">verbose</code></td>
<td>
<p>a boolean object to set on verbose mode (default to 'TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'gridanalysis.cartogramR' object which is a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  ga &lt;- grid_analysis(data=usa, gridpower2=4:8, verbose=TRUE)
  summary(ga)

</code></pre>

<hr>
<h2 id='make_layer'>Make a layer</h2><span id='topic+make_layer'></span>

<h3>Description</h3>

<p>Create a sfc object containing final centers, original centers,
centers displacement, original graticule or final graticule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_layer(
  x,
  type = c("final_centers", "original_centers", "centers_translation",
    "final_graticule", "original_graticule")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_layer_+3A_x">x</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="make_layer_+3A_type">type</code></td>
<td>
<p>a character string giving the type of layer:
- &quot;final_centers&quot;: if <code>method</code> is <code>dcn</code>, <a href="sf.html#topic+geos_unary">sf::st_centroid</a>
is applied on deformed/cartogram region ; if <code>method</code> is
<code>gsm</code> or <code>gn</code> (ie flow based), initial &quot;centers&quot; are calculated
and the cartogram deformation is applied on
these &quot;centers&quot; giving the final_centers.
- &quot;original_centers&quot; if <code>method</code> is <code>dcn</code>, <a href="sf.html#topic+geos_unary">sf::st_centroid</a>
is applied on original regions); if <code>method</code> is
<code>gsm</code> or <code>gn</code> (ie flow based), initial &quot;centers&quot; are calculated
using cartogramR <code>center</code> option see <a href="#topic+cartogramR_options">cartogramR_options</a>.
- &quot;centers_translation&quot; linestring giving the movement of
centers due to the deformation used to have the cartogram
- &quot;final_graticule&quot; (method <code>gsm</code> or <code>gn</code>) graticule
obtained by the cartogram algorithm
- &quot;original_graticule&quot; (method <code>gsm</code> or <code>gn</code>) graticule
used by the cartogram algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sfc object
</p>

<hr>
<h2 id='plot.cartogramR'>Plot a cartogram object</h2><span id='topic+plot.cartogramR'></span>

<h3>Description</h3>

<p>Plot a cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cartogramR_+3A_x">x</code></td>
<td>
<p>a cartogram object</p>
</td></tr>
<tr><td><code id="plot.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  plot(carto)


</code></pre>

<hr>
<h2 id='plot.dbv.cartogramR'>Plot a dbv.cartogram object</h2><span id='topic+plot.dbv.cartogramR'></span>

<h3>Description</h3>

<p>Plot a dbv.cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbv.cartogramR'
plot(x, which = 1:2, ask = TRUE, key = TRUE, last = 10, probminx = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dbv.cartogramR_+3A_x">x</code></td>
<td>
<p>a dbv.cartogram object</p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of the
numbers <code>1:2</code></p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot, see
<a href="graphics.html#topic+par">par</a><code>(ask=.)</code></p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_key">key</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend is drawn</p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_last">last</code></td>
<td>
<p>draw the density of distance between vertices for the <code>last</code>
coordinates</p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_probminx">probminx</code></td>
<td>
<p>the sample quantiles (of distance between vertices)
corresponding to the probability is used as a minimum
of x-axis for the density plot (used only if <code>last</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plot.dbv.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first plot is the density of distance between
consecutive vertice by region. Only the upper quantiles
are shown. The second plot is a barplot by region of the
number of vertice divided by the perimeter of the region
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  precarto &lt;- precartogramR(usa, method="dcn")
  plot(precarto)

</code></pre>

<hr>
<h2 id='plot.gridanalysis.cartogramR'>Plot a gridanalysis.cartogram object</h2><span id='topic+plot.gridanalysis.cartogramR'></span>

<h3>Description</h3>

<p>Plot a gridanalysis.cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gridanalysis.cartogramR'
plot(
  x,
  nthsmallest = 5,
  redrawxaxis = TRUE,
  type = "b",
  xlab = NULL,
  ylab = NULL,
  ylim = c(0, 20),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_x">x</code></td>
<td>
<p>a gridanalysis.cartogram object</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_nthsmallest">nthsmallest</code></td>
<td>
<p>plot only  the nthsmallest values among all polygons</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_redrawxaxis">redrawxaxis</code></td>
<td>
<p>if <code>TRUE</code> redraw ticks and labels of x axe at grid size on
log scale</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_type">type</code></td>
<td>
<p>character string (length 1 vector) or vector of 1-character
strings indicating the type of plot for each polygons,
see <a href="graphics.html#topic+matplot">graphics::matplot</a> for all possible <code>type</code>s.</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_xlab">xlab</code></td>
<td>
<p>titles for x axe, as in <a href="graphics.html#topic+matplot">graphics::matplot</a>.</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_ylab">ylab</code></td>
<td>
<p>titles for y axe, as in <a href="graphics.html#topic+matplot">graphics::matplot</a>.</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_ylim">ylim</code></td>
<td>
<p>ranges of y axe, as in <a href="graphics.html#topic+matplot">graphics::matplot</a>.</p>
</td></tr>
<tr><td><code id="plot.gridanalysis.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  precarto &lt;- precartogramR(usa, method="gsm", pf=1.2, verbose=TRUE)
  plot(precarto)


</code></pre>

<hr>
<h2 id='precartogramR'>Make a pre cartogram analysis</h2><span id='topic+precartogramR'></span>

<h3>Description</h3>

<p>Make a pre cartogram analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precartogramR(
  data,
  method = c("gsm", "gn", "dcn", "GastnerSeguyMore", "GastnerNewman",
    "DougenikChrismanNiemeyer"),
  gridpower2 = 8:11,
  pf = 1.5,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precartogramR_+3A_data">data</code></td>
<td>
<p>a sf object which contains at least two columns:
obviously a geometry column (giving the map) and a column which
contains a count by region (leading to a density by region,
density to be equalized by deformation). Each row of <code>data</code> is a region and
contains the simple feature geometry of type <code>POLYGON</code> or
<code>MULTIPOLYGON</code>. Polygon ring directions are not checked but
exterior ring must counter clockwise and holes clockwise (use
option <code>check_ring_dir</code> of <a href="sf.html#topic+st_read">sf::st_read</a> to achieve the right
orientation of ring direction on import or use <a href="#topic+check_ring_dir">check_ring_dir</a>
function)</p>
</td></tr>
<tr><td><code id="precartogramR_+3A_method">method</code></td>
<td>
<p>the method to be used, can be one of the following:
<code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code>, <code>dcn</code> or <code>DougenikChrismanNiemeyer</code>.</p>
</td></tr>
<tr><td><code id="precartogramR_+3A_gridpower2">gridpower2</code></td>
<td>
<p>a vector of exponent (to be raised at the power of 2) that
gives the log2(size) of the grid (default to <code>8:11</code>);
meaningful for method <code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code></p>
</td></tr>
<tr><td><code id="precartogramR_+3A_pf">pf</code></td>
<td>
<p>Determines space between map and boundary (default to 1.5);
meaningful for method <code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code></p>
</td></tr>
<tr><td><code id="precartogramR_+3A_verbose">verbose</code></td>
<td>
<p>a boolean object to set on verbose mode (default to <code>FALSE</code>);
meaningful for method <code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a <code>dbv.cartogramR</code> object (if method
is <code>dcn</code> or <code>DougenikChrismanNiemeyer</code>) see <a href="#topic+dist_between_vertices">dist_between_vertices</a>
for details or
a <code>gridanalysis.cartogramR</code> (if method
is <code>gsm</code> or <code>GastnerSeguyMore</code> (default), <code>gn</code> or
<code>GastnerNewman</code>) see <a href="#topic+grid_analysis">grid_analysis</a> for details
</p>


<h3>References</h3>


<ul>
<li><p> Dougenik, J., Chrisman, R. &amp;  Niemeyer, D. (1985).
An algorithm to construct continuous area cartograms.
Professional Geographer <strong>37</strong>: 75-81.
</p>
</li>
<li><p> Gastner, M. &amp; Newman, M.E.J. (2004). Diffusion-based
method for producing density equalizing
maps. <em>Proc. Natl. Acad. Sci. USA</em>, <strong>101</strong>:7499-7504
</p>
</li>
<li><p> Gastner, M., Seguy, V. &amp; More, P. (2018). Fast flow-based
algorithm for creating density-equalizing map
projections. <em>Proceedings of the National Academy of Sciences
USA</em>, <strong>115</strong>:E2156-E2164
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  precarto &lt;- precartogramR(usa)
  plot(precarto)
  summary(precarto)


</code></pre>

<hr>
<h2 id='print.cartogramR'>Print a cartogram object</h2><span id='topic+print.cartogramR'></span>

<h3>Description</h3>

<p>Print a cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cartogramR_+3A_x">x</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="print.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='print.summary.cartogramR'>Print a summary of a cartogram object</h2><span id='topic+print.summary.cartogramR'></span>

<h3>Description</h3>

<p>Print a summary of a cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.cartogramR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.cartogramR_+3A_x">x</code></td>
<td>
<p>a summary.cartogramR object</p>
</td></tr>
<tr><td><code id="print.summary.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods. The following
argument is available at this level :  digits, the number of significant
digits to use when printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  summary(carto)


</code></pre>

<hr>
<h2 id='residuals.cartogramR'>Errors of a cartogram object</h2><span id='topic+residuals.cartogramR'></span>

<h3>Description</h3>

<p>Errors of a cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.cartogramR_+3A_object">object</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="residuals.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods. The following
arguments are available:
- type; a character string giving the type of residuals (see details)
- &quot;relative error&quot;
- &quot;absolute error&quot;
- &quot;symmetric difference&quot;
- center ; a character string giving the type of center:
- &quot;point_on_surface&quot; (<a href="sf.html#topic+st_point_on_surface">st_point_on_surface</a> applied on original
and on deformed/cartogram region).
- &quot;deformed_center&quot; (the center function, see
<a href="#topic+cartogramR_options">cartogramR_options</a>, is applied on region and
this center follows the deformation  giving
the center on the deformed/cartogram region)
- &quot;centroid&quot; (centroid of original and
deformed/cartogram region).
Can be abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The error vector contains the values of the differences
between actual area of regions in the cartogram and theorical area
(obtained with conservation of total area and constant density over
region in the final cartogram)
</p>
<div class="sourceCode"><pre>Relative error are the error vector divided by the theorical area

Symmetric difference are the symmetric difference between
actual area of regions in the cartogram and the original
area. Each region is scaled to have an area equal to 1 and centered
around the chosen center.
</pre></div>


<h3>Value</h3>

<p>A numeric vector which contains for each region observed
area minus theorical area
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  residuals(carto)


</code></pre>

<hr>
<h2 id='summary.cartogramR'>Summary of a cartogram object</h2><span id='topic+summary.cartogramR'></span>

<h3>Description</h3>

<p>Summary of a cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cartogramR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cartogramR_+3A_object">object</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
<tr><td><code id="summary.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods. The following
arguments are available:
- digits integer, used for number formatting with signif if
not specified (i.e., <code style="white-space: pre;">&#8288;[missing](.)&#8288;</code>, <code style="white-space: pre;">&#8288;[signif]()&#8288;</code> will not be
called anymore (since \R &gt;= 3.4.0, where the default has been
changed to only round in the <code>print</code> and <code>format</code> methods).
- quantile.type integer code used in <code style="white-space: pre;">&#8288;quantile(*, type=quantile.type)&#8288;</code>.
- center character string code used in <a href="#topic+residuals.cartogramR">residuals.cartogramR</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary.cartogramR object: a list with the following components:
</p>

<ul>
<li><p> qrr, the summary of absolute relative residuals
</p>
</li>
<li><p> qres, the summary of absolute residuals
</p>
</li>
<li><p> qsymdiff, the summary of all pairwise symmetric difference beween two
scaled (multi)polygons representative of two regions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  summary(carto)


</code></pre>

<hr>
<h2 id='summary.dbv.cartogramR'>Summary of a dbv.cartogram object</h2><span id='topic+summary.dbv.cartogramR'></span>

<h3>Description</h3>

<p>Summary of a dbv.cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbv.cartogramR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dbv.cartogramR_+3A_object">object</code></td>
<td>
<p>a dbv.cartogramR object</p>
</td></tr>
<tr><td><code id="summary.dbv.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data-table which contains by region (<code>L3</code>)
</p>

<ul>
<li><p> the sample quantiles corresponding to the probability
0.8, 0.85, ...,1
</p>
</li>
<li><p> the total number of vertices divided by the
perimeter of the region (the sum of all polygons
perimeter of the region, <code>NbyPerim</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  data(usa)
  dbv &lt;- dist_between_vertices(data=usa)
  summary(dbv)

</code></pre>

<hr>
<h2 id='summary.gridanalysis.cartogramR'>Summary of a gridanalysis.cartogram object</h2><span id='topic+summary.gridanalysis.cartogramR'></span>

<h3>Description</h3>

<p>Summary of a gridanalysis.cartogram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gridanalysis.cartogramR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gridanalysis.cartogramR_+3A_object">object</code></td>
<td>
<p>a gridanalysis.cartogramR object</p>
</td></tr>
<tr><td><code id="summary.gridanalysis.cartogramR_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector which indicate the grid size necessary to have more than <code>steps</code>
grid points in each polygon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(usa)
  ga &lt;- grid_analysis(data=usa, gridpower2=4:9)
  summary(ga)

</code></pre>

<hr>
<h2 id='to_coord_polygon'>Transform from coordinates system used in flow based cartogram to coordinates
system used in the polygons</h2><span id='topic+to_coord_polygon'></span>

<h3>Description</h3>

<p>Apply the mapping from the coordinates system used in flow based cartogram
to the coordinates system used in the polygons (caracterised by the CRS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_coord_polygon(coord, carto)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_coord_polygon_+3A_coord">coord</code></td>
<td>
<p>a vector of length 2 or a two columns matrix containing
xy  coordinates to transform</p>
</td></tr>
<tr><td><code id="to_coord_polygon_+3A_carto">carto</code></td>
<td>
<p>a cartogramR object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 2 or a two columns matrix containing xy
coordinates in the coordinate systems of polygons used to build
the cartogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  data(usa)
  carto &lt;- cartogramR(usa, "electors64")
  to_coord_polygon(c(256,256), carto)
 


</code></pre>

<hr>
<h2 id='usa'>Map of the number of electors in each state of the USA</h2><span id='topic+usa'></span>

<h3>Description</h3>

<p>This data set is a basemap of the conterminous USA with the the number of electors in the 49 states from 1964 to 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(usa)</code></pre>


<h3>Format</h3>

<p>A sf object containing 24 columns of data and the geometry. Projected CRS: US National Atlas Equal Area (EPSG:2163)</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
