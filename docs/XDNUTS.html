<!DOCTYPE html><html lang="en"><head><title>Help for package XDNUTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XDNUTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#XDNUTS-package'>
<p>Discontinuous Hamiltonian Monte Carlo with Varying Trajectory Length</p></a></li>
<li><a href='#main_function'><p>Function to generate a Markov chain for both continuous and discontinuous posterior distributions.</p></a></li>
<li><a href='#plot.XDNUTS'><p>Function to view the draws from the posterior distribution.</p></a></li>
<li><a href='#print.summary.XDNUTS'><p>Function for printing an object of class summary.XDNUTS</p></a></li>
<li><a href='#print.XDNUTS'><p>Function for printing an object of class XDNUTS</p></a></li>
<li><a href='#set_parameters'><p>Function that regulates the specifications of the xdnuts function.</p></a></li>
<li><a href='#summary.XDNUTS'><p>Function to print the summary of an XDNUTS model.</p></a></li>
<li><a href='#viscosity'><p>Blood viscosity data</p></a></li>
<li><a href='#xdextract'><p>Function to extract samples from the output of an XDNUTS model.</p></a></li>
<li><a href='#xdnuts'><p>Discontinuous Hamiltonian Monte Carlo using both manual and automatic termination criteria.</p></a></li>
<li><a href='#xdtransform'><p>Function to apply a transformation to the samples from the output of an XDNUTS model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discontinuous Hamiltonian Monte Carlo with Varying Trajectory
Length</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Hamiltonian Monte Carlo for both continuous and discontinuous
  posterior distributions with customisable trajectory length 
  termination criterion. See Nishimura et al. (2020) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasz083">doi:10.1093/biomet/asz083</a>&gt; for
  the original Discontinuous Hamiltonian Monte Carlo, 
  Hoffman et al. (2014) &lt;<a href="https://doi.org/10.48550%2FarXiv.1111.4246">doi:10.48550/arXiv.1111.4246</a>&gt; and Betancourt (2016) 
  &lt;<a href="https://doi.org/10.48550%2FarXiv.1601.00225">doi:10.48550/arXiv.1601.00225</a>&gt; for the definition of possible Hamiltonian
  Monte Carlo termination criteria.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, coda, ggplot2, graphics, grDevices, gridExtra, parallel,
purrr, Rcpp (&ge; 1.0.12), Rdpack, stats</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, KernSmooth</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-27 15:31:38 UTC; paolomanildo</td>
</tr>
<tr>
<td>Author:</td>
<td>Paolo Manildo <a href="https://orcid.org/0009-0006-7056-7012"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Manildo &lt;paolo.manildo@phd.unipd.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-28 13:40:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='XDNUTS-package'>
Discontinuous Hamiltonian Monte Carlo with Varying Trajectory Length
</h2><span id='topic+XDNUTS-package'></span><span id='topic+XDNUTS'></span>

<h3>Description</h3>

<p>Hamiltonian Monte Carlo for both continuous and discontinuous
  posterior distributions with customisable trajectory length 
  termination criterion. See Nishimura et al. (2020) &lt;doi:10.1093/biomet/asz083&gt; for
  the original Discontinuous Hamiltonian Monte Carlo, 
  Hoffman et al. (2014) &lt;doi:10.48550/arXiv.1111.4246&gt; and Betancourt (2016) 
  &lt;doi:10.48550/arXiv.1601.00225&gt; for the definition of possible Hamiltonian
  Monte Carlo termination criteria.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> XDNUTS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Discontinuous Hamiltonian Monte Carlo with Varying Trajectory Length</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-01-27</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person("Paolo", "Manildo", email = "paolo.manildo@phd.unipd.it",
  role = c("aut", "cre"), comment = c(ORCID = "0009-0006-7056-7012"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Hamiltonian Monte Carlo for both continuous and discontinuous
  posterior distributions with customisable trajectory length 
  termination criterion. See Nishimura et al. (2020) &lt;doi:10.1093/biomet/asz083&gt; for
  the original Discontinuous Hamiltonian Monte Carlo, 
  Hoffman et al. (2014) &lt;doi:10.48550/arXiv.1111.4246&gt; and Betancourt (2016) 
  &lt;doi:10.48550/arXiv.1601.00225&gt; for the definition of possible Hamiltonian
  Monte Carlo termination criteria.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> MIT + file LICENSE</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> base,
coda,
ggplot2,
graphics,
grDevices,
gridExtra,
parallel,
purrr,
Rcpp (&gt;= 1.0.12),
Rdpack,
stats</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,
rmarkdown,
KernSmooth</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Paolo Manildo [aut, cre] (&lt;https://orcid.org/0009-0006-7056-7012&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Paolo Manildo &lt;paolo.manildo@phd.unipd.it&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
XDNUTS-package          Discontinuous Hamiltonian Monte Carlo with
                        Varying Trajectory Length
main_function           Function to generate a Markov chain for both
                        continuous and discontinuous posterior
                        distributions.
plot.XDNUTS             Function to view the draws from the posterior
                        distribution.
print.XDNUTS            Function for printing an object of class XDNUTS
print.summary.XDNUTS    Function for printing an object of class
                        summary.XDNUTS
set_parameters          Function that regulates the specifications of
                        the xdnuts function.
summary.XDNUTS          Function to print the summary of an XDNUTS
                        model.
viscosity               Blood viscosity data
xdextract               Function to extract samples from the output of
                        an XDNUTS model.
xdnuts                  Discontinuous Hamiltonian Monte Carlo using
                        both manual and automatic termination criteria.
xdtransform             Function to apply a transformation to the
                        samples from the output of an XDNUTS model.
</pre>
<p>The package allows to use a more efficient version of the Discontinuous Hamiltonian Monte Carlo proposed in (Nishimura et al. 2020), thanks to the use of recycled samples from each trajectory (Nishimura and Dunson 2020) and a termination criterion for identyfing the optimal discrete integration time of each trajectory (Betancourt 2016). No models are at disposal, so the user must specify one through the definition of the function <code>nlp</code>. This function must evaluate the negative log posterior of the model and its gradient with respect to the first <code class="reqn">d-k</code> parameters. <code class="reqn">d</code> is the model dimension, while <code class="reqn">k</code> is the number of parameters for which the sampling scheme will be based on the method described in (Nishimura et al. 2020). This method was born for treating discontinuous components but it is applicable to continuous one too. <code>nlp</code> must be a function with 3 arguments:
</p>

<ul>
<li><p>the vector of parameters, current state of the chain/trajectory, for which the negative log posterior or its gradient must be evaluated.
</p>
</li>
<li><p>a list object that contains the necessary argouments, namely data and hyperparameters.
</p>
</li>
<li><p>a boolean value, <code>TRUE</code> to evaluate only the negative log posterior of the models, 
<code>FALSE</code> to evaluate its gradient with respect to the continuous components of the posterior.
</p>
</li></ul>

<p>The available algorithms are the following
</p>

<dl>
<dt>NUTS</dt><dd><p>No U-Turn Sampler of (Hoffman et al. 2014).</p>
</dd>
<dt>XHMC</dt><dd><p>Hamiltonian Monte Carlo with a termination criterion based on the exhustion of the virial (Betancourt 2016) which require the specification of a threshold.</p>
</dd>
<dt>HMC</dt><dd><p>Hamiltonian Monte Carlo with trajectory length varying uniformly inside a user specified interval. Instead of proposing the last value of each trajectories a sample is drawn uniformly from them. Reference can be found in (Betancourt 2017).</p>
</dd>
</dl>

<p>All of them are embedded into the framework described in (Nishimura et al. 2020) which allows the use of Hamiltonian Monte Carlo with discontinuous posterior and hence to discrete parameter space by the definition of a step function shape density.
</p>


<h3>Author(s)</h3>

<p>Paolo Manildo [aut, cre] (&lt;https://orcid.org/0009-0006-7056-7012&gt;)
</p>
<p>Maintainer: Paolo Manildo &lt;paolo.manildo@phd.unipd.it&gt;
</p>


<h3>References</h3>

<p>Hoffman MD, Gelman A, others (2014).
&ldquo;The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.&rdquo;
<em>J. Mach. Learn. Res.</em>, <b>15</b>(1), 1593&ndash;1623.<br /><br />
Betancourt M (2016).
&ldquo;Identifying the optimal integration time in Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1601.00225</em>.<br /><br />
Betancourt M (2017).
&ldquo;A conceptual introduction to Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1701.02434</em>.<br /><br />
Nishimura A, Dunson DB, Lu J (2020).
&ldquo;Discontinuous Hamiltonian Monte Carlo for discrete parameters and discontinuous likelihoods.&rdquo;
<em>Biometrika</em>, <b>107</b>(2), 365&ndash;380.<br /><br />
Nishimura A, Dunson D (2020).
&ldquo;Recycling Intermediate Steps to Improve Hamiltonian Monte Carlo.&rdquo;
<em>Bayesian Analysis</em>, <b>15</b>(4).
ISSN 1936-0975, <a href="https://doi.org/10.1214/19-ba1171">doi:10.1214/19-ba1171</a>, <a href="http://dx.doi.org/10.1214/19-BA1171">http://dx.doi.org/10.1214/19-BA1171</a>.
</p>

<hr>
<h2 id='main_function'>Function to generate a Markov chain for both continuous and discontinuous posterior distributions.</h2><span id='topic+main_function'></span>

<h3>Description</h3>

<p>The function allows to generate a single Markov Chain for sampling from both continuous and discontinuous
posterior distributions using a plethora of algorithms. Classic Hamiltonian Monte Carlo (Duane et al. 1987) ,
NUTS (Hoffman et al. 2014) and XHMC (Betancourt 2016) are embedded into the framework
described in (Nishimura et al. 2020), which allows to deal with such posteriors.
Furthermore, for each method, it is possible to recycle samples from the trajectories using
the method proposed by (Nishimura and Dunson 2020).
This is used to improve the estimation of the mass matrix during the warm-up phase
without requiring significant additional computational costs.
This function should not be used directly, but only through the user interface provided by <a href="#topic+xdnuts">xdnuts</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main_function(
  theta0,
  nlp,
  args,
  k,
  N,
  K,
  tau,
  L,
  thin,
  chain_id,
  verbose,
  control
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="main_function_+3A_theta0">theta0</code></td>
<td>
<p>a vector of length-<code class="reqn">d</code> containing the starting point of the chain.</p>
</td></tr>
<tr><td><code id="main_function_+3A_nlp">nlp</code></td>
<td>
<p>a function object that takes three arguments:
</p>
<dl>
<dt>par</dt><dd><p>a vector of length-<code class="reqn">d</code> containing the value of the parameters.</p>
</dd>
<dt>args</dt><dd><p>a list object that contains the necessary arguments, namely data and hyperparameters.</p>
</dd>
<dt>eval_nlp</dt><dd><p>a boolean value, <code>TRUE</code> for evaluating only the model\'s negative log posterior, 
<code>FALSE</code> to evaluate the gradient with respect to the continuous components of the posterior.</p>
</dd></dl>
</td></tr>
<tr><td><code id="main_function_+3A_args">args</code></td>
<td>
<p>the necessary arguments to evaluate the negative log posterior and its gradient.</p>
</td></tr>
<tr><td><code id="main_function_+3A_k">k</code></td>
<td>
<p>the number of parameters that induce a discontinuity in the posterior distribution.</p>
</td></tr>
<tr><td><code id="main_function_+3A_n">N</code></td>
<td>
<p>integer containing the number of post warm-up samples to evaluate.</p>
</td></tr>
<tr><td><code id="main_function_+3A_k">K</code></td>
<td>
<p>integer containing the number of recycled samples from each trajectory during the warm-up phase or beyond.</p>
</td></tr>
<tr><td><code id="main_function_+3A_tau">tau</code></td>
<td>
<p>the threshold for the exhaustion termination criterion described in (Betancourt 2016).</p>
</td></tr>
<tr><td><code id="main_function_+3A_l">L</code></td>
<td>
<p>the desired length of the trajectory of classic Hamiltonian Monte Carlo algorithm.</p>
</td></tr>
<tr><td><code id="main_function_+3A_thin">thin</code></td>
<td>
<p>integer containing the number of samples to discard in order to produce a final iteration of the chain.</p>
</td></tr>
<tr><td><code id="main_function_+3A_chain_id">chain_id</code></td>
<td>
<p>the identification number of the chain.</p>
</td></tr>
<tr><td><code id="main_function_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value that controls whether to print all the information regarding the sampling process.</p>
</td></tr>
<tr><td><code id="main_function_+3A_control">control</code></td>
<td>
<p>an object of class <code>control_xdnuts</code> containing the specifications for the algorithm.
See the <a href="#topic+set_parameters">set_parameters</a> function for detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing: </p>

<dl>
<dt>values</dt><dd><p>a <code class="reqn">N \times d</code> matrix containing the sample from the
target distribution (if convergence has been reached).</p>
</dd>
<dt>energy</dt><dd><p>a vector of length-<code class="reqn">N</code> containing the Markov Chain of the energy level sets.</p>
</dd>
<dt>delta_energy</dt><dd><p>a vector of length-<code class="reqn">N</code> containing the Markov Chain of the first difference energy level sets.</p>
</dd>
<dt>step_size</dt><dd><p>a vector of length-<code class="reqn">N</code> containing the sampled step size used for each iteration.</p>
</dd>
<dt>step_length</dt><dd><p>a vector of length-<code class="reqn">N</code> containing the length of each trajectory of the chain.</p>
</dd>
<dt>alpha</dt><dd><p>a vector of length-<code class="reqn">k + 1</code> containing the estimate of the Metropolis acceptance probabilities.
The first element of the vector is the estimated global acceptance probability. The remaining k elements are the 
estimate rate of reflection for each parameters which travels coordinate-wise through some discontinuity.</p>
</dd>
<dt>warm_up</dt><dd><p>a <code class="reqn">N_{adapt} \times d</code> matrix containing the sample of the chain
coming from the warm-up phase. If <code>keep_warm_up = FALSE</code> inside the <code>control</code>
argument, nothing is returned.</p>
</dd>
<dt>div_trans</dt><dd><p>a <code class="reqn">M \times d</code> matrix containing the locations where a divergence has been 
encountered during the integration of Hamilton equation. Hopefully <code class="reqn">M \ll N</code>, and even better if <code class="reqn">M = 0</code>.</p>
</dd>
<dt>M_cont</dt><dd><p>the Mass Matrix of the continuous components estimated during the warm-up phase.
Based on the <code>M_type</code> value of the <code>control</code> arguments, this could be an empty object, a vector or a matrix.</p>
</dd>
<dt>M_disc</dt><dd><p>the Mass Matrix of the discontinuous components estimated during the warm-up phase.
Based on the <code>M_type</code> value of the <code>control</code> arguments, this could be an empty object or a vector.</p>
</dd></dl>



<h3>References</h3>

<p>Betancourt M (2016).
&ldquo;Identifying the optimal integration time in Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1601.00225</em>.<br /><br /> Duane S, Kennedy AD, Pendleton BJ, Roweth D (1987).
&ldquo;Hybrid monte carlo.&rdquo;
<em>Physics letters B</em>, <b>195</b>(2), 216&ndash;222.<br /><br /> Hoffman MD, Gelman A, others (2014).
&ldquo;The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.&rdquo;
<em>J. Mach. Learn. Res.</em>, <b>15</b>(1), 1593&ndash;1623.<br /><br /> Nishimura A, Dunson D (2020).
&ldquo;Recycling Intermediate Steps to Improve Hamiltonian Monte Carlo.&rdquo;
<em>Bayesian Analysis</em>, <b>15</b>(4).
ISSN 1936-0975, <a href="https://doi.org/10.1214/19-ba1171">doi:10.1214/19-ba1171</a>, <a href="http://dx.doi.org/10.1214/19-BA1171">http://dx.doi.org/10.1214/19-BA1171</a>.<br /><br /> Nishimura A, Dunson DB, Lu J (2020).
&ldquo;Discontinuous Hamiltonian Monte Carlo for discrete parameters and discontinuous likelihoods.&rdquo;
<em>Biometrika</em>, <b>107</b>(2), 365&ndash;380.
</p>

<hr>
<h2 id='plot.XDNUTS'>Function to view the draws from the posterior distribution.</h2><span id='topic+plot.XDNUTS'></span>

<h3>Description</h3>

<p>Function to view the draws from the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XDNUTS'
plot(
  x,
  type = 1,
  which = NULL,
  warm_up = FALSE,
  plot.new = FALSE,
  which_chains = NULL,
  colors = NULL,
  gg = TRUE,
  scale = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.XDNUTS_+3A_x">x</code></td>
<td>
<p>an object of class <code>XDNUTS</code>.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_type">type</code></td>
<td>
<p>the type of plot to display. </p>

<dl>
<dt><code>type = 1</code></dt><dd><p>marginal chains, one for each desired dimension.</p>
</dd>
<dt><code>type = 2</code></dt><dd><p>bivariate plot.</p>
</dd>
<dt><code>type = 3</code></dt><dd><p>time series plot of the energy level sets. Good for a quick diagnostic of big models.</p>
</dd>
<dt><code>type = 4</code></dt><dd><p>stickplot of the step-length of each iteration.</p>
</dd>
<dt><code>type = 5</code></dt><dd><p>Histograms of the centered marginal energy in gray and of the first differences of energy in red.</p>
</dd>
<dt><code>type = 6</code></dt><dd><p>Autoregressive function plot of the parameters.</p>
</dd>
<dt><code>type = 7</code></dt><dd><p>Matplot of the empirical acceptance rate and refraction rates.</p>
</dd></dl>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_which">which</code></td>
<td>
<p>either a numerical vector indicating the index of the parameters of interest or a string </p>

<dl>
<dt><code>which = 'continuous'</code></dt><dd><p>for plotting the first <code class="reqn">d-k</code> parameters.</p>
</dd>
<dt><code>which = 'discontinuous'</code></dt><dd><p>for plotting the last <code class="reqn">k</code> parameters.</p>
</dd>
</dl>

<p>where both <code class="reqn">d</code> and <code class="reqn">k</code> are elements contained in the output of the <a href="#topic+xdnuts">xdnuts</a> function.
If <code>type = 7</code>, it refers to the rates index instead. When <code>which = 'continuous'</code>, 
only the global acceptance rate is displayed. In contrast, when <code>which = 'discontinuous'</code>,
the refraction rates are shown.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_warm_up">warm_up</code></td>
<td>
<p>a boolean value indicating whether the plot should be made using the warm-up samples.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_plot.new">plot.new</code></td>
<td>
<p>a boolean value indicating whether a new graphical window should be opened. This is advised if the parameters space is big.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_which_chains">which_chains</code></td>
<td>
<p>a numerical vector indicating the index of the chains of interest.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_colors">colors</code></td>
<td>
<p>a numerical vector containing the colors for each chain specified in <code>which_chains</code>
or for each rate specified in <code>which</code> when <code>type = 7</code>.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_gg">gg</code></td>
<td>
<p>A boolean value indicating whether the plot should utilize the grammar of graphics features. 
Default value is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_scale">scale</code></td>
<td>
<p>A numeric value for scaling the appearance of plots.</p>
</td></tr>
<tr><td><code id="plot.XDNUTS_+3A_...">...</code></td>
<td>
<p>additional arguments to customize plots. In reality, these do nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphical object if <code>gg = TRUE</code>, otherwise nothing is returned.
</p>

<hr>
<h2 id='print.summary.XDNUTS'>Function for printing an object of class summary.XDNUTS</h2><span id='topic+print.summary.XDNUTS'></span>

<h3>Description</h3>

<p>Print to console the statistics about the MCMC samples obtained with
a call to the function <a href="#topic+summary.XDNUTS">summary.XDNUTS</a>. See that for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.XDNUTS'
print(x, ..., digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.XDNUTS_+3A_x">x</code></td>
<td>
<p>an object of class summary.XDNUTS</p>
</td></tr>
<tr><td><code id="print.summary.XDNUTS_+3A_...">...</code></td>
<td>
<p>additional values to pass. These currently do nothing.</p>
</td></tr>
<tr><td><code id="print.summary.XDNUTS_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding the output. Default value is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='print.XDNUTS'>Function for printing an object of class XDNUTS</h2><span id='topic+print.XDNUTS'></span>

<h3>Description</h3>

<p>Print to console the specific of the algorithm used to generate an XDNUTS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XDNUTS'
print(x, ..., digits = 3, show_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.XDNUTS_+3A_x">x</code></td>
<td>
<p>an object of class XDNUTS.</p>
</td></tr>
<tr><td><code id="print.XDNUTS_+3A_...">...</code></td>
<td>
<p>additional arguments to pass. These currently do nothing.</p>
</td></tr>
<tr><td><code id="print.XDNUTS_+3A_digits">digits</code></td>
<td>
<p>a numeric scalar indicating the number of digits to show. Default value is 3.</p>
</td></tr>
<tr><td><code id="print.XDNUTS_+3A_show_all">show_all</code></td>
<td>
<p>logical scalar indicating where to print all the summary statistics 
even if these are more than 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a graphical object.
</p>

<hr>
<h2 id='set_parameters'>Function that regulates the specifications of the <a href="#topic+xdnuts">xdnuts</a> function.</h2><span id='topic+set_parameters'></span>

<h3>Description</h3>

<p>Function that regulates the specifications of the <a href="#topic+xdnuts">xdnuts</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parameters(
  N_init1 = 50L,
  N_adapt = 200L,
  N_init2 = 75L,
  burn_adapt_ratio = 0.1,
  keep_warm_up = FALSE,
  recycle_only_init = TRUE,
  max_treedepth = 10L,
  max_treedepth_init = 10L,
  eps_jitter = 0.1,
  L_jitter = 3L,
  gamma = 0.05,
  kappa = 0.75,
  delta = NULL,
  t0 = 10L,
  M_type = "dense",
  refresh = 0.1,
  l_eps_init = NA_real_,
  different_stepsize = FALSE,
  mu = NA_real_,
  M_cont = NULL,
  M_disc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_parameters_+3A_n_init1">N_init1</code></td>
<td>
<p>an integer that regulates the number of samples used to
adapt the step size.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_n_adapt">N_adapt</code></td>
<td>
<p>an integer that regulates the number of samples used to
estimate the Mass Matrix with fixed step size.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_n_init2">N_init2</code></td>
<td>
<p>an integer that regulates the number of samples used to
adapt the step size after the estimation of the Mass Matrix.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_burn_adapt_ratio">burn_adapt_ratio</code></td>
<td>
<p>a numeric scalar <code class="reqn">\in (0,1]</code> indicating the ratio of warm-up
samples to discard in order to estimate the covariance matrix of the parameters.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_keep_warm_up">keep_warm_up</code></td>
<td>
<p>a logical scalar that determines whether the warm-up samples should be returned.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_recycle_only_init">recycle_only_init</code></td>
<td>
<p>a logical value which disables the recycling of the
samples from each trajectory once the warm-up phase has terminated.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>an integer that regulates the maximum depth of
the binary tree used to approximate Hamilton equation for the exploration
of each energy level set of the phase space.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_max_treedepth_init">max_treedepth_init</code></td>
<td>
<p>an integer that controls the maximum depth of
the binary tree during the step-size adaptation phase. Setting a smaller value 
can help avoid wasting valuable time on low-probability areas with suboptimal 
algorithm parameters.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_eps_jitter">eps_jitter</code></td>
<td>
<p>a numeric scalar which regulates the amount of jittering
used to perturb the value of the step size for each iteration of the chain
after the warm-up phase.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_l_jitter">L_jitter</code></td>
<td>
<p>an integer scalar that regulates the amount of jittering used to perturb the
value of the trajectory length if this is specified to be constant.
This occurs when the classic Hamiltonian Monte Carlo algorithm is used through the 
<code>method = "HMC"</code> option in the <a href="#topic+xdnuts">xdnuts</a> function. If <code>L_jitter</code> <code class="reqn">\geq 1</code>
each trajectory length is sampled uniformly inside the interval [L - L_jitter , L + L_jitter].</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_gamma">gamma</code></td>
<td>
<p>a numeric value that, in the Nesterov Dual Averaging algorithm, regulates 
the sensitivity of the step size updating scheme to fluctuations in the estimate of the 
mean Metropolis acceptance probability.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_kappa">kappa</code></td>
<td>
<p>a numeric value that regulates the vanishing of Nesterov Dual Averaging
algorithm for the estimation of the step size.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_delta">delta</code></td>
<td>
<p>a vector containing the Metropolis acceptance probabilities, 
including both the global and those related to potential differences. Default values are (0.8,0.6).
If the second element of the vector is set to <code>NA</code>, then the step size calibration is conducted 
solely through the global acceptance probabilities.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_t0">t0</code></td>
<td>
<p>an integer value that makes Nesterov Dual Averaging
algorithm for the estimation of the step size less sensitive to early iterations.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_m_type">M_type</code></td>
<td>
<p>a character value specifying the type of Mass Matrix to estimate:</p>

<ul>
<li><p><code>"identity"</code> no Mass Matrix estimation is done.
</p>
</li>
<li><p><code>"diagonal"</code> a diagonal Mass Matrix is estimated during the warm-up phase.
</p>
</li>
<li><p><code>"dense"</code> a full dense Mass Matrix is estimated during the warm-up phase.
</p>
</li></ul>
</td></tr>
<tr><td><code id="set_parameters_+3A_refresh">refresh</code></td>
<td>
<p>a numeric scalar bounded in <code class="reqn">(0,1)</code> which regulates the update frequency of
the displayed sampling process state. Default values is 0.1, meaning every 10% of the total samples.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_l_eps_init">l_eps_init</code></td>
<td>
<p>a numeric scalar containing the logarithm of the initial value for the step size
used to approximate Hamilton differential equation for phase space exploration.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_different_stepsize">different_stepsize</code></td>
<td>
<p>a boolean value indicating where the adaptation scheme should adapt different step size. 
If <code>TRUE</code>, a global step size is adapted via Nesterov Dual Averaging algorithm. 
At the same time, for each empirical reflection rate of each component treated as discontinuous the same
algorithm is exploited and the difference between these is obtained through the updating of the discontinuous
components Mass Matrix. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_mu">mu</code></td>
<td>
<p>a numeric scalar containing the value to which the step size is shrunken during the warm-up phase.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_m_cont">M_cont</code></td>
<td>
<p>a vector of length-<code class="reqn">d-k</code> if <code>M_type = "diagonal"</code> or a <code class="reqn">(d-k) \times (d-k)</code> matrix
if <code>M_type = "dense"</code> containing an initial estimate for the Mass Matrix
(the inverse of the parameters covariance matrix).
If you want to keep it fixed, they should specify <code>N_adapt = 0</code>.</p>
</td></tr>
<tr><td><code id="set_parameters_+3A_m_disc">M_disc</code></td>
<td>
<p>a vector of length-<code class="reqn">k</code> if <code>M_type = "diagonal"</code> or 
<code>M_type = "dense"</code> containing an initial estimate for the Mass Matrix
(the inverse of the parameters covariances).
If one wants to keep it fixed, they should specify <code>N_adapt = 0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>control_xdnuts</code> containing a named list with all the above parameters.
</p>

<hr>
<h2 id='summary.XDNUTS'>Function to print the summary of an XDNUTS model.</h2><span id='topic+summary.XDNUTS'></span>

<h3>Description</h3>

<p>Function to print the summary of an XDNUTS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XDNUTS'
summary(
  object,
  ...,
  q.val = c(0.05, 0.25, 0.5, 0.75, 0.95),
  which = NULL,
  which_chains = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.XDNUTS_+3A_object">object</code></td>
<td>
<p>an object of class <code>XDNUTS</code>.</p>
</td></tr>
<tr><td><code id="summary.XDNUTS_+3A_...">...</code></td>
<td>
<p>additional arguments to customize the summary.</p>
</td></tr>
<tr><td><code id="summary.XDNUTS_+3A_q.val">q.val</code></td>
<td>
<p>desired quantiles of the posterior distribution for each coordinate.
Default values are <code>0.05,0.25,0.5,0.75,0.95</code>.</p>
</td></tr>
<tr><td><code id="summary.XDNUTS_+3A_which">which</code></td>
<td>
<p>either a numerical vector indicating the index of the parameters of interest or a string </p>

<dl>
<dt><code>which = 'continuous'</code></dt><dd><p>for plotting the first <code class="reqn">d-k</code> parameters.</p>
</dd>
<dt><code>which = 'discontinuous'</code></dt><dd><p>for plotting the last <code class="reqn">k</code> parameters.</p>
</dd>
</dl>

<p>where both <code class="reqn">d</code> and <code class="reqn">k</code> are elements contained in the output of the function <a href="#topic+xdnuts">xdnuts</a>.</p>
</td></tr>
<tr><td><code id="summary.XDNUTS_+3A_which_chains">which_chains</code></td>
<td>
<p>a numerical vector indicating the index of the chains of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a data frame named <code>stats</code> with the following columns: </p>
<dl>
<dt>mean</dt><dd><p>the mean of the posterior distribution.</p>
</dd>
<dt>sd</dt><dd><p>the standard deviation of the posterior distribution.</p>
</dd>
<dt>q.val</dt><dd><p>the desired quantiles of the posterior distribution.</p>
</dd>
<dt>ESS</dt><dd><p>the Effective Sample Size for each marginal distribution.</p>
</dd>
<dt>R_hat</dt><dd><p>the Potential Scale Reduction Factor of Gelman (Gelman and Rubin 1992), only if multiple chains are available.</p>
</dd>
<dt>R_hat_upper_CI</dt><dd><p>the upper confidence interval for the latter, only if multiple chains are available.</p>
</dd>
</dl>

<p>Other quantities returned are:</p>

<dl>
<dt>Gelman.Test</dt><dd><p>the value of the multivariate Potential Scale Reduction Factor test (Gelman and Rubin 1992).</p>
</dd>
<dt>BFMI</dt><dd><p>the value of the empirical Bayesian Fraction of Information Criteria (Betancourt 2016). 
A value below 0.2 indicates a bad random walk behavior in the energy Markov Chain, mostly due to a suboptimal
specification of the momentum parameters probability density.</p>
</dd>
<dt>n_div</dt><dd><p>the total number of trajectory ended with a divergent transition.</p>
</dd>
<dt>n_premature</dt><dd><p>the total number of trajectory with a premature termination.</p>
</dd></dl>



<h3>References</h3>

<p>Betancourt M (2016).
&ldquo;Diagnosing suboptimal cotangent disintegrations in Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1604.00695</em>.<br /><br /> Gelman A, Rubin DB (1992).
&ldquo;Inference from iterative simulation using multiple sequences.&rdquo;
<em>Statistical science</em>, <b>7</b>(4), 457&ndash;472.
</p>

<hr>
<h2 id='viscosity'>Blood viscosity data</h2><span id='topic+viscosity'></span>

<h3>Description</h3>

<p>Contains blood viscosity measurements of 6 subjects. Each individual
was measured 7 times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viscosity
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 8 variables:
</p>

<dl>
<dt>id</dt><dd><p>subject identifier.</p>
</dd>
<dt>Time.1</dt><dd><p>viscosity measurements for the first time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.2</dt><dd><p>viscosity measurements for the second time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.3</dt><dd><p>viscosity measurements for the third time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.4</dt><dd><p>viscosity measurements for the fourth time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.5</dt><dd><p>viscosity measurements for the fifth time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.6</dt><dd><p>viscosity measurements for the sixth time.</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>Time.7</dt><dd><p>viscosity measurements for the seventh time.</p>
</dd></dl>



<h3>Source</h3>

<p>Master\'s Degree course at the University of Padua
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(viscosity)
</code></pre>

<hr>
<h2 id='xdextract'>Function to extract samples from the output of an XDNUTS model.</h2><span id='topic+xdextract'></span>

<h3>Description</h3>

<p>Function to extract samples from the output of an XDNUTS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdextract(
  X,
  which = NULL,
  which_chains = NULL,
  collapse = FALSE,
  thin = NULL,
  burn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xdextract_+3A_x">X</code></td>
<td>
<p>an object of class <code>XDNUTS</code>.</p>
</td></tr>
<tr><td><code id="xdextract_+3A_which">which</code></td>
<td>
<p>either a numerical vector indicating the index of the parameters of interest or a string </p>

<dl>
<dt><code>which = 'continuous'</code></dt><dd><p>for plotting the first <code class="reqn">d-k</code> parameters.</p>
</dd>
<dt><code>which = 'discontinuous'</code></dt><dd><p>for plotting the last <code class="reqn">k</code> parameters.</p>
</dd>
</dl>

<p>where both <code class="reqn">d</code> and <code class="reqn">k</code> are elements contained in the output of the function <a href="#topic+xdnuts">xdnuts</a>.</p>
</td></tr>
<tr><td><code id="xdextract_+3A_which_chains">which_chains</code></td>
<td>
<p>a vector of indices containing the chains to extract. By default, all chains are considered.</p>
</td></tr>
<tr><td><code id="xdextract_+3A_collapse">collapse</code></td>
<td>
<p>a boolean value. If TRUE, all samples from every chain are collapsed into one. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="xdextract_+3A_thin">thin</code></td>
<td>
<p>an integer value indicating how many samples should be discarded before returning an iteration of the chain.</p>
</td></tr>
<tr><td><code id="xdextract_+3A_burn">burn</code></td>
<td>
<p>an integer value indicating how many initial samples for each chain to burn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">N \times d</code> matrix or an <code class="reqn">N \times d \times C</code> array, where C is the number of chains, containing the MCMC samples.
</p>

<hr>
<h2 id='xdnuts'>Discontinuous Hamiltonian Monte Carlo using both manual and automatic termination criteria.</h2><span id='topic+xdnuts'></span>

<h3>Description</h3>

<p>The function allows generating multiple Markov Chains for sampling from both continuous and discontinuous
posterior distributions using a variety of algorithms. Classic Hamiltonian Monte Carlo (Duane et al. 1987), 
NUTS (Hoffman et al. 2014), and XHMC (Betancourt 2016) are embedded into the framework
described in (Nishimura et al. 2020), which allows dealing with such posteriors.
Furthermore, for each method, it is possible to recycle samples from the trajectories using
the method proposed by (Nishimura and Dunson 2020).
This is used to improve the estimate of the Mass Matrix during the warm-up phase
without requiring a relevant additional computational cost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdnuts(
  theta0,
  nlp,
  args,
  k,
  N = 1000,
  K = 3,
  method = "NUTS",
  tau = NULL,
  L = NULL,
  thin = 1,
  control = set_parameters(),
  parallel = FALSE,
  loadLibraries = NULL,
  loadRObject = NULL,
  verbose = FALSE,
  hide = FALSE,
  logfile = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xdnuts_+3A_theta0">theta0</code></td>
<td>
<p>a list containing the starting values for each chain. These starting values are vectors of length-<code class="reqn">d</code>. 
The last <code class="reqn">k \in [0,d]</code> elements refer to parameters which determine a discontinuity in the posterior distribution.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_nlp">nlp</code></td>
<td>
<p>a function which evaluates the negative log posterior and its gradient with respect to 
parameters that do not induce any discontinuity in the posterior distribution (more generally, the first <code class="reqn">d-k</code> parameters).
This function must take 3 arguments:
</p>

<dl>
<dt>par</dt><dd><p>a vector of length-<code class="reqn">d</code> containing the parameter values.</p>
</dd>
<dt>args</dt><dd><p>a list object that contains the necessary arguments, namely data and hyperparameters.</p>
</dd>
<dt>eval_nlp</dt><dd><p>a boolean value, <code>TRUE</code> to evaluate only the negative log posterior of the models, 
<code>FALSE</code> to evaluate its gradient with respect to the continuous components of the posterior.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="xdnuts_+3A_args">args</code></td>
<td>
<p>a list containing the inputs for the negative posterior function.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_k">k</code></td>
<td>
<p>an integer value that states the number of parameters that determines a discontinuity in the posterior distribution.
Actually, since the algorithm proposed in (Nishimura et al. 2020) also works for the full continuous case,
<code>k</code> is the number of parameters specified by the user for which this algorithm is used.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_n">N</code></td>
<td>
<p>the number of draws from the posterior distribution, after warm-up, for each chain. Default value is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_k">K</code></td>
<td>
<p>the number of recycled samples per iteration used by default during the warm-up phase.
Default value is <code>3</code>. To recycle in the sampling phase too, specify <code>recycle_only_init = FALSE</code>
in the <code>control</code> argument above.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_method">method</code></td>
<td>
<p>a character value which defines the type of algorithm to exploit:</p>

<dl>
<dt><code>"NUTS"</code></dt><dd><p>applies the No U-Turn Sampler of (Hoffman et al. 2014).</p>
</dd>
<dt><code>"XHMC"</code></dt><dd><p>applies the Exhaustion Hamiltonian Monte Carlo of (Betancourt 2016).</p>
</dd>
<dt><code>"HMC"</code></dt><dd><p>applies one of the classic version of Hamiltonian Monte Carlo algorithm,
in particular the one described in (Betancourt 2017), which samples from the trajectory instead of always returning the last value.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="xdnuts_+3A_tau">tau</code></td>
<td>
<p>the threshold for the virial termination criterion (Betancourt 2016).</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_l">L</code></td>
<td>
<p>the desired length of the trajectory of classic Hamiltonian Monte Carlo algorithm.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_thin">thin</code></td>
<td>
<p>the number of necessary and discarded samples to obtain a final iteration of one chain.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_control">control</code></td>
<td>
<p>an object of class <code>control_xdnuts</code>, output of the function <a href="#topic+set_parameters">set_parameters</a>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_parallel">parallel</code></td>
<td>
<p>a boolean value specifying whether the chains must be run in parallel. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_loadlibraries">loadLibraries</code></td>
<td>
<p>A character vector indicating the names of the packages to load on each cluster if
<code>parallel</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_loadrobject">loadRObject</code></td>
<td>
<p>A character vector indicating the names of the R objects to load on each cluster if
<code>parallel</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value for printing all the information regarding the sampling process.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_hide">hide</code></td>
<td>
<p>a boolean value that omits the printing to the console if set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xdnuts_+3A_logfile">logfile</code></td>
<td>
<p>The pathname of the log file. The default value is <code>""</code>. 
On Linux or macOS systems, this allows the output to be printed directly to the console. 
Unfortunately, this is not possible on Windows systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>XDNUTS</code> containing </p>

<dl>
<dt>chains</dt><dd><p>a list of the same length of <code>theta0</code>, each element containing the output from the function <a href="#topic+main_function">main_function</a>.</p>
</dd>
<dt>d</dt><dd><p>the dimension of the parameter space.</p>
</dd>
<dt>k</dt><dd><p>the number of parameters that lead to a discontinuous posterior distribution. 
Or, more generally, for which the algorithm of (Nishimura et al. 2020) is exploited.</p>
</dd>
<dt>K</dt><dd><p>the number of recycled samples for each iteration during the sampling phase.</p>
</dd>
<dt>N</dt><dd><p>the number of posterior draws for each chain.</p>
</dd>
<dt>method</dt><dd><p>the MCMC method used. This could be either &quot;NUTS&quot;, &quot;XHMC&quot;, or &quot;HMC&quot;.</p>
</dd>
<dt>tau</dt><dd><p>the threshold for the virial termination criterion (Betancourt 2016). 
Only if <code>method = "XHMC"</code> this value is different from zero.</p>
</dd>
<dt>L</dt><dd><p>the desired length of the trajectory of classic Hamiltonian Monte Carlo algorithm specified by the user.
This argument is necessary if <code>method = "HMC"</code>.</p>
</dd>
<dt>thin</dt><dd><p>the number of discarded samples for every final iteration, specified by the user.</p>
</dd>
<dt>control</dt><dd><p>an object of class <code>control_xdnuts</code>, output of the function <a href="#topic+set_parameters">set_parameters</a> with arguments specified by the user.</p>
</dd>
<dt>verbose</dt><dd><p>the boolean value specified by the user regarding the printing of the sampling process information.</p>
</dd>
<dt>parallel</dt><dd><p>the boolean value specified by the user regarding parallel processing.</p>
</dd>
</dl>



<h3>References</h3>

<p>Betancourt M (2016).
&ldquo;Identifying the optimal integration time in Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1601.00225</em>.<br /><br /> Betancourt M (2017).
&ldquo;A conceptual introduction to Hamiltonian Monte Carlo.&rdquo;
<em>arXiv preprint arXiv:1701.02434</em>.<br /><br /> Duane S, Kennedy AD, Pendleton BJ, Roweth D (1987).
&ldquo;Hybrid monte carlo.&rdquo;
<em>Physics letters B</em>, <b>195</b>(2), 216&ndash;222.<br /><br /> Hoffman MD, Gelman A, others (2014).
&ldquo;The No-U-Turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo.&rdquo;
<em>J. Mach. Learn. Res.</em>, <b>15</b>(1), 1593&ndash;1623.<br /><br /> Nishimura A, Dunson D (2020).
&ldquo;Recycling Intermediate Steps to Improve Hamiltonian Monte Carlo.&rdquo;
<em>Bayesian Analysis</em>, <b>15</b>(4).
ISSN 1936-0975, <a href="https://doi.org/10.1214/19-ba1171">doi:10.1214/19-ba1171</a>, <a href="http://dx.doi.org/10.1214/19-BA1171">http://dx.doi.org/10.1214/19-BA1171</a>.<br /><br /> Nishimura A, Dunson DB, Lu J (2020).
&ldquo;Discontinuous Hamiltonian Monte Carlo for discrete parameters and discontinuous likelihoods.&rdquo;
<em>Biometrika</em>, <b>107</b>(2), 365&ndash;380.
</p>

<hr>
<h2 id='xdtransform'>Function to apply a transformation to the samples from the output of an XDNUTS model.</h2><span id='topic+xdtransform'></span>

<h3>Description</h3>

<p>Function to apply a transformation to the samples from the output of an XDNUTS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdtransform(
  X,
  FUN = NULL,
  ...,
  which = NULL,
  which_chains = NULL,
  new.names = NULL,
  thin = NULL,
  burn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xdtransform_+3A_x">X</code></td>
<td>
<p>an object of class <code>XDNUTS</code>.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_fun">FUN</code></td>
<td>
<p>a function object which takes one or more components of an MCMC iteration and any other possible arguments.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_...">...</code></td>
<td>
<p>optional arguments for FUN.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_which">which</code></td>
<td>
<p>a vector of indices indicating which parameter the transformation should be applied to.
If <code>NULL</code>, the function is applied to all of them.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_which_chains">which_chains</code></td>
<td>
<p>a numerical vector indicating the index of the chains of interest.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_new.names">new.names</code></td>
<td>
<p>a character vector containing the parameter names in the new parameterization.
If only one value is provided, but the transformation involves more, the name is iterated with an increasing index.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_thin">thin</code></td>
<td>
<p>an integer value indicating how many samples should be discarded before returning an iteration of the chain.</p>
</td></tr>
<tr><td><code id="xdtransform_+3A_burn">burn</code></td>
<td>
<p>an integer value indicating how many initial samples for each chain to discard.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>XDNUTS</code> with the specified transformation applied to each chain.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
