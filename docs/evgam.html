<!DOCTYPE html><html><head><title>Help for package evgam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evgam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colplot'><p>Scatter plot, with variable-based point colours</p></a></li>
<li><a href='#COprcp'><p>Colorado daily precipitation accumulations</p></a></li>
<li><a href='#dfbind'><p>Bind a list a data frames</p></a></li>
<li><a href='#evgam'><p>Fitting generalised additive extreme-value family models</p></a></li>
<li><a href='#extremal'><p>Estimate extremal index using &lsquo;intervals&rsquo; method</p></a></li>
<li><a href='#FCtmax'><p>Fort Collins, Colorado, US daily max. temperatures</p></a></li>
<li><a href='#fitted.evgam'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#fremantle'><p>Annual Maximum Sea Levels at Fremantle, Western Australia</p></a></li>
<li><a href='#logLik.evgam'><p>Log-likelihood, AIC and BIC from a fitted <code>evgam</code> object</p></a></li>
<li><a href='#pinv'><p>Moore-Penrose pseudo-inverse of a matrix</p></a></li>
<li><a href='#plot.evgam'><p>Plot a fitted <code>evgam</code> object</p></a></li>
<li><a href='#predict.evgam'><p>Predictions from a fitted <code>evgam</code> object</p></a></li>
<li><a href='#print.evgam'><p>Print a fitted <code>evgam</code> object</p></a></li>
<li><a href='#qev'><p>Quantile estimation of a composite extreme value distribution</p></a></li>
<li><a href='#runmax'><p>Running maximum</p></a></li>
<li><a href='#seq_between'><p>More Sequence Generation</p></a></li>
<li><a href='#simulate.evgam'><p>Simulations from a fitted <code>evgam</code> object</p></a></li>
<li><a href='#summary.evgam'><p>Summary method for a fitted <code>evgam</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalised Additive Extreme Value Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Youngman</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Youngman &lt;b.youngman@exeter.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for fitting various extreme value distributions with parameters of 
      generalised additive model (GAM) form are provided. For details of distributions 
      see Coles, S.G. (2001) &lt;<a href="https://doi.org/10.1007%2F978-1-4471-3675-0">doi:10.1007/978-1-4471-3675-0</a>&gt;, GAMs see Wood, S.N. (2017) 
      &lt;<a href="https://doi.org/10.1201%2F9781315370279">doi:10.1201/9781315370279</a>&gt;, and the fitting approach see Wood, S.N., Pya, N. &amp; 
      Safken, B. (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1180986">doi:10.1080/01621459.2016.1180986</a>&gt;. Details of how evgam works
      and various examples are given in Youngman, B.D. (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v103.i03">doi:10.18637/jss.v103.i03</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8.3), mgcv</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-28 11:07:30 UTC; ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-28 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colplot'>Scatter plot, with variable-based point colours</h2><span id='topic+colplot'></span>

<h3>Description</h3>

<p>Scatter plot, with variable-based point colours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colplot(
  x,
  y,
  z,
  n = 20,
  z.lim = NULL,
  breaks = NULL,
  palette = heat.colors,
  rev = TRUE,
  pch = 21,
  add = FALSE,
  ...,
  legend = FALSE,
  n.legend = 6,
  legend.pretty = TRUE,
  legend.plot = TRUE,
  legend.x,
  legend.y = NULL,
  legend.horiz = FALSE,
  legend.bg = par("bg")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colplot_+3A_x">x</code></td>
<td>
<p>a vector of x coordinates</p>
</td></tr>
<tr><td><code id="colplot_+3A_y">y</code></td>
<td>
<p>a vector of y coordinates</p>
</td></tr>
<tr><td><code id="colplot_+3A_z">z</code></td>
<td>
<p>a variable for defining colours</p>
</td></tr>
<tr><td><code id="colplot_+3A_n">n</code></td>
<td>
<p>an integer giving the number of colour levels, supplied to <a href="base.html#topic+pretty">pretty</a></p>
</td></tr>
<tr><td><code id="colplot_+3A_z.lim">z.lim</code></td>
<td>
<p>xxx</p>
</td></tr>
<tr><td><code id="colplot_+3A_breaks">breaks</code></td>
<td>
<p>a vector or breaks for defining color intervals; defaults to <code>NULL</code>, so <a href="base.html#topic+pretty">pretty</a> and <code>n</code> are used on <code>z</code></p>
</td></tr>
<tr><td><code id="colplot_+3A_palette">palette</code></td>
<td>
<p>a function for the color palette, or colors between <code>breaks</code>; defaults to <a href="grDevices.html#topic+heat.colors">heat.colors</a></p>
</td></tr>
<tr><td><code id="colplot_+3A_rev">rev</code></td>
<td>
<p>logical: should the palette be reversed? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="colplot_+3A_pch">pch</code></td>
<td>
<p>an integer giving the plotting character, supplied to <a href="graphics.html#topic+plot">plot</a></p>
</td></tr>
<tr><td><code id="colplot_+3A_add">add</code></td>
<td>
<p>should this be added to an existing plot? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="colplot_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="graphics.html#topic+plot">plot</a></p>
</td></tr>
<tr><td><code id="colplot_+3A_legend">legend</code></td>
<td>
<p>should a legend be added? Defaults to codeFALSE</p>
</td></tr>
<tr><td><code id="colplot_+3A_n.legend">n.legend</code></td>
<td>
<p>an integer giving the approximate number of legend entries; defaults to 6</p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.pretty">legend.pretty</code></td>
<td>
<p>logical: should the legend values produced by \[base]pretty? Othewrwise they are exact. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.plot">legend.plot</code></td>
<td>
<p>passed to <a href="graphics.html#topic+legend">legend</a>'s <code>plot</code> argument</p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.x">legend.x</code></td>
<td>
<p>passed to <a href="graphics.html#topic+legend">legend</a>'s <code>x</code> argument</p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.y">legend.y</code></td>
<td>
<p>passed to <a href="graphics.html#topic+legend">legend</a>'s <code>y</code> argument</p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.horiz">legend.horiz</code></td>
<td>
<p>passed to <a href="graphics.html#topic+legend">legend</a>'s <code>horiz</code> argument</p>
</td></tr>
<tr><td><code id="colplot_+3A_legend.bg">legend.bg</code></td>
<td>
<p>passed to <a href="graphics.html#topic+legend">legend</a>'s <code>bg</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- runif(50)
y &lt;- runif(50)
colplot(x, y, x * y)
colplot(x, y, x * y, legend=TRUE, legend.x="bottomleft")
colplot(x, y, x * y, legend=TRUE, legend.pretty=FALSE, n.legend=10, 
  legend.x="bottomleft", legend.horiz=TRUE)

</code></pre>

<hr>
<h2 id='COprcp'>Colorado daily precipitation accumulations</h2><span id='topic+COprcp'></span><span id='topic+COprcp_meta'></span><span id='topic+COelev'></span>

<h3>Description</h3>

<p>Three objects: 1) <code>COprcp</code>, a 404,326-row
data frame with columns <code>date</code>, <code>prcp</code> and <code>meta_row</code>;
2) <code>COprcp_meta</code>, a 64-row data frame, with meta data for 64 stations.
3) <code>COelev</code>, a list of elevation for the domain at 0.02 x 0.02
degree resolution. Precipitation amounts are only given for April
to October in the years 1990 - 2019. The domain has a longitude range
of [-106, -104] and a latitude range [37, 41]. These choices reflect
the analysis of Cooley et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(COprcp) # loads all three objects
</code></pre>


<h3>Format</h3>

<p>A data frame with 2383452 rows and 8 variables
</p>
<p>The variables are as follows:
</p>

<dl>
<dt>date</dt><dd><p>date of observation</p>
</dd>
<dt>prcp</dt><dd><p>daily rainfall accumulation in mm</p>
</dd>
<dt>meta_row</dt><dd><p>an identifier for the row in COprcp_meta; see &lsquo;Examples&rsquo;</p>
</dd>
<dt>lon</dt><dd><p>longitude of station</p>
</dd>
<dt>lat</dt><dd><p>latitude of station</p>
</dd>
<dt>elev</dt><dd><p>elevation of station in metres</p>
</dd>
<dt>id</dt><dd><p>GHCDN identifier</p>
</dd>
</dl>



<h3>References</h3>

<p>Cooley, D., Nychka, D., &amp; Naveau, P. (2007). Bayesian spatial modeling of 
extreme precipitation return levels. Journal of the American Statistical 
Association, 102(479), 824-840.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(evgam)
data(COprcp)

brks &lt;- pretty(COelev$z, 50)
image(COelev, breaks=brks, col=rev(heat.colors(length(brks[-1]))))
colplot(COprcp_meta$lon, COprcp_meta$lat, COprcp_meta$elev, breaks=brks, add=TRUE)

</code></pre>

<hr>
<h2 id='dfbind'>Bind a list a data frames</h2><span id='topic+dfbind'></span>

<h3>Description</h3>

<p>Bind a list a data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfbind(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfbind_+3A_x">x</code></td>
<td>
<p>a list of data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+rbind">rbind</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- list(data.frame(x=1, y=1), data.frame(x=2, y=2))
dfbind(z)

</code></pre>

<hr>
<h2 id='evgam'>Fitting generalised additive extreme-value family models</h2><span id='topic+evgam'></span><span id='topic+fevgam'></span>

<h3>Description</h3>

<p>Function <code>evgam</code> fits generalised additive extreme-value models. It allows 
the fitting of various extreme-value models, including the generalised 
extreme value and Pareto distributions. It can also perform quantile regression
via the asymmetric Laplace dsitribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evgam(
  formula,
  data,
  family = "gev",
  correctV = TRUE,
  rho0 = 0,
  inits = NULL,
  outer = "bfgs",
  control = NULL,
  removeData = FALSE,
  trace = 0,
  knots = NULL,
  maxdata = 1e+20,
  maxspline = 1e+20,
  compact = FALSE,
  ald.args = list(),
  exi.args = list(),
  pp.args = list(),
  sandwich.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evgam_+3A_formula">formula</code></td>
<td>
<p>a list of formulae for location, scale and shape parameters, as in <a href="mgcv.html#topic+gam">gam</a></p>
</td></tr>
<tr><td><code id="evgam_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="evgam_+3A_family">family</code></td>
<td>
<p>a character string giving the type of family to be fitted; defaults to <code>"gev"</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_correctv">correctV</code></td>
<td>
<p>logicial: should the variance-covariance matrix include smoothing parameter uncertainty? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_rho0">rho0</code></td>
<td>
<p>a scalar or vector of initial log smoothing parameter values; a scalar will be repeated if there are multiple smoothing terms</p>
</td></tr>
<tr><td><code id="evgam_+3A_inits">inits</code></td>
<td>
<p>a vector or list giving initial values for constant basis coefficients; if a list, a grid is formed using <a href="base.html#topic+expand.grid">expand.grid</a>, and the &lsquo;best&rsquo; used; defaults to <code>NULL</code>, so initial values are automatically found</p>
</td></tr>
<tr><td><code id="evgam_+3A_outer">outer</code></td>
<td>
<p>a character string specifying the outer optimiser is full <code>"Newton"</code>, <code>"BFGS"</code> or uses finite differences, <code>"FD"</code>; defaults to <code>"BFGS"</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_control">control</code></td>
<td>
<p>a list of lists of control parameters to pass to inner and outer optimisers; defaults to <code>evgam.control()</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_removedata">removeData</code></td>
<td>
<p>logical: should <code>data</code> be removed from <code>evgam</code> object? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_trace">trace</code></td>
<td>
<p>an integer specifying the amount of information supplied about fitting, with <code>-1</code> suppressing all output; defaults to <code>0</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_knots">knots</code></td>
<td>
<p>passed to <a href="mgcv.html#topic+s">s</a>; defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_maxdata">maxdata</code></td>
<td>
<p>an integer specifying the maximum number of <code>data</code> rows. <code>data</code> is sampled if its number of rows exceeds <code>maxdata</code>; defaults to <code>1e20</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_maxspline">maxspline</code></td>
<td>
<p>an integer specifying the maximum number of <code>data</code> rows used for spline construction; defaults to <code>1e20</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_compact">compact</code></td>
<td>
<p>logical: should duplicated <code>data</code> rows be compacted? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="evgam_+3A_ald.args">ald.args</code></td>
<td>
<p>a list of arguments for <code>family="ald"</code>; see Details</p>
</td></tr>
<tr><td><code id="evgam_+3A_exi.args">exi.args</code></td>
<td>
<p>a list of arguments for <code>family="exi"</code>; see Details</p>
</td></tr>
<tr><td><code id="evgam_+3A_pp.args">pp.args</code></td>
<td>
<p>a list of arguments for <code>family="pp"</code>; see Details</p>
</td></tr>
<tr><td><code id="evgam_+3A_sandwich.args">sandwich.args</code></td>
<td>
<p>a list of arguments for sandwich adjustment; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following families are currently available: <code>"ald"</code>, the asymmetric Laplace distribution,
primarily intended for quantile regression, as in Yu &amp; Moyeed (2001); <code>"gev"</code> (default), the
generalised extreme valued distribution; <code>"exp"</code>, the exponential distribution; <code>"gpd"</code>,
the generalised Pareto distribution; <code>"gauss"</code>, the Gaussian distribution; <code>"pp"</code>, the 
point process model for extremes, implemented through <code class="reqn">r</code>-largest order statistics; <code>"weibull"</code>, the Weibull distribution; <code>"exi"</code>, estimation if the
extremal index, as in Schlather &amp; Tawn (2003).
</p>
<p>Arguments for the asymmetric Laplace distribution are given by <code>ald.args</code>. A 
scalar <code>tau</code> defines the quantile sought, which has no default. The scalar
<code>C</code> specifies the curvature parameter of Oh et al. (2011).
</p>
<p>Arguments for extremal index estimation are given by <code>exi.args</code>. A character
string <code>id</code> specifies the variable in <code>data</code>over which an <code>nexi</code>
(default 2) running max. has been taken. The <code>link</code> is specified as a character string,
which is one of <code>"logistic"</code>, <code>"probit"</code>, <code>"cloglog"</code>; defaults to <code>"logistic"</code>.
</p>
<p>Arguments for the point process model are given by <code>pp.args</code>. An integer <code>r</code>
specifies the number of order statistics from which the model will be estimated.
If <code>r = -1</code>, all <code>data</code> will be used. The character string <code>id</code> specifies the variable 
in <code>data</code> over which the point process isn't integrated; e.g. if a map 
of parameter estimates related to extremes over time is sought, integration isn't 
over locations. The scalar <code>nper</code> number of data per period of interest; scalar or
integer vector <code>ny</code> specifies the number of periods; if <code>length(ny) &gt; 1</code>
then <code>names(ny)</code> must ne supplied and must match to every unique <code>id</code>. 
logical <code>correctny</code> specifies whether <code>ny</code> is 
corrected to adjust proportionally for data missingness.
</p>
<p>Arguments for the sandwich adjustment are given by <code>sandwich.args</code>. A character
string <code>id</code> can be supplied to the list, which identifies the name of the 
variable in <code>data</code> such that independence will be assumed between its values. The
<code>method</code> for the adjustment is supplied as <code>"magnitude"</code> (default) or <code>"curvature"</code>;
see Chandler &amp; Bate (2007) for their definitions.
</p>


<h3>Value</h3>

<p>An object of class <code>evgam</code>
</p>


<h3>References</h3>

<p>Chandler, R. E., &amp; Bate, S. (2007). Inference for clustered data
using the independence loglikelihood. Biometrika, 94(1), 167-183.
</p>
<p>Oh, H. S., Lee, T. C., &amp; Nychka, D. W. (2011). Fast nonparametric 
quantile regression with arbitrary smoothing methods. Journal of 
Computational and Graphical Statistics, 20(2), 510-526.
</p>
<p>Schlather, M., &amp; Tawn, J. A. (2003). A dependence measure for multivariate and 
spatial extreme values: Properties and inference. Biometrika, 90(1), 139-156.
</p>
<p>Wood, S. N., Pya, N., &amp; Safken, B. (2016). Smoothing parameter and model 
selection for general smooth models. Journal of the American Statistical 
Association, 111(516), 1548-1563.
</p>
<p>Youngman, B. D. (2022). evgam: An R Package for Generalized Additive Extreme
Value Modules. Journal of Statistical Software. To appear. <a href="https://doi.org/10.18637/jss.v103.i03">doi:10.18637/jss.v103.i03</a>
</p>
<p>Yu, K., &amp; Moyeed, R. A. (2001). Bayesian quantile regression. 
Statistics &amp; Probability Letters, 54(4), 437-447.
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.evgam">predict.evgam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")



data(COprcp)

## fit generalised Pareto distribution to excesses on 20mm

COprcp &lt;- cbind(COprcp, COprcp_meta[COprcp$meta_row,])
threshold &lt;- 20
COprcp$excess &lt;- COprcp$prcp - threshold
COprcp_gpd &lt;- subset(COprcp, excess &gt; 0)
fmla_gpd &lt;- list(excess ~ s(lon, lat, k=12) + s(elev, k=5, bs="cr"), ~ 1)
m_gpd &lt;- evgam(fmla_gpd, data=COprcp_gpd, family="gpd")

## fit generalised extreme value distribution to annual maxima

COprcp$year &lt;- format(COprcp$date, "%Y")
COprcp_gev &lt;- aggregate(prcp ~ year + meta_row, COprcp, max)
COprcp_gev &lt;- cbind(COprcp_gev, COprcp_meta[COprcp_gev$meta_row,])
fmla_gev2 &lt;- list(prcp ~ s(lon, lat, k=30) + s(elev, bs="cr"), ~ s(lon, lat, k=20), ~ 1)
m_gev2 &lt;- evgam(fmla_gev2, data=COprcp_gev, family="gev")
summary(m_gev2)
plot(m_gev2)
predict(m_gev2, newdata=COprcp_meta, type="response")

## fit point process model using r-largest order statistics

# we have `ny=30' years' data and use top 45 order statistics
pp_args &lt;- list(id="id", ny=30, r=45)
m_pp &lt;- evgam(fmla_gev2, COprcp, family="pp", pp.args=pp_args)

## estimate 0.98 quantile using asymmetric Laplace distribution

fmla_ald &lt;- prcp ~ s(lon, lat, k=15) + s(elev, bs="cr")
m_ald &lt;- evgam(fmla_ald, COprcp, family="ald", ald.args=list(tau=.98))



</code></pre>

<hr>
<h2 id='extremal'>Estimate extremal index using &lsquo;intervals&rsquo; method</h2><span id='topic+extremal'></span>

<h3>Description</h3>

<p>Estimate extremal index using &lsquo;intervals&rsquo; method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extremal(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremal_+3A_x">x</code></td>
<td>
<p>a logical vector or list of logical vectors</p>
</td></tr>
<tr><td><code id="extremal_+3A_y">y</code></td>
<td>
<p>an integer vector the same length as <code>x</code>; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals estimator of extremal index based on Ferro and Segers (2003)'s moment-based estimator.
</p>
<p>If <code>x</code> is supplied and <code>y</code> is not, <code>x</code> is assumed to identify consecutive threshold exceedances.
If <code>x</code> is supplied as a list, each list element is assumed to comprise identifiers of consecutive exceedances.
If <code>y</code> is supplied, <code>x</code> must be a logical vector, and <code>y</code> gives positions of <code>x</code> in
its original with-missing-values vector: so <code>y</code> identifies consecutive <code>x</code>.
</p>


<h3>Value</h3>

<p>A scalar estimate of the extremal index
</p>


<h3>References</h3>

<p>Ferro, C. A., &amp; Segers, J. (2003). Inference for clusters of extreme values. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 65(2), 545-556.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1e2
x &lt;- runif(n)
extremal(x &gt; .9)

y &lt;- sort(sample(n, n - 5))
x2 &lt;- x[y]
extremal(x2 &gt; .9, y)

</code></pre>

<hr>
<h2 id='FCtmax'>Fort Collins, Colorado, US daily max. temperatures</h2><span id='topic+FCtmax'></span>

<h3>Description</h3>

<p>Daily maximum temperatures at Fort Collins, Colorado, US 
from 1st January 1970 to 31st December 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FCtmax)
</code></pre>


<h3>Format</h3>

<p>A data frame with 18156 rows and 2 variables
</p>
<p>The variables are as follows:
</p>

<dl>
<dt>date</dt><dd><p>date of observation</p>
</dd>
<dt>tmax</dt><dd><p>daily maximum temperature in degrees Celcius</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
library(evgam)
data(FCtmax)
</code></pre>

<hr>
<h2 id='fitted.evgam'>Extract Model Fitted Values</h2><span id='topic+fitted.evgam'></span>

<h3>Description</h3>

<p>Extract Model Fitted Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.evgam_+3A_object">object</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="fitted.evgam_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values extracted from the object &lsquo;object&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
fitted(m_gev)

</code></pre>

<hr>
<h2 id='fremantle'>Annual Maximum Sea Levels at Fremantle, Western Australia</h2><span id='topic+fremantle'></span>

<h3>Description</h3>

<p>The 'fremantle' data frame has 86 rows and 3 columns.  The second
column gives 86 annual maximimum sea levels recorded at Fremantle,
Western Australia, within the period 1897 to 1989.  The first
column gives the corresponding years.  The third column gives
annual mean values of the Southern Oscillation Index (SOI), which
is a proxy for meteorological volitility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fremantle)
</code></pre>


<h3>Format</h3>

<p>A data frame with 86 rows and 3 variables
</p>
<p>The variables are as follows:
</p>

<dl>
<dt>Year</dt><dd><p>a numeric vector of years</p>
</dd>
<dt>SeaLevel</dt><dd><p>a numeric vector of annual sea level maxima</p>
</dd>
<dt>SOI</dt><dd><p>A numeric vector of annual mean values of the Southern Oscillation Index</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001) _An Introduction to Statistical Modelling of
Extreme Values. London: Springer.
</p>
<p>Eric Gilleland's ismev R package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(evgam)
data(fremantle)
</code></pre>

<hr>
<h2 id='logLik.evgam'>Log-likelihood, AIC and BIC from a fitted <code>evgam</code> object</h2><span id='topic+logLik.evgam'></span>

<h3>Description</h3>

<p>Log-likelihood, AIC and BIC from a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.evgam_+3A_object">object</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="logLik.evgam_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
logLik(m_gev)
AIC(m_gev)
BIC(m_gev)

</code></pre>

<hr>
<h2 id='pinv'>Moore-Penrose pseudo-inverse of a matrix</h2><span id='topic+pinv'></span><span id='topic+ginv.evgam'></span>

<h3>Description</h3>

<p>Moore-Penrose pseudo-inverse of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinv(x, tol = -1)

ginv.evgam(x, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pinv_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="pinv_+3A_tol">tol</code></td>
<td>
<p>a scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is merely a wrapper for Armadillo's pinv function with its
default settings, which, in particular uses the divide-and-conquer
method. If <code>tol</code> isn't provided Armadillo's default for pinv is used.
<code>ginv.evgam</code> mimics <a href="MASS.html#topic+ginv">ginv</a> using Armadillo's pinv.
</p>


<h3>Value</h3>

<p>A matrix
</p>


<h3>References</h3>

<p>http://arma.sourceforge.net/docs.html#pinv
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+ginv">ginv</a>
</p>

<hr>
<h2 id='plot.evgam'>Plot a fitted <code>evgam</code> object</h2><span id='topic+plot.evgam'></span>

<h3>Description</h3>

<p>Plot a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
plot(x, onepage = TRUE, which = NULL, main, ask = !onepage, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evgam_+3A_x">x</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="plot.evgam_+3A_onepage">onepage</code></td>
<td>
<p>logical: should all plots be on one page, or on separate pages? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.evgam_+3A_which">which</code></td>
<td>
<p>a vector of integers identifying which smooths to plot. The default <code>NULL</code> plots all smooths</p>
</td></tr>
<tr><td><code id="plot.evgam_+3A_main">main</code></td>
<td>
<p>a character string or vector of plot titles for each plot. If not supplied default titles are used</p>
</td></tr>
<tr><td><code id="plot.evgam_+3A_ask">ask</code></td>
<td>
<p>logical: ask to show next plots if too many figures for current device?</p>
</td></tr>
<tr><td><code id="plot.evgam_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <a href="mgcv.html#topic+plot.gam">plot.gam</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots representing all one- or two-dimensional smooths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
plot(m_gev)

</code></pre>

<hr>
<h2 id='predict.evgam'>Predictions from a fitted <code>evgam</code> object</h2><span id='topic+predict.evgam'></span>

<h3>Description</h3>

<p>Predictions from a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
predict(
  object,
  newdata,
  type = "link",
  prob = NULL,
  se.fit = FALSE,
  marginal = TRUE,
  exi = FALSE,
  trace = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.evgam_+3A_object">object</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_newdata">newdata</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_type">type</code></td>
<td>
<p>a character string giving the type of prediction sought; see Details. Defaults to <code>"link"</code></p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_prob">prob</code></td>
<td>
<p>a scalar or vector of probabilities for quantiles to be estimated if <code>type == "quantile"</code>; defaults to 0.5</p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_se.fit">se.fit</code></td>
<td>
<p>a logical: should estimated standard errors be returned? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_marginal">marginal</code></td>
<td>
<p>a logical: should uncertainty estimates integrate out smoothing parameter uncertainty? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_exi">exi</code></td>
<td>
<p>a logical: if a dependent GEV is fitted should the independent parameters be returned? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_trace">trace</code></td>
<td>
<p>an integer where higher values give more output. -1 suppresses everything. Defaults to 0</p>
</td></tr>
<tr><td><code id="predict.evgam_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are five options for <code>type</code>: 1) <code>"link"</code> distribution parameters 
transformed to their model fitting scale; 2) <code>"response"</code> as 1), but on their 
original scale; 3) &quot;lpmatrix&quot; a list of design matrices; 4) &quot;quantile&quot;
estimates of distribution quantile(s); and 5) &quot;qqplot&quot; a quantile-quantile
plot.
</p>


<h3>Value</h3>

<p>A data frame or list of predictions, or a plot if <code>type == "qqplot"</code>
</p>


<h3>References</h3>

<p>Youngman, B. D. (2022). evgam: An R Package for Generalized Additive Extreme
Value Modules. Journal of Statistical Software. To appear. <a href="https://doi.org/10.18637/jss.v103.i03">doi:10.18637/jss.v103.i03</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
# prediction of link GEV parameter for fremantle data
predict(m_gev)
# predictions for Year 1989
y1989 &lt;- data.frame(Year = 1989)
# link GEV parameter predictions
predict(m_gev, y1989)
# GEV parameter predictions
predict(m_gev, y1989, type= "response")
# 10-year return level predictions
predict(m_gev, y1989, type= "quantile", prob = .9)
# 10- and 100-year return level predictions
predict(m_gev, y1989, type= "quantile", prob = c(.9, .99))

</code></pre>

<hr>
<h2 id='print.evgam'>Print a fitted <code>evgam</code> object</h2><span id='topic+print.evgam'></span>

<h3>Description</h3>

<p>Print a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evgam_+3A_x">x</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="print.evgam_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The call of the <code>evgam</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
print(m_gev)

</code></pre>

<hr>
<h2 id='qev'>Quantile estimation of a composite extreme value distribution</h2><span id='topic+qev'></span>

<h3>Description</h3>

<p>Quantile estimation of a composite extreme value distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qev(
  p,
  loc,
  scale,
  shape,
  m = 1,
  alpha = 1,
  theta = 1,
  family,
  tau = 0,
  start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qev_+3A_p">p</code></td>
<td>
<p>a scalar giving the quantile of the distribution sought</p>
</td></tr>
<tr><td><code id="qev_+3A_loc">loc</code></td>
<td>
<p>a scalar, vector or matrix giving the location parameter</p>
</td></tr>
<tr><td><code id="qev_+3A_scale">scale</code></td>
<td>
<p>as above, but scale parameter</p>
</td></tr>
<tr><td><code id="qev_+3A_shape">shape</code></td>
<td>
<p>as above, but shape parameter</p>
</td></tr>
<tr><td><code id="qev_+3A_m">m</code></td>
<td>
<p>a scalar giving the number of values per return period unit, e.g. 365 for daily data giving annual return levels</p>
</td></tr>
<tr><td><code id="qev_+3A_alpha">alpha</code></td>
<td>
<p>a scalar, vector or matrix of weights if within-block variables not identically distributed and of different frequencies</p>
</td></tr>
<tr><td><code id="qev_+3A_theta">theta</code></td>
<td>
<p>a scalar, vector or matrix of extremal index values</p>
</td></tr>
<tr><td><code id="qev_+3A_family">family</code></td>
<td>
<p>a character string giving the family for which return levels sought</p>
</td></tr>
<tr><td><code id="qev_+3A_tau">tau</code></td>
<td>
<p>a scalar, vector or matrix of values giving the threshold quantile for the GPD (i.e. 1 - probability of exceedance)</p>
</td></tr>
<tr><td><code id="qev_+3A_start">start</code></td>
<td>
<p>a 2-vector giving starting values that bound the return level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">F</code> is the generalised extreme value or generalised Pareto
distribution, <code>qev</code> solves 
</p>
<p style="text-align: center;"><code class="reqn">\prod_{j=1}^n \big\{F(z)\}^{m \alpha_j \theta_j} = p.</code>
</p>

<p>For both distributions, location, scale and shape parameters 
are given by <code>loc</code>, <code>scale</code> and <code>shape</code>. The 
generalised Pareto distribution, for <code class="reqn">\xi \neq 0</code> and <code class="reqn">z &gt; u</code>, 
is parameterised as <code class="reqn">1 - (1 - \tau) [1 + \xi (z - u) / \psi_u]^{-1/\xi}</code>,
where <code class="reqn">u</code>, <code class="reqn">\psi_u</code> and <code class="reqn">\xi</code> are its location, scale and shape
parameters, respectively, and <code class="reqn">\tau</code> corresponds to argument <code>tau</code>.
</p>


<h3>Value</h3>

<p>A scalar or vector of estimates of <code>p</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qev(0.9, c(1, 2), c(1, 1.1), .1, family="gev")
qev(0.99, c(1, 2), c(1, 1.1), .1, family="gpd", tau=0.9)

</code></pre>

<hr>
<h2 id='runmax'>Running maximum</h2><span id='topic+runmax'></span><span id='topic+dfrunmax'></span>

<h3>Description</h3>

<p>Running <code class="reqn">n</code>-value maximum and data frame with variable swapped for running maximum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runmax(y, n)

dfrunmax(data, cons, ynm, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runmax_+3A_y">y</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="runmax_+3A_n">n</code></td>
<td>
<p>an integer giving the number of observations to calculate running maxmimum over; defaults to 2</p>
</td></tr>
<tr><td><code id="runmax_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="runmax_+3A_cons">cons</code></td>
<td>
<p>a character string for the variable in <code>data</code> that identifies consecutive observations</p>
</td></tr>
<tr><td><code id="runmax_+3A_ynm">ynm</code></td>
<td>
<p>a character string for the variable in <code>data</code> that is the observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>runmax</code> returns a vector of the same dimension as <code>y</code>
</p>
<p><code>dfrunmax</code> returns a data frame with observations swapped for <code class="reqn">n</code>-observation running maximum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runmax(runif(10), 5)

</code></pre>

<hr>
<h2 id='seq_between'>More Sequence Generation</h2><span id='topic+seq_between'></span>

<h3>Description</h3>

<p>Generate a sequence of values between a range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_between(x, length = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_between_+3A_x">x</code></td>
<td>
<p>a 2-vector</p>
</td></tr>
<tr><td><code id="seq_between_+3A_length">length</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+seq">seq</a>, <a href="base.html#topic+seq_len">seq_len</a>, <a href="base.html#topic+seq_along">seq_along</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seq_between(c(1, 9))
seq_between(range(runif(10)), 5)

</code></pre>

<hr>
<h2 id='simulate.evgam'>Simulations from a fitted <code>evgam</code> object</h2><span id='topic+simulate.evgam'></span>

<h3>Description</h3>

<p>Simulations from a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
simulate(
  object,
  nsim = 1000,
  seed = NULL,
  newdata,
  type = "link",
  probs = NULL,
  threshold = 0,
  marginal = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.evgam_+3A_object">object</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_nsim">nsim</code></td>
<td>
<p>an integer giving the number of simulations</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_seed">seed</code></td>
<td>
<p>an integer giving the seed for simulations</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_newdata">newdata</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_type">type</code></td>
<td>
<p>a character string, as in <code>predict.evgam</code>; defaults to <code>"quantile"</code></p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_probs">probs</code></td>
<td>
<p>a scalar or vector of probabilities for quantiles; defaults to NULL</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_threshold">threshold</code></td>
<td>
<p>a scalar, vector or matrix, which is added to each simulation if <code>family == "gpd"</code>; defaults to 0</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_marginal">marginal</code></td>
<td>
<p>a logical: should simulations integrate out smoothing parameter uncertainty? Defaults to TRUE</p>
</td></tr>
<tr><td><code id="simulate.evgam_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>predict.evgam</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulations of parameters or quantiles
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.evgam">predict.evgam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
# simulations of link GEV parameters for fremantle data
simulate(m_gev, nsim=5)
# simulations for Year 1989
y1989 &lt;- data.frame(Year = 1989)
# link GEV parameter simulations
simulate(m_gev, nsim=5, newdata = y1989)
# GEV parameter simulations
simulate(m_gev, nsim=5, newdata = y1989, type = "response")
# 10-year return level simulations
simulate(m_gev, nsim=5, newdata = y1989, type= "quantile", prob = .9)
# 10- and 100-year return level simulations
simulate(m_gev, nsim=5, newdata = y1989, type= "quantile", prob = c(.9, .99))

</code></pre>

<hr>
<h2 id='summary.evgam'>Summary method for a fitted <code>evgam</code> object</h2><span id='topic+summary.evgam'></span><span id='topic+print.summary.evgam'></span>

<h3>Description</h3>

<p>Summary method for a fitted <code>evgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evgam'
summary(object, ...)

## S3 method for class 'summary.evgam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.evgam_+3A_object">object</code></td>
<td>
<p>a fitted <code>evgam</code> object</p>
</td></tr>
<tr><td><code id="summary.evgam_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="summary.evgam_+3A_x">x</code></td>
<td>
<p>a <code>summary.evgam</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key part of summary.evgam is p-values for smooths.
The tests use code directly taken from <code>mgcv 1.8-14</code>. This is 
to avoid use of <code>mgcv:::...</code> . Tests implement the method of
Wood (2013).
</p>


<h3>Value</h3>

<p>A <code>summary.evgam</code> object
</p>


<h3>References</h3>

<p>Wood, S. N., (2013) On p-values for smooth components of an extended
generalized additive model, Biometrika 100(1) 221&ndash;228
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fremantle)
fmla_gev &lt;- list(SeaLevel ~ s(Year, k=5, bs="cr"), ~ 1, ~ 1)
m_gev &lt;- evgam(fmla_gev, fremantle, family = "gev")
summary(m_gev)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
