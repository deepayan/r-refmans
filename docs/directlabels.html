<!DOCTYPE html><html><head><title>Help for package directlabels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {directlabels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ahull.grid'><p>ahull grid</p></a></li>
<li><a href='#ahull.points'><p>ahull points</p></a></li>
<li><a href='#angled.boxes'><p>angled boxes</p></a></li>
<li><a href='#angled.endpoints'><p>angled endpoints</p></a></li>
<li><a href='#apply.method'><p>Apply a Positioning Method</p></a></li>
<li><a href='#big.boxes'><p>big boxes</p></a></li>
<li><a href='#bottom.pieces'><p>bottom pieces</p></a></li>
<li><a href='#bottom.points'><p>bottom points</p></a></li>
<li><a href='#bottom.polygons'><p>bottom polygons</p></a></li>
<li><a href='#bumpup'><p>bumpup</p></a></li>
<li><a href='#calc.borders'><p>calc borders</p></a></li>
<li><a href='#calc.boxes'><p>calc boxes</p></a></li>
<li><a href='#check.for.columns'><p>check for columns</p></a></li>
<li><a href='#chull.grid'><p>chull grid</p></a></li>
<li><a href='#chull.points'><p>chull points</p></a></li>
<li><a href='#default.ahull'><p>default ahull</p></a></li>
<li><a href='#default.picker'><p>default picker</p></a></li>
<li><a href='#defaultpf.ggplot'><p>defaultpf ggplot</p></a></li>
<li><a href='#defaultpf.trellis'><p>defaultpf trellis</p></a></li>
<li><a href='#direct.label'><p>Direct labels for color decoding</p></a></li>
<li><a href='#direct.label.ggplot'><p>direct label ggplot</p></a></li>
<li><a href='#direct.label.trellis'><p>direct label trellis</p></a></li>
<li><a href='#dl.combine'><p>Combine output of several methods</p></a></li>
<li><a href='#dl.env'><p>dl env</p></a></li>
<li><a href='#dl.jitter'><p>dl jitter</p></a></li>
<li><a href='#dl.move'><p>Manually move a direct label</p></a></li>
<li><a href='#dl.summarize'><p>dl summarize</p></a></li>
<li><a href='#dl.trans'><p>Direct label data transform</p></a></li>
<li><a href='#dlcompare'><p>Direct label comparison plot</p></a></li>
<li><a href='#dldoc'><p>Make directlabels documentation</p></a></li>
<li><a href='#dlgrob'><p>dlgrob</p></a></li>
<li><a href='#draw.polygons'><p>draw polygons</p></a></li>
<li><a href='#draw.rects'><p>draw rects</p></a></li>
<li><a href='#drawDetails.dlgrob'><p>drawDetails dlgrob</p></a></li>
<li><a href='#edges.to.outside'><p>edges to outside</p></a></li>
<li><a href='#empty.grid'><p>empty grid</p></a></li>
<li><a href='#enlarge.box'><p>enlarge box</p></a></li>
<li><a href='#extract.plot'><p>Extract plot and definition for documentation</p></a></li>
<li><a href='#extract.posfun'><p>Extract Positioning Method for documentation</p></a></li>
<li><a href='#extreme.grid'><p>extreme grid</p></a></li>
<li><a href='#extreme.points'><p>extreme points</p></a></li>
<li><a href='#far.from.others.borders'><p>far from others borders</p></a></li>
<li><a href='#filltemplate'><p>filltemplate</p></a></li>
<li><a href='#first.bumpup'><p>first bumpup</p></a></li>
<li><a href='#first.points'><p>first points</p></a></li>
<li><a href='#first.polygons'><p>first polygons</p></a></li>
<li><a href='#first.qp'><p>first qp</p></a></li>
<li><a href='#gapply'><p>gapply</p></a></li>
<li><a href='#gapply.fun'><p>Direct label groups independently</p></a></li>
<li><a href='#geom_dl'><p>geom dl</p></a></li>
<li><a href='#GeomDl'><p>GeomDl</p></a></li>
<li><a href='#get.means'><p>get means</p></a></li>
<li><a href='#getLegendVariables'><p>getLegendVariables</p></a></li>
<li><a href='#ignore.na'><p>ignore na</p></a></li>
<li><a href='#in1box'><p>in1box</p></a></li>
<li><a href='#in1which'><p>in1which</p></a></li>
<li><a href='#inside'><p>inside</p></a></li>
<li><a href='#iris.l1.cluster'><p>Clustering of the iris data with the l1 clusterpath</p></a></li>
<li><a href='#label.endpoints'><p>label endpoints</p></a></li>
<li><a href='#label.pieces'><p>label pieces</p></a></li>
<li><a href='#lasso.labels'><p>lasso labels</p></a></li>
<li><a href='#last.bumpup'><p>last bumpup</p></a></li>
<li><a href='#last.points'><p>last points</p></a></li>
<li><a href='#last.polygons'><p>last polygons</p></a></li>
<li><a href='#last.qp'><p>last qp</p></a></li>
<li><a href='#lattice.translators'><p>lattice translators</p></a></li>
<li><a href='#left.points'><p>left points</p></a></li>
<li><a href='#left.polygons'><p>left polygons</p></a></li>
<li><a href='#legends2hide'><p>legends2hide</p></a></li>
<li><a href='#lines2'><p>lines2</p></a></li>
<li><a href='#LOPART.ROC'>
<p>ROC curve for LOPART algorithm and competitors</p></a></li>
<li><a href='#LOPART100'>
<p>Labeled Optimal Partitioning (LOPART) results</p></a></li>
<li><a href='#make.tiebreaker'><p>make tiebreaker</p></a></li>
<li><a href='#maxvar.points'><p>maxvar points</p></a></li>
<li><a href='#maxvar.qp'><p>maxvar qp</p></a></li>
<li><a href='#merge_recurse'><p>merge recurse</p></a></li>
<li><a href='#midrange'><p>midrange</p></a></li>
<li><a href='#normal.l2.cluster'>
<p>Clustering of some normal data in 2d with the l2 clusterpath</p></a></li>
<li><a href='#odd_timings'>
<p>Odd timings</p></a></li>
<li><a href='#only.unique.vals'><p>only unique vals</p></a></li>
<li><a href='#outside.ahull'><p>outside ahull</p></a></li>
<li><a href='#outside.chull'><p>outside chull</p></a></li>
<li><a href='#panel.superpose.dl'><p>panel superpose dl</p></a></li>
<li><a href='#pkgFun'><p>pkgFun</p></a></li>
<li><a href='#polygon.method'><p>polygon method</p></a></li>
<li><a href='#positioning.functions'><p>Built-in Positioning Methods for direct label placement</p></a></li>
<li><a href='#project.onto.segments'><p>project onto segments</p></a></li>
<li><a href='#projectionSeconds'>
<p>Timings of projection algorithms</p></a></li>
<li><a href='#qp.labels'><p>Make a Positioning Method for non-overlapping lineplot labels</p></a></li>
<li><a href='#reduce.cex'><p>reduce cex</p></a></li>
<li><a href='#reduce.cex.lr'><p>reduce cex lr</p></a></li>
<li><a href='#reduce.cex.tb'><p>reduce cex tb</p></a></li>
<li><a href='#rhtmlescape'><p>rhtmlescape</p></a></li>
<li><a href='#right.points'><p>right points</p></a></li>
<li><a href='#right.polygons'><p>right polygons</p></a></li>
<li><a href='#SegCost'>
<p>Cost of segmentation models</p></a></li>
<li><a href='#smart.grid'><p>smart grid</p></a></li>
<li><a href='#static.labels'><p>static labels</p></a></li>
<li><a href='#svmtrain'>
<p>False positive rates from several 1-SVM models</p></a></li>
<li><a href='#top.bumptwice'><p>top bumptwice</p></a></li>
<li><a href='#top.bumpup'><p>top bumpup</p></a></li>
<li><a href='#top.pieces'><p>top pieces</p></a></li>
<li><a href='#top.points'><p>top points</p></a></li>
<li><a href='#top.polygons'><p>top polygons</p></a></li>
<li><a href='#top.qp'><p>top qp</p></a></li>
<li><a href='#uselegend.ggplot'><p>uselegend ggplot</p></a></li>
<li><a href='#uselegend.trellis'><p>uselegend trellis</p></a></li>
<li><a href='#vertical.qp'><p>vertical qp</p></a></li>
<li><a href='#visualcenter'><p>visualcenter</p></a></li>
<li><a href='#xlimits'><p>xlimits</p></a></li>
<li><a href='#ylimits'><p>ylimits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Toby Dylan Hocking &lt;toby.hocking@r-project.org&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Toby Dylan Hocking</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.8.25</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tdhock/directlabels/issues">https://github.com/tdhock/directlabels/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Direct Labels for Multicolor Plots</td>
</tr>
<tr>
<td>Description:</td>
<td>An extensible framework
 for automatically placing direct labels onto multicolor 'lattice' or
 'ggplot2' plots.
 Label positions are described using Positioning Methods
 which can be re-used across several different plots.
 There are heuristics for examining "trellis" and "ggplot" objects
 and inferring an appropriate Positioning Method.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tdhock/directlabels">https://github.com/tdhock/directlabels</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, markdown, inlinedocs, RColorBrewer, ggplot2 (&ge;
2.0), rlang, lattice, alphahull, nlme, lars, latticeExtra,
dplyr, ggthemes, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid (&ge; 3.0.0), quadprog</td>
</tr>
<tr>
<td>Collate:</td>
<td>utility.function.R compare.R dotplot.R lineplot.R
densityplot.R ggplot2.R positioning.functions.R doc.R lattice.R
scatterplot.R contourplot.R</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 23:08:35 UTC; th798</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-01 08:30:06 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2024-01-02 07:14:33 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='ahull.grid'>ahull grid</h2><span id='topic+ahull.grid'></span>

<h3>Description</h3>

<p>Label the closest point on the alpha hull of the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"ahull.grid"</code></pre>

<hr>
<h2 id='ahull.points'>ahull points</h2><span id='topic+ahull.points'></span>

<h3>Description</h3>

<p>Calculate the points on the ashape.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ahull.points(d, ..., 
    ahull = default.ahull(d))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ahull.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="ahull.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
<tr><td><code id="ahull.points_+3A_ahull">ahull</code></td>
<td>
<p>ahull </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='angled.boxes'>angled boxes</h2><span id='topic+angled.boxes'></span>

<h3>Description</h3>

<p>Draw a box with the label <code><a href="directlabels.html#topic+inside">inside</a></code>, at the point furthest away from
the plot border and any other curve.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"angled.boxes"</code></pre>

<hr>
<h2 id='angled.endpoints'>angled endpoints</h2><span id='topic+angled.endpoints'></span>

<h3>Description</h3>

<p>Useful for labeling lines that all end at the top.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"angled.endpoints"</code></pre>

<hr>
<h2 id='apply.method'>Apply a Positioning Method</h2><span id='topic+apply.method'></span>

<h3>Description</h3>

<p>Run a Positioning Method list on a given data set. This function
contains all the logic for parsing a Positioning Method and
sequentially applying its elements to the input data to obtain the
label positions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.method(method, 
    d, columns.to.check = c("x", 
        "y", "groups", 
        "label"), ..., 
    debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply.method_+3A_method">method</code></td>
<td>
<p>Direct labeling Positioning Method. Starting from the data frame
of points to plot for the panel, the elements of the Positioning
Method list are applied in sequence, and then each row of the
resulting data frame is used to draw a direct label. The
elements of a Positioning Method list can be
</p>

<ul>
<li><p> a Positioning Function is any function(d,...) which takes a
data.frame <code>d</code> with columns x,y,groups and returns another
data.frame representing the positions of the desired direct
labels. For a description of all the columns that are interpreted
for drawing direct labels, see <code><a href="directlabels.html#topic+drawDetails.dlgrob">drawDetails.dlgrob</a></code>.
For example, <code><a href="directlabels.html#topic+maxvar.points">maxvar.points</a></code> is a Positioning Function that returns
a data.frame with columns x,y,groups,hjust,vjust.
</p>
</li>
<li><p> a character vector of length 1 is treated as the name of an
R object. For example, specifying &quot;maxvar.points&quot; means to look up
the variable called <code><a href="directlabels.html#topic+maxvar.points">maxvar.points</a></code> and use that. Using the name of
a Positioning Function is preferable to specifying the Positioning
Function itself, since then the name is visible in the Positioning
Method list, which is more interpretable when debugging.
</p>
</li>
<li><p> a named list element is used to add or update variables in
the data.frame of direct labels to plot. For example
list(&quot;first.points&quot;,cex=1.5) means take only the first points of
every group and then set the cex column to 1.5.
</p>
</li>
<li><p> an element of a Positioning Method list can be another
Positioning Method list, in which case the elements of the inner
list are applied.
</p>
</li></ul>
</td></tr>
<tr><td><code id="apply.method_+3A_d">d</code></td>
<td>
<p>Data frame to which we apply the Positioning Method. The x and y
columns should be in centimeters (cm), so that Positioning Methods
can easily calculate the L2/Euclidean/visual distance between
pairs of points.</p>
</td></tr>
<tr><td><code id="apply.method_+3A_columns.to.check">columns.to.check</code></td>
<td>
<p>After applying each Positioning Method list element, we check for
the presence of these columns, and if not found we stop with an
error.</p>
</td></tr>
<tr><td><code id="apply.method_+3A_...">...</code></td>
<td>
<p>Named arguments, passed to Positioning Functions.</p>
</td></tr>
<tr><td><code id="apply.method_+3A_debug">debug</code></td>
<td>
<p>If TRUE, print each Positioning Method list elmenent and the
direct label data.frame that results from its evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The final data frame returned after applying all of the items in
the Positioning Method list, with x and y in units of cm.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='big.boxes'>big boxes</h2><span id='topic+big.boxes'></span>

<h3>Description</h3>

<p>Calculate big boxes around the means of each cluster.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"big.boxes"</code></pre>

<hr>
<h2 id='bottom.pieces'>bottom pieces</h2><span id='topic+bottom.pieces'></span>

<h3>Description</h3>

<p>Positioning Method for the bottom of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottom.pieces(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottom.pieces_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="bottom.pieces_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='bottom.points'>bottom points</h2><span id='topic+bottom.points'></span>

<h3>Description</h3>

<p>Positioning Method for the bottom of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottom.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottom.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="bottom.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='bottom.polygons'>bottom polygons</h2><span id='topic+bottom.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the bottom point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"bottom.polygons"</code></pre>

<hr>
<h2 id='bumpup'>bumpup</h2><span id='topic+bumpup'></span>

<h3>Description</h3>

<p>Sequentially bump labels up, starting from the bottom, if they
collide with the label underneath.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bumpup(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bumpup_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="bumpup_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='calc.borders'>calc borders</h2><span id='topic+calc.borders'></span>

<h3>Description</h3>

<p>Calculate bounding box based on newly calculated width and height.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.borders(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.borders_+3A_d">d</code></td>
<td>
<p>Data frame of point labels, with new widths and heights in the w
and h columns.</p>
</td></tr>
<tr><td><code id="calc.borders_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='calc.boxes'>calc boxes</h2><span id='topic+calc.boxes'></span>

<h3>Description</h3>

<p>Calculate boxes around labels, for collision detection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.boxes(d, debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.boxes_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="calc.boxes_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
<tr><td><code id="calc.boxes_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='check.for.columns'>check for columns</h2><span id='topic+check.for.columns'></span>

<h3>Description</h3>

<p>Stop if a data.frame does not have some columns.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.for.columns(d, 
    must.have)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.for.columns_+3A_d">d</code></td>
<td>
<p>data.frame to check.</p>
</td></tr>
<tr><td><code id="check.for.columns_+3A_must.have">must.have</code></td>
<td>
<p>column names to check.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='chull.grid'>chull grid</h2><span id='topic+chull.grid'></span>

<h3>Description</h3>

<p>Label the closest point on the convex hull of the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"chull.grid"</code></pre>

<hr>
<h2 id='chull.points'>chull points</h2><span id='topic+chull.points'></span>

<h3>Description</h3>

<p>Calculate the points on the convex hull.</p>


<h3>Usage</h3>

<pre><code class='language-R'>chull.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chull.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="chull.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='default.ahull'>default ahull</h2><span id='topic+default.ahull'></span>

<h3>Description</h3>

<p>Calculate the default alpha parameter for ashape based on the
average size of label boxes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.ahull(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.ahull_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="default.ahull_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='default.picker'>default picker</h2><span id='topic+default.picker'></span>

<h3>Description</h3>

<p>Look at options() for a user-defined default Positioning Method
picker, and use that (or the hard-coded default picker), with the
calling environment to figure out a good default.</p>


<h3>Usage</h3>

<pre><code class='language-R'>default.picker(f)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.picker_+3A_f">f</code></td>
<td>
<p>Object class to look for (trellis or ggplot).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='defaultpf.ggplot'>defaultpf ggplot</h2><span id='topic+defaultpf.ggplot'></span>

<h3>Description</h3>

<p>Default method selection method for ggplot2 plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultpf.ggplot(geom, 
    p, L, colvar, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultpf.ggplot_+3A_geom">geom</code></td>
<td>
<p>geom </p>
</td></tr>
<tr><td><code id="defaultpf.ggplot_+3A_p">p</code></td>
<td>
<p>p </p>
</td></tr>
<tr><td><code id="defaultpf.ggplot_+3A_l">L</code></td>
<td>
<p>L </p>
</td></tr>
<tr><td><code id="defaultpf.ggplot_+3A_colvar">colvar</code></td>
<td>
<p>colvar </p>
</td></tr>
<tr><td><code id="defaultpf.ggplot_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='defaultpf.trellis'>defaultpf trellis</h2><span id='topic+defaultpf.trellis'></span>

<h3>Description</h3>

<p>If no Positioning Method specified, choose a default using this
function. The idea is that this is called with all the variables
in the environment of <code><a href="directlabels.html#topic+panel.superpose.dl">panel.superpose.dl</a></code>, and this can be
user-customizable by setting the directlabels.defaultpf.lattice
option to a function like this.</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultpf.trellis(lattice.fun.name, 
    groups, type, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultpf.trellis_+3A_lattice.fun.name">lattice.fun.name</code></td>
<td>
<p>lattice.fun.name </p>
</td></tr>
<tr><td><code id="defaultpf.trellis_+3A_groups">groups</code></td>
<td>
<p>groups </p>
</td></tr>
<tr><td><code id="defaultpf.trellis_+3A_type">type</code></td>
<td>
<p>type </p>
</td></tr>
<tr><td><code id="defaultpf.trellis_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='direct.label'>Direct labels for color decoding</h2><span id='topic+direct.label'></span><span id='topic+directlabels'></span>

<h3>Description</h3>

<p>Add direct labels to a plot, and hide the color legend. Modern
plotting packages like lattice and ggplot2 show automatic legends
based on the variable specified for color, but these legends can
be confusing if there are too many colors. Direct labels are a
useful and clear alternative to a confusing legend in many common
plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.label(p, method = NULL, 
    debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.label_+3A_p">p</code></td>
<td>
<p>The &quot;trellis&quot; or &quot;ggplot&quot; object with things drawn in different
colors.</p>
</td></tr>
<tr><td><code id="direct.label_+3A_method">method</code></td>
<td>
<p>Positioning Method, which determines the positions of the direct
labels as a function of the plotted data. If NULL, we examine the
plot <code>p</code> and try to choose an appropriate default. See
<code><a href="directlabels.html#topic+apply.method">apply.method</a></code> for more information about Positioning
Methods.</p>
</td></tr>
<tr><td><code id="direct.label_+3A_debug">debug</code></td>
<td>
<p>Show <code>debug</code> output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with direct labels and no color legend.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ggplot2)){
  ## Add direct labels to a ggplot2 scatterplot, making sure that each
  ## label is close to its point cloud, and doesn't overlap points or
  ## other labels.
  scatter &lt;- qplot(jitter(hwy),jitter(cty),data=mpg,colour=class,
                   main="Fuel efficiency depends on car size")
  direct.label(scatter)
}

## direct labels for lineplots that do not overlap and do not go off
## the plot.
if(require(nlme) &amp;&amp; require(lattice)){
  oldopt &lt;- lattice.options(panel.error=NULL)
  ratplot &lt;-
    xyplot(weight~Time|Diet,BodyWeight,groups=Rat,type='l',layout=c(3,1))
  ## Using the default Positioning Method (maxvar.qp), the labels are
  ## placed on the side which is most spread out, so in multipanel
  ## plots they sometimes end up on different sides.
  print(direct.label(ratplot))
  ## To put them on the same side, just manually specify the
  ## Positioning Method.
  print(direct.label(ratplot,"last.qp"))
  lattice.options(oldopt)
}

</code></pre>

<hr>
<h2 id='direct.label.ggplot'>direct label ggplot</h2><span id='topic+direct.label.ggplot'></span>

<h3>Description</h3>

<p>Direct label a ggplot2 grouped plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ggplot'
direct.label(p, 
    method = NULL, debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.label.ggplot_+3A_p">p</code></td>
<td>
<p>The ggplot object.</p>
</td></tr>
<tr><td><code id="direct.label.ggplot_+3A_method">method</code></td>
<td>
<p>Method for direct labeling as described in
<code><a href="directlabels.html#topic+apply.method">apply.method</a></code>.</p>
</td></tr>
<tr><td><code id="direct.label.ggplot_+3A_debug">debug</code></td>
<td>
<p>Show <code>debug</code> output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ggplot object with direct labels added.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='direct.label.trellis'>direct label trellis</h2><span id='topic+direct.label.trellis'></span>

<h3>Description</h3>

<p>Add direct labels to a grouped lattice plot. This works by parsing
the trellis object returned by the high level plot function, and
returning it with a new panel function that will plot direct
labels using the specified <code>method</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trellis'
direct.label(p, 
    method = NULL, debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.label.trellis_+3A_p">p</code></td>
<td>
<p>The lattice plot (result of a call to a high-level lattice
function).</p>
</td></tr>
<tr><td><code id="direct.label.trellis_+3A_method">method</code></td>
<td>
<p>Method for direct labeling as described in
<code><a href="directlabels.html#topic+apply.method">apply.method</a></code>.</p>
</td></tr>
<tr><td><code id="direct.label.trellis_+3A_debug">debug</code></td>
<td>
<p>Show <code>debug</code> output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lattice plot.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='dl.combine'>Combine output of several methods</h2><span id='topic+dl.combine'></span>

<h3>Description</h3>

<p>Apply several Positioning methods to the original data frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl.combine(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl.combine_+3A_...">...</code></td>
<td>
<p>Several Positioning Methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Positioning Method that returns the combined data frame after
applying each specified Positioning Method.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple example: label the start and endpoints
if(require(nlme) &amp;&amp; require(lattice)){
  ratplot &lt;- xyplot(
    weight~Time|Diet,BodyWeight,groups=Rat,type='l',layout=c(3,1))
  both &lt;- dl.combine("first.points","last.points")
  rat.both &lt;- direct.label(ratplot,"both")
  print(rat.both)
  ## same as repeated call to direct.label:
  rat.repeated &lt;-
    direct.label(direct.label(ratplot,"last.points"),"first.points")
  print(rat.repeated)
}

## same with ggplot2:
if(require(nlme) &amp;&amp; require(ggplot2)){
  rp2 &lt;- qplot(
    Time,weight,data=BodyWeight,geom="line",facets=.~Diet,colour=Rat)
  print(direct.label(direct.label(rp2,"last.points"),"first.points"))
  print(direct.label(rp2,"both"))
}

## more complex example: first here is a function for computing the
## lasso path.
mylars &lt;- function
## Least angle regression algorithm for calculating lasso solutions.
(x,
 ## Matrix of predictor variables.
 y,
 ## Vector of responses.
 epsilon=1e-6
 ## If correlation &lt; epsilon, we are done.
 ){
  xscale &lt;- scale(x) # need to work with standardized variables
  b &lt;- rep(0,ncol(x))# coef vector starts at 0
  names(b) &lt;- colnames(x)
  ycor &lt;- apply(xscale,2,function(xj)sum(xj*y))
  j &lt;- which.max(ycor) # variables in active set, starts with most correlated
  alpha.total &lt;- 0
  out &lt;- data.frame()
  while(1){## lar loop
    xak &lt;- xscale[,j] # current variables
    r &lt;- y-xscale%*%b # current residual
    ## direction of parameter evolution
    delta &lt;- solve(t(xak)%*%xak)%*%t(xak)%*%r
    ## Current correlations (actually dot product)
    intercept &lt;- apply(xscale,2,function(xk)sum(r*xk))
    ## current rate of change of correlations
    z &lt;- xak%*%delta
    slope &lt;- apply(xscale,2,function(xk)-sum(z*xk))
    ## store current values of parameters and correlation
    out &lt;- rbind(out,data.frame(variable=colnames(x),
                                coef=b,
                                corr=abs(intercept),
                                alpha=alpha.total,
                                arclength=sum(abs(b)),
                                coef.unscaled=b/attr(xscale,"scaled:scale")))
    if(sum(abs(intercept)) &lt; epsilon)#corr==0 so we are done
      return(transform(out,s=arclength/max(arclength)))
    ## If there are more variables we can enter into the regression,
    ## then see which one will cross the highest correlation line
    ## first, and record the alpha value of where the lines cross.
    d &lt;- data.frame(slope,intercept)
    d[d$intercept&lt;0,] &lt;- d[d$intercept&lt;0,]*-1
    d0 &lt;- data.frame(d[j[1],])# highest correlation line
    d2 &lt;- data.frame(rbind(d,-d),variable=names(slope))#reflected lines
    ## Calculation of alpha for where lines cross for each variable
    d2$alpha &lt;- (d0$intercept-d2$intercept)/(d2$slope-d0$slope)
    subd &lt;- d2[(!d2$variable%in%colnames(x)[j])&amp;d2$alpha&gt;epsilon,]
    subd &lt;- subd[which.min(subd$alpha),]
    nextvar &lt;- subd$variable
    alpha &lt;- if(nrow(subd))subd$alpha else 1
    ## If one of the coefficients would hit 0 at a smaller alpha
    ## value, take it out of the regression and continue.
    hit0 &lt;- xor(b[j]&gt;0,delta&gt;0)&amp;b[j]!=0
    alpha0 &lt;- -b[j][hit0]/delta[hit0]
    takeout &lt;- length(alpha0)&amp;&amp;min(alpha0) &lt; alpha
    if(takeout){
      i &lt;- which.min(alpha0)
      alpha &lt;- alpha0[i]
    }
    b[j] &lt;- b[j]+alpha*delta ## evolve parameters
    alpha.total &lt;- alpha.total+alpha
    ## add or remove a variable from the active set
    j &lt;- if(takeout)j[j!=which(names(i)==colnames(x))]
         else c(j,which(nextvar==colnames(x)))
  }
}

## Calculate lasso path, plot labels at two points: (1) where the
## variable enters the path, and (2) at the end of the path.
if(require(lars) &amp;&amp; require(lattice)){
  data(diabetes,envir=environment())
  dres &lt;- with(diabetes,mylars(x,y))
  P &lt;- xyplot(coef~arclength,dres,groups=variable,type="l")
  mylasso &lt;- dl.combine("lasso.labels", "last.qp")
  plot(direct.label(P,"mylasso"))
}

</code></pre>

<hr>
<h2 id='dl.env'>dl env</h2><span id='topic+dl.env'></span>

<h3>Description</h3>

<p>This environment holds an integer id that will be incremented to
get a unique id for each <code><a href="directlabels.html#topic+dlgrob">dlgrob</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"dl.env"</code></pre>

<hr>
<h2 id='dl.jitter'>dl jitter</h2><span id='topic+dl.jitter'></span>

<h3>Description</h3>

<p>Jitter the label positions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl.jitter(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl.jitter_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="dl.jitter_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='dl.move'>Manually move a direct label</h2><span id='topic+dl.move'></span>

<h3>Description</h3>

<p>Sometimes there is 1 label that is placed oddly by another
Positioning Function. This function can be used to manually place
that label in a good spot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl.move(group, x, y, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl.move_+3A_group">group</code></td>
<td>
<p>Group to change.</p>
</td></tr>
<tr><td><code id="dl.move_+3A_x">x</code></td>
<td>
<p>Horizontal position of the new label.</p>
</td></tr>
<tr><td><code id="dl.move_+3A_y">y</code></td>
<td>
<p>Vertical position of the new label. If missing(<code>y</code>) and !missing(<code>x</code>)
then we will calculate a new <code>y</code> value using linear interpolation.</p>
</td></tr>
<tr><td><code id="dl.move_+3A_...">...</code></td>
<td>
<p>Variables to change for the specified <code>group</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Positioning Function that moves a label into a good spot.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ggplot2) &amp;&amp; require(lattice)){
  scatter &lt;- xyplot(jitter(cty)~jitter(hwy),mpg,groups=class,aspect=1)
  dlcompare(list(scatter),
            list("extreme.grid",
                 `+dl.move`=list(extreme.grid,dl.move("suv",15,15))))
  p &lt;- qplot(log10(gamma),rate,data=svmtrain,group=data,colour=data,
             geom="line",facets=replicate~nu)
  adjust.kif &lt;- dl.move("KIF11",-0.9,hjust=1,vjust=1)
  dlcompare(list(p+xlim(-8,7)),
            list("last.points",
                 `+dl.move`=list(last.points,adjust.kif)))
}
</code></pre>

<hr>
<h2 id='dl.summarize'>dl summarize</h2><span id='topic+dl.summarize'></span>

<h3>Description</h3>

<p>summarize which preserves important columns for direct labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl.summarize(OLD, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl.summarize_+3A_old">OLD</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="dl.summarize_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='dl.trans'>Direct label data transform</h2><span id='topic+dl.trans'></span>

<h3>Description</h3>

<p>Make a function that transforms the data. This is for conveniently
making a function that calls transform on the data frame, with the
arguments provided. See examples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl.trans(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl.trans_+3A_...">...</code></td>
<td>
<p>Arguments to pass to transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Positioning Function.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>complicated &lt;- list(dl.trans(x=x+10),
                    gapply.fun(d[-2,]),
                    rot=c(30,180))
if(require(lattice)){
  direct.label(dotplot(VADeaths,type="o"),complicated,TRUE)
}
</code></pre>

<hr>
<h2 id='dlcompare'>Direct label comparison plot</h2><span id='topic+dlcompare'></span>

<h3>Description</h3>

<p>Compare several <code>plots</code> and/or label placement methods. This creates
a custom grid graphics display based on lattice and/or ggplot2
output. Plots will be on the columns and positioning methods will
be on the rows.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlcompare(plots, pos.funs, 
    rects = TRUE, row.items = "plots", 
    debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlcompare_+3A_plots">plots</code></td>
<td>
<p>List of ggplot2 or lattice <code>plots</code>. List names will be used to
annotate the plot.</p>
</td></tr>
<tr><td><code id="dlcompare_+3A_pos.funs">pos.funs</code></td>
<td>
<p>List of label placement methods to apply to each plot. List names,
or function names if specified as character strings, will be used
to annotate the plot.</p>
</td></tr>
<tr><td><code id="dlcompare_+3A_rects">rects</code></td>
<td>
<p>Draw rectangles around each plot, creating a grid?</p>
</td></tr>
<tr><td><code id="dlcompare_+3A_row.items">row.items</code></td>
<td>
<p>If &quot;plots&quot; then put <code>plots</code> on the rows and method on the
columns. Otherwise, do the opposite.</p>
</td></tr>
<tr><td><code id="dlcompare_+3A_debug">debug</code></td>
<td>
<p>Show <code>debug</code> output?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare two plots of the same data using lattice and ggplot2.
deaths.by.sex &lt;- list(male=mdeaths, female=fdeaths)
deaths.list &lt;- list()
for(sex in names(deaths.by.sex)){
  deaths.ts &lt;- deaths.by.sex[[sex]]
  deaths.list[[sex]] &lt;-
    data.frame(year=as.numeric(time(deaths.ts)),
               sex,
               deaths=as.integer(deaths.ts))
}
deaths &lt;- do.call(rbind, deaths.list)
death.plot.list &lt;- list()
if(require(lattice)){
  oldopt &lt;- lattice.options(panel.error=NULL)
  death.plot.list[["lattice"]] &lt;- xyplot(
    deaths~year,deaths,groups=sex,type="l")
}
if(require(ggplot2)){
  death.plot.list[["ggplot2"]] &lt;- qplot(
    year,deaths,data=deaths,colour=sex,geom="line")
}
if(length(death.plot.list) &amp;&amp; names(dev.cur())!="postscript"){##to avoid error on pkg check.
  ## Use some exotic labeling options with different rotation, font
  ## face, family, and alpha transparency.
  exotic &lt;- list("last.points",
                 rot=c(0,180),
                 fontsize=c(10,20),
                 fontface=c("bold","italic"),
                 fontfamily=c("mono","serif"),
                 alpha=c(0.25,1))
  dlcompare(death.plot.list, list(exotic))
}
if(require(lattice))lattice.options(oldopt)
## Compare a legend with direct labels on the same plot.
if(require(ggplot2) &amp;&amp; require(nlme)){
  ggrat &lt;- qplot(Time,weight,data=BodyWeight,
                 colour=Rat,geom="line",facets=.~Diet)
  pfuns &lt;- list("legend","direct labels"="last.qp")
  dlcompare(list(ggrat),pfuns,rects=FALSE,row.items="posfuns")
}

</code></pre>

<hr>
<h2 id='dldoc'>Make directlabels documentation</h2><span id='topic+dldoc'></span>

<h3>Description</h3>

<p>Positioning Methods for direct labels are supposed to work with
only certain plot types. Each Positioning Method is defined in
R/file.R and plot examples are found in tests/doc/file/*.R so that
we can automatically assemble a database of example plots from the
code.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dldoc(pkgdir = "..")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dldoc_+3A_pkgdir">pkgdir</code></td>
<td>
<p>Package directory root.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of lists describing example plots and matching builtin
Positioning Methods.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='dlgrob'>dlgrob</h2><span id='topic+dlgrob'></span>

<h3>Description</h3>

<p>Make a grid grob that will draw direct labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlgrob(data, method, 
    debug = FALSE, axes2native = identity, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlgrob_+3A_data">data</code></td>
<td>
<p>Data frame including points to plot in native coordinates.</p>
</td></tr>
<tr><td><code id="dlgrob_+3A_method">method</code></td>
<td>
<p>Positioning Method.</p>
</td></tr>
<tr><td><code id="dlgrob_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
<tr><td><code id="dlgrob_+3A_axes2native">axes2native</code></td>
<td>
<p>axes2native </p>
</td></tr>
<tr><td><code id="dlgrob_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='draw.polygons'>draw polygons</h2><span id='topic+draw.polygons'></span>

<h3>Description</h3>

<p>Draw polygons around label positions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.polygons(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.polygons_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="draw.polygons_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='draw.rects'>draw rects</h2><span id='topic+draw.rects'></span>

<h3>Description</h3>

<p>Positioning Function that draws boxes around label positions. Need
to have previously called <code><a href="directlabels.html#topic+calc.boxes">calc.boxes</a></code>. Does not edit the data
frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.rects(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.rects_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="draw.rects_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='drawDetails.dlgrob'>drawDetails dlgrob</h2><span id='topic+drawDetails.dlgrob'></span>

<h3>Description</h3>

<p>Process data points using the Positioning Method and draw the
resulting direct labels. This is called for every panel with
direct labels, every time the plot window is resized.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dlgrob'
drawDetails(x, 
    recording)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawDetails.dlgrob_+3A_x">x</code></td>
<td>
<p>The <code><a href="directlabels.html#topic+dlgrob">dlgrob</a></code> list object. x$method should be a Positioning Method
list and x$data should be a data.frame with the following
variables: </p>

<dl>
<dt>x,y</dt><dd><p>numeric horizontal and vertical positions of direct
labels, in native units. These are converted to cm units before
applying the Positioning Method.</p>
</dd>
<dt>groups</dt><dd><p>factor that indices the different groups, and
colour indicates the corresponding group colour.</p>
</dd>
<dt>hjust and vjust</dt><dd><p>(optional) numeric values usually in
[0,1] that control the justification of the text label relative to
the x,y position.</p>
</dd>
<dt>rot</dt><dd><p>(optional) numeric value in [0,360] that specifies
the degrees which the text should be rotated.</p>
</dd>
<dt>cex, alpha, fontface, fontfamily</dt><dd><p>(optional) passed to
gpar.</p>
</dd>
</dl>
<p> Additionally, x$debug should be set to TRUE or
FALSE, and x$axestonative should be a function that converts units
shown on the axes to native units of x$data[,c(&quot;x&quot;,&quot;y&quot;)].</p>
</td></tr>
<tr><td><code id="drawDetails.dlgrob_+3A_recording">recording</code></td>
<td>
<p>recording </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='edges.to.outside'>edges to outside</h2><span id='topic+edges.to.outside'></span>

<h3>Description</h3>

<p>Given a list of <code>edges</code> from the convex or alpha hull, and a list of
cluster <code>centers</code>, calculate a point near to each cluster on the
outside of the hull.</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges.to.outside(edges, 
    centers, debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges.to.outside_+3A_edges">edges</code></td>
<td>
<p>edges </p>
</td></tr>
<tr><td><code id="edges.to.outside_+3A_centers">centers</code></td>
<td>
<p>centers </p>
</td></tr>
<tr><td><code id="edges.to.outside_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
<tr><td><code id="edges.to.outside_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='empty.grid'>empty grid</h2><span id='topic+empty.grid'></span>

<h3>Description</h3>

<p>Label placement method for scatterplots that ensures labels are
placed in different places. A grid is drawn over the whole
plot. Each cluster is considered in sequence and assigned to the
point on this grid which is closest to the point given by
the input data points. Makes use of attr(d,&quot;orig.data&quot;).</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty.grid(d, debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty.grid_+3A_d">d</code></td>
<td>
<p>Data frame of target points on the scatterplot for each label.</p>
</td></tr>
<tr><td><code id="empty.grid_+3A_debug">debug</code></td>
<td>
<p>Show debugging info on the plot?</p>
</td></tr>
<tr><td><code id="empty.grid_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns groups x y, 1 line for each group, giving
the positions on the grid closest to each cluster.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='enlarge.box'>enlarge box</h2><span id='topic+enlarge.box'></span>

<h3>Description</h3>

<p>Make text bounding box larger by some amount.</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlarge.box(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enlarge.box_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="enlarge.box_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='extract.plot'>Extract plot and definition for documentation</h2><span id='topic+extract.plot'></span>

<h3>Description</h3>

<p>Given an R code file, execute it, store the definition, and save
the resulting plot in a variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.plot(f)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.plot_+3A_f">f</code></td>
<td>
<p>R code file with plot example.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='extract.posfun'>Extract Positioning Method for documentation</h2><span id='topic+extract.posfun'></span>

<h3>Description</h3>

<p>Use inlinedocs to extract comments and definitions from code, then
for each item found add the value and its name to the list.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.posfun(f)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.posfun_+3A_f">f</code></td>
<td>
<p>R code file, which should contain only Positioning Methods that
can be used with examples defined in the doc/ subdirectory with
the same name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of lists, each of which describes one Positioning Method
defined in <code>f</code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='extreme.grid'>extreme grid</h2><span id='topic+extreme.grid'></span>

<h3>Description</h3>

<p>Label each point cloud near the extremities of the plot region.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"extreme.grid"</code></pre>

<hr>
<h2 id='extreme.points'>extreme points</h2><span id='topic+extreme.points'></span>

<h3>Description</h3>

<p>Label the points furthest from the middle for each group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extreme.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="extreme.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='far.from.others.borders'>far from others borders</h2><span id='topic+far.from.others.borders'></span>

<h3>Description</h3>

<p>Find the point on each curve which maximizes the distance to the
plot border or to another curve.</p>


<h3>Usage</h3>

<pre><code class='language-R'>far.from.others.borders(all.groups, 
    ..., debug = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="far.from.others.borders_+3A_all.groups">all.groups</code></td>
<td>
<p>all.groups </p>
</td></tr>
<tr><td><code id="far.from.others.borders_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
<tr><td><code id="far.from.others.borders_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='filltemplate'>filltemplate</h2><span id='topic+filltemplate'></span>

<h3>Description</h3>

<p>Fill in occurances of OBJ$item in the file <code>template</code> with the value
in R of L$item.</p>


<h3>Usage</h3>

<pre><code class='language-R'>filltemplate(L, template)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filltemplate_+3A_l">L</code></td>
<td>
<p>L </p>
</td></tr>
<tr><td><code id="filltemplate_+3A_template">template</code></td>
<td>
<p>template </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='first.bumpup'>first bumpup</h2><span id='topic+first.bumpup'></span>

<h3>Description</h3>

<p>Label first points, bumping labels up if they collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"first.bumpup"</code></pre>

<hr>
<h2 id='first.points'>first points</h2><span id='topic+first.points'></span>

<h3>Description</h3>

<p>Positioning Method for the first of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>first.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="first.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='first.polygons'>first polygons</h2><span id='topic+first.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the first point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"first.polygons"</code></pre>

<hr>
<h2 id='first.qp'>first qp</h2><span id='topic+first.qp'></span>

<h3>Description</h3>

<p>Label first points from QP solver that ensures labels do not collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"first.qp"</code></pre>

<hr>
<h2 id='gapply'>gapply</h2><span id='topic+gapply'></span>

<h3>Description</h3>

<p>apply a Positioning Method to every group. works like ddply from
plyr package, but the grouping column is always called <code>groups</code>, and
the Positioning Method is not necessarily a function (but can be).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapply(d, method, ..., 
    groups = "groups")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapply_+3A_d">d</code></td>
<td>
<p>data frame with column <code>groups</code>.</p>
</td></tr>
<tr><td><code id="gapply_+3A_method">method</code></td>
<td>
<p>Positioning Method to apply to every group separately.</p>
</td></tr>
<tr><td><code id="gapply_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to Positioning Methods.</p>
</td></tr>
<tr><td><code id="gapply_+3A_groups">groups</code></td>
<td>
<p>can also be useful for piece column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of results after applying FUN to each group in <code>d</code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='gapply.fun'>Direct label groups independently</h2><span id='topic+gapply.fun'></span>

<h3>Description</h3>

<p>Makes a function you can use to specify the location of each group
independently.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapply.fun(expr)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapply.fun_+3A_expr">expr</code></td>
<td>
<p>Expression that takes a subset of the d data frame, with data from
only a single group, and returns the direct label position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Positioning Function.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>complicated &lt;- list(dl.trans(x=x+10),
                    gapply.fun(d[-2,]),
                    rot=c(30,180))
if(require(lattice)){
  direct.label(dotplot(VADeaths,type="o"),complicated,TRUE)
}
</code></pre>

<hr>
<h2 id='geom_dl'>geom dl</h2><span id='topic+geom_dl'></span>

<h3>Description</h3>

<p>Geom that will plot direct labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_dl(mapping = NULL, 
    data = NULL, ..., 
    method = stop("must specify method= argument"), 
    debug = FALSE, stat = "identity", 
    position = "identity", 
    inherit.aes = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_dl_+3A_mapping">mapping</code></td>
<td>
<p>aes(label=variable_that_will_be_used_as_groups_in_Positioning_Methods).</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_data">data</code></td>
<td>
<p>data.frame to start with for direct label computation.</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_...">...</code></td>
<td>
<p>passed to params.</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_method">method</code></td>
<td>
<p>Positioning Method for direct label placement, passed to <code><a href="directlabels.html#topic+apply.method">apply.method</a></code>.</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_debug">debug</code></td>
<td>
<p>Show directlabels debugging output?</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_stat">stat</code></td>
<td>
<p>passed to layer.</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_position">position</code></td>
<td>
<p>passed to layer.</p>
</td></tr>
<tr><td><code id="geom_dl_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>inherit aes from global ggplot definition?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ggplot2)){
  vad &lt;- as.data.frame.table(VADeaths)
  names(vad) &lt;- c("age","demographic","deaths")
  ## color + legend
  leg &lt;- ggplot(vad,aes(deaths,age,colour=demographic))+
    geom_line(aes(group=demographic))+
    xlim(8,80)
  print(direct.label(leg,list("last.points",rot=30)))
  ## this is what direct.label is doing internally:
  labeled &lt;- leg+
    geom_dl(aes(label=demographic), method=list("last.points",rot=30))+
    scale_colour_discrete(guide="none")
  print(labeled)
  ## no color, just direct labels!
  p &lt;- ggplot(vad,aes(deaths,age))+
    geom_line(aes(group=demographic))+
    geom_dl(aes(label=demographic),method="top.qp")
  print(p)
  ## add color:
  p.color &lt;- p+aes(colour=demographic)+
    scale_colour_discrete(guide="none")
  print(p.color)
  ## add linetype:
  p.linetype &lt;- p+aes(linetype=demographic)+
    scale_linetype(guide="none")
  print(p.linetype)
  ## no color, just direct labels
  if(require(nlme)){
    bwbase &lt;- ggplot(BodyWeight,aes(Time,weight,label=Rat))+
      geom_line(aes(group=Rat))+
      facet_grid(.~Diet)
    bw &lt;- bwbase+geom_dl(method="last.qp")
    print(bw)
    ## add some more direct labels
    bw2 &lt;- bw+geom_dl(method="first.qp")
    print(bw2)
    ## add color
    colored &lt;- bw2+aes(colour=Rat)+
      scale_colour_discrete(guide="none")
    print(colored)
    ## or just use direct.label if you use color:
    print(direct.label(bwbase+aes(colour=Rat),dl.combine("first.qp","last.qp")))
  }
  ## iris data example
  giris &lt;- ggplot(iris,aes(Petal.Length,Sepal.Length))+
    geom_point(aes(shape=Species))
  giris.labeled &lt;- giris+
    geom_dl(aes(label=Species),method="smart.grid")+
    scale_shape_manual(values=c(setosa=1,virginica=6,versicolor=3),
                       guide="none")
  ##png("~/R/directlabels/www/scatter-bw-ggplot2.png",h=503,w=503)
  print(giris.labeled)
  ##dev.off()
}

</code></pre>

<hr>
<h2 id='GeomDl'>GeomDl</h2><span id='topic+GeomDl'></span>

<h3>Description</h3>

<p>ggproto object implementing direct labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"GeomDl"</code></pre>

<hr>
<h2 id='get.means'>get means</h2><span id='topic+get.means'></span>

<h3>Description</h3>

<p>Positioning Function for the mean of each cluster of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.means(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.means_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="get.means_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='getLegendVariables'>getLegendVariables</h2><span id='topic+getLegendVariables'></span>

<h3>Description</h3>

<p>get the aes which are variable in one legend.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLegendVariables(mb)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLegendVariables_+3A_mb">mb</code></td>
<td>
<p>mb </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='ignore.na'>ignore na</h2><span id='topic+ignore.na'></span>

<h3>Description</h3>

<p>Remove rows for which either x or y is NA</p>


<h3>Usage</h3>

<pre><code class='language-R'>ignore.na(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ignore.na_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="ignore.na_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='in1box'>in1box</h2><span id='topic+in1box'></span>

<h3>Description</h3>

<p>Calculate how many points fall in a <code>box</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>in1box(p, box)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in1box_+3A_p">p</code></td>
<td>
<p>p </p>
</td></tr>
<tr><td><code id="in1box_+3A_box">box</code></td>
<td>
<p>box </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='in1which'>in1which</h2><span id='topic+in1which'></span>

<h3>Description</h3>

<p>Calculate which points fall in a <code>box</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>in1which(p, box)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in1which_+3A_p">p</code></td>
<td>
<p>data frame of points with columns x and y and many rows.</p>
</td></tr>
<tr><td><code id="in1which_+3A_box">box</code></td>
<td>
<p>data frame of 1 row with columns left right top bottom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='inside'>inside</h2><span id='topic+inside'></span>

<h3>Description</h3>

<p>Calculate for each box how many <code>points</code> are inside.</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside(boxes, points)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside_+3A_boxes">boxes</code></td>
<td>
<p>Data frame of box descriptions, each row is 1 box, need columns
left right top bottom.</p>
</td></tr>
<tr><td><code id="inside_+3A_points">points</code></td>
<td>
<p>Data frame of <code>points</code>, each row is 1 point, need columns x y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of point counts for each box.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='iris.l1.cluster'>Clustering of the iris data with the l1 clusterpath</h2><span id='topic+iris.l1.cluster'></span>

<h3>Description</h3>

<p> The l1 clustering algorithm from the clusterpath package
was applied to the iris dataset and the breakpoints in the solution
path are stored in this data frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(iris.l1.cluster)</code></pre>


<h3>Format</h3>

<p>A data frame with 9643 observations on the following 8 variables.
</p>

<dl>
<dt><code>row</code></dt><dd><p>a numeric vector: row of the original iris data matrix</p>
</dd>
<dt><code>Species</code></dt><dd><p>a factor with levels <code>setosa</code>
<code>versicolor</code> <code>virginica</code>: Species from corresponding row</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a numeric vector: the value of the optimal
solution.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>a numeric vector: the regularization parameter
(ie point in the path).</p>
</dd>
<dt><code>col</code></dt><dd><p>a factor with levels <code>Sepal.Length</code>
<code>Sepal.Width</code> <code>Petal.Length</code> <code>Petal.Width</code>: column
from the original iris data.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>a factor with levels <code>0</code>: parameter from clustering.</p>
</dd>
<dt><code>norm</code></dt><dd><p>a factor with levels <code>1</code> parameter from clustering.</p>
</dd>
<dt><code>solver</code></dt><dd><p>a factor with levels <code>path</code> algorithm used for
clustering.</p>
</dd>
</dl>



<h3>Source</h3>

<p>clusterpath package
</p>


<h3>References</h3>

<p>clusterpath article
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris.l1.cluster,package="directlabels")
iris.l1.cluster$y &lt;- iris.l1.cluster$alpha
if(require(ggplot2)){
  p &lt;- ggplot(iris.l1.cluster,aes(lambda,y,group=row,colour=Species))+
    geom_line(alpha=1/4)+
    facet_grid(col~.)
  p2 &lt;- p+xlim(-0.0025,max(iris.l1.cluster$lambda))
  print(direct.label(p2,list(first.points,get.means)))
}
</code></pre>

<hr>
<h2 id='label.endpoints'>label endpoints</h2><span id='topic+label.endpoints'></span>

<h3>Description</h3>

<p>Make a Positioning Method that labels a certain x value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.endpoints(FUN, 
    HJUST)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label.endpoints_+3A_fun">FUN</code></td>
<td>
<p>FUN(d$x) should return an index of which point to label. for
example you can use which.min or which.max.</p>
</td></tr>
<tr><td><code id="label.endpoints_+3A_hjust">HJUST</code></td>
<td>
<p>hjust of the labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Positioning Method like <code><a href="directlabels.html#topic+first.points">first.points</a></code> or <code><a href="directlabels.html#topic+last.points">last.points</a></code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='label.pieces'>label pieces</h2><span id='topic+label.pieces'></span>

<h3>Description</h3>

<p>Make a Positioning Method that will, for every piece, select
points and assign a vjust value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.pieces(FUN, VJUST)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label.pieces_+3A_fun">FUN</code></td>
<td>
<p>FUN </p>
</td></tr>
<tr><td><code id="label.pieces_+3A_vjust">VJUST</code></td>
<td>
<p>VJUST </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='lasso.labels'>lasso labels</h2><span id='topic+lasso.labels'></span>

<h3>Description</h3>

<p>Label points at the zero before the first nonzero y value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"lasso.labels"</code></pre>

<hr>
<h2 id='last.bumpup'>last bumpup</h2><span id='topic+last.bumpup'></span>

<h3>Description</h3>

<p>Label last points, bumping labels up if they collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"last.bumpup"</code></pre>

<hr>
<h2 id='last.points'>last points</h2><span id='topic+last.points'></span>

<h3>Description</h3>

<p>Positioning Method for the last of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>last.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="last.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="last.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='last.polygons'>last polygons</h2><span id='topic+last.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the last point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"last.polygons"</code></pre>

<hr>
<h2 id='last.qp'>last qp</h2><span id='topic+last.qp'></span>

<h3>Description</h3>

<p>Label last points from QP solver that ensures labels do not collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"last.qp"</code></pre>

<hr>
<h2 id='lattice.translators'>lattice translators</h2><span id='topic+lattice.translators'></span>

<h3>Description</h3>

<p>Some lattice plot functions do some magic in the background to
translate the data you give them into the data points that are
plotted onscreen. We have to replicate this magic in native
coordinate space before applying the Positioning Method in cm
space. These functions accomplish this translation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"lattice.translators"</code></pre>

<hr>
<h2 id='left.points'>left points</h2><span id='topic+left.points'></span>

<h3>Description</h3>

<p>Positioning Method for the first of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>left.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="left.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="left.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='left.polygons'>left polygons</h2><span id='topic+left.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the first point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"left.polygons"</code></pre>

<hr>
<h2 id='legends2hide'>legends2hide</h2><span id='topic+legends2hide'></span>

<h3>Description</h3>

<p>Extract guides to hide from a ggplot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>legends2hide(p)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legends2hide_+3A_p">p</code></td>
<td>
<p>p </p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL if no legends with colour or fill to hide.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='lines2'>lines2</h2><span id='topic+lines2'></span>

<h3>Description</h3>

<p>Positioning Method for 2 groups of longitudinal data. One curve
is on top of the other one (on average), so we label the top one
at its maximal point, and the bottom one at its minimal
point. Vertical justification is chosen to minimize collisions
with the other line. This may not work so well for data with high
variability, but then again lineplots may not be the best for
these data either.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines2(d, offset = 0.3, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines2_+3A_d">d</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="lines2_+3A_offset">offset</code></td>
<td>
<p>Offset from 0 or 1 for the vjust values.</p>
</td></tr>
<tr><td><code id="lines2_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='LOPART.ROC'>
ROC curve for LOPART algorithm and competitors
</h2><span id='topic+LOPART.ROC'></span>

<h3>Description</h3>

<p>For the LOPART paper we computed ROC curves for predictions of
changepoint detection algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LOPART.ROC")</code></pre>


<h3>Format</h3>

<p>A named list of two data frames: points has one row per
model/algorithm, roc has one row per point on the ROC curve.
</p>


<h3>Source</h3>

<p>Figure/paper describing LOPART algorithm and R package,
https://github.com/tdhock/LOPART-paper/blob/master/figure-cv-BIC.R
</p>

<hr>
<h2 id='LOPART100'>
Labeled Optimal Partitioning (LOPART) results
</h2><span id='topic+LOPART100'></span>

<h3>Description</h3>

<p>Results of running LOPART algorithm (for changepoint detection in
partially labeled data sequence) on a simulated data set of size 100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LOPART100")</code></pre>


<h3>Format</h3>

<p>Named list of data frames: signal has one row per data point, labels has
one row per label, segments has one row per segment, cost has one row
per feasible last changepoint for model up to t=100 data.
</p>


<h3>Source</h3>

<p>Figure/paper describing LOPART algorithm and R package,
https://github.com/tdhock/LOPART-paper/blob/master/figure-candidates.R
</p>

<hr>
<h2 id='make.tiebreaker'>make tiebreaker</h2><span id='topic+make.tiebreaker'></span>

<h3>Description</h3>

<p>Make a tiebreaker function that can be used with <code><a href="directlabels.html#topic+qp.labels">qp.labels</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.tiebreaker(x.var, 
    tiebreak.var)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.tiebreaker_+3A_x.var">x.var</code></td>
<td>
<p>x.var </p>
</td></tr>
<tr><td><code id="make.tiebreaker_+3A_tiebreak.var">tiebreak.var</code></td>
<td>
<p>tiebreak.var </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='maxvar.points'>maxvar points</h2><span id='topic+maxvar.points'></span>

<h3>Description</h3>

<p>Do first or last, whichever has points most spread out.</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxvar.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxvar.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="maxvar.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='maxvar.qp'>maxvar qp</h2><span id='topic+maxvar.qp'></span>

<h3>Description</h3>

<p>Label first or last points, whichever are more spread out, and use
a QP solver to make sure the labels do not collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"maxvar.qp"</code></pre>

<hr>
<h2 id='merge_recurse'>merge recurse</h2><span id='topic+merge_recurse'></span>

<h3>Description</h3>

<p>Copied from reshape.</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_recurse(dfs, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_recurse_+3A_dfs">dfs</code></td>
<td>
<p>dfs </p>
</td></tr>
<tr><td><code id="merge_recurse_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='midrange'>midrange</h2><span id='topic+midrange'></span>

<h3>Description</h3>

<p>Point halfway between the min and max</p>


<h3>Usage</h3>

<pre><code class='language-R'>midrange(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midrange_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='normal.l2.cluster'>
Clustering of some normal data in 2d with the l2 clusterpath
</h2><span id='topic+normal.l2.cluster'></span>

<h3>Description</h3>

<p>The l2 clustering algorithm from the clusterpath package was applied to
some randomly generated data in 2 dimensions, and the solutions found
using the descent algorithm are stored in this data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(normal.l2.cluster)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 2
$ pts :'data.frame':	320 obs. of  3 variables:
..$ class: Factor w/ 8 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
..$ x    : num [1:320] -2.73 -3.63 -2.13 -1.27 -2.98 ...
..$ y    : num [1:320] -3.89 -3.43 -3.42 -3.17 -2.75 ...
$ path:Classes 'l2', 'clusterpath' and 'data.frame':	21760 obs. of  7 variables:
..$ x     : num [1:21760] -2.73 -3.63 -2.13 -1.27 -2.98 ...
..$ y     : num [1:21760] -3.89 -3.43 -3.42 -3.17 -2.75 ...
..$ lambda: num [1:21760] 0 0 0 0 0 0 0 0 0 0 ...
..$ row   : Factor w/ 320 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 7 8 9 10 ...
..$ gamma : Factor w/ 1 level &quot;0.1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
..$ norm  : Factor w/ 1 level &quot;2&quot;: 1 1 1 1 1 1 1 1 1 1 ...
..$ solver: Factor w/ 1 level &quot;descent.nocheck&quot;: 1 1 1 1 1 1 1 1 1 1 ...
..- attr(*, &quot;data&quot;)= num [1:320, 1:2] -2.73 -3.63 -2.13 -1.27 -2.98 ...
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
..- attr(*, &quot;alphacolnames&quot;)= chr [1:2] &quot;x&quot; &quot;y&quot;
..- attr(*, &quot;weight.pts&quot;)= num [1:320, 1:2] -2.73 -3.63 -2.13 -1.27 -2.98 ...
.. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] &quot;x&quot; &quot;y&quot;
</p>


<h3>Source</h3>

<p>clusterpath package
</p>


<h3>References</h3>

<p>clusterpath article
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(normal.l2.cluster)
if(require(ggplot2)){
  p &lt;- ggplot(normal.l2.cluster$path,aes(x,y))+
    geom_path(aes(group=row),colour="grey")+
    geom_point(aes(size=lambda),colour="grey")+
    geom_point(aes(colour=class),data=normal.l2.cluster$pts)+
    coord_equal()
  print(direct.label(p))
}
</code></pre>

<hr>
<h2 id='odd_timings'>
Odd timings
</h2><span id='topic+odd_timings'></span>

<h3>Description</h3>

<p>These timings data made strange output labels with the
&quot;right.polygons&quot; method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("odd_timings")</code></pre>


<h3>Format</h3>

<p>A data frame with 116 observations on the following 4 variables. Plot
median.seconds versus N.col using a different line for each fun and a
different panel for each captures.
</p>

<dl>
<dt><code>N.col</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fun</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>captures</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>median.seconds</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/tdhock/nc-article">https://github.com/tdhock/nc-article</a>
</p>

<hr>
<h2 id='only.unique.vals'>only unique vals</h2><span id='topic+only.unique.vals'></span>

<h3>Description</h3>

<p>Create a 1-row data.frame consisting of only the columns for which
there is only 1 unique value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>only.unique.vals(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="only.unique.vals_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="only.unique.vals_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='outside.ahull'>outside ahull</h2><span id='topic+outside.ahull'></span>

<h3>Description</h3>

<p>Calculate closest point on the alpha hull with size of the boxes,
and put it outside that point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>outside.ahull(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outside.ahull_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="outside.ahull_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='outside.chull'>outside chull</h2><span id='topic+outside.chull'></span>

<h3>Description</h3>

<p>Calculate closest point on the convex hull and put it outside that
point. Assume <code>d</code> is the center for each point cloud and then use
orig.data to calculate hull.</p>


<h3>Usage</h3>

<pre><code class='language-R'>outside.chull(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outside.chull_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="outside.chull_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='panel.superpose.dl'>panel superpose dl</h2><span id='topic+panel.superpose.dl'></span>

<h3>Description</h3>

<p>Call panel.superpose for the data points and then for the direct
labels. This is a proper lattice panel function that behaves much
like panel.superpose.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.superpose.dl(x, 
    y = NULL, subscripts, 
    groups, panel.groups, 
    method = NULL, .panel.superpose = lattice::panel.superpose, 
    type = "p", debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.superpose.dl_+3A_x">x</code></td>
<td>
<p>Vector of <code>x</code> values.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_y">y</code></td>
<td>
<p>Vector of <code>y</code> values.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_subscripts">subscripts</code></td>
<td>
<p>Subscripts of x,y,groups.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_groups">groups</code></td>
<td>
<p>Vector of group ids.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_panel.groups">panel.groups</code></td>
<td>
<p>To be parsed for default labeling <code>method</code>, and passed to
panel.superpose.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_method">method</code></td>
<td>
<p>Positioning Method for direct labeling. NULL indicates to choose a
Positioning Method based on the <code>panel.groups</code> function.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_.panel.superpose">.panel.superpose</code></td>
<td>
<p>The panel function to use for drawing data points.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_type">type</code></td>
<td>
<p>Plot <code>type</code>, used for default <code>method</code> dispatch.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_debug">debug</code></td>
<td>
<p>passed to <code><a href="directlabels.html#topic+dlgrob">dlgrob</a></code>.</p>
</td></tr>
<tr><td><code id="panel.superpose.dl_+3A_...">...</code></td>
<td>
<p>passed to real panel function, and to translator.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>loci &lt;- data.frame(
  ppp=c(rbeta(800,10,10),rbeta(100,0.15,1),rbeta(100,1,0.15)),
  type=factor(c(rep("NEU",800),rep("POS",100),rep("BAL",100))))
## 3 equivalent ways to make the same plot:
if(require(lattice)){
  print(direct.label( ## most user-friendly
    densityplot(~ppp,loci,groups=type,n=500)
  ))
  print(direct.label( ## exactly the same as above but with specific panel fns
    densityplot(
      ~ppp,loci,groups=type,n=500,
      panel=lattice::panel.superpose,
      panel.groups="panel.densityplot")
  ))
  ## using panel.superpose.dl as the panel function automatically adds
  ## direct labels
  print(densityplot(
    ~ppp,loci,groups=type,n=500,
    panel=panel.superpose.dl,panel.groups="panel.densityplot"
  ))
  ## Exploring custom panel and panel.groups functions
  if(require(nlme)){
    ## Say we want to use a simple linear model to explain rat body weight:
    fit &lt;- lm(weight~Time+Diet+Rat,BodyWeight)
    bw &lt;- BodyWeight
    bw$.fitted &lt;- predict(fit,BodyWeight)
    ## lots of examples to come, all with these arguments:
    ratxy &lt;- function(...){
      xyplot(weight~Time|Diet,bw,groups=Rat,type="l",layout=c(3,1),...)
    }
    ## No custom panel functions:
    ##regular &lt;- ratxy(par.settings=simpleTheme(col=c("red","black")))
    regular &lt;- ratxy()
    print(regular) ## normal lattice plot
    print(direct.label(regular)) ## with direct labels
    ## The direct label panel function panel.superpose.dl can be used to
    ## display direct labels as well:
    print(ratxy(panel=panel.superpose.dl,panel.groups="panel.xyplot"))
    print(ratxy(panel=function(...)
      panel.superpose.dl(panel.groups="panel.xyplot",...)))
    ## Not very user-friendly, since default label placement is
    ## impossible, but these should work:
    print(ratxy(
      panel=panel.superpose.dl,panel.groups=panel.xyplot,
      method=first.points))
    print(ratxy(panel=function(...)
      panel.superpose.dl(panel.groups=panel.xyplot,...),
      method=first.points))
    ## Custom panel.groups functions:
    ## This panel.groups function will display the model fits:
    panel.model &lt;- function(x,subscripts,col.line,...){
      panel.xyplot(x=x,subscripts=subscripts,col.line=col.line,...)
      llines(x,bw[subscripts,".fitted"],col=col.line,lty=2)
    }
    pg &lt;- ratxy(panel=lattice::panel.superpose,panel.groups=panel.model)
    print(pg)
    ## If you use panel.superpose.dl with a custom panel.groups function,
    ## you need to manually specify the Positioning Method, since the
    ## name of panel.groups is used to infer a default:
    print(direct.label(pg,method="first.qp"))
    print(ratxy(
      panel=panel.superpose.dl,panel.groups="panel.model",
      method="first.qp"))
    ## Custom panel function that draws a box around values:
    panel.line1 &lt;- function(ps=lattice::panel.superpose){
      function(y,...){
        panel.abline(h=range(y))
        ps(y=y,...)
      }
    }
    custom &lt;- ratxy(panel=panel.line1())
    print(custom)
    print(direct.label(custom))
    ## Alternate method, producing the same results, but using
    ## panel.superpose.dl in the panel function. This is useful for direct
    ## label plots where you use several datasets.
    print(ratxy(panel=panel.line1(panel.superpose.dl),panel.groups="panel.xyplot"))
    ## Lattice plot with custom panel and panel.groups functions:
    both &lt;- ratxy(panel=panel.line1(),panel.groups="panel.model")
    print(both)
    print(direct.label(both,method="first.qp"))
    print(ratxy(panel=panel.line1(panel.superpose.dl),
                panel.groups=panel.model,method="first.qp"))
  }
}

</code></pre>

<hr>
<h2 id='pkgFun'>pkgFun</h2><span id='topic+pkgFun'></span>

<h3>Description</h3>

<p>https://github.com/tdhock/directlabels/issues/2 CRAN won't
complain about this version of :::</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgFun(fun, pkg = "ggplot2")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgFun_+3A_fun">fun</code></td>
<td>
<p>fun </p>
</td></tr>
<tr><td><code id="pkgFun_+3A_pkg">pkg</code></td>
<td>
<p>pkg </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='polygon.method'>polygon method</h2><span id='topic+polygon.method'></span>

<h3>Description</h3>

<p>Make a Positioning Method that places non-overlapping speech
polygons at the first or last points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon.method(top.bottom.left.right, 
    offset.cm = 0.1, 
    padding.cm = 0.05, 
    custom.colors = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon.method_+3A_top.bottom.left.right">top.bottom.left.right</code></td>
<td>
<p>Character string indicating what side of the plot to label.</p>
</td></tr>
<tr><td><code id="polygon.method_+3A_offset.cm">offset.cm</code></td>
<td>
<p>Offset from the polygon to the most extreme data point.</p>
</td></tr>
<tr><td><code id="polygon.method_+3A_padding.cm">padding.cm</code></td>
<td>
<p>Padding <code><a href="directlabels.html#topic+inside">inside</a></code> the polygon.</p>
</td></tr>
<tr><td><code id="polygon.method_+3A_custom.colors">custom.colors</code></td>
<td>
<p>Positioning method applied just before <code><a href="directlabels.html#topic+draw.polygons">draw.polygons</a></code>, can set
box.color and text.color for custom colors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='positioning.functions'>Built-in Positioning Methods for direct label placement</h2><span id='topic+positioning.functions'></span><span id='topic+positioning.methods'></span>

<h3>Description</h3>

<p>When adding direct labels to a grouped plot, label
placement can be specified using a Positioning Method (or a list of
them), of the form function(d,...), where d is a data frame of the
points to plot, with columns x y groups. The job of the Positioning
Method(s) is to return the position of each direct label you want to
plot as a data frame, with 1 row for each label. Thus normally a
Positioning Method will return 1 row for each group. Several
built-in Positioning Methods are discussed below, but you can also
create your own, either from scratch or by using dl.indep and
dl.trans.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking &lt;toby.hocking@inria.fr&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### contourplot Positioning Methods
for(p in list({
## Example from help(contourplot)
require(stats)
require(lattice)
attach(environmental)
ozo.m &lt;- loess((ozone^(1/3)) ~ wind * temperature * radiation,
               parametric = c("radiation", "wind"), span = 1, degree = 2)
w.marginal &lt;- seq(min(wind), max(wind), length.out = 50)
t.marginal &lt;- seq(min(temperature), max(temperature), length.out = 50)
r.marginal &lt;- seq(min(radiation), max(radiation), length.out = 4)
wtr.marginal &lt;- list(wind = w.marginal, temperature = t.marginal,
                     radiation = r.marginal)
grid &lt;- expand.grid(wtr.marginal)
grid[, "fit"] &lt;- c(predict(ozo.m, grid))
detach(environmental)
library(ggplot2)
p &lt;- ggplot(grid,aes(wind,temperature,z=fit))+
  stat_contour(aes(colour=..level..))+
  facet_wrap(~radiation)

},
{
## example from help(stat_contour)
library(reshape2)
volcano3d &lt;- melt(volcano)
names(volcano3d) &lt;- c("x", "y", "z")
library(ggplot2)
p &lt;- ggplot(volcano3d, aes(x, y, z = z))+
  stat_contour(aes(colour = ..level..))
})){
  print(direct.label(p,"bottom.pieces"))
  print(direct.label(p,"top.pieces"))
}

### densityplot Positioning Methods
for(p in list({
data(Chem97,package="mlmRev")
library(lattice)
p &lt;- densityplot(~gcsescore|gender,Chem97,
            groups=factor(score),layout=c(1,2),
            n=500,plot.points=FALSE)
},
{
library(reshape2)
iris2 &lt;- melt(iris,id="Species")
library(lattice)
p &lt;- densityplot(~value|variable,iris2,groups=Species,scales="free")
},
{
loci &lt;- data.frame(ppp=c(rbeta(800,10,10),rbeta(100,0.15,1),rbeta(100,1,0.15)),
                   type=factor(c(rep("NEU",800),rep("POS",100),rep("BAL",100))))
library(ggplot2)
p &lt;- qplot(ppp,data=loci,colour=type,geom="density")
})){
  print(direct.label(p,"top.bumptwice"))
  print(direct.label(p,"top.bumpup"))
  print(direct.label(p,"top.points"))
}

### dotplot Positioning Methods
for(p in list({
library(lattice)
p &lt;- dotplot(VADeaths,xlim=c(8,85),type="o")
},
{
vad &lt;- as.data.frame.table(VADeaths)
names(vad) &lt;- c("age","demographic","deaths")
library(ggplot2)
p &lt;- qplot(deaths,age,data=vad,group=demographic,geom="line",colour=demographic)+
  xlim(8,80)
})){
  print(direct.label(p,"angled.endpoints"))
  print(direct.label(p,"top.qp"))
}

### lineplot Positioning Methods
for(p in list({
data(BodyWeight,package="nlme")
library(lattice)
p &lt;- xyplot(weight~Time|Diet,BodyWeight,groups=Rat,type='l',
       layout=c(3,1),xlim=c(-10,75))
},
{
data(Chem97,package="mlmRev")
library(lattice)
p &lt;- qqmath(~gcsescore|gender,Chem97,groups=factor(score),
       type=c('l','g'),f.value=ppoints(100))
},
{
data(Chem97,package="mlmRev")
library(lattice)
p &lt;- qqmath(~gcsescore,Chem97,groups=gender,
       type=c("l","g"),f.value=ppoints(100))
},
{
data(prostate,package="ElemStatLearn")
pros &lt;- subset(prostate,select=-train,train==TRUE)
ycol &lt;- which(names(pros)=="lpsa")
x &lt;- as.matrix(pros[-ycol])
y &lt;- pros[[ycol]]
library(lars)
fit &lt;- lars(x,y,type="lasso")
beta &lt;- scale(coef(fit),FALSE,1/fit$normx)
arclength &lt;- rowSums(abs(beta))
library(reshape2)
path &lt;- data.frame(melt(beta),arclength)
names(path)[1:3] &lt;- c("step","variable","standardized.coef")
library(ggplot2)
p &lt;- ggplot(path,aes(arclength,standardized.coef,colour=variable))+
  geom_line(aes(group=variable))+
  ggtitle("LASSO path for prostate cancer data calculated using the LARS")+
  xlim(0,20)
},
{
data(projectionSeconds, package="directlabels")
p &lt;- ggplot(projectionSeconds, aes(vector.length/1e6))+
  geom_ribbon(aes(ymin=min, ymax=max,
                  fill=method, group=method), alpha=1/2)+
  geom_line(aes(y=mean, group=method, colour=method))+
  ggtitle("Projection Time against Vector Length (Sparsity = 10
  guides(fill="none")+
  ylab("Runtime (s)")
},
{
## complicated ridge regression lineplot ex. fig 3.8 from Elements of
## Statistical Learning, Hastie et al.
myridge &lt;- function(f,data,lambda=c(exp(-seq(-15,15,l=200)),0)){
  require(MASS)
  require(reshape2)
  fit &lt;- lm.ridge(f,data,lambda=lambda)
  X &lt;- data[-which(names(data)==as.character(f[[2]]))]
  Xs &lt;- svd(scale(X)) ## my d's should come from the scaled matrix
  dsq &lt;- Xs$d^2
  ## make the x axis degrees of freedom
  df &lt;- sapply(lambda,function(l)sum(dsq/(dsq+l)))
  D &lt;- data.frame(t(fit$coef),lambda,df) # scaled coefs
  molt &lt;- melt(D,id=c("lambda","df"))
  ## add in the points for df=0
  limpts &lt;- transform(subset(molt,lambda==0),lambda=Inf,df=0,value=0)
  rbind(limpts,molt)
}
data(prostate,package="ElemStatLearn")
pros &lt;- subset(prostate,train==TRUE,select=-train)
m &lt;- myridge(lpsa~.,pros)
library(lattice)
p &lt;- xyplot(value~df,m,groups=variable,type="o",pch="+",
       panel=function(...){
         panel.xyplot(...)
         panel.abline(h=0)
         panel.abline(v=5,col="grey")
       },
       xlim=c(-1,9),
       main="Ridge regression shrinks least squares coefficients",
       ylab="scaled coefficients",
       sub="grey line shows coefficients chosen by cross-validation",
       xlab=expression(df(lambda)))
},
{
library(ggplot2)
tx &lt;- time(mdeaths)
Time &lt;- ISOdate(floor(tx),round(tx
uk.lung &lt;- rbind(data.frame(Time,sex="male",deaths=as.integer(mdeaths)),
                 data.frame(Time,sex="female",deaths=as.integer(fdeaths)))
p &lt;- qplot(Time,deaths,data=uk.lung,colour=sex,geom="line")+
  xlim(ISOdate(1973,9,1),ISOdate(1980,4,1))
})){
  print(direct.label(p,"angled.boxes"))
  print(direct.label(p,"first.bumpup"))
  print(direct.label(p,"first.points"))
  print(direct.label(p,"first.polygons"))
  print(direct.label(p,"first.qp"))
  print(direct.label(p,"lasso.labels"))
  print(direct.label(p,"last.bumpup"))
  print(direct.label(p,"last.points"))
  print(direct.label(p,"last.polygons"))
  print(direct.label(p,"last.qp"))
  print(direct.label(p,"lines2"))
  print(direct.label(p,"maxvar.points"))
  print(direct.label(p,"maxvar.qp"))
}

### scatterplot Positioning Methods
for(p in list({
data(mpg,package="ggplot2")
m &lt;- lm(cty~displ,data=mpg)
mpgf &lt;- fortify(m,mpg)
library(lattice)
library(latticeExtra)
p &lt;- xyplot(cty~hwy|manufacturer,mpgf,groups=class,aspect="iso",
       main="City and highway fuel efficiency by car class and manufacturer")+
  layer_(panel.abline(0,1,col="grey90"))
},
{
data(mpg,package="ggplot2")
m &lt;- lm(cty~displ,data=mpg)
mpgf &lt;- fortify(m,mpg)
library(lattice)
p &lt;- xyplot(jitter(.resid)~jitter(.fitted),mpgf,groups=factor(cyl))
},
{
library(lattice)
p &lt;- xyplot(jitter(Sepal.Length)~jitter(Petal.Length),iris,groups=Species)
},
{
data(mpg,package="ggplot2")
library(lattice)
p &lt;- xyplot(jitter(cty)~jitter(hwy),mpg,groups=class,
       main="Fuel efficiency depends on car size")
},
{
library(ggplot2)
data(mpg,package="ggplot2")
p &lt;- qplot(jitter(hwy),jitter(cty),data=mpg,colour=class,
      main="Fuel efficiency depends on car size")
},
{
data(normal.l2.cluster,package="directlabels")
library(ggplot2)
p &lt;- ggplot(normal.l2.cluster$path,aes(x,y))+
  geom_path(aes(group=row),colour="grey")+
  geom_point(aes(size=lambda),colour="grey")+
  geom_point(aes(colour=class),data=normal.l2.cluster$pts,pch=21,fill="white")+
  coord_equal()
})){
  print(direct.label(p,"ahull.grid"))
  print(direct.label(p,"chull.grid"))
  print(direct.label(p,"extreme.grid"))
  print(direct.label(p,"smart.grid"))
}


## End(Not run)
</code></pre>

<hr>
<h2 id='project.onto.segments'>project onto segments</h2><span id='topic+project.onto.segments'></span>

<h3>Description</h3>

<p>Given a point and a set of line segments representing a convex or
alpha hull, calculate the closest point on the segments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.onto.segments(m, 
    h, debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project.onto.segments_+3A_m">m</code></td>
<td>
<p><code>m</code> is 1 row, a center of a point cloud, we need to find the
distance to the closest point on each segment of the convex
hull.</p>
</td></tr>
<tr><td><code id="project.onto.segments_+3A_h">h</code></td>
<td>
<p>Data frame describing the line segments of the convex or alpha
hull.</p>
</td></tr>
<tr><td><code id="project.onto.segments_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
<tr><td><code id="project.onto.segments_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='projectionSeconds'>
Timings of projection algorithms
</h2><span id='topic+projectionSeconds'></span>

<h3>Description</h3>

<p>Timings of seconds for 3 projection algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(projectionSeconds)</code></pre>


<h3>Format</h3>

<p>A data frame with 603 observations on the following 6 variables.
</p>

<dl>
<dt><code>vector.length</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>method</code></dt><dd><p>a factor with levels
<code>Heap</code> <code>Random</code> <code>Sort</code></p>
</dd>
<dt><code>mean</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>sd</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>min</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>max</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mark Schmidt's prettyPlot code for MATLAB
http://www.di.ens.fr/~mschmidt/Software/prettyPlot.html
</p>

<hr>
<h2 id='qp.labels'>Make a Positioning Method for non-overlapping lineplot labels</h2><span id='topic+qp.labels'></span>

<h3>Description</h3>

<p>Use a QP solver to find the best places to put the points on a
line, subject to the constraint that they should not overlap.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp.labels(target.var, 
    lower.var, upper.var, 
    order.labels = function(d) order(d[, 
        target.var]), 
    limits = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qp.labels_+3A_target.var">target.var</code></td>
<td>
<p>Variable name of the label target.</p>
</td></tr>
<tr><td><code id="qp.labels_+3A_lower.var">lower.var</code></td>
<td>
<p>Variable name of the lower limit of each label bounding box.</p>
</td></tr>
<tr><td><code id="qp.labels_+3A_upper.var">upper.var</code></td>
<td>
<p>Variable name of the upper limit of each label bounding box.</p>
</td></tr>
<tr><td><code id="qp.labels_+3A_order.labels">order.labels</code></td>
<td>
<p>Function that takes the data.frame of labels and returns an
ordering, like from the order function. That ordering will be used
to reorder the rows. This is useful to e.g. break ties when two
groups have exactly the same value at the endpoint near the label.</p>
</td></tr>
<tr><td><code id="qp.labels_+3A_limits">limits</code></td>
<td>
<p>Function that takes the data.frame of labels an returns a numeric
vector of length 2. If finite, these values will be used to add
constraints to the QP: limits[1] is the lower limit for the first
label's <code>lower.var</code>, and limits[2] is the upper limit for the last
labels's <code>upper.var</code>. Or NULL for no <code>limits</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Positioning Method that adjusts <code>target.var</code> so there is no overlap
of the label bounding boxes, as specified by <code>upper.var</code> and
<code>lower.var</code>.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>SegCost$error &lt;- factor(SegCost$error,c("FP","FN","E","I"))
if(require(ggplot2)){
  fp.fn.colors &lt;- c(FP="skyblue",FN="#E41A1C",I="black",E="black")
  fp.fn.sizes &lt;- c(FP=2.5,FN=2.5,I=1,E=1)
  fp.fn.linetypes &lt;- c(FP="solid",FN="solid",I="dashed",E="solid")
  err.df &lt;- subset(SegCost,type!="Signal")

  kplot &lt;- ggplot(err.df,aes(segments,cost))+
    geom_line(aes(colour=error,size=error,linetype=error))+
    facet_grid(type~bases.per.probe)+
    scale_linetype_manual(values=fp.fn.linetypes)+
    scale_colour_manual(values=fp.fn.colors)+
    scale_size_manual(values=fp.fn.sizes)+
    scale_x_continuous(limits=c(0,20),breaks=c(1,7,20),minor_breaks=NULL)+
    theme_bw()+theme(panel.margin=grid::unit(0,"lines"))

  ## The usual ggplot without direct labels.
  print(kplot)

  ## Get rid of legend for direct labels.
  no.leg &lt;- kplot+guides(colour="none",linetype="none",size="none")

  ## Default direct labels.
  direct.label(no.leg)

  ## Explore several options for tiebreaking and limits. First let's
  ## make a qp.labels Positioning Method that does not tiebreak.
  no.tiebreak &lt;- list("first.points",
                      "calc.boxes",
                      qp.labels("y","bottom","top"))
  direct.label(no.leg, no.tiebreak)

  ## Look at the weird labels in the upper left panel. The E curve is
  ## above the FN curve, but the labels are the opposite! This is
  ## because they have the same y value on the first points, which are
  ## the targets for qp.labels. We need to tiebreak.
  qp.break &lt;- qp.labels("y","bottom","top",make.tiebreaker("x","y"))
  tiebreak &lt;- list("first.points",
                   "calc.boxes",
                   "qp.break")
  direct.label(no.leg, tiebreak)

  ## Enlarge the text size and spacing.
  tiebreak.big &lt;- list("first.points",
                       cex=2,
                       "calc.boxes",
                       dl.trans(h=1.25*h),
                       "calc.borders",
                       "qp.break")
  direct.label(no.leg, tiebreak.big)

  ## Even on my big monitor, the FP runs off the bottom of the screen
  ## in the top panels. To avoid that you can specify a limits
  ## function.

  ## Below, the ylimits function uses the limits of each panel, so
  ## labels appear inside the plot region. Also, if you resize your
  ## window so that it is small, you can see that the text size of the
  ## labels is decreased until they all fit in the plotting region.
  qp.limited &lt;-  qp.labels("y","bottom","top",make.tiebreaker("x","y"),ylimits)
  tiebreak.lim &lt;- list("first.points",
                       cex=2,
                       "calc.boxes",
                       dl.trans(h=1.25*h),
                       "calc.borders",
                       "qp.limited")
  direct.label(no.leg, tiebreak.lim)
}
</code></pre>

<hr>
<h2 id='reduce.cex'>reduce cex</h2><span id='topic+reduce.cex'></span>

<h3>Description</h3>

<p>If edges of the text are going out of the plotting
region, then decrease cex until it fits. We call <code><a href="directlabels.html#topic+calc.boxes">calc.boxes</a></code>
<code><a href="directlabels.html#topic+inside">inside</a></code>, so you should set cex before using this.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.cex(sides)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.cex_+3A_sides">sides</code></td>
<td>
<p>string: lr (left and right) or tb (top and bottom).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(lars) &amp;&amp; require(ggplot2)){
  data(diabetes,package="lars",envir=environment())
  X &lt;- diabetes$x
  colnames(X) &lt;- paste(colnames(X), colnames(X))
  fit &lt;- lars(X,diabetes$y,type="lasso")
  beta &lt;- scale(coef(fit),FALSE,1/fit$normx)
  arclength &lt;- rowSums(abs(beta))
  path.list &lt;- list()
  for(variable in colnames(beta)){
    standardized.coef &lt;- beta[, variable]
    path.list[[variable]] &lt;-
      data.frame(step=seq_along(standardized.coef),
                 arclength,
                 variable,
                 standardized.coef)
  }
  path &lt;- do.call(rbind, path.list)
  p &lt;- ggplot(path,aes(arclength,standardized.coef,colour=variable))+
    geom_line(aes(group=variable))
  ## the legend isn't very helpful.
  print(p)
  ## add direct labels at the end of the lines.
  direct.label(p, "last.points")
  ## on my screen, some of the labels go off the end, so we can use
  ## this Positioning Method to reduce the text size until the labels
  ## are on the plot.
  direct.label(p, list("last.points",reduce.cex("lr")))
  ## the default direct labels for lineplots are similar.
  direct.label(p)
}

</code></pre>

<hr>
<h2 id='reduce.cex.lr'>reduce cex lr</h2><span id='topic+reduce.cex.lr'></span>

<h3>Description</h3>

<p>If edges of the text are going left or right out of the plotting
region, then decrease cex until it fits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.cex.lr(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.cex.lr_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="reduce.cex.lr_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='reduce.cex.tb'>reduce cex tb</h2><span id='topic+reduce.cex.tb'></span>

<h3>Description</h3>

<p>If edges of the text are going over the top or bottom of the
plotting region, then decrease cex until it fits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce.cex.tb(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce.cex.tb_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="reduce.cex.tb_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='rhtmlescape'>rhtmlescape</h2><span id='topic+rhtmlescape'></span>

<h3>Description</h3>

<p>for standards compliance we should escape &lt;&gt;&amp;</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhtmlescape(code)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhtmlescape_+3A_code">code</code></td>
<td>
<p>R <code>code</code> to be displayed on a HTML page between pre tags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standards compliant HTML to display.</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='right.points'>right points</h2><span id='topic+right.points'></span>

<h3>Description</h3>

<p>Positioning Method for the last of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>right.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="right.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='right.polygons'>right polygons</h2><span id='topic+right.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the last point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"right.polygons"</code></pre>

<hr>
<h2 id='SegCost'>
Cost of segmentation models
</h2><span id='topic+SegCost'></span>

<h3>Description</h3>

<p>20 segmentation models were fit to 2 simulated signals, and several
different error measures were used to quantify the model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SegCost)</code></pre>


<h3>Format</h3>

<p>A data frame with 560 observations on the following 5 variables.
</p>

<dl>
<dt><code>bases.per.probe</code></dt><dd><p>a factor with levels <code>374</code>
<code>7</code>: the sampling density of the signal.</p>
</dd>
<dt><code>segments</code></dt><dd><p>numeric: the model complexity
measured using number of segments.</p>
</dd>
<dt><code>cost</code></dt><dd><p>numeric: the cost value.</p>
</dd>
<dt><code>type</code></dt><dd><p>a factor with levels <code>Signal</code>
<code>Breakpoint</code> <code>Complete</code> <code>Incomplete</code>
<code>Positive</code>: how to judge model fit? Signal: log mean squared
error between latent signal and estimated signal. Breakpoint:
exact breakpoint error. Complete: annotation error with a complete
set of annotations. Incomplete: annotation error with only half of
those annotations. Positive: no negative annotations.</p>
</dd>
<dt><code>error</code></dt><dd><p>a factor with levels <code>E</code> <code>FP</code>
<code>FN</code> <code>I</code>: what kind of error? FP = False
Positive, FN = False Negative, I = Imprecision, E = Error
(sum of the other terms).</p>
</dd>
</dl>



<h3>Source</h3>

<p>PhD thesis of Toby Dylan Hocking, chapter Optimal penalties for
breakpoint detection using segmentation model selection.
</p>

<hr>
<h2 id='smart.grid'>smart grid</h2><span id='topic+smart.grid'></span>

<h3>Description</h3>

<p>Search the plot region for a label position near the center of
each point cloud.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"smart.grid"</code></pre>

<hr>
<h2 id='static.labels'>static labels</h2><span id='topic+static.labels'></span>

<h3>Description</h3>

<p>to hard-code label positions...</p>


<h3>Usage</h3>

<pre><code class='language-R'>static.labels(x, y, groups, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="static.labels_+3A_x">x</code></td>
<td>
<p>x </p>
</td></tr>
<tr><td><code id="static.labels_+3A_y">y</code></td>
<td>
<p>y </p>
</td></tr>
<tr><td><code id="static.labels_+3A_groups">groups</code></td>
<td>
<p>groups </p>
</td></tr>
<tr><td><code id="static.labels_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='svmtrain'>
False positive rates from several 1-SVM models
</h2><span id='topic+svmtrain'></span>

<h3>Description</h3>

<p>Support Vector Machine density estimation (1-SVM) was applied to a set
of negative control samples, and then used to test on a positive control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(svmtrain)</code></pre>


<h3>Format</h3>

<p>A data frame with 378 observations on the following 5 variables.
</p>

<dl>
<dt><code>replicate</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code>
<code>3</code>, the experimental replicate. We fit 1-SVM models to each
replicate separately.</p>
</dd>
<dt><code>rate</code></dt><dd><p>a numeric vector, the percent of observations
that were outside the trained model.</p>
</dd>
<dt><code>data</code></dt><dd><p>a factor with levels <code>KIF11</code> <code>test</code>
<code>train</code>, which set of observations did we measure. test and
train are each 50% random splits of the negative controls in the
experiment, and KIF11 is the positive control in the experiment.</p>
</dd>
<dt><code>gamma</code></dt><dd><p>a numeric vector, the tuning parameter of the
radial basis function kernel.</p>
</dd>
<dt><code>nu</code></dt><dd><p>a numeric vector, the regularization parameter
of the 1-SVM.</p>
</dd>
</dl>


<hr>
<h2 id='top.bumptwice'>top bumptwice</h2><span id='topic+top.bumptwice'></span>

<h3>Description</h3>

<p>Label the tops, bump labels up to avoid other labels, then to the
side to avoid collisions with points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.bumptwice(d, debug = FALSE, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top.bumptwice_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="top.bumptwice_+3A_debug">debug</code></td>
<td>
<p>debug </p>
</td></tr>
<tr><td><code id="top.bumptwice_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='top.bumpup'>top bumpup</h2><span id='topic+top.bumpup'></span>

<h3>Description</h3>

<p>Label the tops, but bump labels up to avoid collisions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"top.bumpup"</code></pre>

<hr>
<h2 id='top.pieces'>top pieces</h2><span id='topic+top.pieces'></span>

<h3>Description</h3>

<p>Positioning Method for the top of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.pieces(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top.pieces_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="top.pieces_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='top.points'>top points</h2><span id='topic+top.points'></span>

<h3>Description</h3>

<p>Positioning Method for the top of a group of points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>top.points(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top.points_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="top.points_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='top.polygons'>top polygons</h2><span id='topic+top.polygons'></span>

<h3>Description</h3>

<p>Draw a speech polygon to the top point.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"top.polygons"</code></pre>

<hr>
<h2 id='top.qp'>top qp</h2><span id='topic+top.qp'></span>

<h3>Description</h3>

<p>Label points at the top, making sure they don't collide.</p>


<h3>Usage</h3>

<pre><code class='language-R'>"top.qp"</code></pre>

<hr>
<h2 id='uselegend.ggplot'>uselegend ggplot</h2><span id='topic+uselegend.ggplot'></span>

<h3>Description</h3>

<p>Show the ggplot2 legend, for comparison.</p>


<h3>Usage</h3>

<pre><code class='language-R'>uselegend.ggplot(p, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uselegend.ggplot_+3A_p">p</code></td>
<td>
<p>The ggplot object.</p>
</td></tr>
<tr><td><code id="uselegend.ggplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='uselegend.trellis'>uselegend trellis</h2><span id='topic+uselegend.trellis'></span>

<h3>Description</h3>

<p>Add a legend to a trellis plot, for comparison.</p>


<h3>Usage</h3>

<pre><code class='language-R'>uselegend.trellis(p, 
    ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uselegend.trellis_+3A_p">p</code></td>
<td>
<p>The trellis object.</p>
</td></tr>
<tr><td><code id="uselegend.trellis_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='vertical.qp'>vertical qp</h2><span id='topic+vertical.qp'></span>

<h3>Description</h3>

<p>Make a Positioning Function from a set of points on a vertical
line that will be spaced out using <code><a href="directlabels.html#topic+qp.labels">qp.labels</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertical.qp(M)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertical.qp_+3A_m">M</code></td>
<td>
<p>M </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='visualcenter'>visualcenter</h2><span id='topic+visualcenter'></span>

<h3>Description</h3>

<p>Point in the middle of the min and max for each group.</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualcenter(d, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualcenter_+3A_d">d</code></td>
<td>
<p>d </p>
</td></tr>
<tr><td><code id="visualcenter_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='xlimits'>xlimits</h2><span id='topic+xlimits'></span>

<h3>Description</h3>

<p>Return the positions of the plot horizontal limits in cm, for use
as the limit argument to <code><a href="directlabels.html#topic+qp.labels">qp.labels</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>xlimits(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xlimits_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

<hr>
<h2 id='ylimits'>ylimits</h2><span id='topic+ylimits'></span>

<h3>Description</h3>

<p>Return the positions of the plot vertical limits in cm, for use as
the limit argument to <code><a href="directlabels.html#topic+qp.labels">qp.labels</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ylimits(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ylimits_+3A_...">...</code></td>
<td>
<p>... </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
