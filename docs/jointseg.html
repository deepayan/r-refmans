<!DOCTYPE html><html><head><title>Help for package jointseg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jointseg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anotherBkp'><p>Get best candidate change point</p></a></li>
<li><a href='#binMissingValues'><p>binMissingValues</p></a></li>
<li><a href='#defaultWeights'><p>Compute default weights for the weighted group fused Lasso</p></a></li>
<li><a href='#doCBS'><p>Run CBS segmentation</p></a></li>
<li><a href='#doDynamicProgramming'><p>Run segmentation by dynamic programming</p></a></li>
<li><a href='#doGFLars'><p>Group fused Lars segmentation</p></a></li>
<li><a href='#doPSCBS'><p>Run Paired PSCBS segmentation</p></a></li>
<li><a href='#doPSCN'><p>Run PSCN segmentation (defunct)</p></a></li>
<li><a href='#doRBS'><p>Run RBS segmentation</p></a></li>
<li><a href='#estimateSd'><p>Robust standard deviation estimator</p></a></li>
<li><a href='#Fpsn'><p>Pruned dynamic programming algorithm</p></a></li>
<li><a href='#getCopyNumberDataByResampling'><p>Generate a copy number profile by resampling</p></a></li>
<li><a href='#getTpFp'><p>Calculate the number of true positives and false positives</p></a></li>
<li><a href='#getUnivJ'><p>Get the contribution of one dimension to the RSE.</p></a></li>
<li><a href='#getUnivStat'><p>Get the binary test statistic for one dimension</p></a></li>
<li><a href='#jointSeg'><p>Joint segmentation of multivariate signals</p></a></li>
<li><a href='#leftMultiplyByInvXAtXA'><p>leftMultiplyByInvXAtXA</p></a></li>
<li><a href='#leftMultiplyByXt'><p>leftMultiplyByXt</p></a></li>
<li><a href='#mapPositionsBack'><p>mapPositionsBack</p></a></li>
<li><a href='#modelSelection'><p>Model selection</p></a></li>
<li><a href='#multiplyXtXBySparse'><p>multiplyXtXBySparse</p></a></li>
<li><a href='#oneBkp'><p>Get best candidate change point</p></a></li>
<li><a href='#plotSeg'><p>Plot signal and breakpoints with segment-level signal estimates</p></a></li>
<li><a href='#prof'><p>profile time and memory usage of a given R expression</p></a></li>
<li><a href='#pruneByDP'><p>Exact segmentation of a multivariate signal using dynamic programming.</p></a></li>
<li><a href='#PSSeg'><p>Parent-Specific copy number segmentation</p></a></li>
<li><a href='#randomProfile'><p>Generate a random multi-dimensional profile with breakpoints and noise</p></a></li>
<li><a href='#retour_sn'><p>Extract endpoint matrix from DP result</p></a></li>
<li><a href='#segmentByGFLars'><p>Group fused Lars segmentation (low-level)</p></a></li>
<li><a href='#segmentByRBS'><p>Recursive Binary Segmentation (low-level)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Segmentation of Multivariate (Copy Number) Signals</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for fast segmentation of multivariate
    signals into piecewise constant profiles and for generating realistic
    copy-number profiles. A typical application is the joint segmentation of total
    DNA copy numbers and allelic ratios obtained from Single Nucleotide Polymorphism
    (SNP) microarrays in cancer studies. The methods are described in Pierre-Jean, 
    Rigaill and Neuvial (2015) &lt;<a href="https://doi.org/10.1093%2Fbib%2Fbbu026">doi:10.1093/bib/bbu026</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>acnr (&ge; 0.3.1), matrixStats (&ge; 0.6.0), DNAcopy</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PSCBS, R.cache, digest, changepoint (&ge; 1.0.2), knitr,
rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mpierrejean/jointseg">https://github.com/mpierrejean/jointseg</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mpierrejean/jointseg/issues">https://github.com/mpierrejean/jointseg/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-11 10:58:39 UTC; mpierre-jean</td>
</tr>
<tr>
<td>Author:</td>
<td>Morgane Pierre-Jean [aut, cre],
  Pierre Neuvial [aut],
  Guillem Rigaill [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Morgane Pierre-Jean &lt;mpierrejean.pro@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-11 12:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='anotherBkp'>Get best candidate change point</h2><span id='topic+anotherBkp'></span>

<h3>Description</h3>

<p>Get best candidate change point according to binary segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anotherBkp(Y, weightFUN = defaultWeights, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anotherBkp_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> matrix, <code>p</code> signals of length <code>n</code> to be
segmented (centered by column)</p>
</td></tr>
<tr><td><code id="anotherBkp_+3A_weightfun">weightFUN</code></td>
<td>
<p>A <code>function</code> returning a <code>(n-1)*1</code> vector of
weights for the candidate change point positions. Default weights yield the
likelihood ratio test (LRT) statistic for the identification of a single
change point.</p>
</td></tr>
<tr><td><code id="anotherBkp_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contrary to <code>oneBkp</code>, <code>anotherBkp</code> handles missing values (NA:s).
</p>


<h3>Value</h3>

<p>A numerical value, a candidate breakpoint position
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
n &lt;- 100

sim &lt;- randomProfile(n, 1, 1, p)
Y &lt;- sim$profile
bkp &lt;- anotherBkp(Y)
print(bkp)
print(oneBkp(Y))
##  stopifnot(identical(oneBkp(Y), bkp))
plotSeg(Y, list(sim$bkp, bkp))

## robustness to NA:s
h &lt;- 2
idxs &lt;- seq(from=max(sim$bkp[1]-h, 1), min(sim$bkp[1]+h, n))
Y[idxs, p] &lt;- NA
oneBkp(Y)  ## does not work
bkp &lt;- anotherBkp(Y)  ## works
bkp-sim$bkp

</code></pre>

<hr>
<h2 id='binMissingValues'>binMissingValues</h2><span id='topic+binMissingValues'></span>

<h3>Description</h3>

<p>Perform binning in order to remove missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binMissingValues(Y, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binMissingValues_+3A_y">Y</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="binMissingValues_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ? 
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some segmentation methods (in particular, GFLars) do not natively handle the 
situation when some observations have missing values in one or more 
dimensions. In order to avoid dropping the corresponding observations 
entirely, <code>binMissingValues</code> bins the signal values of the last complete
observation before a (range of) observations with missing entries using the 
<code><a href="matrixStats.html#topic+binMeans">binMeans</a></code> function.
</p>
<p>In the specific case when the first row has NA values, the first non-missing 
entry is replicated in order to make smoothing possible.  This choice is 
arbitrary but some arbitrary choice is needed in that case.
</p>


<h3>Note</h3>

<p>Currently this function is only used by <code><a href="#topic+doGFLars">doGFLars</a></code> in order
to make it possible to run GFLars segmentation on SNP array data where most
markers (on the order of 2/3 to 5/6) have missing values, because of 
uninformative or missing allelic ratio signals.
</p>
<p>The <code>binMissingValues</code> function may be used for other segmentation 
methods suffering from the same limitation.  However, we emphasize that 
handling missing values natively in the segmentation method would be a 
better solution.
</p>
<p>Currently this function is only used by <code><a href="#topic+doGFLars">doGFLars</a></code> in order
to make it possible to run GFLars segmentation on SNP array data where most
markers (on the order of 2/3 to 5/6) have missing values, because of 
uninformative or missing allelic ratio signals. The <code>binMissingValues</code>
function may be used for other segmentation methods suffering from the same
limitation.  However, we emphasize that handling missing values natively in
the segmentation method would be a better solution.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for 
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple 
change-points shared by many signals using group LARS. Advances in Neural 
Information Processing Systems, 23, 2343-2351.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim &lt;- randomProfile(10, 1, 0.1, 3)
Y &lt;- sim$profile
Y[c(4, 8), 2] &lt;- NA
Y[c(7, 8), 3] &lt;- NA

res &lt;- binMissingValues(Y)

Y &lt;- sim$profile
Y[1:5, 2] &lt;- NA
Yb &lt;- binMissingValues(Y)

Y &lt;- sim$profile
Y[3:5, 2] &lt;- NA
Yb &lt;- binMissingValues(Y)

</code></pre>

<hr>
<h2 id='defaultWeights'>Compute default weights for the weighted group fused Lasso</h2><span id='topic+defaultWeights'></span>

<h3>Description</h3>

<p>Compute default weights for the weighted group fused Lasso
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultWeights(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultWeights_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of default weights in the reference article.
</p>


<h3>Note</h3>

<p>This implementation is derived from the MATLAB code by Vert and
Bleakley: <a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
defaultWeights(10)

</code></pre>

<hr>
<h2 id='doCBS'>Run CBS segmentation</h2><span id='topic+doCBS'></span>

<h3>Description</h3>

<p>This function is a wrapper for convenient use of the <code>CBS</code> segmentation
method by <code><a href="#topic+PSSeg">PSSeg</a></code>.  It applies the
<code><a href="DNAcopy.html#topic+segment">segment</a></code> function and reshapes the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doCBS(y, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doCBS_+3A_y">y</code></td>
<td>
<p>A numeric vector, the signal to be segmented</p>
</td></tr>
<tr><td><code id="doCBS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="DNAcopy.html#topic+segment">segment</a></code></p>
</td></tr>
<tr><td><code id="doCBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a single element: </p>
 <dl>
<dt>bkp</dt><dd><p>breakpoint positions </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>See Also</h3>

<p><code><a href="DNAcopy.html#topic+segment">segment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)

## generate a synthetic CN profile
K &lt;- 10
len &lt;- 1e4
sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
datS &lt;- sim$profile

## run CBS segmentation
res &lt;- doCBS(datS[["c"]])
getTpFp(res$bkp, sim$bkp, tol=5, relax = -1)   ## true and false positives
plotSeg(datS, breakpoints=list(sim$bkp, res$bkp))
</code></pre>

<hr>
<h2 id='doDynamicProgramming'>Run segmentation by dynamic programming</h2><span id='topic+doDynamicProgramming'></span>

<h3>Description</h3>

<p>High-level function for univariate or multivariate segmentation by dynamic
programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doDynamicProgramming(Y, K, stat = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doDynamicProgramming_+3A_y">Y</code></td>
<td>
<p>A numeric vector or a matrix, the signal to be segmented</p>
</td></tr>
<tr><td><code id="doDynamicProgramming_+3A_k">K</code></td>
<td>
<p>The number of change points to find</p>
</td></tr>
<tr><td><code id="doDynamicProgramming_+3A_stat">stat</code></td>
<td>
<p>A vector containing the names or indices of the columns of
<code>Y</code> to be segmented</p>
</td></tr>
<tr><td><code id="doDynamicProgramming_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the signal is uni-dimensional, this function simply uses the segmentation
method provided in the <code>cghseg</code> package reshapes the results.
</p>
<p>If the signal is multi-dimensional, this function applies the
<code><a href="#topic+pruneByDP">pruneByDP</a></code> function and reshapes the results.
</p>


<h3>Value</h3>

<table>
<tr><td><code>bkp</code></td>
<td>
<p>A vector of <code>K</code> indices for candidate change points</p>
</td></tr>
<tr><td><code>dpseg</code></td>
<td>
<p>A list of two elements </p>
 <dl>
<dt>bkp</dt><dd><p>A list of vectors
of change point positions for the best model with k change points, for k=1,
2, ... K</p>
</dd> <dt>rse</dt><dd><p>A vector of K+1 residual squared errors</p>
</dd> </dl>
</td></tr>
</table>


<h3>Note</h3>

<p>This is essentially a wrapper for convenient segmentation by dynamic
programming using the <code><a href="#topic+PSSeg">PSSeg</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Rigaill, G. (2015). A pruned dynamic programming algorithm to recover the best segmentations with 1 to K_max change-points. Journal de la Societe Francaise de Statistique, 156(4), 180-205.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)

## generate a synthetic CN profile
K &lt;- 10
len &lt;- 1e4
sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
datS &lt;- sim$profile

## run pruned DPA segmentation
resDP &lt;- doDynamicProgramming(datS[["c"]], K=K)
getTpFp(resDP$bkp, sim$bkp, tol=5, relax = -1)   ## true and false positives
plotSeg(datS, breakpoints=list(sim$bkp, resDP$bkp))

## run 2d dynamic programming segmentation
K &lt;- 2
len &lt;- 1e3
sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
datS &lt;- sim$profile
datS$d &lt;- 2*abs(datS$b-1/2)
datS[which(datS$genotype!=0.5),"d"] &lt;- NA
Y = cbind(datS$c,datS$d)
resDP2d &lt;- doDynamicProgramming(Y, K = K)

</code></pre>

<hr>
<h2 id='doGFLars'>Group fused Lars segmentation</h2><span id='topic+doGFLars'></span>

<h3>Description</h3>

<p>High-level function for multivariate fused Lars (GFLars) segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doGFLars(Y, K, stat = NULL, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doGFLars_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> signal to be segmented</p>
</td></tr>
<tr><td><code id="doGFLars_+3A_k">K</code></td>
<td>
<p>The number of change points to find</p>
</td></tr>
<tr><td><code id="doGFLars_+3A_stat">stat</code></td>
<td>
<p>A vector containing the names or indices of the columns of
<code>Y</code> to be segmented</p>
</td></tr>
<tr><td><code id="doGFLars_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to 'segmentByGFLars'</p>
</td></tr>
<tr><td><code id="doGFLars_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the lower-level segmentation function
<code><a href="#topic+segmentByGFLars">segmentByGFLars</a></code>. It can be run on p-dimensional,
piecewise-constant data in order to defined a set of candidate change
points. It is recommended to prune this list of candidates using dynamic
programming (<code><a href="#topic+pruneByDP">pruneByDP</a></code>), combined with a selection of the best
number of change points. The <code><a href="#topic+jointSeg">jointSeg</a></code> function provides a
convenient wrapper for performing segmentation, pruning and model selection.
</p>
<p>For the specific case of DNA copy number data segmentation, see the
dedicated wrapper <code><a href="#topic+PSSeg">PSSeg</a></code>.
</p>
<p>The default weights <code class="reqn">\sqrt{n/(i*(n-i))}</code> are calibrated as suggested by
Bleakley and Vert (2011).  Using this calibration, the first breakpoint
maximizes the likelihood ratio test (LRT) statistic.
</p>


<h3>Value</h3>

<p>An object of the same structure as the output of
<code><a href="#topic+segmentByGFLars">segmentByGFLars</a></code>
</p>


<h3>Note</h3>

<p>This implementation is derived from the MATLAB code by Vert and
Bleakley: <a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple change-points
shared by many signals using group LARS. Advances in Neural Information
Processing Systems, 23, 2343-2351.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
trueK &lt;- 10
sim &lt;- randomProfile(1e4, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- doGFLars(Y, K)
print(res$bkp)
print(sim$bkp)
plotSeg(Y, res$bkp)

## a toy example with missing values
sim &lt;- randomProfile(1e2, 1, 0.1, 2)
Y &lt;- sim$profile
Y[3:50, 2] &lt;- NA

res &lt;- doGFLars(Y, 10, 2, verbose=TRUE)
print(res$bkp)
print(sim$bkp)
plotSeg(Y, res$bkp)

</code></pre>

<hr>
<h2 id='doPSCBS'>Run Paired PSCBS segmentation</h2><span id='topic+doPSCBS'></span>

<h3>Description</h3>

<p>This function is a wrapper for convenient use of the <code>PSCBS</code>
segmentation method by <code><a href="#topic+PSSeg">PSSeg</a></code>.  It applies the
<code><a href="PSCBS.html#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code> function and reshapes the results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doPSCBS(Y, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doPSCBS_+3A_y">Y</code></td>
<td>
<p>A matrix of signals to be segmented, containing the following
columns </p>
 <dl>
<dt>c</dt><dd><p>total copy numbers</p>
</dd> <dt>b</dt><dd><p>allele B fractions
(a.k.a. BAF)</p>
</dd> <dt>genotype</dt><dd><p>germline genotypes</p>
</dd> </dl>
</td></tr>
<tr><td><code id="doPSCBS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="PSCBS.html#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code></p>
</td></tr>
<tr><td><code id="doPSCBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a single element: </p>
 <dl>
<dt>bkp</dt><dd><p>breakpoint positions </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>See Also</h3>

<p><code><a href="PSCBS.html#topic+segmentByPairedPSCBS">segmentByPairedPSCBS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    ## load known real copy number regions
    affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)

    ## generate a synthetic CN profile
    K &lt;- 10
    len &lt;- 1e4
    sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
    datS &lt;- sim$profile

    ## run PSCBS segmentation
    Y &lt;- as.matrix(subset(datS, select=c(c, b, genotype)))
    res &lt;- doPSCBS(Y)
    getTpFp(res$bkp, sim$bkp, tol=5, relax = -1)   ## true and false positives
    plotSeg(datS, breakpoints=list(sim$bkp, res$bkp))

## End(Not run)
</code></pre>

<hr>
<h2 id='doPSCN'>Run PSCN segmentation (defunct)</h2><span id='topic+doPSCN'></span>

<h3>Description</h3>

<p>The 'PSCN' package is not maintained anymore and it is not available for R
&gt;= 3.0.0.  The original 'doPSCN' function has been moved to the directory
'zzz.defunct'.  The skeleton of that function is kept for backward
compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doPSCN(Y, alpha = 0.01, platform = c("Illumina", "Affymetrix"),
  verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doPSCN_+3A_y">Y</code></td>
<td>
<p>The signal to be segmented, a matrix containing the following
columns: </p>
 <dl>
<dt>c</dt><dd><p>Total copy number (log scale)</p>
</dd> <dt>b</dt><dd><p>Allele
B fraction (a.k.a. BAF)</p>
</dd> </dl>
</td></tr>
<tr><td><code id="doPSCN_+3A_alpha">alpha</code></td>
<td>
<p>sensitivity level in [0,1] to be passed to
<code>PSCN::segmentation</code>.</p>
</td></tr>
<tr><td><code id="doPSCN_+3A_platform">platform</code></td>
<td>
<p>Specifies form which array platform 'Y' was generated:
Illumina or Affymetrix</p>
</td></tr>
<tr><td><code id="doPSCN_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="doPSCN_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>PSCN::smoothing</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Chen, H., Xing, H., &amp; Zhang, N. R. (2011). Estimation of parent
specific DNA copy number in tumors using high-density genotyping arrays.
PLoS computational biology, 7(1), e1001060.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSSeg">PSSeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print("The 'PSCN' package is not available for R &gt;= 3.0.0.")
print("See http://cran.r-project.org/web/packages/PSCN/index.html")

</code></pre>

<hr>
<h2 id='doRBS'>Run RBS segmentation</h2><span id='topic+doRBS'></span>

<h3>Description</h3>

<p>High-level function for multivariate recursive binary (RBS) segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doRBS(Y, K, stat = NULL, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doRBS_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> signal to be segmented</p>
</td></tr>
<tr><td><code id="doRBS_+3A_k">K</code></td>
<td>
<p>The number of change points to find</p>
</td></tr>
<tr><td><code id="doRBS_+3A_stat">stat</code></td>
<td>
<p>A vector containing the names or indices of the columns of
<code>Y</code> to be segmented</p>
</td></tr>
<tr><td><code id="doRBS_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to 'segmentByRBS'</p>
</td></tr>
<tr><td><code id="doRBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the lower-level segmentation function
<code><a href="#topic+segmentByRBS">segmentByRBS</a></code>. It can be run on p-dimensional,
piecewise-constant data in order to defined a set of candidate change
points. It is recommended to prune this list of candidates using dynamic
programming (<code><a href="#topic+pruneByDP">pruneByDP</a></code>), combined with a selection of the best
number of change points. The <code><a href="#topic+jointSeg">jointSeg</a></code> function provides a
convenient wrapper for performing segmentation, pruning and model selection.
</p>


<h3>Value</h3>

<p>An object of the same structure as the output of
<code><a href="#topic+segmentByRBS">segmentByRBS</a></code>
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Gey, S., &amp; Lebarbier, E. (2008). Using CART to Detect Multiple
Change Points in the Mean for Large Sample.
http://hal.archives-ouvertes.fr/hal-00327146/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSSeg">PSSeg</a></code>, <code><a href="#topic+pruneByDP">pruneByDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
trueK &lt;- 10
len &lt;- 5e4
sim &lt;- randomProfile(len, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- doRBS(Y, K)
getTpFp(res$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

cols &lt;- rep(2, K)
cols[1:trueK] &lt;- 3
par(mfrow=c(p,1))
for (ii in 1:p) {
    plot(Y[, ii], pch=19, cex=0.2)
    abline(v=res$bkp[1:trueK], col= cols)
    abline(v=sim$bkp, col=8, lty=2)
}

## NA:s in one dimension at a true breakpoint
jj &lt;- sim$bkp[1]
Y[jj-seq(-10, 10), p] &lt;- NA
res2 &lt;- doRBS(Y, K)
getTpFp(res2$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

## NA:s in both dimensions at a true breakpoint
Y[jj-seq(-10, 10), ] &lt;- NA
res3 &lt;- doRBS(Y, K)
getTpFp(res3$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

</code></pre>

<hr>
<h2 id='estimateSd'>Robust standard deviation estimator</h2><span id='topic+estimateSd'></span>

<h3>Description</h3>

<p>Estimate standard deviation of an unimodal signal with possible changes in
mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSd(y, method = c("Hall", "von Neumann"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSd_+3A_y">y</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="estimateSd_+3A_method">method</code></td>
<td>
<p>Method used to estimate standard deviation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>von Neumann's estimator is proportional to the mean absolute deviation
(<code>mad</code>) of the first-order differences of the original signals:
<code>mad(diff(y)</code>.  By construction this estimator is robust to 1) changes
in the mean of the signal (through the use of differences) and 2) outliers
(through the use of <code>mad</code> instead of <code>mean</code>).
</p>
<p>The proportionality constant <code class="reqn">1/\sqrt 2 \times 1/\Phi^{-1}(3/4)</code> ensures
that the resulting estimator is consistent for the estimation of the
standard deviation in the case of Gaussian signals.
</p>
<p>Hall's estimator is a weigthed sum of squared elements of y. Let m=3.
<code class="reqn">sigma^2 =
(\sum_{k=1}^{n-m}\sum_{j=1}^{m+1}(\code{wei[i]}\code{y}[i+k])^2)/(n-m)</code>
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Von Neumann, J., Kent, R. H., Bellinson, H. R., &amp; Hart, B. T.
(1941). The mean square successive difference. The Annals of Mathematical
Statistics, 153-162.
</p>
<p>Peter Hall, J. W. Kay and D. M. Titterington (1990). Asymptotically Optimal
Difference-Based Estimation of Variance in Nonparametric Regression
Biometrika,521-528
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1e4
y &lt;- rnorm(n)  ## a signal with no change in mean
estimateSd(y)
estimateSd(y, method="von Neumann")
sd(y)
mad(y)

z &lt;- y + rep(c(0,2), each=n/2)  ## a signal with *a single* change in mean
estimateSd(z)
estimateSd(z, method="von Neumann")
sd(z)
mad(z)

z &lt;- y + rep(c(0,2), each=100)  ## a signal with many changes in mean
estimateSd(z)
estimateSd(z, method="von Neumann")
sd(z)
mad(z)  

</code></pre>

<hr>
<h2 id='Fpsn'>Pruned dynamic programming algorithm</h2><span id='topic+Fpsn'></span>

<h3>Description</h3>

<p>Low-level API for the pruned dynamic programming algorithm (pDPA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fpsn(x, Kmax, mini = min(x), maxi = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fpsn_+3A_x">x</code></td>
<td>
<p>A vector of double : the signal to be segmented</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_kmax">Kmax</code></td>
<td>
<p>Max number of segments</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_mini">mini</code></td>
<td>
<p>Min value for the mean parameter of the segment</p>
</td></tr>
<tr><td><code id="Fpsn_+3A_maxi">maxi</code></td>
<td>
<p>Max value for the mean parameter of the segment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation uses functional pruning and segment neighborhood, and the L2-loss function
</p>


<h3>Value</h3>

<p>A list with a vector containing the position of the change-points
</p>


<h3>Author(s)</h3>

<p>Guillem Rigaill
</p>


<h3>References</h3>

<p>Rigaill, G. (2015). A pruned dynamic programming algorithm to recover the best segmentations with 1 to K_max change-points. Journal de la Societe Francaise de Statistique, 156(4), 180-205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+doDynamicProgramming">doDynamicProgramming</a></code> for a higher-level function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)

## generate a synthetic CN profile
K &lt;- 10
len &lt;- 1e4
sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
datS &lt;- sim$profile

## run pruned DPA segmentation
res &lt;- Fpsn(datS[["c"]], Kmax=2*K+1)

## plot segmentation results for the true number of breakpoints
bkp &lt;- res$t.est[K+1, 1:K]
plotSeg(datS, breakpoints=bkp)
</code></pre>

<hr>
<h2 id='getCopyNumberDataByResampling'>Generate a copy number profile by resampling</h2><span id='topic+getCopyNumberDataByResampling'></span>

<h3>Description</h3>

<p>Generate a copy number profile by resampling input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCopyNumberDataByResampling(length, nBkp = NA, bkp = NULL,
  regData = NULL, regions = NULL, regAnnot = NULL, minLength = 0,
  regionSize = 0, connex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCopyNumberDataByResampling_+3A_length">length</code></td>
<td>
<p>length of the profile</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_nbkp">nBkp</code></td>
<td>
<p>number of breakpoints.  If <code>NULL</code>, then argument <code>bkp</code>
is expected to be provided.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_bkp">bkp</code></td>
<td>
<p>a numeric vector of breakpoint positions that may be used to
bypass the breakpoint generation step.  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_regdata">regData</code></td>
<td>
<p>a data.frame containing copy number data for different types
of copy number regions.  Columns:</p>
 <dl>
<dt>c</dt><dd><p>Total copy number</p>
</dd>
<dt>b</dt><dd><p>Allele B fraction (a.k.a. BAF)</p>
</dd> <dt>region</dt><dd><p>a character value,
annotation label for the region. See Details.</p>
</dd> <dt>genotype</dt><dd><p>the
(germline) genotype of SNPs. By definition, rows with missing genotypes are
interpreted as non-polymorphic loci (a.k.a. copy number probes).</p>
</dd> </dl>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_regions">regions</code></td>
<td>
<p>a character vector of region labels that may be used to
bypass the region label generation step.  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_regannot">regAnnot</code></td>
<td>
<p>a data.frame containing annotation data for each copy number
region.  Columns: </p>
 <dl>
<dt>region</dt><dd><p>label of the form (must match
<code>regData[["region"]]</code>).</p>
</dd> <dt>freq</dt><dd><p>frequency (in [0,1]) of this type
of region in the genome.</p>
</dd> </dl>
<p> If <code>NULL</code> (the default), frequencies of
regions (0,1), (0,2), (1,1) and (1,2) (the most common alterations) are set
to represent 90% of the regions. <code>sum(regAnnot[["freq"]])</code> should be
1.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_minlength">minLength</code></td>
<td>
<p>minimum length of region between breakpoints.  Defaults to
0.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_regionsize">regionSize</code></td>
<td>
<p>If <code>regionSize&gt;0</code>, breakpoints are included by pairs,
where the distance within pair is set to <code>regionSize</code>.  <code>nBkp</code> is
then required to be an even number.</p>
</td></tr>
<tr><td><code id="getCopyNumberDataByResampling_+3A_connex">connex</code></td>
<td>
<p>If <code>TRUE</code>, any two successive regions are constrained to
be connex in the (minor CN, major CN) space.  See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a random copy number profile of length 'length',
with 'nBkp' breakpoints randomly chosen. Between two breakpoints, the
profile is constant and taken among the different types of regions in
<code>regData</code>.
</p>
<p>Elements of <code>regData[["region"]]</code> must be of the form <code>"(C1,C2)"</code>,
where <code>C1</code> denotes the minor copy number and <code>C2</code> denotes the
major copy number.  For example, </p>
 <dl>
<dt>(1,1)</dt><dd><p>Normal</p>
</dd>
<dt>(0,1)</dt><dd><p>Hemizygous deletion</p>
</dd> <dt>(0,0)</dt><dd><p>Homozygous deletion</p>
</dd>
<dt>(1,2)</dt><dd><p>Single copy gain</p>
</dd> <dt>(0,2)</dt><dd><p>Copy-neutral LOH</p>
</dd>
<dt>(2,2)</dt><dd><p>Balanced two-copy gain</p>
</dd> <dt>(1,3)</dt><dd><p>Unbalanced two-copy gain</p>
</dd>
<dt>(0,3)</dt><dd><p>Single-copy gain with LOH</p>
</dd> </dl>

<p>If 'connex' is set to TRUE (the default), transitions between copy number
regions are constrained in such a way that for any breakpoint, one of the
minor and the major copy number does not change.  Equivalently, this means
that all breakpoints can be seen in both total copy numbers and allelic
ratios.
</p>


<h3>Value</h3>

<p>A list with elements </p>
<dl>
<dt>profile</dt><dd><p>the profile (a <code>length</code> by <code>2</code> data.frame
containing the same fields as the input data <code>regData</code>.</p>
</dd> <dt>bkp</dt><dd><p>a
vector of bkp positions (the last row index before a breakpoint)</p>
</dd></dl>

<table>
<tr><td><code>regions</code></td>
<td>
<p>a character vector of region labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Pierre-Jean, M, Rigaill, G. J. and Neuvial, P. (2015). &quot;Performance
Evaluation of DNA Copy Number Segmentation Methods.&quot; *Briefings in
Bioinformatics*, no. 4: 600-615.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)
sim &lt;- getCopyNumberDataByResampling(len=1e4, nBkp=5, minLength=100, regData=affyDat)
plotSeg(sim$profile, sim$bkp)

## another run with identical parameters
bkp &lt;- sim$bkp
regions &lt;- sim$regions
sim2 &lt;- getCopyNumberDataByResampling(len=1e4, bkp=bkp, regData=affyDat, regions=regions)
plotSeg(sim2$profile, bkp)

## change tumor fraction but keep same "truth"
affyDatC &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=0.5)
simC &lt;- getCopyNumberDataByResampling(len=1e4, bkp=bkp, regData=affyDatC, regions=regions)
plotSeg(simC$profile, bkp)

## restrict to only normal, single copy gain, and copy-neutral LOH
## with the same bkp
affyDatR &lt;- subset(affyDat, region %in% c("(1,1)", "(0,2)", "(1,2)"))
simR &lt;- getCopyNumberDataByResampling(len=1e4, bkp=bkp, regData=affyDatR)
plotSeg(simR$profile, bkp)

## Same 'truth', on another dataSet
regions &lt;- simR$regions
illuDat &lt;- acnr::loadCnRegionData(dataSet="GSE11976", tumorFraction=1)
sim &lt;- getCopyNumberDataByResampling(len=1e4, bkp=bkp, regData=illuDat, regions=regions)
plotSeg(sim$profile, sim$bkp)

</code></pre>

<hr>
<h2 id='getTpFp'>Calculate the number of true positives and false positives</h2><span id='topic+getTpFp'></span>

<h3>Description</h3>

<p>Calculate the number of true positives and false positives among candidate
breakpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTpFp(candidates, trueBkp, tol, relax = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTpFp_+3A_candidates">candidates</code></td>
<td>
<p>Breakpoints found by the methods</p>
</td></tr>
<tr><td><code id="getTpFp_+3A_truebkp">trueBkp</code></td>
<td>
<p>True breakpoints</p>
</td></tr>
<tr><td><code id="getTpFp_+3A_tol">tol</code></td>
<td>
<p>Tolerance on the position of candidate breakpoints called true</p>
</td></tr>
<tr><td><code id="getTpFp_+3A_relax">relax</code></td>
<td>
<p>Controls the way multiple breapoints within tolerance area are
recorded.  </p>
 <dl>
<dt>1</dt><dd><p>count one true positive if there is at least
one breakpoint within tolerance area</p>
</dd> <dt>0</dt><dd><p>count one true positive only
if there is exactly one breakpoint within tolerance area</p>
</dd> <dt>-1</dt><dd><p>count
only one true positive if there is exactly one breakpoint within tolerance
area; other breakpoints are counted as false positives </p>
</dd></dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements: </p>
<dl>
<dt>TP</dt><dd><p>The number of true positives</p>
</dd>
<dt>FP</dt><dd><p>The number of false positives</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=0.7)

## generate a synthetic CN profile
K &lt;- 10
len &lt;- 2e4
sim &lt;- getCopyNumberDataByResampling(len, K, minLength=100, regData=affyDat)
datS &lt;- sim$profile

## (group-)fused Lasso segmentation
res &lt;- PSSeg(data=datS, K=2*K, method="GFLars", stat="c", profile=TRUE)

## results of the initial (group-)fused lasso segmentation
getTpFp(res$initBkp, sim$bkp, tol=10, relax=-1)
getTpFp(res$initBkp, sim$bkp, tol=10, relax=0)
getTpFp(res$initBkp, sim$bkp, tol=10, relax=1)
plotSeg(datS, breakpoints=list(sim$bkp, res$initBkp))

## results after pruning (group-)fused Lasso candidates by dynamic programming)
getTpFp(res$bestBkp, sim$bkp, tol=10, relax=-1)
getTpFp(res$bestBkp, sim$bkp, tol=10, relax=0)
getTpFp(res$bestBkp, sim$bkp, tol=10, relax=1)
plotSeg(datS, breakpoints=list(sim$bkp, res$bestBkp))
</code></pre>

<hr>
<h2 id='getUnivJ'>Get the contribution of one dimension to the RSE.</h2><span id='topic+getUnivJ'></span>

<h3>Description</h3>

<p>Get the contribution of one dimension to the Residual Squared Error (RSE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUnivJ(y, candCP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUnivJ_+3A_y">y</code></td>
<td>
<p>Input vector of signals for the considered dimension</p>
</td></tr>
<tr><td><code id="getUnivJ_+3A_candcp">candCP</code></td>
<td>
<p>A vector of candidate change points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <code><a href="#topic+pruneByDP">pruneByDP</a></code>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pruneByDP">pruneByDP</a></code>
</p>

<hr>
<h2 id='getUnivStat'>Get the binary test statistic for one dimension</h2><span id='topic+getUnivStat'></span>

<h3>Description</h3>

<p>Get the binary test statistic for one dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUnivStat(y, weightFUN = defaultWeights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUnivStat_+3A_y">y</code></td>
<td>
<p>Input vector of signals for the considered dimension</p>
</td></tr>
<tr><td><code id="getUnivStat_+3A_weightfun">weightFUN</code></td>
<td>
<p>A <code>function</code> returning a <code>(n-1)*1</code> vector of
weights for the candidate change point positions. See
<code><a href="#topic+anotherBkp">anotherBkp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <code><a href="#topic+anotherBkp">anotherBkp</a></code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>length(y)-1</code>, the binary test statistic for one dimension
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anotherBkp">anotherBkp</a></code>
</p>

<hr>
<h2 id='jointSeg'>Joint segmentation of multivariate signals</h2><span id='topic+jointSeg'></span>

<h3>Description</h3>

<p>Joint segmentation of multivariate signals in two steps: </p>
 
<ol>
<li><p>first-pass segmentation.  By default, a fast, greedy approach is used 
(see <code>method</code>). </p>
</li>
<li><p>pruning of the candidate change points obtained 
by dynamic programming </p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>jointSeg(Y, method = "RBS", stat = NULL, dpStat = stat,
  segFUN = NULL, jitter = NULL,
  modelSelectionMethod = ifelse(match(method, c("DynamicProgramming",
  "RBS", "GFLars"), nomatch = 0) &gt; 0, "Lebarbier", "none"),
  modelSelectionOnDP = (match(method, c("DynamicProgramming", "RBS",
  "GFLars"), nomatch = 0) &gt; 0), ..., profile = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointSeg_+3A_y">Y</code></td>
<td>
<p>The signal to be segmented (a matrix or a numeric vector)</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_method">method</code></td>
<td>
<p>A <code>character</code> value, the type of segmentation method used.
May be one of:  </p>
 <dl>
<dt>&quot;RBS&quot;</dt><dd><p>Recursive Binary Segmentation (the 
default), see <code><a href="#topic+segmentByRBS">segmentByRBS</a></code> as described in Gey and Lebarbier 
(2005)</p>
</dd> <dt>&quot;GFLars&quot;</dt><dd><p>Group fused LARS as described in Bleakley and Vert 
(2011).</p>
</dd> <dt>&quot;DP&quot;</dt><dd><p>Dynamic Programming (Bellman, 1956). For univariate 
signals the pruned DP of  Rigaill et al (2010) is used.</p>
</dd> <dt>&quot;other&quot;</dt><dd><p>The
segmentation method is passed as a function using argument <code>segFUN</code> 
(see examples in directory <code>otherMethods</code> of the <code>jointseg</code> 
package).</p>
</dd></dl>
</td></tr>
<tr><td><code id="jointSeg_+3A_stat">stat</code></td>
<td>
<p>A vector containing the names or indices of the columns of 
<code>Y</code> to be segmented</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_dpstat">dpStat</code></td>
<td>
<p>A vector containing the names or indices of the columns of 
<code>Y</code> to be segmented at the second round of segmentation. Defaults to 
the value of argument <code>stat</code>.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_segfun">segFUN</code></td>
<td>
<p>The segmentation function to be used when <code>method</code> is set 
to <code>other</code>. Not used otherwise.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_jitter">jitter</code></td>
<td>
<p>Uncertainty on breakpoint position after initial segmentation. 
Defaults to <code>NULL</code>.  See Details.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_modelselectionmethod">modelSelectionMethod</code></td>
<td>
<p>A character value, the name of the method used to
perform model selection.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_modelselectionondp">modelSelectionOnDP</code></td>
<td>
<p>A logical value. If <code>TRUE</code> (the default), 
model selection is performed on segmentation after dynamic programming; 
else model selection is performed on initial segmentation.  Only applies to
methods &quot;DP&quot;, &quot;RBS&quot; and &quot;GFLars&quot;.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the lower-level segmentation 
method determined by argument <code>method</code>.</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_profile">profile</code></td>
<td>
<p>A <code>logical</code> value: trace time and memory usage ?</p>
</td></tr>
<tr><td><code id="jointSeg_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ? 
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>modelSelectionOnDP</code> is set to <code>FALSE</code>, then model selection is 
run on the sets of the form <code>bkp[1:k]</code> for <code class="reqn">1 \leq k \leq 
length(bkp)</code>, where <code>bkp</code> is the set of breakpoints identified by the 
initial segmentation.  In particular, this implies that the candidate 
breakpoints in <code>bkp</code> are sorted by order of appearance and not by 
position.
</p>
<p>If <code>jitter</code> is not <code>NULL</code>, it should be a vector of integer
indices. The set of candidate breakpoints passed on to dynamic programming is
augmented by all indices distant from an element of <code>jitter</code> from one of
the candidates. For example, if <code>jitter==c(-1, 0, 1)</code> and the initial
set of breakpoints is <code>c(1,5)</code> then dynamic programming is run on
<code>c(1,2,4,5,6)</code>.
</p>
<p>If the return value of the initial segmentation has an element named
<code>dpseg</code>, then initial segmentation results are not pruned by dynamic
programming.
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple
change-points shared by many signals using group LARS. Advances in Neural
Information Processing Systems, 23, 2343-2351.
</p>
<p>Gey, S., &amp; Lebarbier, E. (2008). Using CART to Detect Multiple
Change Points in the Mean for Large Sample.
http://hal.archives-ouvertes.fr/hal-00327146/
</p>
<p>Rigaill, G. (2010). Pruned dynamic programming for optimal
multiple change-point detection. arXiv preprint arXiv:1004.0887.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pruneByDP">pruneByDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A two-dimensional signal
p &lt;- 2
trueK &lt;- 10
len &lt;- 1e4
sim &lt;- randomProfile(len, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- jointSeg(Y, method="RBS", K=K)
bkp &lt;- res$bestBkp
getTpFp(bkp, sim$bkp, tol=5, relax = -1)   ## true and false positives
plotSeg(Y, list(sim$bkp, res$bestBkp), col=1)

## Now we add some NA:s in one dimension
jj &lt;- sim$bkp[1]
Y[jj-seq(-10,10), p] &lt;- NA
res2 &lt;- jointSeg(Y, method="RBS", K=K, verbose=TRUE)
bkp &lt;- res2$bestBkp
getTpFp(res2$bestBkp, sim$bkp, tol=5, relax = -1)   ## true and false positives
</code></pre>

<hr>
<h2 id='leftMultiplyByInvXAtXA'>leftMultiplyByInvXAtXA</h2><span id='topic+leftMultiplyByInvXAtXA'></span>

<h3>Description</h3>

<p>Compute r = inv(X(:,ind)'*X(:,ind))*b , where X is the n*(n-1) design matrix
for the weighted group fused lasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leftMultiplyByInvXAtXA(n, ind, val, w = defaultWeights(n),
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leftMultiplyByInvXAtXA_+3A_n">n</code></td>
<td>
<p>The size of X is n*(n-1)</p>
</td></tr>
<tr><td><code id="leftMultiplyByInvXAtXA_+3A_ind">ind</code></td>
<td>
<p>a*1 vector of indices between 1 and n-1, sorted in increasing
order</p>
</td></tr>
<tr><td><code id="leftMultiplyByInvXAtXA_+3A_val">val</code></td>
<td>
<p>a*p matrix</p>
</td></tr>
<tr><td><code id="leftMultiplyByInvXAtXA_+3A_w">w</code></td>
<td>
<p>(n-1)*1 vector of weights</p>
</td></tr>
<tr><td><code id="leftMultiplyByInvXAtXA_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is derived from the MATLAB code of Vert and Bleakley:
<a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Value</h3>

<dl>
<dt>r</dt><dd><p>the (n-1)*p matrix equal to X'*Y</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple change-points
shared by many signals using group LARS. Advances in Neural Information
Processing Systems, 23, 2343-2351.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
val &lt;- matrix(c(1.56, 1.35, 1.26, 1.15), ncol=2)
ind &lt;- c(5,6)
n &lt;- 10
res &lt;- leftMultiplyByInvXAtXA(n=n, ind=ind, val=val)
res
##         [,1]      [,2]
## [1,] 1.373189 0.9630868
## [2,] 0.228796 0.3636429

</code></pre>

<hr>
<h2 id='leftMultiplyByXt'>leftMultiplyByXt</h2><span id='topic+leftMultiplyByXt'></span>

<h3>Description</h3>

<p>Compute X'*Y where X is the n*(n-1) design matrix for the weighted group
fused Lasso, with weights defined by the vector w, and Y is any n*p matrix.
The computation is done in O(np).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leftMultiplyByXt(Y, w = defaultWeights(nrow(Y)), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leftMultiplyByXt_+3A_y">Y</code></td>
<td>
<p>A n*p matrix</p>
</td></tr>
<tr><td><code id="leftMultiplyByXt_+3A_w">w</code></td>
<td>
<p>(n-1)*1 vector of weights</p>
</td></tr>
<tr><td><code id="leftMultiplyByXt_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is derived from the MATLAB code of Vert and Bleakley:
<a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.\
</p>
<p>Contrary to <code><a href="#topic+getUnivStat">getUnivStat</a></code> it does not handle missing values.
</p>


<h3>Value</h3>

<p>The (n-1)*p matrix equal to X'*Y
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.\ Vert, J.
P., &amp; Bleakley, K. (2010). Fast detection of multiple change-points shared
by many signals using group LARS. Advances in Neural Information Processing
Systems, 23, 2343-2351.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y &lt;- matrix(rnorm(20), ncol=2)
C &lt;- leftMultiplyByXt(Y)

</code></pre>

<hr>
<h2 id='mapPositionsBack'>mapPositionsBack</h2><span id='topic+mapPositionsBack'></span>

<h3>Description</h3>

<p>Map breakpoint positions back to original space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapPositionsBack(pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapPositionsBack_+3A_pos">pos</code></td>
<td>
<p>A sorted list of position (or indices)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>

<hr>
<h2 id='modelSelection'>Model selection</h2><span id='topic+modelSelection'></span>

<h3>Description</h3>

<p>Select the best number of breakpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSelection(rse, n, c = 2.5, lambdas = NULL, method = c("Birge",
  "Lebarbier"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelSelection_+3A_rse">rse</code></td>
<td>
<p>RSE as output by <code><a href="#topic+pruneByDP">pruneByDP</a></code></p>
</td></tr>
<tr><td><code id="modelSelection_+3A_n">n</code></td>
<td>
<p>Length of the profile</p>
</td></tr>
<tr><td><code id="modelSelection_+3A_c">c</code></td>
<td>
<p>Parameter for the model selection</p>
</td></tr>
<tr><td><code id="modelSelection_+3A_lambdas">lambdas</code></td>
<td>
<p>A list of candidate values for the calibration of the penalty</p>
</td></tr>
<tr><td><code id="modelSelection_+3A_method">method</code></td>
<td>
<p>Method to calibrate the constant in the penalty for model
selection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be called directly, but implicitly through
<code><a href="#topic+jointSeg">jointSeg</a></code> or <code><a href="#topic+PSSeg">PSSeg</a></code>.
</p>


<h3>Value</h3>

<p>A list with elements </p>
<dl>
<dt>kbest</dt><dd><p>the best number of breakpoints</p>
</dd> <dt>lambda</dt><dd><p>A numerical value, the result of an internal model selection function</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Lebarbier, E. (2005). Detecting multiple change-points in the
mean of Gaussian process by model selection. Signal processing, 85(4),
717-736
</p>
<p>Birg\'e, L. (2001). Gaussian model selection. J.Eur Math. Soc, 3(3):203-268
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSeg">jointSeg</a></code>
</p>
<p><code><a href="#topic+PSSeg">PSSeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)
sim &lt;- getCopyNumberDataByResampling(1e4, 5, minLength=100, regData=affyDat)
Y &lt;- as.matrix(sim$profile[, "c"])

## Find candidate breakpoints
K &lt;- 50
resRBS &lt;- segmentByRBS(Y, K=K)
## Prune candidate breakpoints
resDP &lt;- pruneByDP(Y, candCP=resRBS$bkp)
selectedModel &lt;- modelSelection(rse=resDP$rse, n=nrow(Y), method="Lebarbier")
str(selectedModel)

## breakpoints of the best model
bestBkp &lt;- resDP$bkp[[selectedModel$kbest]]
print(bestBkp)

## truth
print(sim$bkp)

## Note that all of the above can be done directly using 'PSSeg'
res &lt;- PSSeg(sim$profile, method="RBS", stat="c", K=K)
##  stopifnot(identical(res$bestBkp, bestBkp))
</code></pre>

<hr>
<h2 id='multiplyXtXBySparse'>multiplyXtXBySparse</h2><span id='topic+multiplyXtXBySparse'></span>

<h3>Description</h3>

<p>Compute <code>C = t(X)*X*val</code> , where <code>val</code> is a row-sparse
<code>(n-1)*p</code> matrix and <code>X</code> is the <code>n*(n-1)</code> design matrix for
the weighted group fused lasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplyXtXBySparse(n, ind, val, w = defaultWeights(n),
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplyXtXBySparse_+3A_n">n</code></td>
<td>
<p>Size of the problem</p>
</td></tr>
<tr><td><code id="multiplyXtXBySparse_+3A_ind">ind</code></td>
<td>
<p>a*1 vector of indices of the non-zero rows of b (each in [1,n-1])</p>
</td></tr>
<tr><td><code id="multiplyXtXBySparse_+3A_val">val</code></td>
<td>
<p>a*p matrix whose rows are the non-zero rows of b (same order as
ind)</p>
</td></tr>
<tr><td><code id="multiplyXtXBySparse_+3A_w">w</code></td>
<td>
<p>(n-1)*1 vector of weights</p>
</td></tr>
<tr><td><code id="multiplyXtXBySparse_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is derived from the MATLAB code of Vert and Bleakley:
<a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Value</h3>

<p>The <code>(n-1)*p</code> matrix equal to <code>t(X)*X*val</code>
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
<a href="arxiv.org/arXiv:1106.4199">arxiv.org/arXiv:1106.4199</a>
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple change-points
shared by many signals using group LARS. Advances in Neural Information
Processing Systems, 23, 2343-2351.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
val &lt;- matrix(c(1.56, 1.35, 1.26, 1.15), ncol=2)
ind &lt;- c(5,6)
n &lt;- 10
res &lt;- multiplyXtXBySparse(n=n, ind=ind, val=val)
res
##           [,1]      [,2]
## [1,] 0.8874235 0.7329904
## [2,] 1.3311352 1.0994855
## [3,] 1.7428651 1.4395645
## [4,] 2.1737347 1.7954524
## [5,] 2.6622704 2.1989711
## [6,] 2.6237347 2.1787857
## [7,] 2.1036678 1.7469149
## [8,] 1.6067028 1.3342283
## [9,] 1.0711352 0.8894855

</code></pre>

<hr>
<h2 id='oneBkp'>Get best candidate change point</h2><span id='topic+oneBkp'></span>

<h3>Description</h3>

<p>Get best candidate change point according to binary segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneBkp(Y, weights = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneBkp_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> matrix, <code>p</code> signals of length <code>n</code> to be
segmented (centered by column)</p>
</td></tr>
<tr><td><code id="oneBkp_+3A_weights">weights</code></td>
<td>
<p>a <code>(n-1)*1</code> vector of weights for the candidate change
point positions. Default weights yield the likelihood ratio test (LRT)
statistic for the identification of a single change point.</p>
</td></tr>
<tr><td><code id="oneBkp_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
sim &lt;- randomProfile(1e4, 1, 1, p)
Y &lt;- sim$profile
bkp &lt;- jointseg:::oneBkp(Y)
par(mfrow=c(p,1))
for (ii in 1:p) {
    plot(Y[, ii], pch=19, cex=0.2)
    abline(v=bkp, col=3)
    abline(v=sim$bkp, col=8, lty=2)
}

</code></pre>

<hr>
<h2 id='plotSeg'>Plot signal and breakpoints with segment-level signal estimates</h2><span id='topic+plotSeg'></span>

<h3>Description</h3>

<p>Plot signal and breakpoints with segment-level signal estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSeg(dat, breakpoints = NULL, regNames = NULL,
  exclNames = c("genotype", "region", "bT", "bN", "cellularity"),
  ylabs = colnames(dat), ylims = NULL, binExclPattern = "^b[N|T]*$",
  col = "#33333333", pch = 19, cex = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSeg_+3A_dat">dat</code></td>
<td>
<p>A <code>matrix</code> or data frame whose rows correspond to loci
sorted along the genome, or a <code>numeric</code> <code>vector</code>.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_breakpoints">breakpoints</code></td>
<td>
<p>A vector of breakpoints positions, or a <code>list</code> of
such vectors.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_regnames">regNames</code></td>
<td>
<p>Region labels, a vector of length
<code>length(breakpoints)+1</code> (if <code>breakpoints</code> is a vector) or of
length <code>length(breakpoints[[1]])+1</code> (if <code>breakpoints</code> is a list).</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_exclnames">exclNames</code></td>
<td>
<p>A vector of column names corresponding to columns that
should not be plotted.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_ylabs">ylabs</code></td>
<td>
<p>A vector of 'y' labels (column names or indices) that should be
plotted.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_ylims">ylims</code></td>
<td>
<p>An optional <code class="reqn">2*d</code> matrix with <code>ylim</code> values for each
of the <code class="reqn">d</code> dimensions to be plotted.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_binexclpattern">binExclPattern</code></td>
<td>
<p>A vector of column names or indices in
<code>colnames(dat)</code> for which segment-level signal estimates should *not*
be drawn.</p>
</td></tr>
<tr><td><code id="plotSeg_+3A_col">col</code></td>
<td>
<p>Color of plotting symbol, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plotSeg_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plotSeg_+3A_cex">cex</code></td>
<td>
<p>Magnification factor for plotting symbol, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument 'binCols' is mainly used to avoid calculating mean levels for
allelic ratios, which would not make sense as they are typically
multimodal.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=1)
sim &lt;- getCopyNumberDataByResampling(1e4, 5, minLength=100, regData=affyDat)
dat &lt;- sim$profile
res &lt;- PSSeg(dat, method="RBS", stat=c("c", "d"), K=50)
bkpList &lt;- list(true=sim$bkp, est=res$bestSeg)
plotSeg(dat, breakpoints=bkpList)
</code></pre>

<hr>
<h2 id='prof'>profile time and memory usage of a given R expression</h2><span id='topic+prof'></span>

<h3>Description</h3>

<p>profile time and memory usage of a given R expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prof(expr, doit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prof_+3A_expr">expr</code></td>
<td>
<p>An <code>R</code> expression to be evaluated</p>
</td></tr>
<tr><td><code id="prof_+3A_doit">doit</code></td>
<td>
<p>A boolean variable specifying whether profiling should be
performed or not (intended for internal use).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Profiling is performed using <code>summaryRprof(memory="both")$by.self</code>.
</p>


<h3>Note</h3>

<p>Our memory profiling is not satistfactory yet!
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>
</p>
<p><code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>
</p>

<hr>
<h2 id='pruneByDP'>Exact segmentation of a multivariate signal using dynamic programming.</h2><span id='topic+pruneByDP'></span>

<h3>Description</h3>

<p>Exact segmentation of a multivariate signal using dynamic programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruneByDP(Y, candCP = 1:(nrow(Y) - 1), K = length(candCP),
  allowNA = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruneByDP_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> signal to be segmented</p>
</td></tr>
<tr><td><code id="pruneByDP_+3A_candcp">candCP</code></td>
<td>
<p>A vector of candidate change point positions (defaults to
1:(n-1))</p>
</td></tr>
<tr><td><code id="pruneByDP_+3A_k">K</code></td>
<td>
<p>The maximum number of change points to find</p>
</td></tr>
<tr><td><code id="pruneByDP_+3A_allowna">allowNA</code></td>
<td>
<p>A boolean value specifying whether missing values should be
allowed or not.</p>
</td></tr>
<tr><td><code id="pruneByDP_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function retrieves the maximum likelihood solution of the gaussian
homoscedastic change model into segments, for <code class="reqn">K \in {1 \dots
length(candCP)}</code>. The dynamic programming algorithm used is quadratic in
time. For signals containing more than 1000 points, we recommend using a
first pass segmentation (see <code><a href="#topic+segmentByRBS">segmentByRBS</a></code>) to find a smaller
number of candidates, and to run <code>pruneByDP</code> on these candidates only,
as initially suggested by Gey and Lebarbier (2008). These two steps can be
performed using <code><a href="#topic+jointSeg">jointSeg</a></code> for generic multivariate signals, and
using <code><a href="#topic+PSSeg">PSSeg</a></code> for copy number signals from SNP array data.
</p>
<p>if <code>allowNA</code>, the calulation of the cost of removing candidate
breakpoints between i and j for i&lt;j tolerates missing values. Method
<code>!allowNA</code> is maintained in order to check consistency with the
original dynamic programming in the absence of NA:s.
</p>


<h3>Value</h3>

<p>A list with elements: </p>
<table>
<tr><td><code>bkpList</code></td>
<td>
<p>A list of vectors of change
point positions for the best model with k change points, for k=1, 2, ... K</p>
</td></tr>
<tr><td><code>rse</code></td>
<td>
<p>A vector of K+1 residual squared errors</p>
</td></tr> <tr><td><code>V</code></td>
<td>
<p>V[i,j] is the
best RSE for segmenting intervals 1 to j </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This implementation is derived from the MATLAB code by Vert and
Bleakley: <a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bellman, R. (1961). On the approximation of curves by line
segments using dynamic programming. Communications of the ACM, 4(6), 284.
</p>
<p>Gey, S., &amp; Lebarbier, E. (2008). Using CART to Detect Multiple Change Points
in the Mean for Large Sample. http://hal.archives-ouvertes.fr/hal-00327146/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSeg">jointSeg</a></code>, <code><a href="#topic+PSSeg">PSSeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
trueK &lt;- 10
sim &lt;- randomProfile(1e4, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- segmentByRBS(Y, K)
resP &lt;- pruneByDP(Y, res$bkp)

##   Note that all of the above can be dmethod=="other"one directly using 'jointSeg'
resJ &lt;- jointSeg(sim$profile, method="RBS", K=K)
stopifnot(identical(resP$bkpList, resJ$dpBkp))

## check consistency when no NA
resP2 &lt;- pruneByDP(Y, res$bkp, allowNA=FALSE)
max(abs(resP$rse-resP2$rse))

plotSeg(Y, list(resP$bkp[[trueK]], sim$bkp), col=1)

</code></pre>

<hr>
<h2 id='PSSeg'>Parent-Specific copy number segmentation</h2><span id='topic+PSSeg'></span>

<h3>Description</h3>

<p>This function splits (bivariate) copy number signals into parent-specific 
(PS) segments using recursive binary segmentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSSeg(data, method, stat = NULL, dropOutliers = TRUE,
  rankTransform = FALSE, ..., profile = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PSSeg_+3A_data">data</code></td>
<td>
<p>Data frame containing the following columns: </p>
 
<dl>
<dt>c:</dt><dd><p>Total copy number (logged or non-logged)</p>
</dd> <dt>b:</dt><dd><p>Allele B 
fraction</p>
</dd> <dt>genotype:</dt><dd><p>(germline) genotype of the SNP, coded as 0 for 
AA, 1/2 for AB, 1 for BB</p>
</dd> </dl>
<p> These data are assumed to be ordered by genome 
position.</p>
</td></tr>
<tr><td><code id="PSSeg_+3A_method">method</code></td>
<td>
 <dl>
<dt>&quot;RBS&quot;</dt><dd><p>Recursive Binary Segmentation, see 
<code><a href="#topic+doRBS">doRBS</a></code></p>
</dd> <dt>&quot;GFLars&quot;</dt><dd><p>Group fused LARS as described in 
Bleakley and Vert (2011).</p>
</dd> <dt>&quot;DP&quot;</dt><dd><p>Univariate pruned dynamic 
programming Rigaill et al (2010) or bivariate dynamic programming</p>
</dd> 
<dt>&quot;PSCBS&quot;</dt><dd><p>Parent-specific copy number in paired tumor-normal studies 
using circular binary segmentation by Olshen A. et al (2011)</p>
</dd> 
<dt>&quot;other&quot;</dt><dd><p>The segmentation method is passed as a function using 
argument <code>segFUN</code> (see examples in directory <code>otherMethods</code>).</p>
</dd> </dl>
</td></tr>
<tr><td><code id="PSSeg_+3A_stat">stat</code></td>
<td>
<p>A vector containing the names or indices of the columns of 
<code>Y</code> to be segmented</p>
</td></tr>
<tr><td><code id="PSSeg_+3A_dropoutliers">dropOutliers</code></td>
<td>
<p>If TRUE, outliers are droped by using DNAcopy package</p>
</td></tr>
<tr><td><code id="PSSeg_+3A_ranktransform">rankTransform</code></td>
<td>
<p>If TRUE, data are replaced by their ranks before 
segmentation</p>
</td></tr>
<tr><td><code id="PSSeg_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>jointSeg</code></p>
</td></tr>
<tr><td><code id="PSSeg_+3A_profile">profile</code></td>
<td>
<p>Trace time and memory usage ?</p>
</td></tr>
<tr><td><code id="PSSeg_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ? 
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before segmentation, the decrease in heterozygosity <code>d=2|b-1/2|</code> defined
in Bengtsson et al, 2010 is calculated from the input data. <code>d</code> is only 
defined for heterozygous SNPs, that is, SNPs for which 
<code>data$genotype==1/2</code>. <code>d</code> may be seen as a &quot;mirrored&quot; version of 
allelic ratios (<code>b</code>): it converts them to a piecewise-constant signals 
by taking advantage of the bimodality of <code>b</code> for heterozygous SNPs. The 
rationale for this transformation is that allelic ratios (<code>b</code>) are only 
informative for heterozygous SNPs (see e.g. Staaf et al, 2008).
</p>
<p>Before segmentation, the outliers in the copy number signal are droped 
according the method explained by Venkatraman, E. S. and Olshen, A. B., 2007.
</p>
<p>The resulting data are then segmented using the <code><a href="#topic+jointSeg">jointSeg</a></code> 
function, which combines an initial segmentation according to argument 
<code>method</code> and pruning of candidate change points by dynamic programming 
(skipped when the initial segmentation *is* dynamic programming).
</p>
<p>If argument <code>stat</code> is not provided, then dynamic programming is run on 
the two dimensional statistic <code>"(c,d)"</code>.
</p>
<p>If argument <code>stat</code> is provided, then dynamic programming is run on 
<code>stat</code>; in this case we implicitly assume that <code>stat</code> is a 
piecewise-constant signal.
</p>


<h3>Value</h3>

<p>A list with elements </p>
 <dl>
<dt>bestBkp</dt><dd><p>Best set of 
breakpoints after dynamic programming</p>
</dd> <dt>initBkp</dt><dd><p>Results of the 
initial segmentation, using 'doNnn', where 'Nnn' corresponds to argument 
<code>method</code></p>
</dd> <dt>dpBkpList</dt><dd><p>Results of dynamic programming, a list of 
vectors of breakpoint positions for the best model with k breakpoints for 
k=1, 2, ... K where <code>K=length(initBkp)</code></p>
</dd> <dt>prof</dt><dd><p>a <code>matrix</code> 
providing time usage (in seconds) and memory usage (in Mb) for the main 
steps of the program.  Only defined if argument <code>profile</code> is set to 
<code>TRUE</code></p>
</dd></dl>



<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bengtsson, H., Neuvial, P., &amp; Speed, T. P. (2010). TumorBoost: 
Normalization of allele-specific tumor copy numbers from a single pair of 
tumor-normal genotyping microarrays. BMC bioinformatics, 11(1), 245.
</p>
<p>Staaf, J., Lindgren, D., Vallon-Christersson, et al. (2008). 
Segmentation-based detection of allelic imbalance and 
loss-of-heterozygosity in cancer cells using whole genome SNP arrays. 
Genome Biol, 9(9), R136.
</p>
<p>Pierre-Jean, M, Rigaill, G. J. and Neuvial, P. (2015). &quot;Performance
Evaluation of DNA Copy Number Segmentation Methods.&quot; *Briefings in
Bioinformatics*, no. 4: 600-615.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointSeg">jointSeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load known real copy number regions
affyDat &lt;- acnr::loadCnRegionData(dataSet="GSE29172", tumorFraction=0.5)

## generate a synthetic CN profile
K &lt;- 10
len &lt;- 1e4
sim &lt;- getCopyNumberDataByResampling(len, K, regData=affyDat)
datS &lt;- sim$profile

## run binary segmentation (+ dynamic programming)
resRBS &lt;- PSSeg(data=datS, method="RBS", stat=c("c", "d"), K=2*K, profile=TRUE)
resRBS$prof

getTpFp(resRBS$bestBkp, sim$bkp, tol=5)
plotSeg(datS, breakpoints=list(sim$bkp, resRBS$bestBkp))
</code></pre>

<hr>
<h2 id='randomProfile'>Generate a random multi-dimensional profile with breakpoints and noise</h2><span id='topic+randomProfile'></span>

<h3>Description</h3>

<p>Generate a random multi-dimensional profile with breakpoints and noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomProfile(length, nBkp, noiseLevel, dim, minLength = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomProfile_+3A_length">length</code></td>
<td>
<p>length of the profile</p>
</td></tr>
<tr><td><code id="randomProfile_+3A_nbkp">nBkp</code></td>
<td>
<p>number of breakpoints</p>
</td></tr>
<tr><td><code id="randomProfile_+3A_noiselevel">noiseLevel</code></td>
<td>
<p>variance of the signal between two breakpoints</p>
</td></tr>
<tr><td><code id="randomProfile_+3A_dim">dim</code></td>
<td>
<p>dimension of the profile</p>
</td></tr>
<tr><td><code id="randomProfile_+3A_minlength">minLength</code></td>
<td>
<p>minimum length of region between breakpoints by default
minLength = 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate a random profile (vector) of length <code>length</code>, with <code>nBkp</code>
breakpoints randomly chosen. Between two breakpoints, the profile is
constant, uniformly chosen between 0 and 1, and a Gaussian noice of variance
<code>noiseLevel</code> is added.
</p>


<h3>Value</h3>

<p>a <code>list</code> with elements </p>

<dl>
<dt>profile</dt><dd><p>the profile (a <code>length</code> by <code>dim</code> matrix)</p>
</dd>
<dt>bkp</dt><dd><p>the list of breakpoints positions (the last position at the left
of a breakpoint)</p>
</dd></dl>



<h3>Note</h3>

<p>This implementation is derived from the MATLAB code by Vert and
Bleakley: <a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
len &lt;- 1e4
nBkp &lt;- 10
noiseLevel &lt;- 1
dim &lt;- 2

sim &lt;- randomProfile(len, nBkp, noiseLevel, dim)
res &lt;- doGFLars(sim$profile, K=5*nBkp)
str(res)

</code></pre>

<hr>
<h2 id='retour_sn'>Extract endpoint matrix from DP result</h2><span id='topic+retour_sn'></span>

<h3>Description</h3>

<p>Extract endpoint matrix from DP result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retour_sn(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retour_sn_+3A_path">path</code></td>
<td>
<p>the path vector of the &quot;colibri_sn_R_c C&quot; function</p>
</td></tr>
</table>

<hr>
<h2 id='segmentByGFLars'>Group fused Lars segmentation (low-level)</h2><span id='topic+segmentByGFLars'></span>

<h3>Description</h3>

<p>Low-level function for multivariate fused Lars segmentation (GFLars)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentByGFLars(Y, K, weights = defaultWeights(nrow(Y)),
  epsilon = 1e-09, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentByGFLars_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> matrix of signals to be segmented</p>
</td></tr>
<tr><td><code id="segmentByGFLars_+3A_k">K</code></td>
<td>
<p>The number of change points to find</p>
</td></tr>
<tr><td><code id="segmentByGFLars_+3A_weights">weights</code></td>
<td>
<p>A <code>(n-1)*1</code> vector of weights for the weigthed group
fused Lasso penalty. See Details.</p>
</td></tr>
<tr><td><code id="segmentByGFLars_+3A_epsilon">epsilon</code></td>
<td>
<p>Values smaller than epsilon are considered null. Defaults to
<code>1e-9</code>.</p>
</td></tr>
<tr><td><code id="segmentByGFLars_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recrusively looks for the best candidate change point
according to group-fused LARS. This is a low-level function. It is generally
advised to use the wrapper <code><a href="#topic+doGFLars">doGFLars</a></code> which also works on data
frames, has a convenient argument <code>stat</code>, and includes a basic
workaround for handling missing values.
</p>
<p>See also <code><a href="#topic+jointSeg">jointSeg</a></code> for combining group fused LARS segmentation
with pruning by dynamic programming (<code><a href="#topic+pruneByDP">pruneByDP</a></code>).
</p>
<p>See <code><a href="#topic+PSSeg">PSSeg</a></code> for segmenting genomic signals from SNP arrays.
</p>
<p>The default weights <code class="reqn">\sqrt{n/(i*(n-i))}</code> are calibrated as suggested by
Bleakley and Vert (2011).  Using this calibration, the first breakpoint
maximizes the likelihood ratio test (LRT) statistic.
</p>


<h3>Value</h3>

<p>A list with elements: </p>
<dl>
<dt>bkp</dt><dd><p>A vector of <code>k</code> candidate
change-point positions</p>
</dd> <dt>lambda</dt><dd><p>The estimated lambda values for each
change-point</p>
</dd> <dt>mean</dt><dd><p>A vector of length <code>p</code>, the mean signal per
column</p>
</dd> <dt>value</dt><dd><p>A <code>i x p</code> matrix of change-point values for the
first i change-points</p>
</dd> <dt>c</dt><dd><p><code class="reqn">\hat{c}</code>, a <code>n-1 x K</code> matrix </p>
</dd></dl>



<h3>Note</h3>

<p>This implementation is derived from the MATLAB code by Vert and
Bleakley: <a href="http://cbio.ensmp.fr/GFLseg">http://cbio.ensmp.fr/GFLseg</a>.
</p>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Bleakley, K., &amp; Vert, J. P. (2011). The group fused lasso for
multiple change-point detection. arXiv preprint arXiv:1106.4199.
</p>
<p>Vert, J. P., &amp; Bleakley, K. (2010). Fast detection of multiple change-points
shared by many signals using group LARS. Advances in Neural Information
Processing Systems, 23, 2343-2351.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSSeg">PSSeg</a></code>, <code><a href="#topic+jointSeg">jointSeg</a></code>,
<code><a href="#topic+doGFLars">doGFLars</a></code>, <code><a href="#topic+pruneByDP">pruneByDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
trueK &lt;- 10
sim &lt;- randomProfile(1e4, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- segmentByGFLars(Y, K)
print(res$bkp)
print(sim$bkp)
plotSeg(Y, res$bkp)

</code></pre>

<hr>
<h2 id='segmentByRBS'>Recursive Binary Segmentation (low-level)</h2><span id='topic+segmentByRBS'></span>

<h3>Description</h3>

<p>Low-level function for multivariate Recursive Binary Segmentation (RBS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentByRBS(Y, K, minRegionSize = 2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentByRBS_+3A_y">Y</code></td>
<td>
<p>A <code>n*p</code> signal to be segmented</p>
</td></tr>
<tr><td><code id="segmentByRBS_+3A_k">K</code></td>
<td>
<p>The number of change points to find</p>
</td></tr>
<tr><td><code id="segmentByRBS_+3A_minregionsize">minRegionSize</code></td>
<td>
<p>Regions with less than <code>minRegionSize</code> are not
split</p>
</td></tr>
<tr><td><code id="segmentByRBS_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value: should extra information be output ?
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recrusively looks for the best candidate change point
according to binary segmentation. This is the low-level function. It is
generally advised to use the wrapper <code><a href="#topic+doRBS">doRBS</a></code> which also works on
data frames and has a convenient argument <code>stat</code>.
</p>
<p>See <code><a href="#topic+jointSeg">jointSeg</a></code> for combining recursive binary segmentation with
pruning by dynamic programming (<code><a href="#topic+pruneByDP">pruneByDP</a></code>).
</p>
<p>See <code><a href="#topic+PSSeg">PSSeg</a></code> for segmenting genomic signals from SNP arrays.
</p>
<p>Each dimension of the original signal is scaled before segmentation, using
<code><a href="#topic+estimateSd">estimateSd</a></code>.
</p>


<h3>Value</h3>

<p>A list with elements: </p>
<table>
<tr><td><code>bkp</code></td>
<td>
<p>A <code>vector</code> of <code>K</code>
estimated breakpoint positions, sorted by order of appearance</p>
</td></tr>
<tr><td><code>rse</code></td>
<td>
<p>the residual squared error (RSE) for the successive
segmentations</p>
</td></tr> <tr><td><code>gain</code></td>
<td>
<p>The gain provided by each breakpoints in terms of
difference between RSE </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Morgane Pierre-Jean and Pierre Neuvial
</p>


<h3>References</h3>

<p>Gey, S., &amp; Lebarbier, E. (2008). Using CART to Detect Multiple
Change Points in the Mean for Large Sample.
http://hal.archives-ouvertes.fr/hal-00327146/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSSeg">PSSeg</a></code>, <code><a href="#topic+jointSeg">jointSeg</a></code>, <code><a href="#topic+doRBS">doRBS</a></code>,
<code><a href="#topic+pruneByDP">pruneByDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 2
trueK &lt;- 10
len &lt;- 1e4
sim &lt;- randomProfile(len, trueK, 1, p)
Y &lt;- sim$profile
K &lt;- 2*trueK
res &lt;- segmentByRBS(Y, K)
getTpFp(res$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

cols &lt;- rep(2, K)
cols[1:trueK] &lt;- 3
par(mfrow=c(p,1))
for (ii in 1:p) {
    plot(Y[, ii], pch=19, cex=0.2)
    abline(v=res$bkp[1:trueK], col= cols)
    abline(v=sim$bkp, col=8, lty=2)
}

## NA:s in one dimension at a true breakpoint
jj &lt;- sim$bkp[1]
Y[jj-seq(-10, 10), p] &lt;- NA
res2 &lt;- segmentByRBS(Y, K)
getTpFp(res2$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

## NA:s in both dimensions at a true breakpoint
Y[jj-seq(-10, 10), ] &lt;- NA
res3 &lt;- segmentByRBS(Y, K)
getTpFp(res3$bkp, sim$bkp, tol=10, relax = -1)   ## true and false positives

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
