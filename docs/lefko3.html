<!DOCTYPE html><html><head><title>Help for package lefko3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lefko3}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lefko3-package'><p>Historical and Ahistorical Population Projection Matrix Analysis</p></a></li>
<li><a href='#actualstage3'><p>Calculate Actual Stage, Age, Stage-Pair, or Age-Stage Distributions</p></a></li>
<li><a href='#add_lM'><p>Add Matrices to lefkoMat Object</p></a></li>
<li><a href='#add_stage'><p>Add a New Stage to an Existing LefkoMat Object</p></a></li>
<li><a href='#aflefko2'><p>Create Function-based Ahistorical Age x Stage Matrix Projection Model</p></a></li>
<li><a href='#anthyllis'><p>Matrix Set of <em>Anthyllis vulneraria</em> Populations in Belgium</p></a></li>
<li><a href='#append_lP'><p>Append Projections Into New lefkoProj Object</p></a></li>
<li><a href='#arlefko2'><p>Create Raw Ahistorical Age x Stage Matrix Projection Model</p></a></li>
<li><a href='#beverton3'><p>Two-parameter Beverton-Holt function</p></a></li>
<li><a href='#cond_diff'><p>Extract Conditional Ahistorical Difference Matrices</p></a></li>
<li><a href='#cond_hmpm'><p>Extract Conditional Ahistorical Matrices from Historical MPM</p></a></li>
<li><a href='#create_lM'><p>Create lefkoMat Object from Given Input Matrices or an MPM Database</p></a></li>
<li><a href='#create_pm'><p>Creates a Skeleton Paramnames Object for Use in Function-based Modeling</p></a></li>
<li><a href='#cypdata'><p>Demographic Dataset of <em>Cypripedium candidum</em> Population, in Horizontal</p>
Format</a></li>
<li><a href='#cypvert'><p>Demographic Dataset of <em>Cypripedium candidum</em> Population, in Vertical</p>
Format</a></li>
<li><a href='#delete_lM'><p>Delete Matrices from lefkoMat Object</p></a></li>
<li><a href='#density_input'><p>Set Density Dependence Relationships in Matrix Elements</p></a></li>
<li><a href='#density_vr'><p>Set Density Dependence Relationships in Vital Rates</p></a></li>
<li><a href='#diff_lM'><p>Calculate Difference Matrices Between lefkoMat Objects of Equal Dimensions</p></a></li>
<li><a href='#edit_lM'><p>Edit an MPM based on Supplemental Data</p></a></li>
<li><a href='#elasticity3'><p>Estimate Elasticity of Population Growth Rate to Matrix Elements</p></a></li>
<li><a href='#elasticity3.dgCMatrix'><p>Estimate Elasticity of Population Growth Rate of a Single Sparse Matrix</p></a></li>
<li><a href='#elasticity3.lefkoMat'><p>Estimate Elasticity of Population Growth Rate of a lefkoMat Object</p></a></li>
<li><a href='#elasticity3.list'><p>Estimate Elasticity of Population Growth Rate of a List of Matrices</p></a></li>
<li><a href='#elasticity3.matrix'><p>Estimate Elasticity of Population Growth Rate of a Single Matrix</p></a></li>
<li><a href='#f_projection3'><p>Project Function-based Matrix Projection Model</p></a></li>
<li><a href='#flefko2'><p>Create Function-based Ahistorical Matrix Projection Model</p></a></li>
<li><a href='#flefko3'><p>Create Function-based Historical Matrix Projection Model</p></a></li>
<li><a href='#fleslie'><p>Create Function-based Age-based (Leslie) Matrix Projection Model</p></a></li>
<li><a href='#hfv_qc'><p>Check Quality and Distributions of hfv Datasets</p></a></li>
<li><a href='#hist_null'><p>Create Historical MPMs Assuming No Influence of Individual History</p></a></li>
<li><a href='#historicalize3'><p>Create Historical Vertical Data Frame from Ahistorical Vertical Data Frame</p></a></li>
<li><a href='#image3'><p>Create Matrix Image</p></a></li>
<li><a href='#image3.dgCMatrix'><p>Create a Matrix Image for a Single Sparse Matrix</p></a></li>
<li><a href='#image3.lefkoElas'><p>Create Matrix Image(s) for lefkoElas Object</p></a></li>
<li><a href='#image3.lefkoMat'><p>Create Matrix Image(s) for lefkoMat Object</p></a></li>
<li><a href='#image3.lefkoSens'><p>Create Matrix Image(s) for lefkoSens Object</p></a></li>
<li><a href='#image3.list'><p>Create Matrix Images for Matrices in a List</p></a></li>
<li><a href='#image3.matrix'><p>Create a Matrix Image for a Single Matrix</p></a></li>
<li><a href='#lambda3'><p>Estimate Actual or Deterministic Population Growth Rate</p></a></li>
<li><a href='#lathyrus'><p>Demographic Dataset of <em>Lathyrus vernus</em> Population</p></a></li>
<li><a href='#lmean'><p>Estimate Mean Projection Matrices</p></a></li>
<li><a href='#logistic3'><p>Two-parameter logistic function</p></a></li>
<li><a href='#ltre3'><p>Conduct a Life Table Response Experiment</p></a></li>
<li><a href='#markov_run'><p>Creates Vector of Times Based on First-Order Markov Transition Matrix</p></a></li>
<li><a href='#matrix_interp'><p>Arranges Matrix Elements in Order of Magnitude for Interpretation</p></a></li>
<li><a href='#modelsearch'><p>Develop Best-fit Vital Rate Estimation Models for MPM Development</p></a></li>
<li><a href='#mpm_create'><p>General Matrix Projection Model Creation</p></a></li>
<li><a href='#overwrite'><p>Create Overwrite Table for MPM Development</p></a></li>
<li><a href='#plot.lefkoProj'><p>Plot Projection Simulations</p></a></li>
<li><a href='#projection3'><p>Conduct Population Projection Simulations</p></a></li>
<li><a href='#pyrola'><p>Demographic Dataset of <em>Pyrola japonica</em> and <em>Pyrola subaphylla</em></p>
Populations, in Horizontal Format</a></li>
<li><a href='#repvalue3'><p>Estimate Reproductive Value</p></a></li>
<li><a href='#repvalue3.dgCMatrix'><p>Estimate Reproductive Value Vector for a Single Population Projection Matrix</p></a></li>
<li><a href='#repvalue3.lefkoMat'><p>Estimate Reproductive Value Vectors of Matrices in a lefkoMat Object</p></a></li>
<li><a href='#repvalue3.list'><p>Estimate Reproductive Value Vector for a List of Projection Matrices</p></a></li>
<li><a href='#repvalue3.matrix'><p>Estimate Reproductive Value Vector for a Single Population Projection Matrix</p></a></li>
<li><a href='#ricker3'><p>Two-parameter Ricker function</p></a></li>
<li><a href='#rlefko2'><p>Create Raw Ahistorical Matrix Projection Model</p></a></li>
<li><a href='#rlefko3'><p>Create Raw Historical Matrix Projection Model</p></a></li>
<li><a href='#rleslie'><p>Create Raw Leslie (Age-based) Matrix Projection Model</p></a></li>
<li><a href='#sensitivity3'><p>Estimate Sensitivity of Population Growth Rate to Matrix Elements</p></a></li>
<li><a href='#sensitivity3.dgCMatrix'><p>Estimate Sensitivity of Population Growth Rate of a Single Matrix</p></a></li>
<li><a href='#sensitivity3.lefkoMat'><p>Estimate Sensitivity of Population Growth Rate of a lefkoMat Object</p></a></li>
<li><a href='#sensitivity3.list'><p>Estimate Sensitivity of Population Growth Rate of a List of Matrices</p></a></li>
<li><a href='#sensitivity3.matrix'><p>Estimate Sensitivity of Population Growth Rate of a Single Matrix</p></a></li>
<li><a href='#sf_create'><p>Create Stageframe for Population Matrix Projection Analysis</p></a></li>
<li><a href='#sf_distrib'><p>Test Overdispersion and Zero Inflation in Size and Fecundity Distributions</p></a></li>
<li><a href='#sf_skeleton'><p>Create Skeleton Stageframe</p></a></li>
<li><a href='#slambda3'><p>Estimate Stochastic Population Growth Rate</p></a></li>
<li><a href='#stablestage3'><p>Estimate Stable Stage Distribution</p></a></li>
<li><a href='#stablestage3.dgCMatrix'><p>Estimate Stable Stage Distribution of a Single Population Projection Matrix</p></a></li>
<li><a href='#stablestage3.lefkoMat'><p>Estimate Stable Stage Distribution of Matrices in lefkoMat Object</p></a></li>
<li><a href='#stablestage3.list'><p>Estimate Stable Stage Distribution of a List of Projection Matrices</p></a></li>
<li><a href='#stablestage3.matrix'><p>Estimate Stable Stage Distribution of a Single Population Projection Matrix</p></a></li>
<li><a href='#start_input'><p>Create a Starting Vector for Population Projection</p></a></li>
<li><a href='#subset_lM'><p>Create New lefkoMat Object as Subset of Another lefkoMat Object</p></a></li>
<li><a href='#summary_hfv'><p>Summary of Class &quot;hfvdata&quot;</p></a></li>
<li><a href='#summary.lefkoCondMat'><p>Summary of Class &quot;lefkoCondMat&quot;</p></a></li>
<li><a href='#summary.lefkoElas'><p>Summarize lefkoElas Objects</p></a></li>
<li><a href='#summary.lefkoLTRE'><p>Summarize lefkoLTRE Objects</p></a></li>
<li><a href='#summary.lefkoMat'><p>Summary of Class &quot;lefkoMat&quot;</p></a></li>
<li><a href='#summary.lefkoMod'><p>Summary of Class &quot;lefkoMod&quot;</p></a></li>
<li><a href='#summary.lefkoProj'><p>Summarize lefkoProj Objects</p></a></li>
<li><a href='#supplemental'><p>Create a Data Frame of Supplemental Data for MPM Development</p></a></li>
<li><a href='#usher3'><p>Two-parameter Usher function</p></a></li>
<li><a href='#verticalize3'><p>Create Historical Vertical Data Frame from Horizontal Data Frame</p></a></li>
<li><a href='#vrm_import'><p>Import Vital Rate Model Factor Values for Function-based MPM Development</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Historical and Ahistorical Population Projection Matrix Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>6.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Complete analytical environment for the construction and analysis
             of matrix population models and integral projection models.
             Includes the ability to construct historical matrices, which are
             2d matrices comprising 3 consecutive times of demographic
             information. Estimates both raw and function-based forms of
             historical and standard ahistorical matrices. It also estimates
             function-based age-by-stage matrices and raw and function-based
             Leslie matrices.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.sheffersonlab.com/projects.html">http://www.sheffersonlab.com/projects.html</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), glmmTMB, lme4, MASS, Matrix, methods, MuMIn,
pscl, stats, VGAM, grDevices</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, popbio, rmarkdown, Rcompadre</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-24 06:25:23 UTC; richshefferson</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard P. Shefferson
    <a href="https://orcid.org/0000-0002-5234-3131"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Johan Ehrlen <a href="https://orcid.org/0000-0001-8539-8967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard P. Shefferson &lt;cdorm@g.ecc.u-tokyo.ac.jp&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-24 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lefko3-package'>Historical and Ahistorical Population Projection Matrix Analysis</h2><span id='topic+lefko3'></span><span id='topic+lefko3-package'></span>

<h3>Description</h3>

<p>This package creates population matrix projection models (MPMs)
for use in population ecological analyses. It presents a complete working
environment for the construction and analysis of ALL kinds of MPMs and IPMs,
including age, stage, and age-by-stage versions. Its specialty is the
estimation of historical MPMs, which are 2d matrices comprising 3 monitoring
occasions (2 time steps or periods) of demographic information. The package
constructs both function-based and raw MPMs for both standard ahistorical
(i.e. 2 occasions, 1 time step) and historical analyses, has functions for
complex density-dependent and independent, and stochastic and cyclical,
projections, and also includes the automatic calculation of quality control
metrics throughout every step of analysis. It also includes powerful
functions to standardize demographic datasets.
</p>


<h3>Details</h3>

<p>The lefko3 package provides seven categories of functions:
</p>
<p>1. Data transformation and handling functions
</p>
<p>2. Functions determining population characteristics from vertical data
</p>
<p>3. Model building and selection
</p>
<p>4. Matrix / integral projection model creation functions
</p>
<p>5. Population dynamics analysis and projection functions
</p>
<p>6. Functions describing, summarizing, or visualizing MPMs and derived
structures
</p>
<p>7. Extra functions used to illustrate core theory and ideas.
</p>
<p>lefko3 also includes example datasets complete with sample code.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Richard P. Shefferson <a href="mailto:cdorm@g.ecc.u-tokyo.ac.jp">cdorm@g.ecc.u-tokyo.ac.jp</a> (<a href="https://orcid.org/0000-0002-5234-3131">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Johan Ehrlen (<a href="https://orcid.org/0000-0001-8539-8967">ORCID</a>)
</p>
</li></ul>

<p>Richard P. Shefferson &lt;cdorm@g.ecc.u-tokyo.ac.jp&gt;
</p>
<p>Johan Ehrlén
</p>


<h3>References</h3>

<p>Shefferson, R.P., J. Ehrlen, and S. Kurokawa. 2021. 
<em>lefko3</em>: analyzing individual history through size-classified matrix 
population models. <em>Methods in Ecology and Evolution</em> 12(2): 378-382.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://www.sheffersonlab.com/projects.html">http://www.sheffersonlab.com/projects.html</a>
</p>
</li></ul>


<hr>
<h2 id='actualstage3'>Calculate Actual Stage, Age, Stage-Pair, or Age-Stage Distributions</h2><span id='topic+actualstage3'></span>

<h3>Description</h3>

<p>Function <code>actualstage3()</code> shows the frequencies and proportions of
each stage, stage pair, age-stage, or age in each year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actualstage3(
  data,
  check_stage = TRUE,
  check_age = FALSE,
  historical = FALSE,
  year2 = NULL,
  indices = NULL,
  stagecol = NULL,
  agecol = NULL,
  remove_stage = NULL,
  t1_allow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actualstage3_+3A_data">data</code></td>
<td>
<p>A demographic dataset in hfv format.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_check_stage">check_stage</code></td>
<td>
<p>A logical value indicating whether to assess frequencies
and proportions of stages. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_check_age">check_age</code></td>
<td>
<p>A logical value indicating whether to assess frequencies and
proportions of ages. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_historical">historical</code></td>
<td>
<p>A logical value indicating whether the stage structure
should be ahistorical (<code>FALSE</code>) or historical (<code>TRUE</code>). Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_year2">year2</code></td>
<td>
<p>A string value indicating the name of the variable coding for
monitoring occasion at time <em>t</em>. Defaults to <code>"year2"</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_indices">indices</code></td>
<td>
<p>A vector of three strings, indicating the stage indices for
times <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively, in <code>data</code>.
Defaults to <code>c("stage3index", "stage2index", "stage1index")</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_stagecol">stagecol</code></td>
<td>
<p>A vector of three strings, indicating the stage name columns
for times <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively, in <code>data</code>.
Defaults to <code>stagecol = c("stage3", "stage2", "stage1")</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_agecol">agecol</code></td>
<td>
<p>A single string indicating the age of individuals in time
<em>t</em>. Defaults to <code>"obsage"</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_remove_stage">remove_stage</code></td>
<td>
<p>A string vector indicating the names of stages to remove
from consideration. Defaults to <code>"NotAlive"</code>.</p>
</td></tr>
<tr><td><code id="actualstage3_+3A_t1_allow">t1_allow</code></td>
<td>
<p>A string vector indicating which stages to be removed should
be allowed in the stage at time <em>t</em>-1 portion of historical stage
pairs, if <code>historical = TRUE</code>. Defaults to <code>"NotAlive"</code>. Can also
be set to <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following variables:
</p>
<table>
<tr><td><code>rowid</code></td>
<td>
<p>A string identifier term, equal to the monitoring occasion in
time <em>t</em> and the stage index.</p>
</td></tr>
<tr><td><code>stageindex</code></td>
<td>
<p>The stageframe index of the stage. Only output if
<code>check_stage = TRUE</code>.</p>
</td></tr>
<tr><td><code>stage</code></td>
<td>
<p>The name of each stage, or <code>NA</code>. Only output if
<code>check_stage = TRUE</code>.</p>
</td></tr>
<tr><td><code>stage2</code></td>
<td>
<p>The name of the stage in time <em>t</em>. Only output if
<code>check_stage = TRUE</code>.</p>
</td></tr>
<tr><td><code>stage1</code></td>
<td>
<p>The name of the stage in time <em>t</em>-1, or <code>NA</code>. Only
output if <code>check_stage = TRUE</code>.</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>The age at time <em>t</em>. Only output if <code>check_age = TRUE</code>.</p>
</td></tr>
<tr><td><code>year2</code></td>
<td>
<p>Monitoring occasion in time <em>t</em>.</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>The number of individuals in the respective stage and time.</p>
</td></tr>
<tr><td><code>actual_prop</code></td>
<td>
<p>The proportion of individuals alive in time <em>t</em> in
the respective stage.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>This function produces frequencies and proportions of stages in hfv formatted
data using stage index variables rather than stage name variables, and so
requires the former. The latter is only required if the user wants to know
the associated stage names.
</p>
<p>Frequencies and proportions will be calculated for all times, including the
last time, which is generally found in the <code>stage3</code> columns of the last
<code>year2</code> entry in object <code>data</code>. The default is to treat the
<code>year2</code> entry for that time as <code>max(year2) + 1</code>.
</p>
<p>If <code>check_stage = TRUE</code> and <code>check_age = FALSE</code>, then this function
will assess frequencies and proportions of stages or historical stage-pairs.
If both <code>check_stage = TRUE</code> and <code>check_age = TRUE</code>, then this
function will assess frequencies and proportions of age-stages. If
<code>check_stage = FALSE</code> and <code>check_age = TRUE</code>, then the frequencies
and proportions of ages only will be assessed.
</p>
<p>Note that no stageframe is required for this function to operate. Stage
names and their order are inferred directly from the object <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 3, 6, 11, 19.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1.5, 1.5, 3.5, 5)
comments &lt;- c("Dormant seed", "1st yr protocorm", "2nd yr protocorm",
  "3rd yr protocorm", "Seedling", "Dormant adult",
  "Extra small adult (1 shoot)", "Small adult (2-4 shoots)",
  "Medium adult (5-7 shoots)", "Large adult (8-14 shoots)",
  "Extra large adult (&gt;14 shoots)")
cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset, 
  binhalfwidth = binvec, comments = comments)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004, 
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE, age_offset = 4)

all_stage_props_ah &lt;- actualstage3(cypraw_v1)
all_stage_props_h &lt;- actualstage3(cypraw_v1, historical = TRUE)
all_stage_props_h_NANotAllow &lt;- actualstage3(cypraw_v1, historical = TRUE,
  t1_allow = "none")
all_stage_props_as &lt;- actualstage3(cypraw_v1, check_age = TRUE)
all_age_props &lt;- actualstage3(cypraw_v1, check_stage = FALSE,
  check_age = TRUE)

</code></pre>

<hr>
<h2 id='add_lM'>Add Matrices to lefkoMat Object</h2><span id='topic+add_lM'></span>

<h3>Description</h3>

<p>Function <code>add_lM()</code> adds matrices to lefkoMat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lM(
  lM,
  Amats = NA,
  Umats = NA,
  Fmats = NA,
  UFdecomp = FALSE,
  entrystage = 1,
  pop = NA,
  patch = NA,
  year = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lM_+3A_lm">lM</code></td>
<td>
<p>The lefkoMat object to add matrices to.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_amats">Amats</code></td>
<td>
<p>Either a single <code>A</code> matrix, or a list of <code>A</code> matrices.
Not necessary if <code>Umats</code> and <code>Fmats</code> are both provided.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_umats">Umats</code></td>
<td>
<p>Either a single <code>U</code> matrix, or a list of <code>U</code> matrices.
Not necessary if <code>Amats</code> and <code>Fmats</code> are both provided, or if
<code>UFdecomp = TRUE</code> and <code>entrystage</code> is provided.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_fmats">Fmats</code></td>
<td>
<p>Either a single <code>F</code> matrix, or a list of <code>U</code> matrices.
Not necessary if <code>Amats</code> and <code>Umats</code> are both provided, or if
<code>UFdecomp = TRUE</code> and <code>entrystage</code> is provided.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_ufdecomp">UFdecomp</code></td>
<td>
<p>A logical value indicating whether U and F matrices should be
inferred from A matrices and the given <code>entrystage</code>. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_entrystage">entrystage</code></td>
<td>
<p>The stage or stages produced by reproductive individuals.
Used to determine which transitions are reproductive for U-F decomposition.
Defaults to <code>1</code>, which corresponds to the first stage in the stageframe.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_pop">pop</code></td>
<td>
<p>The population designation for each matrix. If object <code>lM</code>
includes only a single population, then defaults to that designation.
Otherwise requires a designation as input.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_patch">patch</code></td>
<td>
<p>The patch designation for each matrix. If object <code>lM</code>
includes only a single patch, then defaults to that designation. Otherwise
requires a designation as input.</p>
</td></tr>
<tr><td><code id="add_lM_+3A_year">year</code></td>
<td>
<p>The designation for occasion at time <em>t</em> corresponding to
each matrix. Cannot be left empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoMat</code> object incorporating the new matrices within the
object input in <code>lM</code>.
</p>


<h3>Notes</h3>

<p>This function will not allow matrices of different dimension from those input
in object <code>lM</code> to be added to that object.
</p>
<p>Two of <code>Amats</code>, <code>Umats</code>, and <code>Fmats</code> must be provided for this
function to proceed. Also, if <code>Amats</code>, <code>Umats</code>, and <code>Fmats</code>
are all provided, then this function will default to replacing <code>Amats</code>
with the sum of the respective <code>Umats</code> and <code>Fmats</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_lM">create_lM</a>()</code>
</p>
<p><code><a href="#topic+delete_lM">delete_lM</a>()</code>
</p>
<p><code><a href="#topic+subset_lM">subset_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These matrices are of 9 populations of the plant species Anthyllis
# vulneraria, and were originally published in Davison et al. (2010) Journal
# of Ecology 98:255-267 (doi: 10.1111/j.1365-2745.2009.01611.x).

sizevector &lt;- c(1, 1, 2, 3) # These sizes are not from the original paper
stagevector &lt;- c("Sdl", "Veg", "SmFlo", "LFlo")
repvector &lt;- c(0, 0, 1, 1)
obsvector &lt;- c(1, 1, 1, 1)
matvector &lt;- c(0, 1, 1, 1)
immvector &lt;- c(1, 0, 0, 0)
propvector &lt;- c(0, 0, 0, 0)
indataset &lt;- c(1, 1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5, 0.5)

anthframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# POPN C 2003-2004
XC3 &lt;- matrix(c(0, 0, 1.74, 1.74,
0.208333333, 0, 0, 0.057142857,
0.041666667, 0.076923077, 0, 0,
0.083333333, 0.076923077, 0.066666667, 0.028571429), 4, 4, byrow = TRUE)

# 2004-2005
XC4 &lt;- matrix(c(0, 0, 0.3, 0.6,
0.32183908, 0.142857143, 0, 0,
0.16091954, 0.285714286, 0, 0,
0.252873563, 0.285714286, 0.5, 0.6), 4, 4, byrow = TRUE)

# 2005-2006
XC5 &lt;- matrix(c(0, 0, 0.50625, 0.675,
0, 0, 0, 0.035714286,
0.1, 0.068965517, 0.0625, 0.107142857,
0.3, 0.137931034, 0, 0.071428571), 4, 4, byrow = TRUE)

# POPN E 2003-2004
XE3 &lt;- matrix(c(0, 0, 2.44, 6.569230769,
0.196428571, 0, 0, 0,
0.125, 0.5, 0, 0,
0.160714286, 0.5, 0.133333333, 0.076923077), 4, 4, byrow = TRUE)

XE4 &lt;- matrix(c(0, 0, 0.45, 0.646153846,
0.06557377, 0.090909091, 0.125, 0,
0.032786885, 0, 0.125, 0.076923077,
0.049180328, 0, 0.125, 0.230769231), 4, 4, byrow = TRUE)

XE5 &lt;- matrix(c(0, 0, 2.85, 3.99,
0.083333333, 0, 0, 0,
0, 0, 0, 0,
0.416666667, 0.1, 0, 0.1), 4, 4, byrow = TRUE)

mats_list &lt;- list(XC3, XC4, XC5, XE3, XE4, XE5)
yr_ord &lt;- c(1, 2, 3, 1, 2, 3)
pch_ord &lt;- c(1, 1, 1, 2, 2, 2)

anth_lefkoMat &lt;- create_lM(mats_list, anthframe, hstages = NA,
  historical = FALSE, poporder = 1, patchorder = pch_ord, yearorder = yr_ord)
  
XH3 &lt;- matrix(c(0, 0, 0.1125, 1.05,
0.2, 0, 0, 0,
0, 0.5, 0, 0,
0.2, 0.5, 0, 0), 4, 4, byrow = TRUE)

XH3u &lt;- matrix(c(0, 0, 0, 0,
0.2, 0, 0, 0,
0, 0.5, 0, 0,
0.2, 0.5, 0, 0), 4, 4, byrow = TRUE)

XH4 &lt;- matrix(c(0, 0, 0, 0,
0, 0, 0.5, 0,
0.8, 0.5, 0.25, 0.25,
0.2, 0, 0, 0.75), 4, 4, byrow = TRUE)

XH4u &lt;- matrix(c(0, 0, 0, 0,
0, 0, 0.5, 0,
0.8, 0.5, 0.25, 0.25,
0.2, 0, 0, 0.75), 4, 4, byrow = TRUE)

XH5 &lt;- matrix(c(0, 0, 0.2, 1.05,
0, 0, 0, 0,
0.001, 0.001, 0.333333333, 0,
0.001, 0, 0, 0), 4, 4, byrow = TRUE)

XH5u &lt;- matrix(c(0, 0, 0, 0,
0, 0, 0, 0,
0.001, 0.001, 0.333333333, 0,
0.001, 0, 0, 0), 4, 4, byrow = TRUE)

anth_lefkoMat &lt;- add_lM(anth_lefkoMat, Amats = list(XH3, XH4, XH5),
  Umats = list(XH3u, XH4u, XH5u), patch = c(3, 3, 3), year = c(1, 2, 3))
  
</code></pre>

<hr>
<h2 id='add_stage'>Add a New Stage to an Existing LefkoMat Object</h2><span id='topic+add_stage'></span>

<h3>Description</h3>

<p>Function <code>add_stage()</code> adds a new stage to an existing <code>lefkoMat</code>
object. In addition to altering the <code>ahstages</code> object within the MPM,
it alters the <code>hstages</code> and <code>agestages</code> objects and adds the
appropriate number of new rows and columns depending on the kind of MPM
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_stage(mpm, add_before = 0L, add_after = 0L, stage_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_stage_+3A_mpm">mpm</code></td>
<td>
<p>The <code>lefkoMat</code> object to add a stage to.</p>
</td></tr>
<tr><td><code id="add_stage_+3A_add_before">add_before</code></td>
<td>
<p>The index of the stage to insert a new stage before. This
index should be derived from the <code>ahstages</code> of the input <code>mpm</code>.
Cannot be set if <code>add_after</code> is to be used.</p>
</td></tr>
<tr><td><code id="add_stage_+3A_add_after">add_after</code></td>
<td>
<p>The index of the stage to insert a new stage after. This
index should be derived from the <code>ahstages</code> of the input <code>mpm</code>.
Cannot be set if <code>add_before</code> is to be used.</p>
</td></tr>
<tr><td><code id="add_stage_+3A_stage_name">stage_name</code></td>
<td>
<p>The name of the new stage to add. Defaults to
<code>new_stage</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new copy of the original MPM edited to include new rows and
columns in the associated matrices, and with <code>ahstages</code>,
<code>agestages</code>, and <code>hstages</code> objects edited to include the new
stage.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edit_lM">edit_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

cyp_lesl_data &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004, 
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04", 
  stagesize = "sizeadded", NAas0 = TRUE, age_offset = 2)

cyp_survival &lt;- glm(alive3 ~ obsage + as.factor(year2), data = cyp_lesl_data,
  family = "binomial")
cyp_fecundity &lt;- glm(feca2 ~ 1 + obsage + as.factor(year2),
  data = cyp_lesl_data, family = "poisson")

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[22] &lt;- "obsage"

germination &lt;- 0.08
protocorm_to_seedling &lt;- 0.10
seeding_to_adult &lt;- 0.20
seeds_per_fruit &lt;- 8000

cyp_lesl_supp &lt;- supplemental(historical = FALSE, stagebased = FALSE,
  agebased = TRUE, age2 = c(1, 2), type = c(1, 1),
  givenrate = c(protocorm_to_seedling, seeding_to_adult))

cyp_lesl_fb_mpm &lt;- fleslie(data = cyp_lesl_data, surv_model = cyp_survival,
  fec_model = cyp_fecundity, paramnames = mod_params, last_age = 7,
  fecage_min = 3, fecmod = (germination * seeds_per_fruit),
  supplement = cyp_lesl_supp)

altered1 &lt;- add_stage(cyp_lesl_fb_mpm, add_before = 1, stage_name = "DS")

</code></pre>

<hr>
<h2 id='aflefko2'>Create Function-based Ahistorical Age x Stage Matrix Projection Model</h2><span id='topic+aflefko2'></span>

<h3>Description</h3>

<p>Function <code>aflefko2()</code> returns ahistorical age x stage MPMs corresponding
to the patches and occasions given, including the associated component
transition and fecundity matrices, data frames detailing the characteristics
of ahistorical stages and the exact age-stage combinations corresponding to
rows and columns in estimated matrices, and a data frame characterizing the
patch and occasion combinations corresponding to these matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aflefko2(
  year = "all",
  patch = "all",
  stageframe,
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  data = NULL,
  modelsuite = NULL,
  surv_model = NULL,
  obs_model = NULL,
  size_model = NULL,
  sizeb_model = NULL,
  sizec_model = NULL,
  repst_model = NULL,
  fec_model = NULL,
  jsurv_model = NULL,
  jobs_model = NULL,
  jsize_model = NULL,
  jsizeb_model = NULL,
  jsizec_model = NULL,
  jrepst_model = NULL,
  jmatst_model = NULL,
  paramnames = NULL,
  inda = NULL,
  indb = NULL,
  indc = NULL,
  surv_dev = 0,
  obs_dev = 0,
  size_dev = 0,
  sizeb_dev = 0,
  sizec_dev = 0,
  repst_dev = 0,
  fec_dev = 0,
  jsurv_dev = 0,
  jobs_dev = 0,
  jsize_dev = 0,
  jsizeb_dev = 0,
  jsizec_dev = 0,
  jrepst_dev = 0,
  jmatst_dev = 0,
  density = NA,
  fecmod = 1,
  random.inda = FALSE,
  random.indb = FALSE,
  random.indc = FALSE,
  final_age = NA,
  continue = TRUE,
  prebreeding = TRUE,
  negfec = FALSE,
  ipm_method = "CDF",
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  exp_tol = 700,
  theta_tol = 1e+08,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aflefko2_+3A_year">year</code></td>
<td>
<p>A variable corresponding to the observation occasion, or a set
of such values, given in values associated with the year term used in linear 
model development. Defaults to <code>"all"</code>, in which case matrices will be
estimated for all occasions.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Defaults to <code>"all"</code>, but can also be set to specific
patch names or a vector thereof.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_stageframe">stageframe</code></td>
<td>
<p>An object of class <code>stageframe</code>. These objects are
generated by function <code><a href="#topic+sf_create">sf_create</a>()</code>, and include information on
the size, observation status, propagule status, reproduction status,
immaturity status, maturity status, stage group, size bin widths, and other
key characteristics of each ahistorical stage.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of <code>0</code>s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with <code>1</code> equaling full fecundity). If left
blank, and no <code>supplement</code> is provided, then <code>aflefko2()</code> will
assume that all stages marked as reproductive produce offspring at 1x that of
estimated fecundity, and that offspring production will yield the first stage
noted as propagule or immature. Must be the dimensions of an ahistorical
stage-based matrix.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_data">data</code></td>
<td>
<p>The historical vertical demographic data frame used to estimate
vital rates (class <code>hfvdata</code>), which is required to initialize times and
patches properly. Variable names should correspond to the naming conventions
in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and <code><a href="#topic+historicalize3">historicalize3</a>()</code>. Not
required if option <code>modelsuite</code> is set to a <code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_modelsuite">modelsuite</code></td>
<td>
<p>One of two kinds of lists. The first is a <code>lefkoMod</code>
object holding the vital rate models and associated metadata. Alternatively,
an object of class <code>vrm_input</code> may be provided. If given, then
<code>surv_model</code>, <code>obs_model</code>, <code>size_model</code>, <code>sizeb_model</code>,
<code>sizec_model</code>, <code>repst_model</code>, <code>fec_model</code>, <code>jsurv_model</code>,
<code>jobs_model</code>, <code>jsize_model</code>, <code>jsizeb_model</code>,
<code>jsizec_model</code>, <code>jrepst_model</code>, <code>jmatst_model</code>, and
<code>paramnames</code> are not required. No models should include size or
reproductive status in occasion <em>t</em>-1. Although this is optional input,
it is recommended, and without it all vital rate model inputs (named
<code>XX_model</code>) are required.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_surv_model">surv_model</code></td>
<td>
<p>A linear model predicting survival probability. This can 
be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_obs_model">obs_model</code></td>
<td>
<p>A linear model predicting sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_size_model">size_model</code></td>
<td>
<p>A linear model predicting primary size. This can be a model
of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_sizeb_model">sizeb_model</code></td>
<td>
<p>A linear model predicting secondary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_sizec_model">sizec_model</code></td>
<td>
<p>A linear model predicting tertiary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_repst_model">repst_model</code></td>
<td>
<p>A linear model predicting reproduction probability. This 
can be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_fec_model">fec_model</code></td>
<td>
<p>A linear model predicting fecundity. This can be a model of
class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>, <code>vglm</code>,
<code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing only the
impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsurv_model">jsurv_model</code></td>
<td>
<p>A linear model predicting juvenile survival probability.
This can be a model of class <code>glm</code> or <code>glmer</code>, and requires a
predicted binomial variable under a logit link. Ignored if <code>modelsuite</code>
is provided. This model must have been developed in a modeling exercise
testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jobs_model">jobs_model</code></td>
<td>
<p>A linear model predicting juvenile sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsize_model">jsize_model</code></td>
<td>
<p>A linear model predicting juvenile primary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsizeb_model">jsizeb_model</code></td>
<td>
<p>A linear model predicting juvenile secondary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsizec_model">jsizec_model</code></td>
<td>
<p>A linear model predicting juvenile tertiary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jrepst_model">jrepst_model</code></td>
<td>
<p>A linear model predicting reproduction probability of a 
mature individual that was immature in time <em>t</em>. This can be a model
of class <code>glm</code> or <code>glmer</code>, and requires a predicted binomial
variable under a logit link. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing only the
impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jmatst_model">jmatst_model</code></td>
<td>
<p>A linear model predicting maturity probability of an 
individual that was immature in time <em>t</em>. This can be a model of class
<code>glm</code> or <code>glmer</code>, and requires a predicted binomial variable under
a logit link. Ignored if <code>modelsuite</code> is provided. This model must have
been developed in a modeling exercise testing only the impacts of occasion
<em>t</em>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required if <code>modelsuite</code> is not supplied.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_inda">inda</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>a</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_indb">indb</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>b</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_indc">indc</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>c</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_surv_dev">surv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_obs_dev">obs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_size_dev">size_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_sizeb_dev">sizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_sizec_dev">sizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_repst_dev">repst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for probability of reproduction. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_fec_dev">fec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for fecundity. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsurv_dev">jsurv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jobs_dev">jobs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsize_dev">jsize_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsizeb_dev">jsizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jsizec_dev">jsizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jrepst_dev">jrepst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile reproduction probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_jmatst_dev">jmatst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile maturity probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_density">density</code></td>
<td>
<p>A numeric value indicating density value to use to propagate
matrices. Only needed if density is an explanatory term used in one or more
vital rate models. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier of fecundity. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_random.inda">random.inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_random.indb">random.indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_random.indc">random.indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_final_age">final_age</code></td>
<td>
<p>The final age to model in the matrix, where the first age
will be age 0. Defaults to the maximum age in the dataset.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_continue">continue</code></td>
<td>
<p>A logical value designating whether to allow continued
survival of individuals past the final age noted in the stageframe, using the 
demographic characteristics of the final age. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_negfec">negfec</code></td>
<td>
<p>A logical value denoting whether fecundity values estimated to
be negative should be reset to <code>0</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_ipm_method">ipm_method</code></td>
<td>
<p>A string indicating what method to use to estimate size
transition probabilities, if size is treated as continuous. Options include:
<code>"midpoint"</code>, which utilizes the midpoint method; and <code>"CDF"</code>,
which uses the cumulative distribution function. Defaults to <code>"CDF"</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove age-stages
associated solely with <code>0</code> transitions. These are only removed in cases
where the associated row and column sums in ALL matrices estimated equal 0. 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta as
used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.</p>
</td></tr>
<tr><td><code id="aflefko2_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. The structure has the following
elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasions. All matrices output in R's <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Set to <code>NA</code> for age-by-stage
MPMs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing the stage number and stage name
corresponding to <code>ahstages</code>, as well as the associated age, of each
row in each age-by-stage matrix.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the patch and year of each matrix in order.
In <code>aflefko2()</code>, only one population may be analyzed at once.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input.</p>
</td></tr>
<tr><td><code>prob_out</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a list of vital rate probability matrices, with 7 columns in the
order of survival, observation probability, reproduction probability, primary
size transition probability, secondary size transition probability, tertiary
size transition probability, and probability of juvenile transition to
maturity.</p>
</td></tr>
<tr><td><code>allstages</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a data frame giving the values used to determine each matrix element
capable of being estimated.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Unlike <code><a href="#topic+rlefko2">rlefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>,
<code><a href="#topic+arlefko2">arlefko2</a>()</code>, and <code><a href="#topic+rleslie">rleslie</a>()</code>, this function does not
currently distinguish populations. Users wishing to use the same vital rate
models across populations should label them as patches (though we do not
advise this approach, as populations should typically be treated as
statistically independent).
</p>
<p>This function will yield incorrect estimates if the models utilized
incorporate state in occasion <em>t</em>-1. Only use models developed testing
for ahistorical effects.
</p>
<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to 0, then only fecundity transitions noted in the
supplement will be set to non-zero values. To use the default behavior of
setting all reproductive stages to reproduce at full fecundity into immature
and propagule stages but also incorporate given or proxy
survival transitions, input those given and proxy transitions through the
<code>overwrite</code> option.
</p>
<p>The reproduction matrix (field <code>repmatrix</code>) may only be supplied as
ahistorical. If provided as historical, then <code>aflefko2()</code> will fail and
produce an error.
</p>
<p>Stageframes used in this function should include ages for minimum and maximum
age for each stage. <code>NA</code>s are treated as <code>0</code>s in minimum age, and
as <code>final_age</code> for maximum age.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations, but without discriminating between those
patches or subpopulations. Should the aim of analysis be a general MPM that
does not distinguish these patches or subpopulations, the
<code>modelsearch()</code> run should not include patch terms.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order will
lead to erroneous calculations, and may lead to fatal errors.
</p>
<p>Care should be taken to match the random status of year and patch to the
states of those variables within the <code>modelsuite</code>. If they do not match,
then they will be treated as zeroes in vital rate estimation.
</p>
<p>The <code>ipm_method</code> function gives the option of using two different means
of estimating the probability of size transition. The midpoint method
(<code>"midpoint"</code>) refers to the method in which the probability is
estimated by first estimating the probability associated with transition from
the exact size at the midpoint of the size class using the corresponding
probability density function, and then multiplying that value by the bin
width of the size class. Doak et al. 2021 (Ecological Monographs) noted that
this method can produce biased results, with total size transitions
associated with a specific size not totaling to 1.0 and even specific size
transition probabilities capable of being estimated at values greater than
1.0. The alternative and default method, <code>"CDF"</code>, uses the corresponding
cumulative density function to estimate the probability of size transition as
the cumulative probability of size transition at the greater limit of the
size class minus the cumulative probability of size transition at the lower
limit of the size class. The latter method avoids this bias. Note, however,
that both methods are exact and unbiased for the Poisson and negative
binomial distributions.
</p>
<p>Under the Gaussian and gamma size distributions, the number of estimated
parameters may differ between the two <code>ipm_method</code> settings. Because
the midpoint method has a tendency to incorporate upward bias in the
estimation of size transition probabilities, it is more likely to yield non-
zero values when the true probability is extremely close to 0. This will
result in the <code>summary.lefkoMat</code> function yielding higher numbers of
estimated parameters than the <code>ipm_method = "CDF"</code> yields in some cases.
</p>
<p>Using the <code>err_check</code> option will produce a matrix of 7 columns, each
characterizing a different vital rate. The product of each row yields an
element in the associated <code>U</code> matrix. The number and order of elements
in each column of this matrix matches the associated matrix in column vector
format. Use of this option is generally for the purposes of debugging code.
</p>
<p>Individual covariates are treated as categorical only if they are set as
random terms. Fixed categorical individual covariates are currently not
allowed. However, such terms may be supplied if the <code>modelsuite</code> option
is set to a <code>vrm_input</code> object. In that case, the user should also set
the logical random switch for the individual covariate to be used to 
<code>TRUE</code> (e.g., <code>random.inda = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r",
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
minima &lt;- c(1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector, minage = minima)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframeln,
  stagesize = "sizea", censorcol = "Missing1988", censorkeep = NA,
  NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ obsage + sizea2 + as.factor(patchid) +
  as.factor(year2), data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ obsage + as.factor(patchid) +
  as.factor(year2), data = obs_data, family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + repstatus2 + obsage + as.factor(patchid) +
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + as.factor(patchid) + as.factor(year2),
  data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + obsage + as.factor(patchid) +
  as.factor(year2), data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sdl", "rep", "rep"),
  eststage3 = c(NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, "Dorm", NA, NA),
  givenrate = c(0.345, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, 0.8, 0.345, 0.054), type = c(1, 1, 1, 3, 3),
  stageframe = lathframeln, historical = FALSE, agebased = TRUE)

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[22] &lt;- "obsage"

lathmat2age2 &lt;- aflefko2(year = "all", patch = "all", data = lathvertln,
  stageframe = lathframeln, supplement = lathsupp2, final_age = 3,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model,
  paramnames = mod_params, continue = TRUE, reduce = FALSE)

</code></pre>

<hr>
<h2 id='anthyllis'>Matrix Set of <em>Anthyllis vulneraria</em> Populations in Belgium</h2><span id='topic+anthyllis'></span>

<h3>Description</h3>

<p>A <code>lefkoMat</code> object containing projection matrices developed from
demographic data gathered on nine <em>Anthyllis vulneraria</em> populations
from 2003 to 2006 in southwestern Belgium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anthyllis)
</code></pre>


<h3>Format</h3>

<p>A <code>lefkoMat</code> object holding 27 matrices. The structure of the
object is as below:
</p>

<dl>
<dt>A</dt><dd><p>The 27 A matrices.</p>
</dd>
<dt>U</dt><dd><p>The 27 survival-transition matrices used to develop the A
matrices.</p>
</dd>
<dt>F</dt><dd><p>The 27 fecundity matrices used to develop the A matrices.</p>
</dd>
<dt>hstages</dt><dd><p>Not used, so set to <code>NA</code>.</p>
</dd>
<dt>agestages</dt><dd><p>Not used, so set to <code>NA</code>.</p>
</dd>
<dt>ahstages</dt><dd><p>The edited stageframe describing the life history of the
study organism as interpreted in the original demographic study.</p>
</dd>
<dt>labels</dt><dd><p>The order of the matrices, where each population is treated
as a separate patch and each matrix corresponds to a different combination
of population and year in time <em>t</em>.</p>
</dd>
<dt>matrixqc</dt><dd><p>A vector of integers used in the quality control section of
<code>lefkoMat</code> summary statements.</p>
</dd>
<dt>dataqc</dt><dd><p>Currently a vector with two <code>NA</code> values.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Davison, R. et al. 2010. Demographic effects of extreme weather
events on a short-lived calcareous grassland species: stochastic life table
response experiments. <em>Journal of Ecology</em> 98(2):255-267.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(anthyllis)

lambda3(anthyllis)
</code></pre>

<hr>
<h2 id='append_lP'>Append Projections Into New lefkoProj Object</h2><span id='topic+append_lP'></span>

<h3>Description</h3>

<p>Function <code>append_lP()</code> combines two population projections. It takes
two <code>lefkoProj</code> objects and appends them into a new <code>lefkoPrpoj</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_lP(proj1 = NULL, proj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_lP_+3A_proj1">proj1</code></td>
<td>
<p>A <code>lefkoProj</code> object.</p>
</td></tr>
<tr><td><code id="append_lP_+3A_proj2">proj2</code></td>
<td>
<p>A second <code>lefkoProj</code> object, based on the same stageframe
as <code>proj1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>lefkoProj</code>, which always includes the first
three elements of the following, and also includes the remaining elements
below when a <code>lefkoMat</code> object is used as input:
</p>
<table>
<tr><td><code>projection</code></td>
<td>
<p>A list of lists of matrices showing the total number of
individuals per stage per occasion. The first list corresponds to each
pop-patch followed by each population (this top-level list is a single
element in <code>f_projection3()</code>). The inner list corresponds to
replicates within each pop-patch or population.</p>
</td></tr>
<tr><td><code>stage_dist</code></td>
<td>
<p>A list of lists of the actual stage distribution in each
occasion in each replicate in each pop-patch or population.</p>
</td></tr>
<tr><td><code>rep_value</code></td>
<td>
<p>A list of lists of the actual reproductive value in each
occasion in each replicate in each pop-patch or population.</p>
</td></tr>
<tr><td><code>pop_size</code></td>
<td>
<p>A list of matrices showing the total population size in each
occasion per replicate (row within data frame) per pop-patch or population
(list element). <code>NA</code> values will result if projections with different
numbers of time steps are appended.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame showing the order of populations and patches in
item <code>projection</code>.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>The original stageframe used in the study.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame showing the order of historical stage pairs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing the order of age-stage pairs.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A short data frame indicating the population (always <code>1</code>),
and patch (either the numeric index of the single chosen patch, or <code>1</code>
in all other cases). Any pop-patches having the same designation across the
two input projections will be appended together.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>A data frame showing the number of replicates and time steps
corresponding to each set of projections, where each set corresponds to a
pop-patch within the labels object of each input projection.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>The data frame input under the density option. Only provided
if input by the user for at least one of the two projections. Output as a
nested list corresponding to each pop-patch - replicate.</p>
</td></tr>
<tr><td><code>density_vr</code></td>
<td>
<p>The data frame input under the density_vr option. Only
provided if input by the user for at least one of the two projections.
Output as a nested list corresponding to each pop-patch - replicate.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p><code>lefkoProj</code> objects resulting from previous appends can also be
appended.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projection3">projection3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D",
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep", "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3), stageframe = cypframe_raw,
  historical = FALSE)

cypmatrix2r_AB &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = c("A", "B"), stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2",  patchcol = "patchid", indivcol = "individ")

cypmatrix2r_AC &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = c("A", "C"), stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2",  patchcol = "patchid", indivcol = "individ")

cypproj1 &lt;- projection3(cypmatrix2r_AB, nreps = 5, times = 15,
  stochastic = TRUE)
cypproj2 &lt;- projection3(cypmatrix2r_AC, nreps = 10, times = 20,
  stochastic = TRUE)
cypproj3 &lt;- append_lP(cypproj1, cypproj2)

</code></pre>

<hr>
<h2 id='arlefko2'>Create Raw Ahistorical Age x Stage Matrix Projection Model</h2><span id='topic+arlefko2'></span>

<h3>Description</h3>

<p>Function <code>arlefko2()</code> returns raw ahistorical age x stage MPMs
corresponding to the patches and occasion times given, including the
associated component transition and fecundity matrices, data frames detailing
the characteristics of ahistorical stages and the exact age-stage
combinations corresponding to rows and columns in estimated matrices, and a
data frame characterizing the patch and occasion time combinations
corresponding to these matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlefko2(
  data,
  stageframe,
  year = "all",
  pop = NULL,
  patch = NULL,
  censor = FALSE,
  stages = NULL,
  alive = c("alive3", "alive2"),
  obsst = NULL,
  size = c("sizea3", "sizea2"),
  sizeb = NULL,
  sizec = NULL,
  repst = c("repstatus3", "repstatus2"),
  matst = c("matstatus3", "matstatus2"),
  fec = c("feca3", "feca2"),
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  agecol = "obsage",
  yearcol = NULL,
  popcol = NULL,
  patchcol = NULL,
  indivcol = NULL,
  censorcol = NULL,
  censorkeep = 0,
  final_age = NA,
  continue = TRUE,
  prebreeding = TRUE,
  NRasRep = FALSE,
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arlefko2_+3A_data">data</code></td>
<td>
<p>A vertical demographic data frame, with variables corresponding 
to the naming conventions in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_stageframe">stageframe</code></td>
<td>
<p>A stageframe object that includes information on the size,
observation status, propagule status, reproduction status, immaturity status,
and maturity status of each ahistorical stage. Should also incorporate bin
widths if size is continuous.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set
of such values, given in values associated with the year term used in linear 
model development. Defaults to <code>"all"</code>, in which case matrices will be
estimated for all occasions.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_pop">pop</code></td>
<td>
<p>A variable designating which populations will have matrices
estimated. Should be set to specific population names, or to <code>"all"</code> if
all populations should have matrices estimated.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to <code>"all"</code>
if matrices should be estimated for all patches. Defaults to <code>NA</code>, in
which case patch designations are ignored.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_censor">censor</code></td>
<td>
<p>If <code>TRUE</code>, then data will be removed according to the
variable set in <code>censorcol</code>, such that only data with censor values
equal to <code>censorkeep</code> will remain. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_stages">stages</code></td>
<td>
<p>An optional vector denoting the names of the variables within
the main vertical dataset coding for the stages of each individual in
occasions <em>t</em>+1 and <em>t</em>. The names of stages in these variables
should match those used in the <code>stageframe</code> exactly. If left blank, then
<code>arlefko2()</code> will attempt to infer stages by matching values of
<code>alive</code>, <code>size</code>, <code>repst</code>, and <code>matst</code> to characteristics
noted in the associated <code>stageframe</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_alive">alive</code></td>
<td>
<p>A vector of names of binomial variables corresponding to status
as alive (<code>1</code>) or dead (<code>0</code>) in occasions <em>t</em>+1 ans <em>t</em>,
respectively.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_obsst">obsst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
observation status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>NULL</code>, in which case observation status is
not used.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_size">size</code></td>
<td>
<p>A vector of names of variables coding the primary size variable
in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>c("sizea3", "sizea2")</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector of names of variables coding the secondary size
variable in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_sizec">sizec</code></td>
<td>
<p>A vector of names of variables coding the tertiary size
variable in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_repst">repst</code></td>
<td>
<p>A vector of names of variables coding reproductive status in
occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to 
<code>c("repstatus3", "repstatus2")</code>. Must be supplied if <code>stages</code> is
not provided.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_matst">matst</code></td>
<td>
<p>A vector of names of variables coding maturity status in
occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>c("matstatus3", "matstatus2")</code>. Must be supplied if <code>stages</code> is
not provided.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_fec">fec</code></td>
<td>
<p>A vector of names of variables coding fecundity in occasions
<em>t</em>+1 and <em>t</em>, respectively. Defaults to <code>c("feca3", "feca2")</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of 0s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with 1 equaling full fecundity). If left blank,
and no <code>supplement</code> is provided, then <code>aflefko2()</code> will assume that
all stages marked as reproductive produce offspring at 1x that of estimated
fecundity, and that offspring production will yield the first stage noted as
propagule or immature.  To prevent this behavior, input just <code>0</code>, which
will result in fecundity being estimated only for transitions noted in
<code>supplement</code> above. Must be the dimensions of an ahistorical stage-based
matrix.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_agecol">agecol</code></td>
<td>
<p>The variable name or column number coding for age in time
<em>t</em>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_yearcol">yearcol</code></td>
<td>
<p>The variable name or column number corresponding to occasion 
<em>t</em> in the dataset.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_popcol">popcol</code></td>
<td>
<p>The variable name or column number corresponding to the
identity of the population.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_patchcol">patchcol</code></td>
<td>
<p>The variable name or column number corresponding to patch in
the dataset.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_indivcol">indivcol</code></td>
<td>
<p>The variable name or column number coding individual
identity.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_censorcol">censorcol</code></td>
<td>
<p>The variable name or column number denoting the censor
status. Only needed if <code>censor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable denoting data elements to
keep. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_final_age">final_age</code></td>
<td>
<p>The final age to model in the matrix. Defaults to the
maximum age in the dataset.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_continue">continue</code></td>
<td>
<p>A logical value designating whether to allow continued
survival of individuals past the final age noted in the stageframe, using the 
demographic characteristics of the final age. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_nrasrep">NRasRep</code></td>
<td>
<p>If <code>data</code> does not include stage assignments, then this
option determines whether non-reproductive and reproductive individuals
should be lumped into the same stages. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove age-stages
associated with only zero transitions. These are removed only if the
respective row and column sums in ALL matrices estimated equal 0. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="arlefko2_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. Its structure is a list with the
following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasions. All matrices output in R's <code>matrix</code> class, or in the
<code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Set to <code>NA</code> for age-by-stage
MPMs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing the stage number and stage name
corresponding to <code>ahstages</code>, as well as the associated age, of each
row in each age-by-stage matrix.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the patch and year of each matrix in order.
In <code>aflefko2()</code>, only one population may be analyzed at once, and so
<code>pop = NA</code></p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input
in function-based MPMs. Empty in this function.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to 0, then only fecundity transitions noted in the
supplement will be set to non-zero values. To use the default behavior of
setting all reproductive stages to reproduce at full fecundity into immature
and propagule stages but also incorporate given or proxy survival
transitions, input those given and proxy transitions through the
<code>overwrite</code> options.
</p>
<p>The reproduction matrix (field <code>repmatrix</code>) may only be supplied as
ahistorical. If provided as historical, then <code>rlefko2()</code> will fail and
produce an error.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations. Should the aim of analysis be a general
MPM that does not distinguish these patches or subpopulations, the
<code>patchcol</code> variable should be left to <code>NA</code>, which is the default.
Otherwise the variable identifying patch needs to be named.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order WILL
lead to erroneous calculations, and may lead to fatal errors.
</p>
<p>Although this function is capable of assigning stages given an input
stageframe, it lacks the power of <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code> in this regard. Users are strongly
encouraged to use the latter two functions for stage assignment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)
minagevec &lt;- c(1, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5)
maxagevec &lt;- c(rep(NA, 11))

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec, minage = minagevec, maxage = maxagevec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE, age_offset = 4)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE, agebased = TRUE)

cyp_mats &lt;- arlefko2(data = cypraw_v1, stageframe = cypframe_raw, year = "all", 
  patch = NA, censor = FALSE, stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), fec = c("feca3", "feca2"),
  supplement = cypsupp2r, agecol = "obsage", yearcol = "year2", 
  patchcol = "patchid", indivcol = "individ", prebreeding = TRUE, final_age = NA,
  continue = TRUE, reduce = FALSE)

</code></pre>

<hr>
<h2 id='beverton3'>Two-parameter Beverton-Holt function</h2><span id='topic+beverton3'></span>

<h3>Description</h3>

<p>Function <code>beverton3()</code> creates a vector of values produced by the two-
parameter Beverton-Holt function as applied with a user-specified time lag.
The two-parameter Beverton-Holt function is given as 
<code class="reqn">\phi_{t+1} = \phi_t \alpha / (1 + \beta n_t)</code>. Here, if no
<code>separate_N</code> vector is provided, then <code class="reqn">n_t = \phi_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beverton3(
  start_value,
  alpha,
  beta,
  time_steps = 100L,
  time_lag = 1L,
  pre0_subs = FALSE,
  pre0_value = 0,
  substoch = 0L,
  separate_N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beverton3_+3A_start_value">start_value</code></td>
<td>
<p>A positive number to start the return vector in time 0.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter in the two-parameter Beverton-Holt
function. Must be non-negative.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_beta">beta</code></td>
<td>
<p>The beta parameter in the two-parameter Beverton-Holt function.
Must be non-negative.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_time_steps">time_steps</code></td>
<td>
<p>The number of time steps to run the projection. Must be a
positive integer.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_time_lag">time_lag</code></td>
<td>
<p>A positive integer denoting the number of time steps back
for the value of phi in the two-parameter Beverton-Holt function.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_pre0_subs">pre0_subs</code></td>
<td>
<p>A logical value indicating whether to use a number other
than that given in <code>start_value</code> for values of phi lagged from times
prior to time 0.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_pre0_value">pre0_value</code></td>
<td>
<p>A positive number to use for phi lagged from times prior
to time 0. Only used if <code>pre0_subs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="beverton3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating the kind of substochasticity to
use. Values include: <code>0</code>, no substochasticity enforced (the default);
<code>1</code>, all numbers must be non-negative; and <code>2</code>, all numbers should
be forced to the interval [0, 1].</p>
</td></tr>
<tr><td><code id="beverton3_+3A_separate_n">separate_N</code></td>
<td>
<p>An optional numeric vector with values of N in each time,
if phi is to be treated as different from N in the two-parameter model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values showing values projected under the two-
parameter Beverton-Holt function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial_run1 &lt;- beverton3(1, alpha = 0.5, beta = 0.009)
plot(trial_run1)

trial_run2 &lt;- beverton3(1, alpha = 0.5, beta = 0.9)
plot(trial_run2)

trial_run3 &lt;- beverton3(1, alpha = 1, beta = 0.009)
plot(trial_run3)

trial_run4 &lt;- beverton3(1, alpha = 1, beta = 0.9)
plot(trial_run4)

trial_run5 &lt;- beverton3(1, alpha = 5, beta = 0.009)
plot(trial_run5)

trial_run6 &lt;- beverton3(1, alpha = 5, beta = 0.9)
plot(trial_run6)

used_Ns &lt;- c(10, 15, 12, 14, 14, 150, 15, 1, 5, 7, 9, 14, 13, 16, 17, 19,
  25, 26)
trial_run7 &lt;- beverton3(1, alpha = 1, beta = 0.009, separate_N = used_Ns)
plot(trial_run7)

</code></pre>

<hr>
<h2 id='cond_diff'>Extract Conditional Ahistorical Difference Matrices</h2><span id='topic+cond_diff'></span>

<h3>Description</h3>

<p>Function <code>cond_diff()</code> takes a set of historical difference matrices
resulting from function <code><a href="#topic+diff_lM">diff_lM</a>()</code> and decomposes them into 
ahistorical difference matrices conditional upon stage in time <em>t</em>-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_diff(lDiff, ref = 1L, matchoice = NULL, err_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_diff_+3A_ldiff">lDiff</code></td>
<td>
<p>An object of class <code>lefkoDiff</code>.</p>
</td></tr>
<tr><td><code id="cond_diff_+3A_ref">ref</code></td>
<td>
<p>Choice of mpm to use as reference. Defaults to <code>1</code>, which
means that the <code>ahstages</code>, <code>hstages</code>, and <code>labels</code> elements
for mpm1 will be used for all calculations. Only <code>1</code> amd <code>2</code> are
possible inputs.</p>
</td></tr>
<tr><td><code id="cond_diff_+3A_matchoice">matchoice</code></td>
<td>
<p>A character denoting whether to use A, U, or F matrices.
Defaults to <code>A</code> matrices.</p>
</td></tr>
<tr><td><code id="cond_diff_+3A_err_check">err_check</code></td>
<td>
<p>A logical value denoting whether to include a data frame
of element equivalence from the conditional matrices to the original
matrices. Used only for debugging purposes. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoCondDiff</code> object, with the following elements:
</p>
<table>
<tr><td><code>Mcond</code></td>
<td>
<p>A multi-level list holding the conditional matrices derived
from the input <code>lefkoDiff</code> object. The top level of the list
corresponds to each historical difference matrix in turn, and the lower
level corresponds to each stage in time <em>t</em>-1, with individual
conditional matrices named for the latter.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame showing the patch and year of each input full A 
matrix in order.</p>
</td></tr>
<tr><td><code>err_check</code></td>
<td>
<p>An optional data frame showing the order of used element
indices to create conditional matrices.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 3, 6, 11, 19.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1.5, 1.5, 3.5, 5)
comments &lt;- c("Dormant seed", "1st yr protocorm", "2nd yr protocorm",
  "3rd yr protocorm", "Seedling", "Dormant adult",
  "Extra small adult (1 shoot)", "Small adult (2-4 shoots)",
  "Medium adult (5-7 shoots)", "Large adult (8-14 shoots)",
  "Extra large adult (&gt;14 shoots)")
cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset, 
  binhalfwidth = binvec, comments = comments)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004, 
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

seeds_per_pod &lt;- 5000

cypsupp2_raw &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "SL", "D", 
    "XSm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep", "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "D", "XSm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "XSm", "XSm", NA, NA),
  givenrate = c(0.03, 0.15, 0.1, 0.1, 0.1, 0.05, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, (0.5 * seeds_per_pod),
    (0.5 * seeds_per_pod)),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)
cypsupp3_raw &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix2rp &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix3rp &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"), 
  size = c("size3added", "size2added", "size1added"), supplement = cypsupp3_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", stages = c("stage3", "stage2", "stage1"), 
  size = c("size3added", "size2added", "size1added"), supplement = cypsupp3_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix2r_3 &lt;- hist_null(cypmatrix2r)
cypmatrix2r_3 &lt;- delete_lM(cypmatrix2r_3, year = 2004)
diff_r &lt;- diff_lM(cypmatrix3r, cypmatrix2r_3)

cypmatrix2rp_3 &lt;- hist_null(cypmatrix2rp)
cypmatrix2rp_3 &lt;- delete_lM(cypmatrix2rp_3, year = 2004)
diff_rp &lt;- diff_lM(cypmatrix3rp, cypmatrix2rp_3)

condr1 &lt;- cond_diff(diff_r, ref = 1)
condr2 &lt;- cond_diff(diff_r, ref = 2)

condrp1 &lt;- cond_diff(diff_rp, matchoice = "U", ref = 1)
condrp2 &lt;- cond_diff(diff_rp, matchoice = "F", ref = 2)

</code></pre>

<hr>
<h2 id='cond_hmpm'>Extract Conditional Ahistorical Matrices from Historical MPM</h2><span id='topic+cond_hmpm'></span>

<h3>Description</h3>

<p>Function <code>cond_hmpm()</code> takes historical MPMs and decomposes them into 
ahistorical matrices conditional upon stage in time <em>t</em>-1. In effect,
the function takes each historical matrix within a lefkoMat object, and
forms one ahistorical matrix for each stage in time <em>t</em>-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_hmpm(hmpm, matchoice = NULL, err_check = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_hmpm_+3A_hmpm">hmpm</code></td>
<td>
<p>A historical matrix projection model of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="cond_hmpm_+3A_matchoice">matchoice</code></td>
<td>
<p>A character denoting whether to use A, U, or F matrices.
Defaults to <code>A</code> matrices.</p>
</td></tr>
<tr><td><code id="cond_hmpm_+3A_err_check">err_check</code></td>
<td>
<p>A logical value denoting whether to include a data frame
of element equivalence from the conditional matrices to the original
matrices. Used only for debugging purposes. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoCondMat</code> object, with the following elements:
</p>
<table>
<tr><td><code>Mcond</code></td>
<td>
<p>A multi-level list holding the conditional A matrices derived
from the input <code>lefkoMat</code> object. The top level of the list corresponds
to each historical matrix in turn, and the lower level corresponds to each
stage in time <em>t</em>-1, with individual conditional matrices named for the
latter.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame showing the patch and year of each input full A 
matrix in order.</p>
</td></tr>
<tr><td><code>err_check</code></td>
<td>
<p>An optional data frame showing the order of used element
indices to create conditional matrices.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)
 
sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md",
  "Lg", "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"),
  supplement = cypsupp3r, yearcol = "year2", patchcol = "patchid",
  indivcol = "individ")

cypcondmats &lt;- cond_hmpm(cypmatrix3r)
summary(cypcondmats)

</code></pre>

<hr>
<h2 id='create_lM'>Create lefkoMat Object from Given Input Matrices or an MPM Database</h2><span id='topic+create_lM'></span>

<h3>Description</h3>

<p>Function <code>create_lM()</code> creates lefkoMat objects from supplied matrices
and extra information, or from a supplied MPM database such as COMPADRE or
COMADRE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lM(
  mats,
  stageframe = NULL,
  hstages = NA,
  agestages = NA,
  historical = FALSE,
  agebystage = FALSE,
  UFdecomp = TRUE,
  entrystage = 1,
  poporder = 1,
  patchorder = 1,
  yearorder = NA,
  matrix_id = NULL,
  add_FC = TRUE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_lM_+3A_mats">mats</code></td>
<td>
<p>A list of A matrices, or, if importing from a matrix database
such as COMPADRE or COMADRE, then the object holding the database.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_stageframe">stageframe</code></td>
<td>
<p>A stageframe describing all stages utilized.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_hstages">hstages</code></td>
<td>
<p>A data frame outlining the order of historical stages, if
matrices provided in <code>mats</code> are historical. Defaults to NA.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_agestages">agestages</code></td>
<td>
<p>A data frame outlining the order of ahistorical age-stages,
if age-by-stage matrices are provided.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_historical">historical</code></td>
<td>
<p>A logical value indicating whether input matrices are
historical or not. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_agebystage">agebystage</code></td>
<td>
<p>A logical value indicating whether input matrices are
ahistorical age-by-stage matrices. If TRUE, then object <code>agestages</code> is
required. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_ufdecomp">UFdecomp</code></td>
<td>
<p>A logical value indicating whether U and F matrices should be
inferred. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_entrystage">entrystage</code></td>
<td>
<p>The stage or stages produced by reproductive individuals.
Used to determine which transitions are reproductive for U-F decomposition.
Defaults to <code>1</code>, which corresponds to the first stage in the stageframe.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_poporder">poporder</code></td>
<td>
<p>The order of populations in the list supplied in object
<code>mats</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_patchorder">patchorder</code></td>
<td>
<p>The order of patches in the list supplied in object
<code>mats</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_yearorder">yearorder</code></td>
<td>
<p>The order of monitoring occasions in the list supplied in
object <code>mats</code>. Defaults to NA, which leads to each matrix within each
population-patch combination being a different monitoring occasion.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_matrix_id">matrix_id</code></td>
<td>
<p>The values of <code>MatrixID</code> from the used database
corresponding to the matrices to import, if importing from a database. Not
used if importing a list of matrices.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_add_fc">add_FC</code></td>
<td>
<p>A logical value indicating whether to sum the <code>matF</code> and
<code>matC</code> matrices to produce the <code>F</code> matrix. If <code>FALSE</code>, then
only uses the <code>matF</code> matrix. Only used if importing from the COMPADRE or
COMADRE database. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_lM_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices in
sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format. Does not apply to matrices imported from
COMPADRE or COMADRE, which are always in standard format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoMat</code> object incorporating the matrices input in object
<code>mats</code> as object <code>A</code>, their U and F decompositions in objects
<code>U</code> and <code>F</code> (if requested), the provided stageframe as object
<code>ahstages</code>, the order of historical stages as object <code>hstages</code> (if
<code>historical = TRUE</code>), the order of matrices as object <code>labels</code>, and
a short quality control section used by the <code><a href="#topic+summary.lefkoMat">summary.lefkoMat</a>()</code>
function.
</p>


<h3>Notes for importing lists of matrices</h3>

<p>Lists may be composed of a mix of matrices in standard R format (i.e. created
via the <code>matrix()</code> function), and in <code>dgCMatrix</code> sparse format
(i.e. created via the <code>Matrix::Matrix()</code> function with
<code>sparse = TRUE</code>.) All matrices will be forced to one or the other,
depending on the value given for the <code>sparse_output</code> argument.
</p>
<p>U and F decomposition assumes that elements holding fecundity values are
to be interpreted solely as fecundity rates. Users wishing to split these
elements between fecundity and survival should do so manually after running
this function.
</p>
<p>Age-by-stage MPMs require an <code>agestages</code> data frame outlining the order
of age-stages. This data frame has 3 variables: <code>stage_id</code>, which is the
number of the stage as labelled by the equivalently named variable in the
<code>stageframe</code>; <code>stage</code>, which is the official name of the stage as
given in the equivalently named variable in the <code>stageframe</code>; and
<code>age</code>, which of course gives the age associated with the stage at that
time. The number of rows must be equal to the number of rows and columns of
each entered matrix.
</p>
<p>Users may edit the <code>dataqc</code> object, setting the first <code>NA</code> to the
number of individuals sampled, and the second <code>NA</code> to the number of
rows in a vertical version of the demographic dataset. This is not required,
however.
</p>


<h3>Notes for importing from COMPADRE or COMADRE</h3>

<p>For this function to operate, users must have either the COMPADRE database
or the COMADRE database loaded into the global environment. Note that the
sample databases supplied within package <code>Rcompadre</code> will not work with
this function.
</p>
<p>This function does not and cannot replace the wonderful tools offered to
explore the COMPADRE and COMADRE packages. Please see package
<code>Rcompadre</code> to use those tools. Note that function <code>import_Com()</code>
has no relationship to the <code>Rcompadre</code> development team.
</p>
<p>Function <code>import_Com()</code> requires that the dimensions of all matrices
imported into a single <code>lefkoMat</code> object be equal.
</p>
<p>The reproductive and maturity status of each stage is determined by patterns
assessed within the <code>F</code> matrices. Users should check that these values
make sense.
</p>
<p>Stage names may be edited manually afterward.
</p>
<p>Users may edit the <code>dataqc</code> object, setting the first <code>NA</code> to the
number of individuals sampled, and the second <code>NA</code> to the number of
rows in a vertical version of the demographic dataset. This is not required,
however.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_lM">add_lM</a>()</code>
</p>
<p><code><a href="#topic+delete_lM">delete_lM</a>()</code>
</p>
<p><code><a href="#topic+subset_lM">subset_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These matrices are of 9 populations of the plant species Anthyllis
# vulneraria, and were originally published in Davison et al. (2010) Journal
# of Ecology 98:255-267 (doi: 10.1111/j.1365-2745.2009.01611.x).

sizevector &lt;- c(1, 1, 2, 3) # These sizes are not from the original paper
stagevector &lt;- c("Sdl", "Veg", "SmFlo", "LFlo")
repvector &lt;- c(0, 0, 1, 1)
obsvector &lt;- c(1, 1, 1, 1)
matvector &lt;- c(0, 1, 1, 1)
immvector &lt;- c(1, 0, 0, 0)
propvector &lt;- c(0, 0, 0, 0)
indataset &lt;- c(1, 1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5, 0.5)

anthframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# POPN C 2003-2004
XC3 &lt;- matrix(c(0, 0, 1.74, 1.74,
0.208333333, 0, 0, 0.057142857,
0.041666667, 0.076923077, 0, 0,
0.083333333, 0.076923077, 0.066666667, 0.028571429), 4, 4, byrow = TRUE)

# 2004-2005
XC4 &lt;- matrix(c(0, 0, 0.3, 0.6,
0.32183908, 0.142857143, 0, 0,
0.16091954, 0.285714286, 0, 0,
0.252873563, 0.285714286, 0.5, 0.6), 4, 4, byrow = TRUE)

# 2005-2006
XC5 &lt;- matrix(c(0, 0, 0.50625, 0.675,
0, 0, 0, 0.035714286,
0.1, 0.068965517, 0.0625, 0.107142857,
0.3, 0.137931034, 0, 0.071428571), 4, 4, byrow = TRUE)

# POPN E 2003-2004
XE3 &lt;- matrix(c(0, 0, 2.44, 6.569230769,
0.196428571, 0, 0, 0,
0.125, 0.5, 0, 0,
0.160714286, 0.5, 0.133333333, 0.076923077), 4, 4, byrow = TRUE)

XE4 &lt;- matrix(c(0, 0, 0.45, 0.646153846,
0.06557377, 0.090909091, 0.125, 0,
0.032786885, 0, 0.125, 0.076923077,
0.049180328, 0, 0.125, 0.230769231), 4, 4, byrow = TRUE)

XE5 &lt;- matrix(c(0, 0, 2.85, 3.99,
0.083333333, 0, 0, 0,
0, 0, 0, 0,
0.416666667, 0.1, 0, 0.1), 4, 4, byrow = TRUE)

mats_list &lt;- list(XC3, XC4, XC5, XE3, XE4, XE5)
yr_ord &lt;- c(1, 2, 3, 1, 2, 3)
pch_ord &lt;- c(1, 1, 1, 2, 2, 2)

anth_lefkoMat &lt;- create_lM(mats_list, anthframe, hstages = NA,
  historical = FALSE, poporder = 1, patchorder = pch_ord, yearorder = yr_ord)

# A theoretical example showcasing historical matrices
sizevector &lt;- c(1, 2, 3) # These sizes are not from the original paper
stagevector &lt;- c("Sdl", "Veg", "Flo")
repvector &lt;- c(0, 0, 1)
obsvector &lt;- c(1, 1, 1)
matvector &lt;- c(0, 1, 1)
immvector &lt;- c(1, 0, 0)
propvector &lt;- c(1, 0, 0)
indataset &lt;- c(1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5)

exframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

A1 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 2.00, 0, 0, 3.00, 0, 0, 4.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

A2 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 5.00, 0, 0, 6.00, 0, 0, 7.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

A3 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 8.00, 0, 0, 9.00, 0, 0, 10.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

B1 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 11.00, 0, 0, 12.00, 0, 0, 13.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

B2 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 14.00, 0, 0, 15.00, 0, 0, 16.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

B3 &lt;- matrix(c(0.10, 0, 0, 0.12, 0, 0, 0.15, 0, 0,
  0.15, 0, 0, 0.17, 0, 0, 0.20, 0, 0,
  0.20, 0, 0, 0.22, 0, 0, 0.25, 0, 0,
  0, 0.20, 0, 0, 0.22, 0, 0, 0.25, 0,
  0, 0.25, 0, 0, 0.27, 0, 0, 0.30, 0,
  0, 0.30, 0, 0, 0.32, 0, 0, 0.35, 0,
  0, 0, 17.00, 0, 0, 18.00, 0, 0, 19.00,
  0, 0, 0.35, 0, 0, 0.37, 0, 0, 0.40,
  0, 0, 0.40, 0, 0, 0.42, 0, 0, 0.45), 9, 9, byrow = TRUE)

histmats &lt;- list(A1, A2, A3, B1, B2, B3)
stageframe &lt;- exframe
pch_ord &lt;- c("A", "A", "A", "B", "B", "B")
yr_ord &lt;- c(1, 2, 3, 1, 2, 3)

hist_trial &lt;- create_lM(histmats, exframe, historical = TRUE,
  UFdecomp = TRUE, entrystage = 1, patchorder = pch_ord, yearorder = yr_ord)
  
</code></pre>

<hr>
<h2 id='create_pm'>Creates a Skeleton Paramnames Object for Use in Function-based Modeling</h2><span id='topic+create_pm'></span>

<h3>Description</h3>

<p>Creates a simple skeleton <code>paramnames</code> object that can be entered as
input in functions <code><a href="#topic+flefko2">flefko2</a>()</code>, <code><a href="#topic+flefko3">flefko3</a>()</code>, and
<code><a href="#topic+aflefko2">aflefko2</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_pm(name_terms = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_pm_+3A_name_terms">name_terms</code></td>
<td>
<p>A logical value indicating whether to start each variable
name as <code>none</code> if <code>FALSE</code>, or as the default <code>modelparams</code>
name if <code>TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three column data frame, of which the first describes the
parameters in reasonably plain English, the second gives the name of the
parameter within the MPM generating functions, and the third is to be
edited with the names of the variables as they appear in the models.
</p>


<h3>Notes</h3>

<p>The third column in the resulting object should be edited with the names only
of those variables actually used in vital rate modeling. This
<code>paramnames</code> object should apply to all models used in a single MPM
building exercise. So, for example, if the models used include random terms,
then they should all have the same random terms. Fixed terms can vary,
however.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>our_pm &lt;- create_pm()
our_pm

</code></pre>

<hr>
<h2 id='cypdata'>Demographic Dataset of <em>Cypripedium candidum</em> Population, in Horizontal
Format</h2><span id='topic+cypdata'></span>

<h3>Description</h3>

<p>A dataset containing the states and fates of <em>Cypripedium candidum</em> 
(white lady's slipper orchids), family Orchidaceae, from a population in 
Illinois, USA, resulting from monitoring that occurred annually between 2004 
and 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cypdata)
</code></pre>


<h3>Format</h3>

<p>A data frame with 77 individuals and 29 variables. Each row 
corresponds to an unique individual, and each variable from <code>size.04</code> 
on refers to the state of the individual in a particular year.
</p>

<dl>
<dt>plantid</dt><dd><p>A numeric variable giving a unique number to each 
individual.</p>
</dd>
<dt>patch</dt><dd><p>A variable refering to patch within the population.</p>
</dd>
<dt>X</dt><dd><p>An X coordinate for the plant within the population.</p>
</dd>
<dt>Y</dt><dd><p>A Y coordinate for the plant within the population.</p>
</dd>
<dt>censor</dt><dd><p>A variable coding for whether the data point is valid. An
entry of 1 means that it is so.</p>
</dd>
<dt>Inf2.04</dt><dd><p>Number of double inflorescences in 2004.</p>
</dd>
<dt>Inf.04</dt><dd><p>Number of inflorescences in 2004.</p>
</dd>
<dt>Veg.04</dt><dd><p>Number of stems without inflorescences in 2004.</p>
</dd>
<dt>Pod.04</dt><dd><p>Number of fruits in 2004.</p>
</dd>
<dt>Inf2.05</dt><dd><p>Number of double inflorescences in 2005.</p>
</dd>
<dt>Inf.05</dt><dd><p>Number of inflorescences in 2005.</p>
</dd>
<dt>Veg.05</dt><dd><p>Number of stems without inflorescences in 2005.</p>
</dd>
<dt>Pod.05</dt><dd><p>Number of fruits in 2005.</p>
</dd>
<dt>Inf2.06</dt><dd><p>Number of double inflorescences in 2006.</p>
</dd>
<dt>Inf.06</dt><dd><p>Number of inflorescences in 2006.</p>
</dd>
<dt>Veg.06</dt><dd><p>Number of stems without inflorescences in 2006.</p>
</dd>
<dt>Pod.06</dt><dd><p>Number of fruits in 2006.</p>
</dd>
<dt>Inf2.07</dt><dd><p>Number of double inflorescences in 2007.</p>
</dd>
<dt>Inf.07</dt><dd><p>Number of inflorescences in 2007.</p>
</dd>
<dt>Veg.07</dt><dd><p>Number of stems without inflorescences in 2007.</p>
</dd>
<dt>Pod.07</dt><dd><p>Number of fruits in 2007.</p>
</dd>
<dt>Inf2.08</dt><dd><p>Number of double inflorescences in 2008.</p>
</dd>
<dt>Inf.08</dt><dd><p>Number of inflorescences in 2008.</p>
</dd>
<dt>Veg.08</dt><dd><p>Number of stems without inflorescences in 2008.</p>
</dd>
<dt>Pod.08</dt><dd><p>Number of fruits in 2008.</p>
</dd>
<dt>Inf2.09</dt><dd><p>Number of double inflorescences in 2009.</p>
</dd>
<dt>Inf.09</dt><dd><p>Number of inflorescences in 2009.</p>
</dd>
<dt>Veg.09</dt><dd><p>Number of stems without inflorescences in 2009.</p>
</dd>
<dt>Pod.09</dt><dd><p>Number of fruits in 2009.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Shefferson, R.P., R. Mizuta, and M.J. Hutchings. 2017. Predicting
evolution in response to climate change: the example of sprouting probability
in three dormancy-prone orchid species. <em>Royal Society Open Science</em> 
4(1):160647.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")
                       
lambda3(cypmatrix2r)
</code></pre>

<hr>
<h2 id='cypvert'>Demographic Dataset of <em>Cypripedium candidum</em> Population, in Vertical
Format</h2><span id='topic+cypvert'></span>

<h3>Description</h3>

<p>A dataset containing the states and fates of <em>Cypripedium candidum</em> 
(white lady's slipper orchids), family Orchidaceae, from a population in 
Illinois, USA, resulting from monitoring that occurred annually between 2004 
and 2009. Same dataset as <code>cypdata</code>, but arranged in an ahistorical
vertical format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cypvert)
</code></pre>


<h3>Format</h3>

<p>A data frame with 77 individuals, 322 rows, and 14 variables. Each
row corresponds to a specific two-year transition for a specific individual.
Variable codes are similar to those for <code>cypdata</code>, but use <code>.2</code> to
identify occasion <em>t</em> and <code>.3</code> to identify occasion <em>t</em>+1.
</p>

<dl>
<dt>plantid</dt><dd><p>A numeric variable giving a unique number to each 
individual.</p>
</dd>
<dt>patch</dt><dd><p>A variable refering to patch within the population.</p>
</dd>
<dt>X</dt><dd><p>An X coordinate for the plant within the population.</p>
</dd>
<dt>Y</dt><dd><p>A Y coordinate for the plant within the population.</p>
</dd>
<dt>censor</dt><dd><p>A variable coding for whether the data point is valid. An
entry of 1 means that it is so.</p>
</dd>
<dt>year2</dt><dd><p>Year in occasion <em>t</em>.</p>
</dd>
<dt>Inf2.2</dt><dd><p>Number of double inflorescences in occasion <em>t</em>.</p>
</dd>
<dt>Inf.2</dt><dd><p>Number of inflorescences in occasion <em>t</em>.</p>
</dd>
<dt>Veg.2</dt><dd><p>Number of stems without inflorescences in occasion <em>t</em>.</p>
</dd>
<dt>Pod.2</dt><dd><p>Number of fruits in occasion <em>t</em>.</p>
</dd>
<dt>Inf2.3</dt><dd><p>Number of double inflorescences in occasion <em>t</em>+1.</p>
</dd>
<dt>Inf.3</dt><dd><p>Number of inflorescences in occasion <em>t</em>+1.</p>
</dd>
<dt>Veg.3</dt><dd><p>Number of stems without inflorescences in occasion <em>t</em>+1.</p>
</dd>
<dt>Pod.3</dt><dd><p>Number of fruits in occasion <em>t</em>+1.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Shefferson, R.P., R. Mizuta, and M.J. Hutchings. 2017. Predicting
evolution in response to climate change: the example of sprouting probability
in three dormancy-prone orchid species. <em>Royal Society Open Science</em> 
4(1):160647.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypvert)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v2 &lt;- historicalize3(data = cypvert, patchidcol = "patch", 
  individcol = "plantid", year2col = "year2", sizea2col = "Inf2.2", 
  sizea3col = "Inf2.3", sizeb2col = "Inf.2", sizeb3col = "Inf.3", 
  sizec2col = "Veg.2", sizec3col = "Veg.3", repstra2col = "Inf2.2", 
  repstra3col = "Inf2.3", repstrb2col = "Inf.2", repstrb3col = "Inf.3", 
  feca2col = "Pod.2", feca3col = "Pod.3", repstrrel = 2, 
  stageassign = cypframe_raw, stagesize = "sizeadded", censorcol = "censor",
  censor = FALSE, NAas0 = TRUE, NRasRep = TRUE, reduce = TRUE)
  
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v2, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")
  
lambda3(cypmatrix2r)
</code></pre>

<hr>
<h2 id='delete_lM'>Delete Matrices from lefkoMat Object</h2><span id='topic+delete_lM'></span>

<h3>Description</h3>

<p>Function <code>delete_lM()</code> deletes matrices from <code>lefkoMat</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_lM(lM, mat_num = NA, pop = NA, patch = NA, year = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_lM_+3A_lm">lM</code></td>
<td>
<p>The <code>lefkoMat</code> object to delete matrices from.</p>
</td></tr>
<tr><td><code id="delete_lM_+3A_mat_num">mat_num</code></td>
<td>
<p>Either a single integer corresponding to the matrix to remove
within the <code>labels</code> element of <code>lM</code>, or a vector of such integers.</p>
</td></tr>
<tr><td><code id="delete_lM_+3A_pop">pop</code></td>
<td>
<p>The population designation for matrices to remove. Only used if
<code>mat_num</code> is not given.</p>
</td></tr>
<tr><td><code id="delete_lM_+3A_patch">patch</code></td>
<td>
<p>The patch designation for matrices to remove. Only used if
<code>mat_num</code> is not given.</p>
</td></tr>
<tr><td><code id="delete_lM_+3A_year">year</code></td>
<td>
<p>The time <em>t</em> designation for matrices to remove. Only used
if <code>mat_num</code> is not given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoMat</code> object in which the matrices specified in <code>lM</code>
have been removed.
</p>


<h3>Notes</h3>

<p>If <code>mat_num</code> is not provided, then at least one of <code>pop</code>,
<code>patch</code>, or <code>year</code> must be provided. If at least two of <code>pop</code>,
<code>patch</code>, and <code>year</code> are provided, then function <code>detele_lM()</code>
will identify matrices to remove as the intersection of provided inputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_lM">create_lM</a>()</code>
</p>
<p><code><a href="#topic+add_lM">add_lM</a>()</code>
</p>
<p><code><a href="#topic+subset_lM">subset_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These matrices are of 9 populations of the plant species Anthyllis
# vulneraria, and were originally published in Davison et al. (2010) Journal
# of Ecology 98:255-267 (doi: 10.1111/j.1365-2745.2009.01611.x).

sizevector &lt;- c(1, 1, 2, 3) # These sizes are not from the original paper
stagevector &lt;- c("Sdl", "Veg", "SmFlo", "LFlo")
repvector &lt;- c(0, 0, 1, 1)
obsvector &lt;- c(1, 1, 1, 1)
matvector &lt;- c(0, 1, 1, 1)
immvector &lt;- c(1, 0, 0, 0)
propvector &lt;- c(0, 0, 0, 0)
indataset &lt;- c(1, 1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5, 0.5)

anthframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# POPN C 2003-2004
XC3 &lt;- matrix(c(0, 0, 1.74, 1.74,
0.208333333, 0, 0, 0.057142857,
0.041666667, 0.076923077, 0, 0,
0.083333333, 0.076923077, 0.066666667, 0.028571429), 4, 4, byrow = TRUE)

# 2004-2005
XC4 &lt;- matrix(c(0, 0, 0.3, 0.6,
0.32183908, 0.142857143, 0, 0,
0.16091954, 0.285714286, 0, 0,
0.252873563, 0.285714286, 0.5, 0.6), 4, 4, byrow = TRUE)

# 2005-2006
XC5 &lt;- matrix(c(0, 0, 0.50625, 0.675,
0, 0, 0, 0.035714286,
0.1, 0.068965517, 0.0625, 0.107142857,
0.3, 0.137931034, 0, 0.071428571), 4, 4, byrow = TRUE)

# POPN E 2003-2004
XE3 &lt;- matrix(c(0, 0, 2.44, 6.569230769,
0.196428571, 0, 0, 0,
0.125, 0.5, 0, 0,
0.160714286, 0.5, 0.133333333, 0.076923077), 4, 4, byrow = TRUE)

XE4 &lt;- matrix(c(0, 0, 0.45, 0.646153846,
0.06557377, 0.090909091, 0.125, 0,
0.032786885, 0, 0.125, 0.076923077,
0.049180328, 0, 0.125, 0.230769231), 4, 4, byrow = TRUE)

XE5 &lt;- matrix(c(0, 0, 2.85, 3.99,
0.083333333, 0, 0, 0,
0, 0, 0, 0,
0.416666667, 0.1, 0, 0.1), 4, 4, byrow = TRUE)

mats_list &lt;- list(XC3, XC4, XC5, XE3, XE4, XE5)
yr_ord &lt;- c(1, 2, 3, 1, 2, 3)
pch_ord &lt;- c(1, 1, 1, 2, 2, 2)

anth_lefkoMat &lt;- create_lM(mats_list, anthframe, hstages = NA,
  historical = FALSE, poporder = 1, patchorder = pch_ord, yearorder = yr_ord)
  
smaller_anth_lM &lt;- delete_lM(anth_lefkoMat, patch = 2)

</code></pre>

<hr>
<h2 id='density_input'>Set Density Dependence Relationships in Matrix Elements</h2><span id='topic+density_input'></span>

<h3>Description</h3>

<p>Function <code>density_input()</code> provides all necessary data to incorporate
density dependence into a <code>lefkoMat</code> object, a list of matrices, or a
single matrix. Four forms of density dependence are allowed, including the
Ricker function, the Beverton-Holt function, the Usher function, and the
logistic function. In each case, density must have an effect with a delay of
at least one time-step (see Notes). The resulting data frame provides a
guide for other <code>lefko3</code> functions to modify matrix elements by
density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_input(
  mpm,
  stage3 = NULL,
  stage2 = NULL,
  stage1 = NULL,
  age2 = NULL,
  style = NULL,
  time_delay = NULL,
  alpha = NULL,
  beta = NULL,
  type = NULL,
  type_t12 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_input_+3A_mpm">mpm</code></td>
<td>
<p>The <code>lefkoMat</code> object that will be subject to density
dependent projection.</p>
</td></tr>
<tr><td><code id="density_input_+3A_stage3">stage3</code></td>
<td>
<p>A vector showing the name or number of the stage in occasion
<em>t</em>+1 in the transitions to be affected by density. Abbreviations for
groups of stages are also usable (see Notes).</p>
</td></tr>
<tr><td><code id="density_input_+3A_stage2">stage2</code></td>
<td>
<p>A vector showing the name or number of the stage in occasion
<em>t</em> in the transition to be affected by density. Abbreviations for
groups of stages are also usable (see Notes).</p>
</td></tr>
<tr><td><code id="density_input_+3A_stage1">stage1</code></td>
<td>
<p>A vector showing the name or number of the stage in occasion
<em>t</em>-1 in the transition to be affected by density. Only needed if a
historical MPM is used. Abbreviations for groups of stages are also usable
(see Notes).</p>
</td></tr>
<tr><td><code id="density_input_+3A_age2">age2</code></td>
<td>
<p>A vector showing the age of the stage in occasion <em>t</em> in the
transition to be affected by density. Only needed if an age-by-stage MPM is
used.</p>
</td></tr>
<tr><td><code id="density_input_+3A_style">style</code></td>
<td>
<p>A vector coding for the style of density dependence on each
transition subject to density dependence. Options include <code>1</code>,
<code>ricker</code>, <code>ric</code>, or <code>r</code> for the Ricker function; <code>2</code>,
<code>beverton</code>, <code>bev</code>, and <code>b</code> for the Beverton-Holt function;
<code>3</code>, <code>usher</code>, <code>ush</code>, and <code>u</code> for the Usher function; and
<code>4</code>, <code>logistic</code>, <code>log</code>, and <code>l</code> for the logistic
function. If only a single code is provided, then all noted transitions are
assumed to be subject to this style of density dependence. Defaults to
<code>ricker</code>.</p>
</td></tr>
<tr><td><code id="density_input_+3A_time_delay">time_delay</code></td>
<td>
<p>An integer vector indicating the number of occasions back
on which density dependence operates. Defaults to <code>1</code>, and may not equal
any integer less than 1. If a single number is input, then all noted
transitions are assumed to be subject to this time delay.  Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code id="density_input_+3A_alpha">alpha</code></td>
<td>
<p>A vector indicating the numeric values to use as the
alpha term in the two parameter Ricker, Beverton-Holt, or Usher function, or
the value of the carrying capacity <em>K</em> to use in the logistic equation
(see <code>Notes</code> section for more on this term). If a single number is
provided, then all noted transitions are assumed to be subject to this value
of alpha. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="density_input_+3A_beta">beta</code></td>
<td>
<p>A vector indicating the numeric values to use as the beta term in
the two parameter Ricker, Beverton-Holt, or Usher function. Used to indicate
whether to use <em>K</em> as a hard limit in the logistic equation (see section
<code>Notes</code> below). If a single number is provided, then all noted
transitions are assumed to be subject to this value of <code>beta</code>. Defaults
to <code>1</code>.</p>
</td></tr>
<tr><td><code id="density_input_+3A_type">type</code></td>
<td>
<p>A vector denoting the kind of transition between occasions
<em>t</em> and <em>t</em>+1 to be replaced. This should be entered as <code>1</code>,
<code>S</code>, or <code>s</code> for the replacement of a survival transition; or 
<code>2</code>, <code>F</code>, or <code>f</code> for the replacement of a fecundity
transition. If empty or not provided, then defaults to <code>1</code> for survival
transition.</p>
</td></tr>
<tr><td><code id="density_input_+3A_type_t12">type_t12</code></td>
<td>
<p>An optional vector denoting the kind of transition between
occasions <em>t</em>-1 and <em>t</em>. Only necessary if a historical MPM in
deVries format is desired. This should be entered as <code>1</code>, <code>S</code>, or
<code>s</code> for a survival transition; or <code>2</code>, <code>F</code>, or <code>f</code> for a
fecundity transitions. Defaults to <code>1</code> for survival transition, with
impacts only on the construction of deVries-format hMPMs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>lefkoDens</code>. This object can be used as
input in function <code><a href="#topic+projection3">projection3</a>()</code>.
</p>
<p>Variables in this object include the following:
</p>
<table>
<tr><td><code>stage3</code></td>
<td>
<p>Stage at occasion <em>t</em>+1 in the transition to be replaced.</p>
</td></tr>
<tr><td><code>stage2</code></td>
<td>
<p>Stage at occasion <em>t</em> in the transition to be replaced.</p>
</td></tr>
<tr><td><code>stage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1 in the transition to be replaced,
if applicable.</p>
</td></tr>
<tr><td><code>age2</code></td>
<td>
<p>Age at occasion <em>t</em> in the transition to be replaced, if
applicable.</p>
</td></tr>
<tr><td><code>style</code></td>
<td>
<p>Style of density dependence, coded as 1, 2, 3, or 4 for the
Ricker, Beverton-Holt, Usher, or logistic function, respectively.</p>
</td></tr>
<tr><td><code>time_delay</code></td>
<td>
<p>The time delay on density dependence, in time steps.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The value of alpha in the Ricker, Beverton-Holt, or Usher
function, or the value of carrying capacity, <em>K</em>, in the logistic
function.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The value of beta in the Ricker, Beverton-Holt, or Usher
function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Designates whether the transition from occasion <em>t</em> to
occasion <em>t</em>+1 is a survival transition probability (1), or a fecundity
rate (2).</p>
</td></tr>
<tr><td><code>type_t12</code></td>
<td>
<p>Designates whether the transition from occasion <em>t</em>-1 to
occasion <em>t</em> is a survival transition probability (1), a fecundity rate
(2).</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>This function provides inputs when density dependence is operationalized
directly on matrix elements. It can be used in both <code>projection3()</code> and
<code>f_projection3()</code>. Users wishing to modify vital rate functions by
density dependence functions for use in function-based projections with
function <code>f_projection3()</code> should use function <code>density_vr()</code> to
provide the correct inputs.
</p>
<p>The parameters <code>alpha</code> and <code>beta</code> are applied according to the
two-parameter Ricker function, the two-parameter Beverton-Holt function, the
two-parameter Usher function, or the one-parameter logistic function.
Although the default is that a 1 time step delay is assumed, greater time
delays can be set through the <code>time_delay</code> option.
</p>
<p>Entries in <code>stage3</code>, <code>stage2</code>, and <code>stage1</code> can include
abbreviations for groups of stages. Use <code>rep</code> if all reproductive stages
are to be used, <code>nrep</code> if all mature but non-reproductive stages are to
be used, <code>mat</code> if all mature stages are to be used, <code>immat</code> if all
immature stages are to be used, <code>prop</code> if all propagule stages are to be
used, <code>npr</code> if all non-propagule stages are to be used, <code>obs</code> if
all observable stages are to be used, <code>nobs</code> if all unobservable stages
are to be used, and leave empty or use <code>all</code> if all stages in stageframe
are to be used.
</p>
<p>When using the logistic function, it is possible that the time delay used in
density dependent simulations will cause matrix elements to become negative.
To prevent this behavior, set the associated <code>beta</code> term to <code>1.0</code>.
Doing so will set <code>K</code> as the hard limit in the logistic equation,
essentially setting a minimum limit at <code>0</code> for all matrix elements
modified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_input">start_input</a>()</code>
</p>
<p><code><a href="#topic+projection3">projection3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)

e3d &lt;- density_input(ehrlen3mean, stage3 = c("Sd", "Sdl"),
  stage2 = c("rep", "rep"), stage1 = c("all", "all"), style = 1,
  time_delay = 1, alpha = 1, beta = 0, type = c(2, 2), type_t12 = c(1, 1))

lathproj &lt;- projection3(ehrlen3, nreps = 5, stochastic = TRUE, substoch = 2,
  density = e3d)


</code></pre>

<hr>
<h2 id='density_vr'>Set Density Dependence Relationships in Vital Rates</h2><span id='topic+density_vr'></span>

<h3>Description</h3>

<p>Function <code>density_vr()</code> provides all necessary data to incorporate
density dependence into the vital rate functions used to create matrices in
function-based projections using function <code>f_projection3()</code>. Four forms
of density dependence are allowed, including the Ricker function, the
Beverton-Holt function, the Usher function, and the logistic function. In
each case, density must have an effect with at least a one time-step delay
(see Notes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_vr(
  density_yn = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE),
  style = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
  time_delay = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  alpha = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
  beta = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_vr_+3A_density_yn">density_yn</code></td>
<td>
<p>A 14 element logical vector denoting whether each vital
rate is subject to density dependence. The order of vital rates is: survival
probability, observation probability, primary size transition, secondary size
transition, tertiary size transition, reproductive status probability,
fecundity rate, juvenile survival probability, juvenile observation
probability, juvenile primary size transition, juvenile secondary size
transition, juvenile tertiary size transition, juvenile reproductive status
probability, and juvenile maturity status probability. Defaults to a vector
of 14 <code>FALSE</code> values.</p>
</td></tr>
<tr><td><code id="density_vr_+3A_style">style</code></td>
<td>
<p>A 14 element vector coding for the style of density dependence
on each vital rate. Options include <code>0</code>: no density dependence,
<code>1</code>, <code>ricker</code>, <code>ric</code>, or <code>r</code> for the Ricker function;
<code>2</code>, <code>beverton</code>, <code>bev</code>, and <code>b</code> for the Beverton-Holt
function; <code>3</code>, <code>usher</code>, <code>ush</code>, and <code>u</code> for the Usher
function; and <code>4</code>, <code>logistic</code>, <code>log</code>, and <code>l</code> for the
logistic function. Defaults to 14 values of <code>0</code>.</p>
</td></tr>
<tr><td><code id="density_vr_+3A_time_delay">time_delay</code></td>
<td>
<p>A 14 element vector indicating the number of occasions back
on which density dependence operates. Defaults to 14 values of <code>1</code>, and
may not include any number less than 1.</p>
</td></tr>
<tr><td><code id="density_vr_+3A_alpha">alpha</code></td>
<td>
<p>A 14 element vector indicating the numeric values to use as the
alpha term in the two parameter Ricker, Beverton-Holt, or Usher function, or
the value of the carrying capacity <em>K</em> to use in the logistic equation
(see <code>Notes</code> for more on this term). Defaults to 14 values of <code>0</code>.</p>
</td></tr>
<tr><td><code id="density_vr_+3A_beta">beta</code></td>
<td>
<p>A 14 element vector indicating the numeric values to use as the
beta term in the two parameter Ricker, Beverton-Holt, or Usher function. Used
to indicate whether to use <em>K</em> as a hard limit in the logistic equation
(see <code>Notes</code> below). Defaults to 14 values of <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>lefkoDensVR</code> with 14 rows, one for each
vital rate in the order of: survival probability, observation probability,
primary size transition, secondary size transition, tertiary size transition,
reproductive status probability, fecundity rate, juvenile survival
probability, juvenile observation probability, juvenile primary size
transition, juvenile secondary size transition, juvenile tertiary size
transition, juvenile reproductive status probability, and juvenile maturity
status probability. This object can be used as input in function
<code><a href="#topic+f_projection3">f_projection3</a>()</code>.
</p>
<p>Variables in this object include the following:
</p>
<table>
<tr><td><code>vital_rate</code></td>
<td>
<p>The vital rate to be modified.</p>
</td></tr>
<tr><td><code>density_yn</code></td>
<td>
<p>Logical value indicating whether vital rate will be subject
to density dependence.</p>
</td></tr>
<tr><td><code>style</code></td>
<td>
<p>Style of density dependence, coded as <code>1</code>, <code>2</code>,
<code>3</code>, <code>4</code>, or <code>0</code> for the Ricker, Beverton-Holt, Usher, or
logistic function, or no density dependence, respectively.</p>
</td></tr>
<tr><td><code>time_delay</code></td>
<td>
<p>The time delay on density dependence, in time steps.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The value of alpha in the Ricker, Beverton-Holt, or Usher
function, or the value of carrying capacity, <em>K</em>, in the logistic
function.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The value of beta in the Ricker, Beverton-Holt, or Usher
function.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>This function provides inputs when density dependence is operationalized
directly on vital rates. It can be used only in function
<code>f_projection3()</code>. Users wishing to modify matrix elements directly by
density dependence functions for use in function-based or raw projections
with functions <code>projection3()</code> and <code>f_projection3()</code> should use
function <code>density_input()</code> to provide the correct inputs.
</p>
<p>The parameters <code>alpha</code> and <code>beta</code> are applied according to the
two-parameter Ricker function, the two-parameter Beverton-Holt function, the
two-parameter Usher function, or the one-parameter logistic function.
Although the default is that a 1 time step delay is assumed, greater time
delays can be set through the <code>time_delay</code> option.
</p>
<p>When using the logistic function, it is possible that the time delay used in
density dependent simulations will cause matrix elements to become negative.
To prevent this behavior, set the associated <code>beta</code> term to <code>1.0</code>.
Doing so will set <code>K</code> as the hard limit in the logistic equation,
essentially setting a minimum limit at <code>0</code> for all matrix elements
modified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density_input">density_input</a>()</code>
</p>
<p><code><a href="#topic+f_projection3">f_projection3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(patchid), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid) +
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid),
  data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[13] &lt;- "sizea1"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[19] &lt;- "repstatus1"

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "Sdl", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "Sd", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  eststage1 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframeln, historical = TRUE)

# While we do not use MPMs to initialize f_projections3(), we do use MPMs to
# initialize functions start_input() and density_input().
lathmat3ln &lt;- flefko3(year = "all", patch = "all", data = lathvertln,
  stageframe = lathframeln, supplement = lathsupp3, paramnames = mod_params,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model, reduce = FALSE)

e3m_sv &lt;- start_input(lathmat3ln, stage2 = "Sd", stage1 = "Sd", value = 1000)

dyn7 &lt;- c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE, FALSE)
dst7 &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
dal7 &lt;- c(0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
dbe7 &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

e3d_vr &lt;- density_vr(density_yn = dyn7, style = dst7, alpha = dal7,
  beta = dbe7)

trial7_dvr_1 &lt;- f_projection3(format = 1, data = lathvertln, supplement = lathsupp3,
  paramnames = mod_params, stageframe = lathframeln, nreps = 2,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model,
  times = 100, stochastic = TRUE, standardize = FALSE, growthonly = TRUE,
  integeronly = FALSE, substoch = 0, sp_density = 0, start_frame = e3m_sv,
  density_vr = e3d_vr)


</code></pre>

<hr>
<h2 id='diff_lM'>Calculate Difference Matrices Between lefkoMat Objects of Equal Dimensions</h2><span id='topic+diff_lM'></span>

<h3>Description</h3>

<p>Function <code>diff_lM()</code> takes two <code>lefkoMat</code> objects with completely
equal dimensions, including both the size and number of matrices, and
gives the matrix differences between each corresponding set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_lM(mpm1, mpm2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_lM_+3A_mpm1">mpm1</code></td>
<td>
<p>The first <code>lefkoMat</code> object.</p>
</td></tr>
<tr><td><code id="diff_lM_+3A_mpm2">mpm2</code></td>
<td>
<p>The second <code>lefkoMat</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lefkoDiff</code>, which is a set of <code>A</code>,
<code>U</code>, and <code>F</code> matrices corresponding to the differences between each
set of matrices, followed by the <code>hstages</code>, <code>ahstages</code>, and
<code>labels</code> elements from each input <code>lefkoMat</code> object. Elements
labelled with a <code>1</code> at the end refer to <code>mpm1</code>, while those
labelled <code>2</code> at the end refer to <code>mpm2</code>.
</p>


<h3>Notes</h3>

<p>The exact difference is calculated as the respective matrix in <code>mpm1</code>
minus the corresponding matrix in <code>mpm2</code>.
</p>
<p>This function first checks to see if the number of matrices is the same, and
then whether the matrix dimensions are the same. If the two sets differ in at
least one of these characteristics, then the function will yield a fatal
error.
</p>
<p>If the lengths and dimensions of the input <code>lefkoMat</code> objects are the
same, then this will check if the <code>labels</code> element is essentially the
same. If not, then the function will yield a warning, but will still operate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 3, 6, 11, 19.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1.5, 1.5, 3.5, 5)
comments &lt;- c("Dormant seed", "1st yr protocorm", "2nd yr protocorm",
  "3rd yr protocorm", "Seedling", "Dormant adult",
  "Extra small adult (1 shoot)", "Small adult (2-4 shoots)",
  "Medium adult (5-7 shoots)", "Large adult (8-14 shoots)",
  "Extra large adult (&gt;14 shoots)")
cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset, 
  binhalfwidth = binvec, comments = comments)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004, 
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

seeds_per_pod &lt;- 5000

cypsupp2_raw &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "SL", "D", 
    "XSm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep", "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "D", "XSm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "XSm", "XSm", NA, NA),
  givenrate = c(0.03, 0.15, 0.1, 0.1, 0.1, 0.05, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, (0.5 * seeds_per_pod),
    (0.5 * seeds_per_pod)),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)
cypsupp3_raw &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3",
    "SL", "SL", "SL", "D", "D", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "SL", "P3",
    "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "XSm", "D", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", NA, NA),
  givenrate = c(0.01, 0.05, 0.10, 0.20, 0.1, 0.1, 0.05, 0.05, 0.05, NA, NA,
    NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    (0.5 * seeds_per_pod), (0.5 * seeds_per_pod)),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix2rp &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", stages = c("stage3", "stage2"),
  size = c("size3added", "size2added"), supplement = cypsupp2_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix3rp &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"), 
  size = c("size3added", "size2added", "size1added"), supplement = cypsupp3_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", stages = c("stage3", "stage2", "stage1"), 
  size = c("size3added", "size2added", "size1added"), supplement = cypsupp3_raw, 
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cypmatrix2r_3 &lt;- hist_null(cypmatrix2r)
cypmatrix2r_3 &lt;- delete_lM(cypmatrix2r_3, year = 2004)
diff_r &lt;- diff_lM(cypmatrix3r, cypmatrix2r_3)

cypmatrix2rp_3 &lt;- hist_null(cypmatrix2rp)
cypmatrix2rp_3 &lt;- delete_lM(cypmatrix2rp_3, year = 2004)
diff_rp &lt;- diff_lM(cypmatrix3rp, cypmatrix2rp_3)

</code></pre>

<hr>
<h2 id='edit_lM'>Edit an MPM based on Supplemental Data</h2><span id='topic+edit_lM'></span>

<h3>Description</h3>

<p>Function <code>edit_lM()</code> edits existing <code>lefkoMat</code> objects with
external data supplied by the user. The effects are similar to function
<code><a href="#topic+supplemental">supplemental</a>()</code>, though function <code>edit_lM()</code> allows
individuals matrices within <code>lefkoMat</code> objects to be edited after
creation, while <code><a href="#topic+supplemental">supplemental</a>()</code> provides external data that
modifies all matrices within a <code>lefkoMat</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edit_lM(
  mpm,
  pop = NULL,
  patch = NULL,
  year2 = NULL,
  stage3 = NULL,
  stage2 = NULL,
  stage1 = NULL,
  age2 = NULL,
  eststage3 = NULL,
  eststage2 = NULL,
  eststage1 = NULL,
  estage2 = NULL,
  givenrate = NULL,
  multiplier = NULL,
  type = NULL,
  type_t12 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit_lM_+3A_mpm">mpm</code></td>
<td>
<p>The <code>lefkoMat</code> object to be edited.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_pop">pop</code></td>
<td>
<p>A string vector denoting the populations to be edited. Defaults
to <code>NULL</code>, in which case all populations are edited.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_patch">patch</code></td>
<td>
<p>A string vector denoting the patches to be edited. Defaults
to <code>NULL</code>, in which case all patches are edited.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_year2">year2</code></td>
<td>
<p>A string vector denoting the years to be edited. Defaults
to <code>NULL</code>, in which case all years are edited.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_stage3">stage3</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>+1 in the transition
to be replaced. Abbreviations for groups of stages are also usable (see
<code>Notes</code>). Required in all stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_stage2">stage2</code></td>
<td>
<p>The name of the stage in occasion <em>t</em> in the transition
to be replaced. Abbreviations for groups of stages are also usable (see
<code>Notes</code>). Required in all stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_stage1">stage1</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>-1 in the transition
to be replaced. Only needed if a historical matrix is to be produced.
Abbreviations for groups of stages are also usable (see <code>Notes</code>).
Required for historical stage-based MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_age2">age2</code></td>
<td>
<p>An integer vector of the ages in occasion <em>t</em> to use in
transitions to be changed or replaced. Required for all age- and
age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_eststage3">eststage3</code></td>
<td>
<p>The name of the stage to replace <code>stage3</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_eststage2">eststage2</code></td>
<td>
<p>The name of the stage to replace <code>stage2</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_eststage1">eststage1</code></td>
<td>
<p>The name of the stage to replace <code>stage1</code> in a proxy
historical transition. Only needed if a transition will be replaced by
another estimated transition, and the matrix to be estimated is historical
and stage-based. Stage <code>NotAlive</code> is also possible for raw hMPMs as a
means of handling the prior stage for individuals entering the population in
occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_estage2">estage2</code></td>
<td>
<p>The age at time <em>t</em> to replace <code>age2</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in age-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_givenrate">givenrate</code></td>
<td>
<p>A fixed rate or probability to replace for the transition
described by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_multiplier">multiplier</code></td>
<td>
<p>A vector of numeric multipliers for fecundity or for proxy
transitions. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_type">type</code></td>
<td>
<p>A vector denoting the kind of transition between occasions
<em>t</em> and <em>t</em>+1 to be replaced. This should be entered as <code>1</code>,
<code>S</code>, or <code>s</code> for the replacement of a survival transition;
<code>2</code>, <code>F</code>, or <code>f</code> for the replacement of a fecundity
transition; or <code>3</code>, <code>R</code>, or <code>r</code> for a fecundity multiplier.
If empty or not provided, then defaults to <code>1</code> for survival transition.</p>
</td></tr>
<tr><td><code id="edit_lM_+3A_type_t12">type_t12</code></td>
<td>
<p>An optional vector denoting the kind of transition between
occasions <em>t</em>-1 and <em>t</em>. Only necessary if a historical MPM in
deVries format is desired. This should be entered as <code>1</code>, <code>S</code>, or
<code>s</code> for a survival transition; or <code>2</code>, <code>F</code>, or <code>f</code> for a
fecundity transitions. Defaults to <code>1</code> for survival transition, with
impacts only on the construction of deVries-format hMPMs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edited copy of the original MPM is returned, also as a
<code>lefkoMat</code> object.
</p>


<h3>Notes</h3>

<p>Entries in <code>stage3</code>, <code>stage2</code>, and <code>stage1</code> can include
abbreviations for groups of stages. Use <code>rep</code> if all reproductive
stages are to be used, <code>nrep</code> if all mature but non-reproductive stages
are to be used, <code>mat</code> if all mature stages are to be used, <code>immat</code>
if all immature stages are to be used, <code>prop</code> if all propagule stages
are to be used, <code>npr</code> if all non-propagule stages are to be used,
<code>obs</code> if all observable stages are to be used, <code>nobs</code> if all
unobservable stages are to be used, and leave empty or use <code>all</code> if all
stages in stageframe are to be used. Also use <code>groupX</code> to denote all
stages in group X (e.g. <code>group1</code> will use all stages in the respective
stageframe's group 1).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supplemental">supplemental</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  age_offset = 3, NAas0 = TRUE, NRasRep = TRUE)

cyp_rl &lt;- rleslie(data = cypraw_v1, start_age = 0, last_age = 6, continue = TRUE,
  fecage_min = 3, year = "all", pop = NA, patch = "all", yearcol = "year2",
  patchcol = "patchid", indivcol = "individ")

ddd1 &lt;- edit_lM(cyp_rl, age2 = c(0, 1, 2, 3, 4, 5, 6),
  givenrate = c(0.25, 0.25, 0.4, 0.4, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 2000, 2000, 2000),
  type = c(1, 1, 1, 1, 3, 3, 3))
  
ddd1 &lt;- edit_lM(ddd1, age2 = 6, multiplier = 1.5, type = 3, patch = "B",
  year2 = "2005")

</code></pre>

<hr>
<h2 id='elasticity3'>Estimate Elasticity of Population Growth Rate to Matrix Elements</h2><span id='topic+elasticity3'></span>

<h3>Description</h3>

<p><code>elasticity3()</code> is a generic function that returns the elasticity of
the population growth rate to the elements of the matrices in a matrix
population model. Currently, this function estimates both deterministic and
stochastic elasticities, where the growth rate is <code class="reqn">\lambda</code> in the former
case and the log of the stochastic <code class="reqn">\lambda</code> in the latter case. This
function is made to handle very large and sparse matrices supplied as
<code>lefkoMat</code> objects, as lists of matrices, and as individual matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elasticity3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity3_+3A_mats">mats</code></td>
<td>
<p>A lefkoMat object, a population projection matrix, or a list of
population projection matrices for which the stable stage distribution is
desired.</p>
</td></tr>
<tr><td><code id="elasticity3_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the <code>mats</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity3.lefkoMat">elasticity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.matrix">elasticity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.dgCMatrix">elasticity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.list">elasticity3.list</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoElas">summary.lefkoElas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
elasticity3(ehrlen3mean)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

elasticity3(cypmatrix2r)

</code></pre>

<hr>
<h2 id='elasticity3.dgCMatrix'>Estimate Elasticity of Population Growth Rate of a Single Sparse Matrix</h2><span id='topic+elasticity3.dgCMatrix'></span>

<h3>Description</h3>

<p><code>elasticity3.dgCMatrix()</code> returns the elasticities of lambda to elements
of a single matrix.  Because this handles only one matrix, the elasticities
are inherently deterministic and based on the dominant eigen value as the
best metric of the population growth rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
elasticity3(mats, sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity3.dgCMatrix_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="elasticity3.dgCMatrix_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="elasticity3.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a single elasticity matrix in <code>dgCMatrix</code>
format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity3">elasticity3</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.lefkoMat">elasticity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.list">elasticity3.list</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.matrix">elasticity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoElas">summary.lefkoElas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
elasticity3(ehrlen3mean$A[[1]])

</code></pre>

<hr>
<h2 id='elasticity3.lefkoMat'>Estimate Elasticity of Population Growth Rate of a lefkoMat Object</h2><span id='topic+elasticity3.lefkoMat'></span>

<h3>Description</h3>

<p><code>elasticity3.lefkoMat()</code> returns the elasticities of population growth
rate to elements of all <code>$A</code> matrices in an object of class
<code>lefkoMat</code>. If deterministic, then <code class="reqn">\lambda</code> is taken as the
population growth rate. If stochastic, then stochastic <code class="reqn">\lambda</code>, or
the stochastic growth rate, is taken as the population growth rate. This
function can handle large and sparse matrices, and so can be used with large
historical matrices, IPMs, age x stage matrices, as well as smaller
ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
elasticity3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  sparse = "auto",
  append_mats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity3.lefkoMat_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value determining whether to conduct a
deterministic (FALSE) or stochastic (TRUE) elasticity analysis. Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_times">times</code></td>
<td>
<p>The number of occasions to project forward in stochastic
simulation. Defaults to 10,000.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_append_mats">append_mats</code></td>
<td>
<p>A logical value indicating whether to include the original
A, U, and F matrices in the output <code>lefkoElas</code> object.</p>
</td></tr>
<tr><td><code id="elasticity3.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>lefkoElas</code>, which is a
list with 8 elements. The first, <code>h_elasmats</code>, is a list of historical
elasticity matrices (<code>NULL</code> if an ahMPM is used as input). The second,
<code>ah_elasmats</code>, is a list of either ahistorical elasticity matrices if an
ahMPM is used as input, or, if an hMPM is used as input, then the result is a
list of elasticity matrices in which historical elasticities have been summed
by the stage in occasions <em>t</em> and <em>t</em>+1 to produce
historically-corrected elasticity matrices, which are equivalent in dimension
to ahistorical elasticity matrices but reflect the effects of stage in
occasion <em>t</em>-1. The third element, <code>hstages</code>, is a data frame
showing historical stage pairs (NULL if ahMPM used as input). The fourth
element, <code>agestages</code>, shows age-stage combinations in the order used in
age-by-stage MPMs, if suppled. The fifth element, <code>ahstages</code>, is a data
frame showing the order of ahistorical stages. The last 3 elements are the A,
U, and F portions of the input.
</p>


<h3>Notes</h3>

<p>Deterministic elasticities are estimated as eqn. 9.72 in Caswell (2001,
Matrix Population Models). Stochastic elasticities are estimated as eqn.
14.99 in Caswell (2001). Note that stochastic elasticities are of the
stochastic <code class="reqn">\lambda</code>, while stochastic sensitivities are with regard to
the log of the stochastic <code class="reqn">\lambda</code>.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>The <code>time_weights</code>, <code>steps</code>, and <code>force_sparse</code> arguments are
now deprecated. Instead, please use the <code>tweights</code>, <code>times</code>, and
<code>sparse</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity3">elasticity3</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.dgCMatrix">elasticity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.matrix">elasticity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.list">elasticity3.list</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoElas">summary.lefkoElas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

elasticity3(ehrlen3, stochastic = TRUE)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

elasticity3(cypmatrix2r)

</code></pre>

<hr>
<h2 id='elasticity3.list'>Estimate Elasticity of Population Growth Rate of a List of Matrices</h2><span id='topic+elasticity3.list'></span>

<h3>Description</h3>

<p><code>elasticity3.list()</code> returns the elasticities of lambda to elements
of a single matrix. This function can handle large and sparse matrices, and 
so can be used with large historical matrices, IPMs, age x stage matrices,
as well as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
elasticity3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  historical = FALSE,
  seed = NA,
  sparse = "auto",
  append_mats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity3.list_+3A_mats">mats</code></td>
<td>
<p>A list of objects of class <code>matrix</code> or <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value determining whether to conduct a
deterministic (FALSE) or stochastic (TRUE) elasticity analysis. Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_times">times</code></td>
<td>
<p>The number of occasions to project forward in stochastic
simulation. Defaults to 10,000.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_historical">historical</code></td>
<td>
<p>A logical value denoting whether the input matrices are
historical. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_append_mats">append_mats</code></td>
<td>
<p>A logical value indicating whether to include the original
matrices input as object <code>mats</code> in the output <code>lefkoElas</code> object.</p>
</td></tr>
<tr><td><code id="elasticity3.list_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>lefkoElas</code>, which is a
list with 8 elements. The first, <code>h_elasmats</code>, is a list of historical
elasticity matrices, though in the standard list case it returns a NULL
value. The second, <code>ah_elasmats</code>, is a list of ahistorical elasticity
matrices. The third element, <code>hstages</code>, the fourth element,
<code>agestages</code>, and the fifth element, <code>ahstages</code>, are set to NULL.
The last 3 elements are the original A matrices in element A, followed by
NULL values for the U and F elements.
</p>


<h3>Notes</h3>

<p>Deterministic elasticities are estimated as eqn. 9.72 in Caswell (2001,
Matrix Population Models). Stochastic elasticities are estimated as eqn.
14.99 in Caswell (2001). Note that stochastic elasticities are of stochastic
<code class="reqn">\lambda</code>, while stochastic sensitivities are with regard to the log of
the stochastic <code class="reqn">\lambda</code>.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>The <code>time_weights</code>, <code>steps</code>, and <code>force_sparse</code> arguments are
now deprecated. Instead, please use the <code>tweights</code>, <code>times</code>, and
<code>sparse</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity3">elasticity3</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.lefkoMat">elasticity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.matrix">elasticity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.dgCMatrix">elasticity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoElas">summary.lefkoElas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

elasticity3(ehrlen3$A, stochastic = TRUE)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

elasticity3(cypmatrix2r$A)

</code></pre>

<hr>
<h2 id='elasticity3.matrix'>Estimate Elasticity of Population Growth Rate of a Single Matrix</h2><span id='topic+elasticity3.matrix'></span>

<h3>Description</h3>

<p><code>elasticity3.matrix()</code> returns the elasticities of lambda to elements
of a single matrix.  Because this handles only one matrix, the elasticities
are inherently deterministic and based on the dominant eigen value as the
best metric of the population growth rate. This function can handle large and
sparse matrices, and so can be used with large historical matrices, IPMs,
age x stage matrices, as well as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
elasticity3(mats, sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity3.matrix_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="elasticity3.matrix_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="elasticity3.matrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a single elasticity matrix.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>The <code>force_sparse</code> argument is now deprecated. Please use <code>sparse</code>
instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity3">elasticity3</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.lefkoMat">elasticity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.list">elasticity3.list</a>()</code>
</p>
<p><code><a href="#topic+elasticity3.dgCMatrix">elasticity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoElas">summary.lefkoElas</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
elasticity3(ehrlen3mean$A[[1]])

</code></pre>

<hr>
<h2 id='f_projection3'>Project Function-based Matrix Projection Model</h2><span id='topic+f_projection3'></span>

<h3>Description</h3>

<p>Function <code>f_projection3()</code> develops and projects function-based matrix
models. Unlike <code><a href="#topic+projection3">projection3</a>()</code>, which uses matrices provided as
input via already created <code>lefkoMat</code> objects, function
<code>f_projection3()</code> creates matrices at each time step from vital rate
models and parameter inputs provided. Projections may be stochastic or not,
and may be density dependent in either case. Also handles replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_projection3(
  format,
  prebreeding = TRUE,
  start_age = NA_integer_,
  last_age = NA_integer_,
  fecage_min = NA_integer_,
  fecage_max = NA_integer_,
  cont = TRUE,
  stochastic = FALSE,
  standardize = FALSE,
  growthonly = TRUE,
  repvalue = FALSE,
  integeronly = FALSE,
  substoch = 0L,
  ipm_cdf = TRUE,
  nreps = 1L,
  times = 10000L,
  repmod = 1,
  exp_tol = 700,
  theta_tol = 1e+08,
  random_inda = FALSE,
  random_indb = FALSE,
  random_indc = FALSE,
  err_check = FALSE,
  quiet = FALSE,
  data = NULL,
  stageframe = NULL,
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  modelsuite = NULL,
  paramnames = NULL,
  year = NULL,
  patch = NULL,
  sp_density = NULL,
  ind_terms = NULL,
  dev_terms = NULL,
  surv_model = NULL,
  obs_model = NULL,
  size_model = NULL,
  sizeb_model = NULL,
  sizec_model = NULL,
  repst_model = NULL,
  fec_model = NULL,
  jsurv_model = NULL,
  jobs_model = NULL,
  jsize_model = NULL,
  jsizeb_model = NULL,
  jsizec_model = NULL,
  jrepst_model = NULL,
  jmatst_model = NULL,
  start_vec = NULL,
  start_frame = NULL,
  tweights = NULL,
  density = NULL,
  density_vr = NULL,
  sparse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_projection3_+3A_format">format</code></td>
<td>
<p>An integer indicating the kind of function-based MPM to create.
Possible choices include: <code>1</code>, Ehrlen-format historical MPM; <code>2</code>,
deVries-format historical MPM; <code>3</code>, ahistorical MPM; <code>4</code>,
age-by-stage MPM; and <code>5</code>, Leslie (age-based) MPM.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Only used in Leslie and age-by-stage MPMs. Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_start_age">start_age</code></td>
<td>
<p>The age from which to start the matrix. Defaults to
<code>NA</code>, in which case age <code>1</code> is used if <code>prebreeding = TRUE</code>,
and age <code>0</code> is used if <code>prebreeding = FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_last_age">last_age</code></td>
<td>
<p>The final age to use in the matrix. Defaults to <code>NA</code>, in
which case the highest age in the dataset is used.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_fecage_min">fecage_min</code></td>
<td>
<p>The minimum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
starting in the minimum age observed in the dataset.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_fecage_max">fecage_max</code></td>
<td>
<p>The maximum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
until the final observed age.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_cont">cont</code></td>
<td>
<p>A logical value designating whether to allow continued survival
of individuals past the final age noted in the stageframe, using the 
demographic characteristics of the final age. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value denoting whether to conduct a stochastic
projection or a deterministic / cyclical projection.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_standardize">standardize</code></td>
<td>
<p>A logical value denoting whether to re-standardize the
population size to <code>1.0</code> at each occasion. Used in density-independent
simulations in which it is more important to know the general trend in
population growth than the explicit growth rate. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_growthonly">growthonly</code></td>
<td>
<p>A logical value indicating whether to produce only the
projected population size at each occasion (<code>TRUE</code>), or also to produce
vectors showing the stage distribution at each occasion (<code>FALSE</code>).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_repvalue">repvalue</code></td>
<td>
<p>A logical value indicating whether to calculate reproductive
value vectors at each time step. Can only be set to <code>TRUE</code> if 
<code>growthonly = FALSE</code>. Setting to <code>TRUE</code> may dramatically increase
the duration of calculations. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_integeronly">integeronly</code></td>
<td>
<p>A logical value indicating whether to round the number of
individuals projected in each stage at each occasion to the nearest
integer. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating whether to force survival-
transition matrices to be substochastic in density dependent and density
independent simulations. Defaults to <code>0</code>, which does not enforce
substochasticity. Alternatively, <code>1</code> forces all survival-transition
elements to range from 0.0 to 1.0, and forces fecundity to be non-negative;
and <code>2</code> forces all column rows in the survival-transition matrices to
total no more than 1.0, in addition to the actions outlined for option
<code>1</code>. Both settings <code>1</code> and <code>2</code> change negative fecundity
elements to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_ipm_cdf">ipm_cdf</code></td>
<td>
<p>A logical value indicating whether to estimate size
transitions using the cumulative density function in cases with continuous
distributions. Defaults to <code>TRUE</code>, with the midpoint method used if
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_nreps">nreps</code></td>
<td>
<p>The number of replicate projections. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_times">times</code></td>
<td>
<p>Number of occasions to iterate per replicate. Defaults to
<code>10000</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_repmod">repmod</code></td>
<td>
<p>A scalar multiplier of fecundity. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta as
used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_random_inda">random_inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_random_indb">random_indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_random_indc">random_indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra output
for debugging purposes. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_quiet">quiet</code></td>
<td>
<p>A logical value indicating whether warning messages should be
suppressed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_data">data</code></td>
<td>
<p>The historical vertical demographic data frame used to estimate
vital rates (class <code>hfvdata</code>), which is required to initialize times and
patches properly. Variable names should correspond to the naming conventions
in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and <code><a href="#topic+historicalize3">historicalize3</a>()</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_stageframe">stageframe</code></td>
<td>
<p>An object of class <code>stageframe</code>. These objects are
generated by function <code><a href="#topic+sf_create">sf_create</a>()</code>, and include information on
the size, observation status, propagule status, reproduction status,
immaturity status, maturity status, stage group, size bin widths, and other
key characteristics of each ahistorical stage. Required for all MPM formats
except Leslie MPMs.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of <code>0</code>s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with <code>1</code> equaling full fecundity). If left
blank, and no <code>supplement</code> is provided, then <code>flefko3()</code> will
assume that all stages marked as reproductive produce offspring at 1x that of
estimated fecundity, and that offspring production will yield the first stage
noted as propagule or immature. May be the dimensions of either a historical
or an ahistorical matrix. If the latter, then all stages will be used in
occasion <em>t</em>-1 for each suggested ahistorical transition.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_modelsuite">modelsuite</code></td>
<td>
<p>A <code>lefkoMod</code> object, at minimum with all required
best-fit vital rate models and a <code>paramnames</code> data frame, and following
the naming conventions used in this package. If given, then
<code>surv_model</code>, <code>obs_model</code>, <code>size_model</code>, <code>sizeb_model</code>,
<code>sizec_model</code>, <code>repst_model</code>, <code>fec_model</code>, <code>jsurv_model</code>,
<code>jobs_model</code>, <code>jsize_model</code>, <code>jsizeb_model</code>,
<code>jsizec_model</code>, <code>jrepst_model</code>, <code>jmatst_model</code>,
<code>paramnames</code>, <code>yearcol</code>, and <code>patchcol</code> are not required.
Although this is optional input, it is recommended, and without it separate
vital rate model inputs (named <code>XX_model</code>) are required.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required if <code>modelsuite</code> is not supplied.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_year">year</code></td>
<td>
<p>Either a single integer value corresponding to the year to
project, or a vector of <code>times</code> elements with the year to use at each
time step. Defaults to <code>NA</code>, in which the first year in the set of years
in the dataset is projected. If a vector shorter than <code>times</code> is
supplied, then this vector will be cycled.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_patch">patch</code></td>
<td>
<p>A value of <code>NA</code>, a single string value corresponding to the
patch to project, or a vector of <code>times</code> elements with the patch to use
at each time step. If a vector shorter than <code>times</code> is supplied, then
this vector will be cycled. Note that this function currently does not
handle multiple projections for different patches in the same run.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_sp_density">sp_density</code></td>
<td>
<p>Either a single numeric value of spatial density to use in
vital rate models in all time steps, or a vector of <code>times</code> elements of
such numeric values. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_ind_terms">ind_terms</code></td>
<td>
<p>An optional data frame with 3 columns and <code>times</code> rows
giving the values of individual covariates a, b, and c, respectively, for
each projected time. Unused terms must be set to <code>0</code> (use of <code>NA</code>
will produce errors.)</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_dev_terms">dev_terms</code></td>
<td>
<p>An optional data frame with 14 columns and <code>times</code>
rows showing the values of the deviation terms to be added to each linear
vital rate. The column order should be: 1: survival, 2: observation, 3:
primary size, 4: secondary size, 5: tertiary size, 6: reproduction, 7:
fecundity, 8: juvenile survival, 9: juvenile observation, 10: juvenile
primary size, 11: juvenile secondary size, 12: juvenile tertiary size, 13:
juvenile reproduction, and 14: juvenile maturity transition.  Unused terms
must be set to <code>0</code> (use of <code>NA</code> will produce errors.)</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_surv_model">surv_model</code></td>
<td>
<p>A linear model predicting survival probability. This can 
be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_obs_model">obs_model</code></td>
<td>
<p>A linear model predicting sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_size_model">size_model</code></td>
<td>
<p>A linear model predicting primary size. This can be a model
of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_sizeb_model">sizeb_model</code></td>
<td>
<p>A linear model predicting secondary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_sizec_model">sizec_model</code></td>
<td>
<p>A linear model predicting tertiary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_repst_model">repst_model</code></td>
<td>
<p>A linear model predicting reproduction probability. This 
can be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_fec_model">fec_model</code></td>
<td>
<p>A linear model predicting fecundity. This can be a model of
class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>, <code>vglm</code>,
<code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing the impacts of
occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jsurv_model">jsurv_model</code></td>
<td>
<p>A linear model predicting juvenile survival probability.
This can be a model of class <code>glm</code> or <code>glmer</code>, and requires a
predicted binomial variable under a logit link. Ignored if <code>modelsuite</code>
is provided. This model must have been developed in a modeling exercise
testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jobs_model">jobs_model</code></td>
<td>
<p>A linear model predicting juvenile sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jsize_model">jsize_model</code></td>
<td>
<p>A linear model predicting juvenile primary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jsizeb_model">jsizeb_model</code></td>
<td>
<p>A linear model predicting juvenile secondary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jsizec_model">jsizec_model</code></td>
<td>
<p>A linear model predicting juvenile tertiary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jrepst_model">jrepst_model</code></td>
<td>
<p>A linear model predicting reproduction probability of a 
mature individual that was immature in time <em>t</em>. This can be a model
of class <code>glm</code> or <code>glmer</code>, and requires a predicted binomial
variable under a logit link. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing the impacts of
occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_jmatst_model">jmatst_model</code></td>
<td>
<p>A linear model predicting maturity probability of an 
individual that was immature in time <em>t</em>. This can be a model of class
<code>glm</code> or <code>glmer</code>, and requires a predicted binomial variable under
a logit link. Ignored if <code>modelsuite</code> is provided. This model must have
been developed in a modeling exercise testing the impacts of occasions
<em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_start_vec">start_vec</code></td>
<td>
<p>An optional numeric vector denoting the starting stage
distribution for the projection. Defaults to a single individual of each
stage.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_start_frame">start_frame</code></td>
<td>
<p>An optional data frame characterizing stages, age-stages,
or stage-pairs that should be set to non-zero values in the starting vector,
and what those values should be. Can only be used with <code>lefkoMat</code>
objects.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a
matrix is input, then a first-order Markovian environment is assumed, in
which the probability of choosing a specific annual matrix depends on which
annual matrix is currently chosen. If a vector is input, then the choice of
annual matrix is assumed to be independent of the current matrix. Defaults
to equal weighting among matrices.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_density">density</code></td>
<td>
<p>An optional data frame describing the matrix elements that
will be subject to density dependence, and the exact kind of density
dependence that they will be subject to. The data frame used should be an
object of class <code>lefkoDens</code>, which is the output from function
<code><a href="#topic+density_input">density_input</a>()</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_density_vr">density_vr</code></td>
<td>
<p>An optional data frame describing density dependence
relationships in vital rates, if such relationships are to be assumed. The
data frame must be of class <code>lefkoDensVR</code>, which is the output from the
function <code><a href="#topic+density_vr">density_vr</a>()</code>.</p>
</td></tr>
<tr><td><code id="f_projection3_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero. Can also be entered as a logical value if forced sparse
(<code>TRUE</code>) or forced dense (<code>FALSE</code>) projection is desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>lefkoProj</code>, which always includes the first
three elements of the following, and also includes the remaining elements
below when a <code>lefkoMat</code> object is used as input:
</p>
<table>
<tr><td><code>projection</code></td>
<td>
<p>A list of lists of matrices showing the total number of
individuals per stage per occasion. The first list corresponds to each
pop-patch followed by each population (this top-level list is a single
element in <code>f_projection3()</code>). The inner list corresponds to
replicates within each pop-patch or population.</p>
</td></tr>
<tr><td><code>stage_dist</code></td>
<td>
<p>A list of lists of the actual stage distribution in each
occasion in each replicate in each pop-patch or population. The list
structure is the same as in <code><a href="#topic+projection3">projection3</a>()</code>.</p>
</td></tr>
<tr><td><code>rep_value</code></td>
<td>
<p>A list of lists of the actual reproductive value in each
occasion in each replicate in each pop-patch or population. The list
structure is the same as in <code><a href="#topic+projection3">projection3</a>()</code>.</p>
</td></tr>
<tr><td><code>pop_size</code></td>
<td>
<p>A list of matrices showing the total population size in each
occasion per replicate (row within matrix) per pop-patch or population
(list element). Only a single pop-patch or population is allowed in
<code>f_projection3()</code>.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame showing the order of populations and patches in
item <code>projection</code>.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>The original stageframe used in the study.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame showing the order of historical stage pairs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing the order of age-stage pairs.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A short data frame indicating the population (always <code>1</code>),
and patch (either the numeric index of the single chosen patch, or <code>1</code>
in all other cases).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>A short vector indicating the number of replicates and the
number of occasions projected per replicate.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>The data frame input under the density option. Only provided
if input by the user.</p>
</td></tr>
<tr><td><code>density_vr</code></td>
<td>
<p>The data frame input under the density_vr option. Only
provided if input by the user.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Population projection can be a very time-consuming activity, and it is most
time-consuming when matrices need to be created at each time step. We have
created this function to work as quickly as possible, but some options will
slow analysis. First, the <code>err_check</code> option should always be set to
<code>FALSE</code>, as the added created output will not only slow the analysis
down but also potentially crash the memory if matrices are large enough.
Second, the <code>repvalue</code> option should be set to <code>FALSE</code> unless
reproductive values are genuinely needed, since this step requires
concurrent backward projection and so in some cases may double total run
time. Finally, if the only needed data is the total population size and
age/stage structure at each time step, then setting <code>growthonly = TRUE</code>
will yield the quickest possible run time.
</p>
<p>Projections with large matrices may take a long time to run. To assess the
likely running time, try using a low number of iterations on a single
replicate first. For example, set <code>nreps = 1</code> and <code>times = 10</code> for
a trial run. If a full run is set and takes too long, press the STOP button
in RStudio to cancel the projection run, or click <code>esc</code>.
</p>
<p>This function currently allows three forms of density dependence. The first
modifies matrix elements on the basis of the input provided in option
<code>density</code>, and so alters matrix elements once the matrix has already
been created. The second form alters the vital rates estimated, and so
estimates matrix elements using vital rate values already modified by
density. This second form uses the input provided in option
<code>density_vr</code>. These two forms of density dependence utilize the
projected population size at some time to make these alterations. The third
form of density dependence also alters the vital rates, but using spatial
density supplied via option <code>sp_density</code> and only in vital rates in
which spatial density is included as a fixed factor in the associated
vital rate model.
</p>
<p>When running density dependent simulations involving user-set exponents,
such as the beta term in the Ricker function and both the alpha and beta
terms in the Usher function, values above or below the computer limits may
cause unpredictable behavior. Noted odd behavior includes sudden shifts in
population size to negative values. This function produces warnings when
such values are used, and the values used for warnings may be reset with the
<code>exp_tol</code> term. In addition, this function resets beta values for the
Ricker function automatically to positive or negative <code>exp_tol</code>, giving
a warning when doing so.
</p>
<p>Consistently positive population growth can quickly lead to population size
numbers larger than can be handled computationally. In that circumstance, a
continuously rising population size will suddenly become <code>NaN</code> for the
remainder of the projection.
</p>
<p>This function does not reduce the dimensionality of matrices developed for
projection.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>Some issues may arise in first-order Markovian stochastic projections if
the <code>year</code> argument is used. Use the matrix input in the
<code>tweights</code> argument to eliminate any years from consideration that are
not needed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_input">start_input</a>()</code>
</p>
<p><code><a href="#topic+density_input">density_input</a>()</code>
</p>
<p><code><a href="#topic+density_vr">density_vr</a>()</code>
</p>
<p><code><a href="#topic+projection3">projection3</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+append_lP">append_lP</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoProj">summary.lefkoProj</a>()</code>
</p>
<p><code><a href="#topic+plot.lefkoProj">plot.lefkoProj</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(patchid), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid) +
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid),
  data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[13] &lt;- "sizea1"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[19] &lt;- "repstatus1"

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "Sdl", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "Sd", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  eststage1 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframeln, historical = TRUE)

# While we do not use MPMs to initialize f_projections3(), we do use MPMs to
# initialize functions start_input() and density_input().
lathmat3ln &lt;- flefko3(year = "all", patch = "all", data = lathvertln,
  stageframe = lathframeln, supplement = lathsupp3, paramnames = mod_params,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model, reduce = FALSE)

e3m_sv &lt;- start_input(lathmat3ln, stage2 = "Sd", stage1 = "Sd", value = 1000)

dyn7 &lt;- c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
  FALSE, FALSE, FALSE, FALSE, FALSE)
dst7 &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
dal7 &lt;- c(0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
dbe7 &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

e3d_vr &lt;- density_vr(density_yn = dyn7, style = dst7, alpha = dal7,
  beta = dbe7)

trial7_dvr_1 &lt;- f_projection3(format = 1, data = lathvertln, supplement = lathsupp3,
  paramnames = mod_params, stageframe = lathframeln, nreps = 2,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model,
  times = 100, stochastic = TRUE, standardize = FALSE, growthonly = TRUE,
  integeronly = FALSE, substoch = 0, sp_density = 0, start_frame = e3m_sv,
  density_vr = e3d_vr)


</code></pre>

<hr>
<h2 id='flefko2'>Create Function-based Ahistorical Matrix Projection Model</h2><span id='topic+flefko2'></span>

<h3>Description</h3>

<p>Function <code>flefko2()</code> returns ahistorical MPMs corresponding to the
patches and occasions given, including the associated component transition
and fecundity matrices, a data frame detailing the characteristics of the
ahistorical stages used, and a data frame characterizing the patch and
occasion combinations corresponding to these matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flefko2(
  year = "all",
  patch = "all",
  stageframe,
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  data = NULL,
  modelsuite = NULL,
  surv_model = NULL,
  obs_model = NULL,
  size_model = NULL,
  sizeb_model = NULL,
  sizec_model = NULL,
  repst_model = NULL,
  fec_model = NULL,
  jsurv_model = NULL,
  jobs_model = NULL,
  jsize_model = NULL,
  jsizeb_model = NULL,
  jsizec_model = NULL,
  jrepst_model = NULL,
  jmatst_model = NULL,
  paramnames = NULL,
  inda = NULL,
  indb = NULL,
  indc = NULL,
  surv_dev = 0,
  obs_dev = 0,
  size_dev = 0,
  sizeb_dev = 0,
  sizec_dev = 0,
  repst_dev = 0,
  fec_dev = 0,
  jsurv_dev = 0,
  jobs_dev = 0,
  jsize_dev = 0,
  jsizeb_dev = 0,
  jsizec_dev = 0,
  jrepst_dev = 0,
  jmatst_dev = 0,
  density = NA,
  fecmod = 1,
  random.inda = FALSE,
  random.indb = FALSE,
  random.indc = FALSE,
  negfec = FALSE,
  ipm_method = "CDF",
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  exp_tol = 700,
  theta_tol = 1e+08,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flefko2_+3A_year">year</code></td>
<td>
<p>A variable corresponding to the observation occasion, or a set
of such values, given in values associated with the year term used in linear 
model development. Defaults to <code>"all"</code>, in which case matrices will be
estimated for all occasions.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Defaults to <code>"all"</code>, but can also be set to specific
patch names or a vector thereof.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_stageframe">stageframe</code></td>
<td>
<p>An object of class <code>stageframe</code>. These objects are
generated by function <code><a href="#topic+sf_create">sf_create</a>()</code>, and include information on
the size, observation status, propagule status, reproduction status,
immaturity status, maturity status, stage group, size bin widths, and other
key characteristics of each ahistorical stage.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="flefko2_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of <code>0</code>s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with <code>1</code> equaling full fecundity). If left
blank, and no <code>supplement</code> is provided, then <code>flefko2()</code> will
assume that all stages marked as reproductive produce offspring at 1x that of
estimated fecundity, and that offspring production will yield the first stage
noted as propagule or immature. Must be the dimensions of an ahistorical
matrix.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_data">data</code></td>
<td>
<p>The historical vertical demographic data frame used to estimate
vital rates (class <code>hfvdata</code>), which is required to initialize times and
patches properly. Variable names should correspond to the naming conventions
in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and <code><a href="#topic+historicalize3">historicalize3</a>()</code>. Not
required if option <code>modelsuite</code> is set to a <code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_modelsuite">modelsuite</code></td>
<td>
<p>One of two kinds of lists. The first is a <code>lefkoMod</code>
object holding the vital rate models and associated metadata. Alternatively,
an object of class <code>vrm_input</code> may be provided. If given, then
<code>surv_model</code>, <code>obs_model</code>, <code>size_model</code>, <code>sizeb_model</code>,
<code>sizec_model</code>, <code>repst_model</code>, <code>fec_model</code>, <code>jsurv_model</code>,
<code>jobs_model</code>, <code>jsize_model</code>, <code>jsizeb_model</code>,
<code>jsizec_model</code>, <code>jrepst_model</code>, <code>jmatst_model</code>, and
<code>paramnames</code> are not required. No models should include size or
reproductive status in occasion <em>t</em>-1. Although this is optional input,
it is recommended, and without it all vital rate model inputs (named
<code>XX_model</code>) are required.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_surv_model">surv_model</code></td>
<td>
<p>A linear model predicting survival probability. This can 
be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_obs_model">obs_model</code></td>
<td>
<p>A linear model predicting sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_size_model">size_model</code></td>
<td>
<p>A linear model predicting primary size. This can be a model
of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_sizeb_model">sizeb_model</code></td>
<td>
<p>A linear model predicting secondary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_sizec_model">sizec_model</code></td>
<td>
<p>A linear model predicting tertiary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_repst_model">repst_model</code></td>
<td>
<p>A linear model predicting reproduction probability. This 
can be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_fec_model">fec_model</code></td>
<td>
<p>A linear model predicting fecundity. This can be a model of
class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>, <code>vglm</code>,
<code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing only the
impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsurv_model">jsurv_model</code></td>
<td>
<p>A linear model predicting juvenile survival probability.
This can be a model of class <code>glm</code> or <code>glmer</code>, and requires a
predicted binomial variable under a logit link. Ignored if <code>modelsuite</code>
is provided. This model must have been developed in a modeling exercise
testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jobs_model">jobs_model</code></td>
<td>
<p>A linear model predicting juvenile sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsize_model">jsize_model</code></td>
<td>
<p>A linear model predicting juvenile primary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsizeb_model">jsizeb_model</code></td>
<td>
<p>A linear model predicting juvenile secondary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsizec_model">jsizec_model</code></td>
<td>
<p>A linear model predicting juvenile tertiary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jrepst_model">jrepst_model</code></td>
<td>
<p>A linear model predicting reproduction probability of a 
mature individual that was immature in time <em>t</em>. This can be a model
of class <code>glm</code> or <code>glmer</code>, and requires a predicted binomial
variable under a logit link. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing only the
impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jmatst_model">jmatst_model</code></td>
<td>
<p>A linear model predicting maturity probability of an 
individual that was immature in time <em>t</em>. This can be a model of class
<code>glm</code> or <code>glmer</code>, and requires a predicted binomial variable under
a logit link. Ignored if <code>modelsuite</code> is provided. This model must have
been developed in a modeling exercise testing only the impacts of occasion
<em>t</em>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required if <code>modelsuite</code> is not supplied.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_inda">inda</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>a</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_indb">indb</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>b</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_indc">indc</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>c</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_surv_dev">surv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_obs_dev">obs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_size_dev">size_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_sizeb_dev">sizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_sizec_dev">sizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_repst_dev">repst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for probability of reproduction. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_fec_dev">fec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for fecundity. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsurv_dev">jsurv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jobs_dev">jobs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsize_dev">jsize_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsizeb_dev">jsizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jsizec_dev">jsizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jrepst_dev">jrepst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile reproduction probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_jmatst_dev">jmatst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile maturity probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_density">density</code></td>
<td>
<p>A numeric value indicating density value to use to propagate
matrices. Only needed if density is an explanatory term used in one or more
vital rate models. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier of fecundity. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_random.inda">random.inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_random.indb">random.indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_random.indc">random.indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_negfec">negfec</code></td>
<td>
<p>A logical value denoting whether fecundity values estimated to
be negative should be reset to <code>0</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_ipm_method">ipm_method</code></td>
<td>
<p>A string indicating what method to use to estimate size
transition probabilities, if size is treated as continuous. Options include:
<code>"midpoint"</code>, which utilizes the midpoint method; and <code>"CDF"</code>,
which uses the cumulative distribution function. Defaults to <code>"CDF"</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove ahistorical stages
associated solely with <code>0</code> transitions. These are only removed in cases
where the associated row and column sums in ALL matrices estimated equal 0. 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta as
used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.</p>
</td></tr>
<tr><td><code id="flefko2_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. The structure has the following
elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasion times. All matrices output in R's <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Set to <code>NA</code> for ahistorical
matrices.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. In this function, it
is set to <code>NA</code>. Only used in output to function <code>aflefko2</code>().</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each
matrix in order. In <code>flefko2()</code>, only one population may be analyzed at
once.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input.</p>
</td></tr>
<tr><td><code>prob_out</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a list of vital rate probability matrices, with 7 columns in the
order of survival, observation probability, reproduction probability, primary
size transition probability, secondary size transition probability, tertiary
size transition probability, and probability of juvenile transition to
maturity.</p>
</td></tr>
<tr><td><code>allstages</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a data frame giving the values used to determine each matrix element
capable of being estimated.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Unlike <code><a href="#topic+rlefko2">rlefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>,
<code><a href="#topic+arlefko2">arlefko2</a>()</code>, and <code><a href="#topic+rleslie">rleslie</a>()</code>, this function does not
currently distinguish populations. Users wishing to use the same vital rate
models across populations should label them as patches (though we do not
advise this approach, as populations should typically be treated as
statistically independent).
</p>
<p>This function will yield incorrect estimates if the models utilized
incorporate state in occasion <em>t</em>-1. Only use models developed testing
for ahistorical effects.
</p>
<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to <code>0</code>, then only fecundity transitions noted in
the <code>supplement</code> will be set to non-zero values. To use the default
behavior of setting all reproductive stages to reproduce at full fecundity
into immature and propagule stages, but also incorporate given or proxy
survival transitions, input those given and proxy transitions through the
<code>overwrite</code> option.
</p>
<p>The reproduction matrix (field <code>repmatrix</code>) may only be supplied as
ahistorical. If provided as historical, then <code>flefko2()</code> will fail and
produce an error.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations, but without discriminating between those
patches or subpopulations. Should the aim of analysis be a general MPM that
does not distinguish these patches or subpopulations, the
<code>modelsearch()</code> run should not include patch terms.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order will
lead to erroneous calculations, and may lead to fatal errors.
</p>
<p>Care should be taken to match the random status of year and patch to the
states of those variables within the <code>modelsuite</code>. If they do not match,
then they will be treated as zeroes in vital rate estimation.
</p>
<p>The <code>ipm_method</code> function gives the option of using two different means
of estimating the probability of size transition. The midpoint method
(<code>"midpoint"</code>) refers to the method in which the probability is
estimated by first estimating the probability associated with transition from
the exact size at the midpoint of the size class using the corresponding
probability density function, and then multiplying that value by the bin
width of the size class. Doak et al. 2021 (Ecological Monographs) noted that
this method can produce biased results, with total size transitions
associated with a specific size not totaling to 1.0 and even specific size
transition probabilities capable of being estimated at values greater than
1.0. The alternative and default method, <code>"CDF"</code>, uses the corresponding
cumulative density function to estimate the probability of size transition as
the cumulative probability of size transition at the greater limit of the
size class minus the cumulative probability of size transition at the lower
limit of the size class. The latter method avoids this bias. Note, however,
that both methods are exact and unbiased for negative binomial and Poisson
distributions.
</p>
<p>Under the Gaussian and gamma size distributions, the number of estimated
parameters may differ between the two <code>ipm_method</code> settings. Because
the midpoint method has a tendency to incorporate upward bias in the
estimation of size transition probabilities, it is more likely to yield non-
zero values when the true probability is extremely close to 0. This will
result in the <code>summary.lefkoMat</code> function yielding higher numbers of
estimated parameters than the <code>ipm_method = "CDF"</code> yields in some cases.
</p>
<p>Using the <code>err_check</code> option will produce a matrix of 7 columns, each
characterizing a different vital rate. The product of each row yields an
element in the associated <code>U</code> matrix. The number and order of elements
in each column of this matrix matches the associated matrix in column vector
format. Use of this option is generally for the purposes of debugging code.
</p>
<p>Individual covariates are treated as categorical only if they are set as
random terms. Fixed categorical individual covariates are currently not
allowed. However, such terms may be supplied if the <code>modelsuite</code> option
is set to a <code>vrm_input</code> object. In that case, the user should also set
the logical random switch for the individual covariate to be used to 
<code>TRUE</code> (e.g., <code>random.inda = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr", 
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988, 
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln,
  stagesize = "sizea", censorcol = "Missing1988", censorkeep = NA,
  NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ sizea2 + as.factor(patchid),
  data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(patchid), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + repstatus2 + as.factor(patchid) + 
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + as.factor(patchid) + as.factor(year2),
  data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + as.factor(patchid) + as.factor(year2),
  data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[18] &lt;- "repstatus2"

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "rep", "rep"),
  givenrate = c(0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, 0.345, 0.054),
  type = c(1, 1, 3, 3), stageframe = lathframeln, historical = FALSE)

lathmat2ln &lt;- flefko2(year = "all", patch = "all", data = lathvertln,
  stageframe = lathframeln, supplement = lathsupp2, paramnames = mod_params,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model, reduce = FALSE)


# Cypripedium example using three size metrics for classification
data(cypdata)

sizevector_f &lt;- c(0, 0, 0, 0, 0, 0, seq(1, 12, by = 1), seq(0, 9, by = 1),
  seq(0, 8, by = 1), seq(0, 7, by = 1), seq(0, 6, by = 1), seq(0, 5, by = 1),
  seq(0, 4, by = 1), seq(0, 3, by = 1), 0, 1, 2, 0, 1, 0, 
  0, 0, 1, 0)
sizebvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(0, 12), rep(1, 10), rep(2, 9),
  rep(3, 8), rep(4, 7), rep(5, 6), rep(6, 5), rep(7, 4), rep(8, 3), 9, 9, 10, 
  0, 1, 1, 2)
sizecvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(0, 12), rep(0, 10), rep(0, 9),
  rep(0, 8), rep(0, 7), rep(0, 6), rep(0, 5), rep(0, 4), 0, 0, 0, 0, 0, 0, 
  1, 1, 1, 1)
stagevector_f &lt;- c("DS", "P1", "P2", "P3", "Sdl", "Dorm", "V1 I0 D0",
  "V2 I0 D0", "V3 I0 D0", "V4 I0 D0", "V5 I0 D0", "V6 I0 D0", "V7 I0 D0",
  "V8 I0 D0", "V9 I0 D0", "V10 I0 D0", "V11 I0 D0", "V12 I0 D0", "V0 I1 D0",
  "V1 I1 D0", "V2 I1 D0", "V3 I1 D0", "V4 I1 D0", "V5 I1 D0", "V6 I1 D0",
  "V7 I1 D0", "V8 I1 D0", "V9 I1 D0", "V0 I2 D0", "V1 I2 D0", "V2 I2 D0",
  "V3 I2 D0", "V4 I2 D0", "V5 I2 D0", "V6 I2 D0", "V7 I2 D0", "V8 I2 D0",
  "V0 I3 D0", "V1 I3 D0", "V2 I3 D0", "V3 I3 D0", "V4 I3 D0", "V5 I3 D0",
  "V6 I3 D0", "V7 I3 D0", "V0 I4 D0", "V1 I4 D0", "V2 I4 D0", "V3 I4 D0",
  "V4 I4 D0", "V5 I4 D0", "V6 I4 D0", "V0 I5 D0", "V1 I5 D0", "V2 I5 D0",
  "V3 I5 D0", "V4 I5 D0", "V5 I5 D0", "V0 I6 D0", "V1 I6 D0", "V2 I6 D0",
  "V3 I6 D0", "V4 I6 D0", "V0 I7 D0", "V1 I7 D0", "V2 I7 D0", "V3 I7 D0",
  "V0 I8 D0", "V1 I8 D0", "V2 I8 D0", "V0 I9 D0", "V1 I9 D0", "V0 I10 D0",
  "V0 I0 D1", "V0 I1 D1", "V1 I1 D1", "V0 I2 D1")
repvector_f &lt;- c(0, 0, 0, 0, 0, rep(0, 13), rep(1, 59))
obsvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(1, 71))
matvector_f &lt;- c(0, 0, 0, 0, 0, rep(1, 72))
immvector_f &lt;- c(0, 1, 1, 1, 1, rep(0, 72))
propvector_f &lt;- c(1, rep(0, 76))
indataset_f &lt;- c(0, 0, 0, 0, 0, rep(1, 72))
binvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))
binbvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))
bincvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))

vertframe_f &lt;- sf_create(sizes = sizevector_f, sizesb = sizebvector_f,
  sizesc = sizecvector_f, stagenames = stagevector_f, repstatus = repvector_f,
  obsstatus = obsvector_f, propstatus = propvector_f, immstatus = immvector_f,
  matstatus = matvector_f, indataset = indataset_f, binhalfwidth = binvec_f,
  binhalfwidthb = binbvec_f, binhalfwidthc = bincvec_f)

vert_data_f &lt;- verticalize3(cypdata, noyears = 6, firstyear = 2004,
  individcol = "plantid", blocksize = 4, sizeacol = "Veg.04",
  sizebcol = "Inf.04", sizeccol = "Inf2.04", repstracol = "Inf.04",
  repstrbcol = "Inf2.04", fecacol = "Pod.04", censorcol = "censor",
  censorkeep = 1, censorRepeat = FALSE, stageassign = vertframe_f,
  stagesize = "sizeabc", NAas0 = TRUE, censor = FALSE)

surv_model &lt;- glm(alive3 ~ sizea2 + sizeb2, data = vert_data_f,
  family = "binomial")

obs_data &lt;- subset(vert_data_f, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ sizeb2 + as.factor(year2), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- MASS::glm.nb(sizea3 ~ sizea2 + sizeb2 + as.factor(year2),
  data = size_data)
sizb_model &lt;- glm(sizeb3 ~ sizea2 + sizeb2 + repstatus2 + as.factor(year2),
  data = size_data, family = "poisson")
sizc_model &lt;- glm(sizec3 ~ repstatus2, data = size_data, family = "poisson")

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizeb2 + repstatus2 + as.factor(year2),
  data = size_data, family = "binomial")

fec_data &lt;- subset(vert_data_f, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizeb2 + as.factor(year2), data = fec_data,
  family = "poisson")

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[18] &lt;- "repstatus2"

vertsupp2f &lt;- supplemental(stage3 = c("DS", "P1", "P2", "P3", "Sdl", "Sdl",
    "Dorm", "V1 I0 D0", "V2 I0 D0", "V3 I0 D0", "DS", "P1"),
  stage2 = c("DS", "DS", "P1", "P2", "P3", "Sdl", "Sdl", "Sdl", "Sdl", "Sdl",
    "rep", "rep"), 
  eststage3 = c(NA, NA, NA, NA, NA, NA, "Dorm", "V1 I0 D0", "V2 I0 D0",
    "V3 I0 D0", NA, NA), 
  eststage2 = c(NA, NA, NA, NA, NA, NA, "V1 I0 D0", "V1 I0 D0", "V1 I0 D0",
    "V1 I0 D0", NA, NA), 
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, 0.40, NA, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0.5 * 5000,
    0.5 * 5000),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3), stageframe = vertframe_f,
  historical = FALSE)

vert_mats_f2 &lt;- flefko2(stageframe = vertframe_f, supplement = vertsupp2f,
  data = vert_data_f, surv_model = surv_model, obs_model = obs_model,
  size_model = siz_model, sizeb_model = sizb_model, sizec_model = sizc_model,
  repst_model = reps_model, fec_model = fec_model, paramnames = mod_params)

</code></pre>

<hr>
<h2 id='flefko3'>Create Function-based Historical Matrix Projection Model</h2><span id='topic+flefko3'></span>

<h3>Description</h3>

<p>Function <code>flefko3()</code> returns function-based historical MPMs
corresponding to the patches and occasions given, including the associated
component transition and fecundity matrices, data frames detailing the
characteristics of the ahistorical stages used and historical stage pairs
created, and a data frame characterizing the patch and occasion combinations
corresponding to these matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flefko3(
  year = "all",
  patch = "all",
  stageframe,
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  data = NULL,
  modelsuite = NULL,
  surv_model = NULL,
  obs_model = NULL,
  size_model = NULL,
  sizeb_model = NULL,
  sizec_model = NULL,
  repst_model = NULL,
  fec_model = NULL,
  jsurv_model = NULL,
  jobs_model = NULL,
  jsize_model = NULL,
  jsizeb_model = NULL,
  jsizec_model = NULL,
  jrepst_model = NULL,
  jmatst_model = NULL,
  paramnames = NULL,
  inda = NULL,
  indb = NULL,
  indc = NULL,
  surv_dev = 0,
  obs_dev = 0,
  size_dev = 0,
  sizeb_dev = 0,
  sizec_dev = 0,
  repst_dev = 0,
  fec_dev = 0,
  jsurv_dev = 0,
  jobs_dev = 0,
  jsize_dev = 0,
  jsizeb_dev = 0,
  jsizec_dev = 0,
  jrepst_dev = 0,
  jmatst_dev = 0,
  density = NA,
  fecmod = 1,
  random.inda = FALSE,
  random.indb = FALSE,
  random.indc = FALSE,
  negfec = FALSE,
  format = "ehrlen",
  ipm_method = "CDF",
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  exp_tol = 700,
  theta_tol = 1e+08,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flefko3_+3A_year">year</code></td>
<td>
<p>A variable corresponding to the observation occasion, or a set
of such values, given in values associated with the year term used in linear 
model development. Defaults to <code>"all"</code>, in which case matrices will be
estimated for all occasions.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Defaults to <code>"all"</code>, but can also be set to specific
patch names or a vector thereof.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_stageframe">stageframe</code></td>
<td>
<p>An object of class <code>stageframe</code>. These objects are
generated by function <code><a href="#topic+sf_create">sf_create</a>()</code>, and include information on
the size, observation status, propagule status, reproduction status,
immaturity status, maturity status, stage group, size bin widths, and other
key characteristics of each ahistorical stage.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="flefko3_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of <code>0</code>s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with <code>1</code> equaling full fecundity). If left
blank, and no <code>supplement</code> is provided, then <code>flefko3()</code> will
assume that all stages marked as reproductive produce offspring at 1x that of
estimated fecundity, and that offspring production will yield the first stage
noted as propagule or immature. May be the dimensions of either a historical
or an ahistorical matrix. If the latter, then all stages will be used in
occasion <em>t</em>-1 for each suggested ahistorical transition.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_data">data</code></td>
<td>
<p>The historical vertical demographic data frame used to estimate
vital rates (class <code>hfvdata</code>), which is required to initialize times and
patches properly. Variable names should correspond to the naming conventions
in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and <code><a href="#topic+historicalize3">historicalize3</a>()</code>. Not
required if option <code>modelsuite</code> is set to a <code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_modelsuite">modelsuite</code></td>
<td>
<p>One of two kinds of lists. The first is a <code>lefkoMod</code>
object holding the vital rate models and associated metadata. Alternatively,
an object of class <code>vrm_input</code> may be provided. If given, then
<code>surv_model</code>, <code>obs_model</code>, <code>size_model</code>, <code>sizeb_model</code>,
<code>sizec_model</code>, <code>repst_model</code>, <code>fec_model</code>, <code>jsurv_model</code>,
<code>jobs_model</code>, <code>jsize_model</code>, <code>jsizeb_model</code>,
<code>jsizec_model</code>, <code>jrepst_model</code>, <code>jmatst_model</code>, and
<code>paramnames</code> are not required. One or more of these models should
include size or reproductive status in occasion <em>t</em>-1. Although this is
optional input, it is recommended, and without it all vital rate model inputs
(named <code>XX_model</code>) are required.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_surv_model">surv_model</code></td>
<td>
<p>A linear model predicting survival probability. This can 
be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_obs_model">obs_model</code></td>
<td>
<p>A linear model predicting sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_size_model">size_model</code></td>
<td>
<p>A linear model predicting primary size. This can be a model
of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_sizeb_model">sizeb_model</code></td>
<td>
<p>A linear model predicting secondary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_sizec_model">sizec_model</code></td>
<td>
<p>A linear model predicting tertiary size. This can be a
model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_repst_model">repst_model</code></td>
<td>
<p>A linear model predicting reproduction probability. This 
can be a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_fec_model">fec_model</code></td>
<td>
<p>A linear model predicting fecundity. This can be a model of
class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>, <code>vglm</code>,
<code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing the impacts of
occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsurv_model">jsurv_model</code></td>
<td>
<p>A linear model predicting juvenile survival probability.
This can be a model of class <code>glm</code> or <code>glmer</code>, and requires a
predicted binomial variable under a logit link. Ignored if <code>modelsuite</code>
is provided. This model must have been developed in a modeling exercise
testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jobs_model">jobs_model</code></td>
<td>
<p>A linear model predicting juvenile sprouting or observation
probability. This can be a model of class <code>glm</code> or <code>glmer</code>, and
requires a predicted binomial variable under a logit link. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsize_model">jsize_model</code></td>
<td>
<p>A linear model predicting juvenile primary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsizeb_model">jsizeb_model</code></td>
<td>
<p>A linear model predicting juvenile secondary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsizec_model">jsizec_model</code></td>
<td>
<p>A linear model predicting juvenile tertiary size. This
can be a model of class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>,
<code>zeroinfl</code>, <code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if
<code>modelsuite</code> is provided. This model must have been developed in a
modeling exercise testing the impacts of occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jrepst_model">jrepst_model</code></td>
<td>
<p>A linear model predicting reproduction probability of a 
mature individual that was immature in time <em>t</em>. This can be a model
of class <code>glm</code> or <code>glmer</code>, and requires a predicted binomial
variable under a logit link. Ignored if <code>modelsuite</code> is provided. This
model must have been developed in a modeling exercise testing the impacts of
occasions <em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jmatst_model">jmatst_model</code></td>
<td>
<p>A linear model predicting maturity probability of an 
individual that was immature in time <em>t</em>. This can be a model of class
<code>glm</code> or <code>glmer</code>, and requires a predicted binomial variable under
a logit link. Ignored if <code>modelsuite</code> is provided. This model must have
been developed in a modeling exercise testing the impacts of occasions
<em>t</em> and <em>t</em>-1.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required if <code>modelsuite</code> is not supplied.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_inda">inda</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>a</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_indb">indb</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>b</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_indc">indc</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>c</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1 in
historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_surv_dev">surv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_obs_dev">obs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_size_dev">size_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_sizeb_dev">sizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_sizec_dev">sizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_repst_dev">repst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for probability of reproduction. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_fec_dev">fec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for fecundity. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsurv_dev">jsurv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jobs_dev">jobs_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile observation probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsize_dev">jsize_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for juvenile primary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsizeb_dev">jsizeb_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile secondary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jsizec_dev">jsizec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile tertiary size. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jrepst_dev">jrepst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile reproduction probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_jmatst_dev">jmatst_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the
linear model for juvenile maturity probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_density">density</code></td>
<td>
<p>A numeric value indicating density value to use to propagate
matrices. Only needed if density is an explanatory term used in one or more
vital rate models. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier of fecundity. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_random.inda">random.inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_random.indb">random.indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_random.indc">random.indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_negfec">negfec</code></td>
<td>
<p>A logical value denoting whether fecundity values estimated to
be negative should be reset to <code>0</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_format">format</code></td>
<td>
<p>A string indicating whether to estimate matrices in
<code>ehrlen</code> format or <code>deVries</code> format. The latter adds one extra
prior stage to account for the prior state of newborns. Defaults to
<code>ehrlen</code> format.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_ipm_method">ipm_method</code></td>
<td>
<p>A string indicating what method to use to estimate size
transition probabilities, if size is treated as continuous. Options include:
<code>"midpoint"</code>, which utilizes the midpoint method; and <code>"CDF"</code>,
which uses the cumulative distribution function. Defaults to <code>"CDF"</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove historical stages
associated solely with <code>0</code> transitions. These are only removed in cases
where the associated row and column sums in ALL matrices estimated equal 0. 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta as
used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.</p>
</td></tr>
<tr><td><code id="flefko3_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. The structure has the following
elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasion times. All matrices output in R's <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. In this function, it
is set to <code>NA</code>. Only used in output to function <code>aflefko2</code>().</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each
matrix in order. In <code>flefko3()</code>, only one population may be analyzed at
once.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input.</p>
</td></tr>
<tr><td><code>prob_out</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a list of vital rate probability matrices, with 7 columns in the
order of survival, observation probability, reproduction probability, primary
size transition probability, secondary size transition probability, tertiary
size transition probability, and probability of juvenile transition to
maturity.</p>
</td></tr>
<tr><td><code>allstages</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a data frame giving the values used to determine each matrix element
capable of being estimated.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Unlike <code><a href="#topic+rlefko2">rlefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>,
<code><a href="#topic+arlefko2">arlefko2</a>()</code>, and <code><a href="#topic+rleslie">rleslie</a>()</code>, this function does not
currently distinguish populations. Users wishing to use the same vital rate
models across populations should label them as patches (though we do not
advise this approach, as populations should typically be treated as
statistically independent).
</p>
<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to <code>0</code>, then only fecundity transitions noted in
the <code>supplement</code> will be set to non-zero values. To use the default
behavior of setting all reproductive stages to reproduce at full fecundity
into immature and propagule stages, but also incorporate given or proxy
survival transitions, input those given and proxy transitions through the
<code>overwrite</code> option.
</p>
<p>If used, the reproduction matrix (field <code>repmatrix</code>) may be supplied as
either historical or ahistorical. If provided as ahistorical, then
<code>flefko3()</code> will assume that all historical transitions involving stages
noted for occasions <em>t</em> and <em>t</em>+1 should be set to the respective
fecundity multipliers noted.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations, but without discriminating between those
patches or subpopulations. Should the aim of analysis be a general MPM that
does not distinguish these patches or subpopulations, the
<code>modelsearch()</code> run should not include patch terms.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Rearranging
the order will lead to erroneous calculations, and will may lead to fatal
errors.
</p>
<p>The <code>ipm_method</code> function gives the option of using two different means
of estimating the probability of size transition. The midpoint method
(<code>"midpoint"</code>) refers to the method in which the probability is
estimated by first estimating the probability associated with transition from
the exact size at the midpoint of the size class using the corresponding
probability density function, and then multiplying that value by the bin
width of the size class. Doak et al. 2021 (Ecological Monographs) noted that
this method can produce biased results, with total size transitions
associated with a specific size not totaling to 1.0 and even specific size
transition probabilities capable of being estimated at values greater than
1.0. The alternative and default method, <code>"CDF"</code>, uses the corresponding
cumulative density function to estimate the probability of size transition as
the cumulative probability of size transition at the greater limit of the
size class minus the cumulative probability of size transition at the lower
limit of the size class. This latter method avoids this bias. Note, however,
that both methods are exact and unbiased for negative binomial and Poisson
distributions.
</p>
<p>Under the Gaussian and gamma size distributions, the number of estimated
parameters may differ between the two <code>ipm_method</code> settings. Because
the midpoint method has a tendency to incorporate upward bias in the
estimation of size transition probabilities, it is more likely to yield non-
zero values when the true probability is extremely close to 0. This will
result in the <code>summary.lefkoMat</code> function yielding higher numbers of
estimated parameters than the <code>ipm_method = "CDF"</code> yields in some cases.
</p>
<p>Using the <code>err_check</code> option will produce a matrix of 7 columns, each
characterizing a different vital rate. The product of each row yields an
element in the associated <code>U</code> matrix. The number and order of elements
in each column of this matrix matches the associated matrix in column vector
format. Use of this option is generally for the purposes of debugging code.
'
Individual covariates are treated as categorical only if they are set as
random terms. Fixed categorical individual covariates are currently not
allowed. However, such terms may be supplied if the <code>modelsuite</code> option
is set to a <code>vrm_input</code> object. In that case, the user should also set
the logical random switch for the individual covariate to be used to 
<code>TRUE</code> (e.g., <code>random.inda = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "Sdl", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "Sd", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  eststage1 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframeln, historical = TRUE)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(patchid), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid) +
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid),
  data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[13] &lt;- "sizea1"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[19] &lt;- "repstatus1"

lathmat3ln &lt;- flefko3(year = "all", patch = "all", data = lathvertln,
  stageframe = lathframeln, supplement = lathsupp3, paramnames = mod_params,
  surv_model = surv_model, obs_model = obs_model, size_model = siz_model,
  repst_model = reps_model, fec_model = fec_model, jsurv_model = jsurv_model,
  jobs_model = jobs_model, jsize_model = jsiz_model,
  jrepst_model = jrepst_model, jmatst_model = jmatst_model, reduce = FALSE)


# Cypripedium example using three size metrics for classification
data(cypdata)

sizevector_f &lt;- c(0, 0, 0, 0, 0, 0, seq(1, 12, by = 1), seq(0, 9, by = 1),
  seq(0, 8, by = 1), seq(0, 7, by = 1), seq(0, 6, by = 1), seq(0, 5, by = 1),
  seq(0, 4, by = 1), seq(0, 3, by = 1), 0, 1, 2, 0, 1, 0, 
  0, 0, 1, 0)
sizebvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(0, 12), rep(1, 10), rep(2, 9),
  rep(3, 8), rep(4, 7), rep(5, 6), rep(6, 5), rep(7, 4), rep(8, 3), 9, 9, 10, 
  0, 1, 1, 2)
sizecvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(0, 12), rep(0, 10), rep(0, 9),
  rep(0, 8), rep(0, 7), rep(0, 6), rep(0, 5), rep(0, 4), 0, 0, 0, 0, 0, 0, 
  1, 1, 1, 1)
stagevector_f &lt;- c("DS", "P1", "P2", "P3", "Sdl", "Dorm", "V1 I0 D0",
  "V2 I0 D0", "V3 I0 D0", "V4 I0 D0", "V5 I0 D0", "V6 I0 D0", "V7 I0 D0",
  "V8 I0 D0", "V9 I0 D0", "V10 I0 D0", "V11 I0 D0", "V12 I0 D0", "V0 I1 D0",
  "V1 I1 D0", "V2 I1 D0", "V3 I1 D0", "V4 I1 D0", "V5 I1 D0", "V6 I1 D0",
  "V7 I1 D0", "V8 I1 D0", "V9 I1 D0", "V0 I2 D0", "V1 I2 D0", "V2 I2 D0",
  "V3 I2 D0", "V4 I2 D0", "V5 I2 D0", "V6 I2 D0", "V7 I2 D0", "V8 I2 D0",
  "V0 I3 D0", "V1 I3 D0", "V2 I3 D0", "V3 I3 D0", "V4 I3 D0", "V5 I3 D0",
  "V6 I3 D0", "V7 I3 D0", "V0 I4 D0", "V1 I4 D0", "V2 I4 D0", "V3 I4 D0",
  "V4 I4 D0", "V5 I4 D0", "V6 I4 D0", "V0 I5 D0", "V1 I5 D0", "V2 I5 D0",
  "V3 I5 D0", "V4 I5 D0", "V5 I5 D0", "V0 I6 D0", "V1 I6 D0", "V2 I6 D0",
  "V3 I6 D0", "V4 I6 D0", "V0 I7 D0", "V1 I7 D0", "V2 I7 D0", "V3 I7 D0",
  "V0 I8 D0", "V1 I8 D0", "V2 I8 D0", "V0 I9 D0", "V1 I9 D0", "V0 I10 D0",
  "V0 I0 D1", "V0 I1 D1", "V1 I1 D1", "V0 I2 D1")
repvector_f &lt;- c(0, 0, 0, 0, 0, rep(0, 13), rep(1, 59))
obsvector_f &lt;- c(0, 0, 0, 0, 0, 0, rep(1, 71))
matvector_f &lt;- c(0, 0, 0, 0, 0, rep(1, 72))
immvector_f &lt;- c(0, 1, 1, 1, 1, rep(0, 72))
propvector_f &lt;- c(1, rep(0, 76))
indataset_f &lt;- c(0, 0, 0, 0, 0, rep(1, 72))
binvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))
binbvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))
bincvec_f &lt;- c(0, 0, 0, 0, 0, rep(0.5, 72))

vertframe_f &lt;- sf_create(sizes = sizevector_f, sizesb = sizebvector_f,
  sizesc = sizecvector_f, stagenames = stagevector_f, repstatus = repvector_f,
  obsstatus = obsvector_f, propstatus = propvector_f, immstatus = immvector_f,
  matstatus = matvector_f, indataset = indataset_f, binhalfwidth = binvec_f,
  binhalfwidthb = binbvec_f, binhalfwidthc = bincvec_f)

vert_data_f &lt;- verticalize3(cypdata, noyears = 6, firstyear = 2004,
  individcol = "plantid", blocksize = 4, sizeacol = "Veg.04",
  sizebcol = "Inf.04", sizeccol = "Inf2.04", repstracol = "Inf.04",
  repstrbcol = "Inf2.04", fecacol = "Pod.04", censorcol = "censor",
  censorkeep = 1, censorRepeat = FALSE, stageassign = vertframe_f,
  stagesize = "sizeabc", NAas0 = TRUE, censor = FALSE)

vertsupp3f &lt;- supplemental(stage3 = c("DS", "P1", "DS", "P1", "P2", "P2", "P3",
    "Sdl", "Sdl", "Sdl", "Dorm", "V1 I0 D0", "V2 I0 D0", "V3 I0 D0", "Dorm",
    "V1 I0 D0", "V2 I0 D0", "V3 I0 D0", "mat", "mat", "mat", "mat", "DS", "P1"),
  stage2 = c("DS", "DS", "DS", "DS", "P1", "P1", "P2", "P3", "Sdl", "Sdl", "Sdl",
    "Sdl", "Sdl", "Sdl", "Sdl", "Sdl", "Sdl", "Sdl", "Dorm", "V1 I0 D0",
    "V2 I0 D0", "V3 I0 D0", "rep", "rep"),
  stage1 = c("DS", "DS", "rep", "rep", "DS", "rep", "P1", "P2", "P3", "Sdl",
    "Sdl", "Sdl", "Sdl", "Sdl", "P3", "P3", "P3", "P3", "Sdl", "Sdl", "Sdl",
    "Sdl", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, "Dorm", "V1 I0 D0",
    "V2 I0 D0", "V3 I0 D0", "Dorm", "V1 I0 D0", "V2 I0 D0", "V3 I0 D0", "mat",
    "mat", "mat", "mat", NA, NA), 
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, "V1 I0 D0", "V1 I0 D0",
    "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0",
    "Dorm", "V1 I0 D0", "V2 I0 D0", "V3 I0 D0", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, "V1 I0 D0", "V1 I0 D0",
    "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0",
    "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", "V1 I0 D0", NA, NA),
  givenrate = c(0.10, 0.20, 0.10, 0.20, 0.20, 0.20, 0.20, 0.25, 0.40, 0.40, NA,
    NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, NA, NA, 0.5 * 5000, 0.5 * 5000),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    3, 3),
  type_t12 = c(1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1),
  stageframe = vertframe_f, historical = TRUE)

surv_model &lt;- glm(alive3 ~ sizea2 + sizeb2, data = vert_data_f,
  family = "binomial")

obs_data &lt;- subset(vert_data_f, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ sizeb2 + sizec1 + as.factor(year2),
  data = obs_data, family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- MASS::glm.nb(sizea3 ~ sizea2 + sizea1 + sizeb1, data = size_data)
sizb_model &lt;- glm(sizeb3 ~ sizea2 + sizeb2 + sizec1 + repstatus2 + repstatus1 +
  as.factor(year2), data = size_data, family = "poisson")
sizc_model &lt;- glm(sizec3 ~ sizea1 + repstatus2, data = size_data,
  family = "poisson")

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizeb2 + repstatus2 + as.factor(year2),
  data = size_data, family = "binomial")

fec_data &lt;- subset(vert_data_f, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizeb2 + as.factor(year2), data = fec_data,
  family = "poisson")

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[13] &lt;- "sizea1"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[19] &lt;- "repstatus1"

vert_mats_f3 &lt;- flefko3(stageframe = vertframe_f, supplement = vertsupp3f,
  data = vert_data_f, surv_model = surv_model, obs_model = obs_model,
  size_model = siz_model, sizeb_model = sizb_model, sizec_model = sizc_model,
  repst_model = reps_model, fec_model = fec_model, paramnames = mod_params,
  sparse_output = TRUE)


</code></pre>

<hr>
<h2 id='fleslie'>Create Function-based Age-based (Leslie) Matrix Projection Model</h2><span id='topic+fleslie'></span>

<h3>Description</h3>

<p>Function <code>fleslie()</code> returns age-based (Leslie) MPMs corresponding to
the patches and occasions given, including the associated component
transition and fecundity matrices, data frames detailing the characteristics
of the exact ages corresponding to rows and columns in estimated matrices,
and a data frame characterizing the patch and occasion combinations
corresponding to these matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fleslie(
  year = "all",
  patch = NULL,
  prebreeding = TRUE,
  data = NULL,
  modelsuite = NULL,
  surv_model = NULL,
  fec_model = NULL,
  paramnames = NULL,
  supplement = NULL,
  start_age = NA,
  last_age = NA,
  fecage_min = NA,
  fecage_max = NA,
  continue = TRUE,
  inda = NULL,
  indb = NULL,
  indc = NULL,
  surv_dev = 0,
  fec_dev = 0,
  density = NA,
  fecmod = 1,
  random.inda = FALSE,
  random.indb = FALSE,
  random.indc = FALSE,
  negfec = FALSE,
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  exp_tol = 700,
  theta_tol = 1e+08,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fleslie_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set
of such values, given in values associated with the year term used in linear 
model development. Defaults to <code>"all"</code>, in which case matrices will be
estimated for all occasions.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Defaults to <code>"all"</code>, but can also be set to specific
patch names or a vector thereof.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_data">data</code></td>
<td>
<p>The historical vertical demographic data frame used to estimate
vital rates (class <code>hfvdata</code>). The original data frame is generally
required in order to initialize occasions and patches properly, and to assess
the range of ages observed in the population. Not required if option
<code>modelsuite</code> is set to a <code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_modelsuite">modelsuite</code></td>
<td>
<p>One of two optional lists. THe first is an optional
<code>lefkoMod</code> object holding the vital rate models. Alternatively,
an object of class <code>vrm_input</code> may be provided. If given, then
<code>surv_model</code>, <code>fec_model</code>, and <code>paramnames</code> are not required.
No models should include size or reproductive status in any occasion, nor
should they include any variable for occasion <em>t</em>-1. Note that the
modelsuite must have been created from a <code>modelsearch()</code> run in which
<code>vitalrates = c("surv", "fec")</code> and the <code>suite</code> option was set to
either <code>age</code> or <code>cons</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_surv_model">surv_model</code></td>
<td>
<p>A linear model predicting survival probability. This can be
a model of class <code>glm</code> or <code>glmer</code>, and requires a predicted
binomial variable under a logit link. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_fec_model">fec_model</code></td>
<td>
<p>A linear model predicting fecundity. This can be a model of
class <code>glm</code>, <code>glmer</code>, <code>glmmTMB</code>, <code>zeroinfl</code>,
<code>vglm</code>, <code>lm</code>, or <code>lmer</code>. Ignored if <code>modelsuite</code> is
provided. This model must have been developed in a modeling exercise testing
only the impacts of occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required if <code>modelsuite</code> is not supplied.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_start_age">start_age</code></td>
<td>
<p>The age from which to start the matrix. Defaults to
<code>NA</code>, in which case age <code>1</code> is used if <code>prebreeding = TRUE</code>,
and age <code>0</code> is used if <code>prebreeding = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_last_age">last_age</code></td>
<td>
<p>The final age to use in the matrix. Defaults to <code>NA</code>, in
which case the highest age in the dataset is used.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_fecage_min">fecage_min</code></td>
<td>
<p>The minimum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
starting in the minimum age observed in the dataset.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_fecage_max">fecage_max</code></td>
<td>
<p>The maximum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
until the final observed age.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_continue">continue</code></td>
<td>
<p>A logical value designating whether to allow continued
survival of individuals past the final age noted in the stageframe, using the 
demographic characteristics of the final age. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_inda">inda</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>a</code>
in all matrices, or a vector of such values corresponding to each occasion in
the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_indb">indb</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>b</code>
in all matrices, or a vector of such values corresponding to each occasion in
the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_indc">indc</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>c</code>
in all matrices, or a vector of such values corresponding to each occasion in
the dataset. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_surv_dev">surv_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for survival probability. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_fec_dev">fec_dev</code></td>
<td>
<p>A numeric value to be added to the y-intercept in the linear
model for fecundity. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_density">density</code></td>
<td>
<p>A numeric value indicating density value to use to propagate
matrices. Only needed if density is an explanatory term used in linear
models. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier of fecundity. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_random.inda">random.inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_random.indb">random.indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_random.indc">random.indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated as
a fixed, numeric variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_negfec">negfec</code></td>
<td>
<p>A logical value denoting whether fecundity values estimated to
be negative should be reset to <code>0</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove ages associated
solely with <code>0</code> transitions. These are only removed in cases where the
associated row and column sums in ALL matrices estimated equal 0. Defaults to
<code>FALSE</code>, and should generally not be used in age-based MPMs.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta as
used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.</p>
</td></tr>
<tr><td><code id="fleslie_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. Its structure has the following
elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasions. All matrices output in R's <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>Set to <code>NA</code> for Leslie MPMs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>Set to <code>NA</code> for Leslie MPMs.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ages, in the form of a modified stageframe including reproduction status.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the patch and year of each matrix in order.
In <code>fleslie()</code>, only one population may be analyzed at once.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input.</p>
</td></tr>
<tr><td><code>prob_out</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a list of vital rate probability matrices, with 7 columns in the
order of survival, observation probability, reproduction probability, primary
size transition probability, secondary size transition probability, tertiary
size transition probability, and probability of juvenile transition to
maturity.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Unlike <code><a href="#topic+rlefko2">rlefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>,
<code><a href="#topic+arlefko2">arlefko2</a>()</code>, and <code><a href="#topic+rleslie">rleslie</a>()</code>, this function does not
currently distinguish populations.
</p>
<p>This function will yield incorrect estimates if the models utilized
incorporate state in occasion <em>t</em>-1, or any size or reproductive status
terms.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations, but without discriminating between those
patches or subpopulations. Should the aim of analysis be a general MPM that
does not distinguish these patches or subpopulations, the
<code>modelsearch()</code> run should not include patch terms.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order will
lead to erroneous calculations, and may lead to fatal errors.
</p>
<p>Care should be taken to match the random status of year and patch to the
states of those variables within the modelsuite. If they do not match, then
they will be treated as zeroes in vital rate estimation.
</p>
<p>Individual covariates are treated as categorical only if they are set as
random terms. Fixed categorical individual covariates are currently not
allowed. However, such terms may be supplied if the <code>modelsuite</code> option
is set to a <code>vrm_input</code> object. In that case, the user should also set
the logical random switch for the individual covariate to be used to 
<code>TRUE</code> (e.g., <code>random.inda = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

lathvert_base &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  sizeacol = "Volume88", repstracol = "FCODE88", fecacol = "Intactseed88",
  deadacol = "Dead1988", censorcol = "Missing1988", censorkeep = NA,
  censor = TRUE, NAas0 = TRUE, NRasRep = TRUE, NOasObs = TRUE)

lathvert_base$feca3 &lt;- round(lathvert_base$feca3)
lathvert_base$feca2 &lt;- round(lathvert_base$feca2)
lathvert_base$feca1 &lt;- round(lathvert_base$feca1)

lathvert_age &lt;- subset(lathvert_base, firstseen &gt; 1988)

lath_survival &lt;- glm(alive3 ~ obsage + as.factor(year2), data = lathvert_age,
  family = "binomial")
lath_fecundity &lt;- glm(feca2 ~ obsage + as.factor(year2), data = lathvert_age,
  family = "poisson")

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[22] &lt;- "obsage"

lathmat2fleslie &lt;- fleslie(year = "all", data = lathvert_age,
  surv_model = lath_survival, fec_model = lath_fecundity,
  paramnames = mod_params, fecage_min = 1)
  
</code></pre>

<hr>
<h2 id='hfv_qc'>Check Quality and Distributions of hfv Datasets</h2><span id='topic+hfv_qc'></span>

<h3>Description</h3>

<p>Function <code>hfv_qc()</code> tests the overall quality of hfv datasets, and also
runs a series of tests to assess which statistical distributions match the
variables within these datasets. The input format is equivalent to the input
format of function <code><a href="#topic+modelsearch">modelsearch</a>()</code>, allowing users to assess
vital rate variable distributions assuming the same internal dataset
subsetting used by the latter function and simply copy and pasting the
parameter options from one function to the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfv_qc(
  data,
  stageframe = NULL,
  historical = TRUE,
  suite = "size",
  vitalrates = c("surv", "size", "fec"),
  surv = c("alive3", "alive2", "alive1"),
  obs = c("obsstatus3", "obsstatus2", "obsstatus1"),
  size = c("sizea3", "sizea2", "sizea1"),
  sizeb = c(NA, NA, NA),
  sizec = c(NA, NA, NA),
  repst = c("repstatus3", "repstatus2", "repstatus1"),
  fec = c("feca3", "feca2", "feca1"),
  stage = c("stage3", "stage2", "stage1"),
  matstat = c("matstatus3", "matstatus2", "matstatus1"),
  indiv = "individ",
  patch = NA,
  year = "year2",
  density = NA,
  patch.as.random = TRUE,
  year.as.random = TRUE,
  juvestimate = NA,
  juvsize = FALSE,
  fectime = 2,
  censor = NA,
  age = NA,
  indcova = NA,
  indcovb = NA,
  indcovc = NA,
  random.indcova = FALSE,
  random.indcovb = FALSE,
  random.indcovc = FALSE,
  test.group = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hfv_qc_+3A_data">data</code></td>
<td>
<p>The vertical dataset to be used for analysis. This dataset should 
be of class <code>hfvdata</code>, but can also be a data frame formatted similarly
to the output format provided by functions <code><a href="#topic+verticalize3">verticalize3</a>()</code> or
<code><a href="#topic+historicalize3">historicalize3</a>()</code>, as long as all needed variables are properly
designated.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_stageframe">stageframe</code></td>
<td>
<p>The stageframe characterizing the life history model used.
Optional unless <code>test.group = TRUE</code>, in which case it is required.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_historical">historical</code></td>
<td>
<p>A logical variable denoting whether to assess the effects
of state in occasion <em>t</em>-1, in addition to state in occasion <em>t</em>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_suite">suite</code></td>
<td>
<p>This describes the global model for each vital rate estimation,
and has the following possible values: <code>full</code>, includes main effects and
all two-way interactions of size and reproductive status; <code>main</code>,
includes main effects only of size and reproductive status; <code>size</code>,
includes only size (also interactions between size in historical model);
<code>rep</code>, includes only reproductive status (also interactions between
status in historical model); <code>age</code>, all vital rates estimated with age
and y-intercepts only; <code>cons</code>, all vital rates estimated only as
y-intercepts. Defaults to <code>size</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_vitalrates">vitalrates</code></td>
<td>
<p>A vector describing which vital rates will be estimated via
linear modeling, with the following options: <code>surv</code>, survival
probability; <code>obs</code>, observation probability; <code>size</code>, overall size;
<code>repst</code>, probability of reproducing; and <code>fec</code>, amount of
reproduction (overall fecundity). May also be set to
<code>vitalrates = "leslie"</code>, which is equivalent to setting
<code>c("surv", "fec")</code> for a Leslie MPM. This choice also determines how
internal data subsetting for vital rate model estimation will work. Defaults
to <code>c("surv", "size", "fec")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_surv">surv</code></td>
<td>
<p>A vector indicating the variable names coding for status as alive
or dead in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("alive3", "alive2", "alive1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_obs">obs</code></td>
<td>
<p>A vector indicating the variable names coding for observation
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("obsstatus3", "obsstatus2", "obsstatus1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_size">size</code></td>
<td>
<p>A vector indicating the variable names coding for the primary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c("sizea3", "sizea2", "sizea1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector indicating the variable names coding for the secondary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c(NA, NA, NA)</code>, in which case <code>sizeb</code> is
not used.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_sizec">sizec</code></td>
<td>
<p>A vector indicating the variable names coding for the tertiary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c(NA, NA, NA)</code>, in which case <code>sizec</code> is
not used.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_repst">repst</code></td>
<td>
<p>A vector indicating the variable names coding for reproductive
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("repstatus3", "repstatus2", "repstatus1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_fec">fec</code></td>
<td>
<p>A vector indicating the variable names coding for fecundity in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to
<code>c("feca3", "feca2", "feca1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_stage">stage</code></td>
<td>
<p>A vector indicating the variable names coding for stage in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Defaults to
<code>c("stage3", "stage2", "stage1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_matstat">matstat</code></td>
<td>
<p>A vector indicating the variable names coding for maturity
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Defaults to
<code>c("matstatus3", "matstatus2", "matstatus1")</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_indiv">indiv</code></td>
<td>
<p>A text value indicating the variable name coding individual
identity. Defaults to <code>"individ"</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_patch">patch</code></td>
<td>
<p>A text value indicating the variable name coding for patch,
where patches are defined as permanent subgroups within the study population.
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_year">year</code></td>
<td>
<p>A text value indicating the variable coding for observation
occasion <em>t</em>. Defaults to <code>"year2"</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_density">density</code></td>
<td>
<p>A text value indicating the name of the variable coding for
spatial density, should the user wish to test spatial density as a fixed
factor affecting vital rates. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_patch.as.random">patch.as.random</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>approach = "mixed"</code>,
then <code>patch</code> is included as a random factor. If set to <code>FALSE</code> and
<code>approach = "glm"</code>, then <code>patch</code> is included as a fixed factor. All
other combinations of logical value and <code>approach</code> lead to <code>patch</code>
not being included in modeling. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_year.as.random">year.as.random</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>approach = "mixed"</code>,
then <code>year</code> is included as a random factor. If set to <code>FALSE</code>, then
<code>year</code> is included as a fixed factor. All other combinations of logical
value and <code>approach</code> lead to <code>year</code> not being included in modeling.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_juvestimate">juvestimate</code></td>
<td>
<p>An optional variable denoting the stage name of the
juvenile stage in the vertical dataset. If not <code>NA</code>, and <code>stage</code> is
also given (see below), then vital rates listed in <code>vitalrates</code> other
than <code>fec</code> will also be estimated from the juvenile stage to all adult
stages. Defaults to <code>NA</code>, in which case juvenile vital rates are not
estimated.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_juvsize">juvsize</code></td>
<td>
<p>A logical variable denoting whether size should be used as a
term in models involving transition from the juvenile stage. Defaults to
<code>FALSE</code>, and is only used if <code>juvestimate</code> does not equal
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_fectime">fectime</code></td>
<td>
<p>A variable indicating which year of fecundity to use as the
response term in fecundity models. Options include <code>2</code>, which refers to
occasion <em>t</em>, and <code>3</code>, which refers to occasion <em>t</em>+1.
Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_censor">censor</code></td>
<td>
<p>A vector denoting the names of censoring variables in the
dataset, in order from occasion <em>t</em>+1, followed by occasion <em>t</em>,
and lastly followed by occasion <em>t</em>-1. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_age">age</code></td>
<td>
<p>Designates the name of the variable corresponding to age in time
<em>t</em> in the vertical dataset. Defaults to <code>NA</code>, in which case age
is not included in linear models. Should only be used if building Leslie or
age x stage matrices.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_indcova">indcova</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of an individual covariate. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_indcovb">indcovb</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of a second individual covariate. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_indcovc">indcovc</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of a third individual covariate. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_random.indcova">random.indcova</code></td>
<td>
<p>A logical value indicating whether <code>indcova</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_random.indcovb">random.indcovb</code></td>
<td>
<p>A logical value indicating whether <code>indcovb</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_random.indcovc">random.indcovc</code></td>
<td>
<p>A logical value indicating whether <code>indcovc</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_test.group">test.group</code></td>
<td>
<p>A logical value indicating whether to include the
<code>group</code> variable from the input <code>stageframe</code> as a fixed categorical
variable in linear models. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hfv_qc_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function yields text output describing the subsets to be used in
linear vital rate modeling. No value or object is returned.
</p>


<h3>Notes</h3>

<p>This function is meant to handle input as would be supplied to function
<code>modelsearch()</code>. To use most easily, users may copy all input parameters
from a call to function <code>modelsearch()</code>, and paste directly within this
function. The exact subsets used in the <code>modelsearch()</code> run will also be
created here.
</p>
<p>Tests of Gaussian normality are conducted as Shapiro-Wilk tests via base R's
<code>shapiro.test()</code> function. If datasets with more than 5000 rows are
supplied, function <code>hfv_qc()</code> will sample 5000 rows from the dataset and
conduct the Shapiro-Wilk test on the data sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

hfv_qc(lathvertln, historical = TRUE, suite = "main", 
  vitalrates = c("surv", "obs", "size", "repst", "fec"), juvestimate = "Sdl",
  indiv = "individ", patch = "patchid", year = "year2",year.as.random = TRUE,
  patch.as.random = TRUE)

</code></pre>

<hr>
<h2 id='hist_null'>Create Historical MPMs Assuming No Influence of Individual History</h2><span id='topic+hist_null'></span>

<h3>Description</h3>

<p>Function <code>hist_null()</code> uses ahistorical MPMs to create the equivalent
MPMs in the structure of historical MPMs. These MPMs have the same
dimensions and stage structure of hMPMs but assume no influence of
individual history, and so can be compared to actual hMPMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_null(mpm, format = 1L, err_check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_null_+3A_mpm">mpm</code></td>
<td>
<p>An ahistorical MPM of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="hist_null_+3A_format">format</code></td>
<td>
<p>An integer stipulating whether historical matrices should be
produced in Ehrlen format (<code>1</code>) or deVries format (<code>2</code>).</p>
</td></tr>
<tr><td><code id="hist_null_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to output the main index
data frames used to sort elements in the matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lefkoMat</code>, with the same list structure as
the input object, but with <code>A</code>, <code>U</code>, and <code>F</code> elements
replaced with lists of historically-structured matrices, and with element
<code>hstages</code> changed from <code>NA</code> to an index of stage pairs
corresponding to the rows and columns of the new matrices. If
<code>err_check = TRUE</code>, then a list of three data frames showing the values
used to determine matrix element index values is also exported.
</p>


<h3>Notes</h3>

<p>This function does not currently identify biologically impossible
transitions. Ahistorical transition values are placed in all theoretically
possible historical transitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizevector &lt;- c(1, 1, 2, 3)
stagevector &lt;- c("Sdl", "Veg", "SmFlo", "LFlo")
repvector &lt;- c(0, 0, 1, 1)
obsvector &lt;- c(1, 1, 1, 1)
matvector &lt;- c(0, 1, 1, 1)
immvector &lt;- c(1, 0, 0, 0)
propvector &lt;- c(0, 0, 0, 0)
indataset &lt;- c(1, 1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5, 0.5)

anthframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# POPN C 2003-2004
XC3 &lt;- matrix(c(0, 0, 1.74, 1.74,
0.208333333, 0, 0, 0.057142857,
0.041666667, 0.076923077, 0, 0,
0.083333333, 0.076923077, 0.066666667, 0.028571429), 4, 4, byrow = TRUE)

# 2004-2005
XC4 &lt;- matrix(c(0, 0, 0.3, 0.6,
0.32183908, 0.142857143, 0, 0,
0.16091954, 0.285714286, 0, 0,
0.252873563, 0.285714286, 0.5, 0.6), 4, 4, byrow = TRUE)

mats_list &lt;- list(XC3, XC4)
yr_ord &lt;- c(1, 2)
pch_ord &lt;- c(1, 1)

anth_lefkoMat &lt;- create_lM(mats_list, anthframe, hstages = NA, historical = FALSE,
  poporder = 1, patchorder = pch_ord, yearorder = yr_ord)
  
nullmodel1 &lt;- hist_null(anth_lefkoMat, 1) # Ehrlen format
nullmodel2 &lt;- hist_null(anth_lefkoMat, 2) # deVries format

</code></pre>

<hr>
<h2 id='historicalize3'>Create Historical Vertical Data Frame from Ahistorical Vertical Data Frame</h2><span id='topic+historicalize3'></span>

<h3>Description</h3>

<p>Function <code>historicalize3()</code> returns a vertically formatted demographic
data frame organized to create historical projection matrices, given a
vertically but ahistorically formatted data frame. This data frame is in
standard <code>hfvdata</code> format and can be used in all functions in the
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>historicalize3(
  data,
  popidcol = 0,
  patchidcol = 0,
  individcol,
  year2col = 0,
  year3col = 0,
  xcol = 0,
  ycol = 0,
  sizea2col = 0,
  sizea3col = 0,
  sizeb2col = 0,
  sizeb3col = 0,
  sizec2col = 0,
  sizec3col = 0,
  repstra2col = 0,
  repstra3col = 0,
  repstrb2col = 0,
  repstrb3col = 0,
  feca2col = 0,
  feca3col = 0,
  fecb2col = 0,
  fecb3col = 0,
  indcova2col = 0,
  indcova3col = 0,
  indcovb2col = 0,
  indcovb3col = 0,
  indcovc2col = 0,
  indcovc3col = 0,
  alive2col = 0,
  alive3col = 0,
  dead2col = 0,
  dead3col = 0,
  obs2col = 0,
  obs3col = 0,
  nonobs2col = 0,
  nonobs3col = 0,
  repstrrel = 1,
  fecrel = 1,
  stage2col = 0,
  stage3col = 0,
  juv2col = 0,
  juv3col = 0,
  stageassign = NA,
  stagesize = NA,
  censor = FALSE,
  censorcol = 0,
  censorkeep = 0,
  spacing = NA,
  NAas0 = FALSE,
  NRasRep = FALSE,
  NOasObs = FALSE,
  prebreeding = TRUE,
  age_offset = 0,
  reduce = TRUE,
  a2check = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="historicalize3_+3A_data">data</code></td>
<td>
<p>The horizontal data file.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_popidcol">popidcol</code></td>
<td>
<p>A variable name or column number corresponding to the
identity of the population for each individual.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_patchidcol">patchidcol</code></td>
<td>
<p>A variable name or column number corresponding to the
identity of the patch or subpopulation for each individual, if patches have
been designated within populations.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_individcol">individcol</code></td>
<td>
<p>A variable name or column number corresponding to the
unique identity of each individual.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_year2col">year2col</code></td>
<td>
<p>A variable name or column number corresponding to occasion
<em>t</em> (year or time).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_year3col">year3col</code></td>
<td>
<p>A variable name or column number corresponding to occasion
<em>t</em>+1 (year or time).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_xcol">xcol</code></td>
<td>
<p>A variable name or column number corresponding to the X
coordinate of each individual in Cartesian space.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_ycol">ycol</code></td>
<td>
<p>A variable name or column number corresponding to the Y
coordinate of each individual in Cartesian space.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizea2col">sizea2col</code></td>
<td>
<p>A variable name or column number corresponding to the
primary size entry in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizea3col">sizea3col</code></td>
<td>
<p>A variable name or column number corresponding to the
primary size entry in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizeb2col">sizeb2col</code></td>
<td>
<p>A variable name or column number corresponding to the
secondary size entry in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizeb3col">sizeb3col</code></td>
<td>
<p>A variable name or column number corresponding to the
secondary size entry in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizec2col">sizec2col</code></td>
<td>
<p>A variable name or column number corresponding to the
tertiary size entry in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_sizec3col">sizec3col</code></td>
<td>
<p>A variable name or column number corresponding to the
tertiary size entry in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_repstra2col">repstra2col</code></td>
<td>
<p>A variable name or column number corresponding to the
production of reproductive structures, such as flowers, in occasion <em>t</em>.
This can be binomial or count data, and is used to in analysis of the
probability of reproduction.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_repstra3col">repstra3col</code></td>
<td>
<p>A variable name or column number corresponding to the
production of reproductive structures, such as flowers, in occasion
<em>t</em>+1. This can be binomial or count data, and is used to in analysis
of the probability of reproduction.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_repstrb2col">repstrb2col</code></td>
<td>
<p>A second variable name or column number corresponding to
the production of reproductive structures, such as flowers, in occasion
<em>t</em>. This can be binomial or count data.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_repstrb3col">repstrb3col</code></td>
<td>
<p>A second variable name or column number corresponding to
the production of reproductive structures, such as flowers, in occasion 
<em>t</em>+1. This can be binomial or count data.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_feca2col">feca2col</code></td>
<td>
<p>A variable name or column number corresponding to fecundity
in occasion <em>t</em>. This may represent egg counts, fruit counts, seed 
production, etc.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_feca3col">feca3col</code></td>
<td>
<p>A variable name or column number corresponding to fecundity
in occasion <em>t</em>+1. This may represent egg counts, fruit counts, seed
production, etc.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_fecb2col">fecb2col</code></td>
<td>
<p>A second variable name or column number corresponding to 
fecundity in occasion <em>t</em>. This may represent egg counts, fruit counts,
seed production, etc.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_fecb3col">fecb3col</code></td>
<td>
<p>A second variable name or column number corresponding to 
fecundity in occasion <em>t</em>+1. This may represent egg counts, fruit
counts, seed production, etc.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcova2col">indcova2col</code></td>
<td>
<p>A variable name or column number corresponding to an
individual covariate to be used in analysis, in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcova3col">indcova3col</code></td>
<td>
<p>A variable name or column number corresponding to an
individual covariate to be used in analysis, in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcovb2col">indcovb2col</code></td>
<td>
<p>A variable name or column number corresponding to a second
individual covariate to be used in analysis, in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcovb3col">indcovb3col</code></td>
<td>
<p>A variable name or column number corresponding to a second
individual covariate to be used in analysis, in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcovc2col">indcovc2col</code></td>
<td>
<p>A variable name or column number corresponding to a third
individual covariate to be used in analysis, in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_indcovc3col">indcovc3col</code></td>
<td>
<p>A variable name or column number corresponding to a third
individual covariate to be used in analysis, in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_alive2col">alive2col</code></td>
<td>
<p>A variable name or column number that provides information
on whether an individual is alive in occasion <em>t</em>. If used, living
status must be designated as binomial (living = <code>1</code>, dead = <code>0</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_alive3col">alive3col</code></td>
<td>
<p>A variable name or column number that provides information
on whether an individual is alive in occasion <em>t</em>+1. If used, living
status must be designated as binomial (living = <code>1</code>, dead = <code>0</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_dead2col">dead2col</code></td>
<td>
<p>A variable name or column number that provides information on
whether an individual is dead in occasion <em>t</em>. If used, dead status
must be designated as binomial (living = <code>0</code>, dead = <code>1</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_dead3col">dead3col</code></td>
<td>
<p>A variable name or column number that provides information on
whether an individual is dead in occasion <em>t</em>+1. If used, dead status
must be designated as binomial (living = <code>0</code>, dead = <code>1</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_obs2col">obs2col</code></td>
<td>
<p>A variable name or column number providing information on
whether an individual is in an observable stage in occasion <em>t</em>. If
used, observation status must be designated as binomial (observed = <code>1</code>,
not observed = <code>0</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_obs3col">obs3col</code></td>
<td>
<p>A variable name or column number providing information on
whether an individual is in an observable stage in occasion <em>t</em>+1. If
used, observation status must be designated as binomial (observed = <code>1</code>,
not observed = <code>0</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_nonobs2col">nonobs2col</code></td>
<td>
<p>A variable name or column number providing information on
whether an individual is in an unobservable stage in occasion <em>t</em>. If
used, observation status must be designated as binomial (observed = <code>0</code>,
not observed = <code>1</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_nonobs3col">nonobs3col</code></td>
<td>
<p>A variable name or column number providing information on
whether an individual is in an unobservable stage in occasion <em>t</em>+1. If
used, observation status must be designated as binomial (observed = <code>0</code>,
not observed = <code>1</code>).</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_repstrrel">repstrrel</code></td>
<td>
<p>This is a scalar multiplier making the variable represented
by <code>repstrb2col</code> equivalent to the variable represented by 
<code>repstra2col</code>. This can be useful if two reproductive status variables
have related but unequal units, for example if <code>repstrb2col</code> refers to
one-flowered stems while <code>repstra2col</code> refers to two-flowered stems.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_fecrel">fecrel</code></td>
<td>
<p>This is a scalar multiplier making the variable represented by
<code>fecb2col</code> equivalent to the variable represented by <code>feca2col</code>.
This can be useful if two fecundity variables have related but unequal units.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_stage2col">stage2col</code></td>
<td>
<p>Optional variable name or column number corresponding to
life history stage in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_stage3col">stage3col</code></td>
<td>
<p>Optional variable name or column number corresponding to
life history stage in occasion <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_juv2col">juv2col</code></td>
<td>
<p>A variable name or column number that marks individuals in
immature stages in occasion <em>t</em>. Function <code>historicalize3()</code>
assumes that immature individuals are identified in this variable marked with
a number equal to or greater than <code>1</code>, and that mature individuals are
marked as <code>0</code> or <code>NA</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_juv3col">juv3col</code></td>
<td>
<p>A variable name or column number that marks individuals in
immature stages in occasion <em>t</em>+1. Function <code>historicalize3()</code>
assumes that immature individuals are identified in this variable marked with
a number equal to or greater than <code>1</code>, and that mature individuals are
marked as <code>0</code> or <code>NA</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_stageassign">stageassign</code></td>
<td>
<p>The stageframe object identifying the life history model
being operationalized. Note that if <code>stage2col</code> is provided, then this
stageframe is not utilized in stage designation.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_stagesize">stagesize</code></td>
<td>
<p>A variable name or column number describing which size 
variable to use in stage estimation. Defaults to <code>NA</code>, and can also take 
<code>sizea</code>, <code>sizeb</code>, <code>sizec</code>, <code>sizeab</code>, <code>sizebc</code>,
<code>sizeac</code>, <code>sizeabc</code>, or <code>sizeadded</code>, depending on
which size variable within the input dataset is chosen. Note that the
variable(s) chosen should be presented in the order of the primary,
secondary, and tertiary variables in the stageframe input with
<code>stageassign</code>. For example, choosing <code>sizeb</code> assumes that this size
variable in the dataset is the primary variable in the stageframe.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_censor">censor</code></td>
<td>
<p>A logical variable determining whether the output data should
be censored using the variable defined in <code>censorcol</code>. Defaults to 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_censorcol">censorcol</code></td>
<td>
<p>A variable name or column number corresponding to a censor
variable within the dataset, used to distinguish between entries to use and
those to discard from analysis, or to designate entries with special issues 
that require further attention.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censoring variable identifying data that
should be included in analysis. Defaults to <code>0</code>, but may take any value
including <code>NA</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_spacing">spacing</code></td>
<td>
<p>The spacing at which density should be estimated, if density
estimation is desired and X and Y coordinates are supplied. Given in the same
units as those used in the X and Y coordinates given in <code>xcol</code> and
<code>ycol</code>. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_naas0">NAas0</code></td>
<td>
<p>If TRUE, then all <code>NA</code> entries for size and fecundity
variables will be set to <code>0</code>. This can help increase the sample size
analyzed by  <code><a href="#topic+modelsearch">modelsearch</a>()</code>, but should only be used when it is
clear that this substitution is biologically realistic. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_nrasrep">NRasRep</code></td>
<td>
<p>If set to <code>TRUE</code>, then this function will treat
non-reproductive but mature individuals as reproductive during stage
assignment. This can be useful when a matrix is desired without separation of
reproductive and non-reproductive but mature stages of the same size. Only
used if <code>stageassign</code> is set to a valid stageframe. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_noasobs">NOasObs</code></td>
<td>
<p>If <code>TRUE</code>, then will treat individuals that are
interpreted as not observed in the dataset as though they were observed
during stage assignment. This can be useful when a MPM is desired without
separation of observable and unobservable stages. Only used if
<code>stageassign</code> is set to a stageframe. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical term indicating whether the life history model
is pre-breeding. If so, then <code>1</code> is added to all ages. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_age_offset">age_offset</code></td>
<td>
<p>A number to add automatically to all values of age at time
<em>t</em>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_reduce">reduce</code></td>
<td>
<p>A logical variable determining whether unused variables and
some invariant state variables should be removed from the output dataset.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_a2check">a2check</code></td>
<td>
<p>A logical variable indicating whether to retain all data with
living status at occasion <em>t</em>. Defaults to <code>FALSE</code>, in which case
data for occasions in which the individual is not alive in time <em>t</em> is
not retained. This option should be kept <code>FALSE</code>, except to inspect
potential errors in the dataset.</p>
</td></tr>
<tr><td><code id="historicalize3_+3A_quiet">quiet</code></td>
<td>
<p>A logical variable indicating whether to silence warnings.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will output
a historical vertical data frame (class <code>hfvdata</code>), meaning that the
output data frame will have three consecutive years of size and reproductive
data per individual per row. This data frame is in standard format for all
functions used in <code>lefko3</code>, and so can be used without further 
modification. Note that determination of state in occasions <em>t</em>-1 and
<em>t</em>+1 gives preference to condition in occasion <em>t</em> within the
input dataset. Conflicts in condition in input datasets that have both
occasions <em>t</em> and <em>t</em>+1 listed per row are resolved by using
condition in occasion <em>t</em>.
</p>
<p>Variables in this data frame include the following:
</p>
<table>
<tr><td><code>rowid</code></td>
<td>
<p>Unique identifier for the row of the data frame.</p>
</td></tr>
<tr><td><code>popid</code></td>
<td>
<p>Unique identifier for the population, if given.</p>
</td></tr>
<tr><td><code>patchid</code></td>
<td>
<p>Unique identifier for patch within population, if given.</p>
</td></tr>
<tr><td><code>individ</code></td>
<td>
<p>Unique identifier for the individual.</p>
</td></tr>
<tr><td><code>year2</code></td>
<td>
<p>Year or time in occasion <em>t</em>.</p>
</td></tr>
<tr><td><code>firstseen</code></td>
<td>
<p>Occasion of first observation.</p>
</td></tr>
<tr><td><code>lastseen</code></td>
<td>
<p>Occasion of last observation.</p>
</td></tr>
<tr><td><code>obsage</code></td>
<td>
<p>Observed age in occasion <em>t</em>, assuming first observation
corresponds to age = 0.</p>
</td></tr>
<tr><td><code>obslifespan</code></td>
<td>
<p>Observed lifespan, given as <code>lastseen - firstseen + 1</code>.</p>
</td></tr>
<tr><td><code>xpos1</code>, <code>xpos2</code>, <code>xpos3</code></td>
<td>
<p>X position in Cartesian space in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively, if provided.</p>
</td></tr>
<tr><td><code>ypos1</code>, <code>ypos2</code>, <code>ypos3</code></td>
<td>
<p>Y position in Cartesian space in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively, if provided.</p>
</td></tr>
<tr><td><code>sizea1</code>, <code>sizea2</code>, <code>sizea3</code></td>
<td>
<p>Main size measurement in occasions <em>t</em>-1,
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>sizeb1</code>, <code>sizeb2</code>, <code>sizeb3</code></td>
<td>
<p>Secondary size measurement in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>sizec1</code>, <code>sizec2</code>, <code>sizec3</code></td>
<td>
<p>Tertiary size measurement in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>size1added</code>, <code>size2added</code>, <code>size3added</code></td>
<td>
<p>Sum of primary, secondary, and
tertiary size measurements in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1,
respectively.</p>
</td></tr>
<tr><td><code>repstra1</code>, <code>repstra2</code>, <code>repstra3</code></td>
<td>
<p>Main numbers of reproductive structures in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstrb1</code>, <code>repstrb2</code>, <code>repstrb3</code></td>
<td>
<p>Secondary numbers of reproductive
structures in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstr1added</code>, <code>repstr2added</code>, <code>repstr3added</code></td>
<td>
<p>Sum of primary and secondary
reproductive structures in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1,
respectively.</p>
</td></tr>
<tr><td><code>feca1</code>, <code>feca2</code>, <code>feca3</code></td>
<td>
<p>Main numbers of offspring in occasions <em>t</em>-1,
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fecb1</code>, <code>fecb2</code>, <code>fecb3</code></td>
<td>
<p>Secondary numbers of offspring in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fec1added</code>, <code>fec2added</code>, <code>fec3added</code></td>
<td>
<p>Sum of primary and secondary fecundity
in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>censor1</code>, <code>censor2</code>, <code>censor3</code></td>
<td>
<p>Censor status values in occasions <em>t</em>-1,
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>juvgiven1</code>, <code>juvgiven2</code>, <code>juvgiven3</code></td>
<td>
<p>Binomial variable indicating whether
individual is juvenile in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1.
Only given if <code>juvcol</code> is provided.</p>
</td></tr>
<tr><td><code>obsstatus1</code>, <code>obsstatus2</code>, <code>obsstatus3</code></td>
<td>
<p>Binomial observation status in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstatus1</code>, <code>repstatus2</code>, <code>repstatus3</code></td>
<td>
<p>Binomial reproductive status in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fecstatus1</code>, <code>fecstatus2</code>, <code>fecstatus3</code></td>
<td>
<p>Binomial offspring production status
in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>matstatus1</code>, <code>matstatus2</code>, <code>matstatus3</code></td>
<td>
<p>Binomial maturity status in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>alive1</code>, <code>alive2</code>, <code>alive3</code></td>
<td>
<p>Binomial status as alive in occasions <em>t</em>-1,
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>Density of individuals per unit designated in <code>spacing</code>.
Only given if spacing is not <code>NA</code>.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Warnings that some individuals occur in state combinations that do not match
any stages in the stageframe used to assign stages, and that some individuals
match characteristics of several stages in the stageframe, are common when
first working with a dataset. Typically, these situations can be identified as
<code>NoMatch</code> entries in <code>stage3</code>, although such entries may crop up in
<code>stage1</code> and <code>stage2</code>, as well. In some cases, these warnings will
arise with no concurrent <code>NoMatch</code> entries. These are important warnings
and suggest that there is likely a problem with the stageframe. The most
common such problems are: 1) stages have significant overlap in
characteristics, with the most common being overlapping size bins caused by
erroneous definitions of size bin halfwidths; and 2) some individuals exist
in states not defined within the stageframe.
</p>
<p>In some datasets with unobservable stages, observation status
(<code>obsstatus</code>) might not be inferred properly if a single size variable
is used that does not yield sizes greater than 0 in all cases in which
individuals were observed. Such situations may arise, for example, in plants
when leaf number is the dominant size variable used, but individuals
occasionally occur with inflorescences but no leaves. In this instances,
it helps to mark related variables as <code>sizeb</code> and <code>sizec</code>, because
observation status will be interpreted in relation to all 3 size variables.
Alternatively, observation status may be input via <code>obs2col</code> and
<code>obs3col</code> to force computation with given values (although this requires
all instances of observation and non-observation to be known and coded ahead
of time). Further analysis can then utilize only a single size variable, of
the user's choosing. Similar issues can arise in reproductive status
(<code>repstatus</code>).
</p>
<p>Juvenile designation should only be used when juveniles fall outside of the
size classification scheme used in determining stages. If juveniles are to be
size classified along the size spectrum that adults also fall on, then
it is best to treat juveniles as mature but not reproductive.
</p>
<p>Care should be taken to avoid variables with negative values indicating size,
fecundity, or reproductive or observation status. Negative values can be
interpreted in different ways, typically reflecting estimation through other
algorithms rather than actual measured data. Variables holding negative
values can conflict with data management algorithms in ways that are
difficult to predict.
</p>
<p>Unusual errors (e.g. <code>"Error in pjf..."</code>) may occur in cases where the
variables are improperly passed, or where seemingly numeric variables include
text and so get automatically converted to string variables.
</p>
<p>Density estimation is performed as a count of individuals alive and within
the radius specified in <code>spacing</code> of the respective individual at some
point in time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypvert)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v2 &lt;- historicalize3(data = cypvert, patchidcol = "patch", 
  individcol = "plantid", year2col = "year2", sizea2col = "Inf2.2", 
  sizea3col = "Inf2.3", sizeb2col = "Inf.2", sizeb3col = "Inf.3", 
  sizec2col = "Veg.2", sizec3col = "Veg.3", repstra2col = "Inf2.2", 
  repstra3col = "Inf2.3", repstrb2col = "Inf.2", repstrb3col = "Inf.3", 
  feca2col = "Pod.2", feca3col = "Pod.3", repstrrel = 2, 
  stageassign = cypframe_raw, stagesize = "sizeadded", censorcol = "censor",
  censor = FALSE, NAas0 = TRUE, NRasRep = TRUE, reduce = TRUE)

</code></pre>

<hr>
<h2 id='image3'>Create Matrix Image</h2><span id='topic+image3'></span>

<h3>Description</h3>

<p>Function <code>image3()</code> is a generic function that creates matrix plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3_+3A_mats">mats</code></td>
<td>
<p>A lefkoMat object, or a single projection matrix, for which the
dominant eigenvalue is desired.</p>
</td></tr>
<tr><td><code id="image3_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a single matrix image, or a series of images, depending on
the input. Non-zero elements appear as red space, while zero elements appear
as white space.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image3.lefkoMat">image3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+image3.matrix">image3.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

image3(ehrlen3, used = 1, type = "U")

</code></pre>

<hr>
<h2 id='image3.dgCMatrix'>Create a Matrix Image for a Single Sparse Matrix</h2><span id='topic+image3.dgCMatrix'></span>

<h3>Description</h3>

<p>Function <code>image3.dgCMatrix</code> plots a matrix image for a single sparse
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
image3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.dgCMatrix_+3A_mats">mats</code></td>
<td>
<p>A <code>matrix</code> class object.</p>
</td></tr>
<tr><td><code id="image3.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ", sparse_output = TRUE)

image3(ehrlen3$U[[1]])

</code></pre>

<hr>
<h2 id='image3.lefkoElas'>Create Matrix Image(s) for lefkoElas Object</h2><span id='topic+image3.lefkoElas'></span>

<h3>Description</h3>

<p>Function <code>image3.lefkoElas</code> plots matrix images for elasticity matrices
supplied within <code>lefkoElas</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoElas'
image3(mats, used = "all", type = "a", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.lefkoElas_+3A_mats">mats</code></td>
<td>
<p>A <code>lefkoElas</code> object.</p>
</td></tr>
<tr><td><code id="image3.lefkoElas_+3A_used">used</code></td>
<td>
<p>A numeric value or vector designating the matrices to plot. Can
also take the value <code>"all"</code>, which plots all matrices. Defaults to
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="image3.lefkoElas_+3A_type">type</code></td>
<td>
<p>Character value indicating whether to plot <code>"a"</code>historical or
<code>"h"</code>istorical elasticity matrices. Defaults to <code>"a"</code>historical,
but will plot a historical elasticity matrix image if no ahistorical
elasticity matrix exists.</p>
</td></tr>
<tr><td><code id="image3.lefkoElas_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe,
  year = c(1989, 1990), stages = c("stage3", "stage2", "stage1"),
  supplement = lathsupp3, yearcol = "year2", indivcol = "individ")

ehrlen_elas &lt;- elasticity3(ehrlen3)

image3(ehrlen_elas, used = 1, type = "h")

</code></pre>

<hr>
<h2 id='image3.lefkoMat'>Create Matrix Image(s) for lefkoMat Object</h2><span id='topic+image3.lefkoMat'></span>

<h3>Description</h3>

<p>Function <code>image3.lefkoMat</code> plots matrix images for matrices supplied
within <code>lefkoMat</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
image3(mats, used = "all", type = "A", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.lefkoMat_+3A_mats">mats</code></td>
<td>
<p>A <code>lefkoMat</code> object.</p>
</td></tr>
<tr><td><code id="image3.lefkoMat_+3A_used">used</code></td>
<td>
<p>A numeric value or vector designating the matrices to plot. Can
also take the value <code>"all"</code>, which plots all matrices. Defaults to
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="image3.lefkoMat_+3A_type">type</code></td>
<td>
<p>Character value indicating whether to plot <code>A</code>, <code>U</code>, or
<code>F</code> matrices. Defaults to <code>"A"</code>.</p>
</td></tr>
<tr><td><code id="image3.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

image3(ehrlen3, used = 1, type = "U")

</code></pre>

<hr>
<h2 id='image3.lefkoSens'>Create Matrix Image(s) for lefkoSens Object</h2><span id='topic+image3.lefkoSens'></span>

<h3>Description</h3>

<p>Function <code>image3.lefkoSens</code> plots matrix images for sensitivity matrices
supplied within <code>lefkoSens</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoSens'
image3(mats, used = "all", type = "a", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.lefkoSens_+3A_mats">mats</code></td>
<td>
<p>A <code>lefkoSens</code> object.</p>
</td></tr>
<tr><td><code id="image3.lefkoSens_+3A_used">used</code></td>
<td>
<p>A numeric value or vector designating the matrices to plot. Can
also take the value <code>"all"</code>, which plots all matrices. Defaults to
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="image3.lefkoSens_+3A_type">type</code></td>
<td>
<p>Character value indicating whether to plot <code>"a"</code>historical or
<code>"h"</code>istorical sensitivity matrices. Defaults to <code>"a"</code>historical,
but will plot a historical sensitivity matrix image if no ahistorical
sensitivity matrix exists.</p>
</td></tr>
<tr><td><code id="image3.lefkoSens_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe,
  year = c(1989, 1990), stages = c("stage3", "stage2", "stage1"),
  supplement = lathsupp3, yearcol = "year2", indivcol = "individ")

ehrlen_sens &lt;- sensitivity3(ehrlen3)

image3(ehrlen_sens, used = 1, type = "h")

</code></pre>

<hr>
<h2 id='image3.list'>Create Matrix Images for Matrices in a List</h2><span id='topic+image3.list'></span>

<h3>Description</h3>

<p>Function <code>image3.list</code> plots matrix images for matrices contained in a
list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
image3(mats, used = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.list_+3A_mats">mats</code></td>
<td>
<p>A <code>list</code> class object.</p>
</td></tr>
<tr><td><code id="image3.list_+3A_used">used</code></td>
<td>
<p>A numeric vector of projection matrices within <code>mats</code> to
represent as matrix images. Can also take the text value <code>"all"</code>, which
will produce images of all matrices. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="image3.list_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "all", "all"), 
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

image3(ehrlen3$A, used = 1)

</code></pre>

<hr>
<h2 id='image3.matrix'>Create a Matrix Image for a Single Matrix</h2><span id='topic+image3.matrix'></span>

<h3>Description</h3>

<p>Function <code>image3.matrix</code> plots a matrix image for a single matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
image3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3.matrix_+3A_mats">mats</code></td>
<td>
<p>A <code>matrix</code> class object.</p>
</td></tr>
<tr><td><code id="image3.matrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a matrix image, or series of matrix images, denoting non-zero
elements as red space and zero elements as white space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ", sparse_output = FALSE)

image3(ehrlen3$U[[1]])

</code></pre>

<hr>
<h2 id='lambda3'>Estimate Actual or Deterministic Population Growth Rate</h2><span id='topic+lambda3'></span>

<h3>Description</h3>

<p>Function <code>lambda3()</code> is a generic function that returns the dominant
eigenvalue of a matrix, set of dominant eigenvalues of a set of matrices,
set of dominant eigenvalues for a <code>lefkoMat</code> object, or actual
<code class="reqn">\lambda</code> in each year in a <code>lefkoProj</code> object. It can handle
large and sparse matrices supplied as <code>lefkoMat</code> objects or as
individual matrices, and can be used with large historical matrices, IPMs, 
age x stage matrices, as well as smaller ahistorical matrices, and general
projetions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda3(mpm, force_sparse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda3_+3A_mpm">mpm</code></td>
<td>
<p>A <code>lefkoMat</code> object, a list of projection matrices, a
<code>lefkoProj</code> object, or a single projection matrix.</p>
</td></tr>
<tr><td><code id="lambda3_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A logical value or string detailing whether to force
sparse matrix encoding for simple matrix input. Defaults to <code>"auto"</code>,
which only forces sparse matrix coding if simple matrices are input that are
both sparse (i.e, percentage of matrix elements that are non-zero &lt;= 50
and have more than 20 rows. Can also be set to <code>"yes"</code>, <code>"no"</code>,
<code>TRUE</code>, or <code>FALSE</code>. Note that sparse matrix coding is always used
for <code>lefkoMat</code> objects with matrices in sparse format (class
<code>dgCMatrix</code>). Ignored with <code>lefkoProj</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the <code>mpm</code> argument.
If a <code>lefkoMat</code> object is provided, then this function will return the
<code>labels</code> data frame with a new column named <code>lambda</code> showing the
dominant eigenvalues for each matrix. If a list of matrices is provided,
then this function will produce a numeric vector with the dominant
eigenvalues provided in order of matrix. If a single matrix is provided,
then this function will return the dominant eigenvalue of that matrix. Only
the largest real parts of the eigenvalues are returned.
</p>
<p>If a <code>lefkoProj</code> object is provided, then the output consists of a list
with three elements. The second and third elements are lists of matrices
with each lower-level list elements corresponding to <code>labels</code> rows,
and matrices within these lists showing the actual <code class="reqn">\lambda</code> and
<code>log</code> <code class="reqn">\lambda</code> for each consecutive year or time index (columns)
within each replicate (row).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slambda3">slambda3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
lambda3(ehrlen3mean)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

lambda3(cypmatrix2r)

</code></pre>

<hr>
<h2 id='lathyrus'>Demographic Dataset of <em>Lathyrus vernus</em> Population</h2><span id='topic+lathyrus'></span>

<h3>Description</h3>

<p>A dataset containing the states and fates of <em>Lathyrus vernus</em> (spring
vetch), family Fabaceae, from a population in Sweden monitored annually
from 1988 to 1991 in six study plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lathyrus)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1119 individuals and 34 variables. Each row
corresponds to a unique individual, and each variable from <code>Volume88</code>
on refers to the state of the individual in a given year.
</p>

<dl>
<dt>SUBPLOT</dt><dd><p>A variable refering to patch within the population.</p>
</dd>
<dt>GENET</dt><dd><p>A numeric variable giving a unique number to each 
individual.</p>
</dd>
<dt>Volume88</dt><dd><p>Aboveground volume in cubic mm in 1988.</p>
</dd>
<dt>lnVol88</dt><dd><p>Natural logarithm of <code>Volume88</code>.</p>
</dd>
<dt>FCODE88</dt><dd><p>Equals 1 if flowering and 0 if not flowering in 1988.</p>
</dd>
<dt>Flow88</dt><dd><p>Number of flowers in 1988.</p>
</dd>
<dt>Intactseed88</dt><dd><p>Number of intact mature seeds produced in 1988.
Not always an integer, as in some cases seed number was estimated via 
linear modeling.</p>
</dd>
<dt>Dead1988</dt><dd><p>Marked as 1 if known to be dead in 1988.</p>
</dd>
<dt>Dormant1988</dt><dd><p>Marked as 1 if known to be alive but vegetatively 
dormant in 1988.</p>
</dd>
<dt>Missing1988</dt><dd><p>Marked as 1 if not found in 1988.</p>
</dd>
<dt>Seedling1988</dt><dd><p>Marked as 1, 2, or 3 if observed as a seedling in year
<em>t</em>. Numbers refer to certainty of assignment: 1 = certain that plant
is a seedling in 1988, 2 = likely that plant is a seedling in 1988,
3 = probable that plant is a seedling in 1988.</p>
</dd>
<dt>Volume89</dt><dd><p>Aboveground volume in cubic mm in 1989.</p>
</dd>
<dt>lnVol89</dt><dd><p>Natural logarithm of <code>Volume89</code>.</p>
</dd>
<dt>FCODE89</dt><dd><p>Equals 1 if flowering and 0 if not flowering in 1989.</p>
</dd>
<dt>Flow89</dt><dd><p>Number of flowers in 1989.</p>
</dd>
<dt>Intactseed89</dt><dd><p>NZumber of intact mature seeds produced in 1989.
Not always an integer, as in some cases seed number was estimated via
linear modeling.</p>
</dd>
<dt>Dead1989</dt><dd><p>Marked as 1 if known to be dead in 1989.</p>
</dd>
<dt>Dormant1989</dt><dd><p>Marked as 1 if known to be alive but vegetatively 
dormant in 1989.</p>
</dd>
<dt>Missing1989</dt><dd><p>Marked as 1 if not found in 1989.</p>
</dd>
<dt>Seedling1989</dt><dd><p>Marked as 1, 2, or 3 if observed as a seedling in
year <em>t</em>. Numbers refer to certainty of assignment: 1 = certain 
that plant is a seedling in 1989, 2 = likely that plant is a seedling 
in 1989, 3 = probable that plant is a seedling in 1989.</p>
</dd>
<dt>Volume90</dt><dd><p>Aboveground volume in mm&lt;sup&gt;3&lt;/sup&gt; in 1990.</p>
</dd>
<dt>lnVol90</dt><dd><p>Natural logarithm of <code>Volume90</code>.</p>
</dd>
<dt>FCODE90</dt><dd><p>Equals 1 if flowering and 0 if not flowering in 1990.</p>
</dd>
<dt>Flow90</dt><dd><p>Number of flowers in 1990.</p>
</dd>
<dt>Intactseed90</dt><dd><p>NZumber of intact mature seeds produced in 1990.
Not always an integer, as in some cases seed number was estimated via 
linear modeling.</p>
</dd>
<dt>Dead1990</dt><dd><p>Marked as 1 if known to be dead in 1990.</p>
</dd>
<dt>Dormant1990</dt><dd><p>Marked as 1 if known to be alive but vegetatively 
dormant in 1990.</p>
</dd>
<dt>Missing1990</dt><dd><p>Marked as 1 if not found in 1990.</p>
</dd>
<dt>Seedling1990</dt><dd><p>Marked as 1, 2, or 3 if observed as a seedling in
year <em>t</em>. Numbers refer to certainty of assignment: 1 = certain 
that plant is a seedling in 1990, 2 = likely that plant is a seedling
in 1990, 3 = probable that plant is a seedling in 1990.</p>
</dd>
<dt>Volume91</dt><dd><p>Aboveground volume in mm&lt;sup&gt;3&lt;/sup&gt; in 1991.</p>
</dd>
<dt>lnVol91</dt><dd><p>Natural logarithm of <code>Volume91</code>.</p>
</dd>
<dt>FCODE91</dt><dd><p>Equals 1 if flowering and 0 if not flowering in 1991.</p>
</dd>
<dt>Flow91</dt><dd><p>Number of flowers in 1991.</p>
</dd>
<dt>Intactseed91</dt><dd><p>NZumber of intact mature seeds produced in 1991.
Not always an integer, as in some cases seed number was estimated via
linear modeling.</p>
</dd>
<dt>Dead1991</dt><dd><p>Marked as 1 if known to be dead in 1991.</p>
</dd>
<dt>Dormant1991</dt><dd><p>Marked as 1 if known to be alive but vegetatively 
dormant in 1991.</p>
</dd>
<dt>Missing1991</dt><dd><p>Marked as 1 if not found in 1991.</p>
</dd>
<dt>Seedling1991</dt><dd><p>Marked as 1, 2, or 3 if observed as a seedling 
in year <em>t</em>. Numbers refer to certainty of assignment: 
1 = certain that plant is a seedling in 1991, 2 = likely that plant 
is a seedling in 1991, 3 = probable that plant is a seedling in 
1991.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ehrlen, J. 2000. The dynamics of plant populations: does the 
history of individuals matter? <em>Ecology</em> 81(6):1675-1684.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET",
  juvcol = c("Seedling1988", "Seedling1989", "Seedling1990", "Seedling1991"),
  sizeacol = c("Volume88", "Volume89", "Volume90", "Volume91"),
  repstracol = c("FCODE88", "FCODE89", "FCODE90", "FCODE91"),
  fecacol = c("Intactseed88", "Intactseed89", "Intactseed90", "Intactseed91"),
  deadacol = c("Dead1988", "Dead1989", "Dead1990", "Dead1991"),
  nonobsacol = c("Dormant1988", "Dormant1989", "Dormant1990", "Dormant1991"),
  censorcol = c("Missing1988", "Missing1989", "Missing1990", "Missing1991"), 
  stageassign = lathframe, stagesize = "sizea",
  censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
ehrlen3mean$A[[1]]

lambda3(ehrlen3mean)
</code></pre>

<hr>
<h2 id='lmean'>Estimate Mean Projection Matrices</h2><span id='topic+lmean'></span>

<h3>Description</h3>

<p>Function <code>lmean()</code> estimates mean projection matrices as element-wise
arithmetic means. It produces <code>lefkoMat</code> objects if provided with them,
or single matrices in a simple one-element list if provided a list of
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmean(mats, matsout = NULL, force_sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmean_+3A_mats">mats</code></td>
<td>
<p>A <code>lefkoMat</code> object, or a list of square matrices of equal
dimension.</p>
</td></tr>
<tr><td><code id="lmean_+3A_matsout">matsout</code></td>
<td>
<p>A string identifying which means to estimate. Option
<code>"pop"</code> indicates population-level only, <code>"patch"</code> indicates
patch-level only, and <code>"all"</code> indicates that both patch- and
population-level means should be estimated. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="lmean_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A logical value identifying whether to output the mean
matrices in sparse format, if input as standard matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Yields a <code>lefkoMat</code> object with the following characteristics:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full mean projection matrices in order of sorted
populations, patches, and years. These are typically estimated as the sums
of the associated mean <code>U</code> and <code>F</code> matrices. All matrices output
in either the <code>matrix</code> class, or the <code>dgCMatrix</code> class.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of mean survival-transition matrices sorted as in <code>A</code>.
All matrices output in the <code>matrix</code> class.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of mean fecundity matrices sorted as in <code>A</code>. All
matrices output in the <code>matrix</code> class.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame showing the pairing of ahistorical stages used
to create historical stage pairs. Given if the MPM is historical.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame detailing the order of population, patch, and
year of each mean matrix. If <code>pop</code>, <code>patch</code>, or <code>year2</code> are
<code>NA</code> in the original <code>labels</code> set, then these will be re-labeled
as <code>A</code>, <code>1</code>, or <code>1</code>, respectively.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> mean matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input.
Only output from <code>lefkoMat</code> objects resulting from function-based
estimation.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input. Only output from <code>lefkoMat</code> objects
resulting from raw matrix estimation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

cyp2mean &lt;- lmean(cypmatrix2r)

</code></pre>

<hr>
<h2 id='logistic3'>Two-parameter logistic function</h2><span id='topic+logistic3'></span>

<h3>Description</h3>

<p>Function <code>logistic3()</code> creates a vector of values produced by the
logistic function as applied with a user-specified time lag. The logistic
function is given as 
<code class="reqn">\phi_{t+1} = \phi_t \lambda (1 - n_t / K)</code>. Here,
if no <code>separate_N</code> vector is provided, then <code class="reqn">n_t = \phi_t</code>. If
<code class="reqn">\lambda</code> is not provided, then it defaults to <code>1.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic3(
  start_value,
  alpha,
  beta = 0,
  lambda = 1,
  time_steps = 100L,
  time_lag = 1L,
  pre0_subs = FALSE,
  pre0_value = 0,
  substoch = 0L,
  separate_N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic3_+3A_start_value">start_value</code></td>
<td>
<p>A positive number to start the return vector in time 0.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_alpha">alpha</code></td>
<td>
<p>The carrying capacity K.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_beta">beta</code></td>
<td>
<p>If set to some positive number, then this number is the maximum
value of phi to enforce. Otherwise, equals <code>0</code> and enforces no limit.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_lambda">lambda</code></td>
<td>
<p>The value of the discrete population growth rate to use.
Equal to the natural logarithm of the instantaneous growth rate, r.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_time_steps">time_steps</code></td>
<td>
<p>The number of time steps to run the projection. Must be a
positive integer.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_time_lag">time_lag</code></td>
<td>
<p>A positive integer denoting the number of time steps back
for the value of phi in the logistic function.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_pre0_subs">pre0_subs</code></td>
<td>
<p>A logical value indicating whether to use a number other
than that given in <code>start_value</code> for values of phi lagged from times
prior to time 0.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_pre0_value">pre0_value</code></td>
<td>
<p>A positive number to use for phi lagged from times prior
to time 0. Only used if <code>pre0_subs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="logistic3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating the kind of substochasticity to
use. Values include: <code>0</code>, no substochasticity enforced (the default);
<code>1</code>, all numbers must be non-negative; and <code>2</code>, all numbers should
be forced to the interval [0, 1].</p>
</td></tr>
<tr><td><code id="logistic3_+3A_separate_n">separate_N</code></td>
<td>
<p>An optional numeric vector with values of N in each time,
if phi is to be treated as different from N in the logistic model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values showing values projected under the-
logistic function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial_run1 &lt;- logistic3(1, alpha = 5)
plot(trial_run1)

trial_run2 &lt;- logistic3(1, alpha = 5, beta = 5)
plot(trial_run2)

trial_run3 &lt;- logistic3(1, alpha = 100)
plot(trial_run3)

trial_run4 &lt;- logistic3(1, alpha = 100, beta = 50)
plot(trial_run4)

trial_run5 &lt;- logistic3(1, alpha = 500)
plot(trial_run5)

trial_run6 &lt;- logistic3(1, alpha = 500, beta = 501)
plot(trial_run6)

used_Ns &lt;- c(10, 15, 12, 14, 14, 150, 15, 1, 5, 7, 9, 14, 13, 16, 17, 19,
  25, 26)
trial_run7 &lt;- logistic3(1, alpha = 500, beta = 501, separate_N = used_Ns)
plot(trial_run7)

</code></pre>

<hr>
<h2 id='ltre3'>Conduct a Life Table Response Experiment</h2><span id='topic+ltre3'></span>

<h3>Description</h3>

<p><code>ltre3()</code> returns a set of matrices of one-way LTRE (life table response
experiment), stochastic LTRE (sLTRE) matrices, or small noise approximation
LTRE (sna-LTRE) contributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltre3(
  mats,
  refmats = NA,
  ref = NA,
  stochastic = FALSE,
  times = 10000,
  burnin = 3000,
  tweights = NA,
  sparse = "auto",
  seed = NA,
  append_mats = FALSE,
  sna_ltre = FALSE,
  tol = 1e-30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltre3_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_refmats">refmats</code></td>
<td>
<p>A reference lefkoMat object, or matrix, for use as the
control. Default is <code>NA</code>, which sets to the same object as <code>mats</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_ref">ref</code></td>
<td>
<p>A numeric value indicating which matrix or matrices in
<code>refmats</code> to use as the control. The numbers used must correspond to the
number of the matrices in the <code>labels</code> element of the associated
<code>lefkoMat</code> object. The default setting, <code>NA</code>, uses all entries in
<code>refmats</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value determining whether to conduct a
deterministic (<code>FALSE</code>) or stochastic (<code>TRUE</code>) elasticity analysis.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_times">times</code></td>
<td>
<p>The number of occasions to project forward in stochastic
simulation. Defaults to <code>10000</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_burnin">burnin</code></td>
<td>
<p>The number of initial steps to ignore in stochastic projection
when calculating stochastic elasticities. Must be smaller than <code>steps</code>.
Defaults to <code>3000</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices. Note that SNA-LTRE analysis cannot take matrix
input.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_seed">seed</code></td>
<td>
<p>Optional numeric value corresponding to the random seed for
stochastic simulation.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_append_mats">append_mats</code></td>
<td>
<p>A logical value denoting whether to include the original
<code>A</code>, <code>U</code>, and <code>F</code> matrices in the returned <code>lefkoLTRE</code>
object. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_sna_ltre">sna_ltre</code></td>
<td>
<p>A logical value indicating whether to treat stochastic LTRE
via the sna-LTRE approach from Davison et al. (2019) (<code>TRUE</code>), or the
stochastic LTRE approximation from Davison et al. (2010) (<code>FALSE</code>).
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_tol">tol</code></td>
<td>
<p>A numeric value indicating a lower positive limit to matrix
element values when applied to stochastic and small noise approximation LTRE
estimation protocols. Matrix element values lower than this will be treated
as <code>0.0</code> values. Defaults to <code>1e-30</code>.</p>
</td></tr>
<tr><td><code id="ltre3_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>lefkoLTRE</code>. This
includes a list of LTRE matrices as object <code>cont_mean</code> if a
deterministic LTRE is called for, or a list of mean-value LTRE matrices as
object <code>cont_mean</code> and a list of SD-value LTRE matrices as object
<code>cont_sd</code> if a stochastic LTRE is called for. If a small-noise
approximation LTRE (SNA-LTRE) is performed, then the output includes six
objects: <code>cont_mean</code>, which provides the contributions of shifts in mean
matrix elements; <code>cont_elas</code>, which provides the contributions of shifts
in the elasticities of matrix elements; <code>cont_cv</code>, which provides the
contributions of temporal variation in matrix elements; <code>cont_corr</code>,
which provides the contributions of temporal correlations in matrix elements;
<code>r_values_m</code>, which provides a vector of log deterministic lambda values
for treatment populations; and <code>r_values_ref</code>, which provides the log
deterministic lambda of the mean reference matrix.This is followed by the
stageframe as object <code>ahstages</code>, the order of historical stages as
object <code>hstages</code>, the age-by-stage order as object <code>agestages</code>, the
order of matrices as object <code>labels</code>, and, if requested, the original A,
U, and F matrices.
</p>


<h3>Notes</h3>

<p>Deterministic LTRE is one-way, fixed, and based on the sensitivities of the
matrix midway between each input matrix and the reference matrix, per Caswell
(2001, Matrix Population Models, Sinauer Associates, MA, USA). Stochastic
LTRE is performed via two methods. The stochastic LTRE approximation is
simulated per Davison et al. (2010) Journal of Ecology 98:255-267
(doi: 10.1111/j.1365-2745.2009.01611.x). The small noise approximation
(sna-LTRE) is analyzed per Davison et al. (2019) Ecological Modelling 408:
108760 (doi: 10.1016/j.ecolmodel.2019.108760).
</p>
<p>All stochastic and small noise approximation LTREs conducted without
reference matrices are performed as spatial tests of the population dynamics
among patches.
</p>
<p>Default behavior for stochastic LTRE uses the full population provided in
<code>mats</code> as the reference if no <code>refmats</code> and <code>ref</code> is provided.
If no <code>refmats</code> is provided but <code>ref</code> is, then the matrices noted
in <code>ref</code> are used as the reference matrix set. Year and patch order is
utilized from object <code>mats</code>, but not from object <code>refmats</code>, in
which each matrix is assumed to represent a different year from one
population. This function cannot currently handle multiple populations within
the same <code>mats</code> object (although such analysis is possible if these
populations are designated as patches instead).
</p>
<p>If <code>sparse = "auto"</code>, the default, then sparse matrix encoding
will be used if the size of the input matrices is at least 50 columns by 50
rows for deterministic and stochastic LTREs and 10 columns by 10 rows for
small noise approximation LTREs, in all cases as long as 50% of the elements
in the first matrix are non-zero.
</p>
<p>Stochastic LTREs do not test for the impact of temporal change in vital
rates. An MPM with a single population, a single patch, and only annual
matrices will produce contributions of 0 to stochastic <code class="reqn">\lambda</code>.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 10 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>SNA-LTRE analysis cannot test the impact of first-order Markovian
environments. However, different random weightings of annual matrices are
allowed if given in vector format.
</p>
<p>The <code>time_weights</code>, <code>steps</code>, <code>force_sparse</code>, and <code>rseed</code>
arguments are now deprecated. Instead, please use the <code>tweights</code>,
<code>times</code>, <code>sparse</code>, and <code>seed</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lefkoLTRE">summary.lefkoLTRE</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

ltre3(cypmatrix2r, sna_ltre = TRUE)

</code></pre>

<hr>
<h2 id='markov_run'>Creates Vector of Times Based on First-Order Markov Transition Matrix</h2><span id='topic+markov_run'></span>

<h3>Description</h3>

<p>Creates a vector of randomly sampled years / times to be used in projection.
Random sampling requires a 1st order Markovian transition matrix, showing
the probability of transitioning to each time from each time. Note that this
function is not required if the probability of transitioning to a particular
time does not vary with time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov_run(main_times, mat, times = 10000L, start = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markov_run_+3A_main_times">main_times</code></td>
<td>
<p>An integer vector giving the years / times to use.</p>
</td></tr>
<tr><td><code id="markov_run_+3A_mat">mat</code></td>
<td>
<p>A matrix giving the transition probabilities from each time to
each time. Must have the same number of columns and rows as there are
elements in vector <code>times</code>.</p>
</td></tr>
<tr><td><code id="markov_run_+3A_times">times</code></td>
<td>
<p>The number of times to project forward. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="markov_run_+3A_start">start</code></td>
<td>
<p>The start time to use. Defaults to the first time in vector
<code>main_times</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the order of times / years to use in
projection. This can be used as input in the <code>year</code> option in
functions <code><a href="#topic+projection3">projection3</a>()</code> and <code><a href="#topic+f_projection3">f_projection3</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projection3">projection3</a>()</code>
</p>
<p><code><a href="#topic+f_projection3">f_projection3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cypripedium example
data(cypdata)
 
sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"), 
  supplement = cypsupp3r, yearcol = "year2", indivcol = "individ")

used_years &lt;-c(2005, 2006, 2007, 2008)

yr_tx_vec &lt;- c(0.4, 0.2, 0.2, 0.2, 0.2, 0.4, 0.2, 0.2, 0.2, 0.2, 0.4, 0.2,
  0.2, 0.2, 0.2, 0.4)
yr_tx_mat &lt;- matrix(yr_tx_vec, 4, 4)

set.seed(1)
cyp_markov_vec_1 &lt;- markov_run(main_times = used_years, mat = yr_tx_mat,
  times = 100)

set.seed(2)
cyp_markov_vec_2 &lt;- markov_run(main_times = used_years, mat = yr_tx_mat,
  times = 100)

set.seed(3)
cyp_markov_vec_3 &lt;- markov_run(main_times = used_years, mat = yr_tx_mat,
  times = 100)

cypstoch_1 &lt;- projection3(cypmatrix3r, nreps = 1, times = 100,
  year = cyp_markov_vec_1)
cypstoch_2 &lt;- projection3(cypmatrix3r, nreps = 1, times = 100,
  year = cyp_markov_vec_2)
cypstoch_3 &lt;- projection3(cypmatrix3r, nreps = 1, times = 100,
  year = cyp_markov_vec_3)

</code></pre>

<hr>
<h2 id='matrix_interp'>Arranges Matrix Elements in Order of Magnitude for Interpretation</h2><span id='topic+matrix_interp'></span>

<h3>Description</h3>

<p>Function <code>matrix_interp</code> summarizes matrices from <code>lefkoMat</code>,
<code>lefkoSens</code>, <code>lefkoElas</code>, and <code>lefkoLTRE</code> objects in terms
of the magnitudes of their elements. It can also create ordered summaries of
standard matrices and sparse matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_interp(object, mat_chosen = 1L, part = 1L, type = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_interp_+3A_object">object</code></td>
<td>
<p>A list object in one of <code>lefko3</code>'s output formats, or a
standard matrix or sparse matrix in <code>dgCMatrix</code> format. Standard
<code>lefko3</code> output formats include <code>lefkoMat</code>, <code>lefkoSens</code>,
<code>lefkoElas</code>, and <code>lefkoLTRE</code> objects.</p>
</td></tr>
<tr><td><code id="matrix_interp_+3A_mat_chosen">mat_chosen</code></td>
<td>
<p>The number of the matrix to assess, within the appropriate
matrix list. See <code>Notes</code> for further details.</p>
</td></tr>
<tr><td><code id="matrix_interp_+3A_part">part</code></td>
<td>
<p>An integer noting whether to provide assessments of which of the
main types of matrices to analyze. In a standard <code>lefkoMat</code> object, the
integers <code>1</code>, <code>2</code>, and <code>3</code> correspond to the <code>A</code>,
<code>U</code>, and <code>F</code> lists, respectively. In <code>lefkoSens</code> and
<code>lefkoElas</code> objects, the integers <code>1</code> and <code>2</code> correspond to
the ahistorical matrix sets and the historical matrix sets, respectively.
In deterministic and stochastic <code>lefkoLTRE</code> objects, the integers
<code>1</code> and <code>2</code> correspond to the <code>cont_mean</code> and <code>cont_sd</code>
lists, respectively.</p>
</td></tr>
<tr><td><code id="matrix_interp_+3A_type">type</code></td>
<td>
<p>An integer corresponding to the type of order summary, including
most to least positive (<code>1</code>), most to least negative (<code>2</code>), and
greatest to lowest absolute magnitude (<code>3</code>). Defaults to type <code>3</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame arranging all elements in the matrix chosen from
greatest and smallest. This can be a data frame of only positive elements,
of only negative elements, or all elements in order of absolute magnitude.
</p>


<h3>Notes</h3>

<p>Argument <code>mat_chosen</code> refers to the number of the matrix within the
list that it is held in. For example, if the function is applied to the
<code>cont_sd</code> portion of a stochastic LTRE, and there are four LTRE
matrices within that list element corresponding to three patch LTRE matrices
and one overall population-level LTRE matrix, then setting this value to
<code>4</code> would focus the function on the overall population-level LTRE
matrix associated with contributions of the standard deviations of elements.
This argument should be left blank if a standard matrix or sparse matrix is
input.
</p>
<p>Huge sparse matrices may take more time to process than small, dense
matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

aaa &lt;- ltre3(cypmatrix2r, stochastic = TRUE)

matrix_interp(aaa, mat_chosen = 1, part = 2, type = 3)

</code></pre>

<hr>
<h2 id='modelsearch'>Develop Best-fit Vital Rate Estimation Models for MPM Development</h2><span id='topic+modelsearch'></span>

<h3>Description</h3>

<p>Function <code>modelsearch()</code> runs exhaustive model building and selection
for each vital rate needed to estimate a function-based MPM or IPM. It
returns best-fit models for each vital rate, model table showing all models
tested, and model quality control data. The final output can be used as input
in other functions within this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelsearch(
  data,
  stageframe = NULL,
  historical = TRUE,
  approach = "mixed",
  suite = "size",
  bestfit = "AICc&amp;k",
  vitalrates = c("surv", "size", "fec"),
  surv = c("alive3", "alive2", "alive1"),
  obs = c("obsstatus3", "obsstatus2", "obsstatus1"),
  size = c("sizea3", "sizea2", "sizea1"),
  sizeb = c(NA, NA, NA),
  sizec = c(NA, NA, NA),
  repst = c("repstatus3", "repstatus2", "repstatus1"),
  fec = c("feca3", "feca2", "feca1"),
  stage = c("stage3", "stage2", "stage1"),
  matstat = c("matstatus3", "matstatus2", "matstatus1"),
  indiv = "individ",
  patch = NA,
  year = "year2",
  density = NA,
  test.density = FALSE,
  sizedist = "gaussian",
  sizebdist = NA,
  sizecdist = NA,
  fecdist = "gaussian",
  size.zero = FALSE,
  sizeb.zero = FALSE,
  sizec.zero = FALSE,
  size.trunc = FALSE,
  sizeb.trunc = FALSE,
  sizec.trunc = FALSE,
  fec.zero = FALSE,
  fec.trunc = FALSE,
  patch.as.random = TRUE,
  year.as.random = TRUE,
  juvestimate = NA,
  juvsize = FALSE,
  jsize.zero = FALSE,
  jsizeb.zero = FALSE,
  jsizec.zero = FALSE,
  jsize.trunc = FALSE,
  jsizeb.trunc = FALSE,
  jsizec.trunc = FALSE,
  fectime = 2,
  censor = NA,
  age = NA,
  test.age = FALSE,
  indcova = NA,
  indcovb = NA,
  indcovc = NA,
  random.indcova = FALSE,
  random.indcovb = FALSE,
  random.indcovc = FALSE,
  test.indcova = FALSE,
  test.indcovb = FALSE,
  test.indcovc = FALSE,
  test.group = FALSE,
  show.model.tables = TRUE,
  global.only = FALSE,
  accuracy = TRUE,
  data_out = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelsearch_+3A_data">data</code></td>
<td>
<p>The vertical dataset to be used for analysis. This dataset should 
be of class <code>hfvdata</code>, but can also be a data frame formatted similarly
to the output format provided by functions <code><a href="#topic+verticalize3">verticalize3</a>()</code> or
<code><a href="#topic+historicalize3">historicalize3</a>()</code>, as long as all needed variables are properly
designated.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_stageframe">stageframe</code></td>
<td>
<p>The stageframe characterizing the life history model used.
Optional unless <code>test.group = TRUE</code>, in which case it is required.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_historical">historical</code></td>
<td>
<p>A logical variable denoting whether to assess the effects
of state in occasion <em>t</em>-1, in addition to state in occasion <em>t</em>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_approach">approach</code></td>
<td>
<p>The statistical approach to be taken for model building. The 
default is <code>"mixed"</code>, which uses the mixed model approach utilized in 
packages <code>lme4</code> and <code>glmmTMB</code>. Other options include <code>"glm"</code>,
which uses generalized linear modeling assuming that all factors are fixed.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_suite">suite</code></td>
<td>
<p>Either a single string value or a vector of 14 strings for each
vital rate model. Describes the global model for each vital rate estimation,
and has the following possible values: <code>full</code>, includes main effects and
all two-way interactions of size and reproductive status; <code>main</code>,
includes main effects only of size and reproductive status; <code>size</code>,
includes only size (also interactions between size in historical model);
<code>rep</code>, includes only reproductive status (also interactions between
status in historical model); <code>age</code>, all vital rates estimated with age
and y-intercepts only; <code>cons</code>, all vital rates estimated only as
y-intercepts. If <code>approach = "glm"</code> and <code>year.as.random = FALSE</code>,
then year is also included as a fixed effect, and, in the case of
<code>full</code>, included in two-way interactions. Order of models in the
string vector if more than 1 value is used is: 1) survival, 2) observation,
3) primary size, 4) secondary size, 5) tertiary size, 6) reproductive status,
7) fecundity, 8) juvenile survival, 9) juvenile observation, 10) juvenile
primary size, 11) juvenile secondary size, 12) juvenile tertiary size, 13)
juvenile reproductive status, and 14) juvenile maturity status. Defaults to
<code>size</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_bestfit">bestfit</code></td>
<td>
<p>A variable indicating the model selection criterion for the
choice of best-fit model. The default is <code>AICc&amp;k</code>, which chooses the 
best-fit model as the model with the lowest AICc or, if not the same model,
then the model that has the lowest degrees of freedom among models with
<code class="reqn">\Delta AICc &lt;= 2.0</code>. Alternatively, <code>AICc</code> may be chosen, in which
case the best-fit model is simply the model with the lowest AICc value.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_vitalrates">vitalrates</code></td>
<td>
<p>A vector describing which vital rates will be estimated via
linear modeling, with the following options: <code>surv</code>, survival
probability; <code>obs</code>, observation probability; <code>size</code>, overall size;
<code>repst</code>, probability of reproducing; and <code>fec</code>, amount of
reproduction (overall fecundity). May also be set to
<code>vitalrates = "leslie"</code>, which is equivalent to setting
<code>c("surv", "fec")</code> for a Leslie MPM. This choice also determines how
internal data subsetting for vital rate model estimation will work. Defaults
to <code>c("surv", "size", "fec")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_surv">surv</code></td>
<td>
<p>A vector indicating the variable names coding for status as alive
or dead in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("alive3", "alive2", "alive1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_obs">obs</code></td>
<td>
<p>A vector indicating the variable names coding for observation
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("obsstatus3", "obsstatus2", "obsstatus1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_size">size</code></td>
<td>
<p>A vector indicating the variable names coding for the primary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c("sizea3", "sizea2", "sizea1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector indicating the variable names coding for the secondary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c(NA, NA, NA)</code>, in which case <code>sizeb</code> is
not used.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizec">sizec</code></td>
<td>
<p>A vector indicating the variable names coding for the tertiary
size variable on occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c(NA, NA, NA)</code>, in which case <code>sizec</code> is
not used.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_repst">repst</code></td>
<td>
<p>A vector indicating the variable names coding for reproductive
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>c("repstatus3", "repstatus2", "repstatus1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_fec">fec</code></td>
<td>
<p>A vector indicating the variable names coding for fecundity in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to
<code>c("feca3", "feca2", "feca1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_stage">stage</code></td>
<td>
<p>A vector indicating the variable names coding for stage in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Defaults to
<code>c("stage3", "stage2", "stage1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_matstat">matstat</code></td>
<td>
<p>A vector indicating the variable names coding for maturity
status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Defaults to
<code>c("matstatus3", "matstatus2", "matstatus1")</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_indiv">indiv</code></td>
<td>
<p>A text value indicating the variable name coding individual
identity. Defaults to <code>"individ"</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_patch">patch</code></td>
<td>
<p>A text value indicating the variable name coding for patch,
where patches are defined as permanent subgroups within the study population.
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_year">year</code></td>
<td>
<p>A text value indicating the variable coding for observation
occasion <em>t</em>. Defaults to <code>year2</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_density">density</code></td>
<td>
<p>A text value indicating the name of the variable coding for
spatial density, should the user wish to test spatial density as a fixed
factor affecting vital rates. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.density">test.density</code></td>
<td>
<p>Either a logical value indicating whether to include
<code>density</code> as a fixed categorical variable in linear models, or a logical
vector of such values for 14 models, in order: 1) survival, 2) observation,
3) primary size, 4) secondary size, 5) tertiary size, 6) reproductive
status, 7) fecundity, 8) juvenile survival, 9) juvenile observation,
10) juvenile primary size, 11) juvenile secondary size, 12) juvenile
tertiary size, 13) juvenile reproductive status, and 14) juvenile maturity
status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizedist">sizedist</code></td>
<td>
<p>The probability distribution used to model primary size.
Options include <code>"gaussian"</code> for the Normal distribution (default),
<code>"poisson"</code> for the Poisson distribution, <code>"negbin"</code> for the
negative binomial distribution (quadratic parameterization), and 
<code>"gamma"</code> for the Gamma distribution.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizebdist">sizebdist</code></td>
<td>
<p>The probability distribution used to model secondary size.
Options include <code>"gaussian"</code> for the Normal distribution,
<code>"poisson"</code> for the Poisson distribution, <code>"negbin"</code> for the
negative binomial distribution (quadratic parameterization), and
<code>"gamma"</code> for the Gamma distribution. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizecdist">sizecdist</code></td>
<td>
<p>The probability distribution used to model tertiary size.
Options include <code>"gaussian"</code> for the Normal distribution,
<code>"poisson"</code> for the Poisson distribution, <code>"negbin"</code> for the
negative binomial distribution (quadratic parameterization), and
<code>"gamma"</code> for the Gamma distribution. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_fecdist">fecdist</code></td>
<td>
<p>The probability distribution used to model fecundity. Options
include <code>"gaussian"</code> for the Normal distribution (default),
<code>"poisson"</code> for the Poisson distribution, <code>"negbin"</code> for the
negative binomial distribution (quadratic parameterization), and
<code>"gamma"</code> for the Gamma distribution.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_size.zero">size.zero</code></td>
<td>
<p>A logical variable indicating whether the primary size
distribution should be zero-inflated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizeb.zero">sizeb.zero</code></td>
<td>
<p>A logical variable indicating whether the secondary size
distribution should be zero-inflated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizec.zero">sizec.zero</code></td>
<td>
<p>A logical variable indicating whether the tertiary size
distribution should be zero-inflated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_size.trunc">size.trunc</code></td>
<td>
<p>A logical variable indicating whether the primary size
distribution should be zero-truncated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>. Cannot be <code>TRUE</code> if
<code>size.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizeb.trunc">sizeb.trunc</code></td>
<td>
<p>A logical variable indicating whether the secondary size
distribution should be zero-truncated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>. Cannot be <code>TRUE</code> if
<code>sizeb.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_sizec.trunc">sizec.trunc</code></td>
<td>
<p>A logical variable indicating whether the tertiary size
distribution should be zero-truncated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>. Cannot be <code>TRUE</code> if
<code>sizec.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_fec.zero">fec.zero</code></td>
<td>
<p>A logical variable indicating whether the fecundity
distribution should be zero-inflated. Only applies to Poisson and negative
binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_fec.trunc">fec.trunc</code></td>
<td>
<p>A logical variable indicating whether the fecundity
distribution should be zero-truncated. Only applies to the Poisson and
negative binomial distributions. Defaults to <code>FALSE</code>. Cannot be
<code>TRUE</code> if <code>fec.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_patch.as.random">patch.as.random</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>approach = "mixed"</code>,
then <code>patch</code> is included as a random factor. If set to <code>FALSE</code> and
<code>approach = "glm"</code>, then <code>patch</code> is included as a fixed factor. All
other combinations of logical value and <code>approach</code> lead to <code>patch</code>
not being included in modeling. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_year.as.random">year.as.random</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>approach = "mixed"</code>,
then <code>year</code> is included as a random factor. If set to <code>FALSE</code>, then
<code>year</code> is included as a fixed factor. All other combinations of logical
value and <code>approach</code> lead to <code>year</code> not being included in modeling.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_juvestimate">juvestimate</code></td>
<td>
<p>An optional variable denoting the stage name of the
juvenile stage in the vertical dataset. If not <code>NA</code>, and <code>stage</code> is
also given (see below), then vital rates listed in <code>vitalrates</code> other
than <code>fec</code> will also be estimated from the juvenile stage to all adult
stages. Defaults to <code>NA</code>, in which case juvenile vital rates are not
estimated.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_juvsize">juvsize</code></td>
<td>
<p>A logical variable denoting whether size should be used as a
term in models involving transition from the juvenile stage. Defaults to
<code>FALSE</code>, and is only used if <code>juvestimate</code> does not equal
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsize.zero">jsize.zero</code></td>
<td>
<p>A logical variable indicating whether the primary size
distribution of juveniles should be zero-inflated. Only applies to Poisson
and negative binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsizeb.zero">jsizeb.zero</code></td>
<td>
<p>A logical variable indicating whether the secondary size
distribution of juveniles should be zero-inflated. Only applies to Poisson
and negative binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsizec.zero">jsizec.zero</code></td>
<td>
<p>A logical variable indicating whether the tertiary size
distribution of juveniles should be zero-inflated. Only applies to Poisson
and negative binomial distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsize.trunc">jsize.trunc</code></td>
<td>
<p>A logical variable indicating whether the primary size
distribution in juveniles should be zero-truncated. Defaults to <code>FALSE</code>.
Cannot be <code>TRUE</code> if <code>jsize.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsizeb.trunc">jsizeb.trunc</code></td>
<td>
<p>A logical variable indicating whether the secondary size
distribution in juveniles should be zero-truncated. Defaults to <code>FALSE</code>.
Cannot be <code>TRUE</code> if <code>jsizeb.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_jsizec.trunc">jsizec.trunc</code></td>
<td>
<p>A logical variable indicating whether the tertiary size
distribution in juveniles should be zero-truncated. Defaults to <code>FALSE</code>.
Cannot be <code>TRUE</code> if <code>jsizec.zero = TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_fectime">fectime</code></td>
<td>
<p>A variable indicating which year of fecundity to use as the
response term in fecundity models. Options include <code>2</code>, which refers to
occasion <em>t</em>, and <code>3</code>, which refers to occasion <em>t</em>+1.
Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_censor">censor</code></td>
<td>
<p>A vector denoting the names of censoring variables in the
dataset, in order from occasion <em>t</em>+1, followed by occasion <em>t</em>,
and lastly followed by occasion <em>t</em>-1. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_age">age</code></td>
<td>
<p>Designates the name of the variable corresponding to age in time
<em>t</em> in the vertical dataset. Defaults to <code>NA</code>, in which case age
is not included in linear models. Should only be used if building Leslie or
age x stage matrices.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.age">test.age</code></td>
<td>
<p>Either a logical value indicating whether to include
<code>age</code> as a fixed categorical variable in linear models, or a logical
vector of such values for 14 models, in order: 1) survival, 2) observation,
3) primary size, 4) secondary size, 5) tertiary size, 6) reproductive
status, 7) fecundity, 8) juvenile survival, 9) juvenile observation,
10) juvenile primary size, 11) juvenile secondary size, 12) juvenile
tertiary size, 13) juvenile reproductive status, and 14) juvenile maturity
status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_indcova">indcova</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of an individual covariate. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_indcovb">indcovb</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of a second individual covariate. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_indcovc">indcovc</code></td>
<td>
<p>Vector designating the names in occasions <em>t</em>+1,
<em>t</em>, and <em>t</em>-1 of a third individual covariate. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_random.indcova">random.indcova</code></td>
<td>
<p>A logical value indicating whether <code>indcova</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_random.indcovb">random.indcovb</code></td>
<td>
<p>A logical value indicating whether <code>indcovb</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_random.indcovc">random.indcovc</code></td>
<td>
<p>A logical value indicating whether <code>indcovc</code>
should be treated as a random categorical factor, rather than as a fixed
factor. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.indcova">test.indcova</code></td>
<td>
<p>Either a logical value indicating whether to include the
<code>indcova</code> variable as a fixed categorical variable in linear models, or
a logical vector of such values for 14 models, in order: 1) survival,
2) observation, 3) primary size, 4) secondary size, 5) tertiary size,
6) reproductive status, 7) fecundity, 8) juvenile survival, 9) juvenile
observation, 10) juvenile primary size, 11) juvenile secondary size,
12) juvenile tertiary size, 13) juvenile reproductive status, and
14) juvenile maturity status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.indcovb">test.indcovb</code></td>
<td>
<p>Either a logical value indicating whether to include the
<code>indcovb</code> variable as a fixed categorical variable in linear models, or
a logical vector of such values for 14 models, in order: 1) survival,
2) observation, 3) primary size, 4) secondary size, 5) tertiary size,
6) reproductive status, 7) fecundity, 8) juvenile survival, 9) juvenile
observation, 10) juvenile primary size, 11) juvenile secondary size,
12) juvenile tertiary size, 13) juvenile reproductive status, and
14) juvenile maturity status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.indcovc">test.indcovc</code></td>
<td>
<p>Either a logical value indicating whether to include the
<code>indcovc</code> variable as a fixed categorical variable in linear models, or
a logical vector of such values for 14 models, in order: 1) survival,
2) observation, 3) primary size, 4) secondary size, 5) tertiary size,
6) reproductive status, 7) fecundity, 8) juvenile survival, 9) juvenile
observation, 10) juvenile primary size, 11) juvenile secondary size,
12) juvenile tertiary size, 13) juvenile reproductive status, and
14) juvenile maturity status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_test.group">test.group</code></td>
<td>
<p>Either a logical value indicating whether to include the
<code>group</code> variable from the input <code>stageframe</code> as a fixed categorical
variable in linear models, or a logical vector of such values for 14 models,
in order: 1) survival, 2) observation, 3) primary size, 4) secondary size,
5) tertiary size, 6) reproductive status, 7) fecundity, 8) juvenile survival,
9) juvenile observation, 10) juvenile primary size, 11) juvenile secondary
size, 12) juvenile tertiary size, 13) juvenile reproductive status, and
14) juvenile maturity status. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_show.model.tables">show.model.tables</code></td>
<td>
<p>If set to TRUE, then includes full modeling tables
in the output. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_global.only">global.only</code></td>
<td>
<p>If set to TRUE, then only global models will be built and
evaluated. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_accuracy">accuracy</code></td>
<td>
<p>A logical value indicating whether to test accuracy of
models. See <code>Notes</code> section for details on how accuracy is assessed.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_data_out">data_out</code></td>
<td>
<p>A logical value indicating whether to append all subsetted
datasets used in model building and selection to the output. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_quiet">quiet</code></td>
<td>
<p>May be a logical value, or any one of the strings <code>"yes"</code>,
<code>"no"</code>, or <code>"partial"</code>. If set to <code>TRUE</code> or <code>"yes"</code>, then
model building and selection will proceed with most warnings and diagnostic
messages silenced. If set to <code>FALSE</code> or <code>"no"</code>, then all warnings
and diagnostic messages will be displayed. If set to <code>"partial"</code>, then
only messages related to transitions between different vital rate models will
be displayed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function yields an object of class <code>lefkoMod</code>, which is a
list in which the first 14 elements are the best-fit models for survival,
observation status, primary size, secondary size, tertiary size,
reproductive status, fecundity, juvenile survival, juvenile observation,
juvenile primary size, juvenile secondary size, juvenile tertiary size,
juvenile transition to reproduction, and juvenile transition to maturity,
respectively. This is followed by 14 elements corresponding to the model
tables for each of these vital rates, in order, followed by a data frame
showing the order and names of variables used in modeling, followed by a
single character element denoting the criterion used for model selection, and
ending on a data frame with quality control data:
</p>
<table>
<tr><td><code>survival_model</code></td>
<td>
<p>Best-fit model of the binomial probability of survival
from occasion <em>t</em> to occasion <em>t</em>+1. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>observation_model</code></td>
<td>
<p>Best-fit model of the binomial probability of 
observation in occasion <em>t</em>+1 given survival to that occasion. Defaults
to <code>1</code>.</p>
</td></tr>
<tr><td><code>size_model</code></td>
<td>
<p>Best-fit model of the primary size metric on occasion
<em>t</em>+1 given survival to and observation in that occasion. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code>sizeb_model</code></td>
<td>
<p>Best-fit model of the secondary size metric on occasion
<em>t</em>+1 given survival to and observation in that occasion. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code>sizec_model</code></td>
<td>
<p>Best-fit model of the tertiary size metric on occasion
<em>t</em>+1 given survival to and observation in that occasion. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code>repstatus_model</code></td>
<td>
<p>Best-fit model of the binomial probability of
reproduction in occasion <em>t</em>+1, given survival to and observation in
that occasion. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>fecundity_model</code></td>
<td>
<p>Best-fit model of fecundity in occasion <em>t</em>+1
given survival to, and observation and reproduction in that occasion.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_survival_model</code></td>
<td>
<p>Best-fit model of the binomial probability of
survival from occasion <em>t</em> to occasion <em>t</em>+1 of an immature
individual. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_observation_model</code></td>
<td>
<p>Best-fit model of the binomial probability of 
observation in occasion <em>t</em>+1 given survival to that occasion of an
immature individual. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_size_model</code></td>
<td>
<p>Best-fit model of the primary size metric on occasion
<em>t</em>+1 given survival to and observation in that occasion of an immature
individual. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_sizeb_model</code></td>
<td>
<p>Best-fit model of the secondary size metric on
occasion <em>t</em>+1 given survival to and observation in that occasion of an
immature individual. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_sizec_model</code></td>
<td>
<p>Best-fit model of the tertiary size metric on occasion
<em>t</em>+1 given survival to and observation in that occasion of an immature
individual. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_reproduction_model</code></td>
<td>
<p>Best-fit model of the binomial probability of
reproduction in occasion <em>t</em>+1, given survival to and observation in
that occasion of an individual that was immature in occasion <em>t</em>. This
model is technically not a model of reproduction probability for individuals
that are immature, rather reproduction probability here is given for
individuals that are mature in occasion <em>t</em>+1 but immature in occasion
<em>t</em>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>juv_maturity_model</code></td>
<td>
<p>Best-fit model of the binomial probability of
becoming mature in occasion <em>t</em>+1, given survival to that occasion of an
individual that was immature in occasion <em>t</em>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code>survival_table</code></td>
<td>
<p>Full dredge model table of survival probability.</p>
</td></tr>
<tr><td><code>observation_table</code></td>
<td>
<p>Full dredge model table of observation probability.</p>
</td></tr>
<tr><td><code>size_table</code></td>
<td>
<p>Full dredge model table of the primary size variable.</p>
</td></tr>
<tr><td><code>sizeb_table</code></td>
<td>
<p>Full dredge model table of the secondary size variable.</p>
</td></tr>
<tr><td><code>sizec_table</code></td>
<td>
<p>Full dredge model table of the tertiary size variable.</p>
</td></tr>
<tr><td><code>repstatus_table</code></td>
<td>
<p>Full dredge model table of reproduction probability.</p>
</td></tr>
<tr><td><code>fecundity_table</code></td>
<td>
<p>Full dredge model table of fecundity.</p>
</td></tr>
<tr><td><code>juv_survival_table</code></td>
<td>
<p>Full dredge model table of immature survival 
probability.</p>
</td></tr>
<tr><td><code>juv_observation_table</code></td>
<td>
<p>Full dredge model table of immature observation
probability.</p>
</td></tr>
<tr><td><code>juv_size_table</code></td>
<td>
<p>Full dredge model table of primary size in immature
individuals.</p>
</td></tr>
<tr><td><code>juv_sizeb_table</code></td>
<td>
<p>Full dredge model table of secondary size in immature
individuals.</p>
</td></tr>
<tr><td><code>juv_sizec_table</code></td>
<td>
<p>Full dredge model table of tertiary size in immature
individuals.</p>
</td></tr>
<tr><td><code>juv_reproduction_table</code></td>
<td>
<p>Full dredge model table of immature
reproduction probability.</p>
</td></tr>
<tr><td><code>juv_maturity_table</code></td>
<td>
<p>Full dredge model table of the probability of
an immature individual transitioning to maturity.</p>
</td></tr>
<tr><td><code>paramnames</code></td>
<td>
<p>A data frame showing the names of variables from the input
data frame used in modeling, their associated standardized names in linear
models, and a brief comment describing each variable.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Character variable denoting the criterion used to determine
the best-fit model.</p>
</td></tr>
<tr><td><code>qc</code></td>
<td>
<p>Data frame with five variables: 1) Name of vital rate, 2) number
of individuals used to model that vital rate, 3) number of individual
transitions used to model that vital rate, 4) parameter distribution used to
model the vital rats, and 5) accuracy of model, given as detailed in Notes
section.</p>
</td></tr>
<tr><td><code>subdata</code></td>
<td>
<p>An optional list of data frames, each of which is the data
frame used to develop each model in the <code>lefkoMod</code> object, in order.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>When <code>modelsearch()</code> is called, it first trims the dataset down to just
the variables that will be used (including all response terms and independent
variables). It then subsets the data to only complete cases for those
variables. Next, it builds global models for all vital rates, and runs them.
If a global model fails, then the function proceeds by dropping terms. If
<code>approach = "mixed"</code>, then it will determine which random factor term
contains the most categories in the respective subset, and drop that term.
If this fails, or if <code>approach = "glm"</code>, then it will drop any two-way
interactions and run the model. If this fails, then the function will attempt
to drop further terms, first patch alone, then year alone, then individual
covariates by themselves, then combinations of these four, and finally
individual identity. If all of these attempts fail and the approach used is
<code>mixed</code>, then the function will try running a glm version of the
original failed model. Finally, if all attempts fail, then the function
displays a warning and returns <code>1</code> to allow model building assuming a
constant rate or probability.
</p>
<p>Setting <code>suite = "cons"</code> prevents the inclusion of size and reproductive
status as fixed, independent factors in modeling. However, it does not
prevent any other terms from being included. Density, age, individual
covariates, individual identity, patch, and year may all be included.
</p>
<p>The mechanics governing model building are fairly robust to errors and
exceptions. The function attempts to build global models, and simplifies
models automatically should model building fail. Model building proceeds
through the functions <code><a href="stats.html#topic+lm">lm</a>()</code> (GLM with Gaussian response),
<code><a href="stats.html#topic+glm">glm</a>()</code> (GLM with Poisson, Gamma, or binomial response),
<code><a href="MASS.html#topic+glm.nb">glm.nb</a>()</code> (GLM with negative binomial response),
<code><a href="pscl.html#topic+zeroinfl">zeroinfl</a>()</code> (GLM with zero-inflated Poisson or negative
binomial response), <code><a href="VGAM.html#topic+vglm">vglm</a>()</code> (GLM with zero-truncated
Poisson or negative binomial response), <code><a href="lme4.html#topic+lmer">lmer</a>()</code> (mixed
model with Gaussian response), <code><a href="lme4.html#topic+glmer">glmer</a>()</code> (mixed model with
binomial, Poisson, or Gamma response), and <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a>()</code>
(mixed model with negative binomial, or zero-truncated or zero-inflated
Poisson or negative binomial response). See documentation related to these
functions for further information. Any response term that is invariable in
the dataset will lead to a best-fit model for that response represented by a
single constant value.
</p>
<p>Exhaustive model building and selection proceeds via the
<code><a href="MuMIn.html#topic+dredge">dredge</a>()</code> function in package <code>MuMIn</code>. This function
is verbose, so that any errors and warnings developed during model building,
model analysis, and model selection can be found and dealt with.
Interpretations of errors during global model analysis may be found in
documentation for the functions and packages mentioned. Package <code>MuMIn</code>
is used for model dredging (see <a href="MuMIn.html#topic+dredge">dredge</a>()), and errors and
warnings during dredging can be interpreted using the documentation for that
package. Errors occurring during dredging lead to the adoption of the global
model as the best-fit, and the user should view all logged errors and
warnings to determine the best way to proceed. The <code>quiet = TRUE</code> and
<code>quiet = "partial"</code> options can be used to silence dredge warnings, but
users should note that automated model selection can be viewed as a black
box, and so care should be taken to ensure that the models run make
biological sense, and that model quality is prioritized.
</p>
<p>Exhaustive model selection through dredging works best with larger datasets
and fewer tested parameters. Setting <code>suite = "full"</code> may initiate a
dredge that takes a dramatically long time, particularly if the model is
historical, individual covariates are used, or a zero-inflated distribution
is assumed. In such cases, the number of models built and tested will run at
least in the millions. Small datasets will also increase the error associated
with these tests, leading to adoption of simpler models overall. Note also
that zero-inflated models are processed as two models, and so include twice
the assumed number of parameters. If <code>suite = "full"</code>, then this
function will switch to a main effects global model for the zero-inflated
parameter models if the total number of parameters to test rises above the
limits imposed by the <code><a href="MuMIn.html#topic+dredge">dredge</a>()</code> function in package
<code>MuMIn</code>.
</p>
<p>Accuracy of vital rate models is calculated differently depending on vital
rate and assumed distribution. For all vital rates assuming a binomial
distribution, including survival, observation status, reproductive status,
and juvenile version of these, accuracy is calculated as the percent of
predicted responses equal to actual responses. In all other models, accuracy
is actually assessed as a simple R-squared in which the observed response
values per data subset are compared to the predicted response values
according to each best-fit model. Note that some situations in which factor
variables are used may result in failure to assess accuracy. In these cases,
function <code>modelsearch()</code> simply yields <code>NA</code> values.
</p>
<p>Care must be taken to build models that test the impacts of state in occasion
<em>t</em>-1 for historical models, and that do not test these impacts for
ahistorical models. Ahistorical matrix modeling particularly will yield
biased transition estimates if historical terms from models are ignored. This
can be dealt with at the start of modeling by setting 
<code>historical = FALSE</code> for the ahistorical case, and 
<code>historical = TRUE</code> for the historical case.
</p>
<p>This function handles generalized linear models (GLMs) under zero-inflated
distributions using the <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a>()</code> function, and zero-
truncated distributions using the <code><a href="VGAM.html#topic+vglm">vglm</a>()</code> function. Model
dredging may fail with these functions, leading to the global model being
accepted as the best-fit model. However, model dredges of mixed models work
for all distributions. We encourage the use of mixed models in all cases.
</p>
<p>The negative binomial and truncated negative binomial distributions use the
quadratic structure emphasized in Hardin and Hilbe (2018, 4th Edition of
Generalized Linear Models and Extensions). The truncated negative binomial
distribution may fail to predict size probabilities correctly when dispersion
is near that expected of the Poisson distribution. To prevent this problem,
we have integrated a cap on the overdispersion parameter. However, when using
this distribution, please check the matrix column sums to make sure that they
do not predict survival greater than 1.0. If they do, then please use either
the negative binomial distribution or the zero-truncated Poisson
distribution.
</p>
<p>If density dependence is explored through function <code>modelsearch()</code>,
then the interpretation of density is not the full population size but rather
the spatial density term included in the dataset.
</p>
<p>Users building vital rate models for Leslie matrices must set
<code>vitalrates = c("surv", "fec")</code> or <code>vitalrates = "leslie"</code> rather
than the default, because only survival and fecundity should be estimated in
these cases. Also, the <code>suite</code> setting can be set to either <code>age</code>
or <code>cons</code>, as the results will be exactly the same.
</p>
<p>Users wishing to test age, density, group, or individual covariates, must
include <code>test.age = TRUE</code>, <code>test.density = TRUE</code>,
<code>test.group = TRUE</code>, or <code>test.indcova = TRUE</code> (or
<code>test.indcovb = TRUE</code> or <code>test.indcovc = TRUE</code>, whichever is most
appropriate), respectively, in addition to stipulating the name of the
variable within the dataset. The default for these options is always
<code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathmodelsln3 &lt;- modelsearch(lathvertln, historical = TRUE, 
  approach = "mixed", suite = "main", 
  vitalrates = c("surv", "obs", "size", "repst", "fec"), juvestimate = "Sdl",
  bestfit = "AICc&amp;k", sizedist = "gaussian", fecdist = "poisson", 
  indiv = "individ", patch = "patchid", year = "year2",year.as.random = TRUE,
  patch.as.random = TRUE, show.model.tables = TRUE, quiet = "partial")

# Here we use supplemental() to provide overwrite and reproductive info
lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "Sdl", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "Sd", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  eststage1 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframeln, historical = TRUE)

lathmat3ln &lt;- flefko3(year = "all", patch = "all", stageframe = lathframeln, 
  modelsuite = lathmodelsln3, data = lathvertln, supplement = lathsupp3, 
  reduce = FALSE)


</code></pre>

<hr>
<h2 id='mpm_create'>General Matrix Projection Model Creation</h2><span id='topic+mpm_create'></span>

<h3>Description</h3>

<p>Function <code>mpm_create()</code> is the core workhorse function that creates
all flavors of MPM in <code>lefko3</code>. All other MPM creation functions act
as wrappers for this function. As such, this function provides the most
general and most detailed control over the MPM creation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpm_create(
  historical = FALSE,
  stage = TRUE,
  age = FALSE,
  devries = FALSE,
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  data = NULL,
  year = NULL,
  pop = NULL,
  patch = NULL,
  stageframe = NULL,
  supplement = NULL,
  overwrite = NULL,
  repmatrix = NULL,
  alive = NULL,
  obsst = NULL,
  size = NULL,
  sizeb = NULL,
  sizec = NULL,
  repst = NULL,
  matst = NULL,
  fec = NULL,
  stages = NULL,
  yearcol = NULL,
  popcol = NULL,
  patchcol = NULL,
  indivcol = NULL,
  agecol = NULL,
  censorcol = NULL,
  modelsuite = NULL,
  paramnames = NULL,
  inda = NULL,
  indb = NULL,
  indc = NULL,
  dev_terms = NULL,
  density = NA_real_,
  CDF = TRUE,
  random_inda = FALSE,
  random_indb = FALSE,
  random_indc = FALSE,
  negfec = FALSE,
  exp_tol = 700L,
  theta_tol = 100000000L,
  censor = FALSE,
  censorkeep = NULL,
  start_age = NA_integer_,
  last_age = NA_integer_,
  fecage_min = NA_integer_,
  fecage_max = NA_integer_,
  fectime = 2L,
  fecmod = 1,
  cont = TRUE,
  prebreeding = TRUE,
  stage_NRasRep = FALSE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpm_create_+3A_historical">historical</code></td>
<td>
<p>A logical value indicating whether to build a historical
MPM. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_stage">stage</code></td>
<td>
<p>A logical value indicating whether to build a stage-based MPM.
If both <code>stage = TRUE</code> and <code>age = TRUE</code>, then will proceed to
build an age-by-stage MPM. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_age">age</code></td>
<td>
<p>A logical value indicating whether to build an age-based MPM. If
both <code>stage = TRUE</code> and <code>age = TRUE</code>, then will proceed to build
an age-by-stage MPM. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_devries">devries</code></td>
<td>
<p>A logical value indicating whether to use deVries format
for historical MPMs. Defaults to <code>FALSE</code>, in which case historical MPMs
are created in Ehrlen format.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove ages, ahistorical
stages, or historical stages associated exclusively with zero transitions.
These are removed only if the respective row and column sums in ALL matrices
estimated equal 0. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_data">data</code></td>
<td>
<p>A data frame of class <code>hfvdata</code>. Required for all MPMs,
except for function-based MPMs in which <code>modelsuite</code> is set to a
<code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set of
such values, given in values associated with the <code>year</code> term used in
vital rate model development. Can also equal <code>"all"</code>, in which case
matrices will be estimated for all occasions. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_pop">pop</code></td>
<td>
<p>A variable designating which populations will have matrices
estimated. Should be set to specific population names, or to <code>"all"</code> if
all populations should have matrices estimated. Only used in raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to <code>"all"</code>
if matrices should be estimated for all patches. Defaults to <code>NULL</code>, in
which case patch designations are ignored.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_stageframe">stageframe</code></td>
<td>
<p>An object of class <code>stageframe</code>. These objects are
generated by function <code><a href="#topic+sf_create">sf_create</a>()</code>, and include information on
the size, observation status, propagule status, reproduction status,
immaturity status, maturity status, stage group, size bin widths, and other
key characteristics of each ahistorical stage. Not needed for purely
age-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function. Can be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of <code>0</code>s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with <code>1</code> equaling full fecundity). If left
blank, and no <code>supplement</code> is provided, then all stages marked as
reproductive produce offspring at 1x that of estimated fecundity, and that
offspring production will yield the first stage noted as propagule or
immature. May be the dimensions of either a historical or an ahistorical
matrix. If the latter, then all stages will be used in occasion <em>t</em>-1
for each suggested ahistorical transition. Not used in purely age-based
MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_alive">alive</code></td>
<td>
<p>A vector of names of binomial variables corresponding to status
as alive (<code>1</code>) or dead (<code>0</code>) in occasions <em>t</em>+1, <em>t</em>,
and <em>t</em>-1, respectively. Defaults to 
<code>c("alive3", "alive2", "alive1")</code> for historical MPMs, and
<code>c("alive3", "alive2")</code> for ahistorical MPMs. Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_obsst">obsst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
observation status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c("obsstatus3", "obsstatus2", "obsstatus1")</code>
for historical MPMs, and <code>c("obsstatus3", "obsstatus2")</code> for
ahistorical MPMs. Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_size">size</code></td>
<td>
<p>A vector of names of variables coding the primary size variable
in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to 
<code>c("sizea3", "sizea2", "sizea1")</code> for historical MPMs, and
<code>c("sizea3", "sizea2")</code> for ahistorical MPMs. Only needed for raw,
stage-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector of names of variables coding the secondary size
variable in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to an empty set, assuming that secondary size is not used. Only
needed for raw, stage-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_sizec">sizec</code></td>
<td>
<p>A vector of names of variables coding the tertiary size
variable in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to an empty set, assuming that tertiary size is not used. Only
needed for raw, stage-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_repst">repst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
reproductive status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c("repstatus3", "repstatus2", "repstatus1")</code>
for historical MPMs, and <code>c("repstatus3", "repstatus2")</code> for
ahistorical MPMs. Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_matst">matst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
maturity status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>c("matstatus3", "matstatus2", "matstatus1")</code>
for historical MPMs, and <code>c("matstatus3", "matstatus2")</code> for
ahistorical MPMs. Must be provided if building raw MPMs, and <code>stages</code>
is not provided.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_fec">fec</code></td>
<td>
<p>A vector of names of variables coding for fecundity in occasions
<em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to
<code>c("feca3", "feca2", "feca1")</code> for historical MPMs, and
<code>c("feca3", "feca2")</code> for ahistorical MPMs. Only needed for raw,
stage-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_stages">stages</code></td>
<td>
<p>An optional vector denoting the names of the variables within
the main vertical dataset coding for the stages of each individual in
occasions <em>t</em>+1 and <em>t</em>, and <em>t</em>-1, if historical. The names
of stages in these variables should match those used in the
<code>stageframe</code> exactly. If left blank, then <code>rlefko3()</code> will attempt
to infer stages by matching values of <code>alive</code>, <code>obsst</code>,
<code>size</code>, <code>sizev</code>, <code>sizec</code>, <code>repst</code>, and <code>matst</code> to
characteristics noted in the associated <code>stageframe</code>. Only used in raw,
stage-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_yearcol">yearcol</code></td>
<td>
<p>The variable name or column number corresponding to occasion
<em>t</em> in the dataset. Defaults to <code>"year2"</code>. Only needed for raw
MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_popcol">popcol</code></td>
<td>
<p>The variable name or column number corresponding to the
identity of the population. Defaults to <code>"popid"</code> if a value is
provided for <code>pop</code>; otherwise empty. Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_patchcol">patchcol</code></td>
<td>
<p>The variable name or column number corresponding to patch in 
the dataset. Defaults to <code>"patchid"</code> if a value is provided for
<code>patch</code>; otherwise empty.  Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_indivcol">indivcol</code></td>
<td>
<p>The variable name or column number coding individual
identity. Only needed for raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_agecol">agecol</code></td>
<td>
<p>The variable name or column corresponding to age in time
<em>t</em>. Defaults to <code>"obsage"</code>. Only used in raw age-based and
age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_censorcol">censorcol</code></td>
<td>
<p>The variable name or column number denoting the censor
status. Only needed in raw MPMs, and only if <code>censor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_modelsuite">modelsuite</code></td>
<td>
<p>One of three kinds of lists. The first is a
<code>lefkoMod</code> object holding the vital rate models and associated
metadata. Alternatively, an object of class <code>vrm_input</code> may be
provided. Finally, this argument may simply be a list of models used to
parameterize the MPM. In the final scenario, <code>data</code> and
<code>paramnames</code> must also be given, and all variable names must match
across all objects. If entered, then a function-based MPM will be developed.
Otherwise, a raw MPM will be developed. Only used in function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_paramnames">paramnames</code></td>
<td>
<p>A data frame with three columns, the first describing all
terms used in linear modeling, the second (must be called <code>mainparams</code>)
giving the general model terms that will be used in matrix creation, and the
third showing the equivalent terms used in modeling (must be named
<code>modelparams</code>). Function <code><a href="#topic+create_pm">create_pm</a>()</code> can be used to
create a skeleton <code>paramnames</code> object, which can then be edited. Only
required to build function-based MPMs if <code>modelsuite</code> is neither a
<code>lefkoMod</code> object nor a <code>vrm_input</code> object.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_inda">inda</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>a</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1
in historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_indb">indb</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>b</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1
in historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_indc">indc</code></td>
<td>
<p>Can be a single value to use for individual covariate <code>c</code>
in all matrices, a pair of values to use for times <em>t</em> and <em>t</em>-1
in historical matrices, or a vector of such values corresponding to each
occasion in the dataset. Defaults to <code>NULL</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_dev_terms">dev_terms</code></td>
<td>
<p>A numeric vector of 2 elements in the case of a Leslie MPM,
and of 14 elements in all other cases. Consists of scalar additions to the
y-intercepts of vital rate linear models used to estimate vital rates in
function-based MPMs. Defaults to <code>0</code> values for all vital rates.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_density">density</code></td>
<td>
<p>A numeric value indicating density value to use to propagate
matrices. Only needed if density is an explanatory term used in one or more
vital rate models. Defaults to <code>NA</code>. Only used in function_based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_cdf">CDF</code></td>
<td>
<p>A logical value indicating whether to use the cumulative
distribution function to estimate size transition probabilities in
function-based MPMs. Defaults to <code>TRUE</code>, and should only be changed to
<code>FALSE</code> if approximate probabilities calculated via the midpoint method
are preferred.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_random_inda">random_inda</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>a</code> as a random, categorical variable. Otherwise is treated
as a fixed, numeric variable. Defaults to <code>FALSE</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_random_indb">random_indb</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>b</code> as a random, categorical variable. Otherwise is treated
as a fixed, numeric variable. Defaults to <code>FALSE</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_random_indc">random_indc</code></td>
<td>
<p>A logical value denoting whether to treat individual
covariate <code>c</code> as a random, categorical variable. Otherwise is treated
as a fixed, numeric variable. Defaults to <code>FALSE</code>. Only used in
function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_negfec">negfec</code></td>
<td>
<p>A logical value denoting whether fecundity values estimated to
be negative should be reset to <code>0</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>. Only used in function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_theta_tol">theta_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to theta
as used in the negative binomial probability density kernel. Defaults to
<code>100000000</code>, but can be reset to other values during error checking.
Only used in function-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_censor">censor</code></td>
<td>
<p>If <code>TRUE</code>, then data will be removed according to the
variable set in <code>censorcol</code>, such that only data with censor values
equal to <code>censorkeep</code> will remain. Defaults to <code>FALSE</code>. Only
used in raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable denoting data elements to
keep. Defaults to <code>0</code>. Only used in raw MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_start_age">start_age</code></td>
<td>
<p>The age from which to start the matrix. Defaults to
<code>NULL</code>, in which case age <code>1</code> is used if
<code>prebreeding = TRUE</code>, and age <code>0</code> is used if
<code>prebreeding = FALSE</code>. Only used in age-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_last_age">last_age</code></td>
<td>
<p>The final age to use in the matrix. Defaults to <code>NULL</code>,
in which case the highest age in the dataset is used. Only used in age-based
and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_fecage_min">fecage_min</code></td>
<td>
<p>The minimum age at which reproduction is possible.
Defaults to <code>NULL</code>, which is interpreted to mean that fecundity should
be assessed starting in the minimum age observed in the dataset. Only used
in age-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_fecage_max">fecage_max</code></td>
<td>
<p>The maximum age at which reproduction is possible.
Defaults to <code>NULL</code>, which is interpreted to mean that fecundity should
be assessed until the final observed age. Only used in age-based MPMs.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_fectime">fectime</code></td>
<td>
<p>An integer indicating whether to estimate fecundity using
the variable given for <code>fec</code> in time <em>t</em> (<code>2</code>) or time
<em>t</em>+1 (<code>3</code>). Only used for purely age-based MPMs. Defaults to
<code>2</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier for fecundity. Only used for purely
age-based MPMs. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_cont">cont</code></td>
<td>
<p>A logical value designating whether to allow continued survival
of individuals past the final age noted in age-based and age-by-stage MPMs,
using the demographic characteristics of the final age. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_stage_nrasrep">stage_NRasRep</code></td>
<td>
<p>A logical value indicating whether to treat
non-reproductive individuals as reproductive. Used only in raw, stage-based
MPMs in cases where stage assignment must still be handled. Not used in
function-based MPMs, and in stage-based MPMs in which a valid <code>hfvdata</code>
class data frame with stages already assigned is provided.</p>
</td></tr>
<tr><td><code id="mpm_create_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lefkoMat</code>. This is a list that holds the
matrix projection model and all of its metadata. The structure has the
following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted patches and
occasion times. All matrices output in R's <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in R's <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Only used in historical MPMs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. Only used in
age-by-stage MPMs.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction. Used in all stage-based and
age-by-stage MPMs.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each
matrix in order.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code>
input.</p>
</td></tr>
<tr><td><code>prob_out</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a list of vital rate probability matrices, with 7 columns in the
order of survival, observation probability, reproduction probability, primary
size transition probability, secondary size transition probability, tertiary
size transition probability, and probability of juvenile transition to
maturity.</p>
</td></tr>
<tr><td><code>allstages</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code>.
This is a data frame giving the values used to determine each matrix element
capable of being estimated.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>An optional element only added if <code>err_check = TRUE</code> and a
raw MPM is requested. This consists of the original dataset as edited by
this function for indexing purposes.</p>
</td></tr>
</table>


<h3>General Notes</h3>

<p>This function automatically determines whether to create a raw or
function-based MPM given inputs supplied by the user.
</p>
<p>If used, the reproduction matrix (field <code>repmatrix</code>) may be supplied as
either historical or ahistorical. If provided as historical, then
a historical MPM must be estimated.
</p>
<p>If neither a supplement nor a reproduction matrix are used, and the MPM
to create is stage-based, then fecundity will be assumed to occur from all
reproductive stages to all propagule and immature stages.
</p>


<h3>Function-based MPM Notes</h3>

<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations, but without discriminating between those
patches or subpopulations. Should the aim of analysis be a general MPM that
does not distinguish these patches or subpopulations, the
<code>modelsearch()</code> run should not include patch terms.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Rearranging
the order will lead to erroneous calculations, and will may lead to fatal
errors.
</p>
<p>This function provides two different means of estimating the probability of
size transition. The midpoint method (<code>CDF = FALSE</code>) refers to the
method in which the probability is estimated by first estimating the
probability associated with transition from the exact size at the midpoint
of the size class using the corresponding probability density function, and
then multiplying that value by the bin width of the size class. Doak et al.
2021 (Ecological Monographs) noted that this method can produce biased
results, with total size transitions associated with a specific size not
totaling to 1.0 and even specific size transition probabilities capable of
being estimated at values greater than 1.0. The alternative and default
method (<code>CDF = TRUE</code>) uses the cumulative density function to estimate
the probability of size transition as the cumulative probability of size
transition at the greater limit of the size class minus the cumulative
probability of size transition at the lower limit of the size class. This
latter method avoids this bias. Note, however, that both methods are exact
and unbiased for negative binomial and Poisson distributions.
</p>
<p>Under the Gaussian and gamma size distributions, the number of estimated
parameters may differ between the two <code>ipm_method</code> settings. Because
the midpoint method has a tendency to incorporate upward bias in the
estimation of size transition probabilities, it is more likely to yield non-
zero values when the true probability is extremely close to 0. This will
result in the <code>summary.lefkoMat()</code> function yielding higher numbers of
estimated parameters than the <code>ipm_method = "CDF"</code> yields in some cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathvertln_adults &lt;- subset(lathvertln, stage2index &gt; 2)
surv_model &lt;- glm(alive3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = lathvertln_adults, family = "binomial")

obs_data &lt;- subset(lathvertln_adults, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(patchid), data = obs_data,
  family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
siz_model &lt;- lm(sizea3 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid) +
  as.factor(year2), data = size_data)

reps_model &lt;- glm(repstatus3 ~ sizea2 + sizea1 + as.factor(patchid) +
  as.factor(year2), data = size_data, family = "binomial")

fec_data &lt;- subset(lathvertln_adults, repstatus2 == 1)
fec_model &lt;- glm(feca2 ~ sizea2 + sizea1 + repstatus1 + as.factor(patchid),
  data = fec_data, family = "poisson")

lathvertln_juvs &lt;- subset(lathvertln, stage2index &lt; 3)
jsurv_model &lt;- glm(alive3 ~ as.factor(patchid), data = lathvertln_juvs,
  family = "binomial")

jobs_data &lt;- subset(lathvertln_juvs, alive3 == 1)
jobs_model &lt;- glm(obsstatus3 ~ 1, family = "binomial", data = jobs_data)

jsize_data &lt;- subset(jobs_data, obsstatus3 == 1)
jsiz_model &lt;- lm(sizea3 ~ as.factor(year2), data = jsize_data)

jrepst_model &lt;- 0
jmatst_model &lt;- 1

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[3] &lt;- "patchid"
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "feca2"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[13] &lt;- "sizea1"
mod_params$modelparams[18] &lt;- "repstatus2"
mod_params$modelparams[19] &lt;- "repstatus1"

used_models &lt;- list(survival_model = surv_model, observation_model = obs_model,
  size_model = siz_model, sizeb_model = 1, sizec_model = 1,
  repstatus_model = reps_model, fecundity_model = fec_model,
  juv_survival_model = jsurv_model, juv_observation_model = jobs_model,
  juv_size_model = jsiz_model, juv_sizeb_model = 1, juv_sizec_model = 1,
  juv_reproduction_model = 0, juv_maturity_model = 1, paramnames = mod_params)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "mat", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "Sdl", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "Sd", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  eststage1 = c(NA, NA, NA, NA, "Sdl", NA, NA),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframeln, historical = TRUE)

# While we do not use MPMs to initialize f_projections3(), we do use MPMs to
# initialize functions start_input() and density_input().
lathmat3ln &lt;- mpm_create(historical = TRUE, year = "all", patch = "all",
  data = lathvertln, stageframe = lathframeln, supplement = lathsupp3,
  modelsuite = used_models, reduce = FALSE)


</code></pre>

<hr>
<h2 id='overwrite'>Create Overwrite Table for MPM Development</h2><span id='topic+overwrite'></span>

<h3>Description</h3>

<p><code>overwrite()</code> returns a data frame describing which particular
transitions within an ahistorical or historical projection matrix to
overwrite with either given rates and probabilities, or other estimated
transitions. This function is now deprecated in favor of function
<code><a href="#topic+supplemental">supplemental</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite(
  stage3,
  stage2,
  stage1 = NA,
  eststage3 = NA,
  eststage2 = NA,
  eststage1 = NA,
  givenrate = NA,
  type = NA,
  type_t12 = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overwrite_+3A_stage3">stage3</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>+1 in the transition
to be replaced. Abbreviations for groups of stages are also allowed
(see Notes).</p>
</td></tr>
<tr><td><code id="overwrite_+3A_stage2">stage2</code></td>
<td>
<p>The name of the stage in occasion <em>t</em> in the transition to
be replaced. Abbreviations for groups of stages are also allowed (see Notes).</p>
</td></tr>
<tr><td><code id="overwrite_+3A_stage1">stage1</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>-1 in the transition
to be replaced. Only needed if a historical matrix is to be produced.
Abbreviations for groups of stages are also allowed (see Notes).</p>
</td></tr>
<tr><td><code id="overwrite_+3A_eststage3">eststage3</code></td>
<td>
<p>The name of the stage to replace <code>stage3</code>. Only needed
if a transition will be replaced by another estimated transition.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_eststage2">eststage2</code></td>
<td>
<p>The name of the stage to replace <code>stage2</code>. Only needed
if a transition will be replaced by another estimated transition.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_eststage1">eststage1</code></td>
<td>
<p>The name of the stage to replace <code>stage1</code>. Only needed
if a transition will be replaced by another estimated transition, and the
matrix to be estimated is historical.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_givenrate">givenrate</code></td>
<td>
<p>A fixed rate or probability to replace for the transition
described by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_type">type</code></td>
<td>
<p>A vector denoting the kind of transition between occasions
<em>t</em> and <em>t</em>+1 to be replaced. This should be entered as <code>1</code>,
<code>S</code>, or <code>s</code> for the replacement of a survival transition; or
<code>2</code>, <code>F</code>, or <code>f</code> for the replacement of a fecundity
transition. If empty or not provided, then defaults to <code>1</code> for survival
transition.</p>
</td></tr>
<tr><td><code id="overwrite_+3A_type_t12">type_t12</code></td>
<td>
<p>An optional vector denoting the kind of transition between
occasions <em>t</em>-1 and <em>t</em>. Only necessary if a historical MPM in
deVries format is desired. This should be entered as <code>1</code>, <code>S</code>, or
<code>s</code> for a survival transition; or <code>2</code>, <code>F</code>, or <code>f</code> for a
fecundity transitions. Defaults to <code>1</code> for survival transition, with
impacts only on the construction of deVries-format hMPMs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that puts the above vectors together and can be used as
input in <code><a href="#topic+flefko3">flefko3</a>()</code>, <code><a href="#topic+flefko2">flefko2</a>()</code>,
<code><a href="#topic+rlefko3">rlefko3</a>()</code>,<code><a href="#topic+rlefko2">rlefko2</a>()</code>, and
<code><a href="#topic+aflefko2">aflefko2</a>()</code>.
</p>
<p>Variables in this data frame include the following:
</p>
<table>
<tr><td><code>stage3</code></td>
<td>
<p>Stage at occasion <em>t</em>+1 in the transition to be replaced.</p>
</td></tr>
<tr><td><code>stage2</code></td>
<td>
<p>Stage at occasion <em>t</em> in the transition to be replaced.</p>
</td></tr>
<tr><td><code>stage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1 in the transition to be replaced.</p>
</td></tr>
<tr><td><code>eststage3</code></td>
<td>
<p>Stage at occasion <em>t</em>+1 in the transition to replace
the transition designated by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code>eststage2</code></td>
<td>
<p>Stage at occasion <em>t</em> in the transition to replace the
transition designated by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code>eststage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1 in the transition to replace
the transition designated by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code>givenrate</code></td>
<td>
<p>A constant to be used as the value of the transition.</p>
</td></tr>
<tr><td><code>convtype</code></td>
<td>
<p>Designates whether the transition from occasion <em>t</em> to
occasion <em>t</em>+1 is a survival-transition probability (1) or a fecundity
rate (2).</p>
</td></tr>
<tr><td><code>convtype_t12</code></td>
<td>
<p>Designates whether the transition from occasion
<em>t</em>-1 to occasion <em>t</em> is a survival transition probability (1), a
fecundity rate (2).</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>This function is deprecated. Please use <code><a href="#topic+supplemental">supplemental</a>()</code>.
</p>
<p>Entries in <code>stage3</code>, <code>stage2</code>, and <code>stage1</code> can include
abbreviations for groups of stages. Use <code>rep</code> if all reproductive stages
are to be used, <code>nrep</code> if all mature but non-reproductive stages are to
be used, <code>mat</code> if all mature stages are to be used, <code>immat</code> if all
immature stages are to be used, <code>prop</code> if all propagule stages are to be
used, <code>npr</code> if all non-propagule stages are to be used, and leave empty
or use <code>all</code> if all stages in stageframe are to be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cypover2r &lt;- overwrite(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm"),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm"),
  givenrate = c(0.1, 0.2, 0.2, 0.2, 0.25, NA, NA, NA),
  type = c("S", "S", "S", "S", "S", "S", "S", "S"))

cypover2r

cypover3r &lt;- overwrite(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL", 
    "D", "XSm", "Sm", "D", "XSm", "Sm"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL",
    "SL", "SL", "SL"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm",
    "Sm"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm"),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA),
  type = c("S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S", "S"))

cypover3r

</code></pre>

<hr>
<h2 id='plot.lefkoProj'>Plot Projection Simulations</h2><span id='topic+plot.lefkoProj'></span>

<h3>Description</h3>

<p>Function <code>plot.lefkoProj()</code> produces plots of <code>lefkoProj</code> objects.
Acts as a convenient wrapper for the <code>plot.default()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoProj'
plot(
  x,
  variable = "popsize",
  style = "time",
  repl = "all",
  patch = "pop",
  auto_ylim = TRUE,
  auto_col = TRUE,
  auto_lty = TRUE,
  auto_title = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lefkoProj_+3A_x">x</code></td>
<td>
<p>A <code>lefkoProj</code> object.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_variable">variable</code></td>
<td>
<p>The focus variable of the plot to produce. Defaults to
<code>"popsize"</code>, which produces line plots of the <code>popsize</code> element in
object <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_style">style</code></td>
<td>
<p>A string denoting ther kind of plot to produce. Currently
limited to <code>"timeseries"</code>, which shows <code>variable</code> against time on
the x axis. Other choices include <code>"statespace"</code>, which plots
<code>variable</code> at one time on the x axis against the same variable in the
next time on the y axis.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_repl">repl</code></td>
<td>
<p>The replicate to plot. Defaults to <code>"all"</code>, in which case
all replicates are plotted.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_patch">patch</code></td>
<td>
<p>The patch to plot, as labeled in the <code>labels</code> element in
object <code>x</code>. Defaults to <code>"pop"</code>, in which case only the final
population-level projection is plotted. Can also be set to <code>"all"</code>, in
which case projections for all patches and population in the <code>labels</code>
element are plotted.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_auto_ylim">auto_ylim</code></td>
<td>
<p>A logical value indicating whether the maximum of the y axis
should be determined automatically. Defaults to <code>TRUE</code>, but reverts to
<code>FALSE</code> if any setting for <code>ylim</code> is given.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_auto_col">auto_col</code></td>
<td>
<p>A logical value indicating whether to shift the color of
lines associated with each patch automatically. Defaults to <code>TRUE</code>, but
reverts to <code>FALSE</code> if any setting for <code>col</code> is given.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_auto_lty">auto_lty</code></td>
<td>
<p>A logical value indicating whether to shift the line type
associated with each replicate automatically. Defaults to <code>TRUE</code>, but
reverts to <code>FALSE</code> if any setting for <code>lty</code> is given.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_auto_title">auto_title</code></td>
<td>
<p>A logical value indicating whether to add a title to each
plot. The plot is composed of the concatenated population and patch names.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lefkoProj_+3A_...">...</code></td>
<td>
<p>Other parameters used by functions <code>plot.default()</code> and
<code>lines()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the results of a <code><a href="#topic+projection3">projection3</a>()</code> run.
</p>


<h3>Notes</h3>

<p>Output plots are currently limited to time series and state space plots of
population size.
</p>
<p>The default settings will preferentially plot any projections marked as
<code>0</code> in the <code>patch</code> portion of the <code>labels</code> element of the
input MPM. This can produce confusing results if a mean MPM resulting from
the <code>lmean()</code> function is used as input and the <code>add_mean</code> setting
is set to the default, which is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathrepm &lt;- matrix(0, 7, 7)
lathrepm[1, 6] &lt;- 0.345
lathrepm[2, 6] &lt;- 0.054

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "all", "all"), 
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe,
  year = c(1989, 1990), stages = c("stage3", "stage2", "stage1"),
  repmatrix = lathrepm, supplement = lathsupp3, yearcol = "year2",
  indivcol = "individ")

lathproj &lt;- projection3(ehrlen3, nreps = 5, stochastic = TRUE)
plot(lathproj)

</code></pre>

<hr>
<h2 id='projection3'>Conduct Population Projection Simulations</h2><span id='topic+projection3'></span>

<h3>Description</h3>

<p>Function <code>projection3()</code> runs projection simulations. It projects the
population and patches forward in time by a user-defined number of
occasions. A given set of matrices is utilized and not recreated, although
elements may be altered if density dependence is set. Projections may be
deterministic or stochastic, and may be density dependent in either case. If
deterministic, then projections will be cyclical if matrices exist covering
multiple occasions for each population or patch. If stochastic, then annual
matrices will be shuffled within patches and populations. Also produces
replicates if set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection3(
  mpm,
  nreps = 1L,
  times = 10000L,
  historical = FALSE,
  stochastic = FALSE,
  standardize = FALSE,
  growthonly = TRUE,
  integeronly = FALSE,
  substoch = 0L,
  exp_tol = 700,
  sub_warnings = TRUE,
  quiet = FALSE,
  year = NULL,
  start_vec = NULL,
  start_frame = NULL,
  tweights = NULL,
  density = NULL,
  sparse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection3_+3A_mpm">mpm</code></td>
<td>
<p>A matrix projection model of class <code>lefkoMat</code>, or a list of
full matrix projection matrices.</p>
</td></tr>
<tr><td><code id="projection3_+3A_nreps">nreps</code></td>
<td>
<p>The number of replicate projections.</p>
</td></tr>
<tr><td><code id="projection3_+3A_times">times</code></td>
<td>
<p>Number of occasions to iterate per replicate. Defaults to
10,000.</p>
</td></tr>
<tr><td><code id="projection3_+3A_historical">historical</code></td>
<td>
<p>An optional logical value only used if object <code>mpm</code>
is a list of matrices, rather than a <code>lefkoMat</code> object. Defaults to
<code>FALSE</code> for the former case, and overridden by information supplied in
the <code>lefkoMat</code> object for the latter case.</p>
</td></tr>
<tr><td><code id="projection3_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value denoting whether to conduct a stochastic
projection or a deterministic / cyclical projection.</p>
</td></tr>
<tr><td><code id="projection3_+3A_standardize">standardize</code></td>
<td>
<p>A logical value denoting whether to re-standardize the
population size to 1.0 at each occasion. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_growthonly">growthonly</code></td>
<td>
<p>A logical value indicating whether to produce only the
projected population size at each occasion, or a vector showing the stage
distribution followed by the reproductive value vector followed by the full
population size at each occasion. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_integeronly">integeronly</code></td>
<td>
<p>A logical value indicating whether to round the number of
individuals projected in each stage at each occasion to the nearest
integer. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating whether to force survival-
transition matrices to be substochastic in density dependent simulations.
Defaults to <code>0</code>, which does not force substochasticity. Alternatively,
<code>1</code> forces all survival-transition elements to range from 0.0 to 1.0,
and forces fecundity to be non-negative; and <code>2</code> forces all column rows
in the survival-transition matrices to total no more than 1.0, in addition
to the actions outlined for option <code>1</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_exp_tol">exp_tol</code></td>
<td>
<p>A numeric value used to indicate a maximum value to set
exponents to in the core kernel to prevent numerical overflow. Defaults to
<code>700</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_sub_warnings">sub_warnings</code></td>
<td>
<p>A logical value indicating whether to warn the user if
density dependence yields matrix values outside of the realm of possibility.
Generally, this means that survival-transition elements altered to values
outside of the interval [0, 1], and negative fecundity values, will both
yield warnings. Defaults to <code>TRUE</code>, but becomes <code>FALSE</code> if
<code>quiet = TRUE</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_quiet">quiet</code></td>
<td>
<p>A logical value indicating whether to suppress warnings.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_year">year</code></td>
<td>
<p>Either a single integer value corresponding to the year to
project, or a vector of <code>times</code> elements with the year to use at each
time step. If a vector shorter than <code>times</code> is supplied, then this
vector will be cycled. If not provided, then all annual matrices will be
cycled within patches or populations.</p>
</td></tr>
<tr><td><code id="projection3_+3A_start_vec">start_vec</code></td>
<td>
<p>An optional numeric vector denoting the starting stage
distribution for the projection. Defaults to a single individual of each
stage.</p>
</td></tr>
<tr><td><code id="projection3_+3A_start_frame">start_frame</code></td>
<td>
<p>An optional data frame characterizing stages, age-stages,
or stage-pairs that should be set to non-zero values in the starting vector,
and what those values should be. Can only be used with <code>lefkoMat</code>
objects.</p>
</td></tr>
<tr><td><code id="projection3_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a
matrix is input, then a first-order Markovian environment is assumed, in
which the probability of choosing a specific annual matrix depends on which
annual matrix is currently chosen. If a vector is input, then the choice of
annual matrix is assumed to be independent of the current matrix. Defaults
to equal weighting among matrices.</p>
</td></tr>
<tr><td><code id="projection3_+3A_density">density</code></td>
<td>
<p>An optional data frame describing the matrix elements that
will be subject to density dependence, and the exact kind of density
dependence that they will be subject to. The data frame used should be an
object of class <code>lefkoDens</code>, which is the output from function
<code><a href="#topic+density_input">density_input</a>()</code>.</p>
</td></tr>
<tr><td><code id="projection3_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>), if the
<code>lefkoMat</code> object input as <code>mpm</code> is composed of standard matrices.
Defaults to <code>"auto"</code>, in which case sparse matrix encoding is used with
standard, square matrices with at least 50 rows and no more than 50% of
elements with values greater than zero, or when input <code>lefkoMat</code>
objects include matrices of class <code>dgCMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>lefkoProj</code>, which always includes the first
three elements of the following, and also includes the remaining elements
below when a <code>lefkoMat</code> object is used as input:
</p>
<table>
<tr><td><code>projection</code></td>
<td>
<p>A list of lists of matrices showing the total number of
individuals per stage per occasion. The first list corresponds to each
pop-patch followed by each population. The inner list corresponds to
replicates within each pop-patch or population.</p>
</td></tr>
<tr><td><code>stage_dist</code></td>
<td>
<p>A list of lists of the actual stage distribution in each
occasion in each replicate in each pop-patch or population. The list order
is the same as in <code>projection</code>.</p>
</td></tr>
<tr><td><code>rep_value</code></td>
<td>
<p>A list of lists of the actual reproductive value in each
occasion in each replicate in each pop-patch or population. The list order
is the same as in <code>projection</code>.</p>
</td></tr>
<tr><td><code>pop_size</code></td>
<td>
<p>A list of matrices showing the total population size in
each occasion per replicate (row within matrix) per pop-patch or
population (list element).</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame showing the order of populations and patches in
item <code>projection</code>.</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>The original stageframe used in the study.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame showing the order of historical stage pairs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing the order of age-stage pairs.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>A short vector indicating the number of replicates and the
number of occasions projected per replicate.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>The data frame input under the density option. Only provided
if input by the user.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Projections are run both at the patch level and at the population level.
Population level estimates will be noted at the end of the data frame with
<code>0</code> entries for patch designation.
</p>
<p>Weightings given in <code>tweights</code> do not need to sum to 1. Final
weightings used will be based on the proportion per element of the sum of
elements in the user-supplied vector.
</p>
<p>Starting vectors can be input in one of two ways: 1) as <code>start_vec</code>
input, which is a vector of numbers of the numbers of individuals in each
stage, stage pair, or age-stage, with the length of the vector necessarily
as long as there are rows in the matrices of the MPM; or 2) as
<code>start_frame</code> input, which is a data frame showing only those stages,
stage pairs, or age-stages that should begin with more than 0 individuals,
and the numbers of individuals that those stages should start with (this
object is created using the <code><a href="#topic+start_input">start_input</a>()</code> function). If both
are provided, then <code>start_frame</code> takes precedence and <code>start_vec</code>
is ignored. If neither is provided, then <code>projection3()</code> automatically
assumes that each stage, stage pair, or age-stage begins with a single
individual. Importantly, if a <code>lefkoMat</code> object is not used, and a list
of matrices is provided instead, then <code>start_frame</code> cannot be utilized
and a full <code>start_vec</code> must be provided to conduct a simulation with
starting numbers of individuals other than 1 per stage.
</p>
<p>The resulting data frames in element <code>projection</code> are separated by
pop-patch according to the order provided in element <code>labels</code>, but the
matrices for each element of <code>projection</code> have the result of each
replicate stacked in order on top of one another without any break or
indication. Results for each replicate must be separated using the
information provided in elements <code>control</code> and the 3 stage
descriptor elements.
</p>
<p>Density dependent projections are automatically set up if object
<code>density</code> is input. If this object is not included, then density
independent projections will be set up. Note that currently, density
dependent projections can only be performed with <code>lefkoMat</code> objects.
</p>
<p>When running density dependent simulations involving user-set exponents,
such as the beta term in the Ricker function and both the alpha and beta
terms in the Usher function, values above or below the computer limits may
cause unpredictable behavior. Noted odd behavior includes sudden shifts in
population size to negative values. This function produces warnings when
such values are used, and the values used for warnings may be reset with the
<code>exp_tol</code> term.
</p>
<p>The stage distributions and reproductive values produced are not the
asymptotic values as would be given by the standardized right and left
eigenvectors associated with the dominant eigenvalue of a matrix, but are
vectors describing these values at the specific points in time projected.
See equations 14.86 and 14.88 and section 14.4 on Sensitivity and Elasticity
Analysis under Environmental Stochasticity in Caswell (2001, Matrix
Population Models, Sinauer Associates) for more details.
</p>
<p>Consistently positive population growth can quickly lead to population size
numbers larger than can be handled computationally. In that circumstance, a
continuously rising population size will suddenly become <code>NaN</code> for the
remainder of the projection.
</p>
<p>Users wishing to run a projection of a single patch in a <code>lefkoMat</code>
object with multiple patches should subset the MPM first to contain only
the patch needed. This can be accomplished with the
<code><a href="#topic+subset_lM">subset_lM</a>()</code> function.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_input">start_input</a>()</code>
</p>
<p><code><a href="#topic+density_input">density_input</a>()</code>
</p>
<p><code><a href="#topic+f_projection3">f_projection3</a>()</code>
</p>
<p><code><a href="#topic+append_lP">append_lP</a>()</code>
</p>
<p><code><a href="#topic+summary.lefkoProj">summary.lefkoProj</a>()</code>
</p>
<p><code><a href="#topic+plot.lefkoProj">plot.lefkoProj</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "all", "all"), 
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe,
  year = c(1989, 1990), stages = c("stage3", "stage2", "stage1"),
  supplement = lathsupp3, yearcol = "year2", indivcol = "individ")

lathproj &lt;- projection3(ehrlen3, nreps = 5, stochastic = TRUE)

# Cypripedium example
data(cypdata)
 
sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"), 
  supplement = cypsupp3r, yearcol = "year2", 
  patchcol = "patchid", indivcol = "individ")

cypstoch &lt;- projection3(cypmatrix3r, nreps = 5, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='pyrola'>Demographic Dataset of <em>Pyrola japonica</em> and <em>Pyrola subaphylla</em>
Populations, in Horizontal Format</h2><span id='topic+pyrola'></span>

<h3>Description</h3>

<p>A dataset containing the states and fates of <em>Pyrola japonica</em> and
<em>Pyrola subaphylla</em>, family Ericaceae, from populations in the vicinity
of Mt. Bandai, Fukushima Prefecture, Japan, resulting from monitoring that
occurred annually between 2015 and 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pyrola)
</code></pre>


<h3>Format</h3>

<p>A data frame with 454 individuals and 57 variables. Each row 
corresponds to an unique individual, and each variable from
<code>sprouted.2015</code> on refers to the state of the individual in a particular
year.
</p>

<dl>
<dt>species</dt><dd><p>String denoting which of the two species the individual
belongs to.</p>
</dd>
<dt>population</dt><dd><p>Integer denoting whcih population the individual belongs
to. Synonymous with species in this dataset.</p>
</dd>
<dt>id</dt><dd><p>A numeric variable giving a unique number to each 
individual within each species. Note that numbers are reused among the two
species.</p>
</dd>
<dt>sprouted.2015</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2015 census.</p>
</dd>
<dt>lvs.num.2015</dt><dd><p>Number of leaves in 2015.</p>
</dd>
<dt>lvs.lng.2015</dt><dd><p>Length of largest leaf in 2015.</p>
</dd>
<dt>lvs.wdt.2015</dt><dd><p>Width of largest leaf in 2015.</p>
</dd>
<dt>inf.num.2015</dt><dd><p>Number of inflorescences in 2015.</p>
</dd>
<dt>inf.lng.tot.2015</dt><dd><p>Summed inflorescence length in 2015.</p>
</dd>
<dt>flo.tot.2015</dt><dd><p>Number of flowers in 2015.</p>
</dd>
<dt>frt.tot.2015</dt><dd><p>Number of fruits in 2015.</p>
</dd>
<dt>sprouted.2016</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2016 census.</p>
</dd>
<dt>lvs.num.2016</dt><dd><p>Number of leaves in 2016.</p>
</dd>
<dt>lvs.lng.2016</dt><dd><p>Length of largest leaf in 2016.</p>
</dd>
<dt>lvs.wdt.2016</dt><dd><p>Width of largest leaf in 2016.</p>
</dd>
<dt>inf.num.2016</dt><dd><p>Number of inflorescences in 2016.</p>
</dd>
<dt>inf.lng.tot.2016</dt><dd><p>Summed inflorescence length in 2016.</p>
</dd>
<dt>flo.tot.2016</dt><dd><p>Number of flowers in 2016.</p>
</dd>
<dt>frt.tot.2016</dt><dd><p>Number of fruits in 2016.</p>
</dd>
<dt>sprouted.2017</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2017 census.</p>
</dd>
<dt>lvs.num.2017</dt><dd><p>Number of leaves in 2017.</p>
</dd>
<dt>lvs.lng.2017</dt><dd><p>Length of largest leaf in 2017.</p>
</dd>
<dt>lvs.wdt.2017</dt><dd><p>Width of largest leaf in 2017.</p>
</dd>
<dt>inf.num.2017</dt><dd><p>Number of inflorescences in 2017.</p>
</dd>
<dt>inf.lng.tot.2017</dt><dd><p>Summed inflorescence length in 2017.</p>
</dd>
<dt>flo.tot.2017</dt><dd><p>Number of flowers in 2017.</p>
</dd>
<dt>frt.tot.2017</dt><dd><p>Number of fruits in 2017.</p>
</dd>
<dt>sprouted.2018</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2018 census.</p>
</dd>
<dt>lvs.num.2018</dt><dd><p>Number of leaves in 2018.</p>
</dd>
<dt>lvs.lng.2018</dt><dd><p>Length of largest leaf in 2018.</p>
</dd>
<dt>lvs.wdt.2018</dt><dd><p>Width of largest leaf in 2018.</p>
</dd>
<dt>inf.num.2018</dt><dd><p>Number of inflorescences in 2018.</p>
</dd>
<dt>inf.lng.tot.2018</dt><dd><p>Summed inflorescence length in 2018.</p>
</dd>
<dt>flo.tot.2018</dt><dd><p>Number of flowers in 2018.</p>
</dd>
<dt>frt.tot.2018</dt><dd><p>Number of fruits in 2018.</p>
</dd>
<dt>sprouted.2019</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2019 census.</p>
</dd>
<dt>lvs.num.2019</dt><dd><p>Number of leaves in 2019.</p>
</dd>
<dt>lvs.lng.2019</dt><dd><p>Length of largest leaf in 2019.</p>
</dd>
<dt>lvs.wdt.2019</dt><dd><p>Width of largest leaf in 2019.</p>
</dd>
<dt>inf.num.2019</dt><dd><p>Number of inflorescences in 2019.</p>
</dd>
<dt>inf.lng.tot.2019</dt><dd><p>Summed inflorescence length in 2019.</p>
</dd>
<dt>flo.tot.2019</dt><dd><p>Number of flowers in 2019.</p>
</dd>
<dt>frt.tot.2019</dt><dd><p>Number of fruits in 2019.</p>
</dd>
<dt>sprouted.2020</dt><dd><p>A binomial indicating whether the individual had
living aboveground tissue observable in the 2020 census.</p>
</dd>
<dt>lvs.num.2020</dt><dd><p>Number of leaves in 2020.</p>
</dd>
<dt>lvs.lng.2020</dt><dd><p>Length of largest leaf in 2020.</p>
</dd>
<dt>lvs.wdt.2020</dt><dd><p>Width of largest leaf in 2020.</p>
</dd>
<dt>inf.num.2020</dt><dd><p>Number of inflorescences in 2020.</p>
</dd>
<dt>inf.lng.tot.2020</dt><dd><p>Summed inflorescence length in 2020.</p>
</dd>
<dt>flo.tot.2020</dt><dd><p>Number of flowers in 2020.</p>
</dd>
<dt>frt.tot.2020</dt><dd><p>Number of fruits in 2020.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Shefferson, R.P., K. Shutoh, and K. Suetsugu. <em>In review</em>.
Vegetative dormancy and the evolution of mycoheterotrophy in sister
<em>Pyrola</em> species. <em>Journal of Ecology</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pyrola)

pyrola$species &lt;- as.factor(pyrola$species)
pyrola$population &lt;- as.factor(pyrola$population)
jreg &lt;- pyrola[which(pyrola$population == 1),]
stagevec_jp &lt;- c("P1", "Sdl", "Dorm", "V0nr", "V1nr", "V2nr", "V3nr", "V4nr",
  "V0r", "V1r", "V2r", "V3r", "V4r")
sizeavec_jp &lt;- c(0, 0, 0, 0, 1, 2, 3, 7, 0, 1, 2, 3, 7)
sizeahbin_jp &lt;- c(0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 3.5, 0.5, 0.5, 0.5, 0.5,
  3.5)
repvec_jp &lt;- c(0, 0, 0, 0, rep(0, 4), rep(1, 5))
propvec_jp &lt;- c(1, rep(0, 12))
immvec_jp &lt;- c(1, 1, rep(0, 11))
matvec_jp &lt;- c(0, 0, rep(1, 11))
obsvec_jp &lt;- c(0, 0, 0, rep(1, 10))
indata_jp &lt;- c(0, 0, rep(1, 11))
comments_jp &lt;- c("protocorm", "seedling", "dormant adult", "stump", "1lf nr",
  "2lf nr", "3lf nr", "4+lf nr", "0lf r", "1lf r", "2lf r", "3lf r",
  "4+lf r")
jp_frame &lt;- sf_create(sizes = sizeavec_jp, stagenames = stagevec_jp,
  binhalfwidth = sizeahbin_jp, repstatus = repvec_jp, obsstatus = obsvec_jp,
  indataset = indata_jp, propstatus = propvec_jp, immstatus = immvec_jp,
  matstatus = matvec_jp, comments = comments_jp)
  
jhfv &lt;- verticalize3(data = jreg, noyears = 6, firstyear = 2015,
  individcol = "id", blocksize = 8, sizeacol = "lvs.num.2015",
  obsacol = "sprouted.2015", repstracol = "flo.tot.2015",
  repstrbcol = "frt.tot.2015", fecacol = "flo.tot.2015",
  fecbcol = "frt.tot.2015", NAas0 = TRUE, stagesize = "sizea",
  stageassign = jp_frame)

surv_model &lt;- glm(alive3 ~ sizea2 + as.factor(year2), data = jhfv, family = "binomial")

obs_data &lt;- subset(jhfv, alive3 == 1)
obs_model &lt;- glm(obsstatus3 ~ as.factor(year2), data = obs_data, family = "binomial")

size_data &lt;- subset(obs_data, obsstatus3 == 1)
size_model &lt;- glm(sizea3 ~ sizea2, data = size_data, family = "poisson")

reps_model &lt;- glm(repstatus3 ~ sizea2, data = size_data, family = "binomial")

fec_data &lt;- subset(jhfv, repstatus2 == 1)
fec_model &lt;- MASS::glm.nb(fec2added ~ 1, data = fec_data)

mod_params &lt;- create_pm(name_terms = TRUE)
mod_params$modelparams[4] &lt;- "alive3"
mod_params$modelparams[5] &lt;- "obsstatus3"
mod_params$modelparams[6] &lt;- "sizea3"
mod_params$modelparams[9] &lt;- "repstatus3"
mod_params$modelparams[11] &lt;- "fec2added"
mod_params$modelparams[12] &lt;- "sizea2"
mod_params$modelparams[18] &lt;- "repstatus2"

jp_germ &lt;- 0.90
jp_supp2 &lt;- supplemental(stage3 = c("Sdl", "Dorm", "V0nr", "V1nr", "P1", "Sdl"), 
  stage2 = c("P1", "Sdl", "Sdl", "Sdl", "rep", "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA),
  givenrate = c(0.25, 0.35, 0.10, 0.10, NA, NA), # 0.345, 0.054
  multiplier = c(NA, NA, NA, NA, jp_germ * 0.5, jp_germ * 0.5),
  type = c(1, 1, 1, 1, 3, 3), stageframe = jp_frame, historical = FALSE)

jp_ahmpm &lt;- flefko2(year = "all", stageframe = jp_frame, supplement = jp_supp2,
  paramnames = mod_params, surv_model = surv_model, obs_model = obs_model,
  size_model = size_model, repst_model = reps_model, fec_model = fec_model,
  data = jhfv, err_check = TRUE)

lambda3(jp_ahmpm)
</code></pre>

<hr>
<h2 id='repvalue3'>Estimate Reproductive Value</h2><span id='topic+repvalue3'></span>

<h3>Description</h3>

<p><code>repvalue3()</code> is a generic function that estimates returns the
reproductive values of stages in a population projection matrix or a set of
matrices. The specifics of estimation vary with the class of input object.
This function is made to handle very large and sparse matrices supplied as
<code>lefkoMat</code> objects or as individual matrices, and can be used with large
historical matrices, IPMs, age x stage matrices, as well as ahistorical
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repvalue3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repvalue3_+3A_mats">mats</code></td>
<td>
<p>A lefkoMat object, a population projection matrix, or a list of
population projection matrices for which the reproductive value vector is
desired.</p>
</td></tr>
<tr><td><code id="repvalue3_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the <code>mats</code> argument.
See related functions for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.matrix">repvalue3.matrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.dgCMatrix">repvalue3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.list">repvalue3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus deterministic example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
repvalue3(ehrlen3mean)

# Cypripedium stochastic example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

repvalue3(cypmatrix2r, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='repvalue3.dgCMatrix'>Estimate Reproductive Value Vector for a Single Population Projection Matrix</h2><span id='topic+repvalue3.dgCMatrix'></span>

<h3>Description</h3>

<p><code>repvalue3.dgCMatrix()</code> returns the reproductive values for stages in a 
sparse population projection matrix. The function makes no assumptions about
whether the matrix is ahistorical and simply provides standard reproductive
values corresponding to each row, meaning that the overall reproductive
values of basic life history stages in a historical matrix are not provided
(the <code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code> function estimates these on the basis
of stage description information provided in the <code>lefkoMat</code> object used
as input in that function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
repvalue3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repvalue3.dgCMatrix_+3A_mats">mats</code></td>
<td>
<p>A population projection matrix.</p>
</td></tr>
<tr><td><code id="repvalue3.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector data frame characterizing the 
reproductive values for stages of a population projection matrix. This is 
given as the left eigenvector associated with largest real part of the
dominant eigenvalue, divided by the first non-zero element of the left 
eigenvector.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have several hundred rows and columns. Defaults
work best when matrices are very small and dense, or very large and sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repvalue3">repvalue3</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.matrix">repvalue3.matrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.list">repvalue3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ", sparse_output = TRUE)

repvalue3(ehrlen3$A[[1]])

</code></pre>

<hr>
<h2 id='repvalue3.lefkoMat'>Estimate Reproductive Value Vectors of Matrices in a lefkoMat Object</h2><span id='topic+repvalue3.lefkoMat'></span>

<h3>Description</h3>

<p><code>repvalue3.lefkoMat()</code> returns the reproductive values for stages in a
set of population projection matrices provided as a <code>lefkoMat</code> object.
This function can handle large and sparse matrices, and so can be used with
large historical matrices, IPMs, age x stage matrices, as well as ahistorical
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
repvalue3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  force_sparse = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repvalue3.lefkoMat_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>lefkoMat</code> object.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value indicating whether to use deterministic
(<code>FALSE</code>) or stochastic (<code>TRUE</code>) analysis. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_times">times</code></td>
<td>
<p>An integer variable indicating number of occasions to project if
using stochastic analysis. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) when supplied with standard matrices. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="repvalue3.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the asymptotic reproductive value vectors if
deterministic analysis is chosen, and long-run mean reproductive value
vectors if stochastic analysis is chosen.
</p>
<p>The output depends on whether the <code>lefkoMat</code> object used as input is
ahistorical or historical, and whether the analysis is deterministic or
stochastic. If deterministic and ahistorical, then a single data frame is
output, which includes the number of the matrix within the <code>A</code> element
of the input <code>lefkoMat</code> object, followed by the stage id (numeric and
assigned through <code><a href="#topic+sf_create">sf_create</a>()</code>), the stage name, and the
estimated proportion of the reproductive value vector (<code>rep_value</code>). If
stochastic and ahistorical, then a single data frame is output starting with
the number of the population-patch (<code>matrix_set</code>), a string
concatenating the names of the population and the patch (<code>poppatch</code>),
the assigned stage id number (<code>stage_id</code>), and the stage name
(<code>stage</code>), and the long-run mean reproductive value vector
(<code>rep_value</code>).
</p>
<p>If a historical matrix is used as input, then two data frames are output
into a list object. The <code>hist</code> element describes the historical
stage-pair reproductive values, while the <code>ahist</code> element describes the
stage reproductive values. If deterministic, then <code>hist</code> contains a data
frame including the matrix number (<code>matrix</code>), the numeric stage
designations for stages in occasions <em>t</em> and <em>t</em>-1,
(<code>stage_id_2</code> and <code>stage_id_1</code>, respectively), followed by the
respective stage names (<code>stage_2</code> and <code>stage_1</code>), and ending with
the estimated reproductive values (<code>rep_value</code>). The associated
<code>ahist</code> element is as before. If stochastic, then the <code>hist</code>
element contains a single data frame with the number of the population-patch
(<code>matrix_set</code>), a string concatenating the names of the population and
the patch (<code>poppatch</code>), the assigned stage id numbers in times <em>t</em>
and <em>t</em>-1 (<code>stage_id_2</code> and <code>stage_id_2</code>, respectively), and
the associated stage names (<code>stage_2</code> and <code>stage_1</code>, respectively),
and the long-run mean reproductive values (<code>rep_value</code>). The associated
<code>ahist</code> element is as before in the ahistorical, stochastic case.
</p>
<p>In addition to the data frames noted above, stochastic analysis will result
in the additional output of a list of matrices containing the actual
projected reproductive value vectors across all projected occasions, in the
order of population-patch combinations in the <code>lefkoMat</code> input.
</p>


<h3>Notes</h3>

<p>In stochastic analysis, the projected mean reproductive value vector is the
arithmetic mean across the final projected 1000 occasions if the simulation
is at least 2000 projected occasions long. If between 500 and 2000 projected
occasions long, then only the final 200 are used, and if fewer than 500
occasions are used, then all are used. Note that because reproductive values
in stochastic simulations can change greatly in the initial portion of the
run, we encourage a minimum 2000 projected occasions per simulation, with
10000 preferred.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have several hundred rows and columns. Defaults
work best when matrices are very small and dense, or very large and sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repvalue3">repvalue3</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.matrix">repvalue3.matrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.dgCMatrix">repvalue3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.list">repvalue3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

repvalue3(cypmatrix2r, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='repvalue3.list'>Estimate Reproductive Value Vector for a List of Projection Matrices</h2><span id='topic+repvalue3.list'></span>

<h3>Description</h3>

<p><code>repvalue3.list()</code> returns the reproductive values for stages in
population projection matrices arranged in a general list. The function makes
no assumptions about whether the matrix is ahistorical and simply provides
standard reproductive values corresponding to each row, meaning that the
overall reproductive values of basic life history stages in a historical
matrix are not provided (the <code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code> function
estimates these on the basis of stage description information provided in the
<code>lefkoMat</code> object used as input in that function). This function can
handle large and sparse matrices, and so can be used with large historical
matrices, IPMs, age x stage matrices, as well as smaller ahistorical
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
repvalue3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  force_sparse = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repvalue3.list_+3A_mats">mats</code></td>
<td>
<p>A list of population projection matrices, all in either class
<code>matrix</code> or class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value indicating whether to use deterministic
(<code>FALSE</code>) or stochastic (<code>TRUE</code>) analysis. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_times">times</code></td>
<td>
<p>An integer variable indicating number of occasions to project if
using stochastic analysis. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) when supplied with standard matrices. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="repvalue3.list_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of vector data frames characterizing the 
reproductive values for stages of each population projection matrix. This is 
given as the left eigenvector associated with largest real part of the
dominant eigenvalue, divided by the first non-zero element of the left 
eigenvector.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have several hundred rows and columns. Defaults
work best when matrices are very small and dense, or very large and sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repvalue3">repvalue3</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.dgCMatrix">repvalue3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.matrix">repvalue3.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

repvalue3(ehrlen3$A)

</code></pre>

<hr>
<h2 id='repvalue3.matrix'>Estimate Reproductive Value Vector for a Single Population Projection Matrix</h2><span id='topic+repvalue3.matrix'></span>

<h3>Description</h3>

<p><code>repvalue3.matrix()</code> returns the reproductive values for stages in a 
population projection matrix. The function makes no assumptions about whether
the matrix is ahistorical and simply provides standard reproductive values
corresponding to each row, meaning that the overall reproductive values of
basic life history stages in a historical matrix are not provided (the 
<code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code> function estimates these on the basis of
stage description information provided in the <code>lefkoMat</code> object used as
input in that function). This function can handle large and sparse matrices,
and so can be used with large historical matrices, IPMs, age x stage
matrices, as well as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
repvalue3(mats, force_sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repvalue3.matrix_+3A_mats">mats</code></td>
<td>
<p>A population projection matrix.</p>
</td></tr>
<tr><td><code id="repvalue3.matrix_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) when supplied with standard matrices. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="repvalue3.matrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vector data frame characterizing the 
reproductive values for stages of a population projection matrix. This is 
given as the left eigenvector associated with largest real part of the
dominant eigenvalue, divided by the first non-zero element of the left 
eigenvector.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repvalue3">repvalue3</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.lefkoMat">repvalue3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.dgCMatrix">repvalue3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+repvalue3.list">repvalue3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
repvalue3(ehrlen3mean$A[[1]])

</code></pre>

<hr>
<h2 id='ricker3'>Two-parameter Ricker function</h2><span id='topic+ricker3'></span>

<h3>Description</h3>

<p>Function <code>ricker3()</code> creates a vector of values produced by the two-
parameter Ricker function as applied with a user-specified time lag. The
two-parameter Ricker function is given as 
<code class="reqn">\phi_{t+1} = \phi_t \alpha e^{-\beta n_t}</code>. Here, if no
<code>separate_N</code> vector is provided, then <code class="reqn">n_t = \phi_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ricker3(
  start_value,
  alpha,
  beta,
  time_steps = 100L,
  time_lag = 1L,
  pre0_subs = FALSE,
  pre0_value = 0,
  substoch = 0L,
  separate_N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ricker3_+3A_start_value">start_value</code></td>
<td>
<p>A positive number to start the return vector in time 0.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter in the two-parameter Ricker function. Must
be non-negative.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_beta">beta</code></td>
<td>
<p>The beta parameter in the two-parameter Ricker function.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_time_steps">time_steps</code></td>
<td>
<p>The number of time steps to run the projection. Must be a
positive integer.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_time_lag">time_lag</code></td>
<td>
<p>A positive integer denoting the number of time steps back
for the value of phi in the two-parameter Ricker function.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_pre0_subs">pre0_subs</code></td>
<td>
<p>A logical value indicating whether to use a number other
than that given in <code>start_value</code> for values of phi lagged from times
prior to time 0.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_pre0_value">pre0_value</code></td>
<td>
<p>A positive number to use for phi lagged from times prior
to time 0. Only used if <code>pre0_subs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ricker3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating the kind of substochasticity to
use. Values include: <code>0</code>, no substochasticity enforced (the default);
<code>1</code>, all numbers must be non-negative; and <code>2</code>, all numbers should
be forced to the interval [0, 1].</p>
</td></tr>
<tr><td><code id="ricker3_+3A_separate_n">separate_N</code></td>
<td>
<p>An optional numeric vector with values of N in each time,
if phi is to be treated as different from N in the two-parameter model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values showing values projected under the two-
parameter Ricker function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial_run1 &lt;- ricker3(1, alpha = 0.5, beta = -0.009)
plot(trial_run1)

trial_run2 &lt;- ricker3(1, alpha = 0.5, beta = 0.009)
plot(trial_run2)

trial_run3 &lt;- ricker3(1, alpha = 1, beta = -0.009)
plot(trial_run3)

trial_run4 &lt;- ricker3(1, alpha = 1, beta = 0.009)
plot(trial_run4)

trial_run5 &lt;- ricker3(1, alpha = 5, beta = -0.009)
plot(trial_run5)

trial_run6 &lt;- ricker3(1, alpha = 5, beta = 0.009)
plot(trial_run6)

used_Ns &lt;- c(10, 15, 12, 14, 14, 150, 15, 1, 5, 7, 9, 14, 13, 16, 17, 19,
  25, 26)
trial_run7 &lt;- ricker3(1, alpha = 1, beta = -0.009, separate_N = used_Ns)
plot(trial_run7)

</code></pre>

<hr>
<h2 id='rlefko2'>Create Raw Ahistorical Matrix Projection Model</h2><span id='topic+rlefko2'></span>

<h3>Description</h3>

<p>Function <code>rlefko2()</code> returns raw ahistorical MPMs, including the
associated component transition and fecundity matrices, a data frame
describing the ahistorical stages used, and a data frame describing the
population, patch, and occasion time associated with each matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlefko2(
  data,
  stageframe,
  year = "all",
  pop = NULL,
  patch = NULL,
  censor = FALSE,
  stages = NULL,
  alive = c("alive3", "alive2"),
  obsst = NULL,
  size = c("sizea3", "sizea2"),
  sizeb = NULL,
  sizec = NULL,
  repst = c("repstatus3", "repstatus2"),
  matst = c("matstatus3", "matstatus2"),
  fec = c("feca3", "feca2"),
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  yearcol = NULL,
  popcol = NULL,
  patchcol = NULL,
  indivcol = NULL,
  censorcol = NULL,
  censorkeep = 0,
  NRasRep = FALSE,
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlefko2_+3A_data">data</code></td>
<td>
<p>A vertical demographic data frame, with variables corresponding 
to the naming conventions in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_stageframe">stageframe</code></td>
<td>
<p>A stageframe object that includes information on the size,
observation status, propagule status, reproduction status, immaturity status,
and maturity status of each ahistorical stage.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set
of such values, given in values associated with the <code>year</code> term used in
vital rate model development. Can also equal <code>"all"</code>, in which case
matrices will be estimated for all occasion times. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_pop">pop</code></td>
<td>
<p>A variable designating which populations will have matrices
estimated. Should be set to specific population names, or to <code>"all"</code> if
all populations should have matrices estimated.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to <code>"all"</code>
if matrices should be estimated for all patches. Defaults to <code>NA</code>, in
which case patch designations are ignored..</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_censor">censor</code></td>
<td>
<p>If <code>TRUE</code>, then data will be removed according to the
variable set in <code>censorcol</code>, such that only data with censor values
equal to <code>censorkeep</code> will remain. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_stages">stages</code></td>
<td>
<p>An optional vector denoting the names of the variables within
the main vertical dataset coding for the stages of each individual in
occasions <em>t</em>+1 and <em>t</em>. The names of stages in these variables
should match those used in the <code>stageframe</code> exactly. If left blank, then
<code>rlefko2()</code> will attempt to infer stages by matching values of
<code>alive</code>, <code>size</code>, <code>repst</code>, and <code>matst</code> to characteristics
noted in the associated <code>stageframe</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_alive">alive</code></td>
<td>
<p>A vector of names of binomial variables corresponding to status
as alive (<code>1</code>) or dead (<code>0</code>) in occasions <em>t</em>+1 and <em>t</em>,
respectively.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_obsst">obsst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
observation status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>NULL</code>, in which case observation status is
not used.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_size">size</code></td>
<td>
<p>A vector of names of variables coding the primary size variable
in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>c("sizea3", "sizea2")</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector of names of variables coding the secondary size
variable in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_sizec">sizec</code></td>
<td>
<p>A vector of names of variables coding the tertiary size
variable in occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_repst">repst</code></td>
<td>
<p>A vector of names of variables coding reproductive status in
occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to 
<code>c("repstatus3", "repstatus2")</code>. Must be supplied if <code>stages</code> is
not provided.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_matst">matst</code></td>
<td>
<p>A vector of names of variables coding maturity status in
occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to
<code>c("matstatus3", "matstatus2")</code>. Must be supplied if <code>stages</code> is
not provided.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_fec">fec</code></td>
<td>
<p>A vector of names of variables coding fecundity in occasions
<em>t</em>+1 and <em>t</em>, respectively. Defaults to <code>c("feca3", "feca2")</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for fecundity. This data
frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code> function.
Should be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of 0s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with 1 equaling full fecundity). If left blank,
and no <code>supplement</code> is provided, then <code>rlefko2()</code> will assume that
all stages marked as reproductive produce offspring at 1x that of estimated
fecundity, and that offspring production will yield the first stage noted as
propagule or immature. To prevent this behavior, input just <code>0</code>, which
will result in fecundity being estimated only for transitions noted in
<code>supplement</code> above. Must be the dimensions of an ahistorical matrix.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_yearcol">yearcol</code></td>
<td>
<p>The variable name or column number corresponding to occasion 
<em>t</em> in the dataset.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_popcol">popcol</code></td>
<td>
<p>The variable name or column number corresponding to the
identity of the population.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_patchcol">patchcol</code></td>
<td>
<p>The variable name or column number corresponding to patch in
the dataset.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_indivcol">indivcol</code></td>
<td>
<p>The variable name or column number coding individual
identity.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_censorcol">censorcol</code></td>
<td>
<p>The variable name or column number denoting the censor
status. Only needed if <code>censor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable denoting data elements to
keep. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_nrasrep">NRasRep</code></td>
<td>
<p>If <code>data</code> does not include stage assignments, then this
option determines whether non-reproductive and reproductive individuals
should be lumped into the same stages. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove ahistorical stages
associated with only zero transitions. These are removed only if the
respective row and column sums in ALL matrices estimated equal 0. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko2_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. Its structure is a list with the
following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted populations,
patches, and occasions. All matrices output in the <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Set to NA for ahistorical matrices.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. In this function, it
is set to NA. Only used in output to function <code>aflefko2</code>().</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each 
matrix in order.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input
in function-based MPMs. Empty in this function.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to 0, then only fecundity transitions noted in the
supplement will be set to non-zero values. To use the default behavior of
setting all reproductive stages to reproduce at full fecundity into immature
and propagule stages but also incorporate given or proxy survival
transitions, input those given and proxy transitions through the
<code>overwrite</code> options.
</p>
<p>The reproduction matrix (field <code>repmatrix</code>) may only be supplied as
ahistorical. If provided as historical, then <code>rlefko2()</code> will fail and
produce an error.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations. Should the aim of analysis be a general
MPM that does not distinguish these patches or subpopulations, the
<code>patchcol</code> variable should be left to <code>NA</code>, which is the default.
Otherwise the variable identifying patch needs to be named.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order WILL
lead to erroneous calculations, and may lead to fatal errors.
</p>
<p>Although this function is capable of assigning stages given an input
stageframe, it lacks the power of <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code> in this regard. Users are strongly
encouraged to use the latter two functions for stage assignment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988, 
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88", 
  fecacol = "Intactseed88", deadacol = "Dead1988", nonobsacol = "Dormant1988", 
  stageassign = lathframe, stagesize = "sizea", censorcol = "Missing1988", 
  censorkeep = NA, censor = TRUE)

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "rep", "rep"),
  givenrate = c(0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, 0.345, 0.054),
  type = c(1, 1, 3, 3), stageframe = lathframe, historical = FALSE)

ehrlen2 &lt;- rlefko2(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2"), supplement = lathsupp2, yearcol = "year2",
  indivcol = "individ")

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

</code></pre>

<hr>
<h2 id='rlefko3'>Create Raw Historical Matrix Projection Model</h2><span id='topic+rlefko3'></span>

<h3>Description</h3>

<p>Function <code>rlefko3()</code> returns raw historical MPMs, including the
associated component transition and fecundity matrices, data frames
describing the ahistorical stages used and the historical paired stages, and
a data frame describing the population, patch, and occasion time associated
with each matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlefko3(
  data,
  stageframe,
  year = "all",
  pop = NULL,
  patch = NULL,
  censor = FALSE,
  stages = NULL,
  alive = c("alive3", "alive2", "alive1"),
  obsst = NULL,
  size = c("sizea3", "sizea2", "sizea1"),
  sizeb = NULL,
  sizec = NULL,
  repst = c("repstatus3", "repstatus2", "repstatus1"),
  matst = c("matstatus3", "matstatus2", "matstatus1"),
  fec = c("feca3", "feca2", "feca1"),
  supplement = NULL,
  repmatrix = NULL,
  overwrite = NULL,
  yearcol = NULL,
  popcol = NULL,
  patchcol = NULL,
  indivcol = NULL,
  censorcol = NULL,
  censorkeep = 0,
  NRasRep = FALSE,
  format = "ehrlen",
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlefko3_+3A_data">data</code></td>
<td>
<p>A vertical demographic data frame, with variables corresponding 
to the naming conventions in <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_stageframe">stageframe</code></td>
<td>
<p>A stageframe object that includes information on the size,
observation status, propagule status, reproduction status, immaturity status,
and maturity status of each ahistorical stage.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set of
such values, given in values associated with the <code>year</code> term used in
vital rate model development. Can also equal <code>"all"</code>, in which case
matrices will be estimated for all occasions. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_pop">pop</code></td>
<td>
<p>A variable designating which populations will have matrices
estimated. Should be set to specific population names, or to <code>"all"</code> if
all populations should have matrices estimated.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to <code>"all"</code>
if matrices should be estimated for all patches. Defaults to <code>NA</code>, in
which case patch designations are ignored..</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_censor">censor</code></td>
<td>
<p>If <code>TRUE</code>, then data will be removed according to the
variable set in <code>censorcol</code>, such that only data with censor values
equal to <code>censorkeep</code> will remain. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_stages">stages</code></td>
<td>
<p>An optional vector denoting the names of the variables within
the main vertical dataset coding for the stages of each individual in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1. The names of stages in these
variables should match those used in the <code>stageframe</code> exactly. If left
blank, then <code>rlefko3()</code> will attempt to infer stages by matching values
of <code>alive</code>, <code>size</code>, <code>repst</code>, and <code>matst</code> to
characteristics noted in the associated <code>stageframe</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_alive">alive</code></td>
<td>
<p>A vector of names of binomial variables corresponding to status
as alive (<code>1</code>) or dead (<code>0</code>) in occasions <em>t</em>+1, <em>t</em>, and
<em>t</em>-1, respectively.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_obsst">obsst</code></td>
<td>
<p>A vector of names of binomial variables corresponding to
observation status in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1,
respectively. Defaults to <code>NULL</code>, in which case observation status is
not used.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_size">size</code></td>
<td>
<p>A vector of names of variables coding the primary size variable
in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to 
<code>c("sizea3", "sizea2", "sizea1")</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector of names of variables coding the secondary size
variable in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_sizec">sizec</code></td>
<td>
<p>A vector of names of variables coding the tertiary size
variable in occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively.
Defaults to <code>NULL</code>, in which case this variable is not used.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_repst">repst</code></td>
<td>
<p>A vector of names of variables coding reproductive status in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to 
<code>c("repstatus3", "repstatus2", "repstatus1")</code>. Must be supplied if
<code>stages</code> is not provided.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_matst">matst</code></td>
<td>
<p>A vector of names of variables coding maturity status in
occasions <em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to
<code>c("matstatus3", "matstatus2", "matstatus1")</code>. Must be supplied if
<code>stages</code> is not provided.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_fec">fec</code></td>
<td>
<p>A vector of names of variables coding fecundity in occasions
<em>t</em>+1, <em>t</em>, and <em>t</em>-1, respectively. Defaults to
<code>c("feca3", "feca2", "feca1")</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for fecundity. This data
frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code> function.
Should be used in place of or in addition to an overwrite table (see 
<code>overwrite</code> below) and a reproduction matrix (see <code>repmatrix</code>
below).</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_repmatrix">repmatrix</code></td>
<td>
<p>An optional reproduction matrix. This matrix is composed
mostly of 0s, with non-zero entries acting as element identifiers and
multipliers for fecundity (with 1 equaling full fecundity). If left blank,
and no <code>supplement</code> is provided, then <code>rlefko3()</code> will assume that
all stages marked as reproductive produce offspring at 1x that of estimated
fecundity, and that offspring production will yield the first stage noted as
propagule or immature. To prevent this behavior, input just <code>0</code>, which
will result in fecundity being estimated only for transitions noted in
<code>supplement</code> above. May be the dimensions of either a historical or an
ahistorical matrix. If the former, then the fecundity estimation of this
function may be unpredictable. If the latter, then all stages will be used in
occasion <em>t</em>-1 for each suggested ahistorical transition.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional data frame developed with the
<code><a href="#topic+overwrite">overwrite</a>()</code> function describing transitions to be overwritten
either with given values or with other estimated transitions. Note that this
function supplements overwrite data provided in <code>supplement</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_yearcol">yearcol</code></td>
<td>
<p>The variable name or column number corresponding to occasion
<em>t</em> in the dataset.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_popcol">popcol</code></td>
<td>
<p>The variable name or column number corresponding to the
identity of the population.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_patchcol">patchcol</code></td>
<td>
<p>The variable name or column number corresponding to patch in 
the dataset.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_indivcol">indivcol</code></td>
<td>
<p>The variable name or column number coding individual
identity.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_censorcol">censorcol</code></td>
<td>
<p>The variable name or column number denoting the censor
status. Only needed if <code>censor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable denoting data elements to
keep. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_nrasrep">NRasRep</code></td>
<td>
<p>If <code>data</code> does not include stage assignments, then this
option determines whether non-reproductive and reproductive individuals
should be lumped into the same stages. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_format">format</code></td>
<td>
<p>A string indicating whether to estimate matrices in
<code>ehrlen</code> format or <code>deVries</code> format. The latter adds one unborn
prior stage to account for the prior state of newborns. Defaults to
<code>ehrlen</code> format.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove historical stages
associated exclusively with zero transitions. These are removed only if the
respective row and column sums in ALL matrices estimated equal 0. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rlefko3_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. Its structure is a list with the
following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted populations,
patches, and occasions. All matrices output in the <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. In this function, it
is set to NA. Only used in output to function <code>aflefko2</code>().</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each 
matrix in order.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input
in function-based MPMs. Empty in this function.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>The default behavior of this function is to estimate fecundity with regards
to transitions specified via associated fecundity multipliers in either
<code>supplement</code> or <code>repmatrix</code>. If both of these fields are left
empty, then fecundity will be estimated at full for all transitions leading
from reproductive stages to immature and propagule stages. However, if a
<code>supplement</code> is provided and a <code>repmatrix</code> is not, or if
<code>repmatrix</code> is set to 0, then only fecundity transitions noted in the
supplement will be set to non-zero values. To use the default behavior of
setting all reproductive stages to reproduce at full fecundity into immature
and propagule stages but incorporate given or proxy survival transitions,
input those given and proxy transitions through the <code>overwrite</code> option.
</p>
<p>The reproduction matrix (field <code>repmatrix</code>) may be supplied as either
historical or ahistorical. If provided as ahistorical, then <code>flefko3()</code>
will assume that all historical transitions involving stages noted for
occasions <em>t</em> and <em>t</em>+1 should be set to the respective fecundity
multipliers noted.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations. Should the aim of analysis be a general
MPM that does not distinguish these patches or subpopulations, the
<code>patchcol</code> variable should be left to <code>NA</code>, which is the default.
Otherwise the variable identifying patch needs to be named.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1, <em>t</em>, and <em>t</em>-1. Rearranging
the order WILL lead to erroneous calculations, and may lead to
fatal errors.
</p>
<p>Although this function is capable of assigning stages given an input
stageframe, it lacks the power of <code><a href="#topic+verticalize3">verticalize3</a>()</code> and
<code><a href="#topic+historicalize3">historicalize3</a>()</code> in this regard. Users are strongly
encouraged to use the latter two functions for stage assignment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>
<p><code><a href="#topic+rleslie">rleslie</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec, 
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988, 
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9, 
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88", 
  fecacol = "Intactseed88", deadacol = "Dead1988", nonobsacol = "Dormant1988", 
  stageassign = lathframe, stagesize = "sizea", censorcol = "Missing1988", 
  censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw,
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"),
  supplement = cypsupp3r, yearcol = "year2", patchcol = "patchid",
  indivcol = "individ")

</code></pre>

<hr>
<h2 id='rleslie'>Create Raw Leslie (Age-based) Matrix Projection Model</h2><span id='topic+rleslie'></span>

<h3>Description</h3>

<p>Function <code>rleslie()</code> returns raw Leslie MPMs, including the
associated component transition and fecundity matrices, a data frame
describing the ages used, and a data frame describing the population, patch,
and occasion time associated with each matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rleslie(
  data,
  start_age = NA,
  last_age = NA,
  continue = TRUE,
  fecage_min = NA,
  fecage_max = NA,
  alive = c("alive3", "alive2", "alive1"),
  repst = c("repstatus3", "repstatus2", "repstatus1"),
  fec = c("feca3", "feca2", "feca1"),
  agecol = "obsage",
  year = "all",
  supplement = NULL,
  pop = NULL,
  patch = NULL,
  yearcol = NULL,
  popcol = NULL,
  patchcol = NULL,
  indivcol = NULL,
  censor = FALSE,
  censorcol = NULL,
  censorkeep = 0,
  fectime = 2,
  fecmod = 1,
  prebreeding = TRUE,
  reduce = FALSE,
  simple = FALSE,
  err_check = FALSE,
  sparse_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rleslie_+3A_data">data</code></td>
<td>
<p>A vertical demographic data frame, with variables corresponding 
to the naming conventions in <code><a href="#topic+verticalize3">verticalize3</a>()</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_start_age">start_age</code></td>
<td>
<p>The age from which to start the matrix. Defaults to
<code>NA</code>, age <code>1</code> is used if <code>prebreeding = TRUE</code>, and age
<code>0</code> is used if <code>prebreeding = FALSE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_last_age">last_age</code></td>
<td>
<p>The final age to use in the matrix. Defaults to <code>NA</code>, in
which case the highest age in the dataset is used.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_continue">continue</code></td>
<td>
<p>A logical value designating whether to allow continued
survival of individuals past the final age noted in the stageframe, using the 
demographic characteristics of the final age. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_fecage_min">fecage_min</code></td>
<td>
<p>The minimum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
starting in the minimum age observed in the dataset.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_fecage_max">fecage_max</code></td>
<td>
<p>The maximum age at which reproduction is possible. Defaults
to <code>NA</code>, which is interpreted to mean that fecundity should be assessed
until the final observed age.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_alive">alive</code></td>
<td>
<p>A vector of names of binomial variables corresponding to status
as alive (<code>1</code>) or dead (<code>0</code>) in occasions <em>t</em>+1 ans <em>t</em>,
respectively.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_repst">repst</code></td>
<td>
<p>A vector of names of variables coding reproductive status in
occasions <em>t</em>+1 and <em>t</em>, respectively. Defaults to 
<code>c("repstatus3", "repstatus2")</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_fec">fec</code></td>
<td>
<p>A vector of names of variables coding fecundity in occasions
<em>t</em>+1 and <em>t</em>, respectively. Defaults to <code>c("feca3", "feca2")</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_agecol">agecol</code></td>
<td>
<p>The name or column number of the variable coding for age in
<code>data</code>. Defaults to <code>"obsage"</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_year">year</code></td>
<td>
<p>A variable corresponding to observation occasion, or a set
of such values, given in values associated with the <code>year</code> term used in
vital rate model development. Can also equal <code>"all"</code>, in which case
matrices will be estimated for all occasion times. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_supplement">supplement</code></td>
<td>
<p>An optional data frame of class <code>lefkoSD</code> that
provides supplemental data that should be incorporated into the MPM. Three
kinds of data may be integrated this way: transitions to be estimated via the
use of proxy transitions, transition overwrites from the literature or
supplemental studies, and transition multipliers for survival and fecundity.
This data frame should be produced using the <code><a href="#topic+supplemental">supplemental</a>()</code>
function.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_pop">pop</code></td>
<td>
<p>A variable designating which populations will have matrices
estimated. Should be set to specific population names, or to <code>"all"</code> if
all populations should have matrices estimated.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_patch">patch</code></td>
<td>
<p>A variable designating which patches or subpopulations will have
matrices estimated. Should be set to specific patch names, or to <code>"all"</code>
if matrices should be estimated for all patches. Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_yearcol">yearcol</code></td>
<td>
<p>The variable name or column number corresponding to occasion 
<em>t</em> in the dataset.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_popcol">popcol</code></td>
<td>
<p>The variable name or column number corresponding to the
identity of the population.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_patchcol">patchcol</code></td>
<td>
<p>The variable name or column number corresponding to patch in
the dataset.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_indivcol">indivcol</code></td>
<td>
<p>The variable name or column number coding individual
identity.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_censor">censor</code></td>
<td>
<p>If <code>TRUE</code>, then data will be removed according to the
variable set in <code>censorcol</code>, such that only data with censor values
equal to <code>censorkeep</code> will remain. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_censorcol">censorcol</code></td>
<td>
<p>The variable name or column number denoting the censor
status. Only needed if <code>censor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable denoting data elements to
keep. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_fectime">fectime</code></td>
<td>
<p>An integer indicating whether to estimate fecundity using
the variable given for <code>fec</code> in time <em>t</em> (<code>2</code>) or time
<em>t</em>+1 (<code>3</code>).</p>
</td></tr>
<tr><td><code id="rleslie_+3A_fecmod">fecmod</code></td>
<td>
<p>A scalar multiplier for fecundity. Defaults to <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical value indicating whether the life history model
is a pre-breeding model. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_reduce">reduce</code></td>
<td>
<p>A logical value denoting whether to remove ages associated with
only zero transitions. These are removed only if the respective row and
column sums in ALL matrices estimated equal 0. Defaults to <code>FALSE</code>, and
should generally not be used in age-based MPMs.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_simple">simple</code></td>
<td>
<p>A logical value indicating whether to produce <code>A</code>,
<code>U</code>, and <code>F</code> matrices, or only the latter two. Defaults to
<code>FALSE</code>, in which case all three are output.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to append extra
information used in matrix calculation within the output list. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rleslie_+3A_sparse_output">sparse_output</code></td>
<td>
<p>A logical value indicating whether to output matrices
in sparse format. Defaults to <code>FALSE</code>, in which case all matrices are
output in standard matrix format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will return
an object of class <code>lefkoMat</code>, which is a list that holds the matrix
projection model and all of its metadata. Its structure is a list with the
following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>A list of full projection matrices in order of sorted populations,
patches, and occasions. All matrices output in the <code>matrix</code> class, or in
the <code>dgCMatrix</code> class from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>A list of survival transition matrices sorted as in <code>A</code>. All 
matrices output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class
from the <code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>A list of fecundity matrices sorted as in <code>A</code>. All matrices 
output in the <code>matrix</code> class, or in the <code>dgCMatrix</code> class from the
<code>Matrix</code> package if sparse.</p>
</td></tr>
<tr><td><code>hstages</code></td>
<td>
<p>A data frame matrix showing the pairing of ahistorical stages
used to create historical stage pairs. Set to NA for ahistorical matrices.</p>
</td></tr>
<tr><td><code>agestages</code></td>
<td>
<p>A data frame showing age-stage pairs. In this function, it
is set to NA. Only used in output to function <code>aflefko2</code>().</p>
</td></tr>
<tr><td><code>ahstages</code></td>
<td>
<p>A data frame detailing the characteristics of associated
ahistorical stages, in the form of a modified stageframe that includes
status as an entry stage through reproduction.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>A data frame giving the population, patch, and year of each 
matrix in order.</p>
</td></tr>
<tr><td><code>dataqc</code></td>
<td>
<p>A vector showing the numbers of individuals and rows in the
vertical dataset used as input.</p>
</td></tr>
<tr><td><code>matrixqc</code></td>
<td>
<p>A short vector describing the number of non-zero elements in
<code>U</code> and <code>F</code> matrices, and the number of annual matrices.</p>
</td></tr>
<tr><td><code>modelqc</code></td>
<td>
<p>This is the <code>qc</code> portion of the <code>modelsuite</code> input
in function-based MPMs. Empty in this function.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>In order to accomodate survival to time <em>t</em>+1 in the final year of a
study, the maximum age assessed if no input <code>last_age</code> is provided is
one time step past the final described age.
</p>
<p>Users may at times wish to estimate MPMs using a dataset incorporating
multiple patches or subpopulations. Should the aim of analysis be a general
MPM that does not distinguish these patches or subpopulations, the
<code>patchcol</code> variable should be left to <code>NA</code>, which is the default.
Otherwise the variable identifying patch needs to be named.
</p>
<p>Input options including multiple variable names must be entered in the order
of variables in occasion <em>t</em>+1 and <em>t</em>. Rearranging the order WILL
lead to erroneous calculations, and may lead to fatal errors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpm_create">mpm_create</a>()</code>
</p>
<p><code><a href="#topic+flefko3">flefko3</a>()</code>
</p>
<p><code><a href="#topic+flefko2">flefko2</a>()</code>
</p>
<p><code><a href="#topic+aflefko2">aflefko2</a>()</code>
</p>
<p><code><a href="#topic+arlefko2">arlefko2</a>()</code>
</p>
<p><code><a href="#topic+fleslie">fleslie</a>()</code>
</p>
<p><code><a href="#topic+rlefko3">rlefko3</a>()</code>
</p>
<p><code><a href="#topic+rlefko2">rlefko2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  age_offset = 3, NAas0 = TRUE, NRasRep = TRUE)

cyp_rl &lt;- rleslie(data = cypraw_v1, start_age = 0, last_age = 4,
  continue = TRUE, fecage_min = 3, year = "all", pop = NA, patch = "all",
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

</code></pre>

<hr>
<h2 id='sensitivity3'>Estimate Sensitivity of Population Growth Rate to Matrix Elements</h2><span id='topic+sensitivity3'></span>

<h3>Description</h3>

<p><code>sensitivity3()</code> is a generic function that returns the sensitivity of
the population growth rate to the elements of the matrices in a matrix
population model. Currently, this function estimates both deterministic and
stochastic sensitivities, where the growth rate is <code class="reqn">\lambda</code> in the
former case and the log of the stochastic <code class="reqn">\lambda</code> in the latter case.
This function is made to handle very large and sparse matrices supplied as
<code>lefkoMat</code> objects, as lists of matrices, and as individual matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity3_+3A_mats">mats</code></td>
<td>
<p>A lefkoMat object, or population projection matrix, for which
the stable stage distribution is desired.</p>
</td></tr>
<tr><td><code id="sensitivity3_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the <code>mats</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity3.lefkoMat">sensitivity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.matrix">sensitivity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.dgCMatrix">sensitivity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.list">sensitivity3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

sensitivity3(ehrlen3)

</code></pre>

<hr>
<h2 id='sensitivity3.dgCMatrix'>Estimate Sensitivity of Population Growth Rate of a Single Matrix</h2><span id='topic+sensitivity3.dgCMatrix'></span>

<h3>Description</h3>

<p><code>sensitivity3.dgCMatrix()</code> returns the sensitivities of <code class="reqn">\lambda</code> to
elements of a single, sparse matrix. Because this handles only one matrix,
sensitivities are inherently deterministic and based on the dominant eigen
value as the best metric of the population growth rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
sensitivity3(mats, sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity3.dgCMatrix_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.dgCMatrix_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="sensitivity3.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a single deterministic sensitivity matrix.
</p>


<h3>Notes</h3>

<p>All sensitivity matrix outputs from this function are in standard matrix
format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity3">sensitivity3</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.lefkoMat">sensitivity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.list">sensitivity3.list</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.matrix">sensitivity3.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ", sparse_output = TRUE)

sensitivity3(ehrlen3$A[[1]])

</code></pre>

<hr>
<h2 id='sensitivity3.lefkoMat'>Estimate Sensitivity of Population Growth Rate of a lefkoMat Object</h2><span id='topic+sensitivity3.lefkoMat'></span>

<h3>Description</h3>

<p><code>sensitivity3.lefkoMat()</code> returns the sensitivities of population growth
rate to elements of all <code>$A</code> matrices in an object of class
<code>lefkoMat</code>. If deterministic, then <code class="reqn">\lambda</code> is taken as the
population growth rate. If stochastic, then the log of stochastic
<code class="reqn">\lambda</code>, or the log stochastic growth rate, is taken as the population
growth rate. This function can handle large and sparse matrices, and so can
be used with large historical matrices, IPMs, age x stage matrices, as well
as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
sensitivity3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  sparse = "auto",
  append_mats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity3.lefkoMat_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value determining whether to conduct a
deterministic (FALSE) or stochastic (TRUE) sensitivity analysis. Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_times">times</code></td>
<td>
<p>The number of occasions to project forward in stochastic
simulation. Defaults to <code>10000</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_append_mats">append_mats</code></td>
<td>
<p>A logical value indicating whether to include the original
A, U, and F matrices in the output <code>lefkoSens</code> object.</p>
</td></tr>
<tr><td><code id="sensitivity3.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>lefkoSens</code>, which is a
list of 8 elements. The first, <code>h_sensmats</code>, is a list of historical
sensitivity matrices (<code>NULL</code> if an ahMPM is used as input). The second,
<code>ah_elasmats</code>, is a list of either ahistorical sensitivity matrices if
an ahMPM is used as input, or, if an hMPM is used as input, then the result
is a list of ahistorical matrices based on the equivalent historical
dependencies assumed in the input historical matrices. The third element,
<code>hstages</code>, is a data frame showing historical stage pairs (<code>NULL</code>
if an ahMPM used as input). The fourth element, <code>agestages</code>, show the
order of age-stage combinations, if age-by-stage MPMs have been supplied. The
fifth element, <code>ahstages</code>, is a data frame showing the order of
ahistorical stages. The last 3 elements are the A, U, and F portions of the
input.
</p>


<h3>Notes</h3>

<p>All sensitivity matrix outputs from this function are in standard matrix
format.
</p>
<p>Deterministic sensitivities are estimated as eqn. 9.14 in Caswell (2001,
Matrix Population Models). Stochastic sensitivities are estimated as eqn.
14.97 in Caswell (2001). Note that stochastic sensitivities are of the log of
the stochastic <code class="reqn">\lambda</code>.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>The <code>time_weights</code> and <code>steps</code> arguments are now deprecated.
Instead, please use the <code>tweights</code> and <code>times</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity3">sensitivity3</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.matrix">sensitivity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.dgCMatrix">sensitivity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.list">sensitivity3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

sensitivity3(ehrlen3, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='sensitivity3.list'>Estimate Sensitivity of Population Growth Rate of a List of Matrices</h2><span id='topic+sensitivity3.list'></span>

<h3>Description</h3>

<p><code>sensitivity3.list()</code> returns the sensitivities of population growth
rate to elements of matrices supplied in a list. The sensitivity analysis can
be deterministic or stochastic, but if the latter then at least two A
matrices must be included in the list. This function can handle large and
sparse matrices, and so can be used with large historical matrices, IPMs,
age x stage matrices, as well as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
sensitivity3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  historical = FALSE,
  seed = NA,
  sparse = "auto",
  append_mats = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity3.list_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value determining whether to conduct a
deterministic (FALSE) or stochastic (TRUE) sensitivity analysis. Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_times">times</code></td>
<td>
<p>The number of occasions to project forward in stochastic
simulation. Defaults to 10,000.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_historical">historical</code></td>
<td>
<p>A logical value indicating whether matrices are historical.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_append_mats">append_mats</code></td>
<td>
<p>A logical value indicating whether to include the original
matrices input as object <code>mats</code> in the output <code>lefkoSense</code> object.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="sensitivity3.list_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object of class <code>lefkoSens</code>, which is a
list of 8 elements. The first, <code>h_sensmats</code>, is a list of historical
sensitivity matrices (<code>NULL</code> if an ahMPM is used as input). The second,
<code>ah_elasmats</code>, is a list of ahistorical sensitivity matrices if an ahMPM
is used as input (<code>NULL</code> if an hMPM is used as input). The third
element, <code>hstages</code>, the fourth element, <code>agestages</code>, and the fifth
element, <code>ahstages</code>, are <code>NULL</code>. The last 3 elements include the
original A matrices supplied (as the <code>A</code> element), followed by
<code>NULL</code>s for the U and F elements.
</p>


<h3>Notes</h3>

<p>All sensitivity matrix outputs from this function are in standard matrix
format.
</p>
<p>Deterministic sensitivities are estimated as eqn. 9.14 in Caswell (2001,
Matrix Population Models). Stochastic sensitivities are estimated as eqn.
14.97 in Caswell (2001). Note that stochastic sensitivities are with regard
to the log of the stochastic <code class="reqn">\lambda</code>.
</p>
<p>Currently, this function does not estimate equivalent ahistorical stochastic
sensitivities for input historical matrices, due to the lack of guidance
input on the order of stages (guidance is provided within <code>lefkoMat</code>
objects).
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>
<p>The <code>time_weights</code> and <code>steps</code> arguments are now deprecated.
Instead, please use the <code>tweights</code> and <code>times</code> arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity3">sensitivity3</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.lefkoMat">sensitivity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.matrix">sensitivity3.matrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.dgCMatrix">sensitivity3.dgCMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

sensitivity3(ehrlen3$A)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

sensitivity3(cypmatrix2r$A)

</code></pre>

<hr>
<h2 id='sensitivity3.matrix'>Estimate Sensitivity of Population Growth Rate of a Single Matrix</h2><span id='topic+sensitivity3.matrix'></span>

<h3>Description</h3>

<p><code>sensitivity3.matrix()</code> returns the sensitivities of <code class="reqn">\lambda</code> to
elements of a single matrix. Because this handles only one matrix, the
sensitivities are inherently deterministic and based on the dominant eigen
value as the best metric of the population growth rate. This function can
handle large and sparse matrices, and so can be used with large historical
matrices, IPMs, age x stage matrices, as well as smaller ahistorical
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
sensitivity3(mats, sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity3.matrix_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="sensitivity3.matrix_+3A_sparse">sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix encoding
(<code>"yes"</code>) or dense matrix encoding (<code>"no"</code>). Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="sensitivity3.matrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a single deterministic sensitivity matrix.
</p>


<h3>Notes</h3>

<p>All sensitivity matrix outputs from this function are in standard matrix
format.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity3">sensitivity3</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.lefkoMat">sensitivity3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.dgCMatrix">sensitivity3.dgCMatrix</a>()</code>
</p>
<p><code><a href="#topic+sensitivity3.list">sensitivity3.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
sensitivity3(ehrlen3mean$A[[1]])

</code></pre>

<hr>
<h2 id='sf_create'>Create Stageframe for Population Matrix Projection Analysis</h2><span id='topic+sf_create'></span>

<h3>Description</h3>

<p>Function <code>sf_create()</code> returns a data frame describing each ahistorical
life history stage in the life history model. This data frame can be used as 
input into MPM creation functions including <code><a href="#topic+flefko3">flefko3</a>()</code>, 
<code><a href="#topic+flefko2">flefko2</a>()</code>, <code><a href="#topic+aflefko2">aflefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>,
<code><a href="#topic+rlefko2">rlefko2</a>()</code>, and <code><a href="#topic+arlefko2">arlefko2</a>()</code>, in which it
determines how each stage is treated during matrix estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_create(
  sizes,
  stagenames = NULL,
  sizesb = NULL,
  sizesc = NULL,
  repstatus = NULL,
  obsstatus = NULL,
  propstatus = NULL,
  matstatus = NULL,
  immstatus = NULL,
  minage = NULL,
  maxage = NULL,
  indataset = NULL,
  sizemin = NULL,
  sizebmin = NULL,
  sizecmin = NULL,
  sizemax = NULL,
  sizebmax = NULL,
  sizecmax = NULL,
  binhalfwidth = NULL,
  binhalfwidthb = NULL,
  binhalfwidthc = NULL,
  group = NULL,
  comments = NULL,
  roundsize = 5L,
  roundsizeb = 5L,
  roundsizec = 5L,
  ipmbins = 100L,
  ipmbinsb = NA_integer_,
  ipmbinsc = NA_integer_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_create_+3A_sizes">sizes</code></td>
<td>
<p>A numeric vector of the typical or representative size of each
life history stage. If making function-based MPMs, then this may be a
vector composed of the midpoints of each size bin, or simply of sizes
characteristic of the size bins. If denoting the boundary of an automated
size classification group, then should denote the absolute minimum size of
that group, or the absolute size of that group (see <code>Notes</code>).</p>
</td></tr>
<tr><td><code id="sf_create_+3A_stagenames">stagenames</code></td>
<td>
<p>A vector of stage names, in the same order as elements in
sizes. Can also be set to <code>ipm</code> for automated size classification (see
<code>Notes</code> section).</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizesb">sizesb</code></td>
<td>
<p>An optional numeric vector for a second size metric for each
life history stage. Only to be used if stages are defined by at least two
size metrics in all cases. Same issues apply as in <code>sizes</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizesc">sizesc</code></td>
<td>
<p>An optional numeric vector for a third size metric for each
life history stage. Only to be used if stages are defined by at least three
size metrics in all cases. Same issues apply as in <code>sizes</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_repstatus">repstatus</code></td>
<td>
<p>A vector denoting the binomial reproductive status of each
life history stage. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_obsstatus">obsstatus</code></td>
<td>
<p>A vector denoting the binomial observation status of each
life history stage. Defaults to <code>1</code>, but may be changed for
unobservable stages.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_propstatus">propstatus</code></td>
<td>
<p>A vector denoting whether each life history stage is a 
propagule. Such stages are generally only used in fecundity estimation. 
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_matstatus">matstatus</code></td>
<td>
<p>A vector denoting whether each stage is mature. Must be
composed of binomial values if given. Defaults to 1 for all stages defined 
in <code>sizes</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_immstatus">immstatus</code></td>
<td>
<p>A vector denoting whether each stage is immature. Must be
composed of binomial values if given. Defaults to the complement of vector
<code>matstatus</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_minage">minage</code></td>
<td>
<p>An optional vector denoting the minimum age at which a stage
can occur. Only used in age x stage matrix development. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_maxage">maxage</code></td>
<td>
<p>An optional vector denoting the maximum age at which a stage
should occur. Only used in age x stage matrix development. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_indataset">indataset</code></td>
<td>
<p>A vector designating which stages are found within the 
dataset. While <code><a href="#topic+rlefko2">rlefko2</a>()</code> and <code><a href="#topic+rlefko3">rlefko3</a>()</code> can use
all stages in the input dataset, <code><a href="#topic+flefko3">flefko3</a>()</code> and
<code><a href="#topic+flefko2">flefko2</a>()</code> can only handle size-classified stages with
non-overlapping combinations of size and status variables. Stages that do
not actually exist within the dataset should be marked as <code>0</code> in this
vector.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizemin">sizemin</code></td>
<td>
<p>A vector giving the absolute minimum values corresponding to
each size in the <code>sizes</code> vector. Requires associated values for
<code>sizemax</code> if used. Only required if not using <code>binhalfwidth</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizebmin">sizebmin</code></td>
<td>
<p>A vector giving the absolute minimum values corresponding to
each size in the <code>sizesb</code> vector. Requires associated values for
<code>sizebmax</code> if used. Only required if not using <code>binhalfwidthb</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizecmin">sizecmin</code></td>
<td>
<p>A vector giving the absolute minimum values corresponding to
each size in the <code>sizesc</code> vector. Requires associated values for
<code>sizecmax</code> if used. Only required if not using <code>binhalfwidthc</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizemax">sizemax</code></td>
<td>
<p>A vector giving the absolute maximum values corresponding to
each size in the <code>sizes</code> vector. Requires associated values for
<code>sizemin</code> if used. Only required if not using <code>binhalfwidth</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizebmax">sizebmax</code></td>
<td>
<p>A vector giving the absolute maximum values corresponding to
each size in the <code>sizesb</code> vector. Requires associated values for
<code>sizebmin</code> if used. Only required if not using <code>binhalfwidthb</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_sizecmax">sizecmax</code></td>
<td>
<p>A vector giving the absolute maximum values corresponding to
each size in the <code>sizesc</code> vector. Requires associated values for
<code>sizecmin</code> if used. Only required if not using <code>binhalfwidthc</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_binhalfwidth">binhalfwidth</code></td>
<td>
<p>A numeric vector giving the half-width of size bins.
Required if <code>sizemin</code> and <code>sizemax</code> are not used. Defaults to
<code>0.5</code> for all sizes.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_binhalfwidthb">binhalfwidthb</code></td>
<td>
<p>A numeric vector giving the half-width of size bins
used for the optional second size metric. Required if <code>sizebmin</code> and
<code>sizebmax</code> are not used but two or three size classes are used.
Defaults to <code>0.5</code> for all sizes.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_binhalfwidthc">binhalfwidthc</code></td>
<td>
<p>A numeric vector giving the half-width of size bins
used for the optional third size metric. Required if <code>sizecmin</code> and
<code>sizecmax</code> are not used but three size classes are used. Defaults to
<code>0.5</code> for all sizes.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_group">group</code></td>
<td>
<p>An integer vector providing information on each respective
stage's size classification group. If used, then function-based MPM creation
functions <code><a href="#topic+flefko2">flefko2</a>()</code>, <code><a href="#topic+flefko3">flefko3</a>()</code>, and
<code><a href="#topic+aflefko2">aflefko2</a>()</code> will estimate transitions only within these groups
and for allowed cross-group transitions noted within the supplement table.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_comments">comments</code></td>
<td>
<p>An optional vector of text entries holding useful text
descriptions of all stages.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_roundsize">roundsize</code></td>
<td>
<p>This parameter sets the precision of size classification,
and equals the number of digits used in rounding sizes. Defaults to
<code>5</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_roundsizeb">roundsizeb</code></td>
<td>
<p>This parameter sets the precision of size classification
in the optional second size metric, and equals the number of digits used in
rounding sizes. Defaults to <code>5</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_roundsizec">roundsizec</code></td>
<td>
<p>This parameter sets the precision of size classification
in the optional third size metric, and equals the number of digits used in
rounding sizes. Defaults to <code>5</code>.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_ipmbins">ipmbins</code></td>
<td>
<p>An integer giving the number of size bins to create using the
primary size classification variable. This number is in addition to any
stages that are not size classified. Defaults to <code>100</code>, and numbers
greater than this yield a warning about the loss of statistical power and
increasing chance of matrix over-parameterization resulting from increasing
numbers of stages.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_ipmbinsb">ipmbinsb</code></td>
<td>
<p>An optional integer giving the number of size bins to create
using the secondary size classification variable. This number is in addition
to any stages that are not size classified, as well as in addition to any
automated size classification using the primary and tertiary size variables.
Defaults to <code>NA</code>, and must be set to a positive integer for automated
size classification to progress.</p>
</td></tr>
<tr><td><code id="sf_create_+3A_ipmbinsc">ipmbinsc</code></td>
<td>
<p>An optional integer giving the number of size bins to create
using the tertiary size classification variable. This number is in addition
to any stages that are not size classified, as well as in addition to any
automated size classification using the primary and secondary size
variables. Defaults to <code>NA</code>, and must be set to a positive integer for
automated size classification to progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>stageframe</code>, which includes information
on the stage name, size, reproductive status, observation status, propagule 
status, immaturity status, maturity status, presence within the core dataset, 
stage group classification, raw bin half-width, and the minimum, 
center, and maximum of each size bin, as well as its width. If minimum and
maximum ages were specified, then these are also included. Also includes an 
empty string variable that can be used to describe stages meaningfully. This
object can be used as the <code>stageframe</code> input for <code><a href="#topic+flefko3">flefko3</a>()</code> 
<code><a href="#topic+flefko2">flefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>, and <code><a href="#topic+rlefko2">rlefko2</a>()</code>.
</p>
<p>Variables in this data frame include the following:
</p>
<table>
<tr><td><code>stage</code></td>
<td>
<p>The unique names of the stages to be analyzed.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The typical or representative size at which each stage occurs.</p>
</td></tr>
<tr><td><code>size_b</code></td>
<td>
<p>Size at which each stage occurs in terms of a second size
variable, if one exists.</p>
</td></tr>
<tr><td><code>size_c</code></td>
<td>
<p>Size at which each stage occurs in terms of a third size
variable, if one exists.</p>
</td></tr>
<tr><td><code>min_age</code></td>
<td>
<p>The minimum age at which the stage may occur.</p>
</td></tr>
<tr><td><code>max_age</code></td>
<td>
<p>The maximum age at which the stage may occur.</p>
</td></tr>
<tr><td><code>repstatus</code></td>
<td>
<p>A binomial variable showing whether each stage is
reproductive.</p>
</td></tr>
<tr><td><code>obsstatus</code></td>
<td>
<p>A binomial variable showing whether each stage is
observable.</p>
</td></tr>
<tr><td><code>propstatus</code></td>
<td>
<p>A binomial variable showing whether each stage is a
propagule.</p>
</td></tr>
<tr><td><code>immstatus</code></td>
<td>
<p>A binomial variable showing whether each stage can occur as
immature.</p>
</td></tr>
<tr><td><code>matstatus</code></td>
<td>
<p>A binomial variable showing whether each stage occurs in
maturity.</p>
</td></tr>
<tr><td><code>indataset</code></td>
<td>
<p>A binomial variable describing whether each stage occurs in
the input dataset.</p>
</td></tr>
<tr><td><code>binhalfwidth_raw</code></td>
<td>
<p>The half-width of the size bin, as input.</p>
</td></tr>
<tr><td><code>sizebin_min</code></td>
<td>
<p>The minimum size at which the stage may occur.</p>
</td></tr>
<tr><td><code>sizebin_max</code></td>
<td>
<p>The maximum size at which the stage may occur.</p>
</td></tr>
<tr><td><code>sizebin_center</code></td>
<td>
<p>The midpoint of the size bin at which the stage may
occur.</p>
</td></tr>
<tr><td><code>sizebin_width</code></td>
<td>
<p>The width of the size bin corresponding to the stage.</p>
</td></tr>
<tr><td><code>binhalfwidthb_raw</code></td>
<td>
<p>The half-width of the size bin of a second size
variable, as input.</p>
</td></tr>
<tr><td><code>sizebinb_min</code></td>
<td>
<p>The minimum size at which the stage may occur.</p>
</td></tr>
<tr><td><code>sizebinb_max</code></td>
<td>
<p>The maximum size at which the stage may occur.</p>
</td></tr>
<tr><td><code>sizebinb_center</code></td>
<td>
<p>The midpoint of the size bin at which the stage may
occur, in terms of a second size variable.</p>
</td></tr>
<tr><td><code>sizebinb_width</code></td>
<td>
<p>The width of the size bin corresponding to the stage,
in terms of a second size variable.</p>
</td></tr>
<tr><td><code>binhalfwidthc_raw</code></td>
<td>
<p>The half-width of the size bin of a third size
variable, as input.</p>
</td></tr>
<tr><td><code>sizebinc_min</code></td>
<td>
<p>The minimum size at which the stage may occur, in terms
of a third size variable.</p>
</td></tr>
<tr><td><code>sizebinc_max</code></td>
<td>
<p>The maximum size at which the stage may occur, in terms
of a third size variable.</p>
</td></tr>
<tr><td><code>sizebinc_center</code></td>
<td>
<p>The midpoint of the size bin at which the stage may
occur, in terms of a third size variable.</p>
</td></tr>
<tr><td><code>sizebinc_width</code></td>
<td>
<p>The width of the size bin corresponding to the stage,
in terms of a third size variable.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>An integer denoting the size classification group that the
stage falls within.</p>
</td></tr>
<tr><td><code>comments</code></td>
<td>
<p>A text field for stage descriptions.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Vectors used to create a stageframe may not mix <code>NA</code> values with
non-<code>NA</code> values.
</p>
<p>If an IPM or function-based matrix with automated size classification is
desired, then two stages that occur within the dataset and represent the
lower and upper size limits of the IPM must be marked with <code>ipm</code> in
the stagenames vector. These stages should have all characteristics other
than size equal, and the size input for whichever size will be classified
automatically must include the minimum in one stage and the maximum in the
other. The actual characteristics of the first stage encountered in the
inputs will be used as the template for the creation of these sizes. Note
that <code>ipm</code> refers to size classification with the primary size
variable. To automate size classification with the secondary size variable,
use <code>ipmb</code>, and to automate size classification with the tertiary size
variable, use <code>ipmc</code>. To nest automated size classifications, use 
<code>ipmab</code> for the primary and secondary size variables, <code>ipmac</code> for
the primary and tertiary size variables, <code>ipmbc</code> for the secondary and
tertiary size variables, and <code>ipmabc</code> for all three size variables.
The primary size variable can also be set with <code>ipma</code>.
</p>
<p>If two or more groups of stages, each with its own characteristics, are to
be developed for an IPM or function-based MPM, then an even number of stages
with two stages marking the minimum and maximum size of each group should be
marked with the same code as given above, with all other characteristics
equal within each group.
</p>
<p>Stage classification groups set with the <code>group</code> variable create zones
within function-based matrices in which survival transitions are estimated.
These groups should not be set if transitions are possible between all
stages regardless of group. To denote specific transitions as estimable
between stage groups, use the <code><a href="#topic+supplemental">supplemental</a>()</code> function.
</p>
<p>If importing an IPM rather than building one with <code>lefko3</code>: Using the
<code>vrm_input</code> approach to building function-based MPMs with provided
linear model slope coefficients requires careful attention to the
stageframe. Although no hfv data frame needs to be entered in this instance,
stages for which vital rates are to be estimated via linear models
parameterized with coefficients provided via function
<code><a href="#topic+vrm_import">vrm_import</a>()</code> should be marked as occurring within the dataset.
Stages for which the provided coefficients should not be used should be
marked as not occurring within the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

</code></pre>

<hr>
<h2 id='sf_distrib'>Test Overdispersion and Zero Inflation in Size and Fecundity Distributions</h2><span id='topic+sf_distrib'></span>

<h3>Description</h3>

<p>Function <code>sf_distrib</code> takes a historically formatted vertical data as
input and tests whether size and fecundity data are dispersed according to a
Poisson distribution (where mean = variance), and whether the number of 0s
exceeds expectations. This function is now deprecated in favor of function
<code><a href="#topic+hfv_qc">hfv_qc</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_distrib(
  data,
  sizea = NA,
  sizeb = NA,
  sizec = NA,
  obs3 = NA,
  fec = NA,
  repst = NA,
  zisizea = TRUE,
  zisizeb = TRUE,
  zisizec = TRUE,
  zifec = TRUE,
  fectime = 2,
  show.size = TRUE,
  show.fec = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_distrib_+3A_data">data</code></td>
<td>
<p>A historical vertical data file, which is a data frame of class
<code>hfvdata</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_sizea">sizea</code></td>
<td>
<p>A vector holding the name or column number of the variables
corresponding to primary size in occasions <em>t</em>+1 and <em>t</em>. Input 
only if <code>sizea</code> is to be tested.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_sizeb">sizeb</code></td>
<td>
<p>A vector holding the name or column number of the variables
corresponding to secondary size in occasions <em>t</em>+1 and <em>t</em>. Input 
only if <code>sizeb</code> is to be tested.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_sizec">sizec</code></td>
<td>
<p>A vector holding the name or column number of the variables
corresponding to tertiary size in occasions <em>t</em>+1 and <em>t</em>. Input 
only if <code>sizec</code> is to be tested.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_obs3">obs3</code></td>
<td>
<p>The name or column number of the variable corresponding to
observation status in occasion <em>t</em>+1. This should be used if observation
status will be used as a vital rate to absorb states of size = 0.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_fec">fec</code></td>
<td>
<p>A vector holding the names or column numbers of the variables
corresponding to in occasions <em>t</em>+1 and <em>t</em>. Input only if 
<code>fec</code> is to be tested.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_repst">repst</code></td>
<td>
<p>A vector holding the names or column numbers of the variables
corresponding to reproductive status in occasions <em>t</em>+1 and <em>t</em>.
If not provided, then fecundity will be tested without subsetting to only
reproductive individuals.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_zisizea">zisizea</code></td>
<td>
<p>A logical value indicating whether to conduct a test of zero
inflation in primary size. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_zisizeb">zisizeb</code></td>
<td>
<p>A logical value indicating whether to conduct a test of zero
inflation in secondary size. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_zisizec">zisizec</code></td>
<td>
<p>A logical value indicating whether to conduct a test of zero
inflation in tertiary size. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_zifec">zifec</code></td>
<td>
<p>A logical value indicating whether to conduct a test of zero
inflation in fecundity. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_fectime">fectime</code></td>
<td>
<p>An integer indicating whether to treat fecundity as occurring
in time <em>t</em> (<code>2</code>) or time <em>t</em>+1 (<code>3</code>). Defaults to
<code>2</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_show.size">show.size</code></td>
<td>
<p>A logical value indicating whether to show the output for
tests of size. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf_distrib_+3A_show.fec">show.fec</code></td>
<td>
<p>A logical value indicating whether to show the output for
tests of fecundity. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces text describing the degree and significance of difference
from expected dispersion, and the degree and significance of zero inflation.
The tests are chi-squared score tests based on the expectations of 
mean = variance, and 0s as abundant as predicted by the value of lambda
estimated from the dataset. See van der Broek (1995) for more details.
</p>


<h3>Notes</h3>

<p>This function subsets the data in the same way as <code><a href="#topic+modelsearch">modelsearch</a>()</code>
before testing underlying distributions, making the output much more
appropriate than a simple analysis of size and fecundity variables in
<code>data</code>.
</p>
<p>The specific test used for overdispersion is a chi-squared test of the
dispersion parameter estimated using a generalized linear model predicting
the response given size in occasion <em>t</em>, under a quasi-Poisson
distribution.
</p>
<p>The specific test used for zero-inflation is the chi-squared test presented
in van der Broek (1995).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr",
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r",
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframeln, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

sf_distrib(lathvertln, sizea = c("sizea3", "sizea2"), fec = c("feca3", "feca2"),
  repst = c("repstatus3", "repstatus2"), zifec = FALSE)

</code></pre>

<hr>
<h2 id='sf_skeleton'>Create Skeleton Stageframe</h2><span id='topic+sf_skeleton'></span>

<h3>Description</h3>

<p>Function <code>sf_skeleton()</code> creates a skeleton <code>stageframe</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_skeleton(stages, standard = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_skeleton_+3A_stages">stages</code></td>
<td>
<p>The number of stages, as an integer.</p>
</td></tr>
<tr><td><code id="sf_skeleton_+3A_standard">standard</code></td>
<td>
<p>A logical value indicating whether to create a standard
<code>stageframe</code> object (<code>TRUE</code>, the default), or a reassessed
<code>stageframe</code> object as created by function <code>mpm_create()</code>
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dat frame of class <code>stageframe</code>.
</p>

<hr>
<h2 id='slambda3'>Estimate Stochastic Population Growth Rate</h2><span id='topic+slambda3'></span>

<h3>Description</h3>

<p>Function <code>slambda3()</code> estimates the stochastic population growth rate,
<code class="reqn">a</code>, defined as the long-term arithmetic mean of the log population 
growth rate estimated per simulated occasion. This function can handle both
lefkoMat objects and lists of full A matrices as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slambda3(
  mpm,
  times = 10000L,
  historical = FALSE,
  tweights = NULL,
  force_sparse = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slambda3_+3A_mpm">mpm</code></td>
<td>
<p>A matrix projection model of class <code>lefkoMat</code>, or a list of
full matrix projection matrices.</p>
</td></tr>
<tr><td><code id="slambda3_+3A_times">times</code></td>
<td>
<p>Number of occasions to iterate. Defaults to <code>10000</code>.</p>
</td></tr>
<tr><td><code id="slambda3_+3A_historical">historical</code></td>
<td>
<p>An optional logical value only used if object <code>mpm</code>
is a list of matrices, rather than a <code>lefkoMat</code> object. Defaults to
<code>FALSE</code> for the former case, and overridden by information supplied in
the <code>lefkoMat</code> object for the latter case.</p>
</td></tr>
<tr><td><code id="slambda3_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a
matrix is input, then a first-order Markovian environment is assumed, in
which the probability of choosing a specific annual matrix depends on which
annual matrix is currently chosen. If a vector is input, then the choice of
annual matrix is assumed to be independent of the current matrix. Defaults
to equal weighting among matrices.</p>
</td></tr>
<tr><td><code id="slambda3_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to force sparse matrix 
encoding (<code>"yes"</code>) or not (<code>"no"</code>) if the MPM is composed of
simple matrices. Defaults to <code>"auto"</code>, in which case sparse matrix
encoding is used with simple square matrices with at least 50 rows and no
more than 50% of elements with values greater than zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following variables:
</p>
<table>
<tr><td><code>pop</code></td>
<td>
<p>The identity of the population.</p>
</td></tr>
<tr><td><code>patch</code></td>
<td>
<p>The identity of the patch.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Estimate of stochastic growth rate, estimated as the arithmetic
mean of the log population growth rate across simulated occasions.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The estimated variance of a.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation of a.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The standard error of a.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>The log stochastic population growth rate, <code class="reqn">a</code>, is as given in equation
2 of Tuljapurkar, Horvitz, and Pascarella 2003. This term is estimated via
projection of randomly sampled matrices, similarly to the procedure outlined
in Box 7.4 of Morris and Doak (2002).
</p>
<p>Stochastic growth rate is estimated both at the patch level and at the
population level. Population level estimates will be noted at the end of the
data frame with 0 entries for patch designation.
</p>
<p>Weightings given in <code>tweights</code> do not need to sum to 1. Final
weightings used will be based on the proportion per element of the sum of
elements in the user-supplied vector.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"), 
  supplement = cypsupp3r, yearcol = "year2", 
  patchcol = "patchid", indivcol = "individ")

cypstoch &lt;- slambda3(cypmatrix3r)

</code></pre>

<hr>
<h2 id='stablestage3'>Estimate Stable Stage Distribution</h2><span id='topic+stablestage3'></span>

<h3>Description</h3>

<p><code>stablestage3()</code> is a generic function that returns the stable stage 
distribution for a population projection matrix or set of matrices. This
function is made to handle very large and sparse matrices supplied as 
<code>lefkoMat</code> objects or as individual matrices, and can be used with large
historical matrices, IPMs, age x stage matrices, as well as ahistorical
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stablestage3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stablestage3_+3A_mats">mats</code></td>
<td>
<p>A lefkoMat object, a population projection matrix, or a list of
population projection matrices for which the stable stage distribution is
desired.</p>
</td></tr>
<tr><td><code id="stablestage3_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on the class of the <code>mats</code> argument.
See related functions for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stablestage3.lefkoMat">stablestage3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.list">stablestage3.list</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.matrix">stablestage3.matrix</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.dgCMatrix">stablestage3.dgCMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus deterministic example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
stablestage3(ehrlen3mean)

# Cypripedium stochastic example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

stablestage3(cypmatrix2r, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='stablestage3.dgCMatrix'>Estimate Stable Stage Distribution of a Single Population Projection Matrix</h2><span id='topic+stablestage3.dgCMatrix'></span>

<h3>Description</h3>

<p><code>stablestage3.dgCMatrix()</code> returns the stable stage distribution for a 
sparse population projection matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
stablestage3(mats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stablestage3.dgCMatrix_+3A_mats">mats</code></td>
<td>
<p>A population projection matrix of class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the stable stage distribution corresponding to
the input matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stablestage3">stablestage3</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.lefkoMat">stablestage3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.list">stablestage3.list</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.matrix">stablestage3.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ", sparse_output = TRUE)

stablestage3(ehrlen3$A[[1]])

</code></pre>

<hr>
<h2 id='stablestage3.lefkoMat'>Estimate Stable Stage Distribution of Matrices in lefkoMat Object</h2><span id='topic+stablestage3.lefkoMat'></span>

<h3>Description</h3>

<p><code>stablestage3.lefkoMat()</code> returns the deterministic stable stage
distributions of all <code>A</code> matrices in an object of class <code>lefkoMat</code>,
as well as the long-run projected mean stage distribution in stochastic
analysis. This function can handle large and sparse matrices, and so can be
used with large historical matrices, IPMs, age x stage matrices, as well as
ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
stablestage3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  force_sparse = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stablestage3.lefkoMat_+3A_mats">mats</code></td>
<td>
<p>An object of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value indicating whether to use deterministic
(<code>FALSE</code>) or stochastic (<code>TRUE</code>) analysis. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_times">times</code></td>
<td>
<p>An integer variable indicating number of occasions to project if
using stochastic analysis. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) if standard matrices are provided. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="stablestage3.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the stable stage distributions (and long-run
mean stage distributions in stochastic analysis) corresponding to the
matrices in a <code>lefkoMat</code> object.
</p>
<p>The output depends on whether the <code>lefkoMat</code> object used as input is
ahistorical or historical, and whether the analysis is deterministic or
stochastic. If deterministic and ahistorical, then a single data frame is
output, which includes the number of the matrix within the <code>A</code> element
of the input <code>lefkoMat</code> object, followed by the stage id (numeric and
assigned through <code><a href="#topic+sf_create">sf_create</a>()</code>), the stage name, and the
estimated proportion of the stable stage distribution (<code>ss_prop</code>). If
stochastic and ahistorical, then a single data frame is output starting with
the number of the population-patch (<code>matrix_set</code>), a string
concatenating the names of the population and the patch (<code>poppatch</code>),
the assigned stage id number (<code>stage_id</code>), and the stage name
(<code>stage</code>), and the long-run average stage distribution (<code>ss_prop</code>).
</p>
<p>If a historical matrix is used as input, then two data frames are output
into a list object. The <code>hist</code> element describes the historical
stage-pair distribution, while the <code>ahist</code> element describes the stage
distribution. If deterministic, then <code>hist</code> contains a data frame
including the matrix number (<code>matrix</code>), the numeric stage designations for
stages in occasions <em>t</em> and <em>t</em>-1, (<code>stage_id_2</code> and
<code>stage_id_1</code>, respectively), followed by the respective stage names (
<code>stage_2</code> and <code>stage_1</code>), and ending with the estimated stable
stage-pair distribution. The associated <code>ahist</code> element is as before. If
stochastic, then the <code>hist</code> element contains a single data frame with
the number of the population-patch (<code>matrix_set</code>), a string
concatenating the names of the population and the patch (<code>poppatch</code>),
the assigned stage id numbers in times <em>t</em> and <em>t</em>-1 (
<code>stage_id_2</code> and <code>stage_id_2</code>, respectively), and the associated
stage names (<code>stage_2</code> and <code>stage_1</code>, respectively), and the
long-run average stage distribution (<code>ss_prop</code>). The associated
<code>ahist</code> element is as before in the ahistorical, stochastic case.
</p>
<p>In addition to the data frames noted above, stochastic analysis will result
in the additional output of a list of matrices containing the actual
projected stage distributions across all projected occasions, in the order of
population-patch combinations in the <code>lefkoMat</code> input.
</p>


<h3>Notes</h3>

<p>In stochastic analysis, the projected mean distribution is the arithmetic
mean across the final 1000 projected occasions if the simulation is at least
2000 projected occasions long. If between 500 and 2000 projected occasions
long, then only the final 200 are used, and if fewer than 500 occasions are
used, then all are used. Note that because stage distributions in stochastic
simulations can change greatly in the initial portion of the run, we
encourage a minimum of 2000 projected occasions per simulation, with 10000
preferred.
</p>
<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stablestage3">stablestage3</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.list">stablestage3.list</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.matrix">stablestage3.matrix</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.dgCMatrix">stablestage3.dgCMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus deterministic example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
stablestage3(ehrlen3mean)

# Cypripedium stochastic example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

stablestage3(cypmatrix2r, stochastic = TRUE)

</code></pre>

<hr>
<h2 id='stablestage3.list'>Estimate Stable Stage Distribution of a List of Projection Matrices</h2><span id='topic+stablestage3.list'></span>

<h3>Description</h3>

<p><code>stablestage3.list()</code> returns the stable stage distributions for stages
in population projection matrices arranged in a general list. The function
makes no assumptions about whether the matrix is ahistorical and simply
provides stable stage distribution values corresponding to each row, meaning
that the overall stable stage distribution of basic life history stages in a
historical matrix are not provided (the <code><a href="#topic+stablestage3.lefkoMat">stablestage3.lefkoMat</a>()</code>
historical estimates these on the basis of stage description information
provided in the <code>lefkoMat</code> object used as input in that function). This
provided in the handle large and sparse matrices, and so can be used with
large historical matrices, IPMs, age x stage matrices, as well as smaller
ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
stablestage3(
  mats,
  stochastic = FALSE,
  times = 10000,
  tweights = NA,
  seed = NA,
  force_sparse = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stablestage3.list_+3A_mats">mats</code></td>
<td>
<p>A list of population projection matrices, all in either class
<code>matrix</code> or class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_stochastic">stochastic</code></td>
<td>
<p>A logical value indicating whether to use deterministic
(<code>FALSE</code>) or stochastic (<code>TRUE</code>) analysis. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_times">times</code></td>
<td>
<p>An integer variable indicating number of occasions to project if
using stochastic analysis. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_tweights">tweights</code></td>
<td>
<p>An optional numeric vector or matrix denoting the
probabilities of choosing each matrix in a stochastic projection. If a matrix
is input, then a first-order Markovian environment is assumed, in which the
probability of choosing a specific annual matrix depends on which annual
matrix is currently chosen. If a vector is input, then the choice of annual
matrix is assumed to be independent of the current matrix. Defaults to equal
weighting among matrices.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_seed">seed</code></td>
<td>
<p>A number to use as a random number seed in stochastic projection.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) when supplied with standard matrices. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="stablestage3.list_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of vector data frames characterizing the 
stable stage distributions for stages of each population projection matrix.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stablestage3">stablestage3</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.lefkoMat">stablestage3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.matrix">stablestage3.matrix</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.dgCMatrix">stablestage3.dgCMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
stablestage3(ehrlen3mean$A)

</code></pre>

<hr>
<h2 id='stablestage3.matrix'>Estimate Stable Stage Distribution of a Single Population Projection Matrix</h2><span id='topic+stablestage3.matrix'></span>

<h3>Description</h3>

<p><code>stablestage3.matrix()</code> returns the stable stage distribution for a 
population projection matrix. This function can handle large and sparse
matrices, and so can be used with large historical matrices, IPMs, 
age x stage matrices, as well as smaller ahistorical matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
stablestage3(mats, force_sparse = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stablestage3.matrix_+3A_mats">mats</code></td>
<td>
<p>A population projection matrix of class <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="stablestage3.matrix_+3A_force_sparse">force_sparse</code></td>
<td>
<p>A text string indicating whether to use sparse matrix
encoding (<code>"yes"</code>) when supplied with standard matrices. Defaults to
<code>"auto"</code>, in which case sparse matrix encoding is used with square
matrices with at least 50 rows and no more than 50% of elements with values
greater than zero.</p>
</td></tr>
<tr><td><code id="stablestage3.matrix_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the stable stage distribution corresponding to
the input matrix.
</p>


<h3>Notes</h3>

<p>Speed can sometimes be increased by shifting from automatic sparse matrix
determination to forced dense or sparse matrix projection. This will most
likely occur when matrices have between 30 and 300 rows and columns.
Defaults work best when matrices are very small and dense, or very large and
sparse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stablestage3">stablestage3</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.lefkoMat">stablestage3.lefkoMat</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.list">stablestage3.list</a>()</code>
</p>
<p><code><a href="#topic+stablestage3.dgCMatrix">stablestage3.dgCMatrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)
stablestage3(ehrlen3mean$A[[1]])

</code></pre>

<hr>
<h2 id='start_input'>Create a Starting Vector for Population Projection</h2><span id='topic+start_input'></span>

<h3>Description</h3>

<p>Function <code>start_input()</code> creates a data frame summarizing the non-zero
elements of the start vector for use in population projection analysis via
function <code><a href="#topic+projection3">projection3</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_input(mpm, stage2 = NA, stage1 = NA, age2 = NA, value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_input_+3A_mpm">mpm</code></td>
<td>
<p>The lefkoMat object to be used in projection analysis.</p>
</td></tr>
<tr><td><code id="start_input_+3A_stage2">stage2</code></td>
<td>
<p>A vector showing the name or number of a stage in occasion
<em>t</em> that should be set to a positive number of individuals in the start
vector. Abbreviations for groups of stages are also usable (see Notes).
This input is required for all stage-based and age-by-stage MPMs. Defaults to
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="start_input_+3A_stage1">stage1</code></td>
<td>
<p>A vector showing the name or number of a stage in occasion
<em>t</em>-1 that should be set to a positive number of individuals in the
start vector. Abbreviations for groups of stages are also usable (see Notes).
This is only used for historical MPMs, since the rows of hMPMs correspond to
stage-pairs in times <em>t</em> and <em>t</em>-1 together. Only required for
historical MPMs, and will result in errors if otherwise used.</p>
</td></tr>
<tr><td><code id="start_input_+3A_age2">age2</code></td>
<td>
<p>A vector showing the age of each respective stage in occasion
<em>t</em> that should be set to a positive number of individuals in the start
vector. Only used for Leslie and age-by-stage MPMs. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="start_input_+3A_value">value</code></td>
<td>
<p>A vector showing the values, in order, of the number of
individuals set for the stage or stage-pair in question. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>lefkoStart</code>, with 4 objects, which can be used
as input in function <code><a href="#topic+projection3">projection3</a>()</code>. The last three include the
<code>ahstages</code>, <code>hstages</code>, and <code>agestages</code> objects from the
<code>lefkoMat</code> object supplied in <code>mpm</code>. The first element in the list
is a data frame with the following variables:
</p>
<table>
<tr><td><code>stage2</code></td>
<td>
<p>Stage at occasion <em>t</em>.</p>
</td></tr>
<tr><td><code>stage_id_2</code></td>
<td>
<p>The stage number associated with <code>stage2</code>.</p>
</td></tr>
<tr><td><code>stage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1, if historical. Otherwise NA.</p>
</td></tr>
<tr><td><code>stage_id_1</code></td>
<td>
<p>The stage number associated with <code>stage1</code>.</p>
</td></tr>
<tr><td><code>age2</code></td>
<td>
<p>The age of individuals in <code>stage2</code> and, if applicable,
<code>stage1</code>. Only used in age-by-stage MPMs.</p>
</td></tr>
<tr><td><code>row_num</code></td>
<td>
<p>A number indicating the respective starting vector element.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Number of individuals in corresponding stage or stage-pair.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Entries in <code>stage2</code>, and <code>stage1</code> can include abbreviations for
groups of stages. Use <code>rep</code> if all reproductive stages are to be used,
<code>nrep</code> if all mature but non-reproductive stages are to be used,
<code>mat</code> if all mature stages are to be used, <code>immat</code> if all immature
stages are to be used, <code>prop</code> if all propagule stages are to be used,
<code>npr</code> if all non-propagule stages are to be used, <code>obs</code> if all
observable stages are to be used, <code>nobs</code> if all unobservable stages are
to be used, and leave empty or use <code>all</code> if all stages in stageframe are
to be used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density_input">density_input</a>()</code>
</p>
<p><code><a href="#topic+projection3">projection3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen3mean &lt;- lmean(ehrlen3)

e3m_sv &lt;- start_input(ehrlen3mean, stage2 = "Sd", stage1 = "Sd", value = 1000)

lathproj &lt;- projection3(ehrlen3, nreps = 5, times = 100, stochastic = TRUE,
  start_frame = e3m_sv)

</code></pre>

<hr>
<h2 id='subset_lM'>Create New lefkoMat Object as Subset of Another lefkoMat Object</h2><span id='topic+subset_lM'></span>

<h3>Description</h3>

<p>Function <code>subset_lM()</code> creates a new <code>lefkoMat</code> object from a
subset of matrices in another <code>lefkoMat</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_lM(lM, mat_num = NA, pop = NA, patch = NA, year = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_lM_+3A_lm">lM</code></td>
<td>
<p>The <code>lefkoMat</code> object to select matrices from.</p>
</td></tr>
<tr><td><code id="subset_lM_+3A_mat_num">mat_num</code></td>
<td>
<p>Either a single integer corresponding to the matrix to select
within the <code>labels</code> element of <code>lM</code>, or a vector of such integers.</p>
</td></tr>
<tr><td><code id="subset_lM_+3A_pop">pop</code></td>
<td>
<p>The population designation for matrices to select. Only used if
<code>mat_num</code> is not given.</p>
</td></tr>
<tr><td><code id="subset_lM_+3A_patch">patch</code></td>
<td>
<p>The patch designation for matrices to select. Only used if
<code>mat_num</code> is not given.</p>
</td></tr>
<tr><td><code id="subset_lM_+3A_year">year</code></td>
<td>
<p>The time <em>t</em> designation for matrices to select. Only used
if <code>mat_num</code> is not given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lefkoMat</code> object composed of the matrices specified in the
options.
</p>


<h3>Notes</h3>

<p>If <code>mat_num</code> is not provided, then at least one of <code>pop</code>,
<code>patch</code>, or <code>year</code> must be provided. If at least two of <code>pop</code>,
<code>patch</code>, and <code>year</code> are provided, then function <code>subset_lM()</code>
will identify matrices as the intersection of provided inputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_lM">create_lM</a>()</code>
</p>
<p><code><a href="#topic+add_lM">add_lM</a>()</code>
</p>
<p><code><a href="#topic+delete_lM">delete_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These matrices are of 9 populations of the plant species Anthyllis
# vulneraria, and were originally published in Davison et al. (2010) Journal
# of Ecology 98:255-267 (doi: 10.1111/j.1365-2745.2009.01611.x).

sizevector &lt;- c(1, 1, 2, 3) # These sizes are not from the original paper
stagevector &lt;- c("Sdl", "Veg", "SmFlo", "LFlo")
repvector &lt;- c(0, 0, 1, 1)
obsvector &lt;- c(1, 1, 1, 1)
matvector &lt;- c(0, 1, 1, 1)
immvector &lt;- c(1, 0, 0, 0)
propvector &lt;- c(0, 0, 0, 0)
indataset &lt;- c(1, 1, 1, 1)
binvec &lt;- c(0.5, 0.5, 0.5, 0.5)

anthframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

# POPN C 2003-2004
XC3 &lt;- matrix(c(0, 0, 1.74, 1.74,
0.208333333, 0, 0, 0.057142857,
0.041666667, 0.076923077, 0, 0,
0.083333333, 0.076923077, 0.066666667, 0.028571429), 4, 4, byrow = TRUE)

# 2004-2005
XC4 &lt;- matrix(c(0, 0, 0.3, 0.6,
0.32183908, 0.142857143, 0, 0,
0.16091954, 0.285714286, 0, 0,
0.252873563, 0.285714286, 0.5, 0.6), 4, 4, byrow = TRUE)

# 2005-2006
XC5 &lt;- matrix(c(0, 0, 0.50625, 0.675,
0, 0, 0, 0.035714286,
0.1, 0.068965517, 0.0625, 0.107142857,
0.3, 0.137931034, 0, 0.071428571), 4, 4, byrow = TRUE)

# POPN E 2003-2004
XE3 &lt;- matrix(c(0, 0, 2.44, 6.569230769,
0.196428571, 0, 0, 0,
0.125, 0.5, 0, 0,
0.160714286, 0.5, 0.133333333, 0.076923077), 4, 4, byrow = TRUE)

XE4 &lt;- matrix(c(0, 0, 0.45, 0.646153846,
0.06557377, 0.090909091, 0.125, 0,
0.032786885, 0, 0.125, 0.076923077,
0.049180328, 0, 0.125, 0.230769231), 4, 4, byrow = TRUE)

XE5 &lt;- matrix(c(0, 0, 2.85, 3.99,
0.083333333, 0, 0, 0,
0, 0, 0, 0,
0.416666667, 0.1, 0, 0.1), 4, 4, byrow = TRUE)

# POPN F 2003-2004
XF3 &lt;- matrix(c(0, 0, 1.815, 7.058333333,
0.075949367, 0, 0.05, 0.083333333,
0.139240506, 0, 0, 0.25,
0.075949367, 0, 0, 0.083333333), 4, 4, byrow = TRUE)

XF4 &lt;- matrix(c(0, 0, 1.233333333, 7.4,
0.223880597, 0, 0.111111111, 0.142857143,
0.134328358, 0.272727273, 0.166666667, 0.142857143,
0.119402985, 0.363636364, 0.055555556, 0.142857143), 4, 4, byrow = TRUE)

XF5 &lt;- matrix(c(0, 0, 1.06, 3.372727273,
0.073170732, 0.025, 0.033333333, 0,
0.036585366, 0.15, 0.1, 0.136363636,
0.06097561, 0.225, 0.166666667, 0.272727273), 4, 4, byrow = TRUE)

# POPN G 2003-2004
XG3 &lt;- matrix(c(0, 0, 0.245454545, 2.1,
0, 0, 0.045454545, 0,
0.125, 0, 0.090909091, 0,
0.125, 0, 0.090909091, 0.333333333), 4, 4, byrow = TRUE)

XG4 &lt;- matrix(c(0, 0, 1.1, 1.54,
0.111111111, 0, 0, 0,
0, 0, 0, 0,
0.111111111, 0, 0, 0), 4, 4, byrow = TRUE)

XG5 &lt;- matrix(c(0, 0, 0, 1.5,
0, 0, 0, 0,
0.090909091, 0, 0, 0,
0.545454545, 0.5, 0, 0.5), 4, 4, byrow = TRUE)

# POPN L 2003-2004
XL3 &lt;- matrix(c(0, 0, 1.785365854, 1.856521739,
0.128571429, 0, 0, 0.010869565,
0.028571429, 0, 0, 0,
0.014285714, 0, 0, 0.02173913), 4, 4, byrow = TRUE)

XL4 &lt;- matrix(c(0, 0, 14.25, 16.625,
0.131443299, 0.057142857, 0, 0.25,
0.144329897, 0, 0, 0,
0.092783505, 0.2, 0, 0.25), 4, 4, byrow = TRUE)

XL5 &lt;- matrix(c(0, 0, 0.594642857, 1.765909091,
0, 0, 0.017857143, 0,
0.021052632, 0.018518519, 0.035714286, 0.045454545,
0.021052632, 0.018518519, 0.035714286, 0.068181818), 4, 4, byrow = TRUE)

# POPN O 2003-2004
XO3 &lt;- matrix(c(0, 0, 11.5, 2.775862069,
0.6, 0.285714286, 0.333333333, 0.24137931,
0.04, 0.142857143, 0, 0,
0.16, 0.285714286, 0, 0.172413793), 4, 4, byrow = TRUE)

XO4 &lt;- matrix(c(0, 0, 3.78, 1.225,
0.28358209, 0.171052632, 0, 0.166666667,
0.084577114, 0.026315789, 0, 0.055555556,
0.139303483, 0.447368421, 0, 0.305555556), 4, 4, byrow = TRUE)

XO5 &lt;- matrix(c(0, 0, 1.542857143, 1.035616438,
0.126984127, 0.105263158, 0.047619048, 0.054794521,
0.095238095, 0.157894737, 0.19047619, 0.082191781,
0.111111111, 0.223684211, 0, 0.356164384), 4, 4, byrow = TRUE)

# POPN Q 2003-2004
XQ3 &lt;- matrix(c(0, 0, 0.15, 0.175,
0, 0, 0, 0,
0, 0, 0, 0,
1, 0, 0, 0), 4, 4, byrow = TRUE)

XQ4 &lt;- matrix(c(0, 0, 0, 0.25,
0, 0, 0, 0,
0, 0, 0, 0,
1, 0.666666667, 0, 1), 4, 4, byrow = TRUE)

XQ5 &lt;- matrix(c(0, 0, 0, 1.428571429,
0, 0, 0, 0.142857143,
0.25, 0, 0, 0,
0.25, 0, 0, 0.571428571), 4, 4, byrow = TRUE)

# POPN R 2003-2004
XR3 &lt;- matrix(c(0, 0, 0.7, 0.6125,
0.25, 0, 0, 0.125,
0, 0, 0, 0,
0.25, 0.166666667, 0, 0.25), 4, 4, byrow = TRUE)

XR4 &lt;- matrix(c(0, 0, 0, 0.6,
0.285714286, 0, 0, 0,
0.285714286, 0.333333333, 0, 0,
0.285714286, 0.333333333, 0, 1), 4, 4, byrow = TRUE)

XR5 &lt;- matrix(c(0, 0, 0.7, 0.6125,
0, 0, 0, 0,
0, 0, 0, 0,
0.333333333, 0, 0.333333333, 0.625), 4, 4, byrow = TRUE)

# POPN S 2003-2004
XS3 &lt;- matrix(c(0, 0, 2.1, 0.816666667,
0.166666667, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0.166666667), 4, 4, byrow = TRUE)

XS4 &lt;- matrix(c(0, 0, 0, 7,
0.333333333, 0.5, 0, 0,
0, 0, 0, 0,
0.333333333, 0, 0, 1), 4, 4, byrow = TRUE)

XS5 &lt;- matrix(c(0, 0, 0, 1.4,
0, 0, 0, 0,
0, 0, 0, 0.2,
0.111111111, 0.75, 0, 0.2), 4, 4, byrow = TRUE)

mats_list &lt;- list(XC3, XC4, XC5, XE3, XE4, XE5, XF3, XF4, XF5, XG3, XG4, XG5,
  XL3, XL4, XL5, XO3, XO4, XO5, XQ3, XQ4, XQ5, XR3, XR4, XR5, XS3, XS4, XS5)

yr_ord &lt;- c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1,
  2, 3, 1, 2, 3)

pch_ord &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7,
  8, 8, 8, 9, 9, 9)

anth_lefkoMat &lt;- create_lM(mats_list, anthframe, hstages = NA, historical = FALSE,
  poporder = 1, patchorder = pch_ord, yearorder = yr_ord)
  
smaller_anth_lM &lt;- subset_lM(anth_lefkoMat, patch = c(1, 2, 3), 
  year = c(1, 2))

</code></pre>

<hr>
<h2 id='summary_hfv'>Summary of Class &quot;hfvdata&quot;</h2><span id='topic+summary_hfv'></span>

<h3>Description</h3>

<p>A function to simplify the viewing of basic information describing
demographic data in historical vertical format (data frames of class
<code>hfvdata</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_hfv(
  object,
  popid = "popid",
  patchid = "patchid",
  individ = "individ",
  year2id = "year2",
  full = TRUE,
  err_check = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_hfv_+3A_object">object</code></td>
<td>
<p>An object of class <code>hfvdata</code>.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_popid">popid</code></td>
<td>
<p>A string denoting the name of the variable denoting population
identity.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_patchid">patchid</code></td>
<td>
<p>A string denoting the name of the variable denoting patch
identity.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_individ">individ</code></td>
<td>
<p>A string denoting the name of the variable denoting individual
identity.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_year2id">year2id</code></td>
<td>
<p>A string denoting the name of the variable denoting the year
in time <em>t</em>.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_full">full</code></td>
<td>
<p>A logical value indicating whether to include basic data frame
summary information in addition to hfvdata-specific summary information.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_err_check">err_check</code></td>
<td>
<p>A logical value indicating whether to check for errors in
stage assignment.</p>
</td></tr>
<tr><td><code id="summary_hfv_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the object. The first line shows the numbers of
populations, patches, individuals, and time steps. If <code>full = TRUE</code>, 
then this is followed by a standard data frame summary of the hfv dataset.
If <code>err_check = TRUE</code>, then a subset of the original data frame input
as <code>object</code> is exported with only rows showing stage assignment issues.
</p>


<h3>Notes</h3>

<p>Stage assignment issue identified by option <code>err_check</code> fall under two
categories. First, all rows showing <code>NoMatch</code> as the identified stage
for <code>stage1</code>, <code>stage2</code>, or <code>stage3</code> are identified. Second,
all rows showing <code>stage1 = "NotAlive"</code> and <code>alive1 = 1</code>,
<code>stage2 = "NotAlive"</code> and <code>alive2 = 1</code>, or
<code>stage3 = "NotAlive"</code> and <code>alive3 = 1</code> are identified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

summary_hfv(cypraw_v1)

</code></pre>

<hr>
<h2 id='summary.lefkoCondMat'>Summary of Class &quot;lefkoCondMat&quot;</h2><span id='topic+summary.lefkoCondMat'></span>

<h3>Description</h3>

<p>This function provides basic information summarizing the characteristics of
conditional matrices derived from a <code>lefkoCondMat</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoCondMat'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoCondMat_+3A_object">object</code></td>
<td>
<p>An object of class <code>lefkoCondMat</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoCondMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text summary of the object shown on the console, showing the number
of historical matrices, as well as the number of conditional matrices nested
within each historical matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

lathcondmats &lt;- cond_hmpm(ehrlen3)
summary(lathcondmats)

# Cypripedium  example
data(cypdata)
 
sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"), 
  supplement = cypsupp3r, yearcol = "year2", patchcol = "patchid",
  indivcol = "individ")

cypcondmats &lt;- cond_hmpm(cypmatrix3r)

summary(cypcondmats)

</code></pre>

<hr>
<h2 id='summary.lefkoElas'>Summarize lefkoElas Objects</h2><span id='topic+summary.lefkoElas'></span>

<h3>Description</h3>

<p>Function <code>summary.lefkoElas()</code> summarizes <code>lefkoElas</code> objects.
Particularly, it breaks down elasticity values by the kind of ahistorical
and, if applicable, historical transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoElas'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoElas_+3A_object">object</code></td>
<td>
<p>A <code>lefkoElas</code> object.</p>
</td></tr>
<tr><td><code id="summary.lefkoElas_+3A_...">...</code></td>
<td>
<p>Other parameters currently not utilized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list composed of 2 data frames. The first, <code>hist</code>, is a data
frame showing the summed elasticities for all 16 kinds of historical
transition per matrix, with each column corresponding to each elasticity
matrix in order. The second, <code>ahist</code>, is a data frame showing the
summed elasticities for all 4 kinds of ahistorical transition per matrix,
with each column corresponding to each elasticity matrix in order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "rep", "rep"),
  givenrate = c(0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, 0.345, 0.054),
  type = c(1, 1, 3, 3), stageframe = lathframe, historical = FALSE)
  
ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen2 &lt;- rlefko2(data = lathvert, stageframe = lathframe, year = "all",
  stages = c("stage3", "stage2"), supplement = lathsupp2,
  yearcol = "year2", indivcol = "individ")

ehrlen3elas &lt;- elasticity3(ehrlen3)
ehrlen2elas &lt;- elasticity3(ehrlen2)

summary(ehrlen3elas)
summary(ehrlen2elas)

</code></pre>

<hr>
<h2 id='summary.lefkoLTRE'>Summarize lefkoLTRE Objects</h2><span id='topic+summary.lefkoLTRE'></span>

<h3>Description</h3>

<p>Function <code>summary.lefkoLTRE()</code> summarizes <code>lefkoLTRE</code> objects.
Particularly, it breaks down LTRE contributions by the kind of ahistorical
and, if applicable, historical transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoLTRE'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoLTRE_+3A_object">object</code></td>
<td>
<p>A <code>lefkoLTRE</code> object.</p>
</td></tr>
<tr><td><code id="summary.lefkoLTRE_+3A_...">...</code></td>
<td>
<p>Other parameters currently not utilized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames. In all cases, the first data frame is one
showing the positive, negative, and total contributions of elements in
each LTRE contribution matrix. If not a SNA-LTRE, then there are an
additional two (if deterministic) or four (if stochastic) data frames. If
deterministic, then <code>hist_det</code> is a data frame showing the summed LTRE
contributions for all 16 kinds of historical transition per matrix, with each
column corresponding to each A matrix in order, followed by all summed
positive and all summed negative contributions. Object <code>ahist_det</code> is a
data frame showing the summed LTRE contributions for all four kinds of
ahistorical transition per matrix, with order as before, followed by summed
positive and summed negative contributions. If stochastic, then
<code>hist_mean</code> and <code>hist_sd</code> are the summed LTRE contributions for the
mean vital rates and variability in vital rates, respectively, according to
all 16 historical transition types, followed by summed positive and negative
contributions, and <code>ahist_mean</code> and <code>ahist_sd</code> are the equivalent
ahistorical versions. The output for the SNA-LTRE also includes the
logs of the deterministic lambda estimated through function <code>ltre3()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "rep", "rep"),
  givenrate = c(0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, 0.345, 0.054),
  type = c(1, 1, 3, 3), stageframe = lathframe, historical = FALSE)
  
ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

ehrlen2 &lt;- rlefko2(data = lathvert, stageframe = lathframe, year = "all",
  stages = c("stage3", "stage2"), supplement = lathsupp2,
  yearcol = "year2", indivcol = "individ")

ehrlen3ltre &lt;- ltre3(ehrlen3)
summary(ehrlen3ltre)

</code></pre>

<hr>
<h2 id='summary.lefkoMat'>Summary of Class &quot;lefkoMat&quot;</h2><span id='topic+summary.lefkoMat'></span>

<h3>Description</h3>

<p>A function to simplify the viewing of basic information describing the
matrices produced through functions <code><a href="#topic+flefko3">flefko3</a>()</code>,
<code><a href="#topic+flefko2">flefko2</a>()</code>, <code><a href="#topic+rlefko3">rlefko3</a>()</code>, <code><a href="#topic+rlefko2">rlefko2</a>()</code>,
<code><a href="#topic+aflefko2">aflefko2</a>()</code>, <code><a href="#topic+rleslie">rleslie</a>()</code>, and
<code><a href="#topic+fleslie">fleslie</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMat'
summary(object, colsums = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoMat_+3A_object">object</code></td>
<td>
<p>An object of class <code>lefkoMat</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoMat_+3A_colsums">colsums</code></td>
<td>
<p>A logical value indicating whether column sums should be shown
for U matrices, allowing users to check stage survival probabilities.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="summary.lefkoMat_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the object, showing the number of each type of matrix,
the number of annual matrices, the number of estimated (non-zero) elements
across all matrices and per matrix, the number of unique transitions in the
dataset, the number of individuals, and summaries of the column sums of the
survival-transition matrices. This function will also yield warnings if any
survival-transition matrices include elements outside of the interval [0,1],
if any fecundity matrices contain negative elements, and if any matrices
include NA values.
</p>


<h3>Notes</h3>

<p>Under the Gaussian and gamma size distributions, the number of estimated
parameters may differ between the two <code>ipm_method</code> settings. Because
the midpoint method has a tendency to incorporate upward bias in the
estimation of size transition probabilities, it is more likely to yield non-
zero values when the true probability is extremely close to 0. This will
result in the <code>summary.lefkoMat</code> function yielding higher numbers of
estimated parameters than the <code>ipm_method = "CDF"</code> yields in some cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

# Here we use supplemental() to provide overwrite and reproductive info
cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

summary(cypmatrix2r)

</code></pre>

<hr>
<h2 id='summary.lefkoMod'>Summary of Class &quot;lefkoMod&quot;</h2><span id='topic+summary.lefkoMod'></span>

<h3>Description</h3>

<p>A function to summarize objects of class <code>lefkoMod</code>. This function shows
the best-fit models, summarizes the numbers of models in the model tables,
shows the criterion used to determine the best-fit models, and provides some
basic quality control information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoMod'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoMod_+3A_object">object</code></td>
<td>
<p>An R object of class <code>lefkoMod</code> resulting from
<code><a href="#topic+modelsearch">modelsearch</a>()</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoMod_+3A_...">...</code></td>
<td>
<p>Other parameters currently not utilized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the object, showing the best-fit models for all vital
rates, with constants of 0 or 1 used for unestimated models. This is followed
by a summary of the number of models tested per vital rate, and a table
showing the names of the parameters used to model vital rates and represent
tested factors. At the end is a section describing the numbers of individuals
and of individual transitions used to estimate each vital rate best-fit
model, along with the accuracy of each binomial model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 4.6, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8,
  9)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "Sz1nr", "Sz2nr", "Sz3nr", "Sz4nr", 
  "Sz5nr", "Sz6nr", "Sz7nr", "Sz8nr", "Sz9nr", "Sz1r", "Sz2r", "Sz3r", 
  "Sz4r", "Sz5r", "Sz6r", "Sz7r", "Sz8r", "Sz9r")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 4.6, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
  0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5)

lathframeln &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvertln &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988, 
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "lnVol88", repstracol = "Intactseed88",
  fecacol = "Intactseed88", deadacol = "Dead1988", 
  nonobsacol = "Dormant1988", stageassign = lathframeln,
  stagesize = "sizea", censorcol = "Missing1988", censorkeep = NA,
  NAas0 = TRUE, censor = TRUE)

lathvertln$feca2 &lt;- round(lathvertln$feca2)
lathvertln$feca1 &lt;- round(lathvertln$feca1)
lathvertln$feca3 &lt;- round(lathvertln$feca3)

lathmodelsln2 &lt;- modelsearch(lathvertln, historical = FALSE, 
  approach = "mixed", suite = "main",
  vitalrates = c("surv", "obs", "size", "repst", "fec"), juvestimate = "Sdl",
  bestfit = "AICc&amp;k", sizedist = "gaussian", fecdist = "poisson",
  indiv = "individ", patch = "patchid", year = "year2",
  year.as.random = TRUE, patch.as.random = TRUE, show.model.tables = TRUE,
  quiet = "partial")

summary(lathmodelsln2)


</code></pre>

<hr>
<h2 id='summary.lefkoProj'>Summarize lefkoProj Objects</h2><span id='topic+summary.lefkoProj'></span>

<h3>Description</h3>

<p>Function <code>summary.lefkoProj()</code> summarizes <code>lefkoProj</code> objects.
Particularly, it breaks down the data frames provided in the 
<code>projection</code> element in ways meaningful for those running simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lefkoProj'
summary(
  object,
  threshold = 1,
  inf_alive = TRUE,
  milepost = c(0, 0.25, 0.5, 0.75, 1),
  ext_time = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lefkoProj_+3A_object">object</code></td>
<td>
<p>A <code>lefkoProj</code> object.</p>
</td></tr>
<tr><td><code id="summary.lefkoProj_+3A_threshold">threshold</code></td>
<td>
<p>A threshold population size to be searched for in
projections. Defaults to 1.</p>
</td></tr>
<tr><td><code id="summary.lefkoProj_+3A_inf_alive">inf_alive</code></td>
<td>
<p>A logical value indicating whether to treat infinitely
large population size as indicating that the population is still extant.
If <code>FALSE</code>, then the population is considered extinct. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoProj_+3A_milepost">milepost</code></td>
<td>
<p>A numeric vector indicating at which points in the projection
to assess detailed results. Can be input as integer values, in which case
each number must be between 1 and the total number of occasions projected in
each projection, or decimals between 0 and 1, which would then be translated
into the corresponding projection steps of the total. Defaults to
<code>c(0, 0.25, 0.50, 0.75, 1.00)</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoProj_+3A_ext_time">ext_time</code></td>
<td>
<p>A logical value indicating whether to output extinction times
per population-patch. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.lefkoProj_+3A_...">...</code></td>
<td>
<p>Other parameters currently not utilized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Apart from a statement of the results, this function outputs a list
with the following elements:
</p>
<table>
<tr><td><code>milepost_sums</code></td>
<td>
<p>A data frame showing the number of replicates at each
of the milepost times that is above the threshold population/patch size.</p>
</td></tr>
<tr><td><code>extinction_times</code></td>
<td>
<p>A dataframe showing the numbers of replicates going
extinct (<code>ext_reps</code>) and mean extinction time (<code>ext_time</code>) per
population-patch. If <code>ext_time = FALSE</code>, then only outputs <code>NA</code>.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>The <code>inf_alive</code> and <code>ext_time</code> options both assess whether
replicates have reached a value of <code>NaN</code> or <code>Inf</code>. If
<code>inf_alive = TRUE</code> or <code>ext_time = TRUE</code> and one of these values is
found, then the replicate is counted in the <code>milepost_sums</code> object if
the last numeric value in the replicate is above the <code>threshold</code> value,
and is counted as extant and not extinct if the last numeric value in the
replicate is above the extinction threshold of a single individual.
</p>
<p>Extinction time is calculated on the basis of whether the replicate ever
falls below a single individual. A replicate with a positive population size
below 0.0 that manages to rise above 1.0 individual is still considered to
have gone extinct the first time it crossed below 1.0.
</p>
<p>If the input <code>lefkoProj</code> object is a mixture of two or more other
<code>lefkoProj</code> objects, then mileposts will be given relative to the
maximum number of time steps noted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathrepm &lt;- matrix(0, 7, 7)
lathrepm[1, 6] &lt;- 0.345
lathrepm[2, 6] &lt;- 0.054

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl"), 
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep"),
  stage1 = c("Sd", "rep", "Sd", "rep", "all", "all"), 
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054),
  type = c(1, 1, 1, 1, 3, 3), type_t12 = c(1, 2, 1, 2, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe,
  year = c(1989, 1990), stages = c("stage3", "stage2", "stage1"),
  repmatrix = lathrepm, supplement = lathsupp3, yearcol = "year2",
  indivcol = "individ")

lathproj &lt;- projection3(ehrlen3, nreps = 5, stochastic = TRUE)
summary(lathproj)

# Cypripedium example
data(cypdata)
 
sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector, 
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4, 
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04", 
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE, 
  NRasRep = TRUE)

cypsupp3r &lt;- supplemental(stage3 = c("SD", "SD", "P1", "P1", "P2", "P3", "SL",
    "D", "XSm", "Sm", "D", "XSm", "Sm", "mat", "mat", "mat", "SD", "P1"),
  stage2 = c("SD", "SD", "SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "SL",
    "SL", "SL", "D", "XSm", "Sm", "rep", "rep"),
  stage1 = c("SD", "rep", "SD", "rep", "SD", "P1", "P2", "P3", "P3", "P3",
    "SL", "SL", "SL", "SL", "SL", "SL", "mat", "mat"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, NA, "D", "XSm", "Sm", "D", "XSm", "Sm",
    "mat", "mat", "mat", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "D", "XSm", "Sm", NA, NA),
  eststage1 = c(NA, NA, NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", "XSm", "XSm",
    "XSm", "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.1, 0.1, 0.2, 0.2, 0.2, 0.2, 0.25, NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
    NA, 0.5, 0.5),
  type = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  type_t12 = c(1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
  stageframe = cypframe_raw, historical = TRUE)

cypmatrix3r &lt;- rlefko3(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added", "size1added"), 
  supplement = cypsupp3r, yearcol = "year2", 
  patchcol = "patchid", indivcol = "individ")

cypstoch &lt;- projection3(cypmatrix3r, nreps = 5, stochastic = TRUE)
summary(cypstoch, ext_time = TRUE)

</code></pre>

<hr>
<h2 id='supplemental'>Create a Data Frame of Supplemental Data for MPM Development</h2><span id='topic+supplemental'></span>

<h3>Description</h3>

<p>Function <code>supplemental()</code> provides all necessary supplemental data for
matrix estimation, particularly bringing together data on proxy rates, data
to overwrite existing rates, identified reproductive transitions complete,
and fecundity multipliers. The function should be used to incorporate data
that affects all matrices to be created. To edit MPMs after creation, use
<code><a href="#topic+edit_lM">edit_lM</a>()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supplemental(
  historical = TRUE,
  stagebased = TRUE,
  agebased = FALSE,
  stageframe = NULL,
  stage3 = NULL,
  stage2 = NULL,
  stage1 = NULL,
  age2 = NULL,
  eststage3 = NULL,
  eststage2 = NULL,
  eststage1 = NULL,
  estage2 = NULL,
  givenrate = NULL,
  multiplier = NULL,
  type = NULL,
  type_t12 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplemental_+3A_historical">historical</code></td>
<td>
<p>A logical value indicating whether the MPMs intended will
be historical or ahistorical. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_stagebased">stagebased</code></td>
<td>
<p>A logical value indicating whether the MPM will be stage-
based or age-by-stage. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_agebased">agebased</code></td>
<td>
<p>A logical value indicating whether the MPM will be age-based
or age-by-stage. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_stageframe">stageframe</code></td>
<td>
<p>The stageframe used to produce the MPM. Required if
producing any stage-based or age-by-stage MPM. Must be omitted for purely
age-based MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_stage3">stage3</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>+1 in the transition
to be replaced. Abbreviations for groups of stages are also usable (see
<code>Notes</code>). Required in all stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_stage2">stage2</code></td>
<td>
<p>The name of the stage in occasion <em>t</em> in the transition
to be replaced. Abbreviations for groups of stages are also usable (see
<code>Notes</code>). Required in all stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_stage1">stage1</code></td>
<td>
<p>The name of the stage in occasion <em>t</em>-1 in the transition
to be replaced. Only needed if a historical matrix is to be produced.
Abbreviations for groups of stages are also usable (see <code>Notes</code>).
Required for historical stage-based MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_age2">age2</code></td>
<td>
<p>An integer vector of the ages in occasion <em>t</em> to use in
transitions to be changed or replaced. Required for all age- and
age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_eststage3">eststage3</code></td>
<td>
<p>The name of the stage to replace <code>stage3</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_eststage2">eststage2</code></td>
<td>
<p>The name of the stage to replace <code>stage2</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in stage-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_eststage1">eststage1</code></td>
<td>
<p>The name of the stage to replace <code>stage1</code> in a proxy
historical transition. Only needed if a transition will be replaced by
another estimated transition, and the matrix to be estimated is historical
and stage-based. Stage <code>NotAlive</code> is also possible for raw hMPMs as a
means of handling the prior stage for individuals entering the population in
occasion <em>t</em>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_estage2">estage2</code></td>
<td>
<p>The age at time <em>t</em> to replace <code>age2</code> in a proxy
transition. Only needed if a transition will be replaced by another
estimated transition, and only in age-based and age-by-stage MPMs.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_givenrate">givenrate</code></td>
<td>
<p>A fixed rate or probability to replace for the transition
described by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_multiplier">multiplier</code></td>
<td>
<p>A vector of numeric multipliers for fecundity or for proxy
transitions. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_type">type</code></td>
<td>
<p>A vector denoting the kind of transition between occasions
<em>t</em> and <em>t</em>+1 to be replaced. This should be entered as <code>1</code>,
<code>S</code>, or <code>s</code> for the replacement of a survival transition;
<code>2</code>, <code>F</code>, or <code>f</code> for the replacement of a fecundity
transition; or <code>3</code>, <code>R</code>, or <code>r</code> for a fecundity set value /
general multiplier. If empty or not provided, then defaults to <code>1</code> for
survival transition.</p>
</td></tr>
<tr><td><code id="supplemental_+3A_type_t12">type_t12</code></td>
<td>
<p>An optional vector denoting the kind of transition between
occasions <em>t</em>-1 and <em>t</em>. Only necessary if a historical MPM in
deVries format is desired. This should be entered as <code>1</code>, <code>S</code>, or
<code>s</code> for a survival transition; or <code>2</code>, <code>F</code>, or <code>f</code> for a
fecundity transitions. Defaults to <code>1</code> for survival transition, with
impacts only on the construction of deVries-format hMPMs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>lefkoSD</code>. This object can be used as
input in <code><a href="#topic+flefko3">flefko3</a>()</code>, <code><a href="#topic+flefko2">flefko2</a>()</code>, 
<code><a href="#topic+rlefko3">rlefko3</a>()</code>, <code><a href="#topic+rlefko2">rlefko2</a>()</code>, and 
<code><a href="#topic+aflefko2">aflefko2</a>()</code>.
</p>
<p>Variables in this object include the following:
</p>
<table>
<tr><td><code>stage3</code></td>
<td>
<p>Stage at occasion <em>t</em>+1 in the transition to be
replaced.</p>
</td></tr>
<tr><td><code>stage2</code></td>
<td>
<p>Stage at occasion <em>t</em> in the transition to be replaced.</p>
</td></tr>
<tr><td><code>stage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1 in the transition to be
replaced.</p>
</td></tr>
<tr><td><code>age2</code></td>
<td>
<p>Age at occasion <em>t</em> in the transition to be replaced.</p>
</td></tr>
<tr><td><code>eststage3</code></td>
<td>
<p>Stage at occasion <em>t</em>+1 in the transition to replace
the transition designated by <code>stage3</code>, <code>stage2</code>, and 
<code>stage1</code>.</p>
</td></tr>
<tr><td><code>eststage2</code></td>
<td>
<p>Stage at occasion <em>t</em> in the transition to replace the
transition designated by <code>stage3</code>, <code>stage2</code>, and <code>stage1</code>.</p>
</td></tr>
<tr><td><code>eststage1</code></td>
<td>
<p>Stage at occasion <em>t</em>-1 in the transition to replace
the transition designated by <code>stage3</code>, <code>stage2</code>, and 
<code>stage1</code>.</p>
</td></tr>
<tr><td><code>estage2</code></td>
<td>
<p>Age at occasion <em>t</em> in the transition to replace the
transition designated by <code>age2</code>.</p>
</td></tr>
<tr><td><code>givenrate</code></td>
<td>
<p>A constant to be used as the value of the transition.</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>A multiplier for proxy transitions or for fecundity.</p>
</td></tr>
<tr><td><code>convtype</code></td>
<td>
<p>Designates whether the transition from occasion <em>t</em> to
occasion <em>t</em>+1 is a survival transition probability (1), a fecundity
rate (2), or a fecundity multiplier (3).</p>
</td></tr>
<tr><td><code>convtype_t12</code></td>
<td>
<p>Designates whether the transition from occasion
<em>t</em>-1 to occasion <em>t</em> is a survival transition probability (1), a
fecundity rate (2).</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>Negative values are not allowed in <code>givenrate</code> and <code>multiplier</code>
input. Stage entries should not be used for purely age-based MPMs, and age
entries should not be used for purely stage-based MPMs.
</p>
<p>Fecundity multiplier data supplied via the <code>supplemental()</code> function
acts in the same way as non-zero entries supplied via a reproductive matrix,
but gets priority in all matrix creations. Thus, in cases where fecundity
multipliers are provided for the same function via the reproductive matrix
and function <code>supplemental()</code>, the latter is used.
</p>
<p>Entries in <code>stage3</code>, <code>stage2</code>, and <code>stage1</code> can include
abbreviations for groups of stages. Use <code>rep</code> if all reproductive
stages are to be used, <code>nrep</code> if all mature but non-reproductive stages
are to be used, <code>mat</code> if all mature stages are to be used, <code>immat</code>
if all immature stages are to be used, <code>prop</code> if all propagule stages
are to be used, <code>npr</code> if all non-propagule stages are to be used,
<code>obs</code> if all observable stages are to be used, <code>nobs</code> if all
unobservable stages are to be used, and leave empty or use <code>all</code> if all
stages in stageframe are to be used. Also use <code>groupX</code> to denote all
stages in group X (e.g. <code>group1</code> will use all stages in the respective
stageframe's group 1).
</p>
<p>Type 3 conversions are referred to as fecundity set values, or general
fecundity multipliers. These set the transitions to be used as fecundity
transitions. Transitions set here will be interpreted as being generally
reproductive, meaning that the from and to stages will be used to determine
the general fecundity transitions to incorporate into stage-based MPMs,
while the age portion of the input will be used to incorporate the actual
multiplier(s) specified. If only stage transitions at certain ages are
expected to be the sole contributors to fecundity, then type 2 conversions
should also be included in the supplement (Type 1 and 2 conversions can be
purely age-specific, and do not set reproductive transitions in MPM
creation). For example, if all stage 2 to stage 3 transitions above age 2
yield fecundity, then stage 2 to stage 3 can be set to
<code>multiplier = 1.0</code> with <code>convtype = 3</code>, and the same transition
for <code>age2 = c(1, 2)</code> can be set to <code>multiplier = c(0, 0)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edit_lM">edit_lM</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

lathsupp3 &lt;- supplemental(stage3 = c("Sd", "Sd", "Sdl", "Sdl", "Sd", "Sdl", "mat"),
  stage2 = c("Sd", "Sd", "Sd", "Sd", "rep", "rep", "Sdl"),
  stage1 = c("Sd", "rep", "Sd", "rep", "npr", "npr", "Sd"),
  eststage3 = c(NA, NA, NA, NA, NA, NA, "mat"),
  eststage2 = c(NA, NA, NA, NA, NA, NA, "Sdl"),
  eststage1 = c(NA, NA, NA, NA, NA, NA, "NotAlive"),
  givenrate = c(0.345, 0.345, 0.054, 0.054, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, 0.345, 0.054, NA),
  type = c(1, 1, 1, 1, 3, 3, 1), type_t12 = c(1, 2, 1, 2, 1, 1, 1),
  stageframe = lathframe, historical = TRUE)

ehrlen3 &lt;- rlefko3(data = lathvert, stageframe = lathframe, year = "all", 
  stages = c("stage3", "stage2", "stage1"), supplement = lathsupp3,
  yearcol = "year2", indivcol = "individ")

# Cypripedium example
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = "Inf.04", repstrbcol = "Inf2.04", fecacol = "Pod.04",
  stageassign = cypframe_raw, stagesize = "sizeadded", NAas0 = TRUE,
  NRasRep = TRUE)

cypsupp2r &lt;- supplemental(stage3 = c("SD", "P1", "P2", "P3", "SL", "D", 
    "XSm", "Sm", "SD", "P1"),
  stage2 = c("SD", "SD", "P1", "P2", "P3", "SL", "SL", "SL", "rep",
    "rep"),
  eststage3 = c(NA, NA, NA, NA, NA, "D", "XSm", "Sm", NA, NA),
  eststage2 = c(NA, NA, NA, NA, NA, "XSm", "XSm", "XSm", NA, NA),
  givenrate = c(0.10, 0.20, 0.20, 0.20, 0.25, NA, NA, NA, NA, NA),
  multiplier = c(NA, NA, NA, NA, NA, NA, NA, NA, 0.5, 0.5),
  type =c(1, 1, 1, 1, 1, 1, 1, 1, 3, 3),
  stageframe = cypframe_raw, historical = FALSE)

cypmatrix2r &lt;- rlefko2(data = cypraw_v1, stageframe = cypframe_raw, 
  year = "all", patch = "all", stages = c("stage3", "stage2", "stage1"),
  size = c("size3added", "size2added"), supplement = cypsupp2r,
  yearcol = "year2", patchcol = "patchid", indivcol = "individ")

</code></pre>

<hr>
<h2 id='usher3'>Two-parameter Usher function</h2><span id='topic+usher3'></span>

<h3>Description</h3>

<p>Function <code>usher3()</code> creates a vector of values produced by the two-
parameter Usher function as applied with a user-specified time lag.
The Usher function is given as 
<code class="reqn">\phi_{t+1} = \phi_t / (1 + e^{\alpha n_t + \beta})</code>. Here,
if no <code>separate_N</code> vector is provided, then <code class="reqn">n_t = \phi_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usher3(
  start_value,
  alpha,
  beta,
  time_steps = 100L,
  time_lag = 1L,
  pre0_subs = FALSE,
  pre0_value = 0,
  substoch = 0L,
  separate_N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usher3_+3A_start_value">start_value</code></td>
<td>
<p>A positive number to start the return vector in time 0.</p>
</td></tr>
<tr><td><code id="usher3_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter in the two-parameter Usher
function.</p>
</td></tr>
<tr><td><code id="usher3_+3A_beta">beta</code></td>
<td>
<p>The beta parameter in the two-parameter Usher function.</p>
</td></tr>
<tr><td><code id="usher3_+3A_time_steps">time_steps</code></td>
<td>
<p>The number of time steps to run the projection. Must be a
positive integer.</p>
</td></tr>
<tr><td><code id="usher3_+3A_time_lag">time_lag</code></td>
<td>
<p>A positive integer denoting the number of time steps back
for the value of phi in the two-parameter Usher function.</p>
</td></tr>
<tr><td><code id="usher3_+3A_pre0_subs">pre0_subs</code></td>
<td>
<p>A logical value indicating whether to use a number other
than that given in <code>start_value</code> for values of phi lagged from times
prior to time 0.</p>
</td></tr>
<tr><td><code id="usher3_+3A_pre0_value">pre0_value</code></td>
<td>
<p>A positive number to use for phi lagged from times prior
to time 0. Only used if <code>pre0_subs = TRUE</code>.</p>
</td></tr>
<tr><td><code id="usher3_+3A_substoch">substoch</code></td>
<td>
<p>An integer value indicating the kind of substochasticity to
use. Values include: <code>0</code>, no substochasticity enforced (the default);
<code>1</code>, all numbers must be non-negative; and <code>2</code>, all numbers should
be forced to the interval [0, 1].</p>
</td></tr>
<tr><td><code id="usher3_+3A_separate_n">separate_N</code></td>
<td>
<p>An optional numeric vector with values of N in each time,
if phi is to be treated as different from N in the two-parameter model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of values showing values projected under the two-
parameter Usher function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trial_run1 &lt;- usher3(1, alpha = -0.5, beta = 0.005)
plot(trial_run1)

trial_run2 &lt;- usher3(1, alpha = 0.5, beta = 0.005)
plot(trial_run2)

trial_run3 &lt;- usher3(1, alpha = -5, beta = 0.005)
plot(trial_run3)

trial_run4 &lt;- usher3(1, alpha = 5, beta = 0.005)
plot(trial_run4)

trial_run5 &lt;- usher3(1, alpha = -25, beta = 0.005)
plot(trial_run5)

trial_run6 &lt;- usher3(1, alpha = 25, beta = 0.005)
plot(trial_run6)

used_Ns &lt;- c(10, 15, 12, 14, 14, 150, 15, 1, 5, 7, 9, 14, 13, 16, 17, 19,
  25, 26)
trial_run7 &lt;- usher3(1, alpha = -0.5, beta = 0.005, separate_N = used_Ns)
plot(trial_run7)

</code></pre>

<hr>
<h2 id='verticalize3'>Create Historical Vertical Data Frame from Horizontal Data Frame</h2><span id='topic+verticalize3'></span>

<h3>Description</h3>

<p>Function <code>verticalize3()</code> returns a vertically formatted demographic
data frame organized to create historical projection matrices, given a
horizontally formatted input data frame. It also handles stage assignments
if given an appropriate stageframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verticalize3(
  data,
  noyears,
  firstyear = 1,
  popidcol = 0,
  patchidcol = 0,
  individcol = 0,
  blocksize = NA,
  xcol = 0,
  ycol = 0,
  juvcol = 0,
  sizeacol,
  sizebcol = 0,
  sizeccol = 0,
  repstracol = 0,
  repstrbcol = 0,
  fecacol = 0,
  fecbcol = 0,
  indcovacol = 0,
  indcovbcol = 0,
  indcovccol = 0,
  aliveacol = 0,
  deadacol = 0,
  obsacol = 0,
  nonobsacol = 0,
  censorcol = 0,
  repstrrel = 1,
  fecrel = 1,
  stagecol = 0,
  stageassign = NA,
  stagesize = NA,
  censorkeep = 0,
  censorRepeat = FALSE,
  censor = FALSE,
  coordsRepeat = FALSE,
  spacing = NA,
  NAas0 = FALSE,
  NRasRep = FALSE,
  NOasObs = FALSE,
  prebreeding = TRUE,
  age_offset = 0,
  reduce = TRUE,
  a2check = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verticalize3_+3A_data">data</code></td>
<td>
<p>The horizontal data file. A valid data frame is required as
input.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_noyears">noyears</code></td>
<td>
<p>The number of years or observation occasions in the dataset. A
valid integer is required as input.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_firstyear">firstyear</code></td>
<td>
<p>The first year or occasion of observation. Defaults to
<code>1</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_popidcol">popidcol</code></td>
<td>
<p>A variable name or column number corresponding to the 
identity of the population for each individual.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_patchidcol">patchidcol</code></td>
<td>
<p>A variable name or column number corresponding to the 
identity of the patch or subpopulation for each individual, if patches have
been designated within populations.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_individcol">individcol</code></td>
<td>
<p>A variable name or column number corresponding to the 
identity of each individual.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_blocksize">blocksize</code></td>
<td>
<p>The number of variables corresponding to each occasion in
the input dataset designated in <code>data</code>, if a set pattern of variables is
used for each observation occasion in the data frame used as input. If such a
pattern is not used, and all variable names are properly noted as character
vectors in the other input variables, then this may be set to <code>NA</code>.
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_xcol">xcol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to the X 
coordinate of each individual, or of each individual at each occasion, in
Cartesian space. Can refer to the only instance, the first instance, or all
instances of X variables. In the last case, the values should be entered as a
vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_ycol">ycol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to the Y
coordinate of each individual, or of each individual at each occasion, in
Cartesian space. Can refer to the only instance, the first instance, or all
instances of Y variables. In the last case, the values should be entered as a
vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_juvcol">juvcol</code></td>
<td>
<p>A variable name(s) or column number(s) that marks individuals
in immature stages within the dataset. This function assumes that immature
individuals are identified in this variable marked with a number equal to or
greater than <code>1</code>, and that mature individuals are marked as <code>0</code> or
<code>NA</code>. Can refer to the first instance, or all instances of these
variables. In the latter case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_sizeacol">sizeacol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to the
size entry associated with the first year or observation occasion in the
dataset. Can refer to the first instance, or all instances of these
variables. In the latter case, the values should be entered as a vector.
This variable should refer to the first size variable in the stageframe,
unless <code>stagesize = "sizeadded"</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_sizebcol">sizebcol</code></td>
<td>
<p>A second variable name(s) or column number(s) corresponding
to the size entry associated with the first year or observation occasion in
the dataset. Can refer to the first instance, or all instances of these
variables. In the latter case, the values should be entered as a vector.
This variable should refer to the second size variable in the stageframe,
unless <code>stagesize = "sizeadded"</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_sizeccol">sizeccol</code></td>
<td>
<p>A third variable name(s) or column number(s) corresponding to
the size entry associated with the first year or observation occasion in the
dataset. Can refer to the first instance, or all instances of these variables.
In the latter case, the values should be entered as a vector. This variable
should refer to the third size variable in the stageframe, unless
<code>stagesize = "sizeadded"</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_repstracol">repstracol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to the
production of reproductive structures, such as flowers, associated with the 
first year or observation period in the input dataset. This can be binomial 
or count data, and is used to analyze the probability of reproduction. Can
refer to the first instance, or all instances of these variables. In the
latter case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_repstrbcol">repstrbcol</code></td>
<td>
<p>A second variable name(s) or column number(s) corresponding
to the production of reproductive structures, such as flowers, associated
with the first year or observation period in the input dataset. This can be 
binomial or count data, and is used to analyze the probability of
reproduction. Can refer to the first instance, or all instances of these
variables. In the latter case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_fecacol">fecacol</code></td>
<td>
<p>A variable name(s) or column number(s) denoting fecundity
associated with the first year or observation occasion in the input dataset.
This may represent egg counts, fruit counts, seed production, etc. Can refer
to the first instance, or all instances of these variables. In the latter
case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_fecbcol">fecbcol</code></td>
<td>
<p>A second variable name(s) or column number(s) denoting
fecundity associated with the first year or observation occasion in the input
dataset. This may represent egg counts, fruit counts, seed production, etc.
Can refer to the first instance, or all instances of these variables. In the
latter case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_indcovacol">indcovacol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to an
individual covariate to be used in analysis. Can refer to the only instance,
the first instance, or all instances of these variables. In the last case,
the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_indcovbcol">indcovbcol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to an
individual covariate to be used in analysis. Can refer to the only instance,
the first instance, or all instances of these variables. In the last case,
the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_indcovccol">indcovccol</code></td>
<td>
<p>A second variable name(s) or column number(s) corresponding
to an individual covariate to be used in analysis. Can refer to the only
instance, the first instance, or all instances of these variables. In the
last case, the values should be entered as a vector.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_aliveacol">aliveacol</code></td>
<td>
<p>Variable name(s) or column number(s) providing information
on whether an individual is alive at a given occasion. If used, living status
must be designated as binomial (living = <code>1</code>, dead = <code>0</code>). Can
refer to the first instance of a living status variable in the dataset, or
a full vector of all living status variables in temporal order.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_deadacol">deadacol</code></td>
<td>
<p>Variable name(s) or column number(s) providing information on
whether an individual is alive at a given occasion. If used, dead status must
be designated as binomial (dead = <code>1</code>, living = <code>0</code>).  Can refer to
the first instance of a dead status variable in the dataset, or a full vector
of all dead status variables in temporal order.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_obsacol">obsacol</code></td>
<td>
<p>A variable name(s) or column number(s) providing information
on whether an individual is in an observable stage at a given occasion. If
used, observation status must be designated as binomial (observed = <code>1</code>, 
not observed = <code>0</code>). Can refer to the first instance of an observation
status variable in the dataset, or a full vector of all observation status
variables in temporal order.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_nonobsacol">nonobsacol</code></td>
<td>
<p>A variable name(s) or column number(s) providing
information on whether an individual is in an unobservable stage at a given
occasion. If used, observation status must be designated as binomial (not
observed = <code>1</code>, observed = <code>0</code>). Can refer to the first instance of
a non-observation status variable in the dataset, or a full vector of all
non-observation status variables in temporal order.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_censorcol">censorcol</code></td>
<td>
<p>A variable name(s) or column number(s) corresponding to the
first entry of a censor variable, used to distinguish between entries to use
and entries not to use, or to designate entries with special issues that
require further attention. Can refer to the first instance of a censor status
variable in the dataset, or a full vector of all censor status variables in
temporal order. Can also refer to a single censor status variable used for
the entire individual, if <code>singlecensor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_repstrrel">repstrrel</code></td>
<td>
<p>This is a scalar multiplier on variable <code>repstrbcol</code> to
make it equivalent to <code>repstracol</code>. This can be useful if two 
reproductive status variables have related but unequal units, for example if
<code>repstracol</code> refers to one-flowered stems while <code>repstrbcol</code> refers
to two-flowered stems. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_fecrel">fecrel</code></td>
<td>
<p>This is a scalar multiplier on variable <code>fecbcol</code> to make
it equivalent to <code>fecacol</code>. This can be useful if two fecundity 
variables have related but unequal units. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_stagecol">stagecol</code></td>
<td>
<p>Optional variable name(s) or column number(s) corresponding
to life history stage at a given occasion. Can refer to the first instance of
a stage identity variable in the dataset, or a full vector of all stage
identity variables in temporal order.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_stageassign">stageassign</code></td>
<td>
<p>The stageframe object identifying the life history model
being operationalized. Note that if <code>stagecol</code> is provided, then this
stageframe is not used for stage designation.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_stagesize">stagesize</code></td>
<td>
<p>A variable name or column number describing which size 
variable to use in stage estimation. Defaults to NA, and can also take 
<code>sizea</code>, <code>sizeb</code>, <code>sizec</code>, <code>sizeab</code>, <code>sizebc</code>,
<code>sizeac</code>, <code>sizeabc</code>, or <code>sizeadded</code>, depending on
which size variable within the input dataset is chosen. Note that the
variable(s) chosen should be presented in the order of the primary,
secondary, and tertiary variables in the stageframe input with
<code>stageassign</code>. For example, choosing <code>sizeb</code> assumes that this size
is the primary variable in the stageframe.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_censorkeep">censorkeep</code></td>
<td>
<p>The value of the censor variable identifying data to be
included in analysis. Defaults to <code>0</code>, but may take any value including
<code>NA</code>. Note that if <code>NA</code> is the value to keep, then this function
will alter all <code>NA</code>s to <code>0</code> values, and all other values to
<code>1</code>, treating <code>0</code> as the new value to keep.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_censorrepeat">censorRepeat</code></td>
<td>
<p>A logical value indicating whether the censor variable
is a single column, or whether it repeats across occasion blocks. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_censor">censor</code></td>
<td>
<p>A logical variable determining whether the output data should 
be censored using the variable defined in <code>censorcol</code>. Defaults to 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_coordsrepeat">coordsRepeat</code></td>
<td>
<p>A logical value indicating whether X and Y coordinates
correspond to single X and Y columns. If <code>TRUE</code>, then each observation
occasion has its own X and Y variables. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_spacing">spacing</code></td>
<td>
<p>The spacing at which density should be estimated, if density
estimation is desired and X and Y coordinates are supplied. Given in the same
units as those used in the X and Y coordinates given in <code>xcol</code> and 
<code>ycol</code>. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_naas0">NAas0</code></td>
<td>
<p>If <code>TRUE</code>, then all <code>NA</code> entries for size and
fecundity variables will be set to 0. This can help increase the sample size
analyzed by <code><a href="#topic+modelsearch">modelsearch</a>()</code>, but should only be used when it is
clear that this substitution is biologically realistic. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_nrasrep">NRasRep</code></td>
<td>
<p>If <code>TRUE</code>, then will treat non-reproductive but mature 
individuals as reproductive during stage assignment. This can be useful when
a MPM is desired without separation of reproductive and non-reproductive but
mature stages of the same size. Only used if <code>stageassign</code> is set to a
stageframe. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_noasobs">NOasObs</code></td>
<td>
<p>If <code>TRUE</code>, then will treat individuals that are
interpreted as not observed in the dataset as though they were observed
during stage assignment. This can be useful when a MPM is desired without
separation of observable and unobservable stages. Only used if
<code>stageassign</code> is set to a stageframe. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_prebreeding">prebreeding</code></td>
<td>
<p>A logical term indicating whether the life history model
is pre-breeding. If so, then <code>1</code> is added to all ages. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_age_offset">age_offset</code></td>
<td>
<p>A number to add automatically to all values of age at time
<em>t</em>. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_reduce">reduce</code></td>
<td>
<p>A logical variable determining whether unused variables and 
some invariant state variables should be removed from the output dataset.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_a2check">a2check</code></td>
<td>
<p>A logical variable indicating whether to retain all data with
living status at occasion <em>t</em>. Defaults to <code>FALSE</code>, in which case
data for occasions in which the individual is not alive in time <em>t</em> is
not retained. This option should be kept <code>FALSE</code>, except to inspect
potential errors in the dataset.</p>
</td></tr>
<tr><td><code id="verticalize3_+3A_quiet">quiet</code></td>
<td>
<p>A logical variable indicating whether to silence warnings.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all inputs are properly formatted, then this function will output
a historical vertical data frame (class <code>hfvdata</code>), meaning that the
output data frame will have three consecutive occasions of size and
reproductive data per individual per row. This data frame is in standard
format for all functions used in <code>lefko3</code>, and so can be used without
further modification.
</p>
<p>Variables in this data frame include the following:
</p>
<table>
<tr><td><code>rowid</code></td>
<td>
<p>Unique identifier for the row of the data frame.</p>
</td></tr>
<tr><td><code>popid</code></td>
<td>
<p>Unique identifier for the population, if given.</p>
</td></tr>
<tr><td><code>patchid</code></td>
<td>
<p>Unique identifier for patch within population, if given.</p>
</td></tr>
<tr><td><code>individ</code></td>
<td>
<p>Unique identifier for the individual.</p>
</td></tr>
<tr><td><code>year2</code></td>
<td>
<p>Year or time at occasion <em>t</em>.</p>
</td></tr>
<tr><td><code>firstseen</code></td>
<td>
<p>Occasion of first observation.</p>
</td></tr>
<tr><td><code>lastseen</code></td>
<td>
<p>Occasion of last observation.</p>
</td></tr>
<tr><td><code>obsage</code></td>
<td>
<p>Observed age in occasion <em>t</em>, assuming first observation
corresponds to age = 0.</p>
</td></tr>
<tr><td><code>obslifespan</code></td>
<td>
<p>Observed lifespan, given as <code>lastseen - firstseen + 1</code>.</p>
</td></tr>
<tr><td><code>xpos1</code>, <code>xpos2</code>, <code>xpos3</code></td>
<td>
<p>X position in Cartesian space in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively, if provided.</p>
</td></tr>
<tr><td><code>ypos1</code>, <code>ypos2</code>, <code>ypos3</code></td>
<td>
<p>Y position in Cartesian space in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively, if provided.</p>
</td></tr>
<tr><td><code>sizea1</code>, <code>sizea2</code>, <code>sizea3</code></td>
<td>
<p>Main size measurement in occasions <em>t</em>-1, 
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>sizeb1</code>, <code>sizeb2</code>, <code>sizeb3</code></td>
<td>
<p>Secondary size measurement in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>sizec1</code>, <code>sizec2</code>, <code>sizec3</code></td>
<td>
<p>Tertiary measurement in occasions <em>t</em>-1, 
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>size1added</code>, <code>size2added</code>, <code>size3added</code></td>
<td>
<p>Sum of primary, secondary, and 
tertiary size measurements in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, 
respectively.</p>
</td></tr>
<tr><td><code>repstra1</code>, <code>repstra2</code>, <code>repstra3</code></td>
<td>
<p>Main numbers of reproductive structures in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstrb1</code>, <code>repstrb2</code>, <code>repstrb3</code></td>
<td>
<p>Secondary numbers of reproductive 
structures in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstr1added</code>, <code>repstr2added</code>, <code>repstr3added</code></td>
<td>
<p>Sum of primary and secondary
reproductive structures in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, 
respectively.</p>
</td></tr>
<tr><td><code>feca1</code>, <code>feca2</code>, <code>feca3</code></td>
<td>
<p>Main numbers of offspring in occasions <em>t</em>-1, 
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fecb1</code>, <code>fecb2</code>, <code>fecb3</code></td>
<td>
<p>Secondary numbers of offspring in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fec1added</code>, <code>fec2added</code>, <code>fec3added</code></td>
<td>
<p>Sum of primary and secondary fecundity
in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>censor1</code>, <code>censor2</code>, <code>censor3</code></td>
<td>
<p>Censor state values in occasions <em>t</em>-1, 
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>juvgiven1</code>, <code>juvgiven2</code>, <code>juvgiven3</code></td>
<td>
<p>Binomial variable indicating whether
individual is juvenile in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1.
Only given if <code>juvcol</code> is provided.</p>
</td></tr>
<tr><td><code>obsstatus1</code>, <code>obsstatus2</code>, <code>obsstatus3</code></td>
<td>
<p>Binomial observation state in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>repstatus1</code>, <code>repstatus2</code>, <code>repstatus3</code></td>
<td>
<p>Binomial reproductive state in
occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>fecstatus1</code>, <code>fecstatus2</code>, <code>fecstatus3</code></td>
<td>
<p>Binomial offspring production state
in occasions <em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>matstatus1</code>, <code>matstatus2</code>, <code>matstatus3</code></td>
<td>
<p>Binomial maturity state in occasions
<em>t</em>-1, <em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>alive1</code>, <code>alive2</code>, <code>alive3</code></td>
<td>
<p>Binomial state as alive in occasions <em>t</em>-1,
<em>t</em>, and <em>t</em>+1, respectively.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>Radial density of individuals per unit designated in
<code>spacing</code>. Only given if <code>spacing</code> is not NA.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>In some datasets on species with unobservable stages, observation status
(<code>obsstatus</code>) might not be inferred properly if a single size variable
is used that does not yield sizes greater than 0 in all cases in which
individuals were observed. Such situations may arise, for example, in plants
when leaf number is the dominant size variable used, but individuals
occasionally occur with inflorescences but no leaves. In this instances,
it helps to mark related variables as <code>sizeb</code> and <code>sizec</code>, because
observation status will be interpreted in relation to all 3 size variables.
Further analysis can then utilize only a single size variable, of the user's
choosing. Similar issues can arise in reproductive status (<code>repstatus</code>).
</p>
<p>Juvenile designation should only be used when juveniles fall outside of the
size classification scheme used in determining stages. If juveniles are to be
size classified along the size spectrum that adults also fall on, then
it is best to treat juveniles as mature but not reproductive.
</p>
<p>Warnings that some individuals occur in state combinations that do not match
any stages in the stageframe used to assign stages are common when first
working with a dataset. Typically, these situations can be identified as
<code>NoMatch</code> entries in <code>stage3</code>, although such entries may crop up in
<code>stage1</code> and <code>stage2</code>, as well. In rare cases, these warnings will
arise with no concurrent <code>NoMatch</code> entries, which indicates that the
input dataset contained conflicting state data at once suggesting that the
individual is in some stage but is also dead. The latter is removed if the
conflict occurs in occasion <em>t</em> or <em>t</em>-1, as only living entries
are allowed in time <em>t</em> and time <em>t</em>-1 may involve living entries
as well as non-living entries immediately prior to birth.
</p>
<p>Care should be taken to avoid variables with negative values indicating size,
fecundity, or reproductive or observation status. Negative values can be
interpreted in different ways, typically reflecting estimation through other
algorithms rather than actual measured data. Variables holding negative
values can conflict with data management algorithms in ways that are
difficult to predict.
</p>
<p>Unusual errors (e.g. <code>"Error in .pfj..."</code>) may occur in cases where the
variables are improperly passed, where seemingly numeric variables include
text, or where the <code>blocksize</code> is improperly set.
</p>
<p>Density estimation is performed as a count of individuals alive and within
the radius specified in <code>spacing</code> of the respective individual at some
point in time.
</p>
<p>If a censor variable is included for each monitoring occasion, and the
<code>blocksize</code> option is set, then the user must set
<code>censorRepeat = TRUE</code> in order to censor the correct transitions.
Failing this step will likely lead to the loss of a large portion of the data
as all data for entire individuals will be excluded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lathyrus example using blocksize - when repeated patterns exist in variable
# order
data(lathyrus)

sizevector &lt;- c(0, 100, 13, 127, 3730, 3800, 0)
stagevector &lt;- c("Sd", "Sdl", "VSm", "Sm", "VLa", "Flo", "Dorm")
repvector &lt;- c(0, 0, 0, 0, 0, 1, 0)
obsvector &lt;- c(0, 1, 1, 1, 1, 1, 0)
matvector &lt;- c(0, 0, 1, 1, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 11, 103, 3500, 3800, 0.5)

lathframe &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  immstatus = immvector, indataset = indataset, binhalfwidth = binvec,
  propstatus = propvector)

lathvert &lt;- verticalize3(lathyrus, noyears = 4, firstyear = 1988,
  patchidcol = "SUBPLOT", individcol = "GENET", blocksize = 9,
  juvcol = "Seedling1988", sizeacol = "Volume88", repstracol = "FCODE88",
  fecacol = "Intactseed88", deadacol = "Dead1988",
  nonobsacol = "Dormant1988", stageassign = lathframe, stagesize = "sizea",
  censorcol = "Missing1988", censorkeep = NA, censor = TRUE)

# Cypripedium example using partial repeat patterns with blocksize and part
# explicit variable name cast
data(cypdata)

sizevector &lt;- c(0, 0, 0, 0, 0, 0, 1, 2.5, 4.5, 8, 17.5)
stagevector &lt;- c("SD", "P1", "P2", "P3", "SL", "D", "XSm", "Sm", "Md", "Lg",
  "XLg")
repvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
obsvector &lt;- c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1)
matvector &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
immvector &lt;- c(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
indataset &lt;- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)
binvec &lt;- c(0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, 2.5, 7)

cypframe_raw &lt;- sf_create(sizes = sizevector, stagenames = stagevector,
  repstatus = repvector, obsstatus = obsvector, matstatus = matvector,
  propstatus = propvector, immstatus = immvector, indataset = indataset,
  binhalfwidth = binvec)

cypraw_v1 &lt;- verticalize3(data = cypdata, noyears = 6, firstyear = 2004,
  patchidcol = "patch", individcol = "plantid", blocksize = 4,
  sizeacol = "Inf2.04", sizebcol = "Inf.04", sizeccol = "Veg.04",
  repstracol = c("Inf.04", "Inf.05", "Inf.06", "Inf.07", "Inf.08", "Inf.09"),
  repstrbcol = c("Inf2.04", "Inf2.05", "Inf2.06", "Inf2.07", "Inf2.08", "Inf2.09"), 
  fecacol = "Pod.04", stageassign = cypframe_raw, stagesize = "sizeadded",
  NAas0 = TRUE, NRasRep = TRUE)

</code></pre>

<hr>
<h2 id='vrm_import'>Import Vital Rate Model Factor Values for Function-based MPM Development</h2><span id='topic+vrm_import'></span>

<h3>Description</h3>

<p>Function <code>vrm_import()</code> builds a skeleton list holding data frames and
vectors that can be used to import coefficient values for the factors of the
vital rate models used to build function-based MPMs or run function-based
projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vrm_import(
  years = NULL,
  patches = c(1),
  groups = c(0),
  interactions = FALSE,
  zi = FALSE,
  cat.indcova = NULL,
  cat.indcovb = NULL,
  cat.indcovc = NULL,
  dist.sizea = "gaussian",
  dist.sizeb = "constant",
  dist.sizec = "constant",
  dist.fec = "gaussian",
  trunc.sizea = FALSE,
  trunc.sizeb = FALSE,
  trunc.sizec = FALSE,
  trunc.fec = FALSE,
  use.juv = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vrm_import_+3A_years">years</code></td>
<td>
<p>A numeric vector of the years or times at time <code>t</code> to be
modeled.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_patches">patches</code></td>
<td>
<p>A string or numeric vector of the patch names to be modeled.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_groups">groups</code></td>
<td>
<p>An integer vector of stage groups to be modeled. Defaults to a
vector with a single element with value <code>0</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_interactions">interactions</code></td>
<td>
<p>A logical value indicating whether to include two-way
interactions between main effects (<code>TRUE</code>), or only main effects
(<code>FALSE</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_zi">zi</code></td>
<td>
<p>A logical value indicating whether to include coefficients for the
binomial components of zero-inflation models. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_cat.indcova">cat.indcova</code></td>
<td>
<p>If individual covariate a is categorical, then this term
should equal a string vector of the names of the categories. Defaults to
<code>NULL</code>, in which case individual covariate a is either not used or is
numeric.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_cat.indcovb">cat.indcovb</code></td>
<td>
<p>If individual covariate b is categorical, then this term
should equal a string vector of the names of the categories. Defaults to
<code>NULL</code>, in which case individual covariate b is either not used or is
numeric.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_cat.indcovc">cat.indcovc</code></td>
<td>
<p>If individual covariate c is categorical, then this term
should equal a string vector of the names of the categories. Defaults to
<code>NULL</code>, in which case individual covariate c is either not used or is
numeric.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_dist.sizea">dist.sizea</code></td>
<td>
<p>A string value giving the distribution of the variable
coding primary size. Can equal <code>"none"</code>, <code>"gamma"</code>,
<code>"gaussian"</code>, <code>"poisson"</code>, <code>"negbin"</code>, or <code>"constant"</code>.
Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_dist.sizeb">dist.sizeb</code></td>
<td>
<p>A string value giving the distribution of the variable
coding secondary size. Can equal <code>"none"</code>, <code>"gamma"</code>,
<code>"gaussian"</code>, <code>"poisson"</code>, <code>"negbin"</code>, or <code>"constant"</code>.
Defaults to <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_dist.sizec">dist.sizec</code></td>
<td>
<p>A string value giving the distribution of the variable
coding tertiary size. Can equal <code>"none"</code>, <code>"gamma"</code>,
<code>"gaussian"</code>, <code>"poisson"</code>, <code>"negbin"</code>, or <code>"constant"</code>.
Defaults to <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_dist.fec">dist.fec</code></td>
<td>
<p>A string value giving the distribution of the variable
coding fecundity. Can equal <code>"none"</code>, <code>"gamma"</code>,
<code>"gaussian"</code>, <code>"poisson"</code>, or <code>"negbin"</code>. Defaults to
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_trunc.sizea">trunc.sizea</code></td>
<td>
<p>A logical value indicating whether the distribution of the
primary size variable should be zero-truncated. Defaults to <code>FALSE</code>.
Currently only works with the Poisson and negative binomial distributions.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_trunc.sizeb">trunc.sizeb</code></td>
<td>
<p>A logical value indicating whether the distribution of the
secondary size variable should be zero-truncated. Defaults to <code>FALSE</code>.
Currently only works with the Poisson and negative binomial distributions.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_trunc.sizec">trunc.sizec</code></td>
<td>
<p>A logical value indicating whether the distribution of the
tertiary size variable should be zero-truncated. Defaults to <code>FALSE</code>.
Currently only works with the Poisson and negative binomial distributions.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_trunc.fec">trunc.fec</code></td>
<td>
<p>A logical value indicating whether the distribution of the
fecundity variable should be zero-truncated. Defaults to <code>FALSE</code>.
Currently only works with the Poisson and negative binomial distributions.</p>
</td></tr>
<tr><td><code id="vrm_import_+3A_use.juv">use.juv</code></td>
<td>
<p>A logical value indicating whether to utilize juvenile vital
rates. If <code>FALSE</code>, then all juvenile vital rates will be set to
<code>constant</code> distributions. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>vrm_input</code>, with up to 13 elements including:
</p>
<table>
<tr><td><code>vrm_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for the
linear vital rate models.</p>
</td></tr>
<tr><td><code>year_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for the
year at time t terms in the linear vital rate models.</p>
</td></tr>
<tr><td><code>patch_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for the
patch terms in the linear vital rate models.</p>
</td></tr>
<tr><td><code>group2_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for the
stage group terms in time <em>t</em> in the linear vital rate models.</p>
</td></tr>
<tr><td><code>group1_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for the
stage group terms in time <em>t</em>-1 in the linear vital rate models.</p>
</td></tr>
<tr><td><code>dist_frame</code></td>
<td>
<p>A data frame giving the distributions of all variables,
including primary, secondary, and tertiary size, and fecundity. Some
variables begin as <code>constant</code>.</p>
</td></tr>
<tr><td><code>indcova2_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate a terms in time <em>t</em> in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>indcova1_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate a terms in time <em>t</em>-1 in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>indcovb2_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate b terms in time <em>t</em> in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>indcovb1_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate b terms in time <em>t</em>-1 in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>indcovc2_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate c terms in time <em>t</em> in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>indcovc1_frame</code></td>
<td>
<p>A data frame holding the main slope coefficients for
the categorical individual covariate c terms in time <em>t</em>-1 in the linear
vital rate models.</p>
</td></tr>
<tr><td><code>st_frame</code></td>
<td>
<p>A data frame holding values of sigma or theta for use in
Gaussian or negative binomial response terms, respectively.</p>
</td></tr>
</table>
<p>The first element, called <code>vrm_frame</code>, is a data frame with the
following 18 variables:
</p>
<table>
<tr><td><code>main_effect_1</code></td>
<td>
<p>The main effect for which coefficients are to be
entered.</p>
</td></tr>
<tr><td><code>main_1_defined</code></td>
<td>
<p>A more natural explanation of <code>main_effect_1</code>.</p>
</td></tr>
<tr><td><code>main_effect_2</code></td>
<td>
<p>If given, then indicates another effect in a two-way
interaction with <code>main_effect_1</code>.</p>
</td></tr>
<tr><td><code>main_2_defined</code></td>
<td>
<p>A more natural explanation of <code>main_effect_2</code>.</p>
</td></tr>
<tr><td><code>surv</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
survival.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
observation status.</p>
</td></tr>
<tr><td><code>sizea</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
primary size.</p>
</td></tr>
<tr><td><code>sizeb</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
secondary size.</p>
</td></tr>
<tr><td><code>sizec</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
tertiary size.</p>
</td></tr>
<tr><td><code>repst</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
reproductive status.</p>
</td></tr>
<tr><td><code>fec</code></td>
<td>
<p>A vector of coefficients for the factors in the model of adult
fecundity.</p>
</td></tr>
<tr><td><code>jsurv</code></td>
<td>
<p>A vector of coefficients for the factors in the model of
juvenile survival.</p>
</td></tr>
<tr><td><code>jobs</code></td>
<td>
<p>A vector of coefficients for the factors in the model of juvenile
observation status.</p>
</td></tr>
<tr><td><code>jsize</code></td>
<td>
<p>A vector of coefficients for the factors in the model of
juvenile primary size.</p>
</td></tr>
<tr><td><code>jsizeb</code></td>
<td>
<p>A vector of coefficients for the factors in the model of
juvenile secondary size.</p>
</td></tr>
<tr><td><code>jsizec</code></td>
<td>
<p>A vector of coefficients for the factors in the model of
juvenile tertiary size.</p>
</td></tr>
<tr><td><code>jrepst</code></td>
<td>
<p>A vector of coefficients for the factors in the model of
juvenile reproductive status, for individuals maturing in the current time
step.</p>
</td></tr>
<tr><td><code>jmat</code></td>
<td>
<p>A vector of coefficients for the factors in the model of maturity
status, for individuals capable of maturing at the current time step.</p>
</td></tr>
<tr><td><code>sizea_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of adult primary size, if zero-inflated
models are being used.</p>
</td></tr>
<tr><td><code>sizeb_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of adult secondary size, if
zero-inflated models are being used.</p>
</td></tr>
<tr><td><code>sizec_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of adult tertiary size, if zero-inflated
models are being used.</p>
</td></tr>
<tr><td><code>fec_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of fecundity, if zero-inflated models
are being used.</p>
</td></tr>
<tr><td><code>jsizea_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of juvenile primary size, if
zero-inflated models are being used.</p>
</td></tr>
<tr><td><code>jsizeb_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of juvenile secondary size, if
zero-inflated models are being used.</p>
</td></tr>
<tr><td><code>jsizec_zi</code></td>
<td>
<p>A vector of coefficients for the factors in the binomial
component of the zero-inflated model of juvenile tertiary size, if
zero-inflated models are being used.</p>
</td></tr>
</table>


<h3>Notes</h3>

<p>All coefficients across all data frames are initially set to <code>0</code>. After
using this function to create the skeleton list, all relevant coefficient
values should be set to non-zero values equal to the respective slope from
the appropriate linear model, and any vital rate model to be used should
have its distribution set to <code>"binom"</code>, <code>"gaussian"</code>,
<code>"gamma"</code>, <code>"poisson"</code>, or <code>"negbin"</code>. Unused vital rates
should be set to <code>"constant"</code>, and the first element of the correspoding
column in <code>vrm_frame</code> (corresponding to the y-intercept) should be set
to the constant value to utilize (generally <code>1</code>). If no values are
manually edited, then function-based MPM generator functions will not be able
to generate valid MPMs.
</p>
<p>Users should never change the labels or the order of terms in the data frames
and vectors produced via this function, nor should they ever changes the
names of core list elements in the <code>vrm_input</code> object. Doing so will
result either in fatal errors or erroneous matrix calculations.
</p>
<p>Using the <code>vrm_input</code> approach to building function-based MPMs requires
careful attention to the stageframe. Although no hfv data frame needs to be
entered, stages for which vital rates are to be estimated via linear models
parameterized with coefficients provided via function <code>vrm_import()</code>
should be marked as occurring within the dataset, while stages for which
the provided coefficients should not be used should be marked as not
occurring within the dataset.
</p>
<p>Coefficients added to zero-inflation models can only be added to primary
size, secondary size, tertiary size, fecundity, and the juvenile versions of
primary, secondary, and tertiary size. Care must be taken to include zero-
inflated coefficients only for variables without size-truncated
distributions. Adding such terms will result in fatal errors during matrix
creation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lathyrus)

sizevector &lt;- c(0, 100, 0, 1, 7100)
stagevector &lt;- c("Sd", "Sdl", "Dorm", "ipm", "ipm")
repvector &lt;- c(0, 0, 0, 1, 1)
obsvector &lt;- c(0, 1, 0, 1, 1)
matvector &lt;- c(0, 0, 1, 1, 1)
immvector &lt;- c(1, 1, 0, 0, 0)
propvector &lt;- c(1, 0, 0, 0, 0)
indataset &lt;- c(0, 1, 1, 1, 1)
binvec &lt;- c(0, 100, 0.5, 1, 1)
comments &lt;- c("Dormant seed", "Seedling", "Dormant", "ipm adult stage",
  "ipm adult stage")
lathframeipm &lt;- sf_create(sizes = sizevector, stagenames = stagevector, 
  repstatus = repvector, obsstatus = obsvector, propstatus = propvector,
  immstatus = immvector, matstatus = matvector, comments = comments,
  indataset = indataset, binhalfwidth = binvec, ipmbins = 100, roundsize = 3)

lathsupp2 &lt;- supplemental(stage3 = c("Sd", "Sdl", "Sd", "Sdl"),
  stage2 = c("Sd", "Sd", "rep", "rep"),
  givenrate = c(0.345, 0.054, NA, NA),
  multiplier = c(NA, NA, 0.345, 0.054),
  type = c(1, 1, 3, 3), stageframe = lathframeipm, historical = FALSE)

lath_vrm &lt;- vrm_import(years = c(1988:1990), zi = TRUE, dist.fec = "negbin",
  use.juv = TRUE)

lath_vrm$vrm_frame$surv[1] &lt;- 2.32571
lath_vrm$vrm_frame$surv[2] &lt;- 0.00109
lath_vrm$vrm_frame$obs[1] &lt;- 2.230
lath_vrm$vrm_frame$sizea[1] &lt;- 164.0695
lath_vrm$vrm_frame$sizea[2] &lt;- 0.6211
lath_vrm$vrm_frame$fec[1] &lt;- 1.517
lath_vrm$vrm_frame$fec_zi[1] &lt;- 6.252765
lath_vrm$vrm_frame$fec_zi[2] &lt;- -0.007313
lath_vrm$vrm_frame$jsurv[1] &lt;- 1.03
lath_vrm$vrm_frame$jobs[1] &lt;- 10.390
lath_vrm$vrm_frame$jsizea[1] &lt;- 3.0559
lath_vrm$vrm_frame$jsizea[2] &lt;- 0.8482

lath_vrm$year_frame$fec[c(1:3)] &lt;- c(-0.41749627, 0.51421684, -0.07964038)
lath_vrm$year_frame$fec_zi[c(1:3)] &lt;- c(3.741475e-07, -7.804715e-08,
  -2.533755e-07)
lath_vrm$year_frame$sizea[c(1:3)] &lt;- c(96.3244, -240.8036, 144.4792)
lath_vrm$year_frame$jobs[c(1:3)] &lt;- c(-0.7459843, 0.6118826, -0.9468618)
lath_vrm$year_frame$jsizea[c(1:3)] &lt;- c(0.5937962, 1.4551236, -2.0489198)

lath_vrm$dist_frame$dist[2] &lt;- "binom"
lath_vrm$dist_frame$dist[9] &lt;- "binom"

lath_vrm$st_frame[3] &lt;- 503.6167
lath_vrm$st_frame[7] &lt;- 0.2342114
lath_vrm$st_frame[10] &lt;- 5.831

lath_vrm$vrm_frame$sizeb[1] &lt;- 1
lath_vrm$vrm_frame$sizec[1] &lt;- 1
lath_vrm$vrm_frame$repst[1] &lt;- 1
lath_vrm$vrm_frame$jsizeb[1] &lt;- 1
lath_vrm$vrm_frame$jsizec[1] &lt;- 1
lath_vrm$vrm_frame$jrepst[1] &lt;- 1
lath_vrm$vrm_frame$jmatst[1] &lt;- 1

lathmat2_importipm &lt;- flefko2(stageframe = lathframeipm,
  modelsuite = lath_vrm, supplement = lathsupp2, reduce = FALSE)

summary(lathmat2_importipm)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
