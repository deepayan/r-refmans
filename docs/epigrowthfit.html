<!DOCTYPE html><html><head><title>Help for package epigrowthfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epigrowthfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#epigrowthfit-package'><p><span class="rlang"><b>R</b></span> Package <span class="pkg">epigrowthfit</span></p></a></li>
<li><a href='#coef.egf'><p>Extract Coefficients and Random Effect Covariance Parameters</p></a></li>
<li><a href='#confint.egf'><p>Confidence Intervals</p></a></li>
<li><a href='#cov2theta'><p>Compute a Packed Representation of a Covariance Matrix</p></a></li>
<li><a href='#covid19.ontario'><p>COVID-19 in Ontario, Canada</p></a></li>
<li><a href='#df.residual.egf'><p>Extract the Residual Degrees of Freedom</p></a></li>
<li><a href='#egf'><p>Fit Nonlinear Mixed Effects Models of Epidemic Growth</p></a></li>
<li><a href='#egf_control'><p>Define Control Parameters</p></a></li>
<li><a href='#egf_control_plot'><p>Define Control Parameters for Plotting</p></a></li>
<li><a href='#egf_has_converged'><p>Test for Convergence</p></a></li>
<li><a href='#egf_has_random'><p>Test for Random Effects</p></a></li>
<li><a href='#egf_model'><p>Define a Top Level Nonlinear Model</p></a></li>
<li><a href='#egf_optimizer'><p>Define an Optimization Method</p></a></li>
<li><a href='#egf_parallel'><p>Define a Parallelization Method</p></a></li>
<li><a href='#egf_prior'><p>Prior Distributions</p></a></li>
<li><a href='#egf_top'><p>Top Level Nonlinear Model Parameter Names</p></a></li>
<li><a href='#egf-class'><p>Description of Objects of Class <code>egf</code></p></a></li>
<li><a href='#epigrowthfit-defunct'><p>Defunct Functions in Package <span class="pkg">epigrowthfit</span></p></a></li>
<li><a href='#epigrowthfit-deprecated'><p>Deprecated Functions in Package <span class="pkg">epigrowthfit</span></p></a></li>
<li><a href='#epigrowthfit-notyet'><p>Not Yet Implemented Functions in Package <span class="pkg">epigrowthfit</span></p></a></li>
<li><a href='#extractAIC.egf'><p>Extract the (Generalized) AIC</p></a></li>
<li><a href='#finalsize'><p>Compute the Expected Epidemic Final Size</p></a></li>
<li><a href='#fitted.egf'><p>Fitted Values</p></a></li>
<li><a href='#fixef.egf'><p>Details about Fixed Effect Coefficients</p></a></li>
<li><a href='#formula.egf'><p>Extract Model Formulae</p></a></li>
<li><a href='#getCall.egf'><p>Extract Model Calls</p></a></li>
<li><a href='#gi'><p>Generation Interval Distribution</p></a></li>
<li><a href='#logLik.egf'><p>Extract the Log (Marginal) Likelihood</p></a></li>
<li><a href='#model.frame.egf'><p>Extract Model Frames</p></a></li>
<li><a href='#model.matrix.egf'><p>Extract Design Matrices</p></a></li>
<li><a href='#nobs.egf'><p>Extract the Number of Observations</p></a></li>
<li><a href='#plot.egf'><p>Plot Nonlinear Mixed Effects Models of Epidemic Growth</p></a></li>
<li><a href='#predict.egf'><p>Predicted Values</p></a></li>
<li><a href='#print.egf'><p>Printing Model Objects</p></a></li>
<li><a href='#profile.egf'><p>Univariate Likelihood Profiles</p></a></li>
<li><a href='#R0'><p>Compute the Basic Reproduction Number</p></a></li>
<li><a href='#ranef.egf'><p>Details about Random Effect Coefficients</p></a></li>
<li><a href='#simulate.egf'><p>Simulation and Parametric Bootstrapping</p></a></li>
<li><a href='#simulate.egf_model'><p>Simulating Incidence Time Series</p></a></li>
<li><a href='#summary.egf'><p>Model Summaries</p></a></li>
<li><a href='#terms.egf'><p>Model Terms</p></a></li>
<li><a href='#timescale'><p>Compute the Characteristic Time Scale</p></a></li>
<li><a href='#vcov.egf'><p>Model Covariance Matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.15.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-17</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidearn/epigrowthfit">https://github.com/davidearn/epigrowthfit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidearn/epigrowthfit/issues">https://github.com/davidearn/epigrowthfit/issues</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Mixed Effects Models of Epidemic Growth</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Maximum likelihood estimation of nonlinear mixed effects models of
	epidemic growth using Template Model Builder ('TMB').  Enables
	joint estimation for collections of disease incidence time series,
	including time series that describe multiple epidemic waves.
	Supports a set of widely used phenomenological models: exponential,
	logistic, Richards (generalized logistic), subexponential,
	and Gompertz.  Provides methods for interrogating model objects
	and several auxiliary functions, including one for computing basic
	reproduction numbers from fitted values of the initial exponential
	growth rate.
	Preliminary versions of this software were applied
	in Ma et al. (2014) &lt;<a href="https://doi.org/10.1007%2Fs11538-013-9918-2">doi:10.1007/s11538-013-9918-2</a>&gt; and
	in Earn et al. (2020) &lt;<a href="https://doi.org/10.1073%2Fpnas.2004904117">doi:10.1073/pnas.2004904117</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen (&ge; 0.3.4.0.0), TMB</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.6-2), TMB, grDevices, graphics, methods, nlme,
stats, tools, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-18 01:06:32 UTC; mikael</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikael Jagan <a href="https://orcid.org/0000-0002-3542-2938"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jonathan Dushoff <a href="https://orcid.org/0000-0003-0506-4794"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  David Earn <a href="https://orcid.org/0000-0003-3597-617X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Junling Ma [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikael Jagan &lt;jaganmn@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-18 04:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='epigrowthfit-package'><span class="rlang"><b>R</b></span> Package <span class="pkg">epigrowthfit</span></h2><span id='topic+epigrowthfit-package'></span><span id='topic+epigrowthfit'></span>

<h3>Description</h3>

<p>An <span class="rlang"><b>R</b></span> package for estimating nonlinear mixed effects models of
epidemic growth.
</p>


<h3>Details</h3>

<p>The &ldquo;main&rdquo; model estimating function is <code><a href="#topic+egf">egf</a></code>.
</p>
<p>To render a list of available help topics, use
<code><a href="utils.html#topic+help">help</a>(package = "epigrowthfit")</code>.
Many of these document methods for the class of objects returned
by <code><a href="#topic+egf">egf</a></code>.
</p>
<p>To report a bug or request a change, use
<code><a href="utils.html#topic+bug.report">bug.report</a>(package = "epigrowthfit")</code>.
</p>


<h3>Author(s)</h3>

<p>Mikael Jagan
<a href="mailto:jaganmn@mcmaster.ca">jaganmn@mcmaster.ca</a>
</p>

<hr>
<h2 id='coef.egf'>Extract Coefficients and Random Effect Covariance Parameters</h2><span id='topic+coef.egf'></span><span id='topic+coef.egf_no_fit'></span><span id='topic+print.coef.egf'></span><span id='topic+as.list.coef.egf'></span><span id='topic+labels.coef.egf'></span>

<h3>Description</h3>

<p>Extracts the bottom level parameter vector <code>c(beta, theta, b)</code>
or a subset.  Segments <code>beta</code>, <code>theta</code>, and <code>b</code> contain
(respectively) fixed effect coefficients, random effect covariance
parameters, and random effect coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
coef(object, random = FALSE, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.egf_+3A_random">random</code></td>
<td>

<p>a logical.  If <code>FALSE</code>, then segment <code>b</code> is excluded.</p>
</td></tr>
<tr><td><code id="coef.egf_+3A_full">full</code></td>
<td>

<p>a logical.  If <code>FALSE</code>, then mapped elements are excluded,
and the result is called &ldquo;condensed&rdquo;.</p>
</td></tr>
<tr><td><code id="coef.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector concatenating <code>beta</code>, <code>theta</code>, and
<code>b</code>, without <code>b</code> if <code>random = FALSE</code> and without
mapped elements if <code>full = FALSE</code>.
</p>
<p>Attribute <code>len</code> is a named integer vector partitioning the
result by segment.
</p>
<p>Attribute <code>map</code> is a named list of integer vectors <code>i</code>
such that that a full segment <code>y</code> and its condensed counterpart
<code>x</code> are related by <code>y = x[i]</code>, with the exception that
<code>i[j]</code> is <code>NA</code> if <code>y[j]</code> is mapped to an initial value.
<code>NULL</code> is used in place of an integer vector where <code>x</code>
and <code>y</code> are identical.
</p>
<p>The result inherits from class <code>coef.egf</code>, which has methods
for <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+as.list">as.list</a></code>, and <code><a href="base.html#topic+labels">labels</a></code>.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("egf", package = "epigrowthfit")

for (random in c(FALSE, TRUE)) {
    for (full in c(FALSE, TRUE)) {
        cat(sprintf("random = %s, full = %s :\n\n", random, full))
        str(coef(m1, random = random, full = full))
        cat("\n")
    }
}
</code></pre>

<hr>
<h2 id='confint.egf'>Confidence Intervals</h2><span id='topic+confint.egf'></span><span id='topic+plot.confint.egf'></span>

<h3>Description</h3>

<p>Computes confidence intervals on fixed effect coefficients,
random effect covariance parameters, and linear combinations thereof,
including population fitted values.
Intervals on individual fitted values accounting for random effects
are supported, but only by <code>method = "wald"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
confint(object, parm, level = 0.95,
        A = seq_along(par), method = c("wald", "profile", "uniroot"), scale = 7,
        parallel = egf_parallel(), trace = FALSE,
        top = egf_top(object), subset = NULL, select = NULL,
        class = FALSE, link = TRUE, random = FALSE, ...)

## S3 method for class 'confint.egf'
plot(x, by = 12L,
     subset = NULL, order = NULL, label = NULL, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_parm">parm</code></td>
<td>

<p>unused argument, for consistency with the generic function.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_level">level</code></td>
<td>

<p>a number in the interval <code class="reqn">(0,1)</code> indicating a confidence level.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_a">A</code></td>
<td>

<p>a numeric matrix with <code>1+p</code> columns,
where <code>p = length(coef(object))</code>,
in which case each row specifies a linear combination of the elements
of <code>c(1, coef(fitted))</code> for which intervals are computed;
or a valid index vector for <code>coef(fitted)</code>,
in which case intervals are computed for the indexed elements;
or <code>NULL</code>,
in which case intervals on fitted values are computed.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_method">method</code></td>
<td>

<p>a character string indicating <em>how</em> intervals are computed.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_scale">scale</code></td>
<td>

<p>a positive number, for <code>method = "uniroot"</code>.
<code><a href="TMB.html#topic+tmbroot">tmbroot</a></code> will search for roots between
<code>value-scale*se</code> and <code>value+scale*se</code>, where
<code>value</code> and <code>se</code> are the estimate and standard error.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_parallel">parallel</code></td>
<td>

<p>an <code><a href="#topic+egf_parallel">egf_parallel</a></code> object defining options for <span class="rlang"><b>R</b></span> level
parallelization.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_trace">trace</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then basic tracing messages indicating
progress are printed.  These may be mixed with optimizer output
depending on <code>object[["control"]][["trace"]]</code>.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_top">top</code></td>
<td>

<p>a subset of <code><a href="#topic+egf_top">egf_top</a>(object)</code> naming top level
nonlinear model parameters for which intervals on fitted values
should be computed.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_subset">subset</code>, <code id="confint.egf_+3A_select">select</code></td>
<td>

<p>index vectors for the rows and columns of
<code>model.frame(object, "combined")</code> or language objects
evaluating to such vectors.
<code>subset</code> indicates fitting windows for which intervals
should be computed; the default indicates all.
<code>select</code> indicates variables that should be appended to
the result; the default indicates none.
Evaluation of language objects follows the implementation of
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.<br />
<br />
For the <code><a href="base.html#topic+plot">plot</a></code> method:<br />
an index vector for <code>seq_len(nrow(x))</code> or a language object
evaluating in <code>x</code> to such a vector.
<code>subset</code> indicates which intervals are plotted;
the default indicates all.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_class">class</code></td>
<td>

<p>a logical.  If <code>TRUE</code> and if <code>A = NULL</code>,
then the value of the <code><a href="stats.html#topic+confint">confint</a></code> call is
a <code><a href="#topic+confint.egf">confint.egf</a></code> object, not a matrix.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_link">link</code></td>
<td>

<p>a logical. If <code>FALSE</code> and if <code>A = NULL</code>
and <code>class = TRUE</code>,
then fitted values and confidence limits are returned on the
&ldquo;natural&rdquo; (inverse link) scale.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_random">random</code></td>
<td>

<p>a logical, affecting only <code>method = "wald"</code>.  If <code>TRUE</code>,
then intervals are computed for individual fitted values,
which count random effects, rather than population fitted values,
which do not.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+confint.egf">confint.egf</a></code> object.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_by">by</code></td>
<td>

<p>a positive integer indicating the number of intervals displayed
in one plot.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_order">order</code></td>
<td>

<p>a permutation of <code>seq_len(nrow(x))</code> or a language object
evaluating in <code>x</code> to such a vector.
<code>order</code> indicates the order in which intervals are plotted;
the default indicates the original order.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_label">label</code></td>
<td>

<p>a character or expression vector of length <code>nrow(x)</code>
or a language object evaluating in <code>x</code> to such a vector.
<code>label</code> indicates <code class="reqn">y</code>-axis labels for intervals;
the default is to use <code>as.character(x[["window"]])</code>.</p>
</td></tr>
<tr><td><code id="confint.egf_+3A_main">main</code></td>
<td>

<p>a character or expression vector of length 1 indicating a plot title,
to be recycled for all plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three methods for computing confidence intervals are available:
</p>

<dl>
<dt><code>"wald"</code></dt><dd>
<p>confidence limits are calculated as
</p>
<pre>value + c(-1, 1) * sqrt(q) * se</pre>
<p>where <code>q = qchisq(level, df = 1)</code>.</p>
</dd>
<dt><code>"profile", "uniroot"</code></dt><dd>
<p>confidence limits are calculated as approximate solutions of the
equation
</p>
<pre>2 * (f(x) - f(value)) = q</pre>
<p>where <code>q = qchisq(level, df = 1)</code>
and <code>f</code> is the negative log marginal likelihood function
expressed as a function of the parameter <code>x</code> in question.
Solutions are approximated by interpolating a likelihood profile
(<code>"profile"</code>) or by rootfinding (<code>"uniroot"</code>).</p>
</dd>
</dl>

<p><code>"wald"</code> assumes asymptotic normality of the maximum likelihood
estimator.  <code>"profile"</code> and <code>"uniroot"</code> avoid this contraint
but are typically expensive, requiring estimation of many restricted
models.
They are parallelized at the C++ level when there is OpenMP
support and <code>object[["control"]][["omp_num_threads"]]</code> is set
to an integer greater than 1.  When there is no OpenMP support, they
can still be parallelized at the <span class="rlang"><b>R</b></span> level with appropriate setting
of argument <code>parallel</code>.
</p>


<h3>Value</h3>

<p>A numeric array in 2 or 3 dimensions containing the lower and upper
confidence limits in the last dimension.
</p>
<p>When confidence intervals on fitted values are desired, the user will
set <code>A = NULL</code> and in that case have the option of passing
<code>class = TRUE</code> to obtain an augmented result.  Thus, alternatively:
</p>
<p>A data frame inheriting from class <code>confint.egf</code>, with variables:
</p>
<table>
<tr><td><code>top</code></td>
<td>

<p>top level nonlinear model parameter, from
<code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code>ts</code></td>
<td>

<p>time series, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["ts"]])</code>.</p>
</td></tr>
<tr><td><code>window</code></td>
<td>

<p>fitting window, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["window"]])</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>fitted value.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>

<p>a numeric matrix with two columns giving the lower and upper
confidence limits.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>

<p>further variables from
<a href="#topic+model.frame.egf">model.frame</a>(object, &quot;combined&quot;)
specified by argument <code>select</code>.</p>
</td></tr>
</table>
<p>The confidence level <code>level</code> is preserved as an attribute.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+confint">confint</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("egf", package = "epigrowthfit")

zz1 &lt;- confint(m1, A = NULL, method =    "wald", class = TRUE,
               random = TRUE)
str(zz1)

op &lt;- par(mar = c(4.5, 4, 2, 1), oma = c(0, 0, 0, 0))
plot(zz1)
par(op)

zz2 &lt;- confint(m1, A = NULL, method = "profile", class = TRUE,
               top = "log(r)", subset = quote(country == "A" &amp; wave == 1))
zz3 &lt;- confint(m1, A = NULL, method = "uniroot", class = TRUE,
               top = "log(r)", subset = quote(country == "A" &amp; wave == 1))

</code></pre>

<hr>
<h2 id='cov2theta'>Compute a Packed Representation of a Covariance Matrix</h2><span id='topic+cov2theta'></span><span id='topic+theta2cov'></span>

<h3>Description</h3>

<p>Transform covariances matrices to a &ldquo;packed&rdquo; representation
or compute the inverse transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov2theta(Sigma)
theta2cov(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov2theta_+3A_sigma">Sigma</code></td>
<td>

<p>an <code class="reqn">n</code>-by-<code class="reqn">n</code> real, symmetric positive definite matrix.
Only the upper triangle is &ldquo;seen&rdquo;.</p>
</td></tr>
<tr><td><code id="cov2theta_+3A_theta">theta</code></td>
<td>

<p>a numeric vector of length <code class="reqn">n(n+1)/2</code> whose first
<code class="reqn">n</code> elements are positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code class="reqn">n</code>-by-<code class="reqn">n</code> real, symmetric, positive definite matrix
<code class="reqn">\Sigma</code> can be factorized as
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = R' R\,.</code>
</p>

<p>The upper triangular Cholesky factor <code class="reqn">R</code> can be written as
</p>
<p style="text-align: center;"><code class="reqn">R = R_{1} D^{-1/2} D_{\sigma}^{1/2}\,,</code>
</p>

<p>where
<code class="reqn">R_{1}</code> is a unit upper triangular matrix and
<code class="reqn">D = \mathrm{diag}(\mathrm{diag}(R_{1}' R_{1}))</code>
and
<code class="reqn">D_{\sigma} = \mathrm{diag}(\mathrm{diag}(\Sigma))</code>
are diagonal matrices.
</p>
<p><code>cov2theta</code> takes <code class="reqn">\Sigma</code> and returns the vector <code class="reqn">\theta</code>
of length <code class="reqn">n(n+1)/2</code> containing the log diagonal entries
of <code class="reqn">D_{\sigma}</code> followed by (in column-major order) the strictly
upper triangular entries of <code class="reqn">R_{1}</code>.  <code>theta2cov</code> computes the
inverse transformation.
</p>


<h3>Value</h3>

<p>A vector like <code>theta</code> (<code>cov2theta</code>) or a matrix like
<code>Sigma</code> (<code>theta2cov</code>); see &lsquo;Details&rsquo;.
</p>

<hr>
<h2 id='covid19.ontario'>COVID-19 in Ontario, Canada</h2><span id='topic+covid19.ontario'></span>

<h3>Description</h3>

<p>Time series of COVID-19 cases and tests in Ontario, Canada,
daily from February 8, 2020 to May 1, 2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(covid19.ontario, package = "epigrowthfit")
</code></pre>


<h3>Format</h3>

<p>A data frame with 814 rows and 3 variables:
</p>

<dl>
<dt><code>date</code></dt><dd>
<p>a <code><a href="base.html#topic+Date">Date</a></code> vector.</p>
</dd>
<dt><code>cases</code></dt><dd>
<p>an integer vector.  <code>cases[i]</code> is the number of cases confirmed
by Ontario public health units prior to <code>date[i]</code>.
This number includes resolved and fatal cases as well as reinfections.</p>
</dd>
<dt><code>tests</code></dt><dd>
<p>an integer vector.  <code>tests[i]</code> is the number of tests completed
prior to <code>date[i]</code>.  This number includes repeated tests by
individuals except prior to April 15, 2020, when individuals were
counted at most once.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This data set is a processed subset of a larger data set downloaded
on 2024-01-10 from the
It is updated using an installed script:
</p>
<pre>\link{system.file}("scripts", "covid19.ontario.R", package = "epigrowthfit")</pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(covid19.ontario, package = "epigrowthfit")
plot(1 + diff(c(NA, cases)) ~ date, data = covid19.ontario, log = "y")
</code></pre>

<hr>
<h2 id='df.residual.egf'>Extract the Residual Degrees of Freedom</h2><span id='topic+df.residual.egf'></span><span id='topic+df.residual.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object the number of observations
(see <code><a href="#topic+nobs.egf">nobs</a></code>)
minus the number of estimated parameters
(fixed effect coefficients and random effect covariance parameters).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.residual.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="df.residual.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+df.residual">df.residual</a></code>.
</p>

<hr>
<h2 id='egf'>Fit Nonlinear Mixed Effects Models of Epidemic Growth</h2><span id='topic+egf'></span><span id='topic+egf.egf_model'></span>

<h3>Description</h3>

<p>Fits nonlinear mixed effects models of epidemic growth
to collections of one or more disease incidence time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf(model, ...)

## S3 method for class 'egf_model'
egf(model,
    formula_ts,
    formula_windows,
    formula_parameters = list(),
    formula_priors = list(),
    data_ts,
    data_windows,
    subset_ts = NULL,
    subset_windows = NULL,
    select_windows = NULL,
    na_action_ts = c("fail", "pass"),
    na_action_windows = c("fail", "omit"),
    control = egf_control(),
    init = list(),
    map = list(),
    fit = TRUE,
    se = FALSE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_+3A_model">model</code></td>
<td>

<p>an <span class="rlang"><b>R</b></span> object specifying a top level nonlinear model,
typically of class <code><a href="#topic+egf_model">egf_model</a></code>.</p>
</td></tr>
<tr><td><code id="egf_+3A_formula_ts">formula_ts</code></td>
<td>

<p>a formula of the form <code>cbind(time, x) ~ ts</code>
specifying one or more disease incidence time series in long format.<br />
<br />
<code>ts</code> must evaluate to a factor (insofar as <code>as.factor(ts)</code>
is a factor) grouping the data by time series.
<code>time</code> must evaluate to a numeric vector that is increasing
within levels of <code>ts</code>.
<code><a href="base.html#topic+Date">Date</a></code>, <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, and <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code>
vectors are supported and coerced to numeric with
<code><a href="base.html#topic+julian">julian</a>(time)</code>.
Finally, <code>x</code> must evaluate to a non-negative numeric vector with
<code>x[i]</code> equal to the number of cases observed over the interval
<code>(time[i-1], time[i]]</code>.
Edge cases like <code>x[1]</code> are ignored internally.
Elements of <code>x</code> that are not integer-valued are rounded with a
warning.<br />
<br />
<code>formula_ts = cbind(time, x) ~ 1</code> can be supplied
when there is only one time series; it is equivalent
to <code>formula_ts = cbind(time, x) ~ ts</code> with <code>ts</code>
evaluating to <code>rep(factor(1), length(x))</code>.</p>
</td></tr>
<tr><td><code id="egf_+3A_formula_windows">formula_windows</code></td>
<td>

<p>a formula of the form <code>cbind(start, end) ~ ts</code>
specifying disjoint fitting windows <code>(start, end]</code> in long format.
If <code>formula_ts = cbind(time, x) ~ ts1</code> and
<code>formula_windows = cbind(start, end) ~ ts2</code>,
then observation <code>x[i]</code> is associated with window
<code>(start[j], end[j]]</code> if and only if <code>time[i-1] &gt;= start[j]</code>,
<code>time[i] &lt;= end[j]</code>, and <code>ts1[i] == ts2[j]</code>.</p>
</td></tr>
<tr><td><code id="egf_+3A_formula_parameters">formula_parameters</code></td>
<td>

<p>a list of formulae of the form <code>parameter ~ terms</code>
specifying mixed effects models for top level
nonlinear model parameters using <span class="pkg">lme4</span>-like syntax
(see, e.g., <code>help("lmer", package = "lme4")</code>).
Alternatively, a formula of the form <code>~terms</code> to be recycled
for all parameters.<br />
<br />
A list of parameters for which formulae may be specified can be
retrieved with <code><a href="#topic+egf_top">egf_top</a></code>.
Specifically, <code>deparse(parameter)</code> must be an element of
<code><a href="#topic+egf_top">egf_top</a>(model)</code>.
The default for parameters not assigned a formula is <code>~1</code>.</p>
</td></tr>
<tr><td><code id="egf_+3A_formula_priors">formula_priors</code></td>
<td>

<p>a list of formulae of the form <code>parameter ~ prior</code>
defining priors on:<br />
(i) top level nonlinear model parameters,<br />
(ii) fixed effect coefficients and random effect covariance parameters
(elements of segments <code>beta</code> and <code>theta</code> of the bottom level
parameter vector), or<br />
(iii) random effect covariance matrices
(elements of a list <code>Sigma</code> containing the matrices).<br />
<br />
<code>prior</code> must be a call to a <a href="#topic+egf_prior">prior function</a>
with arguments specifying suitable hyperparameters.
In case (i),
<code>deparse(parameter)</code> must be an element of
<code><a href="#topic+egf_top">egf_top</a>(model)</code>,
and hyperparameters supplied on the right hand side must have length 1.
In cases (ii) and (iii),
<code>parameter</code> must be <code>beta</code>, <code>theta</code>, or <code>Sigma</code>
or a call to <code>[</code> or <code>[[</code> referring to a subset or element
of <code>beta</code>, <code>theta</code>, or <code>Sigma</code>
(e.g., <code>beta[index]</code>, where <code>index</code> is a valid index vector
for <code>beta</code>),
and hyperparameters are recycled to the length of the indicated
subset.<br />
<br />
Expressions <code>prior</code> and <code>index</code> are evaluated in the
corresponding formula environment.</p>
</td></tr>
<tr><td><code id="egf_+3A_data_ts">data_ts</code>, <code id="egf_+3A_data_windows">data_windows</code></td>
<td>

<p>data frames, lists, or environments to be searched for variables
named in the corresponding <code>formula_*</code> and <code>subset_*</code>
arguments.  (<code>formula_parameters</code> uses <code>data_windows</code>.)
Formula environments are searched for variables not found here.</p>
</td></tr>
<tr><td><code id="egf_+3A_subset_ts">subset_ts</code>, <code id="egf_+3A_subset_windows">subset_windows</code></td>
<td>

<p>expressions to be evaluated in the corresponding <code>data_*</code>
data frames.
The value should be a valid index vector for the rows of the data frame.
Rows that are not indexed are discarded.
Rows that are indexed are filtered further (e.g., time series
with zero associated fitting windows are discarded regardless of
<code>subset_ts</code>).
The default is to preserve all rows for further filtering.</p>
</td></tr>
<tr><td><code id="egf_+3A_select_windows">select_windows</code></td>
<td>

<p>an expression indicating additional variables in <code>data_windows</code>
(if it is a data frame) to be preserved in the returned object for use
by methods.
The default is to preserve nothing.
A dot &lsquo;<span class="samp">&#8288;.&#8288;</span>&rsquo; is to preserve all variables not occurring in
<code>formula_windows</code> or <code>formula_parameters</code>.
Outside of these two special cases, evaluation of <code>select</code>
follows the implementation of <code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="egf_+3A_na_action_ts">na_action_ts</code></td>
<td>

<p>a character string affecting the handling of <code>NA</code> in <code>x</code>
if <code>formula_ts = cbind(time, x) ~ ts</code>.
<code>"fail"</code> is to throw an error.
<code>"pass"</code> is to ignore <code>NA</code> when fitting and replace
<code>NA</code> when predicting.
<code>NA</code> in <code>time</code> and <code>ts</code> are always an error.</p>
</td></tr>
<tr><td><code id="egf_+3A_na_action_windows">na_action_windows</code></td>
<td>

<p>a character string affecting the handling of <code>NA</code> in
<code>formula_windows</code> and <code>formula_parameters</code> variables.
<code>"fail"</code> is to throw an error.
<code>"omit"</code> is to discard incomplete rows of data.</p>
</td></tr>
<tr><td><code id="egf_+3A_control">control</code></td>
<td>

<p>an <code><a href="#topic+egf_control">egf_control</a></code> object specifying control parameters.</p>
</td></tr>
<tr><td><code id="egf_+3A_init">init</code></td>
<td>

<p>a named list of numeric vectors with possible elements <code>beta</code>,
<code>theta</code>, and <code>b</code>, specifying values to be used in the first
likelihood evaluation for the so-named segments of the bottom level
parameter vector.  The default value of each segment is a zero vector,
with the exception that <code>"(Intercept)"</code> coefficients in
<code>beta</code> have default values computed from supplied time series.
Use <code>NA</code> to indicate elements that should retain their default
value.</p>
</td></tr>
<tr><td><code id="egf_+3A_map">map</code></td>
<td>

<p>a named list of factors with possible elements <code>beta</code>,
<code>theta</code>, and <code>b</code>, each as long as the so-named segment
of the bottom level parameter.
Elements of a segment <code>&lt;name&gt;</code> indexed by
<code>is.na(map[["&lt;name&gt;"]])</code>
are fixed at their initial values, rather than estimated,
and elements corresponding to a common factor level are constrained
to have a common value during estimation.
<code>map[["&lt;name&gt;"]]</code> can be an index vector for segment
<code>&lt;name&gt;</code>, instead of a factor.
In this case, the indexed elements of that segment are fixed at their
initial values.</p>
</td></tr>
<tr><td><code id="egf_+3A_fit">fit</code></td>
<td>

<p>a logical.  If <code>FALSE</code>, then <code>egf</code> returns early
(<em>before</em> fitting) with a partial model object.
The details of the partial result are subject to change and
therefore sparsely documented, on purpose ...</p>
</td></tr>
<tr><td><code id="egf_+3A_se">se</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then the Hessian matrix of the negative
log marginal likelihood function is computed and inverted to
approximate the joint covariance matrix of segments <code>beta</code> and
<code>theta</code> of the bottom level parameter vector.
Standard errors on the fitted values of all top level nonlinear model
parameters are computed approximately using the delta method.
Computations are preserved in the model object for reuse by methods.</p>
</td></tr>
<tr><td><code id="egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users attempting to set arguments <code>formula_priors</code>, <code>init</code>,
and <code>map</code> should know the structure of the bottom level parameter
vector.  It is described under topic <code><a href="#topic+egf-class">egf-class</a></code>.
</p>
<p>If
</p>
<pre>formula_ts = cbind(time, x) ~ ts1
formula_windows = cbind(start, end) ~ ts2</pre>
<p>then it is expected that <code>time</code>, <code>start</code>, and <code>end</code>
(after coercion to numeric) measure time on the same scale.
To be precise, numeric times should have a common unit of measure
and, at least within time series, represent displacements from a
common reference time.
These conditions will always hold if <code>time</code>, <code>start</code>, and
<code>end</code> all evaluate to <code><a href="base.html#topic+Date">Date</a></code>, <code><a href="base.html#topic+POSIXct">POSIXct</a></code>,
or <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code> vectors.
</p>
<p>When day of week effects are estimated, numeric times are interpreted
as numbers of days since midnight on January 1, 1970, so that time
points can be mapped unambiguously to days of week.
Furthermore, in this case, <code>time</code> (after coercion to numeric) is
required to be integer-valued with one day spacing in all time series.
This means that
</p>
<pre>isTRUE(all.equal(time, round(time))) &amp;&amp;
    all(range(diff(round(time))) == 1)</pre>
<p>must be <code>TRUE</code> in each level of <code>ts1</code>.
These conditions ensure that intervals between successive time points
represent exactly one day of week.
</p>


<h3>Value</h3>

<p>A list inheriting from class <code>egf</code>.
See topic <code><a href="#topic+egf-class">egf-class</a></code> for class documentation.
</p>


<h3>See Also</h3>

<p>The many methods for class <code>egf</code>,
listed by <code><a href="utils.html#topic+methods">methods</a>(class = "egf")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate 'N' incidence time series exhibiting exponential growth
set.seed(180149L)
N &lt;- 10L
f &lt;- function(time, r, c0) {
    lambda &lt;- diff(exp(log(c0) + r * time))
    c(NA, rpois(lambda, lambda))
}
time &lt;- seq.int(0, 40, 1)
r &lt;- rlnorm(N, -3.2, 0.2)
c0 &lt;- rlnorm(N, 6, 0.2)
data_ts &lt;-
    data.frame(country = gl(N, length(time), labels = LETTERS[1:N]),
               time = rep.int(time, N),
               x = unlist(Map(f, time = list(time), r = r, c0 = c0)))
rm(f, time)

## Define fitting windows (here, two per time series)
data_windows &lt;-
    data.frame(country = gl(N, 1L, 2L * N, labels = LETTERS[1:N]),
               wave = gl(2L, 10L),
               start = c(sample(seq.int(0, 5, 1), N, TRUE),
                         sample(seq.int(20, 25, 1), N, TRUE)),
               end = c(sample(seq.int(15, 20, 1), N, TRUE),
                       sample(seq.int(35, 40, 1), N, TRUE)))

## Estimate the generative model
m1 &lt;-
    egf(model = egf_model(curve = "exponential", family = "pois"),
        formula_ts = cbind(time, x) ~ country,
        formula_windows = cbind(start, end) ~ country,
        formula_parameters = ~(1 | country:wave),
        data_ts = data_ts,
        data_windows = data_windows,
        se = TRUE)

## Re-estimate the generative model with:
## * Gaussian prior on beta[1L]
## * LKJ prior on all random effect covariance matrices
##   (here there happens to be just one)
## * initial value of 'theta' set explicitly
## * theta[3L] fixed at initial value
m2 &lt;-
    update(m1,
           formula_priors = list(beta[1L] ~ Normal(mu = -3, sigma = 1),
                                 Sigma ~ LKJ(eta = 2)),
           init = list(theta = c(log(0.5), log(0.5), 0)),
           map = list(theta = 3L))
</code></pre>

<hr>
<h2 id='egf_control'>Define Control Parameters</h2><span id='topic+egf_control'></span>

<h3>Description</h3>

<p>Set parameters controlling the behaviour of <code><a href="#topic+egf">egf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_control(outer_optimizer = egf_optimizer(nlminb),
            inner_optimizer = egf_optimizer(newton),
            trace = FALSE, profile = FALSE, sparse_X = FALSE,
            omp_num_threads = getOption("egf.cores", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_control_+3A_outer_optimizer">outer_optimizer</code>, <code id="egf_control_+3A_inner_optimizer">inner_optimizer</code></td>
<td>

<p><code><a href="#topic+egf_optimizer">egf_optimizer</a></code> objects specifying &ldquo;outer&rdquo; and
&ldquo;inner&rdquo; optimization methods.</p>
</td></tr>
<tr><td><code id="egf_control_+3A_trace">trace</code></td>
<td>

<p>an integer determining the amount of tracing performed;
see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="egf_control_+3A_profile">profile</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then fixed effect coefficients are
profiled out of the likelihood, which may stabilize optimization
for models with many fixed effects.
This &ldquo;feature&rdquo; should be considered experimental,
and in fact it may <em>de</em>stabilize optimization, as it relies
on assumptions about the optimization problem that are not
necessarily satisfied by the nonlinear mixed effects models fit
by <code><a href="#topic+egf">egf</a></code>.</p>
</td></tr>
<tr><td><code id="egf_control_+3A_sparse_x">sparse_X</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then the fixed effects design matrix
is represented as a (sparse) <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>,
rather than as a traditional (dense) matrix.</p>
</td></tr>
<tr><td><code id="egf_control_+3A_omp_num_threads">omp_num_threads</code></td>
<td>

<p>an integer indicating a number of OpenMP threads to be used
when evaluating the objective function, provided that
<span class="pkg">epigrowthfit</span> was compiled with OpenMP support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>trace</code> affects the amount of information printed during
likelihood evaluations:
</p>

<dl>
<dt><code>0</code></dt><dd>
<p>likelihood evaluations are always silent.</p>
</dd>
<dt><code>1</code></dt><dd>
<p>a message is printed whenever a negative log marginal likelihood
term is <code>NaN</code> or exceeds <code>1e+09</code>.</p>
</dd>
<dt><code>2</code></dt><dd>
<p>all negative log marginal likelihood terms are printed.</p>
</dd>
</dl>

<p><code><a href="#topic+egf">egf</a></code> passes <code>silent = trace == 0L</code> to
<code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code>.  A corollary is that nonzero values of
<code>trace</code> have a number of additional side effects:
</p>

<ul>
<li><p> error messages are printed during function and gradient evaluations;
</p>
</li>
<li><p> the maximum absolute gradient element is printed with each gradient
evaluation; and
</p>
</li>
<li><p> trace flags set by <code><a href="TMB.html#topic+config">config</a></code> are turned on.
</p>
</li></ul>



<h3>Value</h3>

<p>A list inheriting from class <code>egf_control</code> containing the
validated arguments.
</p>


<h3>Warning</h3>

<p>Setting <code>trace &gt; 0L</code> and <code>omp_num_threads &gt; 0L</code> simultaneously
should be avoided, because tracing messages are printed using <span class="rlang"><b>R</b></span> API
functions that are not thread-safe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- egf_control()
str(control)
</code></pre>

<hr>
<h2 id='egf_control_plot'>Define Control Parameters for Plotting</h2><span id='topic+egf_control_plot'></span>

<h3>Description</h3>

<p>Sets parameters controlling the graphical output of
<code><a href="#topic+plot.egf">plot</a></code> for objects of class <code><a href="#topic+egf">egf</a></code>.
Supplied values override package defaults
(retrievable as <code>defaults &lt;- egf_control_plot()</code>),
which in turn override global defaults set via <code><a href="graphics.html#topic+par">par</a></code>.<br />
<br />
Below, <code>x</code>, <code>type</code>, <code>time_as</code>, and <code>delta</code>
refer to the so-named arguments of <code>plot.egf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_control_plot(window, data, predict, asymptote, box, axis, title, doubling)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_control_plot_+3A_window">window</code></td>
<td>

<p>a named list of arguments to <code><a href="graphics.html#topic+rect">rect</a></code> affecting
the appearance of fitting windows.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_data">data</code></td>
<td>

<p>a named list of the form <code>list(main, short, long)</code>.
<code>main</code> is a named list of arguments to <code><a href="graphics.html#topic+points">points</a></code>
affecting the appearance of observed data.
<code>short</code> and <code>long</code> are alternatives to <code>main</code> used
for counts over intervals shorter or longer than <code>delta</code> when
<code>type = "interval"</code>.
<code>short</code> and <code>long</code> default to <code>main</code> (elementwise).</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_predict">predict</code></td>
<td>

<p>a named list of the form <code>list(value, ci)</code>.
<code>value</code> and <code>ci</code> are named lists of arguments to
<code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+polygon">polygon</a></code> affecting the
appearance of predicted curves and corresponding confidence bands.
<code>ci[["col"]]</code> defaults to <code>value[["col"]]</code> with added
transparency.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_asymptote">asymptote</code></td>
<td>

<p>a named list of arguments to <code><a href="graphics.html#topic+segments">segments</a></code> affecting
the appearance of line segments drawn at
<code>y = &lt;initial exponential growth rate&gt;</code>
when <code>type = "rt"</code> and
<code>x[["model"]][["curve"]] = "logistic"</code> or <code>"richards"</code>.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_box">box</code></td>
<td>

<p>a named list of arguments to <code><a href="graphics.html#topic+box">box</a></code> affecting
the appearance of the box drawn around the plot region on the device.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_axis">axis</code></td>
<td>

<p>a named list of the form <code>list(x, y)</code>.
<code>x</code> and <code>y</code> are named lists of arguments to <code><a href="graphics.html#topic+axis">axis</a></code>
affecting the appearance of the bottom and left axes.
When <code>time_as = "Date"</code>, there are minor and major bottom axes.
In this case, the major axis uses a modified version of <code>x</code>
that tries to ensure that it is displayed below the minor axis in
a slightly larger font.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_title">title</code></td>
<td>

<p>a named list of the form <code>list(main, sub, xlab, ylab)</code>.
The elements are named lists of arguments to <code><a href="graphics.html#topic+title">title</a></code>
affecting the appearance of plot (sub)titles and axis labels.
<code>sub[["adj"]]</code> defaults to <code>main[["adj"]]</code>.</p>
</td></tr>
<tr><td><code id="egf_control_plot_+3A_doubling">doubling</code></td>
<td>

<p>a named list of the form <code>list(legend, estimate, ci)</code>.
The elements are named lists of arguments to <code><a href="graphics.html#topic+mtext">mtext</a></code>
affecting the appearance of initial doubling times printed in the
top margin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting an argument (or an element thereof in the case of nested lists)
to <code><a href="base.html#topic+NULL">NULL</a></code> has the effect of suppressing the corresponding
plot element.
</p>


<h3>Value</h3>

<p>A named list containing the package defaults modified according to
the arguments in the call.
</p>

<hr>
<h2 id='egf_has_converged'>Test for Convergence</h2><span id='topic+egf_has_converged'></span>

<h3>Description</h3>

<p>Performs simple diagnostic tests to assess whether the optimizer that
produced an estimated model actually converged to a local minimum point
of the negative log marginal likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_has_converged(object, check = TRUE, tol = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_has_converged_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="egf_has_converged_+3A_check">check</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then an error is thrown if <code>object</code>
does not actually inherit from class <code><a href="#topic+egf">egf</a></code>.</p>
</td></tr>
<tr><td><code id="egf_has_converged_+3A_tol">tol</code></td>
<td>

<p>a positive number.  Convergence requires all gradient elements
to be less than or equal to <code>tol</code> in absolute value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all tests pass.  <code>FALSE</code> if any test fails.
<code>NA</code> if no test fails, but the test for a positive definite
Hessian matrix is indeterminate because the matrix has not been
computed.
</p>

<hr>
<h2 id='egf_has_random'>Test for Random Effects</h2><span id='topic+egf_has_random'></span>

<h3>Description</h3>

<p>Tests whether an object specifies a model with random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_has_random(object, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_has_random_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="egf_has_random_+3A_check">check</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then an error is thrown if <code>object</code>
does not actually inherit from class <code><a href="#topic+egf">egf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>

<hr>
<h2 id='egf_model'>Define a Top Level Nonlinear Model</h2><span id='topic+egf_model'></span>

<h3>Description</h3>

<p>Sets flags defining a top level nonlinear model of epidemic growth
to be estimated by <code><a href="#topic+egf">egf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_model(curve = c("logistic", "richards", "exponential",
                    "subexponential", "gompertz"),
          excess = FALSE,
          family = c("nbinom", "pois"),
          day_of_week = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_model_+3A_curve">curve</code></td>
<td>

<p>a character string specifying a model for expected cumulative
incidence as a function of time.</p>
</td></tr>
<tr><td><code id="egf_model_+3A_excess">excess</code></td>
<td>

<p>a logical flag.  If <code>TRUE</code>, then a constant baseline mortality
rate is estimated.</p>
</td></tr>
<tr><td><code id="egf_model_+3A_family">family</code></td>
<td>

<p>a character string specifying a family of discrete probability
distributions assigned to observations, which are
the first order differences of observed cumulative incidence.</p>
</td></tr>
<tr><td><code id="egf_model_+3A_day_of_week">day_of_week</code></td>
<td>

<p>an integer flag.  If positive, then day of week effects are
estimated as offsets relative to the indicated day of week
(1=Sunday, 2=Monday, and so on).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list inheriting from class <code>egf_model</code> containing the
validated arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.egf_model">simulate.egf_model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- egf_model()
str(model)
</code></pre>

<hr>
<h2 id='egf_optimizer'>Define an Optimization Method</h2><span id='topic+egf_optimizer'></span>

<h3>Description</h3>

<p>Utilities for linking an optimizer with optional arguments and
control parameters to define an optimization method for use by
<code><a href="#topic+egf">egf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_optimizer(f = nlminb, args = list(), control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_optimizer_+3A_f">f</code></td>
<td>

<p>a function performing optimization.  Supported are
<code><a href="TMB.html#topic+newton">newton</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="stats.html#topic+nlm">nlm</a></code>, and any <code>optim</code>-like function.</p>
</td></tr>
<tr><td><code id="egf_optimizer_+3A_args">args</code></td>
<td>

<p>a list of optional arguments to <code>f</code> not including
<code>control</code>.  If <code>f = <a href="stats.html#topic+optim">optim</a></code> and <code>args</code> does
not have <code>method</code> as an element, then <code>method = "BFGS"</code>
is appended.</p>
</td></tr>
<tr><td><code id="egf_optimizer_+3A_control">control</code></td>
<td>

<p>a list of control parameters to be passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code><a href="stats.html#topic+optim">optim</a></code>-like function is a function <code>f</code> such that:
</p>
  
<ul>
<li><p> the first three arguments of <code>f</code> specify an initial
parameter vector, an objective function, and a gradient function,
respectively;
</p>
</li>
<li> <p><code>f</code> accepts <code>control</code> as a fourth (or later) argument;
and
</p>
</li>
<li> <p><code>f</code> returns a named list with elements
<code>par</code>, <code>value</code>, <code>convergence</code>, and <code>message</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list inheriting from class <code>egf_optimizer</code> containing the
validated arguments, wherein <code>f</code> may be a new function wrapping
the supplied one to make it <code><a href="stats.html#topic+optim">optim</a></code>-like.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optimizer &lt;- egf_optimizer(nlminb)
str(optimizer)
</code></pre>

<hr>
<h2 id='egf_parallel'>Define a Parallelization Method</h2><span id='topic+egf_parallel'></span>

<h3>Description</h3>

<p>Defines instructions for parallelization by linking a method with options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_parallel(method = c("serial", "multicore", "snow"),
             outfile = "", cores = getOption("egf.cores", 1L),
             args = list(), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_parallel_+3A_method">method</code></td>
<td>

<p>a character string indicating a method of parallelization.
<code>"serial"</code> indicates no parallelization.
<code>"multicore"</code> indicates <span class="rlang"><b>R</b></span> level forking.
It is intended for use from a terminal rather than from a GUI.
<code>"snow"</code> indicates socket clusters.
On Windows, <code>"multicore"</code> is equivalent to <code>"serial"</code>.
<code>"snow"</code> is supported on both Unix-alikes and Windows.</p>
</td></tr>
<tr><td><code id="egf_parallel_+3A_outfile">outfile</code></td>
<td>

<p>a character string indicating a file path where console output
should be diverted.  An empty string indicates no diversion.
If <code>method = "snow"</code>, then diversion may be necessary to
view output.</p>
</td></tr>
<tr><td><code id="egf_parallel_+3A_cores">cores</code></td>
<td>

<p>a positive integer indicating a number of threads/processes to
fork/spawn when <code>parallel != "serial"</code>.
<code><a href="parallel.html#topic+detectCores">detectCores</a></code> can be called to detect the
theoretical maximum.</p>
</td></tr>
<tr><td><code id="egf_parallel_+3A_args">args</code></td>
<td>

<p>a list of optional arguments to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code> (<code>method = "multicore"</code>) or
<code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code> (<code>method = "snow"</code>).</p>
</td></tr>
<tr><td><code id="egf_parallel_+3A_cl">cl</code></td>
<td>

<p>an existing <a href="parallel.html#topic+makePSOCKcluster">socket cluster</a>
(<code>method = "snow"</code>).  The default is to create a new cluster
stop it upon job completion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list inheriting from class <code>"egf_parallel"</code>
containing the arguments (after possible matching and coercion).
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+vignette">vignette</a>("parallel", "parallel")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parallel &lt;- egf_parallel()
str(parallel)
</code></pre>

<hr>
<h2 id='egf_prior'>Prior Distributions</h2><span id='topic+egf_prior'></span><span id='topic+Normal'></span><span id='topic+LKJ'></span><span id='topic+Wishart'></span><span id='topic+InverseWishart'></span>

<h3>Description</h3>

<p>Functions used by <code><a href="#topic+egf">egf</a></code> to specify prior distributions
of bottom level mixed effects model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normal(mu = 0, sigma = 1)
LKJ(eta = 1)
Wishart(df, scale, tol = 1e-06)
InverseWishart(df, scale, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_prior_+3A_mu">mu</code></td>
<td>

<p>a numeric vector listing means.</p>
</td></tr>
<tr><td><code id="egf_prior_+3A_sigma">sigma</code></td>
<td>

<p>a positive numeric vector listing standard deviations.</p>
</td></tr>
<tr><td><code id="egf_prior_+3A_eta">eta</code></td>
<td>

<p>a positive numeric vector listing values for the shape parameter,
with 1 corresponding to a uniform distribution over the space of
real, symmetric, positive definite matrices with unit diagonal
elements.  Lesser (greater) values concentrate the probability
density around such matrices whose determinant is nearer to 0 (1).</p>
</td></tr>
<tr><td><code id="egf_prior_+3A_df">df</code></td>
<td>

<p>a numeric vector listing degrees of freedom.  <code>df</code> must
be greater than <code>nrow(scale) - 1</code>.  If either <code>df</code> or
<code>scale</code> has length greater than 1, then this condition is
checked elementwise after recycling.</p>
</td></tr>
<tr><td><code id="egf_prior_+3A_scale">scale</code></td>
<td>

<p>a list of real, symmetric, positive definite matrices
or a matrix to be placed in a list of length 1.</p>
</td></tr>
<tr><td><code id="egf_prior_+3A_tol">tol</code></td>
<td>

<p>a non-negative number specifying a tolerance for indefiniteness
of <code>scale</code>.  All eigenvalues of <code>scale</code> must exceed
<code>-tol * rho</code>, where <code>rho</code> is the spectral radius of
<code>scale</code>.  However, regardless of <code>tol</code>,
<code>diag(scale)</code> must be positive, as standard deviations are
stored on a logarithmic scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list inheriting from class <code>egf_prior</code>, with elements:
</p>
<table>
<tr><td><code>family</code></td>
<td>

<p>a character string specifying a family of distributions.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>

<p>a named list of numeric vectors specifying parameter values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Normal(mu = 0, sigma = 1)
Normal(mu = -5:5, sigma = c(0.1, 1))

LKJ(eta = 2)

u &lt;- matrix(rnorm(9L), 3L, 3L)
utu &lt;- crossprod(u)
uut &lt;- tcrossprod(u)
Wishart(df = 6, scale = utu)
InverseWishart(df = 6, scale = list(utu, uut))
</code></pre>

<hr>
<h2 id='egf_top'>Top Level Nonlinear Model Parameter Names</h2><span id='topic+egf_top'></span><span id='topic+egf_top.egf'></span><span id='topic+egf_top.egf_no_fit'></span><span id='topic+egf_top.egf_model'></span>

<h3>Description</h3>

<p>Retrieves the names used internally for top level nonlinear model
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egf_top(object, ...)

## S3 method for class 'egf_model'
egf_top(object, link = TRUE, ...)
## S3 method for class 'egf'
egf_top(object, link = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egf_top_+3A_object">object</code></td>
<td>

<p>an <span class="rlang"><b>R</b></span> object specifying a top level nonlinear model,
typically of class <code><a href="#topic+egf_model">egf_model</a></code> or <code><a href="#topic+egf">egf</a></code>.</p>
</td></tr>
<tr><td><code id="egf_top_+3A_link">link</code></td>
<td>

<p>a logical flag.  If <code>TRUE</code>, then <code>"&lt;link&gt;(&lt;name&gt;)"</code>
is returned instead of <code>"&lt;name&gt;"</code>.</p>
</td></tr>
<tr><td><code id="egf_top_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector listing names relevant to <code>object</code>.
</p>

<hr>
<h2 id='egf-class'>Description of Objects of Class <code>egf</code></h2><span id='topic+egf-class'></span>

<h3>Description</h3>

<p>Class <code>egf</code> designates models estimated by function <code><a href="#topic+egf">egf</a></code>.
Objects of this class hold information about an estimated model.
Components can be accessed directly.  However, as the components
are subject to change without notice, portable code will rely on
exported methods for interrogation.
</p>


<h3>Details</h3>

<p>Currently, a legitimate <code>egf</code> object is a list with elements:
</p>

<dl>
<dt><code>model</code></dt><dd>
<p>a copy of the so-named argument of <code><a href="#topic+egf">egf</a></code>.</p>
</dd>
<dt><code>frame</code></dt><dd>
<p>a list of the form <code>list(ts, windows, parameters, extra)</code>.
<code>ts</code> and <code>windows</code> are data frames preserving time series
and fitting window endpoints.
<code>parameters</code> is a list of mixed effects model frames,
with one element for each top level nonlinear model parameter.
<code>extra</code> is a data frame preserving additional variables
specified in <code>call[["select_windows"]]</code>.
<code>windows</code>, the model frames listed in <code>parameters</code>,
and <code>extra</code> all correspond rowwise.</p>
</dd>
<dt><code>priors</code></dt><dd>
<p>a list of the form <code>list(top, bottom = list(beta, theta, Sigma))</code>,
where <code>top</code>, <code>beta</code>, <code>theta</code>, and <code>Sigma</code> are all
lists of <code><a href="#topic+egf_prior">egf_prior</a></code> objects.</p>
</dd>
<dt><code>control</code></dt><dd>
<p>a copy of the so-named argument of <code><a href="#topic+egf">egf</a></code>.</p>
</dd>
<dt><code>tmb_out</code></dt><dd>
<p>the list output of <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code>.</p>
</dd>
<dt><code>optimizer_out</code></dt><dd>
<p>the list output of the optimizer specified by <code>control[["optimizer"]]</code>.</p>
</dd>
<dt><code>init, best</code></dt><dd>
<p>numeric vectors giving the values of the condensed bottom level
parameter vector used in the first and maximal likelihood evaluations.</p>
</dd>
<dt><code>random</code></dt><dd>
<p>a logical vector indexing the elements of the condensed bottom level
parameter vector that are <em>not</em> arguments of the negative log
marginal likelihood function.  It indexes
all elements of segment <code>b</code> (random effect coefficients) and
(but only if <code>control[["profile"]] = TRUE</code>)
all elements of segment <code>beta</code> (fixed effect coefficients).</p>
</dd>
<dt><code>value, gradient</code></dt><dd>
<p>numeric vectors giving the value and gradient of the negative log
marginal likelihood function at <code>best[!random]</code>.</p>
</dd>
<dt><code>hessian</code></dt><dd>
<p>a logical flag indicating whether the Hessian matrix of the negative log
marginal likelihood function is positive definite at <code>best[!random]</code>.
<code>NA</code> means that the matrix has not been computed.</p>
</dd>
<dt><code>coefficients</code></dt><dd>
<p>a list of the form <code>list(fixed, random)</code>, where <code>fixed</code>
and <code>random</code> are data frames preserving interpretive information
about fixed and random effect coefficients.</p>
</dd>
<dt><code>contrasts</code></dt><dd>
<p>a list of the form <code>list(fixed, random)</code>, where <code>fixed</code>
and <code>random</code> are lists preserving contrasts used to construct
the fixed and random effects design matrices.</p>
</dd>
<dt><code>call</code></dt><dd>
<p>the call to <code><a href="#topic+egf">egf</a></code>, enabling updates to the object by
the default method of generic function <code><a href="stats.html#topic+update">update</a></code>.</p>
</dd>
</dl>



<h3>Bottom Level Parameter Vector</h3>

<p>An estimated model is specified by a bottom level parameter vector
that is the concatenation of three segments:
</p>

<dl>
<dt><code>beta</code></dt><dd>
<p>the result of <code>unlist(lbeta)</code>, where <code>lbeta</code> is a list
of numeric vectors of fixed effect coefficients,
with one vector for each top level nonlinear model parameter.
The order of top level parameters is specified by
<code><a href="#topic+egf_top">egf_top</a>(model)</code>.</p>
</dd>
<dt><code>theta</code></dt><dd>
<p>the result of <code>unlist(ltheta)</code>, where <code>ltheta</code> is a list
of numeric vectors of random effect covariance parameters,
with one vector for each distinct random effect term in
<code>formula_parameters</code>.
Each vector parametrizes a random effect covariance matrix via
<code><a href="#topic+theta2cov">theta2cov</a></code> and its inverse <code><a href="#topic+cov2theta">cov2theta</a></code>.<br />
<br />
The list <code>Sigma</code> mentioned in the description of <code><a href="#topic+egf">egf</a></code>
argument <code>formula_priors</code> is precisely
<code><a href="base.html#topic+lapply">lapply</a>(ltheta, <a href="#topic+theta2cov">theta2cov</a>)</code>.</p>
</dd>
<dt><code>b</code></dt><dd>
<p>the result of <code>unlist(lb)</code>, where <code>lb</code> is a list
of numeric matrices of scaled random effect coefficients,
corresponding elementwise to <code>ltheta</code>.
The columns of <code>lb[[i]]</code> (one per level of the grouping variable)
are interpreted as samples from a zero mean, unit variance multivariate
normal distribution with covariance matrix
<code><a href="stats.html#topic+cov2cor">cov2cor</a>(<a href="#topic+theta2cov">theta2cov</a>(ltheta[[i]]))</code>.</p>
</dd>
</dl>

<p>When elements of this vector are &ldquo;mapped&rdquo; via <code><a href="#topic+egf">egf</a></code>
argument <code>map</code>, likelihood is defined as a function of the condensed
vector that excludes mapped elements.
</p>
<p>Methods are defined for generic functions
<code><a href="#topic+coef.egf">coef</a></code>,
<code><a href="#topic+fixef.egf">fixef</a></code>, and
<code><a href="#topic+ranef.egf">ranef</a></code>
to allow users to interrogate the structure of the vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>methods(class = "egf")
help.search("\\.egf$", fields = "alias", package = "epigrowthfit")
## less verbosely: alias??`\\.egf$`
</code></pre>

<hr>
<h2 id='epigrowthfit-defunct'>Defunct Functions in Package <span class="pkg">epigrowthfit</span></h2><span id='topic+epigrowthfit-defunct'></span>

<h3>Description</h3>

<p>The functions and other objects listed here are no longer part
of <span class="pkg">epigrowthfit</span> as they are no longer needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>Details</h3>

<p>These either are stubs reporting that they are defunct or
have been removed completely (apart from being documented here).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>, <code><a href="base.html#topic+base-deprecated">base-deprecated</a></code>,
<code><a href="#topic+epigrowthfit-deprecated">epigrowthfit-deprecated</a></code>, <code><a href="#topic+epigrowthfit-notyet">epigrowthfit-notyet</a></code>.
</p>

<hr>
<h2 id='epigrowthfit-deprecated'>Deprecated Functions in Package <span class="pkg">epigrowthfit</span></h2><span id='topic+epigrowthfit-deprecated'></span>

<h3>Description</h3>

<p>The functions and other objects listed here are provided only
for compatibility with older versions of <span class="pkg">epigrowthfit</span> and
may become defunct as soon as the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Defunct">Defunct</a></code>, <code><a href="base.html#topic+base-defunct">base-defunct</a></code>,
<code><a href="#topic+epigrowthfit-defunct">epigrowthfit-defunct</a></code>, <code><a href="#topic+epigrowthfit-notyet">epigrowthfit-notyet</a></code>.
</p>

<hr>
<h2 id='epigrowthfit-notyet'>Not Yet Implemented Functions in Package <span class="pkg">epigrowthfit</span></h2><span id='topic+epigrowthfit-notyet'></span>

<h3>Description</h3>

<p>The functions listed here are defined but not yet implemented.
Use <code><a href="utils.html#topic+bug.report">bug.report</a>(package = "epigrowthfit")</code> to request
an implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Nothing yet!
</code></pre>


<h3>See Also</h3>

<p><code><a href="base.html#topic+NotYetImplemented">NotYetImplemented</a></code>,
<code><a href="#topic+epigrowthfit-deprecated">epigrowthfit-deprecated</a></code>, <code><a href="#topic+epigrowthfit-defunct">epigrowthfit-defunct</a></code>.
</p>

<hr>
<h2 id='extractAIC.egf'>Extract the (Generalized) AIC</h2><span id='topic+extractAIC.egf'></span>

<h3>Description</h3>

<p>Extracts from a model object the generalized Akaike Information Criterion
(AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
extractAIC(fit, scale, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAIC.egf_+3A_fit">fit</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="extractAIC.egf_+3A_scale">scale</code></td>
<td>

<p>unused argument, for generic consistency.</p>
</td></tr>
<tr><td><code id="extractAIC.egf_+3A_k">k</code></td>
<td>

<p>a number giving a weight for the equivalent degrees of freedom.
<code>k=2</code> and <code>k=log(nobs(fit))</code> give the standard
Akaike Information Criterion and Bayesian Information Criterion.</p>
</td></tr>
<tr><td><code id="extractAIC.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An numeric vector of length 2 giving the equivalent degrees of freedom
and criterion value.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>.
</p>

<hr>
<h2 id='finalsize'>Compute the Expected Epidemic Final Size</h2><span id='topic+finalsize'></span>

<h3>Description</h3>

<p>Computes the proportion of a population expected to be infected over
the course of an epidemic, as a function of the basic reproduction number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalsize(R0, S0, I0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalsize_+3A_r0">R0</code></td>
<td>

<p>a numeric vector listing non-negative values for the basic reproduction
number.</p>
</td></tr>
<tr><td><code id="finalsize_+3A_s0">S0</code>, <code id="finalsize_+3A_i0">I0</code></td>
<td>

<p>numeric vectors listing values in the interval <code class="reqn">[0,1]</code> for the
proportions of the population that are susceptible and infected,
respectively, at the start of the epidemic.  Hence <code>S0 + I0</code>
must be less than or equal to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>S0</code> and <code>I0</code> must be supplied.
If <code>S0</code> (<code>I0</code>) is supplied but not <code>I0</code> (<code>S0</code>),
then the latter is assigned the value of one minus the former.
</p>
<p><code>R0</code>, <code>S0</code>, and <code>I0</code> are recycled to a common length
(the maximum of their lengths).
</p>


<h3>Value</h3>

<p>A numeric vector listing values in the interval <code class="reqn">[0,1]</code> for the
expected epidemic final size.
</p>


<h3>Computation</h3>

<p>The basic reproduction number <code>R0</code> defines the expected
epidemic final size <code>Z</code> through an implicit equation,
</p>
<pre>Z = S0 * (1 - exp(-R0 * (Z + I0))) ,</pre>
<p>which admits an explicit solution
</p>
<pre>Z = S0 + (1/R0) * W(-R0 * S0 * exp(-R0 * (S0 + I0))) .</pre>
<p>Here, <code>W</code> denotes the
<a href="https://en.wikipedia.org/wiki/Lambert_W_function">
Lambert <code class="reqn">W</code> function</a>.
<code>finalsize</code> computes this solution, relying on function
<code>lambertW</code> from package <span class="pkg">emdbook</span>.
</p>


<h3>References</h3>

<p>Ma, J. &amp; Earn, D. J. D. (2006).
Generality of the final size formula for an epidemic of a newly invading
infectious disease.
<em>Bulletin of Mathetmatical Biology</em>,
<em>68</em>(3), 679-702.
<a href="https://doi.org/10.1007/s11538-005-9047-7">doi:10.1007/s11538-005-9047-7</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timescale">timescale</a></code>, <code><a href="#topic+R0">R0</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R0 &lt;- 10^seq(-3, 1, length.out = 151L)
plot(R0, finalsize(R0, S0 = 1, I0 = 0), type = "l", las = 1,
     xlab = "basic reproduction number",
     ylab = "final size")
</code></pre>

<hr>
<h2 id='fitted.egf'>Fitted Values</h2><span id='topic+fitted.egf'></span><span id='topic+fitted.egf_no_fit'></span><span id='topic+confint.fitted.egf'></span>

<h3>Description</h3>

<p>Retrieves fitted values of top level nonlinear model parameters.
The fitted value of a given parameter for a given fitting window
is obtained by adding
(i) the population fitted value computed as a linear combination
of fixed effect coefficients and
(ii) all applicable random effects, with random effects set equal
to their conditional modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
fitted(object,
       top = egf_top(object), subset = NULL, select = NULL,
       class = FALSE, se = FALSE, ...)

## S3 method for class 'fitted.egf'
confint(object, parm = seq_len(nrow(object)), level = 0.95,
        class = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> or <code>fitted.egf</code> object.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_top">top</code></td>
<td>

<p>a subset of <code><a href="#topic+egf_top">egf_top</a>(object)</code> naming top level
nonlinear model parameters whose fitted values should be
retrieved.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_subset">subset</code>, <code id="fitted.egf_+3A_select">select</code></td>
<td>

<p>index vectors for the rows and columns of
<code>model.frame(object, "combined")</code> or language objects
evaluating to such vectors.
<code>subset</code> indicates fitting windows for which fitted values
should be retrieved; the default indicates all.
<code>select</code> indicates variables that should be appended to
the result; the default indicates none.
Evaluation of language objects follows the implementation of
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_class">class</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then the value of the method call
is a <code>fitted.egf</code> or <code><a href="#topic+confint.egf">confint.egf</a></code> object,
not a matrix.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_se">se</code></td>
<td>

<p>a logical.  If <code>TRUE</code> and if <code>class = TRUE</code>,
then the result is augmented with approximate delta method
standard errors.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_parm">parm</code></td>
<td>

<p>a valid index vector for the rows of <code>object</code> indicating a subset
of the fitted values.</p>
</td></tr>
<tr><td><code id="fitted.egf_+3A_level">level</code></td>
<td>

<p>a number in the interval <code class="reqn">(0,1)</code> indicating a confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing fitted values.
</p>
<p>Users can pass <code>class = TRUE</code> to obtain an augmented result.
Thus, alternatively:
</p>
<p>A data frame inheriting from class <code>fitted.egf</code>, with variables:
</p>
<table>
<tr><td><code>top</code></td>
<td>

<p>top level nonlinear model parameter, from
<code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code>ts</code></td>
<td>

<p>time series, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["ts"]])</code>.</p>
</td></tr>
<tr><td><code>window</code></td>
<td>

<p>fitting window, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["window"]])</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>fitted value.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>

<p>approximate delta method standard error (only if requested).</p>
</td></tr>
<tr><td><code>...</code></td>
<td>

<p>further variables from
<a href="#topic+model.frame.egf">model.frame</a>(object, &quot;combined&quot;)
specified by argument <code>select</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+fitted">fitted</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("egf", package = "epigrowthfit")

zz &lt;- fitted(m1, class = TRUE, se = TRUE)
str(zz)

confint(zz, class = TRUE)

</code></pre>

<hr>
<h2 id='fixef.egf'>Details about Fixed Effect Coefficients</h2><span id='topic+fixef.egf'></span><span id='topic+fixef'></span><span id='topic+fixef.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object details about the fixed effect
coefficients, namely segment <code>beta</code> of the bottom level
parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="fixef.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per coefficient and variables:
</p>
<table>
<tr><td><code>bottom</code></td>
<td>

<p>label for a bottom level mixed effects model parameter,
in this case for a fixed effect coefficient.
This is a string with format <code>"beta[%d]"</code>.</p>
</td></tr>
<tr><td><code>top</code></td>
<td>

<p>name of the top level nonlinear model parameter whose
fitted value is a function of <code>bottom</code>,
from <code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>

<p>term from the fixed effects component of the mixed effects
model formula for parameter <code>top</code>.</p>
</td></tr>
<tr><td><code>colname</code></td>
<td>

<p>column name in the fixed effects design matrix
<code><a href="#topic+model.matrix.egf">model.matrix</a>(object, "fixed")</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>coefficient estimate, from segment <code>beta</code> of
<code><a href="#topic+coef.egf">coef</a>(object, full = TRUE)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The generic function <code><a href="nlme.html#topic+fixef">fixef</a></code>.
</p>

<hr>
<h2 id='formula.egf'>Extract Model Formulae</h2><span id='topic+formula.egf'></span><span id='topic+formula.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object the mixed effects model formula
corresponding to a top level nonlinear model parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
formula(x, top = egf_top(x), split = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.egf_+3A_x">x</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="formula.egf_+3A_top">top</code></td>
<td>

<p>a character string specifying a top level nonlinear model parameter.</p>
</td></tr>
<tr><td><code id="formula.egf_+3A_split">split</code></td>
<td>

<p>a logical flag.  If <code>TRUE</code>, then random effect terms are deleted
from the formula and preserved as an attribute.</p>
</td></tr>
<tr><td><code id="formula.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, the mixed effects model formula corresponding to
<code>top</code>.  If <code>split = TRUE</code>, then the same formula
without random effect terms.  The deleted terms are stored in
an expression vector and preserved as attribute <code>random</code>
of the result.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+formula">formula</a></code>.
</p>

<hr>
<h2 id='getCall.egf'>Extract Model Calls</h2><span id='topic+getCall.egf'></span><span id='topic+getCall.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object the call to <code><a href="#topic+egf">egf</a></code> that produced it.
This method exists mainly to enable compatibility with the default method of
generic function <code><a href="stats.html#topic+update">update</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
getCall(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCall.egf_+3A_x">x</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="getCall.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call to <code><a href="#topic+egf">egf</a></code>.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+getCall">getCall</a></code>.
</p>

<hr>
<h2 id='gi'>Generation Interval Distribution</h2><span id='topic+gi'></span><span id='topic+dgi'></span><span id='topic+pgi'></span><span id='topic+qgi'></span><span id='topic+rgi'></span>

<h3>Description</h3>

<p>Generation interval
density function (<code>dgi</code>), distribution function (<code>pgi</code>),
quantile function (<code>qgi</code>), and sampling (<code>rgi</code>).
Results are conditional on supplied latent and infectious period
distributions.  It is assumed
</p>

<ul>
<li><p> that the latent period and infectious waiting time are independent,
</p>
</li>
<li><p> that infectiousness is constant over the infectious period, and
</p>
</li>
<li><p> that the latent and infectious periods are positive and integer-valued
(in arbitrary but common units of time).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dgi(x, latent, infectious)
pgi(q, latent, infectious)
qgi(p, latent, infectious)
rgi(n, latent, infectious)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gi_+3A_x">x</code>, <code id="gi_+3A_q">q</code></td>
<td>

<p>a numeric vector listing generation intervals.</p>
</td></tr>
<tr><td><code id="gi_+3A_p">p</code></td>
<td>

<p>a numeric vector listing probabilities.</p>
</td></tr>
<tr><td><code id="gi_+3A_n">n</code></td>
<td>

<p>a non-negative integer indicating a sample size.
If <code>length(n) &gt; 1</code>, then <code>length(n)</code> is taken to be the
sample size.</p>
</td></tr>
<tr><td><code id="gi_+3A_latent">latent</code>, <code id="gi_+3A_infectious">infectious</code></td>
<td>

<p>numeric vectors such that <code>latent[i]</code> and <code>infectious[i]</code>
are the probabilities that the latent and infectious periods,
respectively, are <code>i</code> units of time.
It is sufficient to supply probability weights, as internally
both vectors are divided by their sums.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with length equal to the that of the first argument
or length <code>n</code> in the case of <code>rgi</code>.
</p>


<h3>References</h3>

<p>Svensson, Å.  (2007).
A note on generation times in epidemic models.
<em>Mathematical Biosciences</em>,
<em>208</em>(1), 300-311.
<a href="https://doi.org/10.1016/j.mbs.2006.10.010">doi:10.1016/j.mbs.2006.10.010</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>latent &lt;- c(0.026, 0.104, 0.182, 0.246, 0.318, 0.104,
            0.013, 0.004, 0.003)
m &lt;- length(latent)

infectious &lt;- c(0.138, 0.462, 0.256, 0.078, 0.041, 0.007,
                0.004, 0.004, 0.006, 0.004)
n &lt;- length(infectious)

## Histogram of samples
y &lt;- rgi(1e06, latent, infectious)
hist(y, breaks = seq(0, m + n + 1), freq = FALSE, las = 1,
     ylab = "relative frequency",
     main = "")

## Density and distribution functions
x &lt;- seq(0, m + n + 1, by = 0.02)
fx &lt;- dgi(x, latent, infectious)
Fx &lt;- pgi(x, latent, infectious)
plot(x, fx, type = "l", las = 1, # consistent with histogram
     xlab = "generation interval",
     ylab = "density function")
plot(x, Fx, type = "l", las = 1,
     xlab = "generation interval",
     ylab = "distribution function")

## Quantile function
p &lt;- seq(0, 1, by = 0.001)
qp &lt;- qgi(p, latent, infectious)
plot(p, qp, type = "l", las = 1,
     xlab = "probability",
     ylab = "quantile function")
</code></pre>

<hr>
<h2 id='logLik.egf'>Extract the Log (Marginal) Likelihood</h2><span id='topic+logLik.egf'></span>

<h3>Description</h3>

<p>Extracts from a model object the value of the log marginal likelihood.
Whether the result represents a local maximum depends on, among other
things, convergence of the optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="logLik.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1 inheriting from class <code>logLik</code>.
Attribute <code>df</code> is the number of estimated parameters
(fixed effect coefficients and random effect covariance parameters).
Attribute <code>nobs</code> is the number of observations of disease
incidence used in estimation.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>

<hr>
<h2 id='model.frame.egf'>Extract Model Frames</h2><span id='topic+model.frame.egf'></span><span id='topic+model.frame.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object any of several data frames used to specify
the model, including the mixed effects model frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
model.frame(formula,
            which = c("ts", "windows", "parameters", "extra", "combined"),
            top = egf_top(formula), full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.egf_+3A_formula">formula</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="model.frame.egf_+3A_which">which</code></td>
<td>

<p>a character string controlling what is returned:
</p>

<dl>
<dt><code>"ts"</code></dt><dd>
<p>disease incidence time series.</p>
</dd>
<dt><code>"windows"</code></dt><dd>
<p>fitting window endpoints.</p>
</dd>
<dt><code>"parameters"</code></dt><dd>
<p>the mixed effects model frame corresponding to <code>top</code>.</p>
</dd>
<dt><code>"extra"</code></dt><dd>
<p>variables preserved in <code>formula</code> due to setting of
<code><a href="#topic+egf">egf</a></code> argument <code>select_windows</code>.</p>
</dd>
<dt><code>"combined"</code></dt><dd>
<p>the result of concatenating (in the sense of <code>cbind</code>)
all mixed effects model frames and the data frame corresponding
to <code>"extra"</code>, then deleting any duplicated variables.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="model.frame.egf_+3A_top">top</code></td>
<td>

<p>a character string specifying a top level nonlinear model parameter,
for <code>which = "parameters"</code>.</p>
</td></tr>
<tr><td><code id="model.frame.egf_+3A_full">full</code></td>
<td>

<p>a logical, for <code>which = "ts"</code>.  If <code>TRUE</code>, then complete
time series are returned.  Otherwise, only observations belonging
to fitting windows are returned.</p>
</td></tr>
<tr><td><code id="model.frame.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+model.frame">model.frame</a></code>.
</p>

<hr>
<h2 id='model.matrix.egf'>Extract Design Matrices</h2><span id='topic+model.matrix.egf'></span><span id='topic+model.matrix.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object fixed and random effects design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
model.matrix(object, which = c("fixed", "random"),
             top = NULL, random = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="model.matrix.egf_+3A_which">which</code></td>
<td>

<p>a character string controlling what is returned:
</p>

<dl>
<dt><code>"fixed"</code></dt><dd>
<p>the fixed effects design matrix <code>X</code> corresponding to <code>top</code>.</p>
</dd>
<dt><code>"random"</code></dt><dd>
<p>the random effects design matrix <code>Z</code> corresponding to <code>top</code>
and <code>random</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="model.matrix.egf_+3A_top">top</code></td>
<td>

<p>a character string specifying a top level nonlinear model parameter.
<code>NULL</code> indicates &ldquo;all of them&rdquo;; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="model.matrix.egf_+3A_random">random</code></td>
<td>

<p>a random effect term, which is a call to binary operator <code>|</code>.
<code>NULL</code> indicates &ldquo;all of them&rdquo;; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="model.matrix.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model.matrix(which = "fixed", top = NULL)</code>
returns the result of combining (in the sense of <code>cbind</code>)
all fixed effects design matrices.
</p>
<p><code>model.matrix(which = "random", top = "&lt;name&gt;", random = NULL)</code>
returns the result of combining all random effects design matrices
associated with parameter <code>top</code>.
</p>
<p><code>model.matrix(which = "random", top = NULL, random = NULL)</code>
returns the result of combining all random effects design matrices
<em>and</em> permuting the columns to obtain a convenient ordering of
random effect coefficients.
(Coefficients are sorted by relation to a common random vector.
Random vectors are sorted by relation to a common covariance matrix.)
</p>
<p>None of these &ldquo;combined&rdquo; design matrices possesses attributes
<code>assign</code> and <code>contrasts</code>.
</p>


<h3>Value</h3>

<p>A (sparse) <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a> or a traditional
(dense) matrix, with attributes <code>assign</code> and <code>contrasts</code>
except in special cases; see &lsquo;Details&rsquo;.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>

<hr>
<h2 id='nobs.egf'>Extract the Number of Observations</h2><span id='topic+nobs.egf'></span><span id='topic+nobs.egf_no_fit'></span>

<h3>Description</h3>

<p>Returns the number of observations of disease incidence that were
used in estimation of a model.  This number excludes missing values
and observations not belonging to a fitting window, which,
despite being preserved in model objects, do not affect estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="nobs.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+nobs">nobs</a></code>.
</p>

<hr>
<h2 id='plot.egf'>Plot Nonlinear Mixed Effects Models of Epidemic Growth</h2><span id='topic+plot.egf'></span>

<h3>Description</h3>

<p>A method for printing objects of class <code><a href="#topic+egf">egf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
plot(x, type = c("interval", "cumulative", "rt"),
     time_as = c("Date", "numeric"), delta = 1, log = TRUE, zero = NA,
     show_predict = TRUE, show_doubling = FALSE, level = 0.95,
     control = egf_control_plot(), cache = NULL, plot = TRUE,
     subset = NULL, order = NULL, xlim = NULL, ylim = NULL,
     main = NULL, sub = NULL, xlab = NULL, ylab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.egf_+3A_x">x</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_type">type</code></td>
<td>

<p>a character string indicating a type of plot.  The options are:
interval incidence (<code>"interval"</code>),
cumulative incidence (<code>"cumulative"</code>), and
per capita growth rate (<code>"rt"</code>).</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_time_as">time_as</code></td>
<td>

<p>a character string indicating how numeric times are displayed
on the bottom axis.  The options are:
as is (<code>"numeric"</code>) and
with a calendar (<code>"Date"</code>).
In the latter case, horizontal user coordinates on measure time
in days since midnight on January 1, 1970.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_delta">delta</code></td>
<td>

<p>a positive number indicating a step size on the time axis.
Predicted curves are evaluated on a grid with this spacing.
When <code>type = "interval"</code>, counts observed over shorter
or longer intervals <code>delta0</code> are scaled by a factor
of <code>delta/delta0</code> so that their scale matches that of
predicted incidence.  Scaled counts can be highlighted via
<code>control</code>.  If <code>x</code> specifies a model with day of
week effects, then <code>delta = 1</code> is used unconditionally.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_log">log</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then the dependent variable is plotted
on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_zero">zero</code></td>
<td>

<p>a positive number indicating a line on which to plot zeros when
<code>log = TRUE</code> and <code>type = "interval"</code> or <code>"cumulative"</code>.
<code>NA</code> is to place zeros on the bottom axis.
<code>NULL</code> is to suppress zeros.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_show_predict">show_predict</code></td>
<td>

<p>an integer flag:
2 is to draw predicted curves with confidence bands,
1 is draw predicted curves only,
0 is to draw neither.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_show_doubling">show_doubling</code></td>
<td>
<p>an integer flag:
2 is to print initial doubling time estimates in the top margin
with confidence intervals,
1 is to print estimates only,
0 is to print neither.
Nothing is printed for models without a well-defined initial
exponential growth rate.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_level">level</code></td>
<td>

<p>a number in the interval <code class="reqn">(0,1)</code> indicating confidence level,
used when <code>show_predict = 2</code> or <code>show_doubling = 2</code>.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_control">control</code></td>
<td>

<p>an <code><a href="#topic+egf_control_plot">egf_control_plot</a></code> object controlling the
appearance of most plot elements.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_cache">cache</code></td>
<td>

<p>a <code>plot.egf</code> object returned by a previous evaluation of
<code>plot(x, ...)</code>.  Fitted and predicted values and standard
errors stored in <code>cache</code> are reused to avoid recomputation.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_plot">plot</code></td>
<td>

<p>a logical.  If <code>FALSE</code>, then plotting does not occur.
Useful when only the returned <code>plot.egf</code> object is desired.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_subset">subset</code></td>
<td>

<p>an index vector for the rows of
<code>mf = model.frame(object, "combined")</code> or a language object
evaluating to such a vector.
Only time series corresponding to indexed rows are plotted and
only fitting windows corresponding to indexed rows are highlighted;
the default is to plot all series and to highlight all windows.
Evaluation of language objects follows the implementation of
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_order">order</code></td>
<td>

<p>a permutation of <code>seq_len(nrow(mf))</code> or a language object
evaluating in <code>mf</code> to such a vector.
<code>order</code> indicates the order in which time series are plotted;
the default indicates the original order.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_xlim">xlim</code>, <code id="plot.egf_+3A_ylim">ylim</code></td>
<td>

<p>numeric vectors of length 2 specifying axis limits, which are
recycled for all plots.
If <code>time_as = "Date"</code>, then <code>xlim</code> can instead be a
<code><a href="base.html#topic+Date">Date</a></code>, <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, or <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code>
vector.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_main">main</code>, <code id="plot.egf_+3A_sub">sub</code>, <code id="plot.egf_+3A_xlab">xlab</code>, <code id="plot.egf_+3A_ylab">ylab</code></td>
<td>

<p>character or expression vectors or (<code>main</code>, <code>sub</code>)
language objects evaluating in <code>mf</code> to such vectors.
These are used to generate plot (<code>main</code>, <code>sub</code>) and
axis (<code>xlab</code>, <code>ylab</code>) labels.</p>
</td></tr>
<tr><td><code id="plot.egf_+3A_...">...</code></td>
<td>
<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of fitted and predicted values and standard errors is
performed before any plots are created.  To avoid waste of computation
time, cached computations are returned <em>even if</em> an error
is thrown during plotting.  To ensure that the cache is preserved,
assign the result of the function call to a name:
</p>
<pre>cache &lt;- plot(x, \dots)</pre><p>.
Caching functionality must be used with care, as mismatch between
<code>x</code> and <code>cache</code> will not be detected.  Constructions such
as <code>plot(y, cache = plot(x, ...), ...)</code>, where <code>x</code>
and <code>y</code> are different <code>egf</code> objects, should not be expected
to produce correct results.
</p>


<h3>Value</h3>

<p>A data frame inheriting from class <code>plot.egf</code>.
</p>
<p>If argument <code>cache</code> was supplied in the function call,
then this data frame is the result of augmenting <code>cache</code>
with any new computations.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="base.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("egf", package = "epigrowthfit")

l &lt;- list(legend = list(cex = 0.8),
          value = list(cex = 0.8, font = 2),
          ci = list(cex = 0.8))
control &lt;- egf_control_plot(doubling = l)

op &lt;- par(mar = c(3.5, 5, 5, 1))
plot(m1,
     type = "interval",
     show_predict = 2L,
     show_doubling = 2L,
     control = control)
plot(m1,
     type = "cumulative",
     main = "Fitted exponential model",
     sub = quote(paste("Country", country)))
par(op)

op &lt;- par(mar = c(3.5, 9.5, 5, 1))
plot(m1, type = "rt", subset = quote(country %in% LETTERS[4:6]))
par(op)
</code></pre>

<hr>
<h2 id='predict.egf'>Predicted Values</h2><span id='topic+predict.egf'></span><span id='topic+confint.predict.egf'></span>

<h3>Description</h3>

<p>Computes predicted values of top level nonlinear model parameters.
These are conditional on an estimated nonlinear mixed effects model
and, optionally, new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
predict(object, newdata = NULL, class = FALSE, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.egf_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing variables to replace those in the model
frame.  The default is to use the model frame as is, and currently
that is the only implemented behaviour.</p>
</td></tr>
<tr><td><code id="predict.egf_+3A_class">class</code></td>
<td>

<p>a logical.  If <code>TRUE</code>,
then the value of the method call call is a <code><a href="#topic+predict.egf">predict.egf</a></code>
object, not a matrix.</p>
</td></tr>
<tr><td><code id="predict.egf_+3A_se">se</code></td>
<td>

<p>a logical.  If <code>TRUE</code> and if <code>class = TRUE</code>,
then the result is augmented with approximate delta method
standard errors.</p>
</td></tr>
<tr><td><code id="predict.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing predicted values.
</p>
<p>Users can pass <code>class = TRUE</code> to obtain an augmented result.
Thus, alternatively:
</p>
<p>A data frame inheriting from class <code>predict.egf</code>, with variables:
</p>
<table>
<tr><td><code>top</code></td>
<td>

<p>top level nonlinear model parameter, from
<code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code>ts</code></td>
<td>

<p>time series, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["ts"]])</code>.</p>
</td></tr>
<tr><td><code>window</code></td>
<td>

<p>fitting window, from
<code>levels(<a href="#topic+model.frame.egf">model.frame</a>(object)[["window"]])</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>predicted value.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>

<p>approximate delta method standard error (only if requested).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+predict">predict</a></code>.
</p>

<hr>
<h2 id='print.egf'>Printing Model Objects</h2><span id='topic+print.egf'></span>

<h3>Description</h3>

<p>A method for printing objects of class <code><a href="#topic+egf">egf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
print(x, width = 0.9 * getOption("width"), indent = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.egf_+3A_x">x</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="print.egf_+3A_width">width</code></td>
<td>

<p>an integer width for header text.</p>
</td></tr>
<tr><td><code id="print.egf_+3A_indent">indent</code></td>
<td>

<p>an integer indent for body text.</p>
</td></tr>
<tr><td><code id="print.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The argument <code>x</code>, unchanged but <a href="base.html#topic+invisible">invisible</a>.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="base.html#topic+print">print</a></code>.
</p>

<hr>
<h2 id='profile.egf'>Univariate Likelihood Profiles</h2><span id='topic+profile.egf'></span><span id='topic+confint.profile.egf'></span><span id='topic+plot.profile.egf'></span>

<h3>Description</h3>

<p>Computes univariate likelihood profiles of fixed effect coefficients,
random effect covariance parameters, and linear combinations thereof,
including population fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
profile(fitted, level = 0.95,
        A = seq_along(par), grid = 12L,
        parallel = egf_parallel(), trace = FALSE,
        top = egf_top(fitted), subset = NULL, select = NULL, ...)

## S3 method for class 'profile.egf'
confint(object, parm = seq_along(object), level = attr(object, "level"),
        class = FALSE, ...)

## S3 method for class 'profile.egf'
plot(x, parm = seq_along(x), level = attr(x, "level"),
     type = c("z", "abs(z)", "z^2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.egf_+3A_fitted">fitted</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_level">level</code></td>
<td>

<p>a number in the interval <code class="reqn">(0,1)</code> indicating a confidence level.
Profiles are computed up to a change in deviance equal to
<code>qchisq(level, df = 1)</code>.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_a">A</code></td>
<td>

<p>a numeric matrix with <code>1+p</code> columns,
where <code>p = length(coef(fitted))</code>,
in which case each row specifies a linear combination of the elements
of <code>c(1, coef(fitted))</code> to be profiled;
or a valid index vector for <code>coef(fitted)</code>,
in which case the indexed elements are profiled;
or <code>NULL</code>,
in which case population fitted values are profiled.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_grid">grid</code></td>
<td>

<p>a positive integer.  Step sizes chosen adaptively by
<code><a href="TMB.html#topic+tmbprofile">tmbprofile</a></code> will generate approximately this many
points on each side of a profile's minimum point.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_parallel">parallel</code></td>
<td>

<p>an <code><a href="#topic+egf_parallel">egf_parallel</a></code> object defining options for <span class="rlang"><b>R</b></span> level
parallelization.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_trace">trace</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then basic tracing messages indicating
progress are printed.  These may be mixed with optimizer output
depending on <code>fitted[["control"]][["trace"]]</code>.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_top">top</code></td>
<td>

<p>a subset of <code><a href="#topic+egf_top">egf_top</a>(fitted)</code> naming top level
nonlinear model parameters for which profiles on population
fitted values should be profiled.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_subset">subset</code>, <code id="profile.egf_+3A_select">select</code></td>
<td>

<p>index vectors for the rows and columns of
<code>model.frame(fitted, "combined")</code> or language objects
evaluating to such vectors.
<code>subset</code> indicates fitting windows for which profiles
should be computed; the default indicates all.
<code>select</code> indicates variables that should be appended to
the result; the default indicates none.
Evaluation of language objects follows the implementation of
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_object">object</code>, <code id="profile.egf_+3A_x">x</code></td>
<td>

<p>a <code>profile.egf</code> object.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_parm">parm</code></td>
<td>

<p>a valid index vector for <code>object</code> or <code>x</code> indicating a subset
of the profiles.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_class">class</code></td>
<td>

<p>a logical.  If <code>TRUE</code> and if <code>object</code> was created by
<code><a href="stats.html#topic+profile">profile</a>(A = NULL)</code>,
then the value of the method call is a <code><a href="#topic+confint.egf">confint.egf</a></code>
object, not a matrix.</p>
</td></tr>
<tr><td><code id="profile.egf_+3A_type">type</code></td>
<td>

<p>a character string indicating which of <code class="reqn">z</code>, <code class="reqn">|z|</code>,
and <code class="reqn">z^{2}</code> is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation of likelihood profiles is typically expensive, requiring
estimation of many restricted models.
It is parallelized at the C++ level when there is OpenMP
support and <code>fitted[["control"]][["omp_num_threads"]]</code> is set
to an integer greater than 1.  When there is no OpenMP support, it
can still be parallelized at the <span class="rlang"><b>R</b></span> level with appropriate setting
of argument <code>parallel</code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nrow(A)</code> inheriting from classes
<code>profile.egf</code> and <code>profile</code>.  Each element is a data frame
specifying a profile, with two variables:
</p>
<table>
<tr><td><code>z</code></td>
<td>

<p>a numeric vector containing profile <code class="reqn">z</code>-statistics.
The profile <code class="reqn">z</code>-statistic is the appropriately signed square
root of the change in deviance under the restricted model.</p>
</td></tr>
<tr><td><code>par.vals</code></td>
<td>

<p>a numeric matrix with one column containing values of the linear
combination specified by <code>A[i, ]</code>.</p>
</td></tr>
</table>
<p>The confidence level <code>level</code> is preserved as an attribute.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+profile">profile</a></code>.
The more basic &ldquo;next&rdquo; method for generic function
<code><a href="base.html#topic+plot">plot</a></code>, namely <code><a href="stats.html#topic+plot.profile">plot.profile</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example("egf", package = "epigrowthfit")

zz &lt;- profile(m1, A = NULL,
              top = "log(r)", subset = quote(country == "A" &amp; wave == 1))
str(zz)

confint(zz, class = TRUE)

pty &lt;- c("z", "abs(z)", "z^2")
bty &lt;- c("l", "u", "u")
for (i in 1:3)
    plot(zz, type = pty[i], bty = bty[i], las = 1)

</code></pre>

<hr>
<h2 id='R0'>Compute the Basic Reproduction Number</h2><span id='topic+R0'></span>

<h3>Description</h3>

<p>Computes the basic reproduction number as a function of the initial
exponential growth rate, conditional on a binned generation interval
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R0(r, breaks, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R0_+3A_r">r</code></td>
<td>

<p>a non-negative numeric vector listing initial exponential growth
rates.</p>
</td></tr>
<tr><td><code id="R0_+3A_breaks">breaks</code></td>
<td>

<p>an increasing numeric vector of length 2 or greater listing break
points in the support of the generation interval distribution,
in reciprocal units of <code>r</code>.</p>
</td></tr>
<tr><td><code id="R0_+3A_probs">probs</code></td>
<td>

<p>a numeric vector of length <code>length(breaks)-1</code>.
<code>probs[i]</code> is the probability that the generation interval
is between <code>breaks[i]</code> and <code>breaks[i+1]</code>.
It is sufficient to supply probability weights, as internally
the vector is divided by its sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector listing basic reproduction numbers.
</p>


<h3>Computation</h3>

<p>For an initial exponential growth rate <code>r</code>,
the basic reproduction number is computed as
</p>
<pre>r / sum(probs * (exp(-r * breaks[-n]) - exp(-r * breaks[-1L])) / (breaks[-1L] - breaks[-n])) ,</pre>
<p>where <code>n = length(breaks)</code>.
</p>


<h3>References</h3>

<p>Wallinga, J. &amp; Lipsitch M. (2007).
How generation intervals shape the relationship between growth rates
and reproductive numbers.
<em>Proceedings of the Royal Society B: Biological Sciences</em>,
<em>274</em>(1609), 599-604.
<a href="https://doi.org/10.1098/rspb.2006.3754">doi:10.1098/rspb.2006.3754</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timescale">timescale</a></code>, <code><a href="#topic+finalsize">finalsize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- seq(0, 1, 0.02)
breaks &lt;- seq(0, 20, 1)
probs &lt;- diff(pgamma(breaks, shape = 1, scale = 2.5))

plot(r, R0(r, breaks, probs), las = 1,
     xlab = "initial exponential growth rate",
     ylab = "basic reproduction number")
</code></pre>

<hr>
<h2 id='ranef.egf'>Details about Random Effect Coefficients</h2><span id='topic+ranef.egf'></span><span id='topic+ranef'></span><span id='topic+ranef.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts from a model object details about the random effect
coefficients, namely segment <code>b</code> of the bottom level
parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
ranef(object, makeSigma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="ranef.egf_+3A_makesigma">makeSigma</code></td>
<td>

<p>a logical flag.  If <code>TRUE</code>, then random effect covariance matrices
are constructed from segment <code>theta</code> of
<code><a href="#topic+coef.egf">coef</a>(object, full = TRUE)</code>
and preserved as an attribute of the result.</p>
</td></tr>
<tr><td><code id="ranef.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per coefficient and variables:
</p>
<table>
<tr><td><code>cov</code></td>
<td>

<p>label for a covariance matrix.
This is the interaction of <code>term</code> and <code>group</code>,
but using levels with format <code>"Sigma[%d]"</code>.</p>
</td></tr>
<tr><td><code>vec</code></td>
<td>

<p>label for a random vector.
This is the interaction of <code>term</code>, <code>group</code>, and <code>level</code>,
but using levels with format <code>"u[%d]"</code>.</p>
</td></tr>
<tr><td><code>bottom</code></td>
<td>

<p>label for a bottom level mixed effects model parameter,
in this case for a random effect coefficient;
this is a string with format <code>"b[%d]"</code>.</p>
</td></tr>
<tr><td><code>top</code></td>
<td>

<p>name of the top level nonlinear model parameter whose
fitted value is a function of <code>bottom</code>,
from <code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code>term</code>, <code>group</code></td>
<td>

<p>term from the random effects component of the mixed effects
model formula for parameter <code>top</code>.
<code>term</code> and <code>group</code> give the left and right hand sides
of the term, which is a call to binary operator <code>|</code>.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>

<p>level of the factor or interaction indicated by <code>group</code>.</p>
</td></tr>
<tr><td><code>colname</code></td>
<td>

<p>column name in the random effects design matrix
<code><a href="#topic+model.matrix.egf">model.matrix</a>(object, "random")</code>.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>random effect conditional mode (unit variance scale),
from segment <code>b</code> of
<code><a href="#topic+coef.egf">coef</a>(object, full = TRUE)</code>.</p>
</td></tr>
</table>
<p>If <code>makeSigma = TRUE</code>, then the result has attribute <code>Sigma</code>,
a list of covariance matrices corresponding to the levels of variable
<code>cov</code>.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="nlme.html#topic+ranef">ranef</a></code>.
</p>

<hr>
<h2 id='simulate.egf'>Simulation and Parametric Bootstrapping</h2><span id='topic+simulate.egf'></span>

<h3>Description</h3>

<p>Simulates incidence data conditional on a fitted nonlinear mixed effects
model of epidemic growth.  Optionally re-estimates the model given the
simulated data, thus generating samples from the conditional distribution
of the bottom level parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
simulate(object, nsim = 1, seed = NULL,
         bootstrap = FALSE,
         control = list(), parallel = egf_parallel(),
         trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_nsim">nsim</code></td>
<td>

<p>a positive integer indicating a number of replications.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_seed">seed</code></td>
<td>

<p>an integer used to set the <a href="base.html#topic+RNG">RNG</a> state before simulation or,
otherwise, <code>NULL</code>; see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_bootstrap">bootstrap</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then a bootstrapping step is performed.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_control">control</code></td>
<td>

<p>passed to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_parallel">parallel</code></td>
<td>

<p>an <code><a href="#topic+egf_parallel">egf_parallel</a></code> object defining options for <span class="rlang"><b>R</b></span> level
parallelization.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_trace">trace</code></td>
<td>

<p>a logical.  If <code>TRUE</code>, then basic tracing messages indicating
progress are printed.  These may be mixed with optimizer output
depending on <code>object[["control"]][["trace"]]</code>.</p>
</td></tr>
<tr><td><code id="simulate.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap optimizations are typically expensive for nontrivial models.
They are parallelized at the C++ level when there is OpenMP
support and <code>object[["control"]][["omp_num_threads"]]</code> is set
to an integer greater than 1.  When there is no OpenMP support, they
can still be parallelized at the <span class="rlang"><b>R</b></span> level with appropriate setting
of argument <code>parallel</code>.
</p>
<p>Arguments <code>control</code>, <code>parallel</code>, and <code>trace</code> are unused
when <code>bootstrap = FALSE</code>.
</p>


<h3>Value</h3>

<p>A list inheriting from class <code>simulate.egf</code>, with elements:
</p>
<table>
<tr><td><code>simulation</code></td>
<td>

<p>a data frame containing simulated incidence data.  It has variables
<code>ts</code>, <code>window</code>, <code>time</code>, and <code>X</code>, where <code>X</code>
is a numeric matrix with <code>nsim</code> columns.  It corresponds rowwise
to <code><a href="#topic+model.frame.egf">model.frame</a>(object)</code>.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>

<p>a numeric matrix with <code>nsim</code> columns, each a sample from the
conditional distribution of the parameter vector represented by
<code><a href="#topic+coef.egf">coef</a>(object)</code>.  <code>NULL</code> if the method
call did not set <code>bootstrap = TRUE</code>.</p>
</td></tr>
</table>
<p>Attribute <code>RNGstate</code> preserves the RNG state prior to simulation,
making the result reproducible.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("egf", package = "epigrowthfit")

zz &lt;- simulate(m2, nsim = 6L, seed = 181952L, bootstrap = TRUE)
str(zz)

matplot(t(zz[["bootstrap"]][!m2[["random"]], ]),
        type = "o", las = 1, xlab = "simulation", ylab = "value")
</code></pre>

<hr>
<h2 id='simulate.egf_model'>Simulating Incidence Time Series</h2><span id='topic+simulate.egf_model'></span><span id='topic+coef.simulate.egf_model'></span><span id='topic+egf.simulate.egf_model'></span><span id='topic+getCall.simulate.egf_model'></span>

<h3>Description</h3>

<p>Simulates equally spaced incidence time series according to a specified
nonlinear model.  Top level nonlinear model parameters vary between
time series according to a fixed intercept model <code>~ts</code> or random
intercept model <code>~(1 | ts)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf_model'
simulate(object, nsim = 1, seed = NULL,
         mu, Sigma = NULL, tol = 1e-06, cstart = 0, tend = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.egf_model_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf_model">egf_model</a></code> object specifying a top level nonlinear
model to be simulated.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_nsim">nsim</code></td>
<td>

<p>a positive integer indicating a number of time series.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_seed">seed</code></td>
<td>

<p>an integer used to set the <a href="base.html#topic+RNG">RNG</a> state before simulation or,
otherwise, <code>NULL</code>; see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_mu">mu</code></td>
<td>

<p>a numeric vector listing means across time series of top level
nonlinear model parameters (link scale).  It is assumed that
elements are ordered as <code><a href="#topic+egf_top">egf_top</a>(object)</code>.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_sigma">Sigma</code></td>
<td>

<p>a real, symmetric positive definite matrix to be used as the
covariance matrix corresponding to <code>mu</code>.  The default is
equivalent to a zero matrix and is handled specially.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_tol">tol</code></td>
<td>

<p>a non-negative number indicating a tolerance for indefinite
<code>Sigma</code>.  Eigenvalues of <code>Sigma</code> must exceed <code>-tol</code>
times its spectral radius.  <code>diag(Sigma)</code> must be positive
regardless of <code>tol</code>, as standard deviations are handled on
a logarithmic scale.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_cstart">cstart</code></td>
<td>

<p>a number indicating a threshold value of cumulative incidence.
Left endpoints of suggested fitting windows are those times when
cumulative incidence first exceeds this threshold.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_tend">tend</code></td>
<td>

<p>a positive number.  Simulated time series run from time 0 to time
<code>tend</code> with unit spacing.  For nonlinear models of expected
cumulative incidence with inflections, this argument is ignored and
set to <code>tinfl+1</code>, where <code>tinfl</code> is the time of inflection.</p>
</td></tr>
<tr><td><code id="simulate.egf_model_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list inheriting from class <code>simulate.egf_model</code>, with elements:
</p>
<table>
<tr><td><code>model</code></td>
<td>

<p>copy of argument <code>object</code>.</p>
</td></tr>
<tr><td><code>formula_ts</code></td>
<td>

<p>a formula, always <code>cbind(time, x) ~ ts</code>,
expressing how simulated time series are stored in <code>data_ts</code>.</p>
</td></tr>
<tr><td><code>formula_windows</code></td>
<td>

<p>a formula, always <code>cbind(start, end) ~ ts</code>,
expressing how fitting window endpoints are stored in <code>data_windows</code>.</p>
</td></tr>
<tr><td><code>formula_parameters</code></td>
<td>

<p>a formula specifying the generative model.
If <code>Sigma = NULL</code>, then the formula is <code>~1</code>
if <code>nsim = 1</code> and <code>~ts</code> if <code>nsim &gt; 1</code>.
Otherwise, it is <code>~(1 | ts)</code>.</p>
</td></tr>
<tr><td><code>data_ts</code></td>
<td>

<p>a data frame with variables <code>ts</code>, <code>time</code>, and <code>x</code>
storing <code>nsim</code> simulated time series in long format.</p>
</td></tr>
<tr><td><code>data_windows</code></td>
<td>

<p>a data frame with <code>nsim</code> rows and variables <code>ts</code>,
<code>start</code>, and <code>end</code> suggesting fitting window endpoints
for each simulated time series.  Start times are determined by
<code>cstart</code>.  End times are always the last time point in the
corresponding time series.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>

<p>a named list of the form <code>list(beta, theta)</code> giving the full
bottom level parameter vector of the generative model.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>

<p>a numeric matrix with <code>nsim</code> rows and <code>length(mu)</code> columns
listing top level nonlinear model parameter values for each time series.
If <code>Sigma = NULL</code>, then the row vectors of are all <code>mu</code>.
Otherwise, <code>Y</code> is (conceptually) the result of
<code>MASS::mvrnorm(nsim, mu, Sigma, tol)</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>the call to <code><a href="stats.html#topic+simulate">simulate</a></code>, allowing for updates to the
<code>simulate.egf_model</code> object via <code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
</table>
<p>Attribute <code>RNGstate</code> preserves the RNG state prior to simulation,
making the result reproducible.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- 0.04
c0 &lt;- 400
s &lt;- 0.2

mu &lt;- log(c(r, c0))
Sigma &lt;- diag(rep.int(s^2, length(mu)))

zz &lt;- simulate(object = egf_model(curve = "exponential", family = "pois"),
               nsim = 20L,
               seed = 202737L,
               mu = mu,
               Sigma = Sigma,
               cstart = 10)
str(zz)

mm &lt;- egf(zz)
(pp &lt;- cbind(actual = coef(zz), fitted = coef(mm)))
</code></pre>

<hr>
<h2 id='summary.egf'>Model Summaries</h2><span id='topic+summary.egf'></span><span id='topic+print.summary.egf'></span>

<h3>Description</h3>

<p>Summarizes fitted values of top level nonlinear model parameters
and gathers diagnostic information that can be used to quickly assess
convergence of the optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.egf_+3A_...">...</code></td>
<td>

<p>additional arguments passed from or to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list inheriting from class <code>summary.egf</code>, with elements:
</p>
<table>
<tr><td><code>fitted</code></td>
<td>

<p>a numeric matrix.  Each column is the result of applying
<code><a href="base.html#topic+summary.default">summary.default</a></code> to a numeric vector listing the fitted
values of a top level nonlinear model parameters.  Fitted values are
retrieved by <code><a href="#topic+fitted.egf">fitted.egf</a></code>.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>an integer code returned by the optimizer, with 0 indicating
successful convergence within the specified absolute or relative
tolerance.</p>
</td></tr>
<tr><td><code>value</code>, <code>gradient</code></td>
<td>

<p>numeric vectors giving the value and gradient of the negative log
marginal likelihood function at the parameter vector returned by
the optimizer.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>

<p>a logical flag indicating whether the Hessian matrix of the
negative log marginal likelihood function is positive definite
at the parameter vector returned by the optimizer.  <code>NA</code>
means that the matrix was not computed by <code><a href="#topic+egf">egf</a></code>,
either because <code>se = TRUE</code> was not passed in the function
call or because an error was thrown during computation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The generic function <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("egf", package = "epigrowthfit")

zz &lt;- summary(m1)
str(zz)
</code></pre>

<hr>
<h2 id='terms.egf'>Model Terms</h2><span id='topic+terms.egf'></span><span id='topic+terms.egf_no_fit'></span>

<h3>Description</h3>

<p>Extracts the <code><a href="stats.html#topic+terms.object">terms</a></code> object
corresponding to a top level nonlinear model parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
terms(x, top = egf_top(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.egf_+3A_x">x</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="terms.egf_+3A_top">top</code></td>
<td>

<p>a character string specifying a top level nonlinear model parameter.</p>
</td></tr>
<tr><td><code id="terms.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+terms.object">terms</a></code> object.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+terms">terms</a></code>.
</p>

<hr>
<h2 id='timescale'>Compute the Characteristic Time Scale</h2><span id='topic+timescale'></span>

<h3>Description</h3>

<p>Computes characteristic time scales corresponding to exponential growth
rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timescale(r, units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timescale_+3A_r">r</code></td>
<td>

<p>a non-negative numeric vector listing exponential growth rates.</p>
</td></tr>
<tr><td><code id="timescale_+3A_units">units</code></td>
<td>

<p>a character string indicating units for the result.
If missing, then the result is &ldquo;unitless&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>1/r</code>, as a <code><a href="base.html#topic+difftime">difftime</a></code> if <code>units</code> is not missing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R0">R0</a></code>, <code><a href="#topic+finalsize">finalsize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- 10^(-2:0)
units &lt;- "days"
stopifnot(all.equal(timescale(r), 1 / r),
          all.equal(timescale(r, units), .difftime(1 / r, units)))
</code></pre>

<hr>
<h2 id='vcov.egf'>Model Covariance Matrices</h2><span id='topic+vcov.egf'></span>

<h3>Description</h3>

<p>Extracts (or, if necessary, computes) the covariance matrix of
bottom level parameters <code>beta</code> and <code>theta</code>,
corresponding to the output of <code><a href="#topic+coef.egf">coef</a>(object)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egf'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.egf_+3A_object">object</code></td>
<td>

<p>an <code><a href="#topic+egf">egf</a></code> object.</p>
</td></tr>
<tr><td><code id="vcov.egf_+3A_...">...</code></td>
<td>

<p>unused optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the resulting matrix is not finite or not positive definite,
then the fit specified by <code>object</code> should be investigated,
as the optimizer that produced the fit may have failed to converge.
</p>


<h3>Value</h3>

<p>A real, symmetric matrix.
</p>


<h3>See Also</h3>

<p>The generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
