<!DOCTYPE html><html><head><title>Help for package valr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {valr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bed_absdist'><p>Compute absolute distances between intervals.</p></a></li>
<li><a href='#bed_closest'><p>Identify closest intervals.</p></a></li>
<li><a href='#bed_cluster'><p>Cluster neighboring intervals.</p></a></li>
<li><a href='#bed_complement'><p>Identify intervals in a genome not covered by a query.</p></a></li>
<li><a href='#bed_coverage'><p>Compute coverage of intervals.</p></a></li>
<li><a href='#bed_fisher'><p>Fisher's test to measure overlap between two sets of intervals.</p></a></li>
<li><a href='#bed_flank'><p>Create flanking intervals from input intervals.</p></a></li>
<li><a href='#bed_glyph'><p>Create example glyphs for valr functions.</p></a></li>
<li><a href='#bed_intersect'><p>Identify intersecting intervals.</p></a></li>
<li><a href='#bed_jaccard'><p>Calculate the Jaccard statistic for two sets of intervals.</p></a></li>
<li><a href='#bed_makewindows'><p>Divide intervals into new sub-intervals (&quot;windows&quot;).</p></a></li>
<li><a href='#bed_map'><p>Calculate summaries from overlapping intervals.</p></a></li>
<li><a href='#bed_merge'><p>Merge overlapping intervals.</p></a></li>
<li><a href='#bed_partition'><p>Partition intervals into elemental intervals</p></a></li>
<li><a href='#bed_projection'><p>Projection test for query interval overlap.</p></a></li>
<li><a href='#bed_random'><p>Generate randomly placed intervals on a genome.</p></a></li>
<li><a href='#bed_reldist'><p>Compute relative distances between intervals.</p></a></li>
<li><a href='#bed_shift'><p>Adjust intervals by a fixed size.</p></a></li>
<li><a href='#bed_shuffle'><p>Shuffle input intervals.</p></a></li>
<li><a href='#bed_slop'><p>Increase the size of input intervals.</p></a></li>
<li><a href='#bed_sort'><p>Sort a set of intervals.</p></a></li>
<li><a href='#bed_subtract'><p>Subtract two sets of intervals.</p></a></li>
<li><a href='#bed_window'><p>Identify intervals within a specified distance.</p></a></li>
<li><a href='#bed12_to_exons'><p>Convert BED12 to individual exons in BED6.</p></a></li>
<li><a href='#bound_intervals'><p>Select intervals bounded by a genome.</p></a></li>
<li><a href='#create_introns'><p>Create intron features.</p></a></li>
<li><a href='#create_tss'><p>Create transcription start site features.</p></a></li>
<li><a href='#create_utrs3'><p>Create 3' UTR features.</p></a></li>
<li><a href='#create_utrs5'><p>Create 5' UTR features.</p></a></li>
<li><a href='#db'><p>Fetch data from remote databases.</p></a></li>
<li><a href='#flip_strands'><p>Flip strands in intervals.</p></a></li>
<li><a href='#gr_to_bed'><p>Convert Granges to bed tibble</p></a></li>
<li><a href='#id'><p>Plyr function id packaged due to plyr being retired</p>
Compute a unique numeric id for each unique row in a data frame.</a></li>
<li><a href='#id_var'><p>Plyr function id_var packaged due to plyr being retired</p>
Numeric id for a vector.</a></li>
<li><a href='#interval_spacing'><p>Calculate interval spacing.</p></a></li>
<li><a href='#ivl_df'><p>Bed-like data.frame requirements for valr functions</p></a></li>
<li><a href='#read_bed'><p>Read BED and related files.</p></a></li>
<li><a href='#read_bigwig'><p>Import and convert a bigwig file into a valr compatible tbl</p></a></li>
<li><a href='#read_genome'><p>Read genome files.</p></a></li>
<li><a href='#read_gtf'><p>Import and convert a GTF/GFF file into a valr compatible bed tbl format</p></a></li>
<li><a href='#read_vcf'><p>Read a VCF file.</p></a></li>
<li><a href='#valr'><p>valr: genome interval arithmetic in R</p></a></li>
<li><a href='#valr_example'><p>Provide working directory for valr example files.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genome Interval Arithmetic</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Read and manipulate genome intervals and signals. Provides
    functionality similar to command-line tool suites within R, enabling
    interactive analysis and visualization of genome-scale data.  Riemondy
    et al. (2017) &lt;<a href="https://doi.org/10.12688%2Ff1000research.11997.1">doi:10.12688/f1000research.11997.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rnabioco/valr/">https://github.com/rnabioco/valr/</a>,
<a href="https://rnabioco.github.io/valr/">https://rnabioco.github.io/valr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rnabioco/valr/issues">https://github.com/rnabioco/valr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, cli, dplyr (&ge; 0.8.0), ggplot2, lifecycle, Rcpp (&ge;
1.0.0), readr, rlang, rtracklayer, stringr, tibble (&ge; 1.4.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, covr, cowplot, curl, DBI, dbplyr, devtools, DT,
GenomicRanges, IRanges, knitr, purrr, RMariaDB, rmarkdown,
S4Vectors, testthat (&ge; 3.0.0), vdiffr (&ge; 1.0.0), tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown, rnabioco/rbitemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 16:41:49 UTC; kriemo</td>
</tr>
<tr>
<td>Author:</td>
<td>Jay Hesselberth <a href="https://orcid.org/0000-0002-6299-179X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kent Riemondy <a href="https://orcid.org/0000-0003-0750-1273"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  RNA Bioscience Initiative [fnd, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kent Riemondy &lt;kent.riemondy@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-18 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bed_absdist'>Compute absolute distances between intervals.</h2><span id='topic+bed_absdist'></span>

<h3>Description</h3>

<p>Computes the absolute distance between the midpoint of each <code>x</code> interval and
the midpoints of each closest <code>y</code> interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_absdist(x, y, genome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_absdist_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_absdist_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_absdist_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absolute distances are scaled by the inter-reference gap for the
chromosome as follows. For <code>Q</code> query points and <code>R</code> reference
points on a chromosome, scale the distance for each query point <code>i</code> to
the closest reference point by the inter-reference gap for each chromosome.
If an <code>x</code> interval has no matching <code>y</code> chromosome,
<code>.absdist</code> is <code>NA</code>.
</p>
<p style="text-align: center;"><code class="reqn">d_i(x,y) = min_k(|q_i - r_k|)\frac{R}{Length\ of\ chromosome}</code>
</p>

<p>Both absolute and scaled distances are reported as <code>.absdist</code> and
<code>.absdist_scaled</code>.
</p>
<p>Interval statistics can be used in combination with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> to calculate
statistics for subsets of data. See <code>vignette('interval-stats')</code> for
examples.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with <code>.absdist</code> and <code>.absdist_scaled</code> columns.
</p>


<h3>See Also</h3>

<p><a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529</a>
</p>
<p>Other interval statistics: 
<code><a href="#topic+bed_fisher">bed_fisher</a>()</code>,
<code><a href="#topic+bed_jaccard">bed_jaccard</a>()</code>,
<code><a href="#topic+bed_projection">bed_projection</a>()</code>,
<code><a href="#topic+bed_reldist">bed_reldist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

x &lt;- bed_random(genome, seed = 1010486)
y &lt;- bed_random(genome, seed = 9203911)

bed_absdist(x, y, genome)

</code></pre>

<hr>
<h2 id='bed_closest'>Identify closest intervals.</h2><span id='topic+bed_closest'></span>

<h3>Description</h3>

<p>Identify closest intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_closest(x, y, overlap = TRUE, suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_closest_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_closest_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_closest_+3A_overlap">overlap</code></td>
<td>
<p>report overlapping intervals</p>
</td></tr>
<tr><td><code id="bed_closest_+3A_suffix">suffix</code></td>
<td>
<p>colname suffixes in output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with additional columns:
</p>

<ul>
<li> <p><code>.overlap</code> amount of overlap with overlapping interval. Non-overlapping
or adjacent intervals have an overlap of 0. <code>.overlap</code> will not be included
in the output if <code>overlap = FALSE</code>.
</p>
</li>
<li> <p><code>.dist</code> distance to closest interval. Negative distances
denote upstream intervals. Book-ended intervals have a distance of 1.
</p>
</li></ul>



<h3>Note</h3>

<p>For each interval in x <code>bed_closest()</code> returns overlapping intervals from y
and the closest non-intersecting y interval. Setting <code>overlap = FALSE</code> will
report the closest non-intersecting y intervals, ignoring any overlapping y
intervals.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/closest.html">https://bedtools.readthedocs.io/en/latest/content/tools/closest.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_coverage">bed_coverage</a>()</code>,
<code><a href="#topic+bed_intersect">bed_intersect</a>()</code>,
<code><a href="#topic+bed_map">bed_map</a>()</code>,
<code><a href="#topic+bed_subtract">bed_subtract</a>()</code>,
<code><a href="#topic+bed_window">bed_window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    125
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25,     50,
  "chr1", 140,    175
)

bed_glyph(bed_closest(x, y))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 500,    600,
  "chr2", 5000,   6000
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    200,
  "chr1", 150,    200,
  "chr1", 550,    580,
  "chr2", 7000,   8500
)

bed_closest(x, y)

bed_closest(x, y, overlap = FALSE)

# Report distance based on strand
x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~name, ~score, ~strand,
  "chr1", 10, 20, "a", 1, "-"
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~name, ~score, ~strand,
  "chr1", 8, 9, "b", 1, "+",
  "chr1", 21, 22, "b", 1, "-"
)

res &lt;- bed_closest(x, y)

# convert distance based on strand
res$.dist_strand &lt;- ifelse(res$strand.x == "+", res$.dist, -(res$.dist))
res

# report absolute distances
res$.abs_dist &lt;- abs(res$.dist)
res

</code></pre>

<hr>
<h2 id='bed_cluster'>Cluster neighboring intervals.</h2><span id='topic+bed_cluster'></span>

<h3>Description</h3>

<p>The output <code>.id</code> column can be used in downstream grouping operations. Default
<code>max_dist = 0</code> means that both overlapping and book-ended intervals will be
clustered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_cluster(x, max_dist = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_cluster_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_cluster_+3A_max_dist">max_dist</code></td>
<td>
<p>maximum distance between clustered intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with <code>.id</code> column specifying sets of clustered intervals.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/cluster.html">https://bedtools.readthedocs.io/en/latest/content/tools/cluster.html</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    200,
  "chr1", 180,    250,
  "chr1", 250,    500,
  "chr1", 501,    1000,
  "chr2", 1,      100,
  "chr2", 150,    200
)

bed_cluster(x)

# glyph illustrating clustering of overlapping and book-ended intervals
x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 1,      10,
  "chr1", 5,      20,
  "chr1", 30,     40,
  "chr1", 40,     50,
  "chr1", 80,     90
)

bed_glyph(bed_cluster(x), label = ".id")

</code></pre>

<hr>
<h2 id='bed_complement'>Identify intervals in a genome not covered by a query.</h2><span id='topic+bed_complement'></span>

<h3>Description</h3>

<p>Identify intervals in a genome not covered by a query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_complement(x, genome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_complement_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_complement_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 0,      10,
  "chr1", 75,     100
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 200
)

bed_glyph(bed_complement(x, genome))

genome &lt;- tibble::tribble(
  ~chrom,  ~size,
  "chr1",  500,
  "chr2",  600,
  "chr3",  800
)

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    300,
  "chr1", 200,    400,
  "chr2", 0,      100,
  "chr2", 200,    400,
  "chr3", 500,    600
)

# intervals not covered by x
bed_complement(x, genome)

</code></pre>

<hr>
<h2 id='bed_coverage'>Compute coverage of intervals.</h2><span id='topic+bed_coverage'></span>

<h3>Description</h3>

<p>Compute coverage of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_coverage(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_coverage_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_coverage_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_coverage_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with the following additional columns:
</p>

<ul>
<li> <p><code>.ints</code> number of <code>x</code> intersections
</p>
</li>
<li> <p><code>.cov</code> per-base coverage of <code>x</code> intervals
</p>
</li>
<li> <p><code>.len</code> total length of <code>y</code> intervals covered by <code>x</code> intervals
</p>
</li>
<li> <p><code>.frac</code> <code>.len</code> scaled by the number of <code>y</code> intervals
</p>
</li></ul>



<h3>Note</h3>

<p>Book-ended intervals are included in coverage calculations.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/coverage.html">https://bedtools.readthedocs.io/en/latest/content/tools/coverage.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_closest">bed_closest</a>()</code>,
<code><a href="#topic+bed_intersect">bed_intersect</a>()</code>,
<code><a href="#topic+bed_map">bed_map</a>()</code>,
<code><a href="#topic+bed_subtract">bed_subtract</a>()</code>,
<code><a href="#topic+bed_window">bed_window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~strand,
  "chr1", 100,    500,  "+",
  "chr2", 200,    400,  "+",
  "chr2", 300,    500,  "-",
  "chr2", 800,    900,  "-"
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value, ~strand,
  "chr1", 150,    400,  100,    "+",
  "chr1", 500,    550,  100,    "+",
  "chr2", 230,    430,  200,    "-",
  "chr2", 350,    430,  300,    "-"
)

bed_coverage(x, y)

</code></pre>

<hr>
<h2 id='bed_fisher'>Fisher's test to measure overlap between two sets of intervals.</h2><span id='topic+bed_fisher'></span>

<h3>Description</h3>

<p>Calculate Fisher's test on number of intervals that are shared and unique
between two sets of <code>x</code> and <code>y</code> intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_fisher(x, y, genome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_fisher_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_fisher_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_fisher_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interval statistics can be used in combination with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> to calculate
statistics for subsets of data. See <code>vignette('interval-stats')</code> for
examples.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/fisher.html">https://bedtools.readthedocs.io/en/latest/content/tools/fisher.html</a>
</p>
<p>Other interval statistics: 
<code><a href="#topic+bed_absdist">bed_absdist</a>()</code>,
<code><a href="#topic+bed_jaccard">bed_jaccard</a>()</code>,
<code><a href="#topic+bed_projection">bed_projection</a>()</code>,
<code><a href="#topic+bed_reldist">bed_reldist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

x &lt;- bed_random(genome, n = 1e4, seed = 1010486)
y &lt;- bed_random(genome, n = 1e4, seed = 9203911)

bed_fisher(x, y, genome)

</code></pre>

<hr>
<h2 id='bed_flank'>Create flanking intervals from input intervals.</h2><span id='topic+bed_flank'></span>

<h3>Description</h3>

<p>Create flanking intervals from input intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_flank(
  x,
  genome,
  both = 0,
  left = 0,
  right = 0,
  fraction = FALSE,
  strand = FALSE,
  trim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_flank_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_flank_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_flank_+3A_both">both</code></td>
<td>
<p>number of bases on both sizes</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_left">left</code></td>
<td>
<p>number of bases on left side</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_right">right</code></td>
<td>
<p>number of bases on right side</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_fraction">fraction</code></td>
<td>
<p>define flanks based on fraction of interval length</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_strand">strand</code></td>
<td>
<p>define <code>left</code> and <code>right</code> based on strand</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_trim">trim</code></td>
<td>
<p>adjust coordinates for out-of-bounds intervals</p>
</td></tr>
<tr><td><code id="bed_flank_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/flank.html">https://bedtools.readthedocs.io/en/latest/content/tools/flank.html</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25, 50,
  "chr1", 100, 125
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 130
)

bed_glyph(bed_flank(x, genome, both = 20))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~name, ~score, ~strand,
  "chr1", 500,    1000, ".",   ".",    "+",
  "chr1", 1000,   1500, ".",   ".",    "-"
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 5000
)

bed_flank(x, genome, left = 100)

bed_flank(x, genome, right = 100)

bed_flank(x, genome, both = 100)

bed_flank(x, genome, both = 0.5, fraction = TRUE)

</code></pre>

<hr>
<h2 id='bed_glyph'>Create example glyphs for valr functions.</h2><span id='topic+bed_glyph'></span>

<h3>Description</h3>

<p>Used to illustrate the output of valr functions with small examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_glyph(expr, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_glyph_+3A_expr">expr</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="bed_glyph_+3A_label">label</code></td>
<td>
<p>column name to use for label values. should be present in the
result of the call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25,     50,
  "chr1", 100,    125
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value,
  "chr1", 30, 75, 50
)

bed_glyph(bed_intersect(x, y))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 30,     75,
  "chr1", 50,     90,
  "chr1", 91,     120
)

bed_glyph(bed_merge(x))

bed_glyph(bed_cluster(x), label = ".id")

</code></pre>

<hr>
<h2 id='bed_intersect'>Identify intersecting intervals.</h2><span id='topic+bed_intersect'></span>

<h3>Description</h3>

<p>Report intersecting intervals from <code>x</code> and <code>y</code> tbls. Book-ended intervals
have <code>.overlap</code> values of <code>0</code> in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_intersect(x, ..., invert = FALSE, suffix = c(".x", ".y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_intersect_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_intersect_+3A_...">...</code></td>
<td>
<p>one or more (e.g. a list of) <code>y</code> <code><a href="#topic+ivl_df">ivl_df()</a></code>s</p>
</td></tr>
<tr><td><code id="bed_intersect_+3A_invert">invert</code></td>
<td>
<p>report <code>x</code> intervals not in <code>y</code></p>
</td></tr>
<tr><td><code id="bed_intersect_+3A_suffix">suffix</code></td>
<td>
<p>colname suffixes in output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with original columns from <code>x</code> and <code>y</code> suffixed with <code>.x</code>
and <code>.y</code>, and a new <code>.overlap</code> column with the extent of overlap for the
intersecting intervals.
</p>
<p>If  multiple <code>y</code> tbls are supplied, the <code>.source</code> contains variable names
associated with each interval. All original columns from the <code>y</code> are suffixed
with <code>.y</code> in the output.
</p>
<p>If <code>...</code> contains named inputs (i.e <code style="white-space: pre;">&#8288;a = y, b = z&#8288;</code> or <code>list(a = y, b =  z)</code>),
then <code>.source</code> will contain supplied names (see examples).
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html">https://bedtools.readthedocs.io/en/latest/content/tools/intersect.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_closest">bed_closest</a>()</code>,
<code><a href="#topic+bed_coverage">bed_coverage</a>()</code>,
<code><a href="#topic+bed_map">bed_map</a>()</code>,
<code><a href="#topic+bed_subtract">bed_subtract</a>()</code>,
<code><a href="#topic+bed_window">bed_window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25, 50,
  "chr1", 100, 125
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 30,     75
)

bed_glyph(bed_intersect(x, y))

bed_glyph(bed_intersect(x, y, invert = TRUE))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    500,
  "chr2", 200,    400,
  "chr2", 300,    500,
  "chr2", 800,    900
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value,
  "chr1", 150,    400,  100,
  "chr1", 500,    550,  100,
  "chr2", 230,    430,  200,
  "chr2", 350,    430,  300
)

bed_intersect(x, y)

bed_intersect(x, y, invert = TRUE)

# start and end of each overlapping interval
res &lt;- bed_intersect(x, y)
dplyr::mutate(res,
  start = pmax(start.x, start.y),
  end = pmin(end.x, end.y)
)

z &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value,
  "chr1", 150,    400,  100,
  "chr1", 500,    550,  100,
  "chr2", 230,    430,  200,
  "chr2", 750,    900,  400
)

bed_intersect(x, y, z)

bed_intersect(x, exons = y, introns = z)

# a list of tbl_intervals can also be passed
bed_intersect(x, list(exons = y, introns = z))

</code></pre>

<hr>
<h2 id='bed_jaccard'>Calculate the Jaccard statistic for two sets of intervals.</h2><span id='topic+bed_jaccard'></span>

<h3>Description</h3>

<p>Quantifies the extent of overlap between to sets of intervals in terms of
base-pairs. Groups that are shared between input are used to calculate the statistic
for subsets of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_jaccard(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_jaccard_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_jaccard_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard statistic takes values of <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> and is measured as:
</p>
<p style="text-align: center;"><code class="reqn"> J(x,y) = \frac{\mid x \bigcap y \mid}
                     {\mid x \bigcup y \mid} =
                \frac{\mid x \bigcap y \mid}
                     {\mid x \mid + \mid y \mid -
                      \mid x \bigcap y \mid} </code>
</p>

<p>Interval statistics can be used in combination with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> to calculate
statistics for subsets of data. See <code>vignette('interval-stats')</code> for
examples.
</p>


<h3>Value</h3>

<p>tibble with the following columns:
</p>

<ul>
<li> <p><code>len_i</code> length of the intersection in base-pairs
</p>
</li>
<li> <p><code>len_u</code> length of the union in base-pairs
</p>
</li>
<li> <p><code>jaccard</code> value of jaccard statistic
</p>
</li>
<li> <p><code>n_int</code> number of intersecting intervals between <code>x</code> and <code>y</code>
</p>
</li></ul>

<p>If inputs are grouped, the return value will contain one set of values per group.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/jaccard.html">https://bedtools.readthedocs.io/en/latest/content/tools/jaccard.html</a>
</p>
<p>Other interval statistics: 
<code><a href="#topic+bed_absdist">bed_absdist</a>()</code>,
<code><a href="#topic+bed_fisher">bed_fisher</a>()</code>,
<code><a href="#topic+bed_projection">bed_projection</a>()</code>,
<code><a href="#topic+bed_reldist">bed_reldist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

x &lt;- bed_random(genome, seed = 1010486)
y &lt;- bed_random(genome, seed = 9203911)

bed_jaccard(x, y)

# calculate jaccard per chromosome
bed_jaccard(
  dplyr::group_by(x, chrom),
  dplyr::group_by(y, chrom)
)

</code></pre>

<hr>
<h2 id='bed_makewindows'>Divide intervals into new sub-intervals (&quot;windows&quot;).</h2><span id='topic+bed_makewindows'></span>

<h3>Description</h3>

<p>Divide intervals into new sub-intervals (&quot;windows&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_makewindows(x, win_size = 0, step_size = 0, num_win = 0, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_makewindows_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_makewindows_+3A_win_size">win_size</code></td>
<td>
<p>divide intervals into fixed-size windows</p>
</td></tr>
<tr><td><code id="bed_makewindows_+3A_step_size">step_size</code></td>
<td>
<p>size to step before next window</p>
</td></tr>
<tr><td><code id="bed_makewindows_+3A_num_win">num_win</code></td>
<td>
<p>divide intervals to fixed number of windows</p>
</td></tr>
<tr><td><code id="bed_makewindows_+3A_reverse">reverse</code></td>
<td>
<p>reverse window numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with <code>.win_id</code> column that contains a numeric
identifier for the window.
</p>


<h3>Note</h3>

<p>The <code>name</code> and <code>.win_id</code> columns can be used to create new
interval names (see 'namenum' example below) or in subsequent
<code>group_by</code> operations (see vignette).
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+bed12_to_exons">bed12_to_exons</a>()</code>,
<code><a href="#topic+bound_intervals">bound_intervals</a>()</code>,
<code><a href="#topic+flip_strands">flip_strands</a>()</code>,
<code><a href="#topic+interval_spacing">interval_spacing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~name, ~score, ~strand,
  "chr1", 100,    200,  "A",   ".",    "+"
)

bed_glyph(bed_makewindows(x, num_win = 10), label = ".win_id")

# Fixed number of windows
bed_makewindows(x, num_win = 10)

# Fixed window size
bed_makewindows(x, win_size = 10)

# Fixed window size with overlaps
bed_makewindows(x, win_size = 10, step_size = 5)

# reverse win_id
bed_makewindows(x, win_size = 10, reverse = TRUE)

# bedtools 'namenum'
wins &lt;- bed_makewindows(x, win_size = 10)
dplyr::mutate(wins, namenum = stringr::str_c(name, "_", .win_id))

</code></pre>

<hr>
<h2 id='bed_map'>Calculate summaries from overlapping intervals.</h2><span id='topic+bed_map'></span><span id='topic+concat'></span><span id='topic+values_unique'></span><span id='topic+values'></span>

<h3>Description</h3>

<p>Apply functions like <code><a href="base.html#topic+min">min()</a></code> and <code><a href="covr.html#topic+count">count()</a></code> to intersecting intervals.
<code><a href="#topic+bed_map">bed_map()</a></code> uses <code><a href="#topic+bed_intersect">bed_intersect()</a></code> to identify intersecting intervals, so
output columns will be suffixed with <code>.x</code> and <code>.y</code>. Expressions that refer to
input columns from <code>x</code> and <code>y</code> columns must take these suffixes into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_map(x, y, ..., min_overlap = 1)

concat(.data, sep = ",")

values_unique(.data, sep = ",")

values(.data, sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_map_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_map_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_map_+3A_...">...</code></td>
<td>
<p>name-value pairs specifying column names and expressions to apply</p>
</td></tr>
<tr><td><code id="bed_map_+3A_min_overlap">min_overlap</code></td>
<td>
<p>minimum overlap for intervals.</p>
</td></tr>
<tr><td><code id="bed_map_+3A_.data">.data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="bed_map_+3A_sep">sep</code></td>
<td>
<p>separator character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Book-ended intervals can be included by setting <code>min_overlap = 0</code>.
</p>
<p>Non-intersecting intervals from <code>x</code> are included in the result with <code>NA</code>
values.
</p>
<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/map.html">https://bedtools.readthedocs.io/en/latest/content/tools/map.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_closest">bed_closest</a>()</code>,
<code><a href="#topic+bed_coverage">bed_coverage</a>()</code>,
<code><a href="#topic+bed_intersect">bed_intersect</a>()</code>,
<code><a href="#topic+bed_subtract">bed_subtract</a>()</code>,
<code><a href="#topic+bed_window">bed_window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
 ~chrom, ~start, ~end,
 'chr1', 100,    250,
 'chr2', 250,    500
)

y &lt;- tibble::tribble(
 ~chrom, ~start, ~end, ~value,
 'chr1', 100,    250,  10,
 'chr1', 150,    250,  20,
 'chr2', 250,    500,  500
)

bed_glyph(bed_map(x, y, value = sum(value)), label = 'value')

# summary examples
bed_map(x, y, .sum = sum(value))

bed_map(x, y, .min = min(value), .max = max(value))

# identify non-intersecting intervals to include in the result
res &lt;- bed_map(x, y, .sum = sum(value))
x_not &lt;- bed_intersect(x, y, invert = TRUE)
dplyr::bind_rows(res, x_not)

# create a list-column
bed_map(x, y, .values = list(value))

# use `nth` family from dplyr
bed_map(x, y, .first = dplyr::first(value))

bed_map(x, y, .absmax = abs(max(value)))

bed_map(x, y, .count = length(value))

bed_map(x, y, .vals = values(value))

# count defaults are NA not 0; differs from bedtools2 ...
bed_map(x, y, .counts = dplyr::n())

# ... but NA counts can be coverted to 0's
dplyr::mutate(bed_map(x, y, .counts = dplyr::n()), .counts = ifelse(is.na(.counts), 0, .counts))

</code></pre>

<hr>
<h2 id='bed_merge'>Merge overlapping intervals.</h2><span id='topic+bed_merge'></span>

<h3>Description</h3>

<p>Operations can be performed on merged intervals by specifying name-value
pairs. Default <code>max_dist</code> of <code>0</code> means book-ended intervals are
merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_merge(x, max_dist = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_merge_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_merge_+3A_max_dist">max_dist</code></td>
<td>
<p>maximum distance between intervals to merge</p>
</td></tr>
<tr><td><code id="bed_merge_+3A_...">...</code></td>
<td>
<p>name-value pairs that specify operations on merged intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/merge.html">https://bedtools.readthedocs.io/en/latest/content/tools/merge.html</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 1, 50,
  "chr1", 10, 75,
  "chr1", 100, 120
)

bed_glyph(bed_merge(x))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value, ~strand,
  "chr1", 1,      50,   1,      "+",
  "chr1", 100,    200,  2,      "+",
  "chr1", 150,    250,  3,      "-",
  "chr2", 1,      25,   4,      "+",
  "chr2", 200,    400,  5,      "-",
  "chr2", 400,    500,  6,      "+",
  "chr2", 450,    550,  7,      "+"
)

bed_merge(x)

bed_merge(x, max_dist = 100)

# merge intervals on same strand
bed_merge(dplyr::group_by(x, strand))

bed_merge(x, .value = sum(value))

</code></pre>

<hr>
<h2 id='bed_partition'>Partition intervals into elemental intervals</h2><span id='topic+bed_partition'></span>

<h3>Description</h3>

<p>Convert a set of intervals into elemental intervals that contain each start
and end position in the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_partition(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_partition_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_partition_+3A_...">...</code></td>
<td>
<p>name-value pairs specifying column names and expressions to apply</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary operations, such as <code><a href="base.html#topic+min">min()</a></code> or <code><a href="covr.html#topic+count">count()</a></code> can be performed
on elemental intervals by specifying name-value pairs.
</p>
<p>This function is useful for calculating summaries across overlapping intervals
without merging the intervals.
</p>
<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+ivl_df">ivl_df()</a></code>
</p>


<h3>See Also</h3>

<p><a href="https://bedops.readthedocs.io/en/latest/content/reference/set-operations/bedops.html#partition-p-partition">https://bedops.readthedocs.io/en/latest/content/reference/set-operations/bedops.html#partition-p-partition</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value, ~strand,
  "chr1", 100, 500, 10, "+",
  "chr1", 200, 400, 20, "-",
  "chr1", 300, 550, 30, "+",
  "chr1", 550, 575, 2, "+",
  "chr1", 800, 900, 5, "+"
)


bed_glyph(bed_partition(x))
bed_glyph(bed_partition(x, value = sum(value)), label = "value")

bed_partition(x)

# compute summary over each elemental interval
bed_partition(x, value = sum(value))

# partition and compute summaries based on group
x &lt;- dplyr::group_by(x, strand)
bed_partition(x, value = sum(value))

# combine values across multiple tibbles
y &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~value, ~strand,
  "chr1", 10, 500, 100, "+",
  "chr1", 250, 420, 200, "-",
  "chr1", 350, 550, 300, "+",
  "chr1", 550, 555, 20, "+",
  "chr1", 800, 900, 50, "+"
)

x &lt;- dplyr::bind_rows(x, y)
bed_partition(x, value = sum(value))

</code></pre>

<hr>
<h2 id='bed_projection'>Projection test for query interval overlap.</h2><span id='topic+bed_projection'></span>

<h3>Description</h3>

<p>Projection test for query interval overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_projection(x, y, genome, by_chrom = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_projection_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_projection_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_projection_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_projection_+3A_by_chrom">by_chrom</code></td>
<td>
<p>compute test per chromosome</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interval statistics can be used in combination with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> to calculate
statistics for subsets of data. See <code>vignette('interval-stats')</code> for
examples.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with the following columns:
</p>

<ul>
<li> <p><code>chrom</code> the name of chromosome tested if <code>by_chrom = TRUE</code>,
otherwise has a value of <code>whole_genome</code>
</p>
</li>
<li> <p><code>p.value</code> p-value from a binomial test. p-values &gt; 0.5
are converted to <code>1 - p-value</code> and <code>lower_tail</code> is <code>FALSE</code>
</p>
</li>
<li> <p><code>obs_exp_ratio</code> ratio of observed to expected overlap frequency
</p>
</li>
<li> <p><code>lower_tail</code> <code>TRUE</code> indicates the observed overlaps are in the lower tail
of the distribution (e.g., less overlap than expected). <code>FALSE</code> indicates
that the observed overlaps are in the upper tail of the distribution (e.g.,
more overlap than expected)
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529">https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002529</a>
</p>
<p>Other interval statistics: 
<code><a href="#topic+bed_absdist">bed_absdist</a>()</code>,
<code><a href="#topic+bed_fisher">bed_fisher</a>()</code>,
<code><a href="#topic+bed_jaccard">bed_jaccard</a>()</code>,
<code><a href="#topic+bed_reldist">bed_reldist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

x &lt;- bed_random(genome, seed = 1010486)
y &lt;- bed_random(genome, seed = 9203911)

bed_projection(x, y, genome)

bed_projection(x, y, genome, by_chrom = TRUE)

</code></pre>

<hr>
<h2 id='bed_random'>Generate randomly placed intervals on a genome.</h2><span id='topic+bed_random'></span>

<h3>Description</h3>

<p>Generate randomly placed intervals on a genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_random(genome, length = 1000, n = 1e+06, seed = 0, sorted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_random_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_random_+3A_length">length</code></td>
<td>
<p>length of intervals</p>
</td></tr>
<tr><td><code id="bed_random_+3A_n">n</code></td>
<td>
<p>number of intervals to generate</p>
</td></tr>
<tr><td><code id="bed_random_+3A_seed">seed</code></td>
<td>
<p>seed RNG for reproducible intervals</p>
</td></tr>
<tr><td><code id="bed_random_+3A_sorted">sorted</code></td>
<td>
<p>return sorted output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sorting can be suppressed with <code>sorted = FALSE</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/random.html">https://bedtools.readthedocs.io/en/latest/content/tools/random.html</a>
</p>
<p>Other randomizing operations: 
<code><a href="#topic+bed_shuffle">bed_shuffle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- tibble::tribble(
  ~chrom,  ~size,
  "chr1",  10000000,
  "chr2",  50000000,
  "chr3",  60000000,
  "chrX",  5000000
)

bed_random(genome, seed = 10104)

# sorting can be suppressed
bed_random(genome, sorted = FALSE, seed = 10104)

# 500 random intervals of length 500
bed_random(genome, length = 500, n = 500, seed = 10104)

</code></pre>

<hr>
<h2 id='bed_reldist'>Compute relative distances between intervals.</h2><span id='topic+bed_reldist'></span>

<h3>Description</h3>

<p>Compute relative distances between intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_reldist(x, y, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_reldist_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_reldist_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_reldist_+3A_detail">detail</code></td>
<td>
<p>report relative distances for each <code>x</code> interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interval statistics can be used in combination with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+do">dplyr::do()</a></code> to calculate
statistics for subsets of data. See <code>vignette('interval-stats')</code> for
examples.
</p>


<h3>Value</h3>

<p>If <code>detail = FALSE</code>, a <a href="#topic+ivl_df">ivl_df</a> that summarizes
calculated <code>.reldist</code> values with the following columns:
</p>

<ul>
<li> <p><code>.reldist</code> relative distance metric
</p>
</li>
<li> <p><code>.counts</code> number of metric observations
</p>
</li>
<li> <p><code>.total</code> total observations
</p>
</li>
<li> <p><code>.freq</code> frequency of observation
</p>
</li></ul>

<p>If <code>detail = TRUE</code>, the <code>.reldist</code> column reports the relative
distance for each input <code>x</code> interval.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/reldist.html">https://bedtools.readthedocs.io/en/latest/content/tools/reldist.html</a>
</p>
<p>Other interval statistics: 
<code><a href="#topic+bed_absdist">bed_absdist</a>()</code>,
<code><a href="#topic+bed_fisher">bed_fisher</a>()</code>,
<code><a href="#topic+bed_jaccard">bed_jaccard</a>()</code>,
<code><a href="#topic+bed_projection">bed_projection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

x &lt;- bed_random(genome, seed = 1010486)
y &lt;- bed_random(genome, seed = 9203911)

bed_reldist(x, y)

bed_reldist(x, y, detail = TRUE)

</code></pre>

<hr>
<h2 id='bed_shift'>Adjust intervals by a fixed size.</h2><span id='topic+bed_shift'></span>

<h3>Description</h3>

<p>Out-of-bounds intervals are removed by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_shift(x, genome, size = 0, fraction = 0, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_shift_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_shift_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_shift_+3A_size">size</code></td>
<td>
<p>number of bases to shift. positive numbers shift right, negative shift left.</p>
</td></tr>
<tr><td><code id="bed_shift_+3A_fraction">fraction</code></td>
<td>
<p>define <code>size</code> as a fraction of interval</p>
</td></tr>
<tr><td><code id="bed_shift_+3A_trim">trim</code></td>
<td>
<p>adjust coordinates for out-of-bounds intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/shift.html">https://bedtools.readthedocs.io/en/latest/content/tools/shift.html</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_slop">bed_slop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25, 50,
  "chr1", 100, 125
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 125
)

bed_glyph(bed_shift(x, genome, size = -20))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~strand,
  "chr1", 100,    150,  "+",
  "chr1", 200,    250,  "+",
  "chr2", 300,    350,  "+",
  "chr2", 400,    450,  "-",
  "chr3", 500,    550,  "-",
  "chr3", 600,    650,  "-"
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 1000,
  "chr2", 2000,
  "chr3", 3000
)

bed_shift(x, genome, 100)

bed_shift(x, genome, fraction = 0.5)

# shift with respect to strand
stranded &lt;- dplyr::group_by(x, strand)
bed_shift(stranded, genome, 100)

</code></pre>

<hr>
<h2 id='bed_shuffle'>Shuffle input intervals.</h2><span id='topic+bed_shuffle'></span>

<h3>Description</h3>

<p>Shuffle input intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_shuffle(
  x,
  genome,
  incl = NULL,
  excl = NULL,
  max_tries = 1000,
  within = FALSE,
  seed = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_shuffle_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_incl">incl</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> of included intervals</p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_excl">excl</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> of excluded intervals</p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_max_tries">max_tries</code></td>
<td>
<p>maximum tries to identify a bounded interval</p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_within">within</code></td>
<td>
<p>shuffle within chromosomes</p>
</td></tr>
<tr><td><code id="bed_shuffle_+3A_seed">seed</code></td>
<td>
<p>seed for reproducible intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/shuffle.html">https://bedtools.readthedocs.io/en/latest/content/tools/shuffle.html</a>
</p>
<p>Other randomizing operations: 
<code><a href="#topic+bed_random">bed_random</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 1e6,
  "chr2", 2e6,
  "chr3", 4e6
)

x &lt;- bed_random(genome, seed = 1010486)

bed_shuffle(x, genome, seed = 9830491)

</code></pre>

<hr>
<h2 id='bed_slop'>Increase the size of input intervals.</h2><span id='topic+bed_slop'></span>

<h3>Description</h3>

<p>Increase the size of input intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_slop(
  x,
  genome,
  both = 0,
  left = 0,
  right = 0,
  fraction = FALSE,
  strand = FALSE,
  trim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_slop_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_slop_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_slop_+3A_both">both</code></td>
<td>
<p>number of bases on both sizes</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_left">left</code></td>
<td>
<p>number of bases on left side</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_right">right</code></td>
<td>
<p>number of bases on right side</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_fraction">fraction</code></td>
<td>
<p>define flanks based on fraction of interval length</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_strand">strand</code></td>
<td>
<p>define <code>left</code> and <code>right</code> based on strand</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_trim">trim</code></td>
<td>
<p>adjust coordinates for out-of-bounds intervals</p>
</td></tr>
<tr><td><code id="bed_slop_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/slop.html">https://bedtools.readthedocs.io/en/latest/content/tools/slop.html</a>
</p>
<p>Other single set operations: 
<code><a href="#topic+bed_cluster">bed_cluster</a>()</code>,
<code><a href="#topic+bed_complement">bed_complement</a>()</code>,
<code><a href="#topic+bed_flank">bed_flank</a>()</code>,
<code><a href="#topic+bed_merge">bed_merge</a>()</code>,
<code><a href="#topic+bed_partition">bed_partition</a>()</code>,
<code><a href="#topic+bed_shift">bed_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 110,    120,
  "chr1", 225,    235
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 400
)

bed_glyph(bed_slop(x, genome, both = 20, trim = TRUE))

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 5000
)

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~name, ~score, ~strand,
  "chr1", 500, 1000, ".", ".", "+",
  "chr1", 1000, 1500, ".", ".", "-"
)

bed_slop(x, genome, left = 100)

bed_slop(x, genome, right = 100)

bed_slop(x, genome, both = 100)

bed_slop(x, genome, both = 0.5, fraction = TRUE)

</code></pre>

<hr>
<h2 id='bed_sort'>Sort a set of intervals.</h2><span id='topic+bed_sort'></span>

<h3>Description</h3>

<p>Sort a set of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_sort(x, by_size = FALSE, by_chrom = FALSE, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_sort_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_sort_+3A_by_size">by_size</code></td>
<td>
<p>sort by interval size</p>
</td></tr>
<tr><td><code id="bed_sort_+3A_by_chrom">by_chrom</code></td>
<td>
<p>sort within chromosome</p>
</td></tr>
<tr><td><code id="bed_sort_+3A_reverse">reverse</code></td>
<td>
<p>reverse sort order</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/sort.html">https://bedtools.readthedocs.io/en/latest/content/tools/sort.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr8", 500,    1000,
  "chr8", 1000,   5000,
  "chr8", 100,    200,
  "chr1", 100,    300,
  "chr1", 100,    200
)

# sort by chrom and start
bed_sort(x)

# reverse sort order
bed_sort(x, reverse = TRUE)

# sort by interval size
bed_sort(x, by_size = TRUE)

# sort by decreasing interval size
bed_sort(x, by_size = TRUE, reverse = TRUE)

# sort by interval size within chrom
bed_sort(x, by_size = TRUE, by_chrom = TRUE)

</code></pre>

<hr>
<h2 id='bed_subtract'>Subtract two sets of intervals.</h2><span id='topic+bed_subtract'></span>

<h3>Description</h3>

<p>Subtract <code>y</code> intervals from <code>x</code> intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_subtract(x, y, any = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_subtract_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_subtract_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_subtract_+3A_any">any</code></td>
<td>
<p>remove any <code>x</code> intervals that overlap <code>y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/subtract.html">https://bedtools.readthedocs.io/en/latest/content/tools/subtract.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_closest">bed_closest</a>()</code>,
<code><a href="#topic+bed_coverage">bed_coverage</a>()</code>,
<code><a href="#topic+bed_intersect">bed_intersect</a>()</code>,
<code><a href="#topic+bed_map">bed_map</a>()</code>,
<code><a href="#topic+bed_window">bed_window</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 1,      100
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 50,     75
)

bed_glyph(bed_subtract(x, y))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 100,    200,
  "chr1", 250,    400,
  "chr1", 500,    600,
  "chr1", 1000,   1200,
  "chr1", 1300,   1500
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 150,    175,
  "chr1", 510,    525,
  "chr1", 550,    575,
  "chr1", 900,    1050,
  "chr1", 1150,   1250,
  "chr1", 1299,   1501
)

bed_subtract(x, y)

bed_subtract(x, y, any = TRUE)

</code></pre>

<hr>
<h2 id='bed_window'>Identify intervals within a specified distance.</h2><span id='topic+bed_window'></span>

<h3>Description</h3>

<p>Identify intervals within a specified distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_window(x, y, genome, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_window_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_window_+3A_y">y</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bed_window_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bed_window_+3A_...">...</code></td>
<td>
<p>params for bed_slop and bed_intersect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>input tbls are grouped by <code>chrom</code> by default, and additional
groups can be added using <code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>. For example,
grouping by <code>strand</code> will constrain analyses to the same strand. To
compare opposing strands across two tbls, strands on the <code>y</code> tbl can
first be inverted using <code><a href="#topic+flip_strands">flip_strands()</a></code>.
</p>


<h3>See Also</h3>

<p><a href="https://bedtools.readthedocs.io/en/latest/content/tools/window.html">https://bedtools.readthedocs.io/en/latest/content/tools/window.html</a>
</p>
<p>Other multiple set operations: 
<code><a href="#topic+bed_closest">bed_closest</a>()</code>,
<code><a href="#topic+bed_coverage">bed_coverage</a>()</code>,
<code><a href="#topic+bed_intersect">bed_intersect</a>()</code>,
<code><a href="#topic+bed_map">bed_map</a>()</code>,
<code><a href="#topic+bed_subtract">bed_subtract</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 25,     50,
  "chr1", 100,    125
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 60,     75
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 125
)

bed_glyph(bed_window(x, y, genome, both = 15))

x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 10, 100,
  "chr2", 200, 400,
  "chr2", 300, 500,
  "chr2", 800, 900
)

y &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 150,    400,
  "chr2", 230,    430,
  "chr2", 350,    430
)

genome &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 500,
  "chr2", 1000
)

bed_window(x, y, genome, both = 100)

</code></pre>

<hr>
<h2 id='bed12_to_exons'>Convert BED12 to individual exons in BED6.</h2><span id='topic+bed12_to_exons'></span>

<h3>Description</h3>

<p>After conversion to BED6 format, the <code>score</code> column contains the exon
number, with respect to strand (i.e., the first exon for <code>-</code> strand
genes will have larger start and end coordinates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed12_to_exons(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed12_to_exons_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+bed_makewindows">bed_makewindows</a>()</code>,
<code><a href="#topic+bound_intervals">bound_intervals</a>()</code>,
<code><a href="#topic+flip_strands">flip_strands</a>()</code>,
<code><a href="#topic+interval_spacing">interval_spacing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_bed12(valr_example("mm9.refGene.bed.gz"))

bed12_to_exons(x)

</code></pre>

<hr>
<h2 id='bound_intervals'>Select intervals bounded by a genome.</h2><span id='topic+bound_intervals'></span>

<h3>Description</h3>

<p>Used to remove out-of-bounds intervals, or trim interval coordinates using a
<code>genome</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound_intervals(x, genome, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bound_intervals_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
<tr><td><code id="bound_intervals_+3A_genome">genome</code></td>
<td>
<p><a href="#topic+genome_df">genome_df</a></p>
</td></tr>
<tr><td><code id="bound_intervals_+3A_trim">trim</code></td>
<td>
<p>adjust coordinates for out-of-bounds intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+bed12_to_exons">bed12_to_exons</a>()</code>,
<code><a href="#topic+bed_makewindows">bed_makewindows</a>()</code>,
<code><a href="#topic+flip_strands">flip_strands</a>()</code>,
<code><a href="#topic+interval_spacing">interval_spacing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", -100,   500,
  "chr1", 100,    1e9,
  "chr1", 500,    1000
)

genome &lt;- read_genome(valr_example("hg19.chrom.sizes.gz"))

# out-of-bounds are removed by default ...
bound_intervals(x, genome)

# ... or can be trimmed within the bounds of a genome
bound_intervals(x, genome, trim = TRUE)

</code></pre>

<hr>
<h2 id='create_introns'>Create intron features.</h2><span id='topic+create_introns'></span>

<h3>Description</h3>

<p>Numbers in the <code>score</code> column are intron numbers from 5' to 3' independent of
strand. I.e., the first introns for <code>+</code> and <code>-</code> strand genes both have <code>score</code>
values of <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_introns(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_introns_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> in BED12 format</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other feature functions: 
<code><a href="#topic+create_tss">create_tss</a>()</code>,
<code><a href="#topic+create_utrs3">create_utrs3</a>()</code>,
<code><a href="#topic+create_utrs5">create_utrs5</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_bed12(valr_example("mm9.refGene.bed.gz"))

create_introns(x)

</code></pre>

<hr>
<h2 id='create_tss'>Create transcription start site features.</h2><span id='topic+create_tss'></span>

<h3>Description</h3>

<p>Create transcription start site features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tss(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tss_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> in BED format</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other feature functions: 
<code><a href="#topic+create_introns">create_introns</a>()</code>,
<code><a href="#topic+create_utrs3">create_utrs3</a>()</code>,
<code><a href="#topic+create_utrs5">create_utrs5</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_bed12(valr_example("mm9.refGene.bed.gz"))

create_tss(x)

</code></pre>

<hr>
<h2 id='create_utrs3'>Create 3' UTR features.</h2><span id='topic+create_utrs3'></span>

<h3>Description</h3>

<p>Create 3' UTR features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_utrs3(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_utrs3_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> in BED12 format</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other feature functions: 
<code><a href="#topic+create_introns">create_introns</a>()</code>,
<code><a href="#topic+create_tss">create_tss</a>()</code>,
<code><a href="#topic+create_utrs5">create_utrs5</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_bed12(valr_example("mm9.refGene.bed.gz"))

create_utrs3(x)

</code></pre>

<hr>
<h2 id='create_utrs5'>Create 5' UTR features.</h2><span id='topic+create_utrs5'></span>

<h3>Description</h3>

<p>Create 5' UTR features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_utrs5(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_utrs5_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a> in BED12 format</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other feature functions: 
<code><a href="#topic+create_introns">create_introns</a>()</code>,
<code><a href="#topic+create_tss">create_tss</a>()</code>,
<code><a href="#topic+create_utrs3">create_utrs3</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_bed12(valr_example("mm9.refGene.bed.gz"))

create_utrs5(x)

</code></pre>

<hr>
<h2 id='db'>Fetch data from remote databases.</h2><span id='topic+db'></span><span id='topic+db_ucsc'></span><span id='topic+db_ensembl'></span>

<h3>Description</h3>

<p>Currently <code>db_ucsc</code> and <code>db_ensembl</code> are available for connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_ucsc(
  dbname,
  host = "genome-mysql.cse.ucsc.edu",
  user = "genomep",
  password = "password",
  port = 3306,
  ...
)

db_ensembl(
  dbname,
  host = "ensembldb.ensembl.org",
  user = "anonymous",
  password = "",
  port = 3306,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_+3A_dbname">dbname</code></td>
<td>
<p>name of database</p>
</td></tr>
<tr><td><code id="db_+3A_host">host</code></td>
<td>
<p>hostname</p>
</td></tr>
<tr><td><code id="db_+3A_user">user</code></td>
<td>
<p>username</p>
</td></tr>
<tr><td><code id="db_+3A_password">password</code></td>
<td>
<p>password</p>
</td></tr>
<tr><td><code id="db_+3A_port">port</code></td>
<td>
<p>MySQL connection port</p>
</td></tr>
<tr><td><code id="db_+3A_...">...</code></td>
<td>
<p>params for connection</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://genome.ucsc.edu/goldenpath/help/mysql.html">https://genome.ucsc.edu/goldenpath/help/mysql.html</a>
</p>
<p><a href="https://www.ensembl.org/info/data/mysql.html">https://www.ensembl.org/info/data/mysql.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(RMariaDB)) {
  library(dplyr)
  ucsc &lt;- db_ucsc("hg38")

  # fetch the `refGene` tbl
  tbl(ucsc, "refGene")

  # the `chromInfo` tbls have size information
  tbl(ucsc, "chromInfo")
}

## End(Not run)
## Not run: 
if (require(RMariaDB)) {
  library(dplyr)
  # squirrel genome
  ensembl &lt;- db_ensembl("spermophilus_tridecemlineatus_core_67_2")

  tbl(ensembl, "gene")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='flip_strands'>Flip strands in intervals.</h2><span id='topic+flip_strands'></span>

<h3>Description</h3>

<p>Flips positive (<code>+</code>) stranded intervals to negative (<code>-</code>) strands,
and vice-versa. Facilitates comparisons among intervals on opposing strands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_strands(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_strands_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+bed12_to_exons">bed12_to_exons</a>()</code>,
<code><a href="#topic+bed_makewindows">bed_makewindows</a>()</code>,
<code><a href="#topic+bound_intervals">bound_intervals</a>()</code>,
<code><a href="#topic+interval_spacing">interval_spacing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end, ~strand,
  "chr1", 1,      100,  "+",
  "chr2", 1,      100,  "-"
)

flip_strands(x)

</code></pre>

<hr>
<h2 id='gr_to_bed'>Convert Granges to bed tibble</h2><span id='topic+gr_to_bed'></span>

<h3>Description</h3>

<p>Convert Granges to bed tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_to_bed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_to_bed_+3A_x">x</code></td>
<td>
<p>GRanges object to convert to bed tibble.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gr &lt;- GenomicRanges::GRanges(
  seqnames = S4Vectors::Rle(
    c("chr1", "chr2", "chr1", "chr3"),
    c(1, 1, 1, 1)
  ),
  ranges = IRanges::IRanges(
    start = c(1, 10, 50, 100),
    end = c(100, 500, 1000, 2000),
    names = head(letters, 4)
  ),
  strand = S4Vectors::Rle(
    c("-", "+"), c(2, 2)
  )
)

gr_to_bed(gr)

# There are two ways to convert a bed-like data.frame to GRanges:

gr &lt;- GenomicRanges::GRanges(
  seqnames = S4Vectors::Rle(x$chrom),
  ranges = IRanges::IRanges(
    start = x$start + 1,
    end = x$end,
    names = x$name
  ),
  strand = S4Vectors::Rle(x$strand)
)
# or:

gr &lt;- GenomicRanges::makeGRangesFromDataFrame(dplyr::mutate(x, start = start + 1))

## End(Not run)

</code></pre>

<hr>
<h2 id='id'>Plyr function id packaged due to plyr being retired
Compute a unique numeric id for each unique row in a data frame.</h2><span id='topic+id'></span>

<h3>Description</h3>

<p>Properties:
</p>

<ul>
<li> <p><code>order(id)</code> is equivalent to <code>do.call(order, df)</code>
</p>
</li>
<li><p> rows containing the same data have the same value
</p>
</li>
<li><p> if <code>drop = FALSE</code> then room for all possibilites
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>id(.variables, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_.variables">.variables</code></td>
<td>
<p>list of variables</p>
</td></tr>
<tr><td><code id="id_+3A_drop">drop</code></td>
<td>
<p>drop unusued factor levels?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with attribute n, giving total number of
possibilities
</p>


<h3>See Also</h3>

<p><code><a href="#topic+id_var">id_var</a></code>
</p>

<hr>
<h2 id='id_var'>Plyr function id_var packaged due to plyr being retired
Numeric id for a vector.</h2><span id='topic+id_var'></span>

<h3>Description</h3>

<p>Plyr function id_var packaged due to plyr being retired
Numeric id for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_var(x, drop = FALSE)
</code></pre>

<hr>
<h2 id='interval_spacing'>Calculate interval spacing.</h2><span id='topic+interval_spacing'></span>

<h3>Description</h3>

<p>Spacing for the first interval of each chromosome is undefined (<code>NA</code>). The
leading interval of an overlapping interval pair has a negative value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_spacing(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_spacing_+3A_x">x</code></td>
<td>
<p><a href="#topic+ivl_df">ivl_df</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a> with <code>.spacing</code> column.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+bed12_to_exons">bed12_to_exons</a>()</code>,
<code><a href="#topic+bed_makewindows">bed_makewindows</a>()</code>,
<code><a href="#topic+bound_intervals">bound_intervals</a>()</code>,
<code><a href="#topic+flip_strands">flip_strands</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 1,      100,
  "chr1", 150,    200,
  "chr2", 200,    300
)

interval_spacing(x)

</code></pre>

<hr>
<h2 id='ivl_df'>Bed-like data.frame requirements for valr functions</h2><span id='topic+ivl_df'></span><span id='topic+genome_df'></span><span id='topic+check_interval'></span><span id='topic+check_genome'></span>

<h3>Description</h3>

<p>Required column names for interval dataframes are
<code>chrom</code>, <code>start</code> and <code>end</code>. Internally interval dataframes are
validated using <code>check_interval()</code>
</p>
<p>Required column names for genome dataframes are
<code>chrom</code> and <code>size</code>. Internally genome dataframes are
validated using <code>check_genome()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_interval(x)

check_genome(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivl_df_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>tibble::tibble</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># using tibble
x &lt;- tibble::tribble(
  ~chrom, ~start, ~end,
  "chr1", 1, 50,
  "chr1", 10, 75,
  "chr1", 100, 120
)

check_interval(x)

# using base R data.frame
x &lt;- data.frame(
  chrom = "chr1",
  start = 0,
  end = 100,
  stringsAsFactors = FALSE
)

check_interval(x)

# example genome input

x &lt;- tibble::tribble(
  ~chrom, ~size,
  "chr1", 1e6
)

check_genome(x)

</code></pre>

<hr>
<h2 id='read_bed'>Read BED and related files.</h2><span id='topic+read_bed'></span><span id='topic+read_bed12'></span><span id='topic+read_bedgraph'></span><span id='topic+read_narrowpeak'></span><span id='topic+read_broadpeak'></span>

<h3>Description</h3>

<p>read functions for BED and related formats. Filenames can be
local file or URLs. The read functions load data into tbls with consistent
<code>chrom</code>, <code>start</code> and <code>end</code> colnames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bed(
  filename,
  col_types = bed12_coltypes,
  sort = TRUE,
  ...,
  n_fields = NULL
)

read_bed12(filename, ...)

read_bedgraph(filename, ...)

read_narrowpeak(filename, ...)

read_broadpeak(filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bed_+3A_filename">filename</code></td>
<td>
<p>file or URL</p>
</td></tr>
<tr><td><code id="read_bed_+3A_col_types">col_types</code></td>
<td>
<p>column type spec for <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code></p>
</td></tr>
<tr><td><code id="read_bed_+3A_sort">sort</code></td>
<td>
<p>sort the tbl by chrom and start</p>
</td></tr>
<tr><td><code id="read_bed_+3A_...">...</code></td>
<td>
<p>options to pass to <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code></p>
</td></tr>
<tr><td><code id="read_bed_+3A_n_fields">n_fields</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format1">https://genome.ucsc.edu/FAQ/FAQformat.html#format1</a>
</p>
<p><a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format1">https://genome.ucsc.edu/FAQ/FAQformat.html#format1</a>
</p>
<p><a href="https://genome.ucsc.edu/goldenPath/help/bedgraph.html">https://genome.ucsc.edu/goldenPath/help/bedgraph.html</a>
</p>
<p><a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format12">https://genome.ucsc.edu/FAQ/FAQformat.html#format12</a>
</p>
<p><a href="https://genome.ucsc.edu/FAQ/FAQformat.html#format13">https://genome.ucsc.edu/FAQ/FAQformat.html#format13</a>
</p>


<h3>Value</h3>

<p><a href="#topic+ivl_df">ivl_df</a>
</p>


<h3>See Also</h3>

<p>Other read functions: 
<code><a href="#topic+read_genome">read_genome</a>()</code>,
<code><a href="#topic+read_vcf">read_vcf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read_bed assumes 3 field BED format.
read_bed(valr_example("3fields.bed.gz"))

# result is sorted by chrom and start unless `sort = FALSE`
read_bed(valr_example("3fields.bed.gz"), sort = FALSE)


read_bed12(valr_example("mm9.refGene.bed.gz"))


read_bedgraph(valr_example("test.bg.gz"))


read_narrowpeak(valr_example("sample.narrowPeak.gz"))


read_broadpeak(valr_example("sample.broadPeak.gz"))

</code></pre>

<hr>
<h2 id='read_bigwig'>Import and convert a bigwig file into a valr compatible tbl</h2><span id='topic+read_bigwig'></span>

<h3>Description</h3>

<p>This function will output a 5 column tibble with
zero-based chrom, start, end, score, and strand columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bigwig(path, set_strand = "+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bigwig_+3A_path">path</code></td>
<td>
<p>path to bigWig file</p>
</td></tr>
<tr><td><code id="read_bigwig_+3A_set_strand">set_strand</code></td>
<td>
<p>strand to add to output (defaults to &quot;+&quot;)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This functions uses <code>rtracklayer</code> to import bigwigs which
has unstable support for the windows platform and therefore may error
for windows users (particularly for 32 bit window users).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (.Platform$OS.type != "windows") {
  bw &lt;- read_bigwig(valr_example("hg19.dnase1.bw"))
  head(bw)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='read_genome'>Read genome files.</h2><span id='topic+read_genome'></span>

<h3>Description</h3>

<p>Genome files (UCSC &quot;chromSize&quot; files) contain chromosome name and size
information. These sizes are used by downstream functions to identify
computed intervals that have coordinates outside of the genome bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_genome(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_genome_+3A_path">path</code></td>
<td>
<p>containing chrom/contig names and sizes, one-pair-per-line,
tab-delimited</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+genome_df">genome_df</a>, sorted by <code>size</code>
</p>


<h3>Note</h3>

<p>URLs to genome files can also be used.
</p>


<h3>See Also</h3>

<p>Other read functions: 
<code><a href="#topic+read_bed">read_bed</a>()</code>,
<code><a href="#topic+read_vcf">read_vcf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_genome(valr_example("hg19.chrom.sizes.gz"))

## Not run: 
# `read_genome` accepts a URL
read_genome("https://genome.ucsc.edu/goldenpath/help/hg19.chrom.sizes")

## End(Not run)

</code></pre>

<hr>
<h2 id='read_gtf'>Import and convert a GTF/GFF file into a valr compatible bed tbl format</h2><span id='topic+read_gtf'></span>

<h3>Description</h3>

<p>This function will output a tibble with the
required chrom, start, and end columns, as well as other columns depending
on content in GTF/GFF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gtf(path, zero_based = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gtf_+3A_path">path</code></td>
<td>
<p>path to gtf or gff file</p>
</td></tr>
<tr><td><code id="read_gtf_+3A_zero_based">zero_based</code></td>
<td>
<p>if TRUE, convert to zero based</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
gtf &lt;- read_gtf(valr_example("hg19.gencode.gtf.gz"))
head(gtf)

</code></pre>

<hr>
<h2 id='read_vcf'>Read a VCF file.</h2><span id='topic+read_vcf'></span>

<h3>Description</h3>

<p>Read a VCF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vcf(vcf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vcf_+3A_vcf">vcf</code></td>
<td>
<p>vcf filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data_frame</code>
</p>


<h3>Note</h3>

<p>return value has <code>chrom</code>, <code>start</code> and <code>end</code> columns.
Interval lengths are the size of the 'REF' field.
</p>


<h3>See Also</h3>

<p>Other read functions: 
<code><a href="#topic+read_bed">read_bed</a>()</code>,
<code><a href="#topic+read_genome">read_genome</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- valr_example("test.vcf.gz")
read_vcf(vcf_file)

</code></pre>

<hr>
<h2 id='valr'>valr: genome interval arithmetic in R</h2><span id='topic+valr'></span><span id='topic+valr-package'></span>

<h3>Description</h3>

<p>valr provides tools to read and manipulate intervals and signals on a genome
reference. valr was developed to facilitate interactive analysis of
genome-scale data sets, leveraging the power of dplyr and piping.
</p>


<h3>Details</h3>

<p>To learn more about valr, start with the vignette:
<code>browseVignettes(package = "valr")</code>
</p>


<h3>Author(s)</h3>

<p>Jay Hesselberth <a href="mailto:jay.hesselberth@gmail.com">jay.hesselberth@gmail.com</a>
</p>
<p>Kent Riemondy <a href="mailto:kent.riemondy@gmail.com">kent.riemondy@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Report bugs at <a href="https://github.com/rnabioco/valr/issues">https://github.com/rnabioco/valr/issues</a>
</p>

<hr>
<h2 id='valr_example'>Provide working directory for valr example files.</h2><span id='topic+valr_example'></span>

<h3>Description</h3>

<p>Provide working directory for valr example files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valr_example(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valr_example_+3A_path">path</code></td>
<td>
<p>path to file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>valr_example("hg19.chrom.sizes.gz")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
