<!DOCTYPE html><html><head><title>Help for package cdmTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cdmTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CA.MI'><p>Calculate corrected classification accuracy with multiple imputation</p></a></li>
<li><a href='#estQ'><p>Empirical Q-matrix estimation</p></a></li>
<li><a href='#genQ'><p>Generate Q-matrix</p></a></li>
<li><a href='#GNPC'><p>General nonparametric classification method</p></a></li>
<li><a href='#is.Qid'><p>Check whether a Q-matrix is identifiable</p></a></li>
<li><a href='#missQ'><p>Introduce random misspecifications in Q-matrix</p></a></li>
<li><a href='#modelcompK'><p>CDM fit comparison - dimensionality assessment method</p></a></li>
<li><a href='#orderQ'><p>Reorder Q-matrix columns</p></a></li>
<li><a href='#paK'><p>Parallel analysis - dimensionality assessment method</p></a></li>
<li><a href='#personFit'><p>Calculate standardized log-likelihood statistic (lZ) for person fit evaluation</p></a></li>
<li><a href='#RDINA'><p>Restricted DINA model</p></a></li>
<li><a href='#RDINA2GDINA'><p>Translate RDINA object into GDINA object</p></a></li>
<li><a href='#valQ'><p>Empirical Q-matrix validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Useful Tools for Cognitive Diagnosis Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides useful tools for cognitive diagnosis modeling (CDM). The package includes functions for empirical Q-matrix estimation and validation, such as the Hull method (Nájera, Sorrel, de la Torre, &amp; Abad, 2021, &lt;<a href="https://doi.org/10.1111%2Fbmsp.12228">doi:10.1111/bmsp.12228</a>&gt;) and the discrete factor loading method (Wang, Song, &amp; Ding, 2018, &lt;<a href="https://doi.org/10.1007%2F978-3-319-77249-3_29">doi:10.1007/978-3-319-77249-3_29</a>&gt;). It also contains dimensionality assessment procedures for CDM, including parallel analysis and automated fit comparison as explored in Nájera, Abad, and Sorrel (2021, &lt;<a href="https://doi.org/10.3389%2Ffpsyg.2021.614470">doi:10.3389/fpsyg.2021.614470</a>&gt;). Other relevant methods and features for CDM applications, such as the restricted DINA model (Nájera et al., 2023; &lt;<a href="https://doi.org/10.3102%2F10769986231158829">doi:10.3102/10769986231158829</a>&gt;), the general nonparametric classification method (Chiu et al., 2018; &lt;<a href="https://doi.org/10.1007%2Fs11336-017-9595-4">doi:10.1007/s11336-017-9595-4</a>&gt;), and corrected estimation of the classification accuracy via multiple imputation (Kreitchmann et al., 2022; &lt;<a href="https://doi.org/10.3758%2Fs13428-022-01967-5">doi:10.3758/s13428-022-01967-5</a>&gt;) are also available. Lastly, the package provides some useful functions for CDM simulation studies, such as random Q-matrix generation and detection of complete/identified Q-matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>GDINA (&ge; 2.8.0), ggplot2 (&ge; 3.3.0), psych (&ge; 1.9.12), sirt
(&ge; 3.9-4), parallel (&ge; 3.6.3), stats (&ge; 3.6.3), GPArotation
(&ge; 2014.11-1), combinat (&ge; 0.0-8), fungible, foreach, doSNOW</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pablo-najera/cdmTools">https://github.com/pablo-najera/cdmTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pablo-najera/cdmTools/issues">https://github.com/pablo-najera/cdmTools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Pablo Nájera [aut, cre, cph],
  Miguel A. Sorrel [aut, cph],
  Francisco J. Abad [aut, cph],
  Rodrigo S. Kreitchmann [ctb],
  Kevin Santos [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pablo Nájera &lt;pnajera@comillas.edu&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 07:10:10 UTC; pnajera</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CA.MI'>Calculate corrected classification accuracy with multiple imputation</h2><span id='topic+CA.MI'></span>

<h3>Description</h3>

<p>This function calculates the test-, pattern-, and attribute-level classification accuracy indices based on integrated posterior probabilities from multiple imputed item parameters (Kreitchmann et al., 2022).
The classification accuracy indices are the ones developed by Iaconangelo (2017) and Wang et al. (2015).
It is only applicable to dichotomous attributes. The function is built upon the <code>CA</code> function from the <code>GDINA</code> package (Ma &amp; de la Torre, 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA.MI(fit, what = "EAP", R = 500, n.cores = 1, verbose = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA.MI_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>RDINA</code> or <code>GDINA</code> (Ma &amp; de la Torre, 2020).</p>
</td></tr>
<tr><td><code id="CA.MI_+3A_what">what</code></td>
<td>
<p>What attribute estimates are used? The default is <code>"EAP"</code>.</p>
</td></tr>
<tr><td><code id="CA.MI_+3A_r">R</code></td>
<td>
<p>Number of bootstrap samples and imputations. The default is 500.</p>
</td></tr>
<tr><td><code id="CA.MI_+3A_n.cores">n.cores</code></td>
<td>
<p>Number of processors to use to speed up multiple imputation. The default is 2.</p>
</td></tr>
<tr><td><code id="CA.MI_+3A_verbose">verbose</code></td>
<td>
<p>Show progress. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="CA.MI_+3A_seed">seed</code></td>
<td>
<p>A seed for obtaining consistent results. If <code>NULL</code>, no seed is used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CA.MI</code> returns an object of class <code>CA</code>, with a list of elements:
</p>

<dl>
<dt><code>tau</code></dt><dd><p>Estimated test-level classification accuracy, see Iaconangelo (2017, Eq 2.2) (<code>vector</code>).</p>
</dd>
<dt><code>tau_l</code></dt><dd><p>Estimated pattern-level classification accuracy, see Iaconangelo (2017, p. 13) (<code>vector</code>).</p>
</dd>
<dt><code>tau_k</code></dt><dd><p>Estimated attribute-level classification accuracy, see Wang, et al (2015, p. 461 Eq 6) (<code>vector</code>).</p>
</dd>
<dt><code>CCM</code></dt><dd><p>Conditional classification matrix, see Iaconangelo (2017, p. 13) (<code>matrix</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Rodrigo S. Kreitchmann, Universidad Nacional de Educación a Distancia
</p>


<h3>References</h3>

<p>Iaconangelo, C.(2017). <em>Uses of classification error probabilities in the three-step approach to estimating cognitive diagnosis models</em>. (Unpublished doctoral dissertation). New Brunswick, NJ: Rutgers University.
</p>
<p>Kreitchmann, R. S., de la Torre, J., Sorrel, M. A., Nájera, P., &amp; Abad, F. J. (2022). Improving reliability estimation in cognitive diagnosis modeling. <em>Behavior Research Methods</em>. https://doi.org/10.3758/s13428-022-01967-5
</p>
<p>Ma, W., &amp; de la Torre, J. (2020). GDINA: An R package for cognitive diagnosis modeling. <em>Journal of Statistical Software</em>, <em>93</em>(14). https://doi.org/10.18637/jss.v093.i14
</p>
<p>Wang, W., Song, L., Chen, P., Meng, Y., &amp; Ding, S. (2015). Attribute-level and pattern-level classification consistency and accuracy indices for cognitive diagnostic assessment. <em>Journal of Educational Measurement</em>, <em>52</em> , 457-476.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
dat &lt;- sim10GDINA$simdat[1:100,]
Q &lt;- sim10GDINA$simQ
fit &lt;- GDINA(dat = dat, Q = Q, model = "GDINA")
ca.mi &lt;- CA.MI(fit)
ca.mi

</code></pre>

<hr>
<h2 id='estQ'>Empirical Q-matrix estimation</h2><span id='topic+estQ'></span>

<h3>Description</h3>

<p>Empirical Q-matrix estimation based on the <em>discrete factor loading</em> method (Wang, Song, &amp; Ding, 2018) as used in Nájera, Abad, and Sorrel (2021).
Apart from the conventional dichotomization criteria, the procedure based on loading differences described in Garcia-Garzon, Abad, and Garrido (2018) is also available.
Furthermore, the bagging bootstrap implementation (Xu &amp; Shang, 2018) can be applied; it is recommended when working with small sample sizes.
The <code>psych</code> package (Revelle, 2020) is used for estimating the required exploratory factor analysis (EFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estQ(
  r,
  K,
  n.obs = NULL,
  criterion = "row",
  boot = FALSE,
  efa.args = list(cor = "tet", rotation = "oblimin", fm = "uls"),
  boot.args = list(N = 0.8, R = 100, verbose = TRUE, seed = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estQ_+3A_r">r</code></td>
<td>
<p>A correlation matrix or raw data (<code>matrix</code> or <code>data.frame</code>). If a correlation matrix is used, it must have dimensions <em>J</em> items × <em>J</em> items. Please note that tetrachoric or polychoric correlations should be used when working with dichotomous or polytomous items, respectively. If raw data is used, it must have dimensions <em>N</em> individuals × <em>J</em> items. Missing values need to be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="estQ_+3A_k">K</code></td>
<td>
<p>Number of attributes to use.</p>
</td></tr>
<tr><td><code id="estQ_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of individuals if <code>r</code> is a correlation matrix. If <code>n.obs</code> is provided, <code>r</code> will be treated as a correlation matrix. Use <code>NULL</code> if <code>r</code> is raw data. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estQ_+3A_criterion">criterion</code></td>
<td>
<p>Dichotomization criterion to transform the factor loading matrix into the Q-matrix. The possible options include <code>"row"</code> (for row means), <code>"col"</code> (for column means), <code>"loaddiff"</code> (for the procedure based on loading differences), or a value between 0 and 1 (for a specific threshold). The default is <code>"row"</code>.</p>
</td></tr>
<tr><td><code id="estQ_+3A_boot">boot</code></td>
<td>
<p>Apply the bagging bootstrap implementation? Only available if <code>r</code> is raw data. If <code>FALSE</code>, the EFA will be applied once using the whole sample size. If <code>TRUE</code>, several EFAs will be applied with different subsamples; the estimated Q-matrix will be dichotomized from the bootstrapped Q-matrix, but the EFA fit indices, factor loadings, and communalities will be computed from the EFA with the whole sample size. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estQ_+3A_efa.args">efa.args</code></td>
<td>
<p>A list of arguments for the EFA estimation:
</p>

<dl>
<dt><code>cor</code></dt><dd><p>Type of correlations to use. It includes <code>"cor"</code> (for Pearson correlations) and <code>"tet"</code> (for tetrachoric/polychoric correlations), among others. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"tet"</code>.</p>
</dd>
<dt><code>rotation</code></dt><dd><p>Rotation procedure to use. It includes <code>"oblimin"</code>, <code>"varimax"</code>, and <code>"promax"</code>, among others. An oblique rotation procedure is usually recommended. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"oblimin"</code>.</p>
</dd>
<dt><code>fm</code></dt><dd><p>Factoring method to use. It includes <code>"uls"</code> (for unweighted least squares), <code>"ml"</code> (for maximum likelihood), and <code>"wls"</code> (for weighted least squares), among others. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"uls"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estQ_+3A_boot.args">boot.args</code></td>
<td>
<p>A list of arguments for the bagging bootstrap implementation (ignored if <code>boot = FALSE</code>):
</p>

<dl>
<dt><code>N</code></dt><dd><p>Sample size (or proportion of the total sample size, if lower than 1) to use in each bootstrap replication. The default is .8.</p>
</dd>
<dt><code>R</code></dt><dd><p>Number of bootstrap replications. The default is 100.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Show progress? The default is <code>TRUE</code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>A seed for obtaining consistent results. If <code>NULL</code>, no seed is used. The default is <code>NULL</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estQ</code> returns an object of class <code>estQ</code>.
</p>

<dl>
<dt><code>est.Q</code></dt><dd><p>Estimated Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>efa.loads</code></dt><dd><p>Factor loading matrix (<code>matrix</code>).</p>
</dd>
<dt><code>efa.comm</code></dt><dd><p>EFA communalities (<code>vector</code>).</p>
</dd>
<dt><code>efa.fit</code></dt><dd><p>EFA model fit indices (<code>vector</code>).</p>
</dd>
<dt><code>boot.Q</code></dt><dd><p>Bagging bootstrap Q-matrix before dichotomization. Only if <code>boot = TRUE</code> (<code>matrix</code>).</p>
</dd>
<dt><code>is.Qid</code></dt><dd><p>Q-matrix identifiability information (<code>list</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Garcia-Garzon, E., Abad, F. J., &amp; Garrido, L. E. (2018). Improving bi-factor exploratory modelling: Empirical target rotation based on loading differences. <em>Methodology</em>, <em>15</em>, 45–55. https://doi.org/10.1027/1614-2241/a000163
</p>
<p>Nájera, P., Abad, F. J., &amp; Sorrel, M. A. (2021). Determining the number of attributes in cognitive diagnosis modeling. <em>Frontiers in Psychology</em>, <em>12</em>:614470. https://doi.org/10.3389/fpsyg.2021.614470
</p>
<p>Revelle, W. (2019). <em>psych: Procedures for Psychological, Psychometric, and Personality Research</em>. R package version 1.9.12. https://CRAN.R-project.org/package=psych.
</p>
<p>Wang, W., Song, L., &amp; Ding, S. (2018). An exploratory discrete factor loading method for Q-matrix specification in cognitive diagnosis models. In: M. Wilberg, S. Culpepper, R. Janssen, J. Gonzalez, &amp; D. Molenaar (Eds.), <em>Quantitative Psychology. IMPS 2017. Springer Proceedings in Mathematics &amp; Statistics</em> (Vol. 233, pp. 351–362). Springer.
</p>
<p>Xu, G., &amp; Shang, Z. (2018). Identifying latent structures in restricted latent class models. <em>Journal of the American Statistical Association</em>, <em>113</em>, 1284–1295. https://doi.org/10.1080/01621459.2017.1340889
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GDINA)
dat &lt;- sim30GDINA$simdat
Q &lt;- sim30GDINA$simQ

#------------------------------
# Using default specifications
#------------------------------
sugQ1 &lt;- estQ(r = dat, K = 5) # Estimate Q-matrix
sugQ1$est.Q &lt;- orderQ(sugQ1$est.Q, Q)$order.Q # Reorder Q-matrix attributes
mean(sugQ1$est.Q == Q) # Check similarity with the generating Q-matrix

#------------------------------------
# Using the bagging bootstrap method
#------------------------------------
# In boot.args argument, R &gt;= 100 is recommended (R = 20 is here used for illustration purposes)
sugQ2 &lt;- estQ(r = dat, K = 5, boot = TRUE, boot.args = list(R = 20, seed = 123)) # Estimate Q-matrix
sugQ2$est.Q &lt;- orderQ(sugQ2$est.Q, Q)$order.Q # Reorder Q-matrix attributes
sugQ2$boot.Q # Proportion of replicas a q-entry was specified in the estimated Q-matrix
mean(sugQ2$est.Q == Q) # Check similarity with the generating Q-matrix
</code></pre>

<hr>
<h2 id='genQ'>Generate Q-matrix</h2><span id='topic+genQ'></span>

<h3>Description</h3>

<p>Generates a Q-matrix.
The criteria from Chen, Liu, Xu, &amp; Ying (2015) and Xu &amp; Shang (2018) can be used to generate identifiable Q-matrices.
Only binary Q-matrix are supported so far.
Useful for simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genQ(J, K, Kj, I = 2, min.JK = 3, max.Kcor = 1, Qid = "none", seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genQ_+3A_j">J</code></td>
<td>
<p>Number of items.</p>
</td></tr>
<tr><td><code id="genQ_+3A_k">K</code></td>
<td>
<p>Number of attributes.</p>
</td></tr>
<tr><td><code id="genQ_+3A_kj">Kj</code></td>
<td>
<p>A vector specifying the number (or proportion, if summing up to 1) of items measuring 1, 2, 3, ..., attributes. The first element of the vector determines the number (or proportion) of items measuring 1 attribute, and so on. See <code>Examples</code>.</p>
</td></tr>
<tr><td><code id="genQ_+3A_i">I</code></td>
<td>
<p>Number of identity matrices to include in the Q-matrix (up to column permutation). The default is 2.</p>
</td></tr>
<tr><td><code id="genQ_+3A_min.jk">min.JK</code></td>
<td>
<p>Minimum number of items measuring each attribute. It can be overwritten by <code>I</code>, if <code>I</code> is higher than <code>min.JK</code>. The default is 3.</p>
</td></tr>
<tr><td><code id="genQ_+3A_max.kcor">max.Kcor</code></td>
<td>
<p>Maximum allowed tetrachoric correlation among the columns to avoid overlapping (Nájera, Sorrel, de la Torre, &amp; Abad, 2020). The default is 1.</p>
</td></tr>
<tr><td><code id="genQ_+3A_qid">Qid</code></td>
<td>
<p>Assure that the generated Q-matrix is generically identifiable. It includes <code>"none"</code> (for no identifiability assurance), <code>"DINA"</code>, <code>"DINO"</code>, or <code>"others"</code> (for other CDMs identifiability). The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="genQ_+3A_seed">seed</code></td>
<td>
<p>A seed for obtaining consistent results. If <code>NULL</code>, no seed is used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genQ</code> returns an object of class <code>genQ</code>.
</p>

<dl>
<dt><code>gen.Q</code></dt><dd><p>The generated Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>JK</code></dt><dd><p>Number of items measuring each attribute (<code>vector</code>).</p>
</dd>
<dt><code>Kcor</code></dt><dd><p>Tetrachoric correlations among the columns (<code>matrix</code>).</p>
</dd>
<dt><code>is.Qid</code></dt><dd><p>Q-matrix identifiability information (<code>list</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Chen, Y., Liu, J., Xu, G., &amp; Ying, Z. (2015). Statistical analysis of Q-matrix based diagnostic classification models. <em>Journal of the American Statistical Association</em>, <em>110</em>, 850-866. https://doi.org/10.1080/01621459.2014.934827
</p>
<p>Nájera, P., Sorrel, M. A., de la Torre, J., &amp; Abad, F. J. (2020). Balancing fit and parsimony to improve Q-matrix validation. <em>British Journal of Mathematical and Statistical Psychology</em>. https://doi.org/10.1111/bmsp.12228
</p>
<p>Xu, G., &amp; Shang, Z. (2018). Identifying latent structures in restricted latent class models. <em>Journal of the American Statistical Association</em>, <em>113</em>, 1284-1295. https://doi.org/10.1080/01621459.2017.1340889
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kj &lt;- c(15, 10, 0, 5) # 15 one-att, 10 2-atts, 0 3-atts, and 5 four-atts items
Q &lt;- genQ(J = 30, K = 4, Kj = Kj, Qid = "others", seed = 123)
</code></pre>

<hr>
<h2 id='GNPC'>General nonparametric classification method</h2><span id='topic+GNPC'></span>

<h3>Description</h3>

<p>Attribute profile estimation using the <em>general nonparametric classification method</em> (GNPC; Chiu, Sun, &amp; Bian, 2018).
The GNPC can be considered as a robust alternative to the parametric G-DINA model with low sample sizes.
The <code>AlphaNP</code> function from the <code>NPCD</code> package (Zheng &amp; Chiu, 2019; Chiu, Sun, &amp; Bian, 2018) using weighted Hamming distances is used to initiate the procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GNPC(
  dat,
  Q,
  initiate = "AND",
  min.change = 0.001,
  maxitr = 1000,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GNPC_+3A_dat">dat</code></td>
<td>
<p>A <em>N</em> individuals x <em>J</em> items (<code>matrix</code> or <code>data.frame</code>). Missing values need to be coded as <code>NA</code>. Caution is advised if missing data are present.</p>
</td></tr>
<tr><td><code id="GNPC_+3A_q">Q</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="GNPC_+3A_initiate">initiate</code></td>
<td>
<p>Should the conjunctive (<code>"AND"</code>) or disjunctive (<code>"OR"</code>) NPC be used to initiate the procedure? Default is <code>"AND"</code>.</p>
</td></tr>
<tr><td><code id="GNPC_+3A_min.change">min.change</code></td>
<td>
<p>Minimum proportion of modified attribute profiles to use as a stopping criterion. Default is .001.</p>
</td></tr>
<tr><td><code id="GNPC_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations. Default is 1000.</p>
</td></tr>
<tr><td><code id="GNPC_+3A_verbose">verbose</code></td>
<td>
<p>Print information after each iteration. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GNPC</code> returns an object of class <code>GNPC</code>.
</p>

<dl>
<dt><code>alpha.est</code></dt><dd><p>Estimated attribute profiles (<code>matrix</code>).</p>
</dd>
<dt><code>loss.matrix</code></dt><dd><p>The distances between the weighted ideal responses from each latent class (rows) and examinees' observed responses (columns) (<code>matrix</code>).</p>
</dd>
<dt><code>eta.w</code></dt><dd><p>The weighted ideal responses for each latent class (rows) on each item (columns) (<code>matrix</code>).</p>
</dd>
<dt><code>w</code></dt><dd><p>The estimated weights, used to compute the weighted ideal responses (<code>matrix</code>).</p>
</dd>
<dt><code>n.ite</code></dt><dd><p>Number of iterations required to achieve convergence (<code>double</code>).</p>
</dd>
<dt><code>hist.change</code></dt><dd><p>Proportion of modified attribute profiles in each iteration (<code>vector</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Chiu, C.-Y., &amp; Douglas, J. (2013). A nonparametric approach to cognitive diagnosis by proximity to ideal response patterns. <em>Journal of Classification</em>, <em>30</em>, 225-250. DOI: 10.1007/s00357-013-9132-9
</p>
<p>Chiu, C.-Y., Sun, Y., &amp; Bian, Y. (2018). Cognitive diagnosis for small education programs: The general nonparametric classification method. <em>Psychometrika</em>, <em>83</em>, 355-375. DOI: 10.1007/s11336-017-9595-4
</p>
<p>Zheng, Y., &amp; Chiu, C.-Y. (2019). <em>NPCD: Nonparametric methods for cognitive diagnosis</em>. R package version 1.0-11. https://cran.r-project.org/web/packages/NPCD/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
Q &lt;- sim30GDINA$simQ # Q-matrix
K &lt;- ncol(Q)
J &lt;- nrow(Q)
set.seed(123)
GS &lt;- data.frame(guessing = rep(0.1, J), slip = rep(0.1, J))
sim &lt;- simGDINA(200, Q, GS)
simdat &lt;- sim$dat # Simulated data
simatt &lt;- sim$attribute # Generating attributes
fit.GNPC &lt;- GNPC(simdat, Q) # Apply the GNPC method
ClassRate(fit.GNPC$alpha.est, simatt) # Check classification accuracy

</code></pre>

<hr>
<h2 id='is.Qid'>Check whether a Q-matrix is identifiable</h2><span id='topic+is.Qid'></span>

<h3>Description</h3>

<p>Checks whether a Q-matrix fulfills the conditions for strict and generic identifiability according to Gu &amp; Xu (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Qid(Q, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Qid_+3A_q">Q</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="is.Qid_+3A_model">model</code></td>
<td>
<p>CDM to be considered. It includes <code>"DINA"</code>, <code>"DINO"</code>, or <code>"others"</code> (for other CDMs; e.g., G-DINA, A-CDM).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.Qid</code> returns an object of class <code>is.Qid</code>.
</p>

<dl>
<dt><code>strict</code></dt><dd><p>Is the Q-matrix strictly identifiable? (<code>logical</code>).</p>
</dd>
<dt><code>generic</code></dt><dd><p>Is the Q-matrix generically identifiable?  (<code>logical</code>).</p>
</dd>
<dt><code>conditions</code></dt><dd><p>Identifiability criteria and whether they are fulfilled or not (<code>vector</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas <br /> Miguel A. Sorrel, Universidad Autónoma de Madrid
</p>


<h3>References</h3>

<p>Gu, Y., &amp; Xu, G. (2021). Sufficient and necessary conditions for the identifiability of the Q-matrix. <em>Statistica Sinica</em>, <em>31</em>, 449-472. https://www.jstor.org/stable/26969691
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kj &lt;- c(15, 10, 0, 5)
Q &lt;- genQ(J = 30, K = 4, Kj = Kj, Qid = "others", seed = 123)$gen.Q
idQ &lt;- is.Qid(Q, model = "DINA")
</code></pre>

<hr>
<h2 id='missQ'>Introduce random misspecifications in Q-matrix</h2><span id='topic+missQ'></span>

<h3>Description</h3>

<p>Introduces random misspecifications in a Q-matrix.
Only binary Q-matrix are supported so far.
Useful for simulation studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missQ(Q, qjk, retainJ = 0, Qid = "none", seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missQ_+3A_q">Q</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="missQ_+3A_qjk">qjk</code></td>
<td>
<p>Number (or proportion, if lower than 1) of q-entries to modify in the Q-matrix.</p>
</td></tr>
<tr><td><code id="missQ_+3A_retainj">retainJ</code></td>
<td>
<p>Number of items to retain (i.e., not modify) in the Q-matrix. It will retain the first <code>retainJ</code> items. It is useful for assuring the completeness of the misspecified Q-matrix if the first items conform one or more identity matrices. The default is 0.</p>
</td></tr>
<tr><td><code id="missQ_+3A_qid">Qid</code></td>
<td>
<p>Assure that the generated Q-matrix is generically identifiable. It includes <code>"none"</code> (for no identifiability assurance), <code>"DINA"</code>, <code>"DINO"</code>, or <code>"others"</code> (for other CDMs identifiability). The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="missQ_+3A_seed">seed</code></td>
<td>
<p>A seed for obtaining consistent results. If <code>NULL</code>, no seed is used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>missQ</code> returns an object of class <code>missQ</code>.
</p>

<dl>
<dt><code>miss.Q</code></dt><dd><p>The misspecified Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>Q</code></dt><dd><p>The input (true) Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>JK</code></dt><dd><p>Number of items measuring each attribute (<code>vector</code>).</p>
</dd>
<dt><code>Kcor</code></dt><dd><p>Tetrachoric correlations among the columns (<code>matrix</code>).</p>
</dd>
<dt><code>is.Qid</code></dt><dd><p>Q-matrix identifiability information (<code>list</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Xu, G., &amp; Shang, Z. (2018). Identifying latent structures in restricted latent class models. <em>Journal of the American Statistical Association</em>, <em>113</em>, 1284-1295. https://doi.org/10.1080/01621459.2017.1340889
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kj &lt;- c(15, 10, 0, 5) # 15 one-att, 10 2-atts, 0 3-atts, and 5 four-atts items
Q &lt;- genQ(J = 30, K = 4, Kj = Kj, Qid = "others", seed = 123)
miss.Q &lt;- missQ(Q = Q$gen.Q, qjk = .20, retainJ = 4, seed = 123)
</code></pre>

<hr>
<h2 id='modelcompK'>CDM fit comparison - dimensionality assessment method</h2><span id='topic+modelcompK'></span>

<h3>Description</h3>

<p>A procedure for determining the number of attributes underlying CDM using model fit comparison.
For each number of attributes under exploration, a Q-matrix is estimated from the data using the <em>discrete factor loading</em> method (Wang, Song, &amp; Ding, 2018), which can be further validated using the <em>Hull</em> method (Nájera, Sorrel, de la Torre, &amp; Abad, 2020).
Then, a CDM is fitted to the data using the resulting Q-matrix, and several fit indices are computed.
After the desired range of number of attributes has been explored, the fit indices are compared.
A suggested number of attributes is given for each fit index.
The AIC index should be preferred among the other fit indices.
For further details, see Nájera, Abad, &amp; Sorrel (2021).
This function can be also used by directly providing different Q-matrices (instead of estimating them from the data) in order to compare their fit and select the most appropriate Q-matrix.
Note that, if Q-matrices are provided, this function will no longer serve as a dimensionality assessment method, but just as an automated model comparison procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelcompK(
  dat,
  exploreK = 1:7,
  Qs = NULL,
  stop = "none",
  val.Q = TRUE,
  estQ.args = list(criterion = "row", cor = "tet", rotation = "oblimin", fm = "uls"),
  valQ.args = list(index = "PVAF", iterative = "test.att", maxitr = 5, CDMconv = 0.01),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelcompK_+3A_dat">dat</code></td>
<td>
<p>A <em>N</em> individuals x <em>J</em> items (<code>matrix</code> or <code>data.frame</code>). Missing values need to be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="modelcompK_+3A_explorek">exploreK</code></td>
<td>
<p>Number of attributes to explore. The default is from 1 to 7 attributes.</p>
</td></tr>
<tr><td><code id="modelcompK_+3A_qs">Qs</code></td>
<td>
<p>A list of Q-matrices to compare in terms of fit. If <code>Qs</code> is used, <code>exploreK</code> is ignored.</p>
</td></tr>
<tr><td><code id="modelcompK_+3A_stop">stop</code></td>
<td>
<p>A fit index to use for stopping the procedure if a model leads to worse fit than a simpler one. This can be useful for saving time without exploring the whole exploreK when it is probable that the correct dimensionality has been already visited. It includes <code>"AIC"</code>, <code>"BIC"</code>, <code>"CAIC"</code>, <code>"SABIC"</code>, <code>"M2"</code>, <code>"SRMSR"</code>, <code>"RMSEA2"</code>, or <code>"sig.item.pairs"</code>. The latter represents the number of items that show bad fit with at least another item based on the transformed correlations (see <code>itemfit</code> function in the <code>GDINA</code> package; Ma &amp; de la Torre, 2020). It can be also <code>"none"</code>, which means that the whole <code>exploreK</code> will be examined. The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="modelcompK_+3A_val.q">val.Q</code></td>
<td>
<p>Validate the estimated Q-matrices using the <em>Hull</em> method? Note that validating the Q-matrix is expected to increase its quality, but the computation time will increase. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="modelcompK_+3A_estq.args">estQ.args</code></td>
<td>
<p>A list of arguments for the <em>discrete factor loading</em> empirical Q-matrix estimation method (see the <code>estQ</code> function):
</p>

<dl>
<dt><code>criterion</code></dt><dd><p>Dichotomization criterion to transform the factor loading matrix into the Q-matrix. The possible options include <code>"row"</code> (for row means), <code>"col"</code> (for column means), <code>"loaddiff"</code> (for the procedure based on loading differences), or a value between 0 and 1 (for a specific threshold). The default is <code>"row"</code>.</p>
</dd>
<dt><code>cor</code></dt><dd><p>Type of correlations to use. It includes <code>"cor"</code> (for Pearson correlations) and <code>"tet"</code> (for tetrachoric/polychoric correlations), among others. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"tet"</code>.</p>
</dd>
<dt><code>rotation</code></dt><dd><p>Rotation procedure to use. It includes <code>"oblimin"</code>, <code>"varimax"</code>, and <code>"promax"</code>, among others. An oblique rotation procedure is usually recommended. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"oblimin"</code>.</p>
</dd>
<dt><code>fm</code></dt><dd><p>Factoring method to use. It includes <code>"uls"</code> (for unweighted least squares), <code>"ml"</code> (for maximum likelihood), and <code>"wls"</code> (for weighted least squares), among others. See <code>fa</code> function from the <code>psych</code> R package for additional details. The default is <code>"uls"</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="modelcompK_+3A_valq.args">valQ.args</code></td>
<td>
<p>A list of arguments for the <em>Hull</em> empirical Q-matrix validation method. Only applicable if <code>valQ = TRUE</code> (see the <code>valQ</code> function):
</p>

<dl>
<dt><code>index</code></dt><dd><p>What index to use. It includes <code>"PVAF"</code> or <code>"R2"</code>. The default is <code>"PVAF"</code>.</p>
</dd>
<dt><code>iterative</code></dt><dd><p>(Iterative) implementation procedure. It includes <code>"none"</code> (for non-iterative), <code>"test"</code> (for test-level iterations), <code>"test.att"</code> (for test-level iterations modifying the least possible amount of q-entries in each iteration), and <code>"item"</code> (for item-level iterations). The default is <code>"test.att"</code>.</p>
</dd>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations if an iterative procedure has been selected. The default is 5.</p>
</dd>
<dt><code>CDMconv</code></dt><dd><p>Convergence criteria for the CDM estimations between iterations (only if an iterative procedure has been selected). The default is 0.01.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="modelcompK_+3A_verbose">verbose</code></td>
<td>
<p>Show progress? The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>modelcompK</code> returns an object of class <code>modelcompK</code>.
</p>

<dl>
<dt><code>sug.K</code></dt><dd><p>The suggested number of attributes for each fit index (<code>vector</code>). Only if <code>Qs = NULL</code>.</p>
</dd>
<dt><code>sel.Q</code></dt><dd><p>The suggested Q-matrix for each fit index (<code>vector</code>).</p>
</dd>
<dt><code>fit</code></dt><dd><p>The fit indices for each fitted model (<code>matrix</code>).</p>
</dd>
<dt><code>exp.exploreK</code></dt><dd><p>Explored dimensionality (<code>vector</code>). It can be different from <code>exploreK</code> if <code>stop</code> has been used.</p>
</dd>
<dt><code>usedQ</code></dt><dd><p>Q-matrices used to fit each model (<code>list</code>). They will be the estimated (and validated) Q-matrices if <code>Qs = NULL</code>. Otherwise, they will be <code>Qs</code>.</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas <br /> Miguel A. Sorrel, Universidad Autónoma de Madrid <br /> Francisco J. Abad, Universidad Autónoma de Madrid
</p>


<h3>References</h3>

<p>Ma, W., &amp; de la Torre, J. (2020). GDINA: An R package for cognitive diagnosis modeling. <em>Journal of Statistical Software</em>, <em>93</em>(14). https://doi.org/10.18637/jss.v093.i14
</p>
<p>Nájera, P., Abad, F. J., &amp; Sorrel, M. A. (2021). Determining the number of attributes in cognitive diagnosis modeling. <em>Frontiers in Psychology</em>, <em>12</em>:614470. https://doi.org/10.3389/fpsyg.2021.614470
</p>
<p>Nájera, P., Sorrel, M. A., de la Torre, J., &amp; Abad, F. J. (2020). Balancing fit and parsimony to improve Q-matrix validation. <em>British Journal of Mathematical and Statistical Psychology</em>. https://doi.org/10.1111/bmsp.12228
</p>
<p>Wang, W., Song, L., &amp; Ding, S. (2018). An exploratory discrete factor loading method for Q-matrix specification in cognitive diagnosis models. In: M. Wilberg, S. Culpepper, R. Janssen, J. González, &amp; D. Molenaar (Eds.), <em>Quantitative Psychology. IMPS 2017. Springer Proceedings in Mathematics &amp; Statistics</em> (Vol. 233, pp. 351-362). Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
dat &lt;- sim30GDINA$simdat
Q &lt;- sim30GDINA$simQ

#-------------------------------------
# Assess dimensionality from CDM data
#-------------------------------------
mcK &lt;- modelcompK(dat = dat, exploreK = 4:7, stop = "AIC", val.Q = TRUE, verbose = TRUE)
mcK$sug.K # Check suggested number of attributes by each fit index
mcK$fit # Check fit indices for each K explored
sug.Q &lt;- mcK$usedQ[[paste0("K", mcK$sug.K["AIC"])]] # Suggested Q-matrix by AIC
sug.Q &lt;- orderQ(sug.Q, Q)$order.Q # Reorder Q-matrix attributes
mean(sug.Q == Q) # Check similarity with the generating Q-matrix

#--------------------------------------------------
# Automatic fit comparison of competing Q-matrices
#--------------------------------------------------
trueQ &lt;- Q
missQ1 &lt;- missQ(Q, .10, seed = 123)$miss.Q
missQ2 &lt;- missQ(Q, .20, seed = 456)$miss.Q
missQ3 &lt;- missQ(Q, .30, seed = 789)$miss.Q
Qs &lt;- list(trueQ, missQ1, missQ2, missQ3)
mc &lt;- modelcompK(dat = dat, Qs = Qs, verbose = TRUE)
mc$sel.Q # Best-fitting Q-matrix for each fit index
mc$fit # Check fit indices for each Q explored



</code></pre>

<hr>
<h2 id='orderQ'>Reorder Q-matrix columns</h2><span id='topic+orderQ'></span>

<h3>Description</h3>

<p>Reorders Q-matrix columns according to a target matrix (e.g., another Q-matrix).
Specifically, it provides a reordered Q-matrix which columns show the lowest possible average Tucker index congruent coefficient with the target columns.
Reordering a Q-matrix is alike relabeling the attributes and it does not change the model.
Useful for simulation studies (e.g., comparing a validated Q-matrix with the generating Q-matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderQ(Q, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderQ_+3A_q">Q</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>). This is the Q-matrix that will be reordered.</p>
</td></tr>
<tr><td><code id="orderQ_+3A_target">target</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>). This could be the &quot;true&quot;, generating Q-matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>orderQ</code> returns an object of class <code>orderQ</code>.
</p>

<dl>
<dt><code>order.Q</code></dt><dd><p>The reordered Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>configs</code></dt><dd><p>Comparison information between the different column configurations of the Q-matrix and the target Q-matrix, including the average absolute difference and the average Tucker index of factor congruence (<code>matrix</code>). The function will not look for all possible specifications if a perfect match is found.</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Francisco J. Abad, Universidad Autónoma de Madrid <br /> Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GDINA)
dat &lt;- sim30GDINA$simdat
Q &lt;- sim30GDINA$simQ
sugQ1 &lt;- estQ(r = dat, K = 5) # Estimate Q-matrix
sugQ1$est.Q &lt;- orderQ(sugQ1$est.Q, Q)$order.Q # Reorder Q-matrix attributes
mean(sugQ1$est.Q == Q) # Check similarity with the generating Q-matrix
</code></pre>

<hr>
<h2 id='paK'>Parallel analysis - dimensionality assessment method</h2><span id='topic+paK'></span>

<h3>Description</h3>

<p>Parallel analysis with column permutation (i.e., resampling) as used in Nájera, Abad, &amp; Sorrel (2021).
It is recommended to use principal components, Pearson correlations, and mean criterion (Garrido, Abad, &amp; Ponsoda, 2013; Nájera, Abad, &amp; Sorrel, 2021).
The parallel analysis based on principal axis factor analysis is conducted using the <code>fa.parallel</code> function of the <code>psych</code> R package (Revelle, 2020).
The tetrachoric correlations are efficiently estimated using the <code>sirt</code> R package (Robitzsch, 2020).
The graph is made with the <code>ggplot2</code> package (Wickham et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paK(
  dat,
  R = 100,
  fa = "pc",
  cor = "both",
  cutoff = "mean",
  fm = "uls",
  plot = TRUE,
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paK_+3A_dat">dat</code></td>
<td>
<p>A <em>N</em> individuals x <em>J</em> items (<code>matrix</code> or <code>data.frame</code>). Missing values need to be coded as <code>NA</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_r">R</code></td>
<td>
<p>Number of resampled datasets (i.e., replications) to generate. The default is 100.</p>
</td></tr>
<tr><td><code id="paK_+3A_fa">fa</code></td>
<td>
<p>Extraction method to use. It includes <code>"pc"</code> (for principal components analysis), <code>"fa"</code> (for principal axis factor analysis), and <code>"both"</code>. The default is <code>"pc"</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_cor">cor</code></td>
<td>
<p>What type of correlations to use. It includes <code>"cor"</code> (for Pearson correlations), <code>"tet"</code> (for tetrachoric/polychoric correlations), and <code>"both"</code>. The default is <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_cutoff">cutoff</code></td>
<td>
<p>What criterion to use as the cutoff. It can be <code>"mean"</code> (for the average generated eigenvalues) or a value between 0 and 100 (for a percentile). A vector with several criteria can be used. The default is <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_fm">fm</code></td>
<td>
<p>Factoring method to use. It includes <code>"uls"</code> (for unweighted least squares), <code>"ml"</code> (for maximum likelihood), and <code>"wls"</code> (for weighted least squares), among others. The default is <code>"uls"</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_plot">plot</code></td>
<td>
<p>Print the parallel analysis plot? Note that the plot might be messy if many variants are requested. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_verbose">verbose</code></td>
<td>
<p>progress. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="paK_+3A_seed">seed</code></td>
<td>
<p>A seed for obtaining consistent results. If <code>NULL</code>, no seed is used. The default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>paK</code> returns an object of class <code>paK</code>.
</p>

<dl>
<dt><code>sug.K</code></dt><dd><p>The suggested number of attributes for each variant (<code>vector</code>).</p>
</dd>
<dt><code>e.values</code></dt><dd><p>The sample and reference eigenvalues (<code>matrix</code>).</p>
</dd>
<dt><code>plot</code></dt><dd><p>The parallel analysis plot. Only if <code>plot = TRUE</code> (<code>plot</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas <br /> Miguel A. Sorrel, Universidad Autónoma de Madrid <br /> Francisco J. Abad, Universidad Autónoma de Madrid
</p>


<h3>References</h3>

<p>Garrido, L. E., Abad, F. J., &amp; Ponsoda, V. (2013). A new look at Horn's parallel analysis with ordinal variables. <em>Psychological Methods</em>, <em>18</em>, 454-474. https://doi.org/10.1037/a0030005
</p>
<p>Nájera, P., Abad, F. J., &amp; Sorrel, M. A. (2021). Determining the number of attributes in cognitive diagnosis modeling. <em>Frontiers in Psychology</em>, <em>12</em>:614470. https://doi.org/10.3389/fpsyg.2021.614470
</p>
<p>Revelle, W. (2019). <em>psych: Procedures for Psychological, Psychometric, and Personality Research</em>. R package version 1.9.12. https://CRAN.R-project.org/package=psych.
</p>
<p>Robitzsch, A. (2020). <em>sirt: Supplementary Item Response Theory Models</em>. R package version 3.9-4. https://CRAN.R-project.org/package=sirt.
</p>
<p>Wickham, H., et al. (2020). <em>ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics</em>. R package version 3.3.2. https://CRAN.R-project.org/package=ggplot2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GDINA)
dat &lt;- sim30GDINA$simdat
Q &lt;- sim30GDINA$simQ
# In paK, R = 100 is recommended (R = 30 is here used for illustration purposes)
pa.K &lt;- paK(dat = dat, R = 30, fa = "pc", cutoff = c("mean", 95), plot = TRUE, seed = 123)
pa.K$sug.K # Check suggested number of attributes by each parallel analysis variant
pa.K$e.values # Check eigenvalues
pa.K$plot # Show parallel analysis plot
</code></pre>

<hr>
<h2 id='personFit'>Calculate standardized log-likelihood statistic (lZ) for person fit evaluation</h2><span id='topic+personFit'></span>

<h3>Description</h3>

<p>This function calculates the standardized log-likelihood statistic (lZ; Cui &amp; Li, 2015; Drasgow et al. 1985) and the proposals for correcting its distribution discussed in Santos et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>personFit(fit, att.est = "MLE", sig.level = 0.05, p.adjust.method = "BH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="personFit_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>RDINA</code> or <code>GDINA</code> (Ma &amp; de la Torre, 2020).</p>
</td></tr>
<tr><td><code id="personFit_+3A_att.est">att.est</code></td>
<td>
<p>What attribute estimates are used? The default is <code>"MLE"</code>.</p>
</td></tr>
<tr><td><code id="personFit_+3A_sig.level">sig.level</code></td>
<td>
<p>Scalar numeric. Alpha level for decision. Default is 0.05.</p>
</td></tr>
<tr><td><code id="personFit_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Scalar character. Correction method for p-values. Possible values include &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, and &quot;none&quot;. See p.adjust function from the stats R package for additional details. Default is BH.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>personFit</code> returns an object of class <code>personFit</code>, with a list of elements:
</p>

<dl>
<dt><code>stat</code></dt><dd><p>Person fit statistics (<code>data.frame</code>).</p>
</dd>
<dt><code>p</code></dt><dd><p>p-values (two-sided test) for the person fit statistics (<code>data.frame</code>).</p>
</dd>
<dt><code>sigp</code></dt><dd><p>Scalar vectors denoting the examinees for which the person fit statitic is significant (p-value) (<code>list</code>).</p>
</dd>
<dt><code>sigadjp</code></dt><dd><p>Scalar vectors denoting the examinees for which the person fit statitic is significant (adjusted p-value) (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Miguel A. Sorrel, Universidad Autónoma de Madrid, <br /> Kevin Santos, University of the Philippines, <br /> Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Cui, Y., &amp; Li, J. (2015). Evaluating person fit for cognitive diagnostic assessment. <em>Applied Psychological Measurement</em>, <em>39</em>, 223–238. https://doi.org/10.1177/0146621614557272
</p>
<p>Drasgow, F., Levine, M. V., &amp; Williams, E. A. (1985). Appropriateness measurement with polychotomous item response models and standardized indices. <em>British Journal of Mathematical and Statistical Psychology</em>, <em>38</em>, 67–86. https://psycnet.apa.org/doi/10.1111/j.2044-8317.1985.tb00817.x
</p>
<p>Santos, K. C. P., de la Torre, J., &amp; von Davier, M. (2020). Adjusting person fit index for skewness in cognitive diagnosis modeling. <em>Journal of Classification</em>, <em>37</em>, 399-420. https://doi.org/10.1007/s00357-019-09325-5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
dat &lt;- sim10GDINA$simdat[1:20, ]
Q &lt;- sim10GDINA$simQ
fit &lt;- GDINA(dat = dat, Q = Q, model = "GDINA")
res.personFit &lt;- personFit(fit)
res.personFit

</code></pre>

<hr>
<h2 id='RDINA'>Restricted DINA model</h2><span id='topic+RDINA'></span>

<h3>Description</h3>

<p>Estimation of the <em>restricted deterministic input, noisy &quot;and&quot; gate</em> model (R-DINA; Nájera et al., 2023).
In addition to the non-compensatory (i.e., conjunctive) condensation rule of the DINA model, the compensatory (i.e., disjunctive) rule of the DINO model can be also applied (i.e., R-DINO model).
The R-DINA/R-DINO model should be only considered for applications involving very small sample sizes (N &lt; 100; Nájera et al., 2023), and model fit evaluation and comparison with competing models (e.g., DINA/DINO, G-DINA) is highly recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDINA(
  dat,
  Q,
  gate = "AND",
  att.prior = NULL,
  est = "Brent",
  EM.args = list(maxitr = 1000, conv.crit = 1e-04, init.phi = 0.2, verbose = TRUE),
  tau.alpha = "MAP",
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RDINA_+3A_dat">dat</code></td>
<td>
<p>A <em>N</em> individuals x <em>J</em> items (<code>matrix</code> or <code>data.frame</code>). Missing values need to be coded as <code>NA</code>. Caution is advised if missing data are present.</p>
</td></tr>
<tr><td><code id="RDINA_+3A_q">Q</code></td>
<td>
<p>A <em>J</em> items x <em>K</em> attributes Q-matrix (<code>matrix</code> or <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="RDINA_+3A_gate">gate</code></td>
<td>
<p>Either a conjunctive (<code>"AND"</code>) or disjunctive (<code>"OR"</code>) condensation rule to estimate the RDINA or RDINO model, respectively. Default is <code>"AND"</code>.</p>
</td></tr>
<tr><td><code id="RDINA_+3A_att.prior">att.prior</code></td>
<td>
<p>A 2^<em>K</em> attributes vector containing the prior distribution for each latent class. The sum of all elements does not have to be equal to 1, since the vector will be normalized. Default is <code>NULL</code>, which is a uniform prior distribution.</p>
</td></tr>
<tr><td><code id="RDINA_+3A_est">est</code></td>
<td>
<p>Use the Brent's method (<code>"Brent"</code>) or the expectation-maximization algorithm (<code>"EM"</code>) to estimate the model? Default is <code>"Brent"</code>, since it is faster and both algorithms are virtually equivalent for the RDINA/RDINO model.</p>
</td></tr>
<tr><td><code id="RDINA_+3A_em.args">EM.args</code></td>
<td>
<p>A list of arguments in case the EM algorithm is used to estimate the model:
</p>

<dl>
<dt><code>maxitr</code></dt><dd><p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>conv.crit</code></dt><dd><p>Convergence criterion regarding the maximum absolute change in either the phi parameter estimate or the marginal posterior probabilities of attribute mastery. Default is 0.0001.</p>
</dd>
<dt><code>init.phi</code></dt><dd><p>Initial value for the phi parameter. Default is 0.2.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print information after each iteration. Default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="RDINA_+3A_tau.alpha">tau.alpha</code></td>
<td>
<p>Attribute profile estimator (either <code>"MAP"</code>, <code>"EAP"</code>, or <code>"MLE"</code>) used to calculate the estimated classification accuracy as done with the <code>CA</code> function of the <code>GDINA</code> package (Ma &amp; de la Torre, 2020).</p>
</td></tr>
<tr><td><code id="RDINA_+3A_seed">seed</code></td>
<td>
<p>Random number generation seed (e.g., to solve ties in case they occur with MLE or MAP estimation). Default is <code>NULL</code>, which means that no specific seed is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RDINA</code> returns an object of class <code>RDINA</code>.
</p>

<dl>
<dt><code>MLE</code></dt><dd><p>Estimated attribute profiles with the MLE estimator (<code>matrix</code>).</p>
</dd>
<dt><code>MAP</code></dt><dd><p>Estimated attribute profiles with the MAP estimator (<code>matrix</code>).</p>
</dd>
<dt><code>EAP</code></dt><dd><p>Estimated attribute profiles with the EAP estimator (<code>matrix</code>).</p>
</dd>
<dt><code>phi</code></dt><dd><p>Phi parameter estimate (<code>numeric</code>).</p>
</dd>
<dt><code>post.probs</code></dt><dd><p>A (<code>list</code>) containing the estimates of the posterior probability of each examinee in each latent class (<code>pp</code>), marginal posterior probabilities of attribute mastery (<code>mp</code>), and posterior probability of each latent class (<code>lp</code>).</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>A (<code>list</code>) containing the likelihood of each examinee in each latent class (<code>lik_il</code>) and the model log-likelihood (<code>logLik</code>).</p>
</dd>
<dt><code>test.fit</code></dt><dd><p>Relative model fit indices (<code>list</code>).</p>
</dd>
<dt><code>class.accu</code></dt><dd><p>A (<code>list</code>) containing the classification accuracy estimates at the test-level (<code>tau</code>), latent class-level (<code>tau_l</code>), and attribute-level (<code>tau_k</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Ma, W., &amp; de la Torre, J. (2020). GDINA: An R package for cognitive diagnosis modeling. <em>Journal of Statistical Software</em>, <em>93</em>(14). https://doi.org/10.18637/jss.v093.i14
</p>
<p>Nájera, P., Abad, F. J., Chiu, C.-Y., &amp; Sorrel, M. A. (2023). The Restricted DINA model: A Comprehensive Cognitive Diagnostic Model for Classroom-Level Assessments. <em>Journal of Educational and Behavioral Statistics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
Q &lt;- sim30GDINA$simQ # Q-matrix
K &lt;- ncol(Q)
J &lt;- nrow(Q)
set.seed(123)
GS &lt;- data.frame(guessing = rep(0.2, J), slip = rep(0.2, J))
sim &lt;- simGDINA(20, Q, GS, model = "DINA")
simdat &lt;- sim$dat # Simulated data
simatt &lt;- sim$attribute # Generating attributes
fit.RDINA &lt;- RDINA(simdat, Q) # Apply the GNPC method
ClassRate(fit.RDINA$EAP, simatt) # Check classification accuracy

</code></pre>

<hr>
<h2 id='RDINA2GDINA'>Translate RDINA object into GDINA object</h2><span id='topic+RDINA2GDINA'></span>

<h3>Description</h3>

<p>This function translates an object of class <code>RDINA</code> to an object of class <code>GDINA</code>, so that the estimated R-DINA object is compatible with most of the functions in the <code>GDINA</code> package (Ma &amp; de la Torre, 2020), including model fit, item fit, and Q-matrix validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDINA2GDINA(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RDINA2GDINA_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>RDINA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RDINA2GDINA</code> returns an object of class <code>GDINA</code>. See the <code>GDINA</code> package for more information.
</p>


<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas
</p>


<h3>References</h3>

<p>Ma, W., &amp; de la Torre, J. (2020). GDINA: An R package for cognitive diagnosis modeling. <em>Journal of Statistical Software</em>, <em>93</em>(14). https://doi.org/10.18637/jss.v093.i14
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(GDINA)
dat &lt;- sim30DINA$simdat
Q &lt;- sim30DINA$simQ
fit1 &lt;- RDINA(dat, Q)
fit2 &lt;- RDINA2GDINA(fit1)
modelfit(fit2) # Model fit evaluation
itemfit(fit2) # Item fit evaluation

</code></pre>

<hr>
<h2 id='valQ'>Empirical Q-matrix validation</h2><span id='topic+valQ'></span>

<h3>Description</h3>

<p>Empirical Q-matrix validation using the <em>Hull</em> method (Nájera, Sorrel, de la Torre, &amp; Abad, 2020a).
The procedure can be used either with the PVAF (de la Torre &amp; Chiu, 2016) or McFadden's pseudo R-squared (McFadden, 1974).
The PVAF is recommended (Nájera, Sorrel, de la Torre, &amp; Abad, 2020a).
Note that the pseudo R-squared might not be computationally feasible for highly dimensional Q-matrices, say more than 10 attributes.
Different iterative implementations are available, such as the test-level implementation (see Terzi &amp; de la Torre, 2018), attribute-test-level implementation (Nájera, Sorrel, de la Torre, &amp; Abad, 2020a), and item-level implementation (Nájera, Sorrel, de la Torre, &amp; Abad, 2020b).
If an iterative implementation is used, the <code>GDINA</code> R package (Ma &amp; de la Torre, 2020) is used for the calibration of the CDMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valQ(
  fit,
  index = "PVAF",
  iterative = "test.att",
  emptyatt = TRUE,
  maxitr = 100,
  CDMconv = 1e-04,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valQ_+3A_fit">fit</code></td>
<td>
<p>A G-DINA model fit object from the <code>GDINA</code> package (Ma &amp; de la Torre, 2020).</p>
</td></tr>
<tr><td><code id="valQ_+3A_index">index</code></td>
<td>
<p>What index to use. It includes <code>"PVAF"</code> or <code>"R2"</code>. The default is <code>"PVAF"</code>.</p>
</td></tr>
<tr><td><code id="valQ_+3A_iterative">iterative</code></td>
<td>
<p>(Iterative) implementation procedure. It includes <code>"none"</code> (for non-iterative), <code>"test"</code> (for test-level iterations), <code>"test.att"</code> (for attribute-test-level), and <code>"item"</code> (for item-level iterations). The default is <code>"test.att"</code>.</p>
</td></tr>
<tr><td><code id="valQ_+3A_emptyatt">emptyatt</code></td>
<td>
<p>Is it possible for the suggested Q-matrix to have an empty attribute (i.e., an attribute not measured by any item)? Although rarely, it is possible for iterative procedures to provide a suggested Q-matrix in which one or more attributes are empty. This might indicate that the original Q-matrix had more attributes than necessary. If <code>FALSE</code>, then at least one item (i.e., the one that is most likely) will measure each attribute in the suggested Q-matrix. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="valQ_+3A_maxitr">maxitr</code></td>
<td>
<p>Maximum number of iterations if an iterative procedure has been selected. The default is 100.</p>
</td></tr>
<tr><td><code id="valQ_+3A_cdmconv">CDMconv</code></td>
<td>
<p>Convergence criteria for the CDM estimations between iterations (only if an iterative procedure has been selected). The default is 0.0001.</p>
</td></tr>
<tr><td><code id="valQ_+3A_verbose">verbose</code></td>
<td>
<p>Print information after each iteration if an iterative procedure is used. The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>valQ</code> returns an object of class <code>valQ</code>.
</p>

<dl>
<dt><code>sug.Q</code></dt><dd><p>Suggested Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>Q</code></dt><dd><p>Original Q-matrix (<code>matrix</code>).</p>
</dd>
<dt><code>sugQ.fit</code></dt><dd><p>Several fit indices from the model obtained with the suggested Q-matrix (<code>vector</code>).</p>
</dd>
<dt><code>index</code></dt><dd><p>PVAF or pseudo R-squared (depending on which one was used) for each item (<code>matrix</code>).</p>
</dd>
<dt><code>iter.Q</code></dt><dd><p>Q-matrices used in each iteration (<code>list</code>). Provided only if an iterative procedure has been used.</p>
</dd>
<dt><code>iter.index</code></dt><dd><p>PVAF or pseudo R-squared (depending on which one was used) for each item in each iteration (<code>list</code>). Provided only if an iterative procedure has been used.</p>
</dd>
<dt><code>n.iter</code></dt><dd><p>Number of iterations used (<code>double</code>). Provided only if an iterative procedure has been used.</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Convergence information (<code>double</code>). It can be 1 (convergence), 2 (lack of convergence: maximum number of iterations achieved), 3 (lack of convergence: empty attribute obtained), and 4 (lack of convergence: loop Q-matrices). Provided only if an iterative procedure has been used.</p>
</dd>
<dt><code>time</code></dt><dd><p>Initial and finish time (<code>vector</code>).</p>
</dd>
<dt><code>time.used</code></dt><dd><p>Total computation time (<code>difftime</code>).</p>
</dd>
<dt><code>specifications</code></dt><dd><p>Function call specifications (<code>list</code>).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Pablo Nájera, Universidad Pontificia Comillas <br /> Miguel A. Sorrel, Universidad Autónoma de Madrid <br /> Francisco J. Abad, Universidad Autónoma de Madrid
</p>


<h3>References</h3>

<p>de la Torre, J., &amp; Chiu, C.-Y. (2016). A general method of empirical Q-matrix validation. <em>Psychometrika</em>, <em>81</em>, 253-273. https://doi.org/10.1007/s11336-015-9467-8
</p>
<p>Ma, W., &amp; de la Torre, J. (2020). GDINA: An R package for cognitive diagnosis modeling. <em>Journal of Statistical Software</em>, <em>93</em>(14). https://doi.org/10.18637/jss.v093.i14
</p>
<p>McFadden, D. (1974). Conditional logit analysis of qualitative choice behavior. In P. Zarembka (Ed.), <em>Frontiers in Economics</em> (pp. 105-142). Academic Press.
</p>
<p>Nájera, P., Sorrel, M. A., de la Torre, J., &amp; Abad, F. J. (2020a). Balancing fit and parsimony to improve Q-matrix validation. <em>British Journal of Mathematical and Statistical Psychology</em>. https://doi.org/10.1111/bmsp.12228
</p>
<p>Nájera, P., Sorrel, M. A., de la Torre, J., &amp; Abad, F. J. (2020b). Improving robustness in Q-matrix validation using an iterative and dynamic procedure. <em>Applied Psychological Measurement</em>, <em>46</em>, 431-446. https://doi.org/10.1177/0146621620909904
</p>
<p>Terzi, R., &amp; de la Torre, J. (2018). An iterative method for empirically-based Q-matrix validation. <em>International Journal of Assessment Tools in Education</em>, <em>5</em>, 248-262. https://doi.org/10.21449/ijate.407193
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GDINA)
dat &lt;- sim30GDINA$simdat
Q &lt;- sim30GDINA$simQ # Generating Q-matrix
miss.Q &lt;- missQ(Q = Q, qjk = .30, retainJ = 5, seed = 123)$miss.Q # Misspecified Q-matrix
fit &lt;- GDINA(dat, miss.Q) # GDINA object
sug.Q &lt;- valQ(fit = fit, verbose = TRUE) # Hull method for Q-matrix validation
mean(sug.Q$sug.Q == Q) # Check similarity with the generating Q-matrix
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
