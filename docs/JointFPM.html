<!DOCTYPE html><html><head><title>Help for package JointFPM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JointFPM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JointFPM-package'><p>JointFPM: A Parametric Model for Estimating the Mean Number of Events</p></a></li>
<li><a href='#bladder1_stacked'><p>Stacked version of the bladder1 dataset included in the survival package</p></a></li>
<li><a href='#JointFPM'><p>Joint FPMs for recurrent and competing events.</p></a></li>
<li><a href='#mean_no'><p>Non-parametric estimation of mean number of events</p></a></li>
<li><a href='#predict.JointFPM'><p>Post-estimation function for JointFPMs</p></a></li>
<li><a href='#test_dfs_JointFPM'><p>Tests DFs for JointFPMs.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Parametric Model for Estimating the Mean Number of Events</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a parametric joint model for modelling recurrent
  and competing event processes using generalised survival models. The joint
  model can subsequently be used to predict the mean number of events in the
  presence of competing risks at different time points. Comparisons of the mean
  number of event functions, e.g. the differences in mean number of events
  between two exposure groups, are also available.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/entjos/JointFPM">https://github.com/entjos/JointFPM</a>,
<a href="https://entjos.github.io/JointFPM/">https://entjos.github.io/JointFPM/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/entjos/JointFPM/issues">https://github.com/entjos/JointFPM/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstpm2 (&ge; 1.5.2), survival (&ge; 3.2-13), data.table (&ge;
1.14.2), rlang (&ge; 1.1.0), lifecycle, rmutil, cli, matrixStats,
statmod</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>watcher, Parallel*</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 08:49:30 UTC; josent</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua P. Entrop <a href="https://orcid.org/0000-0003-1614-8096"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Alessandro Gasparini [ctb],
  Mark Clements [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua P. Entrop &lt;joshuaentrop@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-22 09:12:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='JointFPM-package'>JointFPM: A Parametric Model for Estimating the Mean Number of Events</h2><span id='topic+JointFPM-package'></span>

<h3>Description</h3>

<p>Implementation of a parametric joint model for modelling recurrent and competing event processes using generalised survival models. The joint model can subsequently be used to predict the mean number of events in the presence of competing risks at different time points. Comparisons of the mean number of event functions, e.g. the differences in mean number of events between two exposure groups, are also available.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joshua P. Entrop <a href="mailto:joshuaentrop@posteo.de">joshuaentrop@posteo.de</a> (<a href="https://orcid.org/0000-0003-1614-8096">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Alessandro Gasparini [contributor]
</p>
</li>
<li><p> Mark Clements [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/entjos/JointFPM">https://github.com/entjos/JointFPM</a>
</p>
</li>
<li> <p><a href="https://entjos.github.io/JointFPM/">https://entjos.github.io/JointFPM/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/entjos/JointFPM/issues">https://github.com/entjos/JointFPM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bladder1_stacked'>Stacked version of the bladder1 dataset included in the survival package</h2><span id='topic+bladder1_stacked'></span>

<h3>Description</h3>

<p>This dataset includes the bladder1 dataset included the survival package,
which has been transformed into stacked format for use with <code>JointFPM</code>. The
stacked datset includes one row per individual for the competing event and
one rows per individual for each reoccurrence of bladder cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bladder1_stacked
data(bladder1_stacked)
</code></pre>


<h3>Format</h3>

<p>A data frame with 412 rows and 11 columns
</p>


<h3>Details</h3>

<p>For more information please take a look at <code>?survival::bladder</code>.
</p>

<hr>
<h2 id='JointFPM'>Joint FPMs for recurrent and competing events.</h2><span id='topic+JointFPM'></span>

<h3>Description</h3>

<p>Fits a joint flexible parametric survival model (FPM) for a recurrent and
terminal event. The joint model can be used to predict the mean number of
events at different time points. This function is a wrapper around
<code>rstpm2::stpm2()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JointFPM(
  surv,
  re_model,
  ce_model,
  re_indicator,
  ce_indicator,
  df_ce = 3,
  df_re = 3,
  tvc_re_terms = NULL,
  tvc_ce_terms = NULL,
  cluster,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JointFPM_+3A_surv">surv</code></td>
<td>
<p>A formula of the following form <code>Surv(...) ~ 1</code>.
The <code>Surv</code> objects needs to be of <code>type ==  'counting'</code> with the
following arguments:
</p>

<dl>
<dt><code>time</code>: </dt><dd><p>Start of follow-up time for each event episode, i.e.,
usually 0 for the competing event and the first occurrence of the
recurrent event. For every subsequent event the follow-up can either
be 0 if gap time is the underlying time scale or the time of the
previous event if total time is the underlying time scale.</p>
</dd>
<dt><code>time2</code>: </dt><dd><p>End of follow-up, i.e., either occurrence of a terminal
or recurrent event, or time of censoring.</p>
</dd>
<dt><code>status</code>: </dt><dd><p>Event indicator for both terminal and recurrent
event.</p>
</dd>
<dt><code>type</code>: </dt><dd><p>Has to be <code>counting</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="JointFPM_+3A_re_model">re_model</code></td>
<td>
<p>A formula object specifying the model for the recurrent event
with an empty right hand side of the formula, e.g. <code>~ sex</code>.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_ce_model">ce_model</code></td>
<td>
<p>A formula object specifying the model for the competing event
with an empty right hand side of the formula, e.g. <code>~ sex</code>.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_re_indicator">re_indicator</code></td>
<td>
<p>Indicator that defines which rows in the dataset belong to the recurrent
event process. These are usually more than one row per observations.
The variable name needs to be passed as a character vector.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_ce_indicator">ce_indicator</code></td>
<td>
<p>Indicator that defines which row in the dataset belong to the competing
event process. The variable name needs to be passed as a character vector.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_df_ce">df_ce</code></td>
<td>
<p>Defines the number of knots used to model the baseline hazard function
for the competing event process.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_df_re">df_re</code></td>
<td>
<p>Defines the number of knots used to model the baseline hazard function
for the recurrent event process.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_tvc_re_terms">tvc_re_terms</code></td>
<td>
<p>A named list defining the number of knots used to model potential
time-varying effects of variables included in the recurrent event model.
This list should be of form <code style="white-space: pre;">&#8288;list(&lt;var_name&gt; = &lt;no. of knots&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_tvc_ce_terms">tvc_ce_terms</code></td>
<td>
<p>A named list defining the number of knots used to model potential
time-varying effects of variables included in the competing event model.
This list should be of form <code style="white-space: pre;">&#8288;list(&lt;var_name&gt; = &lt;no. of knots&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_cluster">cluster</code></td>
<td>
<p>A character vector specifying the name of the variable that defines unique
observations in the dataset passed to the function.</p>
</td></tr>
<tr><td><code id="JointFPM_+3A_data">data</code></td>
<td>
<p>A stacked dataset that includes both data on the recurrent and competing
event process. The dataset should have one row for each observation
including the follow-up time and event indicator for the competing event
and possibly multiple rows for each observation including the follow-up
times and event indicator for the recurrent event, e.g.:
</p>
<div class="sourceCode"><pre>id st_start  st_end re status
 1      0      6.88  0      1
 1      0      6.88  1      0
 2      0      8.70  0      1
 2      0      8.70  1      0
 3      0     10     0      0
 3      0      1.78  1      1
 3      1.78   6.08  1      1
 3      6.08  10     1      0
 4      0      6.07  0      1
 4      0      6.07  1      0
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>JointFPM</code> with the following elements:
</p>

<dl>
<dt><code>model</code>: </dt><dd><p>The fitted FPM object,</p>
</dd>
<dt><code>re_terms</code>: </dt><dd><p>The terms used to model the recurrent event model,</p>
</dd>
<dt><code>ce_terms</code>: </dt><dd><p>The terms used to model the competing event model,</p>
</dd>
<dt><code>re_indicator</code>: </dt><dd><p>The name of the indicator variable of the recurrent
event</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>JointFPM(Surv(time  = start,
              time2 = stop,
              event = event,
              type  = 'counting') ~ 1,
         re_model = ~ pyridoxine + thiotepa,
         ce_model = ~ pyridoxine + thiotepa,
         re_indicator = "re",
         ce_indicator = "ce",
         df_ce = 3,
         df_re = 3,
         tvc_ce_terms = list(pyridoxine = 2,
                             thiotepa   = 2),
         tvc_re_terms = list(pyridoxine = 2,
                             thiotepa   = 2),
         cluster  = "id",
         data     = bladder1_stacked)

</code></pre>

<hr>
<h2 id='mean_no'>Non-parametric estimation of mean number of events</h2><span id='topic+mean_no'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_no(
  formula,
  re_indicator,
  ce_indicator,
  data,
  re_control = list(),
  ce_control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_no_+3A_formula">formula</code></td>
<td>
<p>A formula passed to <code>survfit</code>.</p>
</td></tr>
<tr><td><code id="mean_no_+3A_re_indicator">re_indicator</code></td>
<td>
<p>The name of a variable indicating that these rows in the dataset belong
to the risksets of the recurrent event process.</p>
</td></tr>
<tr><td><code id="mean_no_+3A_ce_indicator">ce_indicator</code></td>
<td>
<p>The name of a variable indicating that these rows in the datasets belong
to the riskset of the competing event process.</p>
</td></tr>
<tr><td><code id="mean_no_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in stacked format. The dataset needs to include one row
for the competing event and one row for each risk episode of the
recurrent event.</p>
</td></tr>
<tr><td><code id="mean_no_+3A_re_control">re_control</code></td>
<td>
<p>An optional <code>list</code> with arguments passed to <code>survfit</code> when computing
risksets for the recurrent event.</p>
</td></tr>
<tr><td><code id="mean_no_+3A_ce_control">ce_control</code></td>
<td>
<p>An optional <code>list</code> with arguments passed to <code>survfit</code> when computing
risksets for the competing event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> including the estimated mean number of events <code>expn</code>
at times <code>t</code> within strata <code>strata</code>.
</p>

<hr>
<h2 id='predict.JointFPM'>Post-estimation function for JointFPMs</h2><span id='topic+predict.JointFPM'></span>

<h3>Description</h3>

<p>Predicts different estimates from a joint flexible parametric model.
Currently only the estimation of the mean number of events at different
time points is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JointFPM'
predict(
  object,
  type = "mean_no",
  newdata,
  t,
  exposed = NULL,
  ci_fit = TRUE,
  method = "romberg",
  ngq = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.JointFPM_+3A_object">object</code></td>
<td>
<p>A joint flexible parametric model of class <code>JointFPM</code>.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_type">type</code></td>
<td>
<p>A character vector defining the estimate of interest. Currently available
options are:
</p>

<dl>
<dt><code>mean_no</code>: </dt><dd><p>Estimates the mean number of events at time(s) <code>t</code>.</p>
</dd>
<dt><code>diff</code>: </dt><dd><p>Estimates the difference in mean number of events
between exposed and unexposed at time(s) <code>t</code>.</p>
</dd>
<dt><code>marg_mean_no</code>: </dt><dd><p>Estimates the marginal mean number of events.</p>
</dd>
<dt><code>marg_diff</code>: </dt><dd><p>Estimates the marginal difference in the mean
number of events.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> with one row including the variable values used for t
he prediction. One value for each variable used in either the recurrent or
competing event model is required when predicting <code>mean_no</code> or <code>diff</code>.
For <code>marg_mean_no</code> or <code>marg_diff</code>, this includes the variable
that you would like your marginal estimate to be conditioned on.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_t">t</code></td>
<td>
<p>A vector defining the time points used for the prediction.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_exposed">exposed</code></td>
<td>
<p>A function that takes <code>newdata</code> as an argument and creates a new dataset
for the exposed group. This argument is required if <code>type = 'diff'</code>.
Please see details for more information.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_ci_fit">ci_fit</code></td>
<td>
<p>Logical indicator for whether confidence intervals should be estimated
for the fitted estimates using the delta method.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_method">method</code></td>
<td>
<p>The method used for the underlying numerical integration procedure.
Defaults to <code>"romberg"</code>, which uses the <code><a href="rmutil.html#topic+int">rmutil::int()</a></code> function,
but it is possible to use Gaussian quadrature by setting
<code>method = "gq"</code> instead.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_ngq">ngq</code></td>
<td>
<p>Number of quadrature nodes used when <code>method = "gq"</code>. Defaults to 30,
which lead to accurate results (compared to <code>method = "romberg"</code>) in our
experience.</p>
</td></tr>
<tr><td><code id="predict.JointFPM_+3A_...">...</code></td>
<td>
<p>Added for compatibility with other predict functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function required for the <code>exposed</code> argument must take the <code>newdata</code>
dataset as argument and transform it to a new dataset that defines the
exposed group. Assume we assume that we have a model with one variable
<code>trt</code> which is a 0/1 coded treatment indicator. If we would like to obtain
the difference in mean number of events comparing the untreated to treated
group we could use the following function assuming that
<code>newdata = data.frame(trt = 0)</code>:
</p>
<div class="sourceCode"><pre>function(x){transform(x, trt = 1)}
</pre></div>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns:
</p>

<dl>
<dt><code>t</code>: </dt><dd><p>The time for the prediction,</p>
</dd>
<dt><code>fit</code>: </dt><dd><p>The point estimate of the prediction,</p>
</dd>
<dt><code>lci</code>: </dt><dd><p>The lower confidence interval limit,</p>
</dd>
<dt><code>uci</code>: </dt><dd><p>The upper confidence interval limit.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>bldr_model &lt;- JointFPM(Surv(time  = start,
                            time2 = stop,
                            event = event,
                            type  = 'counting') ~ 1,
                       re_model = ~ pyridoxine + thiotepa,
                       ce_model = ~ pyridoxine + thiotepa,
                       re_indicator = "re",
                       ce_indicator = "ce",
                       df_ce = 3,
                       df_re = 3,
                       cluster  = "id",
                       data     = bladder1_stacked)

predict(bldr_model,
        newdata = data.frame(pyridoxine = 1,
                             thiotepa   = 0),
        t       =  c(10, 20),
        ci_fit  = FALSE)

</code></pre>

<hr>
<h2 id='test_dfs_JointFPM'>Tests DFs for JointFPMs.</h2><span id='topic+test_dfs_JointFPM'></span>

<h3>Description</h3>

<p>Test of different degrees of freedoms (DFs) for joint flexible parametric
survival models.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_dfs_JointFPM(
  surv,
  re_model,
  ce_model,
  re_indicator,
  ce_indicator,
  dfs_ce,
  dfs_re,
  tvc_re_terms = NULL,
  tvc_ce_terms = NULL,
  cluster,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_dfs_JointFPM_+3A_surv">surv</code></td>
<td>
<p>A formula of the following form <code>Surv(...) ~ 1</code>.
The <code>Surv</code> objects needs to be of <code>type ==  'counting'</code> with the
following arguments:
</p>

<dl>
<dt><code>time</code>: </dt><dd><p>Start of follow-up time for each event episode, i.e.,
usually 0 for the competing event and the first occurrence of the
recurrent event. For every subsequent event the follow-up can either
be 0 if gap time is the underlying time scale or the time of the
previous event if total time is the underlying time scale.</p>
</dd>
<dt><code>time2</code>: </dt><dd><p>End of follow-up, i.e., either occurrence of a terminal
or recurrent event, or time of censoring.</p>
</dd>
<dt><code>status</code>: </dt><dd><p>Event indicator for both terminal and recurrent
event.</p>
</dd>
<dt><code>type</code>: </dt><dd><p>Has to be <code>counting</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_re_model">re_model</code></td>
<td>
<p>A formula object specifying the model for the recurrent event
with an empty right hand side of the formula, e.g. <code>~ sex</code>.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_ce_model">ce_model</code></td>
<td>
<p>A formula object specifying the model for the competing event
with an empty right hand side of the formula, e.g. <code>~ sex</code>.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_re_indicator">re_indicator</code></td>
<td>
<p>Indicator that defined which rows in the dataset belong to the recurrent
event process. These are usually more than one row per observations.
The variable name needs to be passed as a character vector.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_ce_indicator">ce_indicator</code></td>
<td>
<p>Indicator that defined which row in the dataset belong to the competing
event process. The variable name needs to be passed as a character vector.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_dfs_ce">dfs_ce</code></td>
<td>
<p>Defines the number of knots used to model the baseline hazard function
for the competing event process.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_dfs_re">dfs_re</code></td>
<td>
<p>Defines the number of knots used to model the baseline hazard function
for the recurrent event process.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_tvc_re_terms">tvc_re_terms</code></td>
<td>
<p>A named list defining the numbers of knots used to model potential
time-varying effects of variables included in the recurrent event model.
This list should be of form <code style="white-space: pre;">&#8288;list(&lt;var_name&gt; = &lt;no. of knots&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_tvc_ce_terms">tvc_ce_terms</code></td>
<td>
<p>A named list defining the numbers of knots used to model potential
time-varying effects of variables included in the competing event model.
This list should be of form <code style="white-space: pre;">&#8288;list(&lt;var_name&gt; = &lt;no. of knots&gt;)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_cluster">cluster</code></td>
<td>
<p>A chara vector specifying the name of the variable that defines unique
observation in the dataset passed to the function.</p>
</td></tr>
<tr><td><code id="test_dfs_JointFPM_+3A_data">data</code></td>
<td>
<p>A stacked dataset that including both data on the recurrent and competing
event process. The dataset should have one row for each observation
including the follow-up time and event indicator for the competing event
and possibly multiple rows for each observation including the follow-up
times and event indicator for the recurrent event, e.g.:
</p>
<div class="sourceCode"><pre>id st_start  st_end re status
 1      0      6.88  0      1
 1      0      6.88  1      0
 2      0      8.70  0      1
 2      0      8.70  1      0
 3      0     10     0      0
 3      0      1.78  1      1
 3      1.78   6.08  1      1
 3      6.08  10     1      0
 4      0      6.07  0      1
 4      0      6.07  1      0
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row per combination of baseline hazards DFs,
and the DFs of the time varying covariates, and the corresponding
AIC and BIC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test different dfs
test_dfs_JointFPM(Surv(time  = start,
                       time2 = stop,
                       event = event,
                       type  = 'counting') ~ 1,
                  re_model = ~ pyridoxine + thiotepa,
                  ce_model = ~ pyridoxine + thiotepa,
                  re_indicator = "re",
                  ce_indicator = "ce",
                  dfs_ce = 1:3,
                  dfs_re = 2,
                  tvc_ce_terms = list(thiotepa   = 1:2),
                  tvc_re_terms = list(pyridoxine = 2),
                  cluster  = "id",
                  data     = bladder1_stacked)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
