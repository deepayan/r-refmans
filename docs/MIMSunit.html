<!DOCTYPE html><html><head><title>Help for package MIMSunit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MIMSunit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate_for_mims'><p>Aggregate over epoch to get numerically integrated values.</p></a></li>
<li><a href='#aggregate_for_orientation'><p>Aggregate over epoch to get estimated accelerometer orientation.</p></a></li>
<li><a href='#bandlimited_interp'><p>Apply a bandlimited interpolation filter to the signal to change the sampling</p>
rate</a></li>
<li><a href='#clip_data'><p>Clip dataframe to the given start and stop time</p></a></li>
<li><a href='#compute_orientation'><p>Estimate the accelerometer orientation</p></a></li>
<li><a href='#conceptual_diagram_data'><p>The input accelerometer data used to generate the conceptual diagram</p>
(Figure 1) in the manuscript.</a></li>
<li><a href='#custom_mims_unit'><p>Compute both MIMS-unit and sensor orientations with custom settings</p></a></li>
<li><a href='#cut_off_signal'><p>Cut off input multi-channel signal according to a new dynamic range</p></a></li>
<li><a href='#cv_different_algorithms'><p>Coefficient of variation values for different acceleration data summary</p>
algorithms</a></li>
<li><a href='#edge_case'><p>A short snippet of raw accelerometer signal from a device that has ending data maxed out.</p></a></li>
<li><a href='#export_to_actilife'><p>Export accelerometer data in Actilife RAW CSV format</p></a></li>
<li><a href='#extrapolate'><p>Extrapolate input multi-channel accelerometer data</p></a></li>
<li><a href='#extrapolate_rate'><p>Get extrapolation rate.</p></a></li>
<li><a href='#generate_interactive_plot'><p>Plot MIMS unit values or raw signal using dygraphs interactive plotting library.</p></a></li>
<li><a href='#iir'><p>Apply IIR filter to the signal</p></a></li>
<li><a href='#illustrate_extrapolation'><p>Plot illustrations about extrapolation in illustration style.</p></a></li>
<li><a href='#illustrate_signal'><p>Plot given raw signal in illustration diagram style.</p></a></li>
<li><a href='#import_actigraph_count_csv'><p>Import Actigraph count data stored in Actigraph summary csv format</p></a></li>
<li><a href='#import_actigraph_csv'><p>Import raw multi-channel accelerometer data stored in Actigraph raw csv</p>
format</a></li>
<li><a href='#import_actigraph_csv_chunked'><p>Import large raw multi-channel accelerometer data stored in Actigraph raw csv</p>
format in chunks</a></li>
<li><a href='#import_actigraph_meta'><p>Import The meta information stored in Actigraph RAW or summary csv file.</p></a></li>
<li><a href='#import_activpal3_csv'><p>Import raw multi-channel accelerometer data stored in ActivPal3 csv format</p></a></li>
<li><a href='#import_enmo_csv'><p>Import ENMO data stored in csv csv</p></a></li>
<li><a href='#import_mhealth_csv'><p>Import raw multi-channel accelerometer data stored in mHealth Specification</p></a></li>
<li><a href='#import_mhealth_csv_chunked'><p>Import large raw multi-channel accelerometer data stored in mHealth Specification</p>
in chunks.</a></li>
<li><a href='#interpolate_signal'><p>Interpolate missing points and unify sampling rate for multi-channel signal</p></a></li>
<li><a href='#measurements_different_devices'><p>The mean and standard deviation of accelerometer summary measure for</p>
different acceleration data summary algorithms and for different devices.</a></li>
<li><a href='#mims_unit'><p>Compute Monitor Independent Motion Summary unit (MIMS-unit)</p></a></li>
<li><a href='#parse_epoch_string'><p>Parse epoch string to the corresponding number of samples it represents.</p></a></li>
<li><a href='#rest_on_table'><p>A short snippet of raw accelerometer signal from a device resting on a table.</p></a></li>
<li><a href='#sample_raw_accel_data'><p>Sample raw accelerometer data</p></a></li>
<li><a href='#sampling_rate'><p>Estimate sampling rate for multi-channel signal</p></a></li>
<li><a href='#segment_data'><p>Segment input dataframe into windows as specified by breaks.</p>
<code>segment_data</code> segments the input sensor dataframe into
epoch windows with length specified in breaks.</a></li>
<li><a href='#sensor_orientations'><p>Estimates sensor orientation</p></a></li>
<li><a href='#shiny_app'><p>Run shiny app to compute MIMSunit values from files</p></a></li>
<li><a href='#simulate_new_data'><p>Simulate new data based on the given multi-channel accelerometer data</p></a></li>
<li><a href='#sum_up'><p>Sum of multi-channel signal.</p></a></li>
<li><a href='#vector_magnitude'><p>Vector magnitude of multi-channel signal.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithm to Compute Monitor Independent Movement Summary Unit
(MIMS-Unit)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-20</td>
</tr>
<tr>
<td>Description:</td>
<td>The MIMS-unit algorithm is developed to compute Monitor Independent
    Movement Summary Unit, a measurement to summarize raw accelerometer data 
    while ensuring harmonized results across different devices. It also includes
    scripts to reproduce results in the related publication 
    (John, D., Tang. Q., Albinali, F. and Intille, S. (2019) &lt;<a href="https://doi.org/10.1123%2Fjmpb.2018-0068">doi:10.1123/jmpb.2018-0068</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mhealthgroup.github.io/MIMSunit/">https://mhealthgroup.github.io/MIMSunit/</a>,
<a href="https://github.com/mhealthgroup/MIMSunit/tree/master">https://github.com/mhealthgroup/MIMSunit/tree/master</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhealthgroup/MIMSunit/issues/">https://github.com/mhealthgroup/MIMSunit/issues/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>caTools (&ge; 1.17.1.1), tibble (&ge; 3.0.4), dplyr (&ge; 0.7.7),
lubridate (&ge; 1.7.4), magrittr (&ge; 1.5), plyr (&ge; 1.8.4), readr
(&ge; 1.1.1), R.utils (&ge; 2.7.0), stringr (&ge; 1.3.1), xts (&ge;
0.11-2), signal (&ge; 0.7-7), dygraphs (&ge; 1.1.1.6), shiny (&ge;
1.4.0.2), RColorBrewer (&ge; 1.1-2), utils (&ge; 3.6.1), ggplot2
(&ge; 3.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, pkgdown, gridExtra, remotes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>memory (&gt;= 4GB) Ubuntu: build-essential,
libxml2-dev, libssl-dev, libcurl4-openssl-dev Windows: Rtools
(&gt;= 3.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-20 09:59:06 UTC; tangqu</td>
</tr>
<tr>
<td>Author:</td>
<td>Qu Tang <a href="https://orcid.org/0000-0001-5415-0205"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Dinesh John [aut],
  Stephen Intille [aut],
  mHealth Research Group [cph] (https://www.mhealthgroup.org)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qu Tang &lt;tang.q@northeastern.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-21 11:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate_for_mims'>Aggregate over epoch to get numerically integrated values.</h2><span id='topic+aggregate_for_mims'></span>

<h3>Description</h3>

<p><code>aggregate_for_mims</code> returns a dataframe with integrated values by
trapzoidal method over each epoch for each column. The epoch start time will
be used as timestamp in the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_for_mims(df, epoch, method = "trapz", rectify = TRUE, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_for_mims_+3A_df">df</code></td>
<td>
<p>dataframe of accelerometer data in mhealth format. First column
should be timestamps in POSIXt format.</p>
</td></tr>
<tr><td><code id="aggregate_for_mims_+3A_epoch">epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5
secs&quot;, &quot;10 mins&quot;.</p>
</td></tr>
<tr><td><code id="aggregate_for_mims_+3A_method">method</code></td>
<td>
<p>string. Integration methods. Supported strings include:
&quot;trapz&quot;, &quot;power&quot;, &quot;sum&quot;, &quot;meanBySecond&quot;, &quot;meanBySize&quot;. Default is &quot;trapz&quot;.</p>
</td></tr>
<tr><td><code id="aggregate_for_mims_+3A_rectify">rectify</code></td>
<td>
<p>logical. If TRUE, input data will be rectified before
integration. Default is TRUE.</p>
</td></tr>
<tr><td><code id="aggregate_for_mims_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a dataframe (in mhealth accelerometer data format) and
computes its aggregated values over each fixed epoch using different
integration methods (default is trapzoidal method, other methods are not used
by mims unit algorithm) for each value columns. The returned dataframe will
have the same number of columns as input dataframe, and have the same
datetime format as input dataframe in the timestamp column. The trapzoidal
method used in the function is based on <code><a href="caTools.html#topic+trapz">trapz</a></code>.
</p>


<h3>Value</h3>

<p>dataframe. The returned dataframe will have the same format as input
dataframe.
</p>


<h3>How is it used in mims-unit algorithm?</h3>

<p>This function is used in
mims-unit algorithm after filtering (<code><a href="#topic+iir">iir</a></code>). The filtered
signal will be rectified and integrated to get mims unit values for each
axis using this function.
</p>


<h3>Note</h3>

<p>If <code>epoch</code> argument is not provided or is <code>NULL</code>, the
function will treat the input dataframe as a single epoch.
</p>
<p>If the number of samples in one segment is less than 90
samples, the aggregation result will be -1 (marker of invalid value).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_for_orientation">aggregate_for_orientation</a></code> for aggregating to get
accelerometer orientation estimation for each epoch.
</p>
<p>Other aggregate functions: 
<code><a href="#topic+aggregate_for_orientation">aggregate_for_orientation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # sample data
  df = sample_raw_accel_data
  head(df)

  # epoch set to 5 seconds, and method set to "trapz"
  aggregate_for_mims(df, epoch = '5 sec', method='trapz')

  # epoch set to 1 second, method set to "sum"
  aggregate_for_mims(df, epoch = '1 sec', method='sum')

  # epoch set to 1 second, and st set to be 1 second before the start time of the data
  # so the first segment will only include data for 1 second, therefore the resulted
  # aggregated value for the first segment will be -1 (invalid) because the
  # samples are not enough. And the second segment starts from 11:00:01, instead
  # of 11:00:02 as shown in prior example,
  aggregate_for_mims(df, epoch = '1 sec', method='sum', st=df[1,1] - 1)
</code></pre>

<hr>
<h2 id='aggregate_for_orientation'>Aggregate over epoch to get estimated accelerometer orientation.</h2><span id='topic+aggregate_for_orientation'></span>

<h3>Description</h3>

<p><code>aggregate_for_orientation</code> returns a dataframe with accelerometer
orientations estimated by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a> over each epoch (see <code><a href="#topic+compute_orientation">compute_orientation</a></code>). The epoch
start time will be used as timestamp in the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_for_orientation(
  df,
  epoch,
  estimation_window = 2,
  unit = "deg",
  st = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_for_orientation_+3A_df">df</code></td>
<td>
<p>dataframe. Input accelerometer data in mhealth format. First column
should be timestamps in POSIXt format.</p>
</td></tr>
<tr><td><code id="aggregate_for_orientation_+3A_epoch">epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5
secs&quot;, &quot;10 mins&quot;.</p>
</td></tr>
<tr><td><code id="aggregate_for_orientation_+3A_estimation_window">estimation_window</code></td>
<td>
<p>number. Duration in seconds to be used to estimate
orientation within each epoch. Default is 2 (seconds), as suggested by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.</p>
</td></tr>
<tr><td><code id="aggregate_for_orientation_+3A_unit">unit</code></td>
<td>
<p>string. The unit of orientation angles. Can be &quot;deg&quot; (degree) or
&quot;rad&quot; (radian). Default is &quot;deg&quot;.</p>
</td></tr>
<tr><td><code id="aggregate_for_orientation_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a dataframe (in mhealth accelerometer data format) and
computes the estimated acclerometer orientations (in x, y, and z angles) over
each fixed epoch. The returned dataframe will have the same format as input
dataframe, including four columns, and have the same datetime format as input
dataframe in the timestamp column. The orientation estimation method used in
the function is based on
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.
</p>


<h3>Value</h3>

<p>dataframe. The returned dataframe will have the same format as input
dataframe.
</p>


<h3>How is it used in mims-unit algorithm?</h3>

<p>This function is used in
mims-unit algorithm after extrapolation (<code><a href="#topic+extrapolate">extrapolate</a></code>). The
extrapolated signal will be estimated to get orientation angles using this
function.
</p>


<h3>Note</h3>

<p>If <code>epoch</code> argument is not provided or is <code>NULL</code>, the
function will treat the input dataframe as a single epoch.
</p>
<p>If the number of samples in an epoch is less than 90
would be NaN (invalid) for this epoch.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a></code> for aggregating to get integrated
values for each axis for each epoch.
</p>
<p>Other aggregate functions: 
<code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample input data
  df = sample_raw_accel_data
  head(df)

  # set epoch to 1 second and unit to degree
  # last epoch does not have enough samples to estimate orientation angles.
  aggregate_for_orientation(df, epoch='1 sec', unit='deg')

  # set epoch to 2 seconds and unit to radian
  # last epoch does not have enough samples to estimate orientation angles.
  aggregate_for_orientation(df, epoch='2 sec', unit='rad')

  # epoch set to 2 seconds, and st set to be 1 second before the start time of the data
  # so the first segment will only include data for 1 second, therefore the resulted
  # aggregated value for the first segment will be -1 (invalid) because the
  # samples are not enough. And the second segment starts from 11:00:01, instead
  # of 11:00:01 as shown in prior example,
  aggregate_for_orientation(df, epoch = '1 sec', unit='rad', st=df[1,1] - 1)

</code></pre>

<hr>
<h2 id='bandlimited_interp'>Apply a bandlimited interpolation filter to the signal to change the sampling
rate</h2><span id='topic+bandlimited_interp'></span>

<h3>Description</h3>

<p><code>bandlimited_interp</code> function takes a multi-channel signal and applies a
bandlimited interpolation filter to the signal to change its sampling rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandlimited_interp(df, orig_sr, new_sr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandlimited_interp_+3A_df">df</code></td>
<td>
<p>dataframe. The input multi-channel signal. The first column is
timestamps in POSXlct format. The rest columns are signal values.</p>
</td></tr>
<tr><td><code id="bandlimited_interp_+3A_orig_sr">orig_sr</code></td>
<td>
<p>number. Sampling rate in Hz of the input signal.</p>
</td></tr>
<tr><td><code id="bandlimited_interp_+3A_new_sr">new_sr</code></td>
<td>
<p>number. The desired sampling rate in Hz of the output signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function filters the input multi-channel signal by applying a bandlimited
interpolation filter. See <code><a href="signal.html#topic+resample">resample</a></code> for the underlying
implementation.
</p>


<h3>Value</h3>

<p>dataframe. Filtered signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is not used in
the released version of MIMS-unit algorithm, but has once been considered
to be used after extrapolation to harmonize sampling rate before filtering.
But in the end, we decided to use linear interpolation before extrapolation
to increase the sampling rate to 100Hz, so this method is no longer needed.
</p>


<h3>See Also</h3>

<p>Other filtering functions: 
<code><a href="#topic+iir">iir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data
  df = sample_raw_accel_data

  # View input
  illustrate_signal(df, plot_maxed_out_line = FALSE)

  # Apply filtering that uses the same setting as in MIMSunit algorithm
  output = bandlimited_interp(df, orig_sr=80, new_sr=30)

  # View output
  illustrate_signal(output, plot_maxed_out_line = FALSE)
</code></pre>

<hr>
<h2 id='clip_data'>Clip dataframe to the given start and stop time</h2><span id='topic+clip_data'></span>

<h3>Description</h3>

<p><code>clip_data</code> clips the input sensor dataframe according to the given
start and stop time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clip_data(df, start_time, stop_time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clip_data_+3A_df">df</code></td>
<td>
<p>dataframe. Input dataframe of the multi-channel signal. The first
column is the timestamps in POSXlct format and the following columns are
accelerometer values.</p>
</td></tr>
<tr><td><code id="clip_data_+3A_start_time">start_time</code></td>
<td>
<p>POSXlct format or character. Start time for clipping.
If it is a character, it should be recognizable by as.POSXlct function.</p>
</td></tr>
<tr><td><code id="clip_data_+3A_stop_time">stop_time</code></td>
<td>
<p>POSXlct format or character. Stop time for clipping.
If it is a character, it should be recognizable by as.POSXlct function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a dataframe of multi-channel signal, clips it
according to the start_time and stop_time.
</p>


<h3>Value</h3>

<p>dataframe. The same format as the input dataframe.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that was used in various part in the algorithm whenever we need to
clip a dataframe.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)
  # Use the provided sample data
  df = sample_raw_accel_data

  # Check the start time and stop time of the dataset
  summary(df)

  # Use timestamp string to clip 1 second data
  start_time = "2016-01-15 11:01:00"
  stop_time = "2016-01-15 11:01:01"
  output = clip_data(df, start_time, stop_time)
  summary(output)

  # Use POSIXct timestamp to clip data
  start_time = as.POSIXct("2016-01-15 11:01:00")
  stop_time = as.POSIXct("2016-01-15 11:01:01")
  output = clip_data(df, start_time, stop_time)
  summary(output)

  # If start and stop time is not in the range of the input data
  # return empty data.frame
  start_time = "2016-01-15 12:01:00"
  stop_time = "2016-01-15 12:01:01"
  output = clip_data(df, start_time, stop_time)
  output

  # Restore original options
  options(default_ops)
</code></pre>

<hr>
<h2 id='compute_orientation'>Estimate the accelerometer orientation</h2><span id='topic+compute_orientation'></span>

<h3>Description</h3>

<p><code>compute_orientation</code> returns a dataframe with accelerometer
orientations estimated by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a> for the input dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_orientation(df, estimation_window = 2, unit = "deg")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_orientation_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel signal. First column should be
timestamps in POSIXt format.</p>
</td></tr>
<tr><td><code id="compute_orientation_+3A_estimation_window">estimation_window</code></td>
<td>
<p>number. window size in seconds to be used to
estimate orientations. Default is 2 (seconds), as suggested by
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.</p>
</td></tr>
<tr><td><code id="compute_orientation_+3A_unit">unit</code></td>
<td>
<p>string. The unit of orientation angles. Can be &quot;deg&quot; (degree) or
&quot;rad&quot; (radian). Default is &quot;deg&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a dataframe (in mhealth accelerometer data format) and
computes the estimated acclerometer orientations (in x, y, and z angles) for
every <code>estimation_window</code> seconds of the entire sequence, and outputs
the mean of these angles. The returned dataframe will have the same format as
input dataframe, including four columns, and have the same datetime format as
input dataframe in the timestamp column. The orientation estimation method
used in the function is based on
<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1241424">Mizell,
2003</a>.
</p>


<h3>Value</h3>

<p>dataframe. The returned dataframe will have the same format as input
dataframe.
</p>


<h3>How is it used in mims-unit algorithm?</h3>

<p>This function is used in
function (<code><a href="#topic+aggregate_for_orientation">aggregate_for_orientation</a></code>).
</p>


<h3>See Also</h3>

<p>Other transformation functions: 
<code><a href="#topic+sum_up">sum_up</a>()</code>,
<code><a href="#topic+vector_magnitude">vector_magnitude</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use first 10 second sample data for testing
  df = sample_raw_accel_data
  df = clip_data(df, start_time = df[1,1], stop_time = df[1, 1] + 600)

  # compute orientation angles in degrees
  compute_orientation(df)

  # compute orientation angles in radian angles
  compute_orientation(df, unit='rad')
</code></pre>

<hr>
<h2 id='conceptual_diagram_data'>The input accelerometer data used to generate the conceptual diagram
(Figure 1) in the manuscript.</h2><span id='topic+conceptual_diagram_data'></span>

<h3>Description</h3>

<p>The dataset includes accelerometer data from four devices. Device 0 is a real
Actigraph GT9X device configured at 80Hz and 8g. Device 1 to 3 are simulated
data from the data of device 0 using function <code><a href="#topic+simulate_new_data">simulate_new_data</a></code>.
Data for device 0 is a random selected nondominant wrist data from a
participant doing Jumping jack. The data is manipulated to insert an
artificial impulse to demonstrate the effect of the MIMS-unit algorithm when
dealing on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conceptual_diagram_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1704 rows and 5 variables:
</p>

<dl>
<dt>HEADER_TIME_STAMP</dt><dd><p>The timestamp of raw accelerometer data, in POSIXct</p>
</dd>
<dt>X</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
<dt>GRANGE</dt><dd><p>The dynamic range of the simulated device in g, in number</p>
</dd>
<dt>SR</dt><dd><p>The sampling rate in Hz of the simulated device, in number</p>
</dd>
<dt>NAME</dt><dd><p>An alternative name that is friendly for plotting for different devices, in character</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit/">https://github.com/mHealthGroup/MIMSunit/</a>
</p>

<hr>
<h2 id='custom_mims_unit'>Compute both MIMS-unit and sensor orientations with custom settings</h2><span id='topic+custom_mims_unit'></span>

<h3>Description</h3>

<p><code>custom_mims_unit</code> computes the Monitor Independent Motion Summary unit
and estimates the sensor orientations for the input multi-channel
accelerometer signal with custom settings. The input signal can be from
devices of any sampling rate and dynamic range. Please refer to the
manuscript for detailed description of the algorithm. Please refer to
functions for the intermediate steps: <code><a href="#topic+extrapolate">extrapolate</a></code> for
extrapolation, <code><a href="#topic+iir">iir</a></code> for filtering,
<code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a></code> and <code><a href="#topic+aggregate_for_orientation">aggregate_for_orientation</a></code>
for aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_mims_unit(
  df,
  epoch = "5 sec",
  dynamic_range,
  noise_level = 0.03,
  k = 0.05,
  spar = 0.6,
  filter_type = "butter",
  cutoffs = c(0.2, 5),
  axes = c(2, 3, 4),
  use_extrapolation = TRUE,
  use_filtering = TRUE,
  combination = "sum",
  allow_truncation = TRUE,
  output_mims_per_axis = FALSE,
  output_orientation_estimation = FALSE,
  epoch_for_orientation_estimation = NULL,
  before_df = NULL,
  after_df = NULL,
  use_gui_progress = FALSE,
  st = NULL,
  use_snapshot_to_check = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_mims_unit_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_epoch">epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5
sec&quot;, &quot;10 min&quot;. Default is &quot;5 sec&quot;.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_dynamic_range">dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_noise_level">noise_level</code></td>
<td>
<p>number. The tolerable noise level in <code class="reqn">g</code> unit, should
be between 0 and 1. Default is 0.03, which applies to most devices.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_k">k</code></td>
<td>
<p>number. Duration of neighborhood to be used in local spline
regression for each side, in seconds. Default is 0.05, as optimized by
MIMS-unit algorithm.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_spar">spar</code></td>
<td>
<p>number. Between 0 and 1, to control how smooth we want to fit
local spline regression, 0 is linear and 1 matches all local points.
Default is 0.6, as optimized by MIMS-unit algorithm.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_filter_type">filter_type</code></td>
<td>
<p>string. The type of filter to be applied. Could be
'butter' for butterworth bandpass filter, 'ellip' for elliptic bandpass
filter or 'bessel' for bessel lowpass filter + average removal highpass
filter. Default is &quot;butter&quot;.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_cutoffs">cutoffs</code></td>
<td>
<p>numerical vector. Cut off frequencies to be used in filtering.
If <code>filter_type</code> is &quot;bessel&quot;, the cut off frequency for lowpass filter
would be multiplied by 2 when being used. Default is 0.2Hz and 5Hz.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_axes">axes</code></td>
<td>
<p>numerical vector. Indices of columns that specifies the axis
values of the input signal. Default is <code>c(2,3,4)</code>.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_use_extrapolation">use_extrapolation</code></td>
<td>
<p>logical. If it is TRUE, the function will apply
extrapolation algorithm to the input signal, otherwise it will skip
extrapolation but only linearly interpolate the signal to 100Hz. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_use_filtering">use_filtering</code></td>
<td>
<p>logical. If it is TRUE, the function will apply bandpass
filtering to the input signal, otherwise it will skip the filtering.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_combination">combination</code></td>
<td>
<p>string. Method to combine MIMS-unit values for each axis.
Could be &quot;sum&quot; for <code><a href="#topic+sum_up">sum_up</a></code> or &quot;vm&quot; for
<code><a href="#topic+vector_magnitude">vector_magnitude</a></code>.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_allow_truncation">allow_truncation</code></td>
<td>
<p>logical. If it is TRUE, the algorithm will truncate
very small MIMS-unit values to zero. Default is TRUE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_output_mims_per_axis">output_mims_per_axis</code></td>
<td>
<p>logical. If it is TRUE, the output MIMS-unit
dataframe will have MIMS-unit values for each axis from the third column.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_output_orientation_estimation">output_orientation_estimation</code></td>
<td>
<p>logical. If it is TRUE, the function
will also estimate sensor orientations over each epoch. And the output will
be a list, with the first element being the MIMS-unit dataframe, and the
second element being the sensor orientation dataframe. Default is FALSE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_epoch_for_orientation_estimation">epoch_for_orientation_estimation</code></td>
<td>
<p>string. string. Any format that is
acceptable by argument <code>breaks</code> in method
<code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5 sec&quot;, &quot;10
min&quot;. Default is &quot;5 sec&quot;. It is independent from <code>epoch</code> for
MIMS-unit.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_before_df">before_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes
before the input signal to be prepended to the input signal during
computation. This is used to eliminate the edge effect during extrapolation
and filtering. If it is <code>NULL</code>, algorithm will run directly on the
input signal. Default is NULL.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_after_df">after_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes after
the input signal to be append to the input signal. This is used to
eliminate the edge effect during extrapolation and filtering. If it is
<code>NULL</code>, algorithm will run directly on the input signal. Default is
NULL.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_use_gui_progress">use_gui_progress</code></td>
<td>
<p>logical. If it is TRUE, show GUI progress bar on
windows platform. Default is FALSE.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
<tr><td><code id="custom_mims_unit_+3A_use_snapshot_to_check">use_snapshot_to_check</code></td>
<td>
<p>logical. If TRUE, the function will use the first
100 rows or 10
the algorithm will use all data to check timestamp duplications. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe or list. If <code>output_orientation_estimation</code> is TRUE,
the output will be a list, otherwise the output will be the MIMS-unit
dataframe.
</p>
<p>The first element will be the MIMS-unit dataframe, in which the first
column is the start time of each epoch in POSIXct format, and the second
column is the MIMS-unit value for the input signal, and the third column
and on are the MIMS-unit values for each axis of the input signal if
<code>output_mims_per_axis</code> is TRUE.
</p>
<p>The second element will be the orientation dataframe, in which the first
column is the start time of each epoch in POSIXct format, and the second to
fourth column is the estimated orientations for the input signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This is the low-level entry
of MIMS-unit and orientation estimation algorithm. <code><a href="#topic+mims_unit">mims_unit</a></code>
calls this function internally.
</p>


<h3>Note</h3>

<p>This function allows you to run customized algorithm for MIMSunit and
sensor orientations.
</p>
<p><code>before_df</code> and <code>after_df</code> are often set when the accelerometer
data are divided into files of smaller chunk.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code><a href="#topic+mims_unit">mims_unit</a>()</code>,
<code><a href="#topic+sensor_orientations">sensor_orientations</a>()</code>,
<code><a href="#topic+shiny_app">shiny_app</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # compute mims unit values with custom parameter
  output = custom_mims_unit(df, epoch = '1 sec', dynamic_range=c(-8, 8), spar=0.7)
  head(output)
</code></pre>

<hr>
<h2 id='cut_off_signal'>Cut off input multi-channel signal according to a new dynamic range</h2><span id='topic+cut_off_signal'></span>

<h3>Description</h3>

<p><code>cut_off_signal</code> cuts off the input multi-channel accelerometer data
according to a new dynamic range, then adds gausian noise to the cut-off
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_off_signal(df, range = NULL, noise_std = 0.03)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_off_signal_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer data.</p>
</td></tr>
<tr><td><code id="cut_off_signal_+3A_range">range</code></td>
<td>
<p>numerical vector. The new dynamic ranges to cut off the signal.
Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach. Default is <code>NULL</code>,
meaning the function will do nothing but return the input data.</p>
</td></tr>
<tr><td><code id="cut_off_signal_+3A_noise_std">noise_std</code></td>
<td>
<p>number. The standard deviation of the added gaussian noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the behavior that a low dynamic range device is
trying to record high intensity movement, where recorded accelerometer signal
will be cut off at the dynamic range, but the true movement should have
higher acceleration values than the dynamic range. This function also adds
gaussian noise to the cut off samples to better simulate the real world
situation.
</p>


<h3>Value</h3>

<p>dataframe. The multi-channel accelerometer data with the new dynamic
range as specified in <code>range</code>.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that is used to simulate the behaviors of low dynamic range
devices during algorithm validation.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # Show df
  illustrate_signal(df, range=c(-8, 8))

  # cut off the signal to c(-2, 2)
  new_df = cut_off_signal(df, range=c(-2, 2), noise_std=0.03)

  # Show new df
  illustrate_signal(new_df, range=c(-2, 2))
</code></pre>

<hr>
<h2 id='cv_different_algorithms'>Coefficient of variation values for different acceleration data summary
algorithms</h2><span id='topic+cv_different_algorithms'></span>

<h3>Description</h3>

<p>A dataset containing the coefficient of variation values at different
frequencies for the dataset that includes accelerometer measures of different
devices on a standard elliptical shaker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_different_algorithms
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 3 variables:
</p>

<dl>
<dt>TYPE</dt><dd><p>Accelerometer summary algorithm name, in character</p>
</dd>
<dt>HZ</dt><dd><p>The frequency of the elliptical shaker, in number</p>
</dd>
<dt>COEFF_OF_VARIATION</dt><dd><p>The coefficient of variation values, in number</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit-dataset-shaker/">https://github.com/mHealthGroup/MIMSunit-dataset-shaker/</a>
</p>

<hr>
<h2 id='edge_case'>A short snippet of raw accelerometer signal from a device that has ending data maxed out.</h2><span id='topic+edge_case'></span>

<h3>Description</h3>

<p>The dataset includes accelerometer data sampled at 80Hz and 6g. This data is used to test the edge case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_case
</code></pre>


<h3>Format</h3>

<p>A data frame with 20001 rows and 4 variables:
</p>

<dl>
<dt>HEADER_TIME_STAMP</dt><dd><p>The timestamp of raw accelerometer data, in POSIXct</p>
</dd>
<dt>X</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
<dt>Y</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
<dt>Z</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit/">https://github.com/mHealthGroup/MIMSunit/</a>
</p>

<hr>
<h2 id='export_to_actilife'>Export accelerometer data in Actilife RAW CSV format</h2><span id='topic+export_to_actilife'></span>

<h3>Description</h3>

<p><code>export_to_actilife</code> exports the input dataframe as a csv file that is
compatible with Actilife.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_to_actilife(
  df,
  filepath,
  actilife_version = "6.13.3",
  firmware_version = "1.6.0"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_to_actilife_+3A_df">df</code></td>
<td>
<p>dataframe. Input accelerometer data. The first column is timestamp
in POSXlct format, and the rest columns are accelerometer values in g
(<code class="reqn">9.81m/s^2</code>).</p>
</td></tr>
<tr><td><code id="export_to_actilife_+3A_filepath">filepath</code></td>
<td>
<p>string. The output filepath.</p>
</td></tr>
<tr><td><code id="export_to_actilife_+3A_actilife_version">actilife_version</code></td>
<td>
<p>string. The Actilife version number to be added to
the header. Default is &quot;6.13.3&quot;, that was used by the algorithm during
development.</p>
</td></tr>
<tr><td><code id="export_to_actilife_+3A_firmware_version">firmware_version</code></td>
<td>
<p>string. The firmware version number to be added to
the header. This is supposed to be the firmware version of the Actigraph
devices. We did not see any usage of the number during the computation of
Actigraph counts by Actilife, so it may be set with an arbitrary version
code seen in any Actigraph devices. We use default version code &quot;1.6.0&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an input accelerometer dataframe and exports it in
Actilife RAW CSV format with a prepended a madeup header. The exported file
csv file has compatible header, column names, timestamp format with Actilife
and can be imported directly into Actilife software.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is an utility
function that was used to convert validation data into Actilife RAW CSV
format so that we can use Actilife to compute Actigraph counts values for
these data.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the first 5 rows from sample data
  df = sample_raw_accel_data[1:5,]
  head(df)

  # Save to current path with default mocked actilife and firmware versions
  filepath = tempfile()
  export_to_actilife(df, filepath)

  # The saved file will have the same format as Actigraph csv files
  readLines(filepath)

  # Cleanup
  file.remove(filepath)
</code></pre>

<hr>
<h2 id='extrapolate'>Extrapolate input multi-channel accelerometer data</h2><span id='topic+extrapolate'></span><span id='topic+extrapolate_single_col'></span>

<h3>Description</h3>

<p><code>extrapolate</code> applies the extrapolation algorithm to a multi-channel
accelerometer data, trying to reconstruct the true movement from the
maxed-out samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrapolate(df, ...)

extrapolate_single_col(
  t,
  value,
  range,
  noise_level = 0.03,
  k = 0.05,
  spar = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrapolate_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer data. Used in
<code><a href="#topic+extrapolate">extrapolate</a></code>.  The first column should be the date/time</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_...">...</code></td>
<td>
<p>see following parameter list.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_t">t</code></td>
<td>
<p>POSIXct or numeric vector. Input index or timestamp sequence Used in
<code><a href="#topic+extrapolate_single_col">extrapolate_single_col</a></code>.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_value">value</code></td>
<td>
<p>numeric vector. Value vector used in
<code><a href="#topic+extrapolate_single_col">extrapolate_single_col</a></code>.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_range">range</code></td>
<td>
<p>numeric vector. The dynamic ranges of the input signal. Should
be a 2-element numeric vector. <code>c(low, high)</code>, where <code>low</code> is
the negative max value the device can reach and <code>high</code> is the positive
max value the device can reach.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_noise_level">noise_level</code></td>
<td>
<p>number. The tolerable noise level in <code class="reqn">g</code> unit, should
be between 0 and 1. Default is 0.03, which applies to most devices.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_k">k</code></td>
<td>
<p>number. Duration of neighborhood to be used in local spline
regression for each side, in seconds. Default is 0.05, as optimized by
MIMS-unit algorithm.</p>
</td></tr>
<tr><td><code id="extrapolate_+3A_spar">spar</code></td>
<td>
<p>number. Between 0 and 1, to control how smooth we want to fit
local spline regression, 0 is linear and 1 matches all local points.
Default is 0.6, as optimized by MIMS-unit algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first linearly interpolates the input signal to 100Hz, and then
applies the extrapolation algorithm (see the manuscript) to recover the
maxed-out samples. Maxed-out samples are samples that are cut off because the
intensity of the underlying movement exceeds the dynamic range of the device.
</p>
<p><code>extrapolate</code> processes a dataframe of a multi-channel accelerometer
signal. <code>extrapolate_single_col</code> processes a single-channel signal with
its timestamps and values specified in the first and second arguments.
</p>


<h3>Value</h3>

<p><code>extraplate</code> returns a dataframe with extrapolated multi-channel
signal. <code>extrapolate_single_col</code> returns a dataframe with extrapolated
single-channel signal, the timestamp col is in numeric values instead of
POSIXct format.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is the first
step during MIMS-unit algorithm, applied before filtering.
</p>


<h3>See Also</h3>

<p>Other extrapolation related functions: 
<code><a href="#topic+extrapolate_rate">extrapolate_rate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the maxed-out data for the conceptual diagram
  df = conceptual_diagram_data[
          conceptual_diagram_data['GRANGE'] == 4,
          c("HEADER_TIME_STAMP", "X")]

  # Plot input
  illustrate_signal(df, range=c(-4, 4))

  # Use the default parameter settings as in MIMunit algorithms
  # The dynamic range of the input data is -4g to 4g.
  output = extrapolate(df, range=c(-4, 4))

  # Plot output
  illustrate_signal(output, range=c(-4, 4))
</code></pre>

<hr>
<h2 id='extrapolate_rate'>Get extrapolation rate.</h2><span id='topic+extrapolate_rate'></span>

<h3>Description</h3>

<p><code>extrapolate_rate</code> computes the extrapolation rate given the test signal
(maxed out), the true complete signal (no maxed out) and the extrapolated
signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrapolate_rate(test_df, true_df, extrap_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrapolate_rate_+3A_test_df">test_df</code></td>
<td>
<p>dataframe. See details for the input format.</p>
</td></tr>
<tr><td><code id="extrapolate_rate_+3A_true_df">true_df</code></td>
<td>
<p>dataframe. See details for the input format.</p>
</td></tr>
<tr><td><code id="extrapolate_rate_+3A_extrap_df">extrap_df</code></td>
<td>
<p>dataframe. See details for the input format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three input dataframes will have the same format, with the first column
being timestamps in POSXlct format, and the following columns being
acceleration values in g.
</p>


<h3>Value</h3>

<p>number. The extrapolation rate value in double format. If
extrapolation rate is 1, it means the extrapolated signal recovers as the
true signal. If extrapolation rate is between 0 and 1, it means the
extrapolation helps reducing the errors caused by signal maxing out. If
extrapolation rate is smaller than 0, it means the extrapolation increases
the errors caused by signal maxing out (during over extrapolation).
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is used to
compute extrapolation rate during extrapolation parameter optimization. You
may see results in Figure 2 of the manuscript.
</p>


<h3>See Also</h3>

<p>Other extrapolation related functions: 
<code><a href="#topic+extrapolate">extrapolate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Prepare data for test, ground truth
  test_df = conceptual_diagram_data[
                conceptual_diagram_data['GRANGE'] == 4,
                c("HEADER_TIME_STAMP", "X")]
  true_df = conceptual_diagram_data[
                conceptual_diagram_data['GRANGE'] == 8,
                c("HEADER_TIME_STAMP", "X")]

  # Do extrapolation
  extrap_df = extrapolate(test_df, range=c(-4, 4))

  # Compute extrapolation rate
  extrapolate_rate(test_df, true_df, extrap_df)
</code></pre>

<hr>
<h2 id='generate_interactive_plot'>Plot MIMS unit values or raw signal using dygraphs interactive plotting library.</h2><span id='topic+generate_interactive_plot'></span>

<h3>Description</h3>

<p><code>generate_interactive_plot</code> plots MIMS unit values or raw signal
using dygraphs interactive plotting library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_interactive_plot(df, y_label, value_cols = c(2, 3, 4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_interactive_plot_+3A_df">df</code></td>
<td>
<p>data.frame.The dataframe storing MIMS unit values or raw
accelerometer signal. The first column should be timestamps.</p>
</td></tr>
<tr><td><code id="generate_interactive_plot_+3A_y_label">y_label</code></td>
<td>
<p>str. The label name to be put on the y axis.</p>
</td></tr>
<tr><td><code id="generate_interactive_plot_+3A_value_cols">value_cols</code></td>
<td>
<p>numerical vector. The indices of columns storing values,
typically starting from the second column. The default is 'c(2,3,4)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dygraphs graph object. When showing, the graph will be plotted in
a html widgets in an opened browser.
</p>


<h3>See Also</h3>

<p>Other visualization functions.: 
<code><a href="#topic+illustrate_extrapolation">illustrate_extrapolation</a>()</code>,
<code><a href="#topic+illustrate_signal">illustrate_signal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # Plot using default settings, due to pkgdown limitation, no interactive
  # plots will be shown on the website page.
  generate_interactive_plot(df,
                            y_label="Acceleration (g)")

  # The function can be used to plot MIMS unit values as well
  mims = mims_unit(df, dynamic_range=c(-8, 8))
  generate_interactive_plot(mims,
                            y_label="MIMS-unit values",
                            value_cols=c(2))
</code></pre>

<hr>
<h2 id='iir'>Apply IIR filter to the signal</h2><span id='topic+iir'></span>

<h3>Description</h3>

<p><code>iir</code> function takes a multi-channel signal and applies an IIR filter to
the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iir(df, sr, cutoff_freq, order = 4, type = "high", filter_type = "butter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iir_+3A_df">df</code></td>
<td>
<p>dataframe. The input multi-channel signal. The first column is
timestamps in POSXlct format. The rest columns are signal values.</p>
</td></tr>
<tr><td><code id="iir_+3A_sr">sr</code></td>
<td>
<p>number. Sampling rate in Hz of the input signal.</p>
</td></tr>
<tr><td><code id="iir_+3A_cutoff_freq">cutoff_freq</code></td>
<td>
<p>number or numerical vector. The cutoff frequencies in Hz.
If the IIR filter is a bandpass or bandstop filter, it will be a 2-element
numerical vector specifying the low and high end cutoff frequencies
<code>c(low, high)</code>.</p>
</td></tr>
<tr><td><code id="iir_+3A_order">order</code></td>
<td>
<p>number. The order of the filter. Default is 4.</p>
</td></tr>
<tr><td><code id="iir_+3A_type">type</code></td>
<td>
<p>string. Filtering type, one of &quot;low&quot; for a low-pass filter,
&quot;high&quot; for a high-pass filter, &quot;stop&quot; for a stop-band (band-reject) filter,
or &quot;pass&quot; for a pass-band filter.</p>
</td></tr>
<tr><td><code id="iir_+3A_filter_type">filter_type</code></td>
<td>
<p>string. IIR filter type, one of &quot;butter&quot; for butterworth
filter, &quot;chebyI&quot; for Chebyshev Type I filter, or &quot;ellip&quot; for Elliptic filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function filters the input multi-channel signal by applying an IIR
filter. See
<a href="https://en.wikipedia.org/wiki/Infinite_impulse_response">wiki</a> for the
explanation of the filter. The implementations of IIR filters can be found in
<code><a href="signal.html#topic+butter">butter</a></code>, <code><a href="signal.html#topic+cheby1">cheby1</a></code>, and <code><a href="signal.html#topic+ellip">ellip</a></code>.
</p>
<p>For Chebyshev Type I, Type II and Elliptic filter, the passband ripple is
fixed to be 0.05 dB. For Elliptic filter, the stopband ripple is fixed to be
-50dB.
</p>


<h3>Value</h3>

<p>dataframe. Filtered signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function has been used
as the main filtering method in MIMS-unit algorithm. Specifically, it uses
a 0.5 - 5 Hz bandpass butterworth filter during filtering.
</p>


<h3>See Also</h3>

<p>Other filtering functions: 
<code><a href="#topic+bandlimited_interp">bandlimited_interp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data
  df = sample_raw_accel_data

  # View input
  illustrate_signal(df, plot_maxed_out_line = FALSE)

  # Apply filtering that uses the same setting as in MIMSunit algorithm
  output = iir(df, sr=80, cutoff_freq=c(0.2, 5), type='pass')

  # View output
  illustrate_signal(output, plot_maxed_out_line = FALSE)
</code></pre>

<hr>
<h2 id='illustrate_extrapolation'>Plot illustrations about extrapolation in illustration style.</h2><span id='topic+illustrate_extrapolation'></span>

<h3>Description</h3>

<p><code>illustrate_extrapolation</code> plots elements of extrapolations
(e.g., marked points, reference lines) in the same style as
<code><a href="#topic+illustrate_signal">illustrate_signal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate_extrapolation(
  df,
  dynamic_range,
  title = NULL,
  show_neighbors = TRUE,
  show_extrapolated_points_and_lines = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illustrate_extrapolation_+3A_df">df</code></td>
<td>
<p>data.frame.The original data before extrapolation.</p>
</td></tr>
<tr><td><code id="illustrate_extrapolation_+3A_dynamic_range">dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td></tr>
<tr><td><code id="illustrate_extrapolation_+3A_title">title</code></td>
<td>
<p>Char. The title of the plot.</p>
</td></tr>
<tr><td><code id="illustrate_extrapolation_+3A_show_neighbors">show_neighbors</code></td>
<td>
<p>bool. Show the points used for extrapolation if TRUE.</p>
</td></tr>
<tr><td><code id="illustrate_extrapolation_+3A_show_extrapolated_points_and_lines">show_extrapolated_points_and_lines</code></td>
<td>
<p>bool. Show the extrapolated points
and curves used for extrapolation.</p>
</td></tr>
<tr><td><code id="illustrate_extrapolation_+3A_...">...</code></td>
<td>
<p>Parameters that can be used to tune extrapolation, including
<code>spar</code>, <code>k</code>, and <code>noise_level</code>. See <code><a href="#topic+extrapolate">extrapolate</a></code>
for explanations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graph object. The graph to be shown.
</p>


<h3>See Also</h3>

<p>Other visualization functions.: 
<code><a href="#topic+generate_interactive_plot">generate_interactive_plot</a>()</code>,
<code><a href="#topic+illustrate_signal">illustrate_signal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the maxed-out data for the conceptual diagram
  df = conceptual_diagram_data[
         conceptual_diagram_data['GRANGE'] == 2,
         c("HEADER_TIME_STAMP", "X")]

  # Plot extrapolation illustration using default settings
  illustrate_extrapolation(df, dynamic_range=c(-2,2))

  # Do not show neighbor points
  illustrate_extrapolation(df, dynamic_range=c(-2,2), show_neighbors=FALSE)

  # Do not show extrapolated points and lines
  illustrate_extrapolation(df,
                           dynamic_range=c(-2,2),
                           show_extrapolated_points_and_lines=FALSE)
</code></pre>

<hr>
<h2 id='illustrate_signal'>Plot given raw signal in illustration diagram style.</h2><span id='topic+illustrate_signal'></span>

<h3>Description</h3>

<p><code>illustrate_signal</code> plots the given uniaxial signal in illustration diagram style.
Illustration diagram style hides axes markers, unnecessary guidelines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate_signal(
  data,
  point_size = 0.3,
  plot_point = TRUE,
  line_size = 0.3,
  plot_line = TRUE,
  range = c(-2, 2),
  plot_maxed_out_line = TRUE,
  plot_origin = TRUE,
  title = NULL,
  plot_title = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illustrate_signal_+3A_data">data</code></td>
<td>
<p>data.frame. The input uniaxial signal. First column should be timestamp.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_point_size">point_size</code></td>
<td>
<p>number. The size of the plotted data point.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_plot_point">plot_point</code></td>
<td>
<p>Bool. Plot signal as points if TRUE.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_line_size">line_size</code></td>
<td>
<p>number. The line width of the plotted signal curve.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_plot_line">plot_line</code></td>
<td>
<p>Bool. Plot signal with curve if TRUE.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_range">range</code></td>
<td>
<p>vector. Dynamic range of the signal.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_plot_maxed_out_line">plot_maxed_out_line</code></td>
<td>
<p>Bool. Plot dynamic range lines if TRUE. Dynamic range is set by 'range'.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_plot_origin">plot_origin</code></td>
<td>
<p>Bool. Plot the 0 horizontal line if TRUE.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_title">title</code></td>
<td>
<p>Char. The title of the plot.</p>
</td></tr>
<tr><td><code id="illustrate_signal_+3A_plot_title">plot_title</code></td>
<td>
<p>Bool. Plot title if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graph object. The graph to be shown.
</p>


<h3>See Also</h3>

<p>Other visualization functions.: 
<code><a href="#topic+generate_interactive_plot">generate_interactive_plot</a>()</code>,
<code><a href="#topic+illustrate_extrapolation">illustrate_extrapolation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # Plot it with default settings
  illustrate_signal(df)

  # Plot with a different style
  illustrate_signal(df, point_size=1, line_size=1)

  # Turn off annotation lines
  illustrate_signal(df, plot_maxed_out_line = FALSE, plot_origin = FALSE)

  # Use title
  illustrate_signal(df, plot_title=TRUE, title = "This is a title")
</code></pre>

<hr>
<h2 id='import_actigraph_count_csv'>Import Actigraph count data stored in Actigraph summary csv format</h2><span id='topic+import_actigraph_count_csv'></span>

<h3>Description</h3>

<p><code>import_actigraph_count_csv</code> imports Actigraph count data stored in
Actigraph summary csv format, which was exported by Actilife.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_actigraph_count_csv(
  filepath,
  count_col = 2,
  count_per_axis_cols = c(2, 3, 4)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_actigraph_count_csv_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
<tr><td><code id="import_actigraph_count_csv_+3A_count_col">count_col</code></td>
<td>
<p>number. The index of column of Actigraph count (combined
axes). If it is <code>NULL</code>, the function will use
<code>count_per_axis_cols</code> to get the combined Actigraph count values.</p>
</td></tr>
<tr><td><code id="import_actigraph_count_csv_+3A_count_per_axis_cols">count_per_axis_cols</code></td>
<td>
<p>numerical vector. The indices of columns of
Actigraph count values per axis. If <code>count_col</code> is not <code>NULL</code>,
the argument will be ignored. If it is <code>NULL</code>, the output dataframe
will only have two columns without Actigraph count values per axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The imported actigraph count data, with the first column
being the timestamps in POSIXct format, and the second column being the
combined Actigraph count values, and the rest of columns being the
Actigraph cont values per axis if available. Column names:
<code>HEADER_TIME_STAMP</code>, <code>ACTIGRAPH_COUNT</code>,
<code>ACTIGRAPH_COUNT_X</code>....
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import Actigraph count data from Actigraph devices
during algorithm validation.
</p>


<h3>Note</h3>

<p>If both <code>count_col</code> and <code>count_per_axis_cols</code> are
<code>NULL</code>, the function will raise an error.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the actigraph count csv file shipped with the package
  filepath = system.file('extdata', 'actigraph_count.csv', package='MIMSunit')

  # Check original data format
  readLines(filepath)[1:5]

  # Load file, default column for actigraph count values are 2, this file does not have
  # axial count values
  output = import_actigraph_count_csv(filepath, count_col=2)

  # Check output
  head(output)
</code></pre>

<hr>
<h2 id='import_actigraph_csv'>Import raw multi-channel accelerometer data stored in Actigraph raw csv
format</h2><span id='topic+import_actigraph_csv'></span>

<h3>Description</h3>

<p><code>import_actigraph_csv</code> imports the raw multi-channel accelerometer data
stored in Actigraph raw csv format. It supports files from the following
devices: GT3X, GT3X+, GT3X+BT, GT9X, and GT9X-IMU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_actigraph_csv(
  filepath,
  in_voltage = FALSE,
  has_ts = TRUE,
  header = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_actigraph_csv_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data. The first column of
the input data should always include timestamps.</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_+3A_in_voltage">in_voltage</code></td>
<td>
<p>set as TRUE only when the input Actigraph csv file is in
analog quantized format and need to be converted into g value</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_+3A_has_ts">has_ts</code></td>
<td>
<p>boolean. If TRUE, the input csv file will have a timestamp column.</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_+3A_header">header</code></td>
<td>
<p>boolean. If TRUE, the input csv file will have column names in
the first row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For old device (GT3X) that stores accelerometer values as digital voltage.
The function will convert the values to <code class="reqn">g</code> unit using the following
equation.
</p>
<p style="text-align: center;"><code class="reqn">x_g = \frac{x_{voltage}r}{(2 ^ r) - \frac{v}{2}}</code>
</p>

<p>Where <code class="reqn">v</code> is the max voltage corresponding to the max accelerometer value
that can be found in the meta section in the csv file; <code class="reqn">r</code> is the
resolution level which is the number of bits used to store the voltage
values. <code class="reqn">r</code> can also be found in the meta section in the csv file.
</p>


<h3>Value</h3>

<p>dataframe. The imported multi-channel accelerometer signal, with the
first column being the timestamps in POSXlct format, and the rest columns
being accelerometer values in <code class="reqn">g</code> unit.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import data from Actigraph devices during
algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)

  # Use the sample actigraph csv file provided by the package
  filepath = system.file('extdata', 'actigraph_timestamped.csv', package='MIMSunit')

  # Check file format
  readLines(filepath)[1:15]

  # Load the file with timestamp column
  df = import_actigraph_csv(filepath)

  # Check loaded file
  head(df)

  # Check more
  summary(df)

  # Use the sample actigraph csv file without timestamp
  filepath = system.file('extdata', 'actigraph_no_timestamp.csv', package='MIMSunit')

  # Check file format
  readLines(filepath)[1:15]

  # Load the file without timestamp column
  df = import_actigraph_csv(filepath, has_ts = FALSE)

  # Check loaded file
  head(df)

  # Check more
  summary(df)

  # Restore default options
  options(default_ops)
</code></pre>

<hr>
<h2 id='import_actigraph_csv_chunked'>Import large raw multi-channel accelerometer data stored in Actigraph raw csv
format in chunks</h2><span id='topic+import_actigraph_csv_chunked'></span>

<h3>Description</h3>

<p><code>import_actigraph_csv_chunked</code> imports the raw multi-channel accelerometer data
stored in Actigraph raw csv format. It supports files from the following
devices: GT3X, GT3X+, GT3X+BT, GT9X, and GT9X-IMU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_actigraph_csv_chunked(
  filepath,
  in_voltage = FALSE,
  header = TRUE,
  has_ts = TRUE,
  chunk_samples = 180000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_actigraph_csv_chunked_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.The first column of
the input data should always include timestamps.</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_chunked_+3A_in_voltage">in_voltage</code></td>
<td>
<p>set as TRUE only when the input Actigraph csv file is in
analog quantized format and need to be converted into g value</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_chunked_+3A_header">header</code></td>
<td>
<p>boolean. If TRUE, the input csv file will have column names in
the first row.</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_chunked_+3A_has_ts">has_ts</code></td>
<td>
<p>boolean. If TRUE, the input csv file should have a timestamp
column at first.</p>
</td></tr>
<tr><td><code id="import_actigraph_csv_chunked_+3A_chunk_samples">chunk_samples</code></td>
<td>
<p>number. The number of samples in each chunk. Default is
180000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For old device (GT3X) that stores accelerometer values as digital voltage.
The function will convert the values to <code class="reqn">g</code> unit using the following
equation.
</p>
<p style="text-align: center;"><code class="reqn">x_g = \frac{x_{voltage}r}{(2 ^ r) - \frac{v}{2}}</code>
</p>

<p>Where <code class="reqn">v</code> is the max voltage corresponding to the max accelerometer value
that can be found in the meta section in the csv file; <code class="reqn">r</code> is the
resolution level which is the number of bits used to store the voltage
values. <code class="reqn">r</code> can also be found in the meta section in the csv file.
</p>


<h3>Value</h3>

<p>list. The list contains two items. The first item is a generator
function that each time it is called, it will return a data.frame of the
imported chunk. The second item is a <code>close</code> function which you can
call at any moment to close the file loading.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import data from Actigraph devices during
algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)

  # Use the actigraph csv file shipped with the package
  filepath = system.file('extdata', 'actigraph_timestamped.csv', package='MIMSunit')

  # Check original file format
  readLines(filepath)[1:15]

  # Example 1: Load chunks every 2000 samples
  results = import_actigraph_csv_chunked(filepath, chunk_samples=2000)
  next_chunk = results[[1]]
  close_connection = results[[2]]
  # Check data as chunks, you can see chunks are shifted at each iteration.
  n = 1
  repeat {
    df = next_chunk()
    if (nrow(df) &gt; 0) {
      print(paste('chunk', n))
      print(paste("df:", df[1, 1], '-', df[nrow(df),1]))
      n = n + 1
    }
    else {
      break
    }
  }

  # Close connection after reading all the data
  close_connection()

  # Example 2: Close loading early
  results = import_actigraph_csv_chunked(filepath, chunk_samples=2000)
  next_chunk = results[[1]]
  close_connection = results[[2]]
  # Check data as chunks, you can see chunk time is shifting forward at each iteration.
  n = 1
  repeat {
    df = next_chunk()
    if (nrow(df) &gt; 0) {
      print(paste('chunk', n))
      print(paste("df:", df[1, 1], '-', df[nrow(df),1]))
      n = n + 1
      close_connection()
    }
    else {
      break
    }
  }

  # Restore default options
  options(default_ops)
</code></pre>

<hr>
<h2 id='import_actigraph_meta'>Import The meta information stored in Actigraph RAW or summary csv file.</h2><span id='topic+import_actigraph_meta'></span>

<h3>Description</h3>

<p><code>import_actigraph_meta</code> imports meta information stored in the Actigraph
summary csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_actigraph_meta(filepath, header = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_actigraph_meta_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
<tr><td><code id="import_actigraph_meta_+3A_header">header</code></td>
<td>
<p>logical. Whether the Actigraph RAW or summary csv file includes
column names. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned meta information includes following fields.
</p>
 <ul>
<li><p> sr: Sampling rate in Hz. </p>
</li>
<li><p> fw: Firmware version. For
example &quot;1.7.0&quot;. </p>
</li>
<li><p> sw: Software version of Actilife. For example &quot;6.13.0&quot;.
</p>
</li>
<li><p> sn: Serial number of the device. </p>
</li>
<li><p> st: Start time of the data, in
POSIXct format. </p>
</li>
<li><p> dt: Download time of the data, in POSIXct format. </p>
</li>
<li>
<p>at: Type of the device. Could be &quot;MAT&quot;,&quot;CLE&quot;, &quot;MOS&quot; or &quot;TAS&quot;, corresponding
to different Actigraph devices. </p>
</li>
<li><p> imu: Whether the file is about
Actigraph GT9X IMU data. </p>
</li>
<li><p> gr: The dynamic range in <code class="reqn">g</code> unit. </p>
</li>
<li>
<p>vs: The voltage level of the device, may be used in AD conversion. See
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a></code>. </p>
</li>
<li><p> res: The resolution or the number of
bits used to store quantized voltage values of the device, may be used in AD
conversion. See <code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a></code>. </p>
</li></ul>



<h3>Value</h3>

<p>list. A list of Actigraph device meta information.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to get related meta information such as sampling
rate, firmware version from Actigraph devices.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)

  # Use the sample actigraph csv file provided by the package
  filepath = system.file('extdata', 'actigraph_timestamped.csv', package='MIMSunit')

  # Check file format
  readLines(filepath)[1:15]

  # Load the meta headers of input file
  import_actigraph_meta(filepath, header=TRUE)

  # Restore default options
  options(default_ops)
</code></pre>

<hr>
<h2 id='import_activpal3_csv'>Import raw multi-channel accelerometer data stored in ActivPal3 csv format</h2><span id='topic+import_activpal3_csv'></span>

<h3>Description</h3>

<p><code>import_activpal3_csv</code> imports the raw multi-channel accelerometer data
stored in ActivPal3 csv format by converting the accelerometer values (in
digital voltage values) to <code class="reqn">g</code> unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_activpal3_csv(filepath, header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_activpal3_csv_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
<tr><td><code id="import_activpal3_csv_+3A_header">header</code></td>
<td>
<p>boolean. If TRUE, the input csv file will have column names in
the first row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ActivPal 3 sensors have known dynamic range to be <code class="reqn">(-2g, +2g)</code>. And the
sensor stores values using 8-bit memory storage. So, the digital voltage
values may be converted to <code class="reqn">g</code> unit using following equation.
</p>
<p style="text-align: center;"><code class="reqn">x_g = \frac{x_{voltage} - 127}{2^8} * 4</code>
</p>



<h3>Value</h3>

<p>dataframe. The imported multi-channel accelerometer signal, with the
first column being the timestamps in POSXlct format, and the rest columns
being accelerometer values in <code class="reqn">g</code> unit.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import data from ActivPal3 devices during
algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)
  # Use the sample activpal3 csv file provided by the package
  filepath = system.file('extdata', 'activpal3.csv', package='MIMSunit')

  # Check the csv format
  readLines(filepath)[1:5]

  # Load the file, in our case without header
  df = import_activpal3_csv(filepath, header=FALSE)

  # Check loaded file
  head(df)

  # Check more
  summary(df)

  # Restore default options
  options(default_ops)
</code></pre>

<hr>
<h2 id='import_enmo_csv'>Import ENMO data stored in csv csv</h2><span id='topic+import_enmo_csv'></span>

<h3>Description</h3>

<p><code>import_enmo_csv</code> imports ENMO data stored in a summary csv format,
which was exported by the
<a href="https://github.com/OxWearables/biobankAccelerometerAnalysis">biobank
data analysis tools</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_enmo_csv(filepath, enmo_col = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_enmo_csv_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
<tr><td><code id="import_enmo_csv_+3A_enmo_col">enmo_col</code></td>
<td>
<p>number. The index of column of ENMO values in the csv file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The imported ENMO data, with the first column being the
timestamps in POSIXct format, and the second column being the ENMO values.
Column names: <code>HEADER_TIME_STAMP</code>, <code>ENMO</code>.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import ENMO data from activity monitor devices
during algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the enmo csv file shipped with the package
  filepath = system.file('extdata', 'enmo.csv', package='MIMSunit')

  # Check original data format
  readLines(filepath)[1:5]

  # Load file, default column for enmo values are 2
  output = import_enmo_csv(filepath, enmo_col=2)

  # Check output
  head(output)
</code></pre>

<hr>
<h2 id='import_mhealth_csv'>Import raw multi-channel accelerometer data stored in mHealth Specification</h2><span id='topic+import_mhealth_csv'></span>

<h3>Description</h3>

<p><code>import_mhealth_csv</code> imports the raw multi-channel accelerometer data
stored in mHealth Specification. Note that this function will fail when
loading data that have size too big to fit in the memory. For large data
file, please use <code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a></code> to load.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_mhealth_csv(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_mhealth_csv_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The imported multi-channel accelerometer signal, with the
first column being the timestamps in POSXlct format, and the rest columns
being accelerometer values in <code class="reqn">g</code> unit.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import data stored in mHealth Specification during
algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv_chunked">import_mhealth_csv_chunked</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)
  # Use the sample mhealth csv file provided by the package
  filepath = system.file('extdata', 'mhealth.csv', package='MIMSunit')
  filepath

  # Load the file
  df = import_mhealth_csv(filepath)

  # Check loaded file
  head(df)

  # Check more
  summary(df)

  # Restore default options
  options(default_ops)
</code></pre>

<hr>
<h2 id='import_mhealth_csv_chunked'>Import large raw multi-channel accelerometer data stored in mHealth Specification
in chunks.</h2><span id='topic+import_mhealth_csv_chunked'></span>

<h3>Description</h3>

<p><code>import_mhealth_csv_chunked</code> imports the raw multi-channel accelerometer
data stored in mHealth Specification in chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_mhealth_csv_chunked(filepath, chunk_samples = 180000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_mhealth_csv_chunked_+3A_filepath">filepath</code></td>
<td>
<p>string. The filepath of the input data.</p>
</td></tr>
<tr><td><code id="import_mhealth_csv_chunked_+3A_chunk_samples">chunk_samples</code></td>
<td>
<p>number. The number of samples in each chunk. Default is
180000, which is half hour data for 100 Hz sampling rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list. The list contains two items. The first item is a generator
function that each time it is called, it will
return a dataframe with at most <code>chunk_samples</code> samples of imported data.
The third item is a <code>close_connection</code> function which you can call at
any moment to close the file loading.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a File IO
function that is used to import data stored in mHealth Specification during
algorithm validation.
</p>


<h3>See Also</h3>

<p>Other File I/O functions: 
<code><a href="#topic+export_to_actilife">export_to_actilife</a>()</code>,
<code><a href="#topic+import_actigraph_count_csv">import_actigraph_count_csv</a>()</code>,
<code><a href="#topic+import_actigraph_csv_chunked">import_actigraph_csv_chunked</a>()</code>,
<code><a href="#topic+import_actigraph_csv">import_actigraph_csv</a>()</code>,
<code><a href="#topic+import_actigraph_meta">import_actigraph_meta</a>()</code>,
<code><a href="#topic+import_activpal3_csv">import_activpal3_csv</a>()</code>,
<code><a href="#topic+import_enmo_csv">import_enmo_csv</a>()</code>,
<code><a href="#topic+import_mhealth_csv">import_mhealth_csv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  default_ops = options()
  options(digits.secs=3)

  # Use the mhealth csv file shipped with the package
  filepath = system.file('extdata', 'mhealth.csv', package='MIMSunit')

  # Example 1
  # Load chunks every 1000 samples
  results = import_mhealth_csv_chunked(filepath, chunk_samples=100)
  next_chunk = results[[1]]
  close_connection = results[[2]]
  # Check data as chunks, you can see chunk time is shifting forward at each iteration.
  n = 1
  repeat {
    df = next_chunk()
    if (nrow(df) &gt; 0) {
      print(paste('chunk', n))
      print(paste("df:", df[1, 1], '-', df[nrow(df),1]))
      n = n + 1
    } else {
      break
    }
  }

  # Close connection after reading all the data
  close_connection()

  # Example 2: close loading early
  results = import_mhealth_csv_chunked(filepath, chunk_samples=1000)
  next_chunk = results[[1]]
  close_connection = results[[2]]
  # Check data as chunks, you can see chunk time is shifting forward at each iteration.
  n = 1
  repeat {
    df = next_chunk()
    if (nrow(df) &gt; 0) {
      print(paste('chunk', n))
      print(paste("df:", df[1, 1], '-', df[nrow(df),1]))
      n = n + 1
      close_connection()
    }
    else {
      break
    }
  }

 # Restore default options
 options(default_ops)
</code></pre>

<hr>
<h2 id='interpolate_signal'>Interpolate missing points and unify sampling rate for multi-channel signal</h2><span id='topic+interpolate_signal'></span>

<h3>Description</h3>

<p><code>interpolate_signal</code> applies different interpolation algorithms to the
input multi-channel signal to fill in the missing samples and harmonizes the
sampling rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_signal(
  df,
  method = "spline_natural",
  sr = 100,
  st = NULL,
  et = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_signal_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal.</p>
</td></tr>
<tr><td><code id="interpolate_signal_+3A_method">method</code></td>
<td>
<p>string. Interpolation algorithms. Could be &quot;spline_natural&quot;,
&quot;spline_improved&quot; or &quot;spline_fmm&quot;: see <code><a href="stats.html#topic+splinefun">splinefun</a></code>;
and &quot;linear&quot;: see <code><a href="stats.html#topic+approxfun">approxfun</a></code>. Default is &quot;spline_natural&quot;.</p>
</td></tr>
<tr><td><code id="interpolate_signal_+3A_sr">sr</code></td>
<td>
<p>number. Sampling rate in Hz of the output signal. Default is 100.</p>
</td></tr>
<tr><td><code id="interpolate_signal_+3A_st">st</code></td>
<td>
<p>POSIXct date. The start time for interpolation. If it is
<code>NULL</code>, it will use the start time of the input signal. Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="interpolate_signal_+3A_et">et</code></td>
<td>
<p>POSIXct date. The end time for interpolation. If it is <code>NULL</code>,
it will use the end time of the input signal. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. Interpolated signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that has been used in functions: <code><a href="#topic+extrapolate">extrapolate</a></code>, and
<code><a href="#topic+simulate_new_data">simulate_new_data</a></code>.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data
  df = sample_raw_accel_data

  # Plot input
  illustrate_signal(df, plot_maxed_out_line=FALSE)

  # Interpolate to 100 Hz
  sr = 100

  # Interpolate the entire sequence of data
  output = interpolate_signal(df, sr=sr)

  # Plot output
  illustrate_signal(output, plot_maxed_out_line=FALSE)

  # Interpolate part of the sequence
  output = interpolate_signal(df, sr=sr, st=df[10,1], et=df[100,1])

  # Plot output
  illustrate_signal(output, plot_maxed_out_line=FALSE)
</code></pre>

<hr>
<h2 id='measurements_different_devices'>The mean and standard deviation of accelerometer summary measure for
different acceleration data summary algorithms and for different devices.</h2><span id='topic+measurements_different_devices'></span>

<h3>Description</h3>

<p>A dataframe contains the mean and standard deviation of accelerometer summary
measured at different frequencies for the raw accelerometer signals
from different devices collected from on a standard elliptical shaker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurements_different_devices
</code></pre>


<h3>Format</h3>

<p>A data frame with 235 rows and 8 variables:
</p>

<dl>
<dt>DEVICE</dt><dd><p>The name of different devices, in character</p>
</dd>
<dt>GRANGE</dt><dd><p>The dynamic range of the device in g, in number</p>
</dd>
<dt>SR</dt><dd><p>The sampling rate in Hz of the device, in number</p>
</dd>
<dt>TYPE</dt><dd><p>Accelerometer summary algorithm name, in character</p>
</dd>
<dt>HZ</dt><dd><p>The frequency of the elliptical shaker, in number</p>
</dd>
<dt>NAME</dt><dd><p>An alternative name that is friendly for plotting for devices, in character</p>
</dd>
<dt>mean</dt><dd><p>The mean values of accelerometer summary measure, in number</p>
</dd>
<dt>sd</dt><dd><p>The standard deviation values of accelerometer summary measure, in number</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit-dataset-shaker/">https://github.com/mHealthGroup/MIMSunit-dataset-shaker/</a>
</p>

<hr>
<h2 id='mims_unit'>Compute Monitor Independent Motion Summary unit (MIMS-unit)</h2><span id='topic+mims_unit'></span><span id='topic+mims_unit_from_files'></span>

<h3>Description</h3>

<p><code>mims_unit</code> computes the Monitor Independent Motion Summary unit for the
input multi-channel accelerometer signal. The input signal can be from
devices of any sampling rate and dynamic range. Please refer to the
manuscript for detailed description of the algorithm. Please refer to
functions for the intermediate steps: <code><a href="#topic+extrapolate">extrapolate</a></code> for
extrapolation, <code><a href="#topic+iir">iir</a></code> for filtering,
<code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a></code> for aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mims_unit(
  df,
  before_df = NULL,
  after_df = NULL,
  epoch = "5 sec",
  dynamic_range,
  output_mims_per_axis = FALSE,
  use_gui_progress = FALSE,
  st = NULL,
  use_snapshot_to_check = FALSE
)

mims_unit_from_files(
  files,
  epoch = "5 sec",
  dynamic_range,
  output_mims_per_axis = FALSE,
  use_gui_progress = FALSE,
  use_snapshot_to_check = FALSE,
  file_type = "mhealth",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mims_unit_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal. The
first column should be the time component. The accelerometer data values
(typically starting from the second column) should be in <code class="reqn">g</code> (per <code class="reqn">9.81m/s^2</code>) unit.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_before_df">before_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes
before the input signal to be prepended to the input signal during
computation. This is used to eliminate the edge effect during extrapolation
and filtering. If it is <code>NULL</code>, algorithm will run directly on the
input signal. Default is NULL.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_after_df">after_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes after
the input signal to be append to the input signal. This is used to
eliminate the edge effect during extrapolation and filtering. If it is
<code>NULL</code>, algorithm will run directly on the input signal. Default is
NULL.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_epoch">epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5
sec&quot;, &quot;10 min&quot;. Default is &quot;5 sec&quot;.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_dynamic_range">dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_output_mims_per_axis">output_mims_per_axis</code></td>
<td>
<p>logical. If it is TRUE, the output MIMS-unit
dataframe will have MIMS-unit values for each axis from the third column.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_use_gui_progress">use_gui_progress</code></td>
<td>
<p>logical. If it is TRUE, show GUI progress bar on
windows platform. Default is FALSE.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_use_snapshot_to_check">use_snapshot_to_check</code></td>
<td>
<p>logical. If TRUE, the function will use the first
100 rows or 10
the algorithm will use all data to check timestamp duplications. Default is FALSE.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_files">files</code></td>
<td>
<p>character vector. A list of csv filepaths for raw accelerometer
data organized in order to be processed. The data should be consecutive in
timestamps. A typical case is a set of hourly or daily files for
continuous accelerometer sampling. For a single file, please wrap the filepath
in a vector 'c(filepath)'.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_file_type">file_type</code></td>
<td>
<p>character. &quot;mhealth&quot; or &quot;actigraph&quot;. The type of the csv files
that store the raw accelerometer data.</p>
</td></tr>
<tr><td><code id="mims_unit_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the import function when reading
in the data from the files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The MIMS-unit dataframe. The first column is the start
time of each epoch in POSIXct format. The second column is the MIMS-unit
value for the input signal. If <code>output_mims_per_axis</code> is TRUE, the
third column and then are the MIMS-unit values for each axis of the input
signal.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This is the main entry of
MIMS-unit algorithm.
</p>


<h3>Note</h3>

<p>This function is a wrapper function for the low-level
<code><a href="#topic+custom_mims_unit">custom_mims_unit</a></code> function. It has set internal parameters as
described in the manuscript. If you want to run customized algorithm for
MIMSunit or if you want to develop better algorithms based on MIMS-unit
algorithm, please use function <code><a href="#topic+custom_mims_unit">custom_mims_unit</a></code> where all
parameters are tunable.
</p>
<p><code>before_df</code> and <code>after_df</code> are often set when the accelerometer
data are divided into files of smaller chunk.
</p>
<p>Please make sure the input data do not contain duplicated timestamps. See
more information about this <a href="https://github.com/mHealthGroup/MIMSunit/issues/32">issue</a>.
Otherwise the computation will stop.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code><a href="#topic+custom_mims_unit">custom_mims_unit</a>()</code>,
<code><a href="#topic+sensor_orientations">sensor_orientations</a>()</code>,
<code><a href="#topic+shiny_app">shiny_app</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # compute mims unit values and output axial values
  output = mims_unit(df, epoch = '1 sec', dynamic_range=c(-8, 8), output_mims_per_axis=TRUE)
  head(output)
  # Use sample mhealth file for testing
  filepaths = c(
    system.file('extdata', 'mhealth.csv', package='MIMSunit')
  )

  # Test with multiple files
  output = mims_unit_from_files(filepaths, epoch = "1 sec", dynamic_range = c(-8, 8))
  head(output)
</code></pre>

<hr>
<h2 id='parse_epoch_string'>Parse epoch string to the corresponding number of samples it represents.</h2><span id='topic+parse_epoch_string'></span>

<h3>Description</h3>

<p><code>parse_epoch_string</code> parses the epoch string (e.g. &quot;1 min&quot;), and outputs
the corresponding number of samples it represents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_epoch_string(epoch_str, sr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_epoch_string_+3A_epoch_str">epoch_str</code></td>
<td>
<p>string. The input epoch str as accepted by <code>breaks</code>
argument of <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.</p>
</td></tr>
<tr><td><code id="parse_epoch_string_+3A_sr">sr</code></td>
<td>
<p>number. The sampling rate in Hz used to parse the epoch string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function parses the given epoch string (e.g. &quot;5 secs&quot;) and outputs the
corresponding number of samples represented by the epoch string.
</p>


<h3>Value</h3>

<p>number. The number of samples represented by the epoch string.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is used in
<code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a></code> function and <code><a href="#topic+mims_unit">mims_unit</a></code> function.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1 min with 80 Hz = 4800 samples
parse_epoch_string('1 min', sr=80)

# 30 sec with 30 Hz = 900 samples
parse_epoch_string('30 sec', sr=30)

# 1 hour with 1 Hz = 3600 samples
parse_epoch_string('1 hour', sr=1)

# 1 day with 10 Hz = 864000 samples
parse_epoch_string('1 day', sr=10)
</code></pre>

<hr>
<h2 id='rest_on_table'>A short snippet of raw accelerometer signal from a device resting on a table.</h2><span id='topic+rest_on_table'></span>

<h3>Description</h3>

<p>The dataset includes accelerometer data sampled at 80Hz and 6g. This data is used to derive the thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rest_on_table
</code></pre>


<h3>Format</h3>

<p>A data frame with 5000 rows and 4 variables:
</p>

<dl>
<dt>HEADER_TIME_STAMP</dt><dd><p>The timestamp of raw accelerometer data, in POSIXct</p>
</dd>
<dt>X</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
<dt>Y</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
<dt>Z</dt><dd><p>The x axis value of raw accelerometer data, in number</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit/">https://github.com/mHealthGroup/MIMSunit/</a>
</p>

<hr>
<h2 id='sample_raw_accel_data'>Sample raw accelerometer data</h2><span id='topic+sample_raw_accel_data'></span>

<h3>Description</h3>

<p>A raw accelerometer data file contains treadmill data collected from a human
subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_raw_accel_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 480 rows and 4 variables:
</p>

<dl>
<dt>HEADER_TIME_STAMP</dt><dd><p>Timestamp, in POSIXct</p>
</dd>
<dt>X</dt><dd><p>X axis values, in number</p>
</dd>
<dt>Y</dt><dd><p>Y axis values, in number</p>
</dd>
<dt>Z</dt><dd><p>Z axis values, in number</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/mHealthGroup/MIMSunit/">https://github.com/mHealthGroup/MIMSunit/</a>
</p>

<hr>
<h2 id='sampling_rate'>Estimate sampling rate for multi-channel signal</h2><span id='topic+sampling_rate'></span>

<h3>Description</h3>

<p><code>sampling_rate</code> estimates the sampling rate based on the average time
intervals between adjacent samples for the input multi-channel signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_rate(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampling_rate_+3A_df">df</code></td>
<td>
<p>dataframe. Input dataframe of the multi-channel signal. The first
column is the timestamps in POSXlct format and the following columns are
accelerometer values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a dataframe of multi-channel signal, computes the
duration of the sequence, and gets the sampling rate by dividing the number
of samples by it.
</p>


<h3>Value</h3>

<p>number. The estimated sampling rate in Hz.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that was used in various part in the algorithm whenever we need to
know the sampling rate.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the test data
df = sample_raw_accel_data

# Default sampling rate is 80Hz
sampling_rate(df)

# Downsample to 30Hz
output = bandlimited_interp(df, 80, 30)
sampling_rate(output)

# Upsampling to 100Hz
output = bandlimited_interp(df, 80, 100)
sampling_rate(output)
</code></pre>

<hr>
<h2 id='segment_data'>Segment input dataframe into windows as specified by breaks.
<code>segment_data</code> segments the input sensor dataframe into
epoch windows with length specified in breaks.</h2><span id='topic+segment_data'></span>

<h3>Description</h3>

<p>This function accepts a dataframe of multi-channel signal, segments it
into epoch windows with length specified in breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_data(df, breaks, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment_data_+3A_df">df</code></td>
<td>
<p>dataframe. Input dataframe of the multi-channel signal. The first
column is the timestamps in POSXlct format and the following columns are
accelerometer values.</p>
</td></tr>
<tr><td><code id="segment_data_+3A_breaks">breaks</code></td>
<td>
<p>character. An epoch length character that can be accepted by
cut.breaks function.</p>
</td></tr>
<tr><td><code id="segment_data_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the breaks generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate breaks. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The same format as the input dataframe, but with an extra
column &quot;SEGMENT&quot; in the end specifies the epoch window a sample belongs to.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that was used in various part in the algorithm whenever we need to
segment a dataframe, e.g., before aggregating values over epoch windows.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+simulate_new_data">simulate_new_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data
  df = sample_raw_accel_data

  # segment data into 1 minute segments
  output = segment_data(df, "1 min")

  # check the 3rd segment, each segment would have 1 minute data
  summary(output[output['SEGMENT'] == 3,])

  # segment data into 15 second segments
  output = segment_data(df, "15 sec")

  # check the 1st segment, each segment would have 15 second data
  summary(output[output['SEGMENT'] == 1,])

  # segment data into 1 hour segments
  output = segment_data(df, "1 hour")

  # because the input data has only 15 minute data
  # there will be only 1 segment in the output
  unique(output['SEGMENT'])
  summary(output)

  # use manually set start time
  output = segment_data(df, "15 sec", st='2016-01-15 10:59:50.000')

  # check the 1st segment, because the start time is 10 seconds before the
  # start time of the actual data, the first segment will only include 5 second
  # data.
  summary(output[output['SEGMENT'] == 1,])
</code></pre>

<hr>
<h2 id='sensor_orientations'>Estimates sensor orientation</h2><span id='topic+sensor_orientations'></span>

<h3>Description</h3>

<p><code>sensor_orientations</code> estimates the orientation angles for the input
multi-channel accelerometer signal. The input signal can be from devices of
any sampling rate and dynamic range. Please refer to function
<code><a href="#topic+compute_orientation">compute_orientation</a></code> for the implementation of the estimation
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensor_orientations(
  df,
  before_df = NULL,
  after_df = NULL,
  epoch = "5 sec",
  dynamic_range,
  st = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensor_orientations_+3A_df">df</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer signal.</p>
</td></tr>
<tr><td><code id="sensor_orientations_+3A_before_df">before_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes
before the input signal to be prepended to the input signal during
computation. This is used to eliminate the edge effect during extrapolation
and filtering. If it is <code>NULL</code>, algorithm will run directly on the
input signal. Default is NULL.</p>
</td></tr>
<tr><td><code id="sensor_orientations_+3A_after_df">after_df</code></td>
<td>
<p>dataframe. The multi-channel accelerometer signal comes after
the input signal to be append to the input signal. This is used to
eliminate the edge effect during extrapolation and filtering. If it is
<code>NULL</code>, algorithm will run directly on the input signal. Default is
NULL.</p>
</td></tr>
<tr><td><code id="sensor_orientations_+3A_epoch">epoch</code></td>
<td>
<p>string. Any format that is acceptable by argument <code>breaks</code>
in method <code><a href="base.html#topic+cut.POSIXt">cut.POSIXt</a></code>.For example, &quot;1 sec&quot;, &quot;1 min&quot;, &quot;5
sec&quot;, &quot;10 min&quot;. Default is &quot;5 sec&quot;.</p>
</td></tr>
<tr><td><code id="sensor_orientations_+3A_dynamic_range">dynamic_range</code></td>
<td>
<p>numerical vector. The dynamic ranges of the input
signal. Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach.</p>
</td></tr>
<tr><td><code id="sensor_orientations_+3A_st">st</code></td>
<td>
<p>character or POSIXct timestamp. An optional start time you can set to
force the epochs generated by referencing this start time. If it is NULL, the
function will use the first timestamp in the timestamp column as start time to
generate epochs. This is useful when you are processing a stream of data and
want to use a common start time for segmenting data. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe. The orientation dataframe. The first column is the start
time of each epoch in POSIXct format. The second to fourth columns are the
orientation angles.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This is not included in the
official MIMS-unit algorithm nor the manuscript, but we found it is useful
to know the sensor orientations in addition to the summary of movement.
</p>


<h3>Note</h3>

<p>This function interpolates and extrapolates the signal before
estimating the orientation angles.
</p>
<p><code>before_df</code> and <code>after_df</code> are often set when the accelerometer
data are divided into files of smaller chunk.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code><a href="#topic+custom_mims_unit">custom_mims_unit</a>()</code>,
<code><a href="#topic+mims_unit">mims_unit</a>()</code>,
<code><a href="#topic+shiny_app">shiny_app</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # compute sensor orientation angles
  sensor_orientations(df, epoch = '2 sec', dynamic_range=c(-8, 8))

  # compute sensor orientation angles with different epoch length
  output = sensor_orientations(df, epoch = '1 sec', dynamic_range=c(-8, 8))
  head(output)
</code></pre>

<hr>
<h2 id='shiny_app'>Run shiny app to compute MIMSunit values from files</h2><span id='topic+shiny_app'></span>

<h3>Description</h3>

<p><code>shiny_app</code> runs a local shiny app that provides a user friendly interface
to compute mims unit values from files stored in mhealth or actigraph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_app(options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiny_app_+3A_options">options</code></td>
<td>
<p>The options passed to <code><a href="shiny.html#topic+shinyApp">shinyApp</a></code>.</p>
</td></tr>
</table>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This provides a user friendly
graphical interface to load local files, call <code><a href="#topic+mims_unit_from_files">mims_unit_from_files</a></code>
and display the results as an interactive graph.
</p>


<h3>See Also</h3>

<p>Other Top level API functions: 
<code><a href="#topic+custom_mims_unit">custom_mims_unit</a>()</code>,
<code><a href="#topic+mims_unit">mims_unit</a>()</code>,
<code><a href="#topic+sensor_orientations">sensor_orientations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  shiny_app()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='simulate_new_data'>Simulate new data based on the given multi-channel accelerometer data</h2><span id='topic+simulate_new_data'></span>

<h3>Description</h3>

<p><code>simulate_new_data</code> simulate new data based on the given multi-channel
accelerometer data, a new dynamic range and a new sampling rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_new_data(old_data, new_range, new_sr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_new_data_+3A_old_data">old_data</code></td>
<td>
<p>dataframe. Input multi-channel accelerometer data.</p>
</td></tr>
<tr><td><code id="simulate_new_data_+3A_new_range">new_range</code></td>
<td>
<p>numerical vector. The new dynamic ranges to cut off the signal.
Should be a 2-element numerical vector. <code>c(low, high)</code>, where
<code>low</code> is the negative max value the device can reach and <code>high</code>
is the positive max value the device can reach. Default is <code>NULL</code>,
meaning the function will do nothing but return the input data.</p>
</td></tr>
<tr><td><code id="simulate_new_data_+3A_new_sr">new_sr</code></td>
<td>
<p>number. New sampling rate in Hz.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the data from a new device based on the signal from a
baseline device. It first changes the sampling rate using function
<code><a href="#topic+interpolate_signal">interpolate_signal</a></code>, and then changes the dynamic range using
function <code><a href="#topic+cut_off_signal">cut_off_signal</a></code>.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is a utility
function that is used to simulate new devices with different sampling rates
and dynamic ranges during algorithm validation.
</p>


<h3>See Also</h3>

<p>Other utility functions: 
<code><a href="#topic+clip_data">clip_data</a>()</code>,
<code><a href="#topic+cut_off_signal">cut_off_signal</a>()</code>,
<code><a href="#topic+interpolate_signal">interpolate_signal</a>()</code>,
<code><a href="#topic+parse_epoch_string">parse_epoch_string</a>()</code>,
<code><a href="#topic+sampling_rate">sampling_rate</a>()</code>,
<code><a href="#topic+segment_data">segment_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use sample data for testing
  df = sample_raw_accel_data

  # Show df
  illustrate_signal(df, range=c(-8, 8))

  # simulate new data by changing range and sampling rate
  new_df = simulate_new_data(df, new_range=c(-2, 2), new_sr = 30)

  # Show new df
  illustrate_signal(new_df, range=c(-2, 2))
</code></pre>

<hr>
<h2 id='sum_up'>Sum of multi-channel signal.</h2><span id='topic+sum_up'></span>

<h3>Description</h3>

<p><code>sum_up</code> computes the sum up value for each sample (row) of a
multi-channel signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_up(df, axes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_up_+3A_df">df</code></td>
<td>
<p>dataframe. multi-channel signal, with the first column being the
timestamp in POSXct format.</p>
</td></tr>
<tr><td><code id="sum_up_+3A_axes">axes</code></td>
<td>
<p>numerical vector. Specify the column indices for each axis. When
this value is NULL, the function assumes the axes are starting from column
2 to the end. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a dataframe of a multi-channel signal as input, and then
computes the sum of each row and returns a transformed dataframe with two
columns.
</p>


<h3>Value</h3>

<p>dataframe. The transformed dataframe will have the same number of
rows as input dataframe but only two columns, with the first being
timestamps and second being the sum up values.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is used to
combine MIMS-unit values on each axis into a single value after aggregating
over each epoch using <code><a href="#topic+aggregate_for_mims">aggregate_for_mims</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vector_magnitude">vector_magnitude</a></code>
</p>
<p>Other transformation functions: 
<code><a href="#topic+compute_orientation">compute_orientation</a>()</code>,
<code><a href="#topic+vector_magnitude">vector_magnitude</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the first 10 rows of the sample data as an example
  df = sample_raw_accel_data[1:10,]
  df

  # By default, the function will assume columns starting from 2 to be axial
  # values.
  sum_up(df)

  # Or, you may specify the column indices yourself
  sum_up(df, axes=c(2,3,4))

  # Or, if you only want to consider x and y axes
  sum_up(df, axes=c(2,3))

  # Or, just return the chosen column
  sum_up(df, axes=c(2))

</code></pre>

<hr>
<h2 id='vector_magnitude'>Vector magnitude of multi-channel signal.</h2><span id='topic+vector_magnitude'></span>

<h3>Description</h3>

<p><code>vector_magnitude</code> computes the vector magnitude value for each sample
(row) of a multi-channel signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_magnitude(df, axes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_magnitude_+3A_df">df</code></td>
<td>
<p>dataframe. multi-channel signal, with the first column being the
timestamp in POSXct format.</p>
</td></tr>
<tr><td><code id="vector_magnitude_+3A_axes">axes</code></td>
<td>
<p>numerical vector. Specify the column indices for each axis. When
this value is NULL, the function assumes the axes are starting from column
2 to the end. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a dataframe of a multi-channel signal as input, and then
computes the 2-norm (vector magnitude) for each row and returns a transformed
dataframe with two columns.
</p>


<h3>Value</h3>

<p>dataframe. The transformed dataframe will have the same number of
rows as input dataframe but only two columns, with the first being
timestamps and second being the vector magnitude values.
</p>


<h3>How is it used in MIMS-unit algorithm?</h3>

<p>This function is not used in
the released version of MIMS-unit algorithm, but was used to compare the
alternative <code><a href="#topic+sum_up">sum_up</a></code> method when combining MIMS-unit values on
each axis into a single value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sum_up">sum_up</a></code>
</p>
<p>Other transformation functions: 
<code><a href="#topic+compute_orientation">compute_orientation</a>()</code>,
<code><a href="#topic+sum_up">sum_up</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Use the first 10 rows of the sample data as an example
  df = sample_raw_accel_data[1:10,]
  df

  # By default, the function will assume columns starting from 2 to be axial
  # values.
  vector_magnitude(df)

  # Or, you may specify the column indices yourself
  vector_magnitude(df, axes=c(2,3,4))

  # Or, if you only want to consider x and y axes
  vector_magnitude(df, axes=c(2,3))

  # Or, just return the chosen column
  vector_magnitude(df, axes=c(2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
