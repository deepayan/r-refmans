<!DOCTYPE html><html lang="en"><head><title>Help for package tidyclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyclust-package'><p>tidyclust: A Common API to Clustering</p></a></li>
<li><a href='#.convert_form_to_x_fit'><p>Helper functions to convert between formula and matrix interface</p></a></li>
<li><a href='#.hier_clust_fit_stats'><p>Simple Wrapper around hclust function</p></a></li>
<li><a href='#.k_means_fit_ClusterR'><p>Simple Wrapper around ClusterR kmeans</p></a></li>
<li><a href='#.k_means_fit_clustMixType'><p>Simple Wrapper around clustMixType kmeans</p></a></li>
<li><a href='#.k_means_fit_klaR'><p>Simple Wrapper around klaR kmeans</p></a></li>
<li><a href='#.k_means_fit_stats'><p>Simple Wrapper around stats kmeans</p></a></li>
<li><a href='#augment.cluster_fit'><p>Augment data with predictions</p></a></li>
<li><a href='#cluster_fit'><p>Model Fit Object Information</p></a></li>
<li><a href='#cluster_metric_set'><p>Combine metric functions</p></a></li>
<li><a href='#cluster_spec'><p>Model Specification Information</p></a></li>
<li><a href='#control_cluster'><p>Control the fit function</p></a></li>
<li><a href='#cut_height'><p>Cut Height</p></a></li>
<li><a href='#details_hier_clust_stats'><p>Hierarchical (Agglomerative) Clustering via stats</p></a></li>
<li><a href='#details_k_means_ClusterR'><p>K-means via ClusterR</p></a></li>
<li><a href='#details_k_means_clustMixType'><p>K-means via clustMixType</p></a></li>
<li><a href='#details_k_means_klaR'><p>K-means via klaR</p></a></li>
<li><a href='#details_k_means_stats'><p>K-means via stats</p></a></li>
<li><a href='#extract_centroids'><p>Extract clusters from model</p></a></li>
<li><a href='#extract_cluster_assignment'><p>Extract cluster assignments from model</p></a></li>
<li><a href='#extract_fit_summary'><p>S3 method to get fitted model summary info depending on engine</p></a></li>
<li><a href='#extract-tidyclust'><p>Extract elements of a tidyclust model object</p></a></li>
<li><a href='#finalize_model_tidyclust'><p>Splice final parameters into objects</p></a></li>
<li><a href='#fit.cluster_spec'><p>Fit a Model Specification to a Data Set</p></a></li>
<li><a href='#get_centroid_dists'><p>Computes distance from observations to centroids</p></a></li>
<li><a href='#get_tidyclust_colors'><p>Get colors for tidyclust text.</p></a></li>
<li><a href='#glance.cluster_fit'><p>Construct a single row summary &quot;glance&quot; of a model, fit, or other object</p></a></li>
<li><a href='#hier_clust'><p>Hierarchical (Agglomerative) Clustering</p></a></li>
<li><a href='#k_means'><p>K-Means</p></a></li>
<li><a href='#knit_engine_docs'><p>Knit engine-specific documentation</p></a></li>
<li><a href='#linkage_method'><p>The agglomeration Linkage method</p></a></li>
<li><a href='#list_md_problems'><p>Locate and show errors/warnings in engine-specific documentation</p></a></li>
<li><a href='#load_pkgs.cluster_spec'><p>Quietly load package namespace</p></a></li>
<li><a href='#make_classes_tidyclust'><p>Prepend a new class</p></a></li>
<li><a href='#min_grid.cluster_spec'><p>Determine the minimum set of model fits</p></a></li>
<li><a href='#new_cluster_metric'><p>Construct a new clustering metric function</p></a></li>
<li><a href='#new_cluster_spec'><p>Functions required for tidyclust-adjacent packages</p></a></li>
<li><a href='#predict_cluster'><p>Other predict methods.</p></a></li>
<li><a href='#predict.cluster_fit'><p>Model predictions</p></a></li>
<li><a href='#prep_data_dist'><p>Prepares data and distance matrices for metric calculation</p></a></li>
<li><a href='#reconcile_clusterings_mapping'><p>Relabels clusters to match another cluster assignment</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#set_args.cluster_spec'><p>Change arguments of a cluster specification</p></a></li>
<li><a href='#set_engine.cluster_spec'><p>Change engine of a cluster specification</p></a></li>
<li><a href='#set_mode.cluster_spec'><p>Change mode of a cluster specification</p></a></li>
<li><a href='#silhouette'><p>Measures silhouette between clusters</p></a></li>
<li><a href='#silhouette_avg'><p>Measures average silhouette across all observations</p></a></li>
<li><a href='#sse_ratio'><p>Compute the ratio of the WSS to the total SSE</p></a></li>
<li><a href='#sse_total'><p>Compute the total sum of squares</p></a></li>
<li><a href='#sse_within'><p>Calculates Sum of Squared Error in each cluster</p></a></li>
<li><a href='#sse_within_total'><p>Compute the sum of within-cluster SSE</p></a></li>
<li><a href='#tidy.cluster_fit'><p>Turn a tidyclust model object into a tidy tibble</p></a></li>
<li><a href='#translate_tidyclust'><p>Resolve a Model Specification for a Computational Engine</p></a></li>
<li><a href='#tune_cluster'><p>Model tuning via grid search</p></a></li>
<li><a href='#update.hier_clust'><p>Update a cluster specification</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Common API to Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A common interface to specifying clustering models, in the
    same style as 'parsnip'. Creates unified interface across different
    functions and computational engines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/tidyclust">https://github.com/tidymodels/tidyclust</a>,
<a href="https://tidyclust.tidymodels.org/">https://tidyclust.tidymodels.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/tidyclust/issues">https://github.com/tidymodels/tidyclust/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.0.0), dials (&ge; 1.3.0), dplyr (&ge; 1.0.9), flexclust
(&ge; 1.3-6), foreach, generics (&ge; 0.1.2), glue (&ge; 1.6.2),
hardhat (&ge; 1.0.0), modelenv (&ge; 0.2.0), parsnip (&ge; 1.0.2),
philentropy (&ge; 0.9.0), prettyunits (&ge; 1.1.0), rlang (&ge;
1.0.6), rsample (&ge; 1.0.0), stats, tibble (&ge; 3.1.0), tidyr (&ge;
1.2.0), tune (&ge; 1.0.0), utils, vctrs (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster, ClusterR, clustMixType (&ge; 0.3-5), covr, klaR,
knitr, modeldata (&ge; 1.0.0), RcppHungarian, recipes (&ge; 1.0.0),
rmarkdown, testthat (&ge; 3.0.0), workflows (&ge; 1.1.2)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>pkgdown, tidymodels, tidyverse, palmerpenguins,
patchwork, ggforce, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-27 23:10:56 UTC; emilhvitfeldt</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kelly Bodwin [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Hvitfeldt &lt;emil.hvitfeldt@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-27 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyclust-package'>tidyclust: A Common API to Clustering</h2><span id='topic+tidyclust'></span><span id='topic+tidyclust-package'></span>

<h3>Description</h3>

<p>A common interface to specifying clustering models, in the same style as 'parsnip'. Creates unified interface across different functions and computational engines.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Kelly Bodwin <a href="mailto:kelly@bodwin.us">kelly@bodwin.us</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/tidyclust">https://github.com/tidymodels/tidyclust</a>
</p>
</li>
<li> <p><a href="https://tidyclust.tidymodels.org/">https://tidyclust.tidymodels.org/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/tidyclust/issues">https://github.com/tidymodels/tidyclust/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.convert_form_to_x_fit'>Helper functions to convert between formula and matrix interface</h2><span id='topic+.convert_form_to_x_fit'></span><span id='topic+.convert_x_to_form_fit'></span><span id='topic+.convert_form_to_x_new'></span><span id='topic+.convert_x_to_form_new'></span>

<h3>Description</h3>

<p>Functions to take a formula interface and get the resulting
objects (y, x, weights, etc) back or the other way around. The functions
are intended for developer use. For the most part, this emulates the
internals of <code>lm()</code> (and also see the notes at
https://developer.r-project.org/model-fitting-functions.html).
</p>
<p><code>.convert_form_to_x_fit()</code> and <code>.convert_x_to_form_fit()</code> are for when the
data are created for modeling. <code>.convert_form_to_x_fit()</code> saves both the
data objects as well as the objects needed when new data are predicted
(e.g. <code>terms</code>, etc.).
</p>
<p><code>.convert_form_to_x_new()</code> and <code>.convert_x_to_form_new()</code> are used when new
samples are being predicted and only require the predictors to be
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convert_form_to_x_fit(
  formula,
  data,
  ...,
  na.action = na.omit,
  indicators = "traditional",
  composition = "data.frame",
  remove_intercept = TRUE
)

.convert_x_to_form_fit(x, weights = NULL, remove_intercept = TRUE)

.convert_form_to_x_new(
  object,
  new_data,
  na.action = stats::na.pass,
  composition = "data.frame"
)

.convert_x_to_form_new(object, new_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".convert_form_to_x_fit_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_data">data</code></td>
<td>
<p>A data frame containing all relevant variables (e.g. predictors,
case weights, etc).</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+model.frame">stats::model.frame()</a></code>.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain NAs.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_indicators">indicators</code></td>
<td>
<p>A string describing whether and how to create
indicator/dummy variables from factor predictors. Possible options are
<code>"none"</code>, <code>"traditional"</code>, and <code>"one_hot"</code>.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_composition">composition</code></td>
<td>
<p>A string describing whether the resulting <code>x</code> and <code>y</code>
should be returned as a <code>"matrix"</code> or a <code>"data.frame"</code>.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_remove_intercept">remove_intercept</code></td>
<td>
<p>A logical indicating whether to remove the intercept
column after <code>model.matrix()</code> is finished.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_x">x</code></td>
<td>
<p>A matrix, sparse matrix, or data frame of predictors. Only some
models have support for sparse matrix input. See <code>modelenv::get_encoding()</code>
for details. <code>x</code> should have column names.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_weights">weights</code></td>
<td>
<p>A numeric vector containing the weights.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+cluster_fit">cluster_fit</a></code>.</p>
</td></tr>
<tr><td><code id=".convert_form_to_x_fit_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='.hier_clust_fit_stats'>Simple Wrapper around hclust function</h2><span id='topic+.hier_clust_fit_stats'></span>

<h3>Description</h3>

<p>This wrapper prepares the data into a distance matrix to send to
<code>stats::hclust</code> and retains the parameters <code>num_clusters</code> or <code>h</code> as an
attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hier_clust_fit_stats(
  x,
  num_clusters = NULL,
  cut_height = NULL,
  linkage_method = NULL,
  dist_fun = philentropy::distance
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".hier_clust_fit_stats_+3A_x">x</code></td>
<td>
<p>matrix or data frame</p>
</td></tr>
<tr><td><code id=".hier_clust_fit_stats_+3A_num_clusters">num_clusters</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
<tr><td><code id=".hier_clust_fit_stats_+3A_cut_height">cut_height</code></td>
<td>
<p>the height to cut the dendrogram</p>
</td></tr>
<tr><td><code id=".hier_clust_fit_stats_+3A_linkage_method">linkage_method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>,
<code>"complete"</code>, <code>"average"</code> (= UPGMA), <code>"mcquitty"</code> (= WPGMA), <code>"median"</code> (=
WPGMC) or <code>"centroid"</code> (= UPGMC).</p>
</td></tr>
<tr><td><code id=".hier_clust_fit_stats_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A distance function to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dendrogram
</p>

<hr>
<h2 id='.k_means_fit_ClusterR'>Simple Wrapper around ClusterR kmeans</h2><span id='topic+.k_means_fit_ClusterR'></span>

<h3>Description</h3>

<p>This wrapper runs <code>ClusterR::KMeans_rcpp()</code> and adds column names to the
<code>centroids</code> field. And reorders the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.k_means_fit_ClusterR(
  data,
  clusters,
  num_init = 1,
  max_iters = 100,
  initializer = "kmeans++",
  fuzzy = FALSE,
  verbose = FALSE,
  CENTROIDS = NULL,
  tol = 1e-04,
  tol_optimal_init = 0.3,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".k_means_fit_ClusterR_+3A_data">data</code></td>
<td>
<p>matrix or data frame</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_clusters">clusters</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_num_init">num_init</code></td>
<td>
<p>number of times the algorithm will be run with different
centroid seeds</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_max_iters">max_iters</code></td>
<td>
<p>the maximum number of clustering iterations</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_initializer">initializer</code></td>
<td>
<p>the method of initialization. One of, optimal_init,
quantile_init, kmeans++ and random. See details for more information</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_fuzzy">fuzzy</code></td>
<td>
<p>either TRUE or FALSE. If TRUE, then prediction probabilities
will be calculated using the distance between observations and centroids</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_verbose">verbose</code></td>
<td>
<p>either TRUE or FALSE, indicating whether progress is printed
during clustering.</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_centroids">CENTROIDS</code></td>
<td>
<p>a matrix of initial cluster centroids. The rows of the
CENTROIDS matrix should be equal to the number of clusters and the columns
should be equal to the columns of the data.</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_tol">tol</code></td>
<td>
<p>a float number. If, in case of an iteration (iteration &gt; 1 and
iteration &lt; max_iters) 'tol' is greater than the squared norm of the
centroids, then kmeans has converged</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_tol_optimal_init">tol_optimal_init</code></td>
<td>
<p>tolerance value for the 'optimal_init' initializer.
The higher this value is, the far appart from each other the centroids are.</p>
</td></tr>
<tr><td><code id=".k_means_fit_ClusterR_+3A_seed">seed</code></td>
<td>
<p>integer value for random number generator (RNG)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following attributes: clusters, fuzzy_clusters (if
fuzzy = TRUE), centroids, total_SSE, best_initialization, WCSS_per_cluster,
obs_per_cluster, between.SS_DIV_total.SS
</p>

<hr>
<h2 id='.k_means_fit_clustMixType'>Simple Wrapper around clustMixType kmeans</h2><span id='topic+.k_means_fit_clustMixType'></span>

<h3>Description</h3>

<p>This wrapper runs <code>clustMixType::kproto()</code> and reorders the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.k_means_fit_clustMixType(x, k, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".k_means_fit_clustMixType_+3A_x">x</code></td>
<td>
<p>Data frame with both numerics and factors (also ordered factors are possible).</p>
</td></tr>
<tr><td><code id=".k_means_fit_clustMixType_+3A_k">k</code></td>
<td>
<p>Either the number of clusters, a vector specifying indices of initial prototypes, or a data frame of 
prototypes of the same columns as <code>x</code>.</p>
</td></tr>
<tr><td><code id=".k_means_fit_clustMixType_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>clustMixType::kproto()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result from <code>clustMixType::kproto()</code>
</p>

<hr>
<h2 id='.k_means_fit_klaR'>Simple Wrapper around klaR kmeans</h2><span id='topic+.k_means_fit_klaR'></span>

<h3>Description</h3>

<p>This wrapper runs <code>klaR::kmodes()</code> and reorders the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.k_means_fit_klaR(data, modes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".k_means_fit_klaR_+3A_data">data</code></td>
<td>
<p>A matrix or data frame of categorical data. Objects have to be in rows, variables in columns.</p>
</td></tr>
<tr><td><code id=".k_means_fit_klaR_+3A_modes">modes</code></td>
<td>
<p>Either the number of modes or a set of initial
(distinct) cluster modes.  If a number, a random set of (distinct)
rows in <code>data</code> is chosen as the initial modes.</p>
</td></tr>
<tr><td><code id=".k_means_fit_klaR_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>klaR::kmodes()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result from <code>klaR::kmodes()</code>
</p>

<hr>
<h2 id='.k_means_fit_stats'>Simple Wrapper around stats kmeans</h2><span id='topic+.k_means_fit_stats'></span>

<h3>Description</h3>

<p>This wrapper runs <code>stats::kmeans()</code> and adds a check that <code>centers</code> is
specified. And reorders the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.k_means_fit_stats(data, centers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".k_means_fit_stats_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters, say <code class="reqn">k</code>, or a set of
initial (distinct) cluster centres.  If a number, a random set of
(distinct) rows in <code>x</code> is chosen as the initial centres.</p>
</td></tr>
<tr><td><code id=".k_means_fit_stats_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>stats::kmeans()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result from <code>stats::kmeans()</code>
</p>

<hr>
<h2 id='augment.cluster_fit'>Augment data with predictions</h2><span id='topic+augment.cluster_fit'></span>

<h3>Description</h3>

<p><code>augment()</code> will add column(s) for predictions to the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_fit'
augment(x, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.cluster_fit_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+cluster_fit">cluster_fit</a></code> object produced by <code><a href="#topic+fit.cluster_spec">fit.cluster_spec()</a></code> or
<code><a href="#topic+fit_xy.cluster_spec">fit_xy.cluster_spec()</a></code> .</p>
</td></tr>
<tr><td><code id="augment.cluster_fit_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="augment.cluster_fit_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For partition models, a <code>.pred_cluster</code> column is added.
</p>


<h3>Value</h3>

<p>A <code>tibble::tibble()</code> with containing <code>new_data</code> with columns added
depending on the mode of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

kmeans_fit %&gt;%
  augment(new_data = mtcars)
</code></pre>

<hr>
<h2 id='cluster_fit'>Model Fit Object Information</h2><span id='topic+cluster_fit'></span>

<h3>Description</h3>

<p>An object with class &quot;cluster_fit&quot; is a container for information about a
model that has been fit to the data.
</p>


<h3>Details</h3>

<p>The following model types are implemented in tidyclust:
</p>

<ul>
<li><p> K-Means in <code><a href="#topic+k_means">k_means()</a></code>
</p>
</li>
<li><p> Hierarchical (Agglomerative) Clustering in <code><a href="#topic+hier_clust">hier_clust()</a></code>
</p>
</li></ul>

<p>The main elements of the object are:
</p>

<ul>
<li> <p><code>spec</code>: A <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.
</p>
</li>
<li> <p><code>fit</code>: The object produced by the fitting function.
</p>
</li>
<li> <p><code>preproc</code>: This contains any data-specific information required to
process new a sample point for prediction. For example, if the underlying
model function requires arguments <code>x</code> and the user passed a formula to
<code>fit</code>, the <code>preproc</code> object would contain items such as the terms object
and so on. When no information is required, this is <code>NA</code>.
</p>
</li></ul>

<p>As discussed in the documentation for <code><a href="#topic+cluster_spec">cluster_spec</a></code>, the original
arguments to the specification are saved as quosures. These are evaluated for
the <code>cluster_fit</code> object prior to fitting. If the resulting model object
prints its call, any user-defined options are shown in the call preceded by a
tilde (see the example below). This is a result of the use of quosures in the
specification.
</p>
<p>This class and structure is the basis for how <span class="pkg">tidyclust</span> stores model
objects after seeing the data and applying a model.
</p>

<hr>
<h2 id='cluster_metric_set'>Combine metric functions</h2><span id='topic+cluster_metric_set'></span>

<h3>Description</h3>

<p><code>cluster_metric_set()</code> allows you to combine multiple metric functions
together into a new function that calculates all of them at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_metric_set(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_metric_set_+3A_...">...</code></td>
<td>
<p>The bare names of the functions to be included in the metric set.
These functions must be cluster metrics such as <code><a href="#topic+sse_total">sse_total()</a></code>,
<code><a href="#topic+sse_ratio">sse_ratio()</a></code>, or <code><a href="#topic+silhouette_avg">silhouette_avg()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions must be:
</p>

<ul>
<li><p> Only cluster metrics
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>cluster_metric_set()</code> object, combining the use of all input
metrics.
</p>

<hr>
<h2 id='cluster_spec'>Model Specification Information</h2><span id='topic+cluster_spec'></span>

<h3>Description</h3>

<p>An object with class &quot;cluster_spec&quot; is a container for information about a
model that will be fit.
</p>


<h3>Details</h3>

<p>The following model types are implemented in tidyclust:
</p>

<ul>
<li><p> K-Means in <code><a href="#topic+k_means">k_means()</a></code>
</p>
</li>
<li><p> Hierarchical (Agglomerative) Clustering in <code><a href="#topic+hier_clust">hier_clust()</a></code>
</p>
</li></ul>

<p>The main elements of the object are:
</p>

<ul>
<li> <p><code>args</code>: A vector of the main arguments for the model. The
names of these arguments may be different from their counterparts n the
underlying model function. For example, for a <code>k_means()</code> model, the argument
name for the number of clusters are called &quot;num_clusters&quot; instead of &quot;k&quot; to
make it more general and usable across different types of models (and to not
be specific to a particular model function). The elements of <code>args</code> can
<code>tune()</code> with the use in <code><a href="#topic+tune_cluster">tune_cluster()</a></code>.
</p>
</li></ul>

<p>For more information see <a href="https://www.tidymodels.org/start/tuning/">https://www.tidymodels.org/start/tuning/</a>. If left
to their defaults (<code>NULL</code>), the arguments will use the underlying model
functions default value. As discussed below, the arguments in <code>args</code> are
captured as quosures and are not immediately executed.
</p>

<ul>
<li> <p><code>...</code>: Optional model-function-specific parameters. As with <code>args</code>, these
will be quosures and can be <code>tune()</code>.
</p>
</li>
<li> <p><code>mode</code>: The type of model, such as &quot;partition&quot;. Other modes will be added
once the package adds more functionality.
</p>
</li>
<li> <p><code>method</code>: This is a slot that is filled in later by the model's constructor
function. It generally contains lists of information that are used to
create the fit and prediction code as well as required packages and similar
data.
</p>
</li>
<li> <p><code>engine</code>: This character string declares exactly what software will be
used. It can be a package name or a technology type.
</p>
</li></ul>

<p>This class and structure is the basis for how <span class="pkg">tidyclust</span> stores model
objects prior to seeing the data.
</p>


<h3>Argument Details</h3>

<p>An important detail to understand when creating model specifications is that
they are intended to be functionally independent of the data. While it is
true that some tuning parameters are <em>data dependent</em>, the model
specification does not interact with the data at all.
</p>
<p>For example, most R functions immediately evaluate their arguments. For
example, when calling <code>mean(dat_vec)</code>, the object <code>dat_vec</code> is immediately
evaluated inside of the function.
</p>
<p><code>tidyclust</code> model functions do not do this. For example, using
</p>
<pre>
  k_means(num_clusters = ncol(mtcars) / 5)
</pre>
<p><strong>does not</strong> execute <code>ncol(mtcars) / 5</code> when creating the specification.
This can be seen in the output:
</p>
<pre>
  &gt; k_means(num_clusters = ncol(mtcars) / 5)
  K Means Cluster Specification (partition)

  Main Arguments:
    num_clusters = ncol(mtcars)/5

  Computational engine: stats
</pre>
<p>The model functions save the argument <em>expressions</em> and their associated
environments (a.k.a. a quosure) to be evaluated later when either
<code><a href="#topic+fit.cluster_spec">fit.cluster_spec()</a></code> or <code><a href="#topic+fit_xy.cluster_spec">fit_xy.cluster_spec()</a></code> are called with the actual
data.
</p>
<p>The consequence of this strategy is that any data required to get the
parameter values must be available when the model is fit. The two main ways
that this can fail is if:
</p>

<ol>
<li><p> The data have been modified between the creation of the model
specification and when the model fit function is invoked.
</p>
</li>
<li><p> If the model specification is saved and loaded into a new session
where those same data objects do not exist.
</p>
</li></ol>

<p>The best way to avoid these issues is to not reference any data objects in
the global environment but to use data descriptors such as <code>.cols()</code>. Another
way of writing the previous specification is
</p>
<pre>
  k_means(num_clusters = .cols() / 5)
</pre>
<p>This is not dependent on any specific data object and is evaluated
immediately before the model fitting process begins.
</p>
<p>One less advantageous approach to solving this issue is to use
quasiquotation. This would insert the actual R object into the model
specification and might be the best idea when the data object is small. For
example, using
</p>
<pre>
  k_means(num_clusters = ncol(!!mtcars) - 1)
</pre>
<p>would work (and be reproducible between sessions) but embeds the entire
mtcars data set into the <code>num_clusters</code> expression:
</p>
<pre>
 &gt; k_means(num_clusters = ncol(!!mtcars) / 5)
 K Means Cluster Specification (partition)

 Main Arguments:
   num_clusters = ncol(structure(list(mpg = c(21, 21, 22.8, 21.4, 18.7,&lt;snip&gt;

 Computational engine: stats
</pre>
<p>However, if there were an object with the number of columns in it, this
wouldn't be too bad:
</p>
<pre>
 &gt; num_clusters_val &lt;- ncol(mtcars) / 5
 &gt; num_clusters_val
 [1] 10
 &gt; k_means(num_clusters = !!num_clusters_val)
 K Means Cluster Specification (partition)

 Main Arguments:
   num_clusters = 2.2
</pre>
<p>More information on quosures and quasiquotation can be found at
<a href="https://adv-r.hadley.nz/quasiquotation.html">https://adv-r.hadley.nz/quasiquotation.html</a>.
</p>

<hr>
<h2 id='control_cluster'>Control the fit function</h2><span id='topic+control_cluster'></span>

<h3>Description</h3>

<p>Options can be passed to the <code><a href="#topic+fit.cluster_spec">fit.cluster_spec()</a></code> function that control the
output and computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_cluster(verbosity = 1L, catch = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control_cluster_+3A_verbosity">verbosity</code></td>
<td>
<p>An integer where a value of zero indicates that no messages
or output should be shown when packages are loaded or when the model is
fit. A value of 1 means that package loading is quiet but model fits can
produce output to the screen (depending on if they contain their own
<code>verbose</code>-type argument). A value of 2 or more indicates that any output
should be seen.</p>
</td></tr>
<tr><td><code id="control_cluster_+3A_catch">catch</code></td>
<td>
<p>A logical where a value of <code>TRUE</code> will evaluate the model inside
of <code>try(, silent = TRUE)</code>. If the model fails, an object is still returned
(without an error) that inherits the class &quot;try-error&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with class &quot;control_cluster&quot; that is a named list with
the results of the function call
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control_cluster()

control_cluster(catch = TRUE)
</code></pre>

<hr>
<h2 id='cut_height'>Cut Height</h2><span id='topic+cut_height'></span>

<h3>Description</h3>

<p>Used in most <code>tidyclust::hier_clust()</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_height(range = c(0, dials::unknown()), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_height_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively. If a transformation is specified,
these values should be in the <em>transformed units</em>.</p>
</td></tr>
<tr><td><code id="cut_height_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::transform_log10()</code> or <code>scales::transform_reciprocal()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cut_height()
</code></pre>

<hr>
<h2 id='details_hier_clust_stats'>Hierarchical (Agglomerative) Clustering via stats</h2><span id='topic+details_hier_clust_stats'></span>

<h3>Description</h3>

<p><code><a href="#topic+hier_clust">hier_clust()</a></code> creates Hierarchical (Agglomerative) Clustering model.
</p>


<h3>Details</h3>

<p>For this engine, there is a single mode: partition
</p>


<h4>Tuning Parameters</h4>

<p>This model has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_clusters</code>: # Clusters (type: integer, default: no default)
</p>
</li></ul>




<h4>Translation from tidyclust to the original package (partition)</h4>

<div class="sourceCode r"><pre>hier_clust(num_clusters = integer(1)) %&gt;% 
  set_engine("stats") %&gt;% 
  set_mode("partition") %&gt;% 
  translate_tidyclust()
</pre></div>
<div class="sourceCode"><pre>## Hierarchical Clustering Specification (partition)
## 
## Main Arguments:
##   num_clusters = integer(1)
##   linkage_method = complete
## 
## Computational engine: stats 
## 
## Model fit template:
## tidyclust::.hier_clust_fit_stats(data = missing_arg(), num_clusters = integer(1), 
##     linkage_method = "complete")
</pre></div>



<h4>Preprocessing requirements</h4>

<p>Factor/categorical predictors need to be converted to numeric values
(e.g., dummy or indicator variables) for this engine. When using the
formula method via <code><a href="#topic+fit.cluster_spec">fit()</a></code>, tidyclust
will convert factor columns to indicators.
</p>



<h4>References</h4>


<ul>
<li><p> Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988). The New S
Language. Wadsworth &amp; Brooks/Cole. (S version.)
</p>
</li>
<li><p> Everitt, B. (1974). Cluster Analysis. London: Heinemann Educ. Books.
</p>
</li>
<li><p> Hartigan, J.A. (1975). Clustering Algorithms. New York: Wiley.
</p>
</li>
<li><p> Sneath, P. H. A. and R. R. Sokal (1973). Numerical Taxonomy. San
Francisco: Freeman.
</p>
</li>
<li><p> Anderberg, M. R. (1973). Cluster Analysis for Applications. Academic
Press: New York.
</p>
</li>
<li><p> Gordon, A. D. (1999). Classification. Second Edition. London: Chapman
and Hall / CRC
</p>
</li>
<li><p> Murtagh, F. (1985). “Multidimensional Clustering Algorithms”, in
COMPSTAT Lectures 4. Wuerzburg: Physica-Verlag (for algorithmic
details of algorithms used).
</p>
</li>
<li><p> McQuitty, L.L. (1966). Similarity Analysis by Reciprocal Pairs for
Discrete and Continuous Data. Educational and Psychological
Measurement, 26, 825–831. <a href="doi:10.1177/001316446602600402">doi:10.1177/001316446602600402</a>.
</p>
</li>
<li><p> Legendre, P. and L. Legendre (2012). Numerical Ecology, 3rd English
ed. Amsterdam: Elsevier Science BV.
</p>
</li>
<li><p> Murtagh, Fionn and Legendre, Pierre (2014). Ward’s hierarchical
agglomerative clustering method: which algorithms implement Ward’s
criterion? Journal of Classification, 31, 274–295.
<a href="doi:10.1007/s00357-014-9161-z">doi:10.1007/s00357-014-9161-z</a>.
</p>
</li></ul>



<hr>
<h2 id='details_k_means_ClusterR'>K-means via ClusterR</h2><span id='topic+details_k_means_ClusterR'></span>

<h3>Description</h3>

<p><code><a href="#topic+k_means">k_means()</a></code> creates K-means model. This engine uses the classical definition
of a K-means model, which only takes numeric predictors.
</p>


<h3>Details</h3>

<p>For this engine, there is a single mode: partition
</p>


<h4>Tuning Parameters</h4>

<p>This model has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_clusters</code>: # Clusters (type: integer, default: no default)
</p>
</li></ul>




<h4>Translation from tidyclust to the original package (partition)</h4>

<div class="sourceCode r"><pre>k_means(num_clusters = integer(1)) %&gt;% 
  set_engine("ClusterR") %&gt;% 
  set_mode("partition") %&gt;% 
  translate_tidyclust()
</pre></div>
<div class="sourceCode"><pre>## K Means Cluster Specification (partition)
## 
## Main Arguments:
##   num_clusters = integer(1)
## 
## Computational engine: ClusterR 
## 
## Model fit template:
## tidyclust::.k_means_fit_ClusterR(data = missing_arg(), clusters = missing_arg(), 
##     clusters = integer(1))
</pre></div>



<h4>Preprocessing requirements</h4>

<p>Factor/categorical predictors need to be converted to numeric values
(e.g., dummy or indicator variables) for this engine. When using the
formula method via <code><a href="#topic+fit.cluster_spec">fit()</a></code>, tidyclust
will convert factor columns to indicators.
</p>
<p>Predictors should have the same scale. One way to achieve this is to
center and scale each so that each predictor has mean zero and a
variance of one.
</p>



<h4>References</h4>


<ul>
<li><p> Forgy, E. W. (1965). Cluster analysis of multivariate data: efficiency
vs interpretability of classifications. Biometrics, 21, 768–769.
</p>
</li>
<li><p> Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means
clustering algorithm. Applied Statistics, 28, 100–108.
<a href="doi:10.2307/2346830">doi:10.2307/2346830</a>.
</p>
</li>
<li><p> Lloyd, S. P. (1957, 1982). Least squares quantization in PCM.
Technical Note, Bell Laboratories. Published in 1982 in IEEE
Transactions on Information Theory, 28, 128–137.
</p>
</li>
<li><p> MacQueen, J. (1967). Some methods for classification and analysis of
multivariate observations. In Proceedings of the Fifth Berkeley
Symposium on Mathematical Statistics and Probability, eds L. M. Le Cam
&amp; J. Neyman, 1, pp. 281–297. Berkeley, CA: University of California
Press.
</p>
</li></ul>



<hr>
<h2 id='details_k_means_clustMixType'>K-means via clustMixType</h2><span id='topic+details_k_means_clustMixType'></span>

<h3>Description</h3>

<p><code><a href="#topic+k_means">k_means()</a></code> creates K-prototypes model. A K-prototypes is the middle ground
between a K-means and K-modes model, in the sense that it can be used with
data that contains both numeric and categorical predictors.
</p>


<h3>Details</h3>

<p>Both numeric and categorical predictors are requires for this engine.
</p>
<p>For this engine, there is a single mode: partition
</p>


<h4>Tuning Parameters</h4>

<p>This model has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_clusters</code>: # Clusters (type: integer, default: no default)
</p>
</li></ul>




<h4>Translation from tidyclust to the original package (partition)</h4>

<div class="sourceCode r"><pre>k_means(num_clusters = integer(1)) %&gt;% 
  set_engine("clustMixType") %&gt;% 
  set_mode("partition") %&gt;% 
  translate_tidyclust()
</pre></div>
<div class="sourceCode"><pre>## K Means Cluster Specification (partition)
## 
## Main Arguments:
##   num_clusters = integer(1)
## 
## Computational engine: clustMixType 
## 
## Model fit template:
## tidyclust::.k_means_fit_clustMixType(x = missing_arg(), k = missing_arg(), 
##     keep.data = missing_arg(), k = integer(1), keep.data = TRUE, 
##     verbose = FALSE)
</pre></div>



<h4>Preprocessing requirements</h4>

<p>Both categorical and numeric predictors are required.
</p>



<h4>References</h4>


<ul>
<li><p> Szepannek, G. (2018): clustMixType: User-Friendly Clustering of
Mixed-Type Data in R, The R Journal 10/2, 200-208,
<a href="doi:10.32614/RJ-2018-048">doi:10.32614/RJ-2018-048</a>.
</p>
</li>
<li><p> Aschenbruck, R., Szepannek, G., Wilhelm, A. (2022): Imputation
Strategies for Clustering Mixed‑Type Data with Missing Values, Journal
of Classification, <a href="doi:10.1007/s00357-022-09422-y">doi:10.1007/s00357-022-09422-y</a>.
</p>
</li>
<li><p> Z.Huang (1998): Extensions to the k-Means Algorithm for Clustering
Large Data Sets with Categorical Variables, Data Mining and Knowledge
Discovery 2, 283-304.
</p>
</li></ul>



<hr>
<h2 id='details_k_means_klaR'>K-means via klaR</h2><span id='topic+details_k_means_klaR'></span>

<h3>Description</h3>

<p><code><a href="#topic+k_means">k_means()</a></code> creates K-Modes model. This model is intended to be used with
categorical predictors. Although it will accept numeric predictors if they
contain a few number of unique values. The numeric predictors will then be
treated like categorical.
</p>


<h3>Details</h3>

<p>For this engine, there is a single mode: partition
</p>


<h4>Tuning Parameters</h4>

<p>This model has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_clusters</code>: # Clusters (type: integer, default: no default)
</p>
</li></ul>




<h4>Translation from tidyclust to the original package (partition)</h4>

<div class="sourceCode r"><pre>k_means(num_clusters = integer(1)) %&gt;% 
  set_engine("klaR") %&gt;% 
  set_mode("partition") %&gt;% 
  translate_tidyclust()
</pre></div>
<div class="sourceCode"><pre>## K Means Cluster Specification (partition)
## 
## Main Arguments:
##   num_clusters = integer(1)
## 
## Computational engine: klaR 
## 
## Model fit template:
## tidyclust::.k_means_fit_klaR(data = missing_arg(), modes = missing_arg(), 
##     modes = integer(1))
</pre></div>



<h4>Preprocessing requirements</h4>

<p>Only categorical variables are accepted, along with numerics with few
unique values.
</p>



<h4>References</h4>


<ul>
<li><p> Huang, Z. (1997) A Fast Clustering Algorithm to Cluster Very Large
Categorical Data Sets in Data Mining. in KDD: Techniques and
Applications (H. Lu, H. Motoda and H. Luu, Eds.), pp. 21-34, World
Scientific, Singapore.
</p>
</li>
<li><p> MacQueen, J. (1967) Some methods for classification and analysis of
multivariate observations. In Proceedings of the Fifth Berkeley
Symposium on Mathematical Statistics and Probability, eds L. M. Le Cam
&amp; J. Neyman, 1, pp. 281-297. Berkeley, CA: University of California
Press.
</p>
</li></ul>



<hr>
<h2 id='details_k_means_stats'>K-means via stats</h2><span id='topic+details_k_means_stats'></span>

<h3>Description</h3>

<p><code><a href="#topic+k_means">k_means()</a></code> creates K-means model. This engine uses the classical definition
of a K-means model, which only takes numeric predictors.
</p>


<h3>Details</h3>

<p>For this engine, there is a single mode: partition
</p>


<h4>Tuning Parameters</h4>

<p>This model has 1 tuning parameters:
</p>

<ul>
<li> <p><code>num_clusters</code>: # Clusters (type: integer, default: no default)
</p>
</li></ul>




<h4>Translation from tidyclust to the original package (partition)</h4>

<div class="sourceCode r"><pre>k_means(num_clusters = integer(1)) %&gt;% 
  set_engine("stats") %&gt;% 
  set_mode("partition") %&gt;% 
  translate_tidyclust()
</pre></div>
<div class="sourceCode"><pre>## K Means Cluster Specification (partition)
## 
## Main Arguments:
##   num_clusters = integer(1)
## 
## Computational engine: stats 
## 
## Model fit template:
## tidyclust::.k_means_fit_stats(x = missing_arg(), centers = missing_arg(), 
##     centers = integer(1))
</pre></div>



<h4>Preprocessing requirements</h4>

<p>Factor/categorical predictors need to be converted to numeric values
(e.g., dummy or indicator variables) for this engine. When using the
formula method via <code><a href="#topic+fit.cluster_spec">fit()</a></code>, tidyclust
will convert factor columns to indicators.
</p>
<p>Predictors should have the same scale. One way to achieve this is to
center and scale each so that each predictor has mean zero and a
variance of one.
</p>



<h4>References</h4>


<ul>
<li><p> Forgy, E. W. (1965). Cluster analysis of multivariate data: efficiency
vs interpretability of classifications. Biometrics, 21, 768–769.
</p>
</li>
<li><p> Hartigan, J. A. and Wong, M. A. (1979). Algorithm AS 136: A K-means
clustering algorithm. Applied Statistics, 28, 100–108.
<a href="doi:10.2307/2346830">doi:10.2307/2346830</a>.
</p>
</li>
<li><p> Lloyd, S. P. (1957, 1982). Least squares quantization in PCM.
Technical Note, Bell Laboratories. Published in 1982 in IEEE
Transactions on Information Theory, 28, 128–137.
</p>
</li>
<li><p> MacQueen, J. (1967). Some methods for classification and analysis of
multivariate observations. In Proceedings of the Fifth Berkeley
Symposium on Mathematical Statistics and Probability, eds L. M. Le Cam
&amp; J. Neyman, 1, pp. 281–297. Berkeley, CA: University of California
Press.
</p>
</li></ul>



<hr>
<h2 id='extract_centroids'>Extract clusters from model</h2><span id='topic+extract_centroids'></span>

<h3>Description</h3>

<p>When applied to a fitted cluster specification, returns a tibble with cluster
location. When such locations doesn't make sense for the model, a mean
location is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_centroids(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_centroids_+3A_object">object</code></td>
<td>
<p>An fitted <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.</p>
</td></tr>
<tr><td><code id="extract_centroids_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods. Using the <code>prefix</code> allows you
to change the prefix in the levels of the factor levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some model types such as K-means as seen in <code><a href="#topic+k_means">k_means()</a></code> stores the centroid
in the object itself. leading the use of this function to act as an simple
extract. Other model types such as Hierarchical (Agglomerative) Clustering as
seen in <code><a href="#topic+hier_clust">hier_clust()</a></code>, are fit in such a way that the number of clusters can
be determined at any time after the fit. Setting the <code>num_clusters</code> or
<code>cut_height</code> in this function will be used to determine the clustering when
reported.
</p>
<p>Further more, some models like <code><a href="#topic+hier_clust">hier_clust()</a></code>, doesn't have a notion of
&quot;centroids&quot;. The mean of the observation within each cluster assignment is
returned as the centroid.
</p>
<p>The ordering of the clusters is such that the first observation in the
training data set will be in cluster 1, the next observation that doesn't
belong to cluster 1 will be in cluster 2, and so on and forth. As the
ordering of clustering doesn't matter, this is done to avoid identical sets
of clustering having different labels if fit multiple times.
</p>


<h4>Related functions</h4>

<p><code>extract_centroids()</code> is a part of a trio of functions doing similar things:
</p>

<ul>
<li> <p><code><a href="#topic+extract_cluster_assignment">extract_cluster_assignment()</a></code> returns the cluster assignments of the
training observations
</p>
</li>
<li> <p><code><a href="#topic+extract_centroids">extract_centroids()</a></code> returns the location of the centroids
</p>
</li>
<li> <p><code><a href="#topic+predict.cluster_fit">predict()</a></code> returns the cluster a new
observation belongs to
</p>
</li></ul>




<h3>Value</h3>

<p>A <code>tibble::tibble()</code> with 1 row for each centroid and their position.
<code>.cluster</code> denotes the cluster name for the centroid. The remaining
variables match variables passed into model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_cluster_assignment">extract_cluster_assignment()</a></code> <code><a href="#topic+predict.cluster_fit">predict.cluster_fit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

kmeans_fit %&gt;%
  extract_centroids()

# Some models such as `hier_clust()` fits in such a way that you can specify
# the number of clusters after the model is fit.
# A Hierarchical (Agglomerative) Clustering method doesn't technically have
# clusters, so the center of the observation within each cluster is returned
# instead.
hclust_spec &lt;- hier_clust() %&gt;%
  set_engine("stats")

hclust_fit &lt;- fit(hclust_spec, ~., mtcars)

hclust_fit %&gt;%
  extract_centroids(num_clusters = 2)

hclust_fit %&gt;%
  extract_centroids(cut_height = 250)
</code></pre>

<hr>
<h2 id='extract_cluster_assignment'>Extract cluster assignments from model</h2><span id='topic+extract_cluster_assignment'></span>

<h3>Description</h3>

<p>When applied to a fitted cluster specification, returns a tibble with cluster
assignments of the data used to train the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cluster_assignment(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_cluster_assignment_+3A_object">object</code></td>
<td>
<p>An fitted <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.</p>
</td></tr>
<tr><td><code id="extract_cluster_assignment_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods. Using the <code>prefix</code> allows you
to change the prefix in the levels of the factor levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some model types such as K-means as seen in <code><a href="#topic+k_means">k_means()</a></code> stores the
cluster assignments in the object itself. leading the use of this function to
act as an simple extract. Other model types such as Hierarchical
(Agglomerative) Clustering as seen in <code><a href="#topic+hier_clust">hier_clust()</a></code>, are fit in such a way
that the number of clusters can be determined at any time after the fit.
Setting the <code>num_clusters</code> or <code>cut_height</code> in this function will be used to
determine the clustering when reported.
</p>
<p>The ordering of the clusters is such that the first observation in the
training data set will be in cluster 1, the next observation that doesn't
belong to cluster 1 will be in cluster 2, and so on and forth. As the
ordering of clustering doesn't matter, this is done to avoid identical sets
of clustering having different labels if fit multiple times.
</p>


<h4>Related functions</h4>

<p><code>extract_cluster_assignment()</code> is a part of a trio of functions doing
similar things:
</p>

<ul>
<li> <p><code><a href="#topic+extract_cluster_assignment">extract_cluster_assignment()</a></code> returns the cluster assignments of the
training observations
</p>
</li>
<li> <p><code><a href="#topic+extract_centroids">extract_centroids()</a></code> returns the location of the centroids
</p>
</li>
<li> <p><code><a href="#topic+predict.cluster_fit">predict()</a></code> returns the cluster a new
observation belongs to
</p>
</li></ul>




<h3>Value</h3>

<p>A <code>tibble::tibble()</code> with 1 column named <code>.cluster</code>. This tibble will
correspond the the training data set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_centroids">extract_centroids()</a></code> <code><a href="#topic+predict.cluster_fit">predict.cluster_fit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

kmeans_fit %&gt;%
  extract_cluster_assignment()

kmeans_fit %&gt;%
  extract_cluster_assignment(prefix = "C_")

# Some models such as `hier_clust()` fits in such a way that you can specify
# the number of clusters after the model is fit
hclust_spec &lt;- hier_clust() %&gt;%
  set_engine("stats")

hclust_fit &lt;- fit(hclust_spec, ~., mtcars)

hclust_fit %&gt;%
  extract_cluster_assignment(num_clusters = 2)

hclust_fit %&gt;%
  extract_cluster_assignment(cut_height = 250)
</code></pre>

<hr>
<h2 id='extract_fit_summary'>S3 method to get fitted model summary info depending on engine</h2><span id='topic+extract_fit_summary'></span>

<h3>Description</h3>

<p>S3 method to get fitted model summary info depending on engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fit_summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_fit_summary_+3A_object">object</code></td>
<td>
<p>a fitted <code><a href="#topic+cluster_spec">cluster_spec</a></code> object</p>
</td></tr>
<tr><td><code id="extract_fit_summary_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The elements <code>cluster_names</code> and <code>cluster_assignments</code> will be factors.
</p>


<h3>Value</h3>

<p>A list with various summary elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

kmeans_fit %&gt;%
  extract_fit_summary()
</code></pre>

<hr>
<h2 id='extract-tidyclust'>Extract elements of a tidyclust model object</h2><span id='topic+extract-tidyclust'></span><span id='topic+extract_fit_engine.cluster_fit'></span><span id='topic+extract_parameter_set_dials.cluster_spec'></span>

<h3>Description</h3>

<p>These functions extract various elements from a clustering object. If they do
not exist yet, an error is thrown.
</p>

<ul>
<li> <p><code>extract_fit_engine()</code> returns the engine specific fit embedded within
a tidyclust model fit. For example, when using <code><a href="#topic+k_means">k_means()</a></code>
with the <code>"lm"</code> engine, this returns the underlying <code>kmeans</code> object.
</p>
</li>
<li> <p><code>extract_parameter_set_dials()</code> returns a set of dials parameter objects.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_fit'
extract_fit_engine(x, ...)

## S3 method for class 'cluster_spec'
extract_parameter_set_dials(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract-tidyclust_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+cluster_fit">cluster_fit</a></code> object or a <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.</p>
</td></tr>
<tr><td><code id="extract-tidyclust_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting the underlying engine fit can be helpful for describing the
model (via <code>print()</code>, <code>summary()</code>, <code>plot()</code>, etc.) or for variable
importance/explainers.
</p>
<p>However, users should not invoke the
<code><a href="#topic+predict.cluster_fit">predict()</a></code> method on an extracted model.
There may be preprocessing operations that <code>tidyclust</code> has executed on the
data prior to giving it to the model. Bypassing these can lead to errors or
silently generating incorrect predictions.
</p>
<p><strong>Good</strong>:
</p>
<div class="sourceCode r"><pre>   tidyclust_fit %&gt;% predict(new_data)
</pre></div>
<p><strong>Bad</strong>:
</p>
<div class="sourceCode r"><pre>   tidyclust_fit %&gt;% extract_fit_engine() %&gt;% predict(new_data)
</pre></div>


<h3>Value</h3>

<p>The extracted value from the tidyclust object, <code>x</code>, as described in the
description section.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 2)
kmeans_fit &lt;- fit(kmeans_spec, ~., data = mtcars)

extract_fit_engine(kmeans_fit)
</code></pre>

<hr>
<h2 id='finalize_model_tidyclust'>Splice final parameters into objects</h2><span id='topic+finalize_model_tidyclust'></span><span id='topic+finalize_workflow_tidyclust'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;finalize_*&#8288;</code> functions take a list or tibble of tuning parameter values
and update objects with those values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalize_model_tidyclust(x, parameters)

finalize_workflow_tidyclust(x, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="finalize_model_tidyclust_+3A_x">x</code></td>
<td>
<p>A recipe, <code>parsnip</code> model specification, or workflow.</p>
</td></tr>
<tr><td><code id="finalize_model_tidyclust_+3A_parameters">parameters</code></td>
<td>
<p>A list or 1-row tibble of parameter values. Note that the
column names of the tibble should be the <code>id</code> fields attached to <code>tune()</code>.
For example, in the <code>Examples</code> section below, the model has <code>tune("K")</code>. In
this case, the parameter tibble should be &quot;K&quot; and not &quot;neighbors&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = tune())
kmeans_spec

best_params &lt;- data.frame(num_clusters = 5)
best_params

finalize_model_tidyclust(kmeans_spec, best_params)
</code></pre>

<hr>
<h2 id='fit.cluster_spec'>Fit a Model Specification to a Data Set</h2><span id='topic+fit.cluster_spec'></span><span id='topic+fit_xy.cluster_spec'></span>

<h3>Description</h3>

<p><code>fit()</code> and <code>fit_xy()</code> take a model specification, translate_tidyclust the
required code by substituting arguments, and execute the model fit routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
fit(object, formula, data, control = control_cluster(), ...)

## S3 method for class 'cluster_spec'
fit_xy(object, x, case_weights = NULL, control = control_cluster(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.cluster_spec_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+cluster_spec">cluster_spec</a></code> that has a chosen engine
(via <code><a href="#topic+set_engine">set_engine()</a></code>).</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_data">data</code></td>
<td>
<p>Optional, depending on the interface (see Details below). A data
frame containing all relevant variables (e.g. predictors, case weights,
etc). Note: when needed, a <em>named argument</em> should be used.</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_control">control</code></td>
<td>
<p>A named list with elements <code>verbosity</code> and <code>catch</code>. See
<code><a href="#topic+control_cluster">control_cluster()</a></code>.</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_...">...</code></td>
<td>
<p>Not currently used; values passed here will be ignored. Other
options required to fit the model should be passed using <code>set_engine()</code>.</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_x">x</code></td>
<td>
<p>A matrix, sparse matrix, or data frame of predictors. Only some
models have support for sparse matrix input. See <code>modelenv::get_encoding()</code>
for details. <code>x</code> should have column names.</p>
</td></tr>
<tr><td><code id="fit.cluster_spec_+3A_case_weights">case_weights</code></td>
<td>
<p>An optional classed vector of numeric case weights. This
must return <code>TRUE</code> when <code><a href="hardhat.html#topic+is_case_weights">hardhat::is_case_weights()</a></code> is run on it. See
<code><a href="hardhat.html#topic+frequency_weights">hardhat::frequency_weights()</a></code> and <code><a href="hardhat.html#topic+importance_weights">hardhat::importance_weights()</a></code> for
examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fit()</code> and <code>fit_xy()</code> substitute the current arguments in the
model specification into the computational engine's code, check them for
validity, then fit the model using the data and the engine-specific code.
Different model functions have different interfaces (e.g. formula or
<code>x</code>/<code>y</code>) and these functions translate_tidyclust between the interface used
when <code>fit()</code> or <code>fit_xy()</code> was invoked and the one required by the
underlying model.
</p>
<p>When possible, these functions attempt to avoid making copies of the data.
For example, if the underlying model uses a formula and <code>fit()</code> is invoked,
the original data are references when the model is fit. However, if the
underlying model uses something else, such as <code>x</code>/<code>y</code>, the formula is
evaluated and the data are converted to the required format. In this case,
any calls in the resulting model objects reference the temporary objects
used to fit the model.
</p>
<p>If the model engine has not been set, the model's default engine will be
used (as discussed on each model page). If the <code>verbosity</code> option of
<code><a href="#topic+control_cluster">control_cluster()</a></code> is greater than zero, a warning will be produced.
</p>
<p>If you would like to use an alternative method for generating contrasts
when supplying a formula to <code>fit()</code>, set the global option <code>contrasts</code> to
your preferred method. For example, you might set it to: <code>options(contrasts = c(unordered = "contr.helmert", ordered = "contr.poly"))</code>. See the help
page for <code><a href="stats.html#topic+contrast">stats::contr.treatment()</a></code> for more possible contrast types.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cluster_fit">cluster_fit</a></code> object that contains several elements:
</p>

<ul>
<li> <p><code>spec</code>: The model specification object (<code>object</code> in the
call to <code>fit</code>)
</p>
</li>
<li> <p><code>fit</code>: when the model is executed without error, this is the
model object. Otherwise, it is a <code>try-error</code>
object with the error message.
</p>
</li>
<li> <p><code>preproc</code>: any objects needed to convert between a formula and
non-formula interface
(such as the <code>terms</code> object)
</p>
</li></ul>

<p>The return value will also have a class related to the fitted model (e.g.
<code>"_kmeans"</code>) before the base class of <code>"cluster_fit"</code>.
</p>
<p>A fitted <code><a href="#topic+cluster_fit">cluster_fit</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_engine">set_engine()</a></code>, <code><a href="#topic+control_cluster">control_cluster()</a></code>, <code><a href="#topic+cluster_spec">cluster_spec</a></code>,
<code><a href="#topic+cluster_fit">cluster_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

kmeans_mod &lt;- k_means(num_clusters = 5)

using_formula &lt;-
  kmeans_mod %&gt;%
  set_engine("stats") %&gt;%
  fit(~., data = mtcars)

using_x &lt;-
  kmeans_mod %&gt;%
  set_engine("stats") %&gt;%
  fit_xy(x = mtcars)

using_formula
using_x
</code></pre>

<hr>
<h2 id='get_centroid_dists'>Computes distance from observations to centroids</h2><span id='topic+get_centroid_dists'></span>

<h3>Description</h3>

<p>Computes distance from observations to centroids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_centroid_dists(
  new_data,
  centroids,
  dist_fun = function(x, y) {
     philentropy::dist_many_many(x, y, method =
    "euclidean")
 }
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_centroid_dists_+3A_new_data">new_data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="get_centroid_dists_+3A_centroids">centroids</code></td>
<td>
<p>A data frame where each row is a centroid.</p>
</td></tr>
<tr><td><code id="get_centroid_dists_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for computing matrix-to-matrix distances. Defaults
to
<code>function(x, y) philentropy::dist_many_many(x, y, method = "euclidean")</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_tidyclust_colors'>Get colors for tidyclust text.</h2><span id='topic+get_tidyclust_colors'></span>

<h3>Description</h3>

<p>Get colors for tidyclust text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tidyclust_colors()
</code></pre>


<h3>Value</h3>

<p>a list of <code>cli</code> functions.
</p>

<hr>
<h2 id='glance.cluster_fit'>Construct a single row summary &quot;glance&quot; of a model, fit, or other object</h2><span id='topic+glance.cluster_fit'></span>

<h3>Description</h3>

<p>This method glances the model in a tidyclust model object, if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_fit'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glance.cluster_fit_+3A_x">x</code></td>
<td>
<p>model or other R object to convert to single-row data frame</p>
</td></tr>
<tr><td><code id="glance.cluster_fit_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>

<hr>
<h2 id='hier_clust'>Hierarchical (Agglomerative) Clustering</h2><span id='topic+hier_clust'></span>

<h3>Description</h3>

<p><code>hier_clust()</code> defines a model that fits clusters based on a distance-based
dendrogram
</p>
<p>There are different ways to fit this model, and the method of estimation is
chosen by setting the model engine. The engine-specific pages for this model
are listed below.
</p>

<ul>
<li> <p><a href="#topic+details_hier_clust_stats">stats</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hier_clust(
  mode = "partition",
  engine = "stats",
  num_clusters = NULL,
  cut_height = NULL,
  linkage_method = "complete"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hier_clust_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model. The only
possible value for this model is &quot;partition&quot;.</p>
</td></tr>
<tr><td><code id="hier_clust_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational engine
to use for fitting. Possible engines are listed below. The default for this
model is <code>"stats"</code>.</p>
</td></tr>
<tr><td><code id="hier_clust_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Positive integer, number of clusters in model (optional).</p>
</td></tr>
<tr><td><code id="hier_clust_+3A_cut_height">cut_height</code></td>
<td>
<p>Positive double, height at which to cut dendrogram to
obtain cluster assignments (only used if <code>num_clusters</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="hier_clust_+3A_linkage_method">linkage_method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>,
<code>"complete"</code>, <code>"average"</code> (= UPGMA), <code>"mcquitty"</code> (= WPGMA), <code>"median"</code> (=
WPGMC) or <code>"centroid"</code> (= UPGMC).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>What does it mean to predict?</h4>

<p>To predict the cluster assignment for a new observation, we find the closest
cluster. How we measure “closeness” is dependent on the specified type of
linkage in the model:
</p>

<ul>
<li> <p><em>single linkage</em>: The new observation is assigned to the same cluster as
its nearest observation from the training data.
</p>
</li>
<li> <p><em>complete linkage</em>: The new observation is assigned to the cluster with the
smallest maximum distances between training observations and the new
observation.
</p>
</li>
<li> <p><em>average linkage</em>: The new observation is assigned to the cluster with the
smallest average distances between training observations and the new
observation.
</p>
</li>
<li> <p><em>centroid method</em>: The new observation is assigned to the cluster with the
closest centroid, as in prediction for k_means.
</p>
</li>
<li> <p><em>Ward’s method</em>: The new observation is assigned to the cluster with the
smallest increase in <strong>error sum of squares (ESS)</strong> due to the new
addition. The ESS is computed as the sum of squared distances between
observations in a cluster, and the centroid of the cluster.
</p>
</li></ul>




<h3>Value</h3>

<p>A <code>hier_clust</code> cluster specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show all engines
modelenv::get_from_env("hier_clust")

hier_clust()
</code></pre>

<hr>
<h2 id='k_means'>K-Means</h2><span id='topic+k_means'></span>

<h3>Description</h3>

<p><code>k_means()</code> defines a model that fits clusters based on distances to a number
of centers. This definition doesn't just include K-means, but includes
models like K-prototypes.
</p>
<p>There are different ways to fit this model, and the method of estimation is
chosen by setting the model engine. The engine-specific pages for this model
are listed below.
</p>

<ul>
<li> <p><a href="#topic+details_k_means_stats">stats</a>: Classical K-means
</p>
</li>
<li> <p><a href="#topic+details_k_means_ClusterR">ClusterR</a>: Classical K-means
</p>
</li>
<li> <p><a href="#topic+details_k_means_klaR">klaR</a>: K-Modes
</p>
</li>
<li> <p><a href="#topic+details_k_means_clustMixType">clustMixType</a>: K-prototypes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>k_means(mode = "partition", engine = "stats", num_clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_means_+3A_mode">mode</code></td>
<td>
<p>A single character string for the type of model. The only
possible value for this model is &quot;partition&quot;.</p>
</td></tr>
<tr><td><code id="k_means_+3A_engine">engine</code></td>
<td>
<p>A single character string specifying what computational engine
to use for fitting. Possible engines are listed below. The default for this
model is <code>"stats"</code>.</p>
</td></tr>
<tr><td><code id="k_means_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Positive integer, number of clusters in model.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>What does it mean to predict?</h4>

<p>For a K-means model, each cluster is defined by a location in the predictor
space. Therefore, prediction in tidyclust is defined by calculating which
cluster centroid an observation is closest too.
</p>



<h3>Value</h3>

<p>A <code>k_means</code> cluster specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Show all engines
modelenv::get_from_env("k_means")

k_means()
</code></pre>

<hr>
<h2 id='knit_engine_docs'>Knit engine-specific documentation</h2><span id='topic+knit_engine_docs'></span>

<h3>Description</h3>

<p>Knit engine-specific documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_engine_docs(pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knit_engine_docs_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression to specify which files to knit. The
default knits all engine documentation files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with column <code>file</code> for the file name and <code>result</code> (a
character vector that echos the output file name or, when there is
a failure, the error message).
</p>

<hr>
<h2 id='linkage_method'>The agglomeration Linkage method</h2><span id='topic+linkage_method'></span><span id='topic+values_linkage_method'></span>

<h3>Description</h3>

<p>The agglomeration Linkage method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkage_method(values = values_linkage_method)

values_linkage_method
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkage_method_+3A_values">values</code></td>
<td>
<p>A character string of possible values. See <code>linkage_methods</code>
in examples below.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 8.
</p>


<h3>Details</h3>

<p>This parameter is used in <code>tidyclust</code> models for <code>hier_clust()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>values_linkage_method
linkage_method()
</code></pre>

<hr>
<h2 id='list_md_problems'>Locate and show errors/warnings in engine-specific documentation</h2><span id='topic+list_md_problems'></span>

<h3>Description</h3>

<p>Locate and show errors/warnings in engine-specific documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_md_problems()
</code></pre>


<h3>Value</h3>

<p>A tibble with column <code>file</code> for the file name, <code>line</code> indicating
the line where the error/warning occurred, and <code>problem</code> showing the
error/warning message.
</p>

<hr>
<h2 id='load_pkgs.cluster_spec'>Quietly load package namespace</h2><span id='topic+load_pkgs.cluster_spec'></span>

<h3>Description</h3>

<p>For one or more packages, load the namespace. This is used during parallel
processing since the different parallel backends handle the package
environments differently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
load_pkgs(x, infra = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_pkgs.cluster_spec_+3A_x">x</code></td>
<td>
<p>A character vector of packages.</p>
</td></tr>
<tr><td><code id="load_pkgs.cluster_spec_+3A_infra">infra</code></td>
<td>
<p>Should base tidymodels packages be loaded as well?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible NULL.
</p>

<hr>
<h2 id='make_classes_tidyclust'>Prepend a new class</h2><span id='topic+make_classes_tidyclust'></span>

<h3>Description</h3>

<p>This adds an extra class to a base class of &quot;cluster_spec&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_classes_tidyclust(prefix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_classes_tidyclust_+3A_prefix">prefix</code></td>
<td>
<p>A character string for a class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='min_grid.cluster_spec'>Determine the minimum set of model fits</h2><span id='topic+min_grid.cluster_spec'></span>

<h3>Description</h3>

<p>Determine the minimum set of model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
min_grid(x, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_grid.cluster_spec_+3A_x">x</code></td>
<td>
<p>A cluster specification.</p>
</td></tr>
<tr><td><code id="min_grid.cluster_spec_+3A_grid">grid</code></td>
<td>
<p>A tibble with tuning parameter combinations.</p>
</td></tr>
<tr><td><code id="min_grid.cluster_spec_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the minimum tuning parameters to fit and an additional
list column with the parameter combinations used for prediction.
</p>

<hr>
<h2 id='new_cluster_metric'>Construct a new clustering metric function</h2><span id='topic+new_cluster_metric'></span>

<h3>Description</h3>

<p>These functions provide convenient wrappers to create the one
type of metric functions in celrry: clustering metrics. They add a
metric-specific class to <code>fn</code>. These features are used by
<code><a href="#topic+cluster_metric_set">cluster_metric_set()</a></code> and by <code><a href="#topic+tune_cluster">tune_cluster()</a></code> when tuning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_cluster_metric(fn, direction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_cluster_metric_+3A_fn">fn</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="new_cluster_metric_+3A_direction">direction</code></td>
<td>
<p>A string. One of:
</p>

<ul>
<li> <p><code>"maximize"</code>
</p>
</li>
<li> <p><code>"minimize"</code>
</p>
</li>
<li> <p><code>"zero"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cluster_metric</code> object.
</p>

<hr>
<h2 id='new_cluster_spec'>Functions required for tidyclust-adjacent packages</h2><span id='topic+new_cluster_spec'></span>

<h3>Description</h3>

<p>These functions are helpful when creating new packages that will register new
cluster specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_cluster_spec(cls, args, eng_args, mode, method, engine)
</code></pre>


<h3>Value</h3>

<p>A <code><a href="#topic+cluster_spec">cluster_spec</a></code> object made to work with tidyclust.
</p>

<hr>
<h2 id='predict_cluster'>Other predict methods.</h2><span id='topic+predict_cluster'></span><span id='topic+predict_cluster.cluster_fit'></span>

<h3>Description</h3>

<p>These are internal functions not meant to be directly called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_cluster(object, ...)

## S3 method for class 'cluster_fit'
predict_cluster(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_cluster_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+cluster_fit">cluster_fit</a></code>.</p>
</td></tr>
<tr><td><code id="predict_cluster_+3A_...">...</code></td>
<td>
<p>Arguments to the underlying model's prediction function cannot be
passed here (see <code>opts</code>).</p>
</td></tr>
<tr><td><code id="predict_cluster_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble::tibble()</code>.
</p>
<p>A <code>tibble::tibble()</code>.
</p>

<hr>
<h2 id='predict.cluster_fit'>Model predictions</h2><span id='topic+predict.cluster_fit'></span><span id='topic+predict_raw.cluster_fit'></span>

<h3>Description</h3>

<p>Apply to a model to create different types of predictions. <code>predict()</code> can be
used for all types of models and uses the &quot;type&quot; argument for more
specificity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_fit'
predict(object, new_data, type = NULL, opts = list(), ...)

## S3 method for class 'cluster_fit'
predict_raw(object, new_data, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cluster_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+cluster_fit">cluster_fit</a></code>.</p>
</td></tr>
<tr><td><code id="predict.cluster_fit_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="predict.cluster_fit_+3A_type">type</code></td>
<td>
<p>A single character value or <code>NULL</code>. Possible values are
&quot;cluster&quot;, or &quot;raw&quot;. When <code>NULL</code>, <code>predict()</code> will choose an appropriate
value based on the model's mode.</p>
</td></tr>
<tr><td><code id="predict.cluster_fit_+3A_opts">opts</code></td>
<td>
<p>A list of optional arguments to the underlying predict function
that will be used when <code>type = "raw"</code>. The list should not include options
for the model object or the new data being predicted.</p>
</td></tr>
<tr><td><code id="predict.cluster_fit_+3A_...">...</code></td>
<td>
<p>Arguments to the underlying model's prediction function cannot be
passed here (see <code>opts</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &quot;type&quot; is not supplied to <code>predict()</code>, then a choice is made:
</p>

<ul>
<li> <p><code>type = "cluster"</code> for clustering models
</p>
</li></ul>

<p><code>predict()</code> is designed to provide a tidy result (see &quot;Value&quot; section below)
in a tibble output format.
</p>
<p>The ordering of the clusters is such that the first observation in the
training data set will be in cluster 1, the next observation that doesn't
belong to cluster 1 will be in cluster 2, and so on and forth. As the
ordering of clustering doesn't matter, this is done to avoid identical sets
of clustering having different labels if fit multiple times.
</p>


<h4>What does it mean to predict?</h4>

<p>Prediction is not always formally defined for clustering models. Therefore,
each <code><a href="#topic+cluster_spec">cluster_spec</a></code> method will have their own section on how &quot;prediction&quot;
is interpreted, and done if implemented.
</p>



<h4>Related functions</h4>

<p><code>predict()</code> when used with tidyclust objects is a part of a trio of functions
doing similar things:
</p>

<ul>
<li> <p><code><a href="#topic+extract_cluster_assignment">extract_cluster_assignment()</a></code> returns the cluster assignments of the
training observations
</p>
</li>
<li> <p><code><a href="#topic+extract_centroids">extract_centroids()</a></code> returns the location of the centroids
</p>
</li>
<li> <p><code><a href="#topic+predict.cluster_fit">predict()</a></code> returns the cluster a new
observation belongs to
</p>
</li></ul>




<h3>Value</h3>

<p>With the exception of <code>type = "raw"</code>, the results of
<code>predict.cluster_fit()</code> will be a tibble as many rows in the output as
there are rows in <code>new_data</code> and the column names will be predictable.
</p>
<p>For clustering results the tibble will have a <code>.pred_cluster</code> column.
</p>
<p>Using <code>type = "raw"</code> with <code>predict.cluster_fit()</code> will return the
unadulterated results of the prediction function.
</p>
<p>When the model fit failed and the error was captured, the <code>predict()</code>
function will return the same structure as above but filled with missing
values. This does not currently work for multivariate models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_cluster_assignment">extract_cluster_assignment()</a></code> <code><a href="#topic+extract_centroids">extract_centroids()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

kmeans_fit %&gt;%
  predict(new_data = mtcars)

# Some models such as `hier_clust()` fits in such a way that you can specify
# the number of clusters after the model is fit
hclust_spec &lt;- hier_clust() %&gt;%
  set_engine("stats")

hclust_fit &lt;- fit(hclust_spec, ~., mtcars)

hclust_fit %&gt;%
  predict(new_data = mtcars[4:6, ], num_clusters = 2)

hclust_fit %&gt;%
  predict(new_data = mtcars[4:6, ], cut_height = 250)
</code></pre>

<hr>
<h2 id='prep_data_dist'>Prepares data and distance matrices for metric calculation</h2><span id='topic+prep_data_dist'></span>

<h3>Description</h3>

<p>Prepares data and distance matrices for metric calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_data_dist(
  object,
  new_data = NULL,
  dists = NULL,
  dist_fun = philentropy::distance
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_data_dist_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.</p>
</td></tr>
<tr><td><code id="prep_data_dist_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to calculate predictions on.  If <code>NULL</code>, the
trained cluster assignments from the fitted object are used.</p>
</td></tr>
<tr><td><code id="prep_data_dist_+3A_dists">dists</code></td>
<td>
<p>A distance matrix for the data.  If <code>NULL</code>, distance is computed
on <code>new_data</code> using the <code>stats::dist()</code> function.</p>
</td></tr>
<tr><td><code id="prep_data_dist_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A custom distance functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='reconcile_clusterings_mapping'>Relabels clusters to match another cluster assignment</h2><span id='topic+reconcile_clusterings_mapping'></span>

<h3>Description</h3>

<p>When forcing one-to-one, the user needs to decide what to prioritize:
</p>

<ul>
<li><p> &quot;accuracy&quot;: optimize raw count of all observations with the same label
across the two assignments
</p>
</li>
<li><p> &quot;precision&quot;: optimize the average percent of each alt cluster that
matches the corresponding primary cluster
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>reconcile_clusterings_mapping(
  primary,
  alternative,
  one_to_one = TRUE,
  optimize = "accuracy"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconcile_clusterings_mapping_+3A_primary">primary</code></td>
<td>
<p>A vector containing cluster labels, to be
matched</p>
</td></tr>
<tr><td><code id="reconcile_clusterings_mapping_+3A_alternative">alternative</code></td>
<td>
<p>Another vector containing cluster labels, to be
changed</p>
</td></tr>
<tr><td><code id="reconcile_clusterings_mapping_+3A_one_to_one">one_to_one</code></td>
<td>
<p>Boolean; should each alt cluster match only one primary
cluster?</p>
</td></tr>
<tr><td><code id="reconcile_clusterings_mapping_+3A_optimize">optimize</code></td>
<td>
<p>One of &quot;accuracy&quot; or &quot;precision&quot;; see description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retains the cluster labels of the primary assignment, and relabel the
alternate assignment to match as closely as possible.  The user must decide
whether clusters are forced to be &quot;one-to-one&quot;; that is, are we allowed to
assign multiple labels from the alternate assignment to the same primary
label?
</p>


<h3>Value</h3>

<p>A tibble with 3 columns; <code>primary</code>, <code>alt</code>, <code>alt_recoded</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
factor1 &lt;- c("Apple", "Apple", "Carrot", "Carrot", "Banana", "Banana")
factor2 &lt;- c("Dog", "Dog", "Cat", "Dog", "Fish", "Fish")
reconcile_clusterings_mapping(factor1, factor2)

factor1 &lt;- c("Apple", "Apple", "Carrot", "Carrot", "Banana", "Banana")
factor2 &lt;- c("Dog", "Dog", "Cat", "Dog", "Fish", "Parrot")
reconcile_clusterings_mapping(factor1, factor2, one_to_one = FALSE)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+fit'></span><span id='topic+tidy'></span><span id='topic+glance'></span><span id='topic+augment'></span><span id='topic+fit_xy'></span><span id='topic+extract_parameter_set_dials'></span><span id='topic+tune'></span><span id='topic+extract_spec_parsnip'></span><span id='topic+extract_fit_engine'></span><span id='topic+min_grid'></span><span id='topic+extract_preprocessor'></span><span id='topic+extract_fit_parsnip'></span><span id='topic+load_pkgs'></span><span id='topic+required_pkgs'></span><span id='topic+predict_raw'></span><span id='topic+set_args'></span><span id='topic+set_engine'></span><span id='topic+set_mode'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+fit">fit</a></code>, <code><a href="generics.html#topic+fit_xy">fit_xy</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+min_grid">min_grid</a></code>, <code><a href="generics.html#topic+required_pkgs">required_pkgs</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>hardhat</dt><dd><p><code><a href="hardhat.html#topic+hardhat-extract">extract_fit_engine</a></code>, <code><a href="hardhat.html#topic+hardhat-extract">extract_fit_parsnip</a></code>, <code><a href="hardhat.html#topic+hardhat-extract">extract_parameter_set_dials</a></code>, <code><a href="hardhat.html#topic+hardhat-extract">extract_preprocessor</a></code>, <code><a href="hardhat.html#topic+hardhat-extract">extract_spec_parsnip</a></code>, <code><a href="hardhat.html#topic+tune">tune</a></code></p>
</dd>
<dt>parsnip</dt><dd><p><code><a href="parsnip.html#topic+predict.model_fit">predict_raw</a></code>, <code><a href="parsnip.html#topic+set_args">set_args</a></code>, <code><a href="parsnip.html#topic+set_engine">set_engine</a></code>, <code><a href="parsnip.html#topic+set_args">set_mode</a></code></p>
</dd>
<dt>tune</dt><dd><p><code><a href="tune.html#topic+load_pkgs">load_pkgs</a></code></p>
</dd>
</dl>

<hr>
<h2 id='set_args.cluster_spec'>Change arguments of a cluster specification</h2><span id='topic+set_args.cluster_spec'></span>

<h3>Description</h3>

<p>Change arguments of a cluster specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
set_args(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_args.cluster_spec_+3A_object">object</code></td>
<td>
<p>A model specification.</p>
</td></tr>
<tr><td><code id="set_args.cluster_spec_+3A_...">...</code></td>
<td>
<p>One or more named model arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.
</p>

<hr>
<h2 id='set_engine.cluster_spec'>Change engine of a cluster specification</h2><span id='topic+set_engine.cluster_spec'></span>

<h3>Description</h3>

<p>Change engine of a cluster specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
set_engine(object, engine, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_engine.cluster_spec_+3A_object">object</code></td>
<td>
<p>A model specification.</p>
</td></tr>
<tr><td><code id="set_engine.cluster_spec_+3A_engine">engine</code></td>
<td>
<p>A character string for the software that should
be used to fit the model. This is highly dependent on the type
of model (e.g. linear regression, random forest, etc.).</p>
</td></tr>
<tr><td><code id="set_engine.cluster_spec_+3A_...">...</code></td>
<td>
<p>Any optional arguments associated with the chosen computational
engine. These are captured as quosures and can be tuned with <code>tune()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.
</p>

<hr>
<h2 id='set_mode.cluster_spec'>Change mode of a cluster specification</h2><span id='topic+set_mode.cluster_spec'></span>

<h3>Description</h3>

<p>Change mode of a cluster specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_spec'
set_mode(object, mode, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_mode.cluster_spec_+3A_object">object</code></td>
<td>
<p>A model specification.</p>
</td></tr>
<tr><td><code id="set_mode.cluster_spec_+3A_mode">mode</code></td>
<td>
<p>A character string for the model type (e.g. &quot;classification&quot; or
&quot;regression&quot;)</p>
</td></tr>
<tr><td><code id="set_mode.cluster_spec_+3A_...">...</code></td>
<td>
<p>One or more named model arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated <code><a href="#topic+cluster_spec">cluster_spec</a></code> object.
</p>

<hr>
<h2 id='silhouette'>Measures silhouette between clusters</h2><span id='topic+silhouette'></span>

<h3>Description</h3>

<p>Measures silhouette between clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette(
  object,
  new_data = NULL,
  dists = NULL,
  dist_fun = philentropy::distance
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silhouette_+3A_object">object</code></td>
<td>
<p>A fitted tidyclust model</p>
</td></tr>
<tr><td><code id="silhouette_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="silhouette_+3A_dists">dists</code></td>
<td>
<p>A distance matrix. Used if <code>new_data</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="silhouette_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances between observations.
Defaults to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+silhouette_avg">silhouette_avg()</a></code> is the corresponding cluster metric function that
returns the average of the values given by <code>silhouette()</code>.
</p>


<h3>Value</h3>

<p>A tibble giving the silhouette for each observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

dists &lt;- mtcars %&gt;%
  as.matrix() %&gt;%
  dist()

silhouette(kmeans_fit, dists = dists)
</code></pre>

<hr>
<h2 id='silhouette_avg'>Measures average silhouette across all observations</h2><span id='topic+silhouette_avg'></span><span id='topic+silhouette_avg.cluster_spec'></span><span id='topic+silhouette_avg.cluster_fit'></span><span id='topic+silhouette_avg.workflow'></span><span id='topic+silhouette_avg_vec'></span>

<h3>Description</h3>

<p>Measures average silhouette across all observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette_avg(object, ...)

## S3 method for class 'cluster_spec'
silhouette_avg(object, ...)

## S3 method for class 'cluster_fit'
silhouette_avg(object, new_data = NULL, dists = NULL, dist_fun = NULL, ...)

## S3 method for class 'workflow'
silhouette_avg(object, new_data = NULL, dists = NULL, dist_fun = NULL, ...)

silhouette_avg_vec(
  object,
  new_data = NULL,
  dists = NULL,
  dist_fun = philentropy::distance,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silhouette_avg_+3A_object">object</code></td>
<td>
<p>A fitted kmeans tidyclust model</p>
</td></tr>
<tr><td><code id="silhouette_avg_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="silhouette_avg_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="silhouette_avg_+3A_dists">dists</code></td>
<td>
<p>A distance matrix. Used if <code>new_data</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="silhouette_avg_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances between observations.
Defaults to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not to be confused with <code><a href="#topic+silhouette">silhouette()</a></code> that returns a tibble
with silhouette for each observation.
</p>


<h3>Value</h3>

<p>A double; the average silhouette.
</p>


<h3>See Also</h3>

<p>Other cluster metric: 
<code><a href="#topic+sse_ratio">sse_ratio</a>()</code>,
<code><a href="#topic+sse_total">sse_total</a>()</code>,
<code><a href="#topic+sse_within_total">sse_within_total</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

dists &lt;- mtcars %&gt;%
  as.matrix() %&gt;%
  dist()

silhouette_avg(kmeans_fit, dists = dists)

silhouette_avg_vec(kmeans_fit, dists = dists)
</code></pre>

<hr>
<h2 id='sse_ratio'>Compute the ratio of the WSS to the total SSE</h2><span id='topic+sse_ratio'></span><span id='topic+sse_ratio.cluster_spec'></span><span id='topic+sse_ratio.cluster_fit'></span><span id='topic+sse_ratio.workflow'></span><span id='topic+sse_ratio_vec'></span>

<h3>Description</h3>

<p>Compute the ratio of the WSS to the total SSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse_ratio(object, ...)

## S3 method for class 'cluster_spec'
sse_ratio(object, ...)

## S3 method for class 'cluster_fit'
sse_ratio(object, new_data = NULL, dist_fun = NULL, ...)

## S3 method for class 'workflow'
sse_ratio(object, new_data = NULL, dist_fun = NULL, ...)

sse_ratio_vec(
  object,
  new_data = NULL,
  dist_fun = function(x, y) {
     philentropy::dist_many_many(x, y, method =
    "euclidean")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sse_ratio_+3A_object">object</code></td>
<td>
<p>A fitted kmeans tidyclust model</p>
</td></tr>
<tr><td><code id="sse_ratio_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="sse_ratio_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="sse_ratio_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances to centroids.  Defaults
to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 3 columns; <code>.metric</code>, <code>.estimator</code>, and <code>.estimate</code>.
</p>


<h3>See Also</h3>

<p>Other cluster metric: 
<code><a href="#topic+silhouette_avg">silhouette_avg</a>()</code>,
<code><a href="#topic+sse_total">sse_total</a>()</code>,
<code><a href="#topic+sse_within_total">sse_within_total</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

sse_ratio(kmeans_fit)

sse_ratio_vec(kmeans_fit)
</code></pre>

<hr>
<h2 id='sse_total'>Compute the total sum of squares</h2><span id='topic+sse_total'></span><span id='topic+sse_total.cluster_spec'></span><span id='topic+sse_total.cluster_fit'></span><span id='topic+sse_total.workflow'></span><span id='topic+sse_total_vec'></span>

<h3>Description</h3>

<p>Compute the total sum of squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse_total(object, ...)

## S3 method for class 'cluster_spec'
sse_total(object, ...)

## S3 method for class 'cluster_fit'
sse_total(object, new_data = NULL, dist_fun = NULL, ...)

## S3 method for class 'workflow'
sse_total(object, new_data = NULL, dist_fun = NULL, ...)

sse_total_vec(
  object,
  new_data = NULL,
  dist_fun = function(x, y) {
     philentropy::dist_many_many(x, y, method =
    "euclidean")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sse_total_+3A_object">object</code></td>
<td>
<p>A fitted kmeans tidyclust model</p>
</td></tr>
<tr><td><code id="sse_total_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="sse_total_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="sse_total_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances to centroids.  Defaults
to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 3 columns; <code>.metric</code>, <code>.estimator</code>, and <code>.estimate</code>.
</p>


<h3>See Also</h3>

<p>Other cluster metric: 
<code><a href="#topic+silhouette_avg">silhouette_avg</a>()</code>,
<code><a href="#topic+sse_ratio">sse_ratio</a>()</code>,
<code><a href="#topic+sse_within_total">sse_within_total</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

sse_total(kmeans_fit)

sse_total_vec(kmeans_fit)
</code></pre>

<hr>
<h2 id='sse_within'>Calculates Sum of Squared Error in each cluster</h2><span id='topic+sse_within'></span>

<h3>Description</h3>

<p>Calculates Sum of Squared Error in each cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse_within(
  object,
  new_data = NULL,
  dist_fun = function(x, y) {
     philentropy::dist_many_many(x, y, method =
    "euclidean")
 }
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sse_within_+3A_object">object</code></td>
<td>
<p>A fitted kmeans tidyclust model</p>
</td></tr>
<tr><td><code id="sse_within_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="sse_within_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances to centroids.  Defaults
to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+sse_within_total">sse_within_total()</a></code> is the corresponding cluster metric function
that returns the sum of the values given by <code>sse_within()</code>.
</p>


<h3>Value</h3>

<p>A tibble with two columns, the cluster name and the SSE within that
cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

sse_within(kmeans_fit)
</code></pre>

<hr>
<h2 id='sse_within_total'>Compute the sum of within-cluster SSE</h2><span id='topic+sse_within_total'></span><span id='topic+sse_within_total.cluster_spec'></span><span id='topic+sse_within_total.cluster_fit'></span><span id='topic+sse_within_total.workflow'></span><span id='topic+sse_within_total_vec'></span>

<h3>Description</h3>

<p>Compute the sum of within-cluster SSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse_within_total(object, ...)

## S3 method for class 'cluster_spec'
sse_within_total(object, ...)

## S3 method for class 'cluster_fit'
sse_within_total(object, new_data = NULL, dist_fun = NULL, ...)

## S3 method for class 'workflow'
sse_within_total(object, new_data = NULL, dist_fun = NULL, ...)

sse_within_total_vec(
  object,
  new_data = NULL,
  dist_fun = function(x, y) {
     philentropy::dist_many_many(x, y, method =
    "euclidean")
 },
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sse_within_total_+3A_object">object</code></td>
<td>
<p>A fitted kmeans tidyclust model</p>
</td></tr>
<tr><td><code id="sse_within_total_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="sse_within_total_+3A_new_data">new_data</code></td>
<td>
<p>A dataset to predict on.  If <code>NULL</code>, uses trained clustering.</p>
</td></tr>
<tr><td><code id="sse_within_total_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A function for calculating distances to centroids. Defaults
to Euclidean distance on processed data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not to be confused with <code><a href="#topic+sse_within">sse_within()</a></code> that returns a tibble
with within-cluster SSE, one row for each cluster.
</p>


<h3>Value</h3>

<p>A tibble with 3 columns; <code>.metric</code>, <code>.estimator</code>, and <code>.estimate</code>.
</p>


<h3>See Also</h3>

<p>Other cluster metric: 
<code><a href="#topic+silhouette_avg">silhouette_avg</a>()</code>,
<code><a href="#topic+sse_ratio">sse_ratio</a>()</code>,
<code><a href="#topic+sse_total">sse_total</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5) %&gt;%
  set_engine("stats")

kmeans_fit &lt;- fit(kmeans_spec, ~., mtcars)

sse_within_total(kmeans_fit)

sse_within_total_vec(kmeans_fit)
</code></pre>

<hr>
<h2 id='tidy.cluster_fit'>Turn a tidyclust model object into a tidy tibble</h2><span id='topic+tidy.cluster_fit'></span>

<h3>Description</h3>

<p>This method tidies the model in a tidyclust model object, if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cluster_fit'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.cluster_fit_+3A_x">x</code></td>
<td>
<p>An object to be converted into a tidy <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.cluster_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments to tidying method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble
</p>

<hr>
<h2 id='translate_tidyclust'>Resolve a Model Specification for a Computational Engine</h2><span id='topic+translate_tidyclust'></span><span id='topic+translate_tidyclust.default'></span>

<h3>Description</h3>

<p><code>translate_tidyclust()</code> will translate_tidyclust a model specification into a
code object that is specific to a particular engine (e.g. R package). It
translate tidyclust generic parameters to their counterparts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_tidyclust(x, ...)

## Default S3 method:
translate_tidyclust(x, engine = x$engine, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_tidyclust_+3A_x">x</code></td>
<td>
<p>A model specification.</p>
</td></tr>
<tr><td><code id="translate_tidyclust_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="translate_tidyclust_+3A_engine">engine</code></td>
<td>
<p>The computational engine for the model (see <code>?set_engine</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>translate_tidyclust()</code> produces a <em>template</em> call that lacks the
specific argument values (such as <code>data</code>, etc). These are filled in once
<code>fit()</code> is called with the specifics of the data for the model. The call
may also include <code>tune()</code> arguments if these are in the specification. To
handle the <code>tune()</code> arguments, you need to use the <a href="https://tune.tidymodels.org/">tune package</a>. For more information see
<a href="https://www.tidymodels.org/start/tuning/">https://www.tidymodels.org/start/tuning/</a>
</p>
<p>It does contain the resolved argument names that are specific to the model
fitting function/engine.
</p>
<p>This function can be useful when you need to understand how <code>tidyclust</code>
goes from a generic model specific to a model fitting function.
</p>
<p><strong>Note</strong>: this function is used internally and users should only use it
to understand what the underlying syntax would be. It should not be used to
modify the cluster specification.
</p>


<h3>Value</h3>

<p>Prints translated code.
</p>

<hr>
<h2 id='tune_cluster'>Model tuning via grid search</h2><span id='topic+tune_cluster'></span><span id='topic+tune_cluster.cluster_spec'></span><span id='topic+tune_cluster.workflow'></span>

<h3>Description</h3>

<p><code><a href="#topic+tune_cluster">tune_cluster()</a></code> computes a set of performance metrics (e.g. accuracy or
RMSE) for a pre-defined set of tuning parameters that correspond to a model
or recipe across one or more resamples of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_cluster(object, ...)

## S3 method for class 'cluster_spec'
tune_cluster(
  object,
  preprocessor,
  resamples,
  ...,
  param_info = NULL,
  grid = 10,
  metrics = NULL,
  control = tune::control_grid()
)

## S3 method for class 'workflow'
tune_cluster(
  object,
  resamples,
  ...,
  param_info = NULL,
  grid = 10,
  metrics = NULL,
  control = tune::control_grid()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tune_cluster_+3A_object">object</code></td>
<td>
<p>A <code>tidyclust</code> model specification or a <code><a href="workflows.html#topic+workflow">workflows::workflow()</a></code>.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_preprocessor">preprocessor</code></td>
<td>
<p>A traditional model formula or a recipe created using
<code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_resamples">resamples</code></td>
<td>
<p>An <code>rset()</code> object.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_param_info">param_info</code></td>
<td>
<p>A <code><a href="dials.html#topic+parameters">dials::parameters()</a></code> object or <code>NULL</code>. If none is given,
a parameters set is derived from other arguments. Passing this argument can
be useful when parameter ranges need to be customized.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_grid">grid</code></td>
<td>
<p>A data frame of tuning combinations or a positive integer. The
data frame should have columns for each parameter being tuned and rows for
tuning parameter candidates. An integer denotes the number of candidate
parameter sets to be created automatically.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_metrics">metrics</code></td>
<td>
<p>A <code><a href="#topic+cluster_metric_set">cluster_metric_set()</a></code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tune_cluster_+3A_control">control</code></td>
<td>
<p>An object used to modify the tuning process. Defaults to
<code>tune::control_grid()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>resamples</code> with extra list columns for
<code>.metrics</code> and <code>.notes</code> (optional columns are <code>.predictions</code> and
<code>.extracts</code>). <code>.notes</code> contains warnings and errors that occur during
execution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(rsample)
library(workflows)
library(tune)

rec_spec &lt;- recipe(~., data = mtcars) %&gt;%
  step_normalize(all_numeric_predictors()) %&gt;%
  step_pca(all_numeric_predictors())

kmeans_spec &lt;- k_means(num_clusters = tune())

wflow &lt;- workflow() %&gt;%
  add_recipe(rec_spec) %&gt;%
  add_model(kmeans_spec)

grid &lt;- tibble(num_clusters = 1:3)

set.seed(4400)
folds &lt;- vfold_cv(mtcars, v = 2)

res &lt;- tune_cluster(
  wflow,
  resamples = folds,
  grid = grid
)
res

collect_metrics(res)
</code></pre>

<hr>
<h2 id='update.hier_clust'>Update a cluster specification</h2><span id='topic+update.hier_clust'></span><span id='topic+update.k_means'></span><span id='topic+tidyclust_update'></span>

<h3>Description</h3>

<p>If parameters of a cluster specification need to be modified,
<code>update()</code> can be used in lieu of recreating the object from scratch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hier_clust'
update(
  object,
  parameters = NULL,
  num_clusters = NULL,
  cut_height = NULL,
  linkage_method = NULL,
  fresh = FALSE,
  ...
)

## S3 method for class 'k_means'
update(object, parameters = NULL, num_clusters = NULL, fresh = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.hier_clust_+3A_object">object</code></td>
<td>
<p>A cluster specification.</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_parameters">parameters</code></td>
<td>
<p>A 1-row tibble or named list with <em>main</em> parameters to
update. Use <strong>either</strong> <code>parameters</code> <strong>or</strong> the main arguments directly when
updating. If the main arguments are used, these will supersede the values
in <code>parameters</code>. Also, using engine arguments in this object will result in
an error.</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Positive integer, number of clusters in model.</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_cut_height">cut_height</code></td>
<td>
<p>Positive double, height at which to cut dendrogram to
obtain cluster assignments (only used if <code>num_clusters</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_linkage_method">linkage_method</code></td>
<td>
<p>the agglomeration method to be used. This should be (an
unambiguous abbreviation of) one of <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>,
<code>"complete"</code>, <code>"average"</code> (= UPGMA), <code>"mcquitty"</code> (= WPGMA), <code>"median"</code> (=
WPGMC) or <code>"centroid"</code> (= UPGMC).</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_fresh">fresh</code></td>
<td>
<p>A logical for whether the arguments should be modified in-place
or replaced wholesale.</p>
</td></tr>
<tr><td><code id="update.hier_clust_+3A_...">...</code></td>
<td>
<p>Not used for <code>update()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated cluster specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_spec &lt;- k_means(num_clusters = 5)
kmeans_spec
update(kmeans_spec, num_clusters = 1)
update(kmeans_spec, num_clusters = 1, fresh = TRUE)

param_values &lt;- tibble::tibble(num_clusters = 10)

kmeans_spec %&gt;% update(param_values)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
