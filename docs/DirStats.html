<!DOCTYPE html><html><head><title>Help for package DirStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DirStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bic_vmf_mix'><p>Fitting mixtures of von Mises&ndash;Fisher distributions</p></a></li>
<li><a href='#bw_dir_cv'><p>Cross-validation bandwidth selectors for directional data</p></a></li>
<li><a href='#bw_dir_pi'><p>Plug-in bandwidth selectors for directional data</p></a></li>
<li><a href='#conv'><p>Convenience functions</p></a></li>
<li><a href='#DirStats-package'><p><code>DirStats</code> &ndash; Nonparametric Methods for Directional Data</p></a></li>
<li><a href='#int'><p>Integration routines</p></a></li>
<li><a href='#kde_dir'><p>Directional kernel density estimator</p></a></li>
<li><a href='#lebedev'><p>Lebedev quadrature on the sphere</p></a></li>
<li><a href='#vmf'><p>Von Mises&ndash;Fisher distribution utilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Methods for Directional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric kernel density estimation, bandwidth selection,
    and other utilities for analyzing directional data. Implements the estimator
    in Bai, Rao and Zhao (1987) &lt;<a href="https://doi.org/10.1016%2F0047-259X%2888%2990113-3">doi:10.1016/0047-259X(88)90113-3</a>&gt;, the
    cross-validation bandwidth selectors in Hall, Watson and Cabrera (1987)
    &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F74.4.751">doi:10.1093/biomet/74.4.751</a>&gt; and the plug-in bandwidth selectors in
    García-Portugués (2013) &lt;<a href="https://doi.org/10.1214%2F13-ejs821">doi:10.1214/13-ejs821</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>movMF, rotasym</td>
</tr>
<tr>
<td>Suggests:</td>
<td>viridisLite</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/DirStats">https://github.com/egarpor/DirStats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/DirStats">https://github.com/egarpor/DirStats</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 20:57:56 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-16 22:04:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='bic_vmf_mix'>Fitting mixtures of von Mises&ndash;Fisher distributions</h2><span id='topic+bic_vmf_mix'></span>

<h3>Description</h3>

<p>Fitting mixtures of von Mises&ndash;Fisher distributions by the
Expectation-Maximization algorithm, with determination of the optimal
number of mixture components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bic_vmf_mix(data, M_bound = ceiling(log(nrow(data))), M_neig = 3,
  crit = "BIC", iterative = TRUE, plot_it = FALSE, verbose = FALSE,
  kappa_max = 250)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bic_vmf_mix_+3A_data">data</code></td>
<td>
<p>directional data, a matrix of size <code>c(n, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_m_bound">M_bound</code></td>
<td>
<p>bound for the number of components in the mixtures. If it is
not enough, the search for the mixture with minimum <code>crit</code> will
continue from <code>M_bound + 1</code> if <code>iterative = TRUE</code>. Defaults to
<code>ceiling(log(nrow(data)))</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_m_neig">M_neig</code></td>
<td>
<p>number of neighbors explored around the optimal number
of mixture components. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_crit">crit</code></td>
<td>
<p>information criterion employed, either <code>"BIC"</code> (default),
<code>"AICc"</code> or <code>"AIC"</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_iterative">iterative</code></td>
<td>
<p>keep exploring higher number of components if the optimum
is attained at <code>M_bound</code>? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_plot_it">plot_it</code></td>
<td>
<p>display an informative plot on the optimization's grid search?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_verbose">verbose</code></td>
<td>
<p>display fitting progress? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bic_vmf_mix_+3A_kappa_max">kappa_max</code></td>
<td>
<p>maximum value of allowed concentrations, to avoid numerical
instabilities. Defaults to <code>250</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Algorithm 3 in García-Portugués (2013). The Expectation-Maximization
fit is performed with <code><a href="movMF.html#topic+movMF">movMF</a></code>.
</p>


<h3>Value</h3>

<p>A list with entries:
</p>

<ul>
<li><p><code>best_fit</code>: a list with estimated mixture parameters
<code>mu_hat</code>, <code>kappa_hat</code>, and <code>p_hat</code> of the best-fitting
mixture according to <code>crit</code>.
</p>
</li>
<li><p><code>fit_mixs</code>: a list with of the fitted mixtures.
</p>
</li>
<li><p><code>BICs</code>: a vector with the BICs (or other information criterion)
of the fitted mixtures.
</p>
</li></ul>



<h3>References</h3>

<p>García-Portugués, E. (2013). Exact risk improvement of bandwidth selectors
for kernel density estimation with directional data. <em>Electronic
Journal of Statistics</em>, 7:1655&ndash;1685.
<a href="https://doi.org/10.1214/13-ejs821">doi:10.1214/13-ejs821</a>
</p>
<p>Hornik, K. and Grün, B. (2014). movMF: An R Package for Fitting Mixtures of
von Mises&ndash;Fisher Distributions. <em>Journal of Statistical Software</em>,
58(10):1&ndash;31. <a href="https://doi.org/10.18637/jss.v058.i10">doi:10.18637/jss.v058.i10</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample
q &lt;- 2
n &lt;- 300
set.seed(42)
samp &lt;- rbind(rotasym::r_vMF(n = n / 3, mu = c(rep(0, q), 1), kappa = 5),
              rotasym::r_vMF(n = n / 3, mu = c(rep(0, q), -1), kappa = 5),
              rotasym::r_vMF(n = n / 3, mu = c(1, rep(0, q)), kappa = 5))

# Mixture fit
bic_vmf_mix(data = samp, plot_it = TRUE, verbose = TRUE)
</code></pre>

<hr>
<h2 id='bw_dir_cv'>Cross-validation bandwidth selectors for directional data</h2><span id='topic+bw_dir_cv'></span><span id='topic+bw_dir_lcv'></span><span id='topic+bw_dir_lscv'></span>

<h3>Description</h3>

<p>Likelihood and least squares cross-validation bandwidth
selectors for kernel density estimation with directional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_dir_lcv(data, h_grid = exp(seq(log(0.05), log(1.5), l = 100)), L = NULL,
  plot_it = FALSE, optim = TRUE, optim_par = 0.25, optim_lower = 0.06,
  optim_upper = 10)

bw_dir_lscv(data, h_grid = exp(seq(log(0.05), log(1.5), l = 100)),
  L = NULL, plot_it = FALSE, optim = TRUE, R_code = FALSE,
  optim_par = 0.25, optim_lower = 0.06, optim_upper = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_dir_cv_+3A_data">data</code></td>
<td>
<p>directional data, a matrix of size <code>c(n, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_h_grid">h_grid</code></td>
<td>
<p>vector of bandwidths for performing a grid search. Defaults
to<br /> <code>exp(seq(log(0.05), log(1.5), l = 100))</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_l">L</code></td>
<td>
<p>kernel function. Set internally to <code>function(x) exp(-x)</code>
(von Mises&ndash;Fisher kernel) if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_plot_it">plot_it</code></td>
<td>
<p>display an informative plot on the optimization's grid search?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_optim">optim</code></td>
<td>
<p>run an optimization? Defaults to <code>TRUE</code>. Otherwise,
a grid search on <code>h</code> is done. Only effective if <code>L = NULL</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_optim_par">optim_par</code>, <code id="bw_dir_cv_+3A_optim_lower">optim_lower</code>, <code id="bw_dir_cv_+3A_optim_upper">optim_upper</code></td>
<td>
<p>parameters passed to <code>par</code>,
<code>lower</code>, and <code>upper</code> in <code><a href="stats.html#topic+optim">optim</a></code> when using
the <code>"L-BFGS-B"</code> method. Default to <code>0.25</code>, <code>0.06</code>
(to avoid numerical instabilities), and <code>10</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_cv_+3A_r_code">R_code</code></td>
<td>
<p>use slower R code when <code>L = NULL</code>? Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> is not checked to have unit norm, so the user must be careful.
When <code>L = NULL</code>, faster FORTRAN code is employed.
</p>
<p><code>bw_dir_lscv</code> employs Monte Carlo integration for <code class="reqn">q &gt; 2</code>, which
results in a random output. Use <code>set.seed</code> before to avoid it.
</p>


<h3>Value</h3>

<p>A list with entries:
</p>

<ul>
<li><p><code>h_opt</code>: selected bandwidth.
</p>
</li>
<li><p><code>h_grid</code>: <code>h_grid</code>, if used (otherwise <code>NULL</code>).
</p>
</li>
<li><p><code>CV_opt</code>: minimum of the CV loss.
</p>
</li>
<li><p><code>CV_grid</code>: value of the CV function at <code>h_grid</code>, if used
(otherwise <code>NULL</code>).
</p>
</li></ul>



<h3>Source</h3>

<p>The function <code>bw_dir_lscv</code> employs Netlib's subroutine
<a href="https://www.netlib.org/specfun/ribesl"><code>ribesl</code></a> for evaluating
the modified Bessel function of the first kind. The subroutine is based
on a program by Sookne (1973) and was modified by W. J. Cody and L. Stoltz.
An earlier version was published in Cody (1983).
</p>


<h3>References</h3>

<p>Cody, W. J. (1983). Algorithm 597: Sequence of modified Bessel functions of
the first kind. <em>ACM Transactions on Mathematical Software</em>,
9(2):242&ndash;245. <a href="https://doi.org/10.1145/357456.357462">doi:10.1145/357456.357462</a>
</p>
<p>Hall, P., Watson, G. S., and Cabrera, J. (1987). Kernel density estimation
with spherical data. <em>Biometrika</em>, 74(4):751&ndash;762.
<a href="https://doi.org/10.1093/biomet/74.4.751">doi:10.1093/biomet/74.4.751</a>
</p>
<p>Sookne, D. J. (1973). Bessel functions of real argument and integer order.
<em>Journal of Research of the National Bureau of Standards</em>,
77B:125&ndash;132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample
n &lt;- 25
q &lt;- 2
set.seed(42)
samp &lt;- rotasym::r_vMF(n = n, mu = c(1, rep(0, q)), kappa = 2)

# bw_dir_lcv
bw_dir_lcv(data = samp, optim = TRUE)$h_opt
bw_dir_lcv(data = samp, optim = FALSE, plot_it = TRUE)$h_opt
bw_dir_lcv(data = samp, L = function(x) exp(-x))$h_opt

# bw_dir_lscv
set.seed(42)
bw_dir_lscv(data = samp, optim = TRUE)$h_opt
bw_dir_lscv(data = samp, optim = FALSE, plot_it = TRUE)$h_opt
bw_dir_lscv(data = samp, optim = FALSE, R_code = TRUE)$h_opt
bw_dir_lscv(data = samp, L = function(x) exp(-x))$h_opt
</code></pre>

<hr>
<h2 id='bw_dir_pi'>Plug-in bandwidth selectors for directional data</h2><span id='topic+bw_dir_pi'></span><span id='topic+bw_dir_rot'></span><span id='topic+bw_dir_ami'></span><span id='topic+R_Psi_mixvmf'></span><span id='topic+bw_dir_emi'></span>

<h3>Description</h3>

<p>Plug-in bandwidth selectors for kernel density estimation
with directional data, including Rule-Of-Thumb (ROT),
Asymptotic MIxtures (AMI), and Exact MIxtures (EMI).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_dir_rot(data)

bw_dir_ami(data, fit_mix = NULL, L = NULL)

R_Psi_mixvmf(q, mu, kappa, p)

bw_dir_emi(data, fit_mix = NULL, optim = TRUE,
  h_grid = exp(seq(log(0.05), log(1.5), l = 100)), plot_it = TRUE,
  optim_par = 0.25, optim_lower = 0.06, optim_upper = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_dir_pi_+3A_data">data</code></td>
<td>
<p>directional data, a matrix of size <code>c(n, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_fit_mix">fit_mix</code></td>
<td>
<p>output from <code><a href="#topic+bic_vmf_mix">bic_vmf_mix</a></code>. Computed internally
if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_l">L</code></td>
<td>
<p>kernel function. Set internally to <code>function(x) exp(-x)</code>
(von Mises&ndash;Fisher kernel) if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_q">q</code></td>
<td>
<p>dimension of <code class="reqn">S^q</code>, <code class="reqn">q\ge 1</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_mu">mu</code>, <code id="bw_dir_pi_+3A_kappa">kappa</code>, <code id="bw_dir_pi_+3A_p">p</code></td>
<td>
<p>mixture parameters. <code>mu</code> is the mean matrix of size
<code>c(length(p), q + 1)</code>, <code>kappa</code> is vector of <code>length(p)</code>
concentration parameters, and <code>p</code> is the vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_optim">optim</code></td>
<td>
<p>run an optimization? Defaults to <code>TRUE</code>. Otherwise,
a grid search on <code>h</code> is done. Only effective if <code>L = NULL</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_h_grid">h_grid</code></td>
<td>
<p>vector of bandwidths for performing a grid search. Defaults
to<br /> <code>exp(seq(log(0.05), log(1.5), l = 100))</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_plot_it">plot_it</code></td>
<td>
<p>display an informative plot on the optimization's grid search?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bw_dir_pi_+3A_optim_par">optim_par</code>, <code id="bw_dir_pi_+3A_optim_lower">optim_lower</code>, <code id="bw_dir_pi_+3A_optim_upper">optim_upper</code></td>
<td>
<p>parameters passed to <code>par</code>,
<code>lower</code>, and <code>upper</code> in <code><a href="stats.html#topic+optim">optim</a></code> when using
the <code>"L-BFGS-B"</code> method. Default to <code>0.25</code>, <code>0.06</code>
(to avoid numerical instabilities), and <code>10</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Algorithms 1 (AMI) and 2 (EMI) in García-Portugués (2013). The ROT
selector is implemented according to Proposition 2, <b>but</b> without
the paper's typo in equation (6), case <code class="reqn">q = 2</code>, where an incorrect
extra <code class="reqn">\hat\kappa</code> appears premultiplying
<code class="reqn">(1 + 4 \hat\kappa^2) \sinh(2 \hat\kappa)</code> in the denominator.
</p>
<p><code>bw_dir_ami</code> uses <code>R_Psi_mixvmf</code> for computing the curvature
term of a mixture of von Mises&ndash;Fisher densities.
</p>
<p><code>bw_dir_emi</code> employs Monte Carlo integration for <code class="reqn">q &gt; 2</code>, which
results in a random output. Use <code>set.seed</code> before to avoid it.
</p>


<h3>Value</h3>

<p>Selected bandwidth for <code>bw_dir_rot</code> and <code>bw_dir_ami</code>.
<code>bw_dir_emi</code> returns a list with entries:
</p>

<ul>
<li><p><code>h_opt</code>: selected bandwidth.
</p>
</li>
<li><p><code>h_grid</code>: <code>h_grid</code>, if used (otherwise <code>NULL</code>).
</p>
</li>
<li><p><code>MISE_opt</code>: minimum of the MISE loss.
</p>
</li>
<li><p><code>MISE_grid</code>: value of the MISE function at <code>h_grid</code>, if
used (otherwise <code>NULL</code>).
</p>
</li></ul>



<h3>References</h3>

<p>García-Portugués, E. (2013). Exact risk improvement of bandwidth selectors
for kernel density estimation with directional data. <em>Electronic
Journal of Statistics</em>, 7:1655&ndash;1685.
<a href="https://doi.org/10.1214/13-ejs821">doi:10.1214/13-ejs821</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample
n &lt;- 25
q &lt;- 2
set.seed(42)
samp &lt;- rotasym::r_vMF(n = n, mu = c(1, rep(0, q)), kappa = 2)

# Mixture fit
fit_mix &lt;- bic_vmf_mix(data = samp, plot_it = TRUE)

# ROT
bw_dir_rot(samp)

# AMI
bw_dir_ami(samp)
bw_dir_ami(samp, fit_mix = fit_mix)
bw_dir_ami(samp, fit_mix = fit_mix, L = function(x) exp(-x))

# EMI
bw_dir_emi(samp)
bw_dir_emi(samp, fit_mix = fit_mix, optim = FALSE, plot_it = TRUE)
</code></pre>

<hr>
<h2 id='conv'>Convenience functions</h2><span id='topic+conv'></span><span id='topic+norm2'></span><span id='topic+normalize'></span><span id='topic+to_cir'></span><span id='topic+to_rad'></span><span id='topic+to_sph'></span>

<h3>Description</h3>

<p>Normalization of data in <code class="reqn">R^{q + 1}</code> to <code class="reqn">S^q</code>.
Transformations between <code class="reqn">S^1</code> and <code class="reqn">[0, 2\pi)</code>, and between
<code class="reqn">S^2</code> and <code class="reqn">[0, 2\pi) \times [0, \pi]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(x)

normalize(x)

to_cir(th)

to_rad(x)

to_sph(th, ph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_x">x</code></td>
<td>
<p>matrix or vector, in <code class="reqn">S^1</code> for <code>to_cir</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_th">th</code></td>
<td>
<p>vector of angles in <code class="reqn">[0, 2\pi)</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_ph">ph</code></td>
<td>
<p>vector of angles in <code class="reqn">[0, \pi]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean norm (<code>norm</code>) and normalized data (<code>normalize</code>).
Position in <code class="reqn">S^1</code> (<code>to_cir</code>) or in <code class="reqn">[0, 2\pi)</code> (<code>to_rad</code>).
Position in <code class="reqn">S^2</code> (<code>to_sph</code>) or in <code class="reqn">[0, 2\pi) \times [0, \pi]</code>
(<code>to_rad</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normalization
x &lt;- 1:3
norm2(x)
normalize(x)
x &lt;- rbind(1:3, 3:1)
norm2(x)
normalize(x)

# Circular transformations
th &lt;- 1
x &lt;- c(0, 1)
to_rad(to_cir(th))
to_rad(to_cir(c(th, th + 1)))
to_cir(to_rad(x))
to_cir(to_rad(rbind(x, -x)))

# Spherical transformations
th &lt;- 2
ph &lt;- 1
x &lt;- c(0, 1, 0)
to_rad(to_sph(th, ph))
to_rad(to_sph(c(th, th + 1),
              c(ph, ph + 1)))
to_sph(to_rad(x)[, 1], to_rad(x)[, 2])
to_sph(to_rad(rbind(x, -x))[, 1], to_rad(rbind(x, -x))[, 2])
</code></pre>

<hr>
<h2 id='DirStats-package'><code>DirStats</code> &ndash; Nonparametric Methods for Directional Data</h2><span id='topic+DirStats-package'></span><span id='topic+DirStats'></span>

<h3>Description</h3>

<p>Nonparametric kernel density estimation, bandwidth selection,
and other utilities for analyzing directional data. Implements the estimator
in Bai, Rao and Zhao (1987) &lt;doi:10.1016/0047-259X(88)90113-3&gt;, the
cross-validation bandwidth selectors in Hall, Watson and Cabrera (1987)
&lt;doi:10.1093/biomet/74.4.751&gt; and the plug-in bandwidth selectors in
García-Portugués (2013) &lt;doi:10.1214/13-ejs821&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>

<hr>
<h2 id='int'>Integration routines</h2><span id='topic+int'></span><span id='topic+int_cir'></span><span id='topic+int_sph'></span><span id='topic+int_hypsph'></span>

<h3>Description</h3>

<p>Several quadrature rules for integration of functions on
<code class="reqn">S^1</code>, <code class="reqn">S^2</code>, and <code class="reqn">S^q</code>, <code class="reqn">q \ge 3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_cir(f, N = 500, na.rm = TRUE, f_vect = TRUE, ...)

int_sph(f, na.rm = TRUE, f_vect = TRUE, ...)

int_hypsph(f, q, M = 1e+05, na.rm = TRUE, f_vect = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_+3A_f">f</code></td>
<td>
<p>function to be integrated on <code class="reqn">S^q</code>. Must be vectorized and
accept matrix inputs of size <code>c(nx, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_n">N</code></td>
<td>
<p>Defaults to <code>5e2</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore possible <code>NA</code>s arising from the evaluation of
<code>f</code>? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_f_vect">f_vect</code></td>
<td>
<p>can <code>f</code> be called in a vectorized form, with matrix
input? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_q">q</code></td>
<td>
<p>dimension of <code class="reqn">S^q</code>, <code class="reqn">q\ge 1</code>.</p>
</td></tr>
<tr><td><code id="int_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replicates. Defaults to <code>1e5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>int_cir</code> is an extension of equation (4.1.11) in Press et al. (1997),
a periodic trapezoidal rule. <code>int_sph</code> employs the
<a href="#topic+lebedev">Lebedev quadrature</a> on <code class="reqn">S^2</code>. <code>int_hypsph</code>
implements a Monte Carlo integration on <code class="reqn">S^q</code>.
</p>


<h3>Value</h3>

<p>A scalar approximating the integral.
</p>


<h3>References</h3>

<p>Lebedev, V. I. and Laikov, D. N. (1999). A quadrature formula for the
sphere of the 131st algebraic order of accuracy. <em>Doklady Mathematics</em>,
59(3):477&ndash;481.
</p>
<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T. and Flannery B. P. (1997).
<em>Numerical Recipes in Fortran 77: The Art of Scientific Computing</em>.
Volume 1. Cambridge University Press, Cambridge. Second edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># S^1, trapezoidal rule
f &lt;- function(x) rotasym::d_vMF(x = x, mu = c(0, 1), kappa = 2)
int_cir(f = f)

# S^2, Lebedev rule
f &lt;- function(x) rotasym::d_vMF(x = x, mu = c(0, 0, 1), kappa = 2)
int_sph(f = f)

# S^2, Monte Carlo
f &lt;- function(x) rotasym::d_vMF(x = x, mu = c(0, 0, 1), kappa = 2)
int_hypsph(f = f, q = 2)
</code></pre>

<hr>
<h2 id='kde_dir'>Directional kernel density estimator</h2><span id='topic+kde_dir'></span><span id='topic+c_h'></span><span id='topic+lambda_L'></span><span id='topic+b_L'></span><span id='topic+d_L'></span>

<h3>Description</h3>

<p>Kernel density estimation with directional data as in
the estimator of Bai et al. (1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde_dir(x, data, h, L = NULL)

c_h(h, q, L = NULL)

lambda_L(L = NULL, q)

b_L(L = NULL, q)

d_L(L = NULL, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde_dir_+3A_x">x</code></td>
<td>
<p>evaluation points, a matrix of size <code>c(nx, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="kde_dir_+3A_data">data</code></td>
<td>
<p>directional data, a matrix of size <code>c(n, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="kde_dir_+3A_h">h</code></td>
<td>
<p>bandwidth, a scalar for <code>kde_dir</code>. Can be a vector
for <code>c_h</code>.</p>
</td></tr>
<tr><td><code id="kde_dir_+3A_l">L</code></td>
<td>
<p>kernel function. Set internally to <code>function(x) exp(-x)</code>
(von Mises&ndash;Fisher kernel) if <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="kde_dir_+3A_q">q</code></td>
<td>
<p>dimension of <code class="reqn">S^q</code>, <code class="reqn">q\ge 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> is not checked to have unit norm, so the user must be careful.
When <code>L = NULL</code>, faster FORTRAN code is employed.
</p>


<h3>Value</h3>

<p><code>kde_dir</code> returns a vector of size <code>nx</code> with the
evaluated kernel density estimator. <code>c_h</code> returns the normalizing
constant for the kernel, a vector of length <code>length(h)</code>.
<code>lambda_L</code>, <code>b_L</code>, and <code>d_L</code> return moments of <code>L</code>.
</p>


<h3>References</h3>

<p>Bai, Z. D., Rao, C. R., and Zhao, L. C. (1988). Kernel estimators of
density function of directional data. <em>Journal of Multivariate
Analysis</em>, 27(1):24&ndash;39.
<a href="https://doi.org/10.1016/0047-259X%2888%2990113-3">doi:10.1016/0047-259X(88)90113-3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample
n &lt;- 50
q &lt;- 3
samp &lt;- rotasym::r_vMF(n = n, mu = c(1, rep(0, q)), kappa = 2)

# Evaluation points
x &lt;- rbind(diag(1, nrow = q + 1), diag(-1, nrow = q + 1))

# kde_dir
kde_dir(x = x, data = samp, h = 0.5, L = NULL)
kde_dir(x = x, data = samp, h = 0.5, L = function(x) exp(-x))

# c_h
c_h(h = 0.5, q = q, L = NULL)
c_h(h = 0.5, q = q, L = function(x) exp(-x))

# b_L
b_L(L = NULL, q = q)
b_L(L = function(x) exp(-x), q = q)

# d_L
d_L(L = NULL, q = q)
d_L(L = function(x) exp(-x), q = q)

# lambda_L
lambda_L(L = NULL, q = q)
lambda_L(L = function(x) exp(-x), q = q)
</code></pre>

<hr>
<h2 id='lebedev'>Lebedev quadrature on the sphere</h2><span id='topic+lebedev'></span>

<h3>Description</h3>

<p>Nodes and weights for Lebedev quadrature on the sphere
<code class="reqn">S^2</code>. The rule has 5810 points and is exact up to polynomials
of order 131.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lebedev
</code></pre>


<h3>Format</h3>

<p>A data frame with 5810 rows and two variables:
</p>

<dl>
<dt>xyz</dt><dd><p>nodes for quadrature, a matrix with three columns.</p>
</dd>
<dt>w</dt><dd><p>weights for quadrature, a vector.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The approximation to the integral of <code class="reqn">f</code> has the form
</p>
<p style="text-align: center;"><code class="reqn">\int_{S^2} f(x, y, z) \,\mathrm{d}x \,\mathrm{d}y \,\mathrm{d}z =
4 \pi \sum_{i = 1}^N w_i f(x_i, y_i, z_i)</code>
</p>

<p>where <code class="reqn">N = 5810</code>. The nodes (in spherical coordinates) and weights
are processed from
<a href="https://people.sc.fsu.edu/~jburkardt/datasets/sphere_lebedev_rule/lebedev_131.txt">lebedev_131.txt</a>.
</p>


<h3>Source</h3>

<p><a href="https://people.sc.fsu.edu/~jburkardt/datasets/sphere_lebedev_rule/sphere_lebedev_rule.html">https://people.sc.fsu.edu/~jburkardt/datasets/sphere_lebedev_rule/sphere_lebedev_rule.html</a>
</p>


<h3>References</h3>

<p>Lebedev, V. I. and Laikov, D. N. (1999). A quadrature formula for the
sphere of the 131st algebraic order of accuracy. <em>Doklady Mathematics</em>,
59(3):477&ndash;481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("lebedev")

# Integrate x_1 * x_2^2 (zero integral)
f_1 &lt;- function(x) x[, 1] * x[, 2]^2
4 * pi * sum(lebedev$w * f_1(lebedev$xyz))
</code></pre>

<hr>
<h2 id='vmf'>Von Mises&ndash;Fisher distribution utilities</h2><span id='topic+vmf'></span><span id='topic+kappa_ml'></span><span id='topic+mu_ml'></span><span id='topic+d_mixvmf'></span>

<h3>Description</h3>

<p>Maximum likelihood estimation for the von Mises&ndash;Fisher
distribution and evaluation of density mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_ml(data, min_kappa = 1e-04, max_kappa = 100, ...)

mu_ml(data)

d_mixvmf(x, mu, kappa, p, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmf_+3A_data">data</code></td>
<td>
<p>directional data, a matrix of size <code>c(n, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="vmf_+3A_min_kappa">min_kappa</code>, <code id="vmf_+3A_max_kappa">max_kappa</code></td>
<td>
<p>minimum and maximum kappas to look for the maximum
likelihood estimate.</p>
</td></tr>
<tr><td><code id="vmf_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="vmf_+3A_x">x</code></td>
<td>
<p>evaluation points, a matrix of size <code>c(nx, q + 1)</code>.</p>
</td></tr>
<tr><td><code id="vmf_+3A_mu">mu</code>, <code id="vmf_+3A_kappa">kappa</code>, <code id="vmf_+3A_p">p</code></td>
<td>
<p>mixture parameters. <code>mu</code> is the mean matrix of size
<code>c(length(p), q + 1)</code>, <code>kappa</code> is vector of <code>length(p)</code>
concentration parameters, and <code>p</code> is the vector of mixture proportions.</p>
</td></tr>
<tr><td><code id="vmf_+3A_norm">norm</code></td>
<td>
<p>enforce normalization of <code>x</code> internally? Defaults
to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated vector mean (<code>mu_ml</code>) or concentration parameter
(<code>kappa_ml</code>). A vector of length <code>nx</code> for <code>d_mixvmf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample
n &lt;- 50
q &lt;- 2
samp &lt;- rotasym::r_vMF(n = n, mu = c(1, rep(0, q)), kappa = 2)

# Estimates
mu_ml(samp)
kappa_ml(samp)

# Mixture
x &lt;- to_cir(seq(0, 2 * pi, l = 200))
dens &lt;- d_mixvmf(x = x, mu = rbind(c(-1, 0), c(0, 1), c(1, 0)),
                 kappa = 1:3, p = c(0.5, 0.2, 0.3))
plot(to_rad(x), dens, type = "l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
