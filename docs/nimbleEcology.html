<!DOCTYPE html><html><head><title>Help for package nimbleEcology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimbleEcology}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dBetaBinom'><p>A beta binomial distribution and beta function for use in <code>nimble</code> models</p></a></li>
<li><a href='#dCJS'><p>Cormack-Jolly-Seber distribution for use in <code>nimble</code> models</p></a></li>
<li><a href='#dDHMM'><p>Dynamic Hidden Markov Model distribution for use in <code>nimble</code> models</p></a></li>
<li><a href='#dDynOcc'><p>Dynamic occupancy distribution for use in <code>nimble</code> models</p>
<code>dDynOcc_**</code> and <code>rDynOcc_**</code> provide dynamic occupancy
model distributions that can be used directly from R or in <code>nimble</code>
models.</a></li>
<li><a href='#dHMM'><p>Hidden Markov Model distribution for use in <code>nimble</code> models</p></a></li>
<li><a href='#dNmixture'><p>dNmixture distribution for use in <code>nimble</code> models</p></a></li>
<li><a href='#dNmixture_steps'><p>Internal helper nimbleFunctions for dNmixture distributions</p></a></li>
<li><a href='#dNmixtureAD'><p>N-mixture distributions with AD support for use in <code>nimble</code> models</p></a></li>
<li><a href='#dOcc'><p>Occupancy distribution suitable for use in <code>nimble</code> models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distributions for Ecological Models in 'nimble'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin R. Goldstein &lt;bgoldst2@ncsu.edu&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Common ecological distributions for 'nimble' models in the form of nimbleFunction objects. 
  Includes Cormack-Jolly-Seber, occupancy, dynamic occupancy, hidden Markov, dynamic hidden Markov, and N-mixture models.
  (Jolly (1965) &lt;<a href="https://doi.org/10.2307%2F2333826">doi:10.2307/2333826</a>&gt;, Seber (1965) &lt;<a href="https://doi.org/10.2307%2F2333827">doi:10.2307/2333827</a>&gt;, Turek et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs10651-016-0353-z">doi:10.1007/s10651-016-0353-z</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Copyright (c) 2024, Perry de Valpine, Ben Goldstein, Daniel
Turek, Lauren Ponisio</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), nimble</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nimble-dev/nimbleEcology">https://github.com/nimble-dev/nimbleEcology</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>utils.R dBetaBinom.R dCJS.R dDynOcc.R dDHMM.R dHMM.R dOcc.R
dNmixture.R dNmixtureAD.R zzz.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 00:06:32 UTC; dochv</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin R. Goldstein [aut, cre],
  Daniel Turek [aut],
  Lauren Ponisio [aut],
  Wei Zhang [ctb],
  Perry de Valpine [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-27 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dBetaBinom'>A beta binomial distribution and beta function for use in <code>nimble</code> models</h2><span id='topic+dBetaBinom'></span><span id='topic+nimBetaFun'></span><span id='topic+dBetaBinom_v'></span><span id='topic+dBetaBinom_s'></span><span id='topic+rBetaBinom_v'></span><span id='topic+rBetaBinom_s'></span>

<h3>Description</h3>

<p><code>dBetaBinom_v</code> and <code>dBetaBinom_s</code> provide a beta binomial
distribution that can be used directly from R or in <code>nimble</code>
models. These are also used by beta binomial variations of dNmixture distributions.
<code>nimBetaFun</code> is the beta function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimBetaFun(a, b, log)

dBetaBinom_v(x, N, shape1, shape2, len, log = 0)

dBetaBinom_s(x, N, shape1, shape2, len, log = 0)

rBetaBinom_v(n, N, shape1, shape2, len)

rBetaBinom_s(n, N, shape1, shape2, len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dBetaBinom_+3A_a">a</code></td>
<td>
<p>shape1 argument of the beta function.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_b">b</code></td>
<td>
<p>shape2 argument of the beta function.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to return
probability.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_x">x</code></td>
<td>
<p>vector of integer counts.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_n">N</code></td>
<td>
<p>number of trials, sometimes called &quot;size&quot;.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_shape1">shape1</code></td>
<td>
<p>shape1 parameter of the beta distribution.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_shape2">shape2</code></td>
<td>
<p>shape2 parameter of the beta distribution.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_len">len</code></td>
<td>
<p>length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="dBetaBinom_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the argument
exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used
directly in R or in <code>nimble</code> hierarchical models (via
<code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code> and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
They are used by the beta-binomial variants of the N-mixture distributions
(<code><a href="#topic+dNmixture">dNmixture</a></code>).
</p>
<p>The beta binomial is the marginal distribution of a  binomial distribution whose
probability follows a  beta distribution.
</p>
<p>The probability mass function of the beta binomial is
<code>choose(N, x) * B(x + shape1, N - x + shape2) /
B(shape1, shape2)</code>, where <code>B(shape1, shape2)</code> is the beta function.
</p>
<p><code>nimBetaFun(shape1, shape2)</code> calculates <code>B(shape1, shape2)</code>.
</p>
<p>The beta binomial distribution is provided in two forms. <code>dBetaBinom_v</code> and
is when <code>shape1</code> and <code>shape2</code> are vectors.
<code>dBetaBinom_s</code> is used when <code>shape1</code> and <code>shape2</code> are scalars.
In both cases, <code>x</code> is a vector.
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein and Perry de Valpine
</p>


<h3>See Also</h3>

<p>For beta binomial N-mixture models, see <code><a href="#topic+dNmixture">dNmixture</a></code>.
For documentation on the beta function, use <code>?stats::dbeta</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate a beta binomial probability with different shape1 and shape2 for each x[i]
dBetaBinom_v(x = c(4, 0, 0, 3), N = 10,
  shape1 = c(0.5, 0.5, 0.3, 0.5), shape2 = c(0.2, 0.4, 1, 1.2))
# or with constant shape1 and shape2
dBetaBinom_s(x = c(4, 0, 0, 3), N = 10, shape1 = 0.5, shape2 = 0.5, log = TRUE)
</code></pre>

<hr>
<h2 id='dCJS'>Cormack-Jolly-Seber distribution for use in <code>nimble</code> models</h2><span id='topic+dCJS'></span><span id='topic+dCJS_ss'></span><span id='topic+dCJS_sv'></span><span id='topic+dCJS_vs'></span><span id='topic+dCJS_vv'></span><span id='topic+rCJS_ss'></span><span id='topic+rCJS_sv'></span><span id='topic+rCJS_vs'></span><span id='topic+rCJS_vv'></span>

<h3>Description</h3>

<p><code>dCJS_**</code> and <code>rCJS_**</code> provide Cormack-Jolly-Seber capture-recapture
distributions that can be used directly from R or in <code>nimble</code>
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCJS_ss(x, probSurvive, probCapture, len = 0, log = 0)

dCJS_sv(x, probSurvive, probCapture, len = 0, log = 0)

dCJS_vs(x, probSurvive, probCapture, len = 0, log = 0)

dCJS_vv(x, probSurvive, probCapture, len = 0, log = 0)

rCJS_ss(n, probSurvive, probCapture, len = 0)

rCJS_sv(n, probSurvive, probCapture, len = 0)

rCJS_vs(n, probSurvive, probCapture, len = 0)

rCJS_vv(n, probSurvive, probCapture, len = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCJS_+3A_x">x</code></td>
<td>
<p>capture history vector of 0s (not captured) and 1s (captured).
Include the initial capture, so <code>x[1]</code> should equal 1.</p>
</td></tr>
<tr><td><code id="dCJS_+3A_probsurvive">probSurvive</code></td>
<td>
<p>survival probability, either a time-independent scalar
(for dCJS_s*) or a time-dependent vector (for dCJS_v*) with length
<code>len - 1</code>.</p>
</td></tr>
<tr><td><code id="dCJS_+3A_probcapture">probCapture</code></td>
<td>
<p>capture probability, either a time-independent scalar
(for dCJS_*s) or a time-dependent vector (for dCJS_*v) with length <code>len</code>.
If a vector, first element is ignored, as the total probability is conditioned
on the capture at <code>t = 1</code>.</p>
</td></tr>
<tr><td><code id="dCJS_+3A_len">len</code></td>
<td>
<p>length of capture history. Should equal <code>length(x)</code></p>
</td></tr>
<tr><td><code id="dCJS_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to return probability.</p>
</td></tr>
<tr><td><code id="dCJS_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the
argument exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used directly in R or
in <code>nimble</code> hierarchical models (via <code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code>
and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>The letters following the 'dCJS_' indicate whether survival and/or capture
probabilities, in that order, are scalar (s, meaning the probability applies
to every <code>x[t]</code>) or vector (v, meaning the probability is a vector
aligned with <code>x</code>).  When <code>probCapture</code> and/or <code>probSurvive</code> is
a vector, they must be the same length as <code>x</code>.
</p>
<p>It is important to use the time indexing correctly for survival.
<code>probSurvive[t]</code> is the survival probabilty from time <code>t</code> to time
<code>t + 1</code>. When a vector, <code>probSurvive</code> may have length greater than
<code>length(x) - 1</code>, but all values beyond that index are ignored.
</p>
<p>Time indexing for detection is more obvious: <code>probDetect[t]</code> is the
detection probability at time <code>t</code>.
</p>
<p>When called from R, the <code>len</code> argument to <code>dCJS_**</code> is not
necessary. It will default to the length of <code>x</code>.  When used in
<code>nimble</code> model code (via <code>nimbleCode</code>), <code>len</code> must be provided
(even though it may seem redundant).
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete latent state for
true alive/dead status at each time and a separate scalar datum for each
observation, use of these distributions allows one to directly sum
(marginalize) over the discrete latent states and calculate the probability
of the detection history for one individual jointly.
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in <code>nimble</code> model code,
</p>
<p><code>captures[i, 1:T] ~ dCSJ_ss(survive, capture, T)</code>
</p>
<p>declares a vector node, <code>captures[i, 1:T]</code>, (detection history for individual
<code>i</code>,  for example) that follows a CJS distribution
with scalar survival probability <code>survive</code> and scalar capture probability <code>capture</code>
(assuming <code>survive</code> and <code>capture</code> are defined elsewhere in the model).
</p>
<p>This will invoke (something like) the following call to <code>dCJS_ss</code> when <code>nimble</code> uses the
model such as for MCMC:
</p>
<p><code>dCJS_ss(captures[i, 1:T], survive, capture, len = T, log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration
needs to generate a random draw for <code>captures[i, 1:T]</code>, it
will make a similar invocation of <code>rCJS_ss</code>, with <code>n = 1</code>.
</p>
<p>If both survival and capture probabilities are time-dependent, use
</p>
<p><code>captures[i,1:T] ~ dCSJ_vv(survive[1:(T-1)], capture[1:T], T)</code>
</p>
<p>and so on for each combination of time-dependent and time-independent parameters.
</p>


<h3>Value</h3>

<p>For <code>dCJS_**</code>: the probability (or likelihood) or log probability of observation vector <code>x</code>.
</p>
<p>For <code>rCJS_**</code>: a simulated capture history, <code>x</code>.
</p>


<h3>Notes for use with automatic differentiation</h3>

<p>The <code>dCJS_**</code> distributions should all work for models and algorithms
that use nimble's automatic differentiation (AD) system. In that system,
some kinds of values are &quot;baked in&quot; (cannot be changed) to the AD calculations
from the first call, unless and until the AD calculations are reset. For
the <code>dCJS_**</code> distributions, the lengths of vector inputs and the data
(<code>x</code>) values themselves are baked in. These can be different for different
iterations through a for loop (or nimble model declarations with different indices,
for example), but the lengths and data values for each specific iteration
will be &quot;baked in&quot; after the first call. <b>In other words, it is assumed that
<code>x</code> are data and are not going to change.</b>
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Perry de Valpine, and Daniel Turek
</p>


<h3>References</h3>

<p>D. Turek, P. de Valpine and C. J. Paciorek. 2016. Efficient Markov chain Monte
Carlo sampling for hierarchical hidden Markov models. Environmental and Ecological Statistics
23:549–564. DOI 10.1007/s10651-016-0353-z
</p>


<h3>See Also</h3>

<p>For multi-state or multi-event capture-recapture models, see <code><a href="#topic+dHMM">dHMM</a></code> or <code><a href="#topic+dDHMM">dDHMM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
dat &lt;- c(1,1,0,0,0) # A vector of observations
probSurvive &lt;- c(0.6, 0.3, 0.3, 0.1)
probCapture &lt;- 0.4


# Define code for a nimbleModel
nc &lt;- nimbleCode({
  x[1:4] ~ dCJS_vs(probSurvive[1:4], probCapture, len = 4)
  probCapture ~ dunif(0,1)
  for (i in 1:4) probSurvive[i] ~ dunif(0, 1)
})

# Build the model, providing data and initial values
CJS_model &lt;- nimbleModel(nc, data = list(x = dat),
                         inits = list(probSurvive = probSurvive,
                                      probCapture = probCapture))

# Calculate log probability of data from the model
CJS_model$calculate()
# Use the model for a variety of other purposes...
</code></pre>

<hr>
<h2 id='dDHMM'>Dynamic Hidden Markov Model distribution for use in <code>nimble</code> models</h2><span id='topic+dDHMM'></span><span id='topic+dDHMMo'></span><span id='topic+rDHMM'></span><span id='topic+rDHMMo'></span>

<h3>Description</h3>

<p><code>dDHMM</code> and <code>dDHMMo</code> provide Dynamic hidden Markov model
distributions for <code>nimble</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDHMM(x, init, probObs, probTrans, len, checkRowSums = 1, log = 0)

dDHMMo(x, init, probObs, probTrans, len, checkRowSums = 1, log = 0)

rDHMM(n, init, probObs, probTrans, len, checkRowSums = 1)

rDHMMo(n, init, probObs, probTrans, len, checkRowSums = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dDHMM_+3A_x">x</code></td>
<td>
<p>vector of observations, each one a positive integer corresponding to
an observation state (one value of which could can correspond to &quot;not
observed&quot;, and another value of which can correspond to &quot;dead&quot; or &quot;removed
from system&quot;).</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_init">init</code></td>
<td>
<p>vector of initial state probabilities. Must sum to 1</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_probobs">probObs</code></td>
<td>
<p>time-independent matrix (<code>dDHMM</code> and <code>rDHMM</code>) or
time-dependent 3D array (<code>dDHMMo</code> and <code>rDHMMo</code>) of observation
probabilities.  First two dimensions of <code>probObs</code> are of size x
(number of possible system states) x (number of possible observation
classes). <code>dDHMMo</code> and <code>rDHMMo</code> expect an additional third
dimension of size (number of observation times). probObs[i, j (,t)] is the
probability that an individual in the ith latent state is recorded as being
in the jth detection state (at time t). See Details for more information.</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_probtrans">probTrans</code></td>
<td>
<p>time-dependent array of system state transition
probabilities. Dimension of <code>probTrans</code> is (number of possible system
states) x (number of possible system states) x (number of observation
times). probTrans[i,j,t] is the probability that an individual truly in
state i at time t will be in state j at time t+1.  See Details for more
information.</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_len">len</code></td>
<td>
<p>length of observations (needed for rDHMM)</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_checkrowsums">checkRowSums</code></td>
<td>
<p>should validity of <code>probObs</code> and <code>probTrans</code> be
checked?  Both of these are required to have each set of probabilities sum
to 1 (over each row, or second dimension). If <code>checkRowSums</code> is
non-zero (or <code>TRUE</code>), these conditions will be checked within a
tolerance of 1e-6.  If it is 0 (or <code>FALSE</code>), they will not be checked.
Not checking should result in faster execution, but whether that is
appreciable will be case-specific.</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_log">log</code></td>
<td>
<p><code>TRUE</code> or 1 to return log probability. <code>FALSE</code> or 0 to
return probability</p>
</td></tr>
<tr><td><code id="dDHMM_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the argument
exists for standardization of &quot;<code>r</code>&quot; functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used
directly in R or in <code>nimble</code> hierarchical models (via
<code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code> and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>The probability (or likelihood) of observation <code>x[t, o]</code> depends on the
previous true latent state, the time-dependent probability of transitioning
to a new state <code>probTrans</code>, and the probability of observation states
given the true latent state <code>probObs</code>.
</p>
<p>The distribution has two forms, <code>dDHMM</code> and <code>dDHMMo</code>. <code>dDHMM</code>
takes a time-independent observation probability matrix with dimension S x O,
while <code>dDHMMo</code> expects a three-dimensional array of time-dependent
observation probabilities with dimension S x O x T, where O is the number of
possible occupancy states, S is the number of true latent states, and T is
the number of time intervals.
</p>
<p><code>probTrans</code> has dimension S x S x (T - 1). <code>probTrans</code>[i, j, t] is
the probability that an individual in state <code>i</code> at time <code>t</code> takes
on state <code>j</code> at time <code>t+1</code>. The length of the third dimension may
be greater than (T - 1) but all values indexed greater than T - 1 will be
ignored.
</p>
<p><code>init</code> has length S. <code>init[i]</code> is the probability of being in state
<code>i</code> at the first observation time. That means that the first
observations arise from the initial state probabilities.
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete true latent state
and a separate scalar datum for each observation, use of these distributions
allows one to directly sum (marginalize) over the discrete latent state and
calculate the probability of all observations from one site jointly.
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in a NIMBLE model,
</p>
<p><code>observedStates[1:T] ~ dDHMM(initStates[1:S], observationProbs[1:S,
1:O], transitionProbs[1:S, 1:S, 1:(T-1)], 1, T)</code>
</p>
<p>declares that the <code>observedStates[1:T]</code> vector follows a dynamic hidden
Markov model distribution with parameters as indicated, assuming all the
parameters have been declared elsewhere in the model. In this case, <code>S</code>
is the number of system states, <code>O</code> is the number of observation
classes, and <code>T</code> is the number of observation occasions.This will invoke
(something like) the following call to <code>dDHMM</code> when <code>nimble</code> uses
the model such as for MCMC:
</p>
<p><code>rDHMM(observedStates[1:T], initStates[1:S], observationProbs[1:S, 1:O],
transitionProbs[1:S, 1:S, 1:(T-1)], 1, T, log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration needs to
generate a random draw for <code>observedStates[1:T]</code>, it will make a similar
invocation of <code>rDHMM</code>, with <code>n = 1</code>.
</p>
<p>If the observation probabilities are time-dependent, one would use:
</p>
<p><code>observedStates[1:T] ~ dDHMMo(initStates[1:S], observationProbs[1:S,
1:O, 1:T], transitionProbs[1:S, 1:S, 1:(T-1)], 1, T)</code>
</p>
<p>The <code>dDHMM[o]</code> distributions should work for models and algorithms that
use nimble's automatic differentiation (AD) system. In that system, some
kinds of values are &quot;baked in&quot; (cannot be changed) to the AD calculations
from the first call, unless and until the AD calculations are reset. For the
<code>dDHMM[o]</code> distributions, the sizes of the inputs and the data (<code>x</code>)
values themselves are baked in. These can be different for different
iterations through a for loop (or nimble model declarations with different
indices, for example), but the sizes and data values for each specific
iteration will be &quot;baked in&quot; after the first call. <b>In other words, it
is assumed that <code>x</code> are data and are not going to change.</b>
</p>


<h3>Value</h3>

<p>For <code>dDHMM</code> and <code>dDHMMo</code>: the probability (or likelihood)
or log probability of observation vector <code>x</code>. For <code>rDHMM</code> and
<code>rDHMMo</code>: a simulated detection history, <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Perry de Valpine, Daniel Turek, and Ben Goldstein
</p>


<h3>References</h3>

<p>D. Turek, P. de Valpine and C. J. Paciorek. 2016. Efficient Markov chain Monte
Carlo sampling for hierarchical hidden Markov models. Environmental and Ecological Statistics
23:549–564. DOI 10.1007/s10651-016-0353-z
</p>


<h3>See Also</h3>

<p>For hidden Markov models with time-independent transitions,
see <a href="#topic+dHMM">dHMM</a> and <a href="#topic+dHMMo">dHMMo</a>.
For simple capture-recapture, see <a href="#topic+dCJS">dCJS</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
dat &lt;- c(1,2,1,1) # A vector of observations
init &lt;- c(0.4, 0.2, 0.4) # A vector of initial state probabilities
probObs &lt;- t(array( # A matrix of observation probabilities
       c(1, 0,
         0, 1,
         0.8, 0.2), c(2, 3)))

probTrans &lt;- array(rep(1/3, 27), # A matrix of time-indexed transition probabilities
            c(3,3,3))

# Define code for a nimbleModel
 nc &lt;- nimbleCode({
   x[1:4] ~ dDHMM(init[1:3], probObs = probObs[1:3, 1:2],
                  probTrans = probTrans[1:3, 1:3, 1:3], len = 4, checkRowSums = 1)

   for (i in 1:3) {
     init[i] ~ dunif(0,1)

     for (j in 1:3) {
       for (t in 1:3) {
         probTrans[i,j,t] ~ dunif(0,1)
       }
     }

     probObs[i, 1] ~ dunif(0,1)
     probObs[i, 2] &lt;- 1 - probObs[i,1]
   }
 })

# Build the model, providing data and initial values
DHMM_model &lt;- nimbleModel(nc,
                          data = list(x = dat),
                          inits = list(init = init,
                                       probObs = probObs,
                                       probTrans = probTrans))
# Calculate log probability of x from the model
DHMM_model$calculate()
# Use the model for a variety of other purposes...
</code></pre>

<hr>
<h2 id='dDynOcc'>Dynamic occupancy distribution for use in <code>nimble</code> models
<code>dDynOcc_**</code> and <code>rDynOcc_**</code> provide dynamic occupancy
model distributions that can be used directly from R or in <code>nimble</code>
models.</h2><span id='topic+dDynOcc'></span><span id='topic+dDynOcc_sss'></span><span id='topic+dDynOcc_svs'></span><span id='topic+dDynOcc_vss'></span><span id='topic+dDynOcc_vvs'></span><span id='topic+dDynOcc_ssv'></span><span id='topic+dDynOcc_svv'></span><span id='topic+dDynOcc_vsv'></span><span id='topic+dDynOcc_vvv'></span><span id='topic+dDynOcc_ssm'></span><span id='topic+dDynOcc_svm'></span><span id='topic+dDynOcc_vsm'></span><span id='topic+dDynOcc_vvm'></span><span id='topic+rDynOcc_vvm'></span><span id='topic+rDynOcc_vsm'></span><span id='topic+rDynOcc_svm'></span><span id='topic+rDynOcc_ssm'></span><span id='topic+rDynOcc_vvv'></span><span id='topic+rDynOcc_vsv'></span><span id='topic+rDynOcc_svv'></span><span id='topic+rDynOcc_ssv'></span><span id='topic+rDynOcc_vvs'></span><span id='topic+rDynOcc_vss'></span><span id='topic+rDynOcc_svs'></span><span id='topic+rDynOcc_sss'></span>

<h3>Description</h3>

<p>Dynamic occupancy distribution for use in <code>nimble</code> models
<code>dDynOcc_**</code> and <code>rDynOcc_**</code> provide dynamic occupancy
model distributions that can be used directly from R or in <code>nimble</code>
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDynOcc_vvm(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_vsm(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_svm(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_ssm(x, init, probPersist, probColonize, p, start, end, log = 0)

rDynOcc_vvm(n, init, probPersist, probColonize, p, start, end)

rDynOcc_vsm(n, init, probPersist, probColonize, p, start, end)

rDynOcc_svm(n, init, probPersist, probColonize, p, start, end)

rDynOcc_ssm(n, init, probPersist, probColonize, p, start, end)

dDynOcc_vvv(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_vsv(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_svv(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_ssv(x, init, probPersist, probColonize, p, start, end, log = 0)

rDynOcc_vvv(n, init, probPersist, probColonize, p, start, end)

rDynOcc_vsv(n, init, probPersist, probColonize, p, start, end)

rDynOcc_svv(n, init, probPersist, probColonize, p, start, end)

rDynOcc_ssv(n, init, probPersist, probColonize, p, start, end)

dDynOcc_vvs(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_vss(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_svs(x, init, probPersist, probColonize, p, start, end, log = 0)

dDynOcc_sss(x, init, probPersist, probColonize, p, start, end, log = 0)

rDynOcc_vvs(n, init, probPersist, probColonize, p, start, end)

rDynOcc_vss(n, init, probPersist, probColonize, p, start, end)

rDynOcc_svs(n, init, probPersist, probColonize, p, start, end)

rDynOcc_sss(n, init, probPersist, probColonize, p, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dDynOcc_+3A_x">x</code></td>
<td>
<p>detection/non-detection matrix of 0s (not detected) and 1s
(detected). Rows represent primary sampling occasions (e.g. different
seasons). Columns are secondary sampling locations (e.g. replicate
visits within a season) that may be different for each row</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_init">init</code></td>
<td>
<p>probability of occupancy in the first sampling period</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_probpersist">probPersist</code></td>
<td>
<p>persistence probability&ndash;probability an occupied
cell remains occupied. 1-extinction probability. Scalar for
<code>dDynOcc_s**</code>, vector for <code>dDynOcc_v**</code>. If vector,
should have length dim(x)[1] - 1 since no transition occurs
after the last observation</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_probcolonize">probColonize</code></td>
<td>
<p>colonization probability. Probability that
an unoccupied cell becomes occupied. Scalar for <code>dDynOcc_*s*</code>,
vector for <code>dDynOcc_*v*</code>. If vector, should have length
dim(x)[1] - 1 since no transition occurs after the last observation</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_p">p</code></td>
<td>
<p>Detection probabilities. Scalar for <code>dDynOcc_**s</code>,
vector for <code>dDynOcc_**v</code>, matrix for <code>dDynOcc_**m</code>.
If a matrix, dimensions should match x</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_start">start</code></td>
<td>
<p>indicates the column number of the first observation in each
row of x. A vector of length dim(x)[1]. This allows for different time
periods to have different numbers of sampling occasions</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_end">end</code></td>
<td>
<p>indicates the column number of the last observation in each
row of x. A vector of length dim(x)[1]. This allows for different time
periods to have different numbers of sampling occasions</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_log">log</code></td>
<td>
<p>TRUE (return log probability) or FALSE (return probability)</p>
</td></tr>
<tr><td><code id="dDynOcc_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a matrix of dimension
<code>c(min(start), max(end))</code>. Currently only <code>n = 1</code> is supported,
but the argument exists for standardization of &quot;<code>r</code>&quot; functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used directly in R or
in <code>nimble</code> hierarchical models (via <code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code>
and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>The probability (or likelihood) of observation <code>x[t, o]</code> depends on
the occupancy status of the site at time t-1, the transitition
probability of persistence (<code>probPersist</code> or <code>probPersist[t-1]</code>),
colonization (<code>probColonize</code> or <code>probColonize[t-1]</code>), and a
detection probability (<code>p</code>, <code>p[t]</code>, or <code>p[t, o]</code>).
</p>
<p>The first two letters following the 'dDynOcc_' indicate whether the
probabilities of persistence and colonization are a constant scalar (s)
or time-indexed vector (v). For example, <code>dDynOcc_svm</code> takes scalar
persistence probability <code>probPersist</code> with a vector of colonization
probabilities <code>probColonize[1:(T-1)]</code>.
</p>
<p>When vectors, <code>probColonize</code> and <code>probPersist</code> may be of any
length greater than or equal to <code>length(x) - 1</code>. Only the first <code>length(x) - 1</code>
indices are used, each corresponding to the transition from time t to t+1
(e.g. <code>probColonize[2]</code> describes the transition probability from
t = 2 to t = 3). All extra values are ignored. This is to make it easier to
use one distribution for many sites, some requiring probabilities of length 1.
</p>
<p>The third letter in the suffix indicates whether the detection probability
is a constant (scalar), time-dependent (vector), or both time-dependent and
dependent on observation occasion (matrix). For example, <code>dDynOcc_svm</code>
takes a matrix of detection probabilities <code>p[1:T, 1:O]</code>.
</p>
<p>The arguments <code>start</code> and <code>end</code> allow different time periods to
contain different numbers of sampling events. Suppose you have observations
for samples in three seasons; in the first two seasons, there are four
observations, but in the third, there are only three. The <code>start</code>
and <code>end</code> could be provided as <code>start = c(1,1,1)</code> and
<code>end = c(4,4,3)</code>. In this case, the value of <code>x[4,4]</code> would
be ignored.
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete latent state for
true occupancy status and a separate scalar datum for each observation, use
of these distributions allows one to directly sum (marginalize) over the
discrete latent state and calculate the probability of all observations from
one site jointly.
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in <code>nimble</code> model code,
</p>
<p><code>detections[1:T, 1:O] ~ dDynOcc_ssm(init,
probPersist = persistence_prob,
probColonize = colonization_prob, p = p[1:T, 1:O],
start = start[1:T], end = end[1:T])</code>
</p>
<p>declares that the <code>detections[1:T]</code> vector follows a dynamic occupancy
model distribution with parameters as indicated, assuming all the parameters
have been declared elsewhere in the model. This
will invoke (something like) the following call to <code>dDynOcc_ssm</code> when
<code>nimble</code> uses the model such as for MCMC:
</p>
<p><code>dDynOcc_ssm(detections[1:T, 1:O], init,
probPersist = persistence_prob,
probColonize = colonization_prob, p = p[1:T, 1:O],
start = start[1:T], end = end[1:T], log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration
needs to generate a random draw for <code>detections[1:T, 1:O]</code>, it
will make a similar invocation of <code>rDynOcc_ssm</code>, with <code>n = 1</code>.
</p>
<p>If the colonization probabilities are time-dependent, one would use:
</p>
<p><code>detections[1:T] ~ dDynOcc_svm(nrep, init = init_prob,
probPersist = persistence_prob,
probColonize = colonization_prob[1:(T-1)], p = p[1:T, 1:O])</code>
</p>


<h3>Value</h3>

<p>For <code>dDynOcc_***</code>: the probability (or likelihood) or log probability
of observation vector <code>x</code>.
For <code>rDynOcc_***</code>: a simulated detection history, <code>x</code>.
</p>


<h3>Notes for use with automatic differentiation</h3>

<p>The <code>dDynOcc_***</code> distributions should all work for models and
algorithms that use nimble's automatic differentiation (AD) system. In that
system, some kinds of values are &quot;baked in&quot; (cannot be changed) to the AD
calculations from the first call, unless and until the AD calculations are
reset. For the <code>dDynOcc_***</code> distributions, the lengths or dimensions of
vector and/or matrix inputs and the <code>start</code> and <code>end</code> values
themselves are baked in. These can be different for different iterations
through a for loop (or nimble model declarations with different indices, for
example), but the for each specific iteration will be &quot;baked in&quot; after the
first call. <b>It is safest if one can assume that <code>x</code> are data and
are not going to change.</b>
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Perry de Valpine and Lauren Ponisio
</p>


<h3>See Also</h3>

<p>For basic occupancy models, see documentation for
<code><a href="#topic+dOcc">dOcc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
  x &lt;- matrix(c(0,0,0,0,
                1,1,1,0,
                0,0,0,0,
                0,0,1,0,
                0,0,0,0), nrow = 4)
  start &lt;- c(1,1,2,1,1)
  end &lt;- c(5,5,5,4,5)
  init &lt;- 0.7
  probPersist &lt;- 0.5
  probColonize &lt;- 0.2
  p &lt;- matrix(rep(0.5, 20), nrow = 4)


# Define code for a nimbleModel
 nc &lt;- nimbleCode({

   x[1:2, 1:5] ~ dDynOcc_vvm(init,
     probPersist[1:2], probColonize[1:2], p[1:2,1:5],
     start = start[1:4], end = end[1:4])

   init ~ dunif(0,1)

   for (i in 1:2) {
     probPersist[i] ~ dunif(0,1)
     probColonize[i] ~ dunif(0,1)
   }

   for (i in 1:2) {
     for (j in 1:5) {
       p[i,j] ~ dunif(0,1)
     }
   }
 })

# Build the model, providing data and initial values
DynOcc_model &lt;- nimbleModel(nc, data = list(x = x),
                            constants = list(start = start, end = end),
                            inits = list(p = p, probPersist = probPersist,
                                         init = init, probColonize = probColonize))

# Calculate log probability of data from the model
DynOcc_model$calculate("x")
# Use the model for a variety of other purposes...
</code></pre>

<hr>
<h2 id='dHMM'>Hidden Markov Model distribution for use in <code>nimble</code> models</h2><span id='topic+dHMM'></span><span id='topic+dHMMo'></span><span id='topic+rHMM'></span><span id='topic+rHMMo'></span>

<h3>Description</h3>

<p><code>dHMM</code> and <code>dHMMo</code> provide hidden Markov model distributions that
can be used directly from R or in <code>nimble</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHMM(x, init, probObs, probTrans, len = 0, checkRowSums = 1, log = 0)

dHMMo(x, init, probObs, probTrans, len = 0, checkRowSums = 1, log = 0)

rHMM(n, init, probObs, probTrans, len = 0, checkRowSums = 1)

rHMMo(n, init, probObs, probTrans, len = 0, checkRowSums = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dHMM_+3A_x">x</code></td>
<td>
<p>vector of observations, each one a positive integer corresponding to
an observation state (one value of which could can correspond to &quot;not
observed&quot;, and another value of which can correspond to &quot;dead&quot; or &quot;removed
from system&quot;).</p>
</td></tr>
<tr><td><code id="dHMM_+3A_init">init</code></td>
<td>
<p>vector of initial state probabilities. Must sum to 1</p>
</td></tr>
<tr><td><code id="dHMM_+3A_probobs">probObs</code></td>
<td>
<p>time-independent matrix (<code>dHMM</code> and <code>rHMM</code>) or
time-dependent array (<code>dHMMo</code> and <code>rHMMo</code>) of observation
probabilities. First two dimensions of <code>probObs</code> are of size x (number
of possible system states) x (number of possible observation classes).
<code>dDHMMo</code> and <code>rDHMMo</code> expects an additional third dimension of
size (number of observation times). probObs[i, j (,t)] is the probability
that an individual in the ith latent state is recorded as being in the jth
detection state (at time t). See Details for more information.</p>
</td></tr>
<tr><td><code id="dHMM_+3A_probtrans">probTrans</code></td>
<td>
<p>time-independent matrix of state transition probabilities.
probTrans[i,j] is the probability that an individual in latent state i
transitions to latent state j at the next timestep. See Details for more
information.</p>
</td></tr>
<tr><td><code id="dHMM_+3A_len">len</code></td>
<td>
<p>length of <code>x</code> (see below).</p>
</td></tr>
<tr><td><code id="dHMM_+3A_checkrowsums">checkRowSums</code></td>
<td>
<p>should validity of <code>probObs</code> and <code>probTrans</code> be
checked?  Both of these are required to have each set of probabilities sum
to 1 (over each row, or second dimension). If <code>checkRowSums</code> is
non-zero (or <code>TRUE</code>), these conditions will be checked within a
tolerance of 1e-6.  If it is 0 (or <code>FALSE</code>), they will not be checked.
Not checking should result in faster execution, but whether that is
appreciable will be case-specific.</p>
</td></tr>
<tr><td><code id="dHMM_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to return
probability.</p>
</td></tr>
<tr><td><code id="dHMM_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the argument
exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used
directly in R or in <code>nimble</code> hierarchical models (via
<code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code> and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>The distribution has two forms, <code>dHMM</code> and <code>dHMMo</code>. Define S as
the number of latent state categories (maximum possible value for elements
of <code>x</code>), O as the number of possible observation state categories, and
T as the number of observation times (length of <code>x</code>). In <code>dHMM</code>,
<code>probObs</code> is a time-independent observation probability matrix with
dimension S x O.  In <code>dHMMo</code>, <code>probObs</code> is a three-dimensional
array of time-dependent observation probabilities with dimension S x O x T.
The first index of <code>probObs</code> indexes the true latent state.  The
second index of <code>probObs</code> indexes the observed state.  For example, in
the time-dependent case, <code>probObs[i, j, t]</code> is the probability at time
<code>t</code> that an individual in state <code>i</code> is observed in state
<code>j</code>.
</p>
<p><code>probTrans</code> has dimension S x S. <code>probTrans</code>[i, j] is the
time-independent probability that an individual in state <code>i</code> at time
<code>t</code> transitions to state <code>j</code> time <code>t+1</code>.
</p>
<p><code>init</code> has length S. <code>init[i]</code> is the probability of being in
state <code>i</code> at the first observation time. That means that the first
observations arise from the initial state probabilities.
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete latent state and a
separate scalar datum for each observation time, use of these distributions
allows one to directly sum (marginalize) over the discrete latent state and
calculate the probability of all observations for one individual (or other
HMM unit) jointly.
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in <code>nimble</code> model code,
</p>
<p><code>observedStates[i, 1:T] ~ dHMM(initStates[1:S], observationProbs[1:S,
  1:O], transitionProbs[1:S, 1:S], 1, T)</code>
</p>
<p>declares that the <code>observedStates[i, 1:T]</code> (observation history for
individual <code>i</code>, for example) vector follows a hidden Markov model
distribution with parameters as indicated, assuming all the parameters have
been declared elsewhere in the model. As above, <code>S</code> is the number of
system state categories, <code>O</code> is the number of observation state
categories, and <code>T</code> is the number of observation occasions. This will
invoke (something like) the following call to <code>dHMM</code> when
<code>nimble</code> uses the model such as for MCMC:
</p>
<p><code>dHMM(observedStates[1:T], initStates[1:S], observationProbs[1:S,
  1:O], transitionProbs[1:S, 1:S], 1, T, log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration needs to
generate a random draw for <code>observedStates[1:T]</code>, it will make a
similar invocation of <code>rHMM</code>, with <code>n = 1</code>.
</p>
<p>If the observation probabilities are time-dependent, one would use:
</p>
<p><code>observedStates[1:T] ~ dHMMo(initStates[1:S], observationProbs[1:S,
  1:O, 1:T], transitionProbs[1:S, 1:S], 1, T)</code>
</p>


<h3>Value</h3>

<p>For <code>dHMM</code> and <code>dHMMo</code>: the probability (or likelihood) or
log probability of observation vector <code>x</code>.
</p>
<p>For <code>rHMM</code> and <code>rHMMo</code>: a simulated detection history, <code>x</code>.
</p>


<h3>Notes for use with automatic differentiation</h3>

<p>The <code>dHMM[o]</code> distributions should work for models and algorithms that
use nimble's automatic differentiation (AD) system. In that system, some
kinds of values are &quot;baked in&quot; (cannot be changed) to the AD calculations
from the first call, unless and until the AD calculations are reset. For the
<code>dHMM[o]</code> distributions, the sizes of the inputs and the data (<code>x</code>)
values themselves are baked in. These can be different for different
iterations through a for loop (or nimble model declarations with different
indices, for example), but the sizes and data values for each specific
iteration will be &quot;baked in&quot; after the first call. <b>In other words, it
is assumed that <code>x</code> are data and are not going to change.</b>
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Perry de Valpine, and Daniel Turek
</p>


<h3>References</h3>

<p>D. Turek, P. de Valpine and C. J. Paciorek. 2016. Efficient
Markov chain Monte Carlo sampling for hierarchical hidden Markov models.
Environmental and Ecological Statistics 23:549–564. DOI
10.1007/s10651-016-0353-z
</p>


<h3>See Also</h3>

<p>For dynamic hidden Markov models with time-dependent transitions,
see <code><a href="#topic+dDHMM">dDHMM</a></code> and <code><a href="#topic+dDHMMo">dDHMMo</a></code>. For simple
capture-recapture, see <code><a href="#topic+dCJS">dCJS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
len &lt;- 5 # length of dataset
dat &lt;- c(1,2,1,1,2) # A vector of observations
init &lt;- c(0.4, 0.2, 0.4) # A vector of initial state probabilities
probObs &lt;- t(array( # A matrix of observation probabilities
       c(1, 0,
         0, 1,
         0.2, 0.8), c(2, 3)))
probTrans &lt;- t(array( # A matrix of transition probabilities
        c(0.6, 0.3, 0.1,
          0, 0.7, 0.3,
          0, 0, 1), c(3,3)))

# Define code for a nimbleModel
 nc &lt;- nimbleCode({
   x[1:5] ~ dHMM(init[1:3], probObs = probObs[1:3,1:2],
                 probTrans = probTrans[1:3, 1:3], len = 5, checkRowSums = 1)

   for (i in 1:3) {
     for (j in 1:3) {
       probTrans[i,j] ~ dunif(0,1)
     }

     probObs[i, 1] ~ dunif(0,1)
     probObs[i, 2] &lt;- 1 - probObs[i, 1]
   }
 })

# Build the model
HMM_model &lt;- nimbleModel(nc,
                         data = list(x = dat),
                         inits = list(init = init,
                                      probObs = probObs,
                                      probTrans = probTrans))
# Calculate log probability of data from the model
HMM_model$calculate()
# Use the model for a variety of other purposes...
</code></pre>

<hr>
<h2 id='dNmixture'>dNmixture distribution for use in <code>nimble</code> models</h2><span id='topic+dNmixture'></span><span id='topic+dNmixture_s'></span><span id='topic+dNmixture_v'></span><span id='topic+rNmixture_s'></span><span id='topic+rNmixture_v'></span><span id='topic+dNmixture_BNB_v'></span><span id='topic+dNmixture_BNB_s'></span><span id='topic+dNmixture_BNB_oneObs'></span><span id='topic+dNmixture_BBP_v'></span><span id='topic+dNmixture_BBP_s'></span><span id='topic+dNmixture_BBP_oneObs'></span><span id='topic+dNmixture_BBNB_v'></span><span id='topic+dNmixture_BBNB_s'></span><span id='topic+dNmixture_BBNB_oneObs'></span><span id='topic+rNmixture_BNB_v'></span><span id='topic+rNmixture_BNB_s'></span><span id='topic+rNmixture_BNB_oneObs'></span><span id='topic+rNmixture_BBP_v'></span><span id='topic+rNmixture_BBP_s'></span><span id='topic+rNmixture_BBP_oneObs'></span><span id='topic+rNmixture_BBNB_v'></span><span id='topic+rNmixture_BBNB_s'></span><span id='topic+rNmixture_BBNB_oneObs'></span>

<h3>Description</h3>

<p><code>dNmixture_s</code> and <code>dNmixture_v</code> provide Poisson-Binomial mixture
distributions of abundance (&quot;N-mixture&quot;) for use in <code>nimble</code> models.
Overdispersion alternatives using the negative binomial distribution (for
the abundance submodel) and the beta binomial distribution (for the detection
submodel) are also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dNmixture_v(x, lambda, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_s(x, lambda, prob, Nmin = -1, Nmax = -1, len, log = 0)

rNmixture_v(n, lambda, prob, Nmin = -1, Nmax = -1, len)

rNmixture_s(n, lambda, prob, Nmin = -1, Nmax = -1, len)

dNmixture_BNB_v(x, lambda, theta, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BNB_s(x, lambda, theta, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BNB_oneObs(x, lambda, theta, prob, Nmin = -1, Nmax = -1, log = 0)

dNmixture_BBP_v(x, lambda, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BBP_s(x, lambda, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BBP_oneObs(x, lambda, prob, s, Nmin = -1, Nmax = -1, log = 0)

dNmixture_BBNB_v(x, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BBNB_s(x, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixture_BBNB_oneObs(x, lambda, theta, prob, s, Nmin = -1, Nmax = -1, log = 0)

rNmixture_BNB_v(n, lambda, theta, prob, Nmin = -1, Nmax = -1, len)

rNmixture_BNB_s(n, lambda, theta, prob, Nmin = -1, Nmax = -1, len)

rNmixture_BNB_oneObs(n, lambda, theta, prob, Nmin = -1, Nmax = -1)

rNmixture_BBP_v(n, lambda, prob, s, Nmin = -1, Nmax = -1, len)

rNmixture_BBP_s(n, lambda, prob, s, Nmin = -1, Nmax = -1, len)

rNmixture_BBP_oneObs(n, lambda, prob, s, Nmin = -1, Nmax = -1)

rNmixture_BBNB_v(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len)

rNmixture_BBNB_s(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len)

rNmixture_BBNB_oneObs(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dNmixture_+3A_x">x</code></td>
<td>
<p>vector of integer counts from a series of sampling occasions.</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_lambda">lambda</code></td>
<td>
<p>expected value of the Poisson distribution of true abundance</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_prob">prob</code></td>
<td>
<p>detection probability (scalar for <code>dNmixture_s</code>, vector for
<code>dNmixture_v</code>).</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_nmin">Nmin</code></td>
<td>
<p>minimum abundance to sum over for the mixture probability. Set to
-1 to select automatically (not available for beta binomial variations; see
Details).</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_nmax">Nmax</code></td>
<td>
<p>maximum abundance to sum over for the mixture probability. Set to
-1 to select automatically (not available for beta binomial variations; see
Details).</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_len">len</code></td>
<td>
<p>The length of the x vector</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to return
probability.</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the argument
exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
<tr><td><code id="dNmixture_+3A_theta">theta</code></td>
<td>
<p>abundance overdispersion parameter required for negative
binomial (*NB) N-mixture models. The negative binomial is parameterized
such that variance of x is <code>lambda^2 * theta + lambda</code></p>
</td></tr>
<tr><td><code id="dNmixture_+3A_s">s</code></td>
<td>
<p>detection overdispersion parameter required for beta binomial (BB*)
N-mixture models. The beta binomial is parameterized such that variance of
x is <code>V(x) = N * prob * (1-prob) * (N + s) / (s + 1)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be
used directly in R or in <code>nimble</code> hierarchical models (via
<code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code> and
<code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>An N-mixture model defines a distribution for multiple counts (typically of
animals, typically made at a sequence of visits to the same site).  The
latent number of animals available to be counted, N, follows a Poisson or
negative binomial distribution. Each count, <code>x[i]</code> for visit <code>i</code>,
follows a binomial or beta-binomial distribution. The N-mixture distributions
calculate the marginal probability of observed counts by summing over the
range of latent abundance values.
</p>
<p>The basic N-mixture model uses Poisson latent abundance with mean
<code>lambda</code> and binomial observed counts  with size (number of trials) N
and probability of success (being counted) <code>prob[i]</code>. This distribution
is available in two forms, <code>dNmixture_s</code> and <code>dNmixture_v</code>. With
<code>dNmixture_s</code>, detection probability is a scalar, independent of visit,
so <code>prob[i]</code> should be replaced with <code>prob</code> above.  With
<code>dNmixture_v</code>, detection probability is a vector, with one element for
each visit, as written above.
</p>
<p>We also provide three important variations on the traditional N-mixture
model: <code>dNmixture_BNB</code>, <code>dNmixture_BBP</code>, and <code>dNmixture_BBNB</code>.
These distributions allow you to replace the Poisson (P) abundance
distribution with the negative binomial (NB) and the binomial (B) detection
distribution with the beta binomial (BB).
</p>
<p>Binomial-negative binomial: BNB N-mixture models use a binomial distribution
for detection and a negative binomial distribution for abundance with scalar
overdispersion parameter <code>theta</code> (0-Inf). We parameterize such that the
variance of the negative binomial is <code>lambda^2 * theta + lambda</code>, so
large <code>theta</code> indicates a large amount of overdisperison in abundance.
The BNB is available in three suffixed forms: <code>dNmixture_BNB_v</code> is used
if <code>prob</code> varies between observations, <code>dNmixture_BNB_s</code> is used if
<code>prob</code> is scalar (constant across observations), and
<code>dNmixture_BNB_oneObs</code> is used if only one observation is available at
the site (so both x and prob are scalar).
</p>
<p>Beta-binomial-Poisson: BBP N-mixture uses a beta binomial distribution for
detection probabilities and a Poisson distribution for abundance. The beta
binomial distribution has scalar overdispersion parameter s (0-Inf). We
parameterize such that the variance of the beta binomial is <code>N * prob
* (1-prob) * (N + s) / (s + 1)</code>, with greater s indicating less variance
(greater-than-binomial relatedness between observations at the site) and s -&gt;
0 indicating the binomial. The BBP is available in three suffixed forms:
<code>dNmixture_BBP_v</code> is used if <code>prob</code> varies between observations,
<code>dNmixture_BBP_s</code> is used if <code>prob</code> is scalar (constant across
observations), and <code>dNmixture_BBP_oneObs</code> is used if only one
observation is available at the site (so both x and prob are scalar).
</p>
<p>Beta-binomial-negative-binomial: dNmixture_BBNB is available using a negative
binomial abundance distribution and a beta binomial detection distribution.
<code>dNmixture_BBNB</code> is available with <code>_s</code>, <code>_v</code>, and
<code>_oneObs</code> suffixes as above and requires both arguments <code>s</code> and
<code>theta</code> as parameterized above.
</p>
<p>The distribution dNmixture_oneObs is not provided as the probability given
by the traditional N-mixture distribution for <code>length(x) = 1</code> is
equivalent to <code>dpois(prob * lambda)</code>.
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete latent state of
abundance N and a separate scalar datum for each count, use of these
distributions allows one to directly sum (marginalize) over the discrete
latent state N and calculate the probability of all observations for a site
jointly.
</p>
<p>If one knows a reasonable range for summation over possible values of N, the
start and end of the range can be provided as <code>Nmin</code> and <code>Nmax</code>.
Otherwise one can set both to -1, in which case values for <code>Nmin</code> and
<code>Nmax</code> will be chosen based on the 0.0001 and 0.9999 quantiles of the
marginal distributions of each count, using the minimum over counts of the
former and the maximum over counts of the latter.
</p>
<p>The summation over N uses the efficient method given by Meehan et al. (2020,
see Appendix B) for the basic Poisson-Binomial case, extended for the
overdispersion cases in Goldstein and de Valpine (2022).
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in <code>nimble</code> model code,
</p>
<p><code>observedCounts[i, 1:T] ~ dNmixture_v(lambda[i],
prob[i, 1:T],
Nmin, Nmax, T)</code>
</p>
<p>declares that the <code>observedCounts[i, 1:T]</code> (observed counts
for site <code>i</code>, for example) vector follows an N-mixture
distribution with parameters as indicated, assuming all the
parameters have been declared elsewhere in the model. As above,
<code>lambda[i]</code> is the mean of the abundance distribution at site
i, <code>prob[i, 1:T]</code> is a vector of detection probabilities at
site i, and <code>T</code> is the number of observation occasions. This
will invoke (something like) the following call to
<code>dNmixture_v</code> when <code>nimble</code> uses the model such as for
MCMC:
</p>
<p><code>dNmixture_v(observedCounts[i, 1:T], lambda[i],
prob[i, 1:T],
Nmin, Nmax, T, log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration
needs to generate a random draw for <code>observedCounts[1:T]</code>, it
will make a similar invocation of <code>rNmixture_v</code>, with <code>n = 1</code>.
</p>
<p>If the observation probabilities are visit-independent, one would use:
</p>
<p><code>observedCounts[1:T] ~ dNmixture_s(observedCounts[i, 1:T], lambda[i],
prob[i],
Nmin, Nmax, T)</code>
</p>


<h3>Value</h3>

<p>For <code>dNmixture_s</code> and <code>dNmixture_v</code>: the probability (or likelihood) or log
probability of observation vector <code>x</code>.
</p>
<p>For <code>rNmixture_s</code> and <code>rNmixture_v</code>: a simulated detection history, <code>x</code>.
</p>


<h3>Notes for use with automatic differentiation</h3>

<p>The N-mixture distributions are the only ones in <code>nimbleEcology</code> for which
one must use different versions when AD support is needed. See
<code><a href="#topic+dNmixtureAD">dNmixtureAD</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Lauren Ponisio, and Perry de Valpine
</p>


<h3>References</h3>

<p>D. Turek, P. de Valpine and C. J. Paciorek. 2016. Efficient Markov chain Monte
Carlo sampling for hierarchical hidden Markov models. Environmental and
Ecological Statistics 23:549–564. DOI 10.1007/s10651-016-0353-z
</p>
<p>Meehan, T. D., Michel, N. L., &amp; Rue, H. 2020. Estimating Animal Abundance
with N-Mixture Models Using the R—INLA Package for R. Journal of Statistical
Software, 95(2). https://doi.org/10.18637/jss.v095.i02
</p>
<p>Goldstein, B.R., and P. de Valpine. 2022. Comparing N-mixture Models and
GLMMs for Relative Abundance Estimation in a Citizen Science Dataset.
Scientific Reports 12: 12276. DOI:10.1038/s41598-022-16368-z
</p>


<h3>See Also</h3>

<p>For occupancy models dealing with detection/nondetection data,
see <code><a href="#topic+dOcc">dOcc</a></code>.
For dynamic occupancy, see <code><a href="#topic+dDynOcc">dDynOcc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
len &lt;- 5 # length of dataset
dat &lt;- c(1,2,0,1,5) # A vector of observations
lambda &lt;- 10 # mean abundance
prob &lt;- c(0.2, 0.3, 0.2, 0.1, 0.4) # A vector of detection probabilities

# Define code for a nimbleModel
 nc &lt;- nimbleCode({
   x[1:5] ~ dNmixture_v(lambda, prob = prob[1:5],
                        Nmin = -1, Nmax = -1, len = 5)

   lambda ~ dunif(0, 1000)

   for (i in 1:5) {
     prob[i] ~ dunif(0, 1)
   }
 })

# Build the model
nmix &lt;- nimbleModel(nc,
                    data = list(x = dat),
                    inits = list(lambda = lambda,
                                 prob = prob))
# Calculate log probability of data from the model
nmix$calculate()
# Use the model for a variety of other purposes...
</code></pre>

<hr>
<h2 id='dNmixture_steps'>Internal helper nimbleFunctions for dNmixture distributions</h2><span id='topic+dNmixture_steps'></span><span id='topic+nimNmixPois_logFac'></span><span id='topic+dNmixture_BNB_steps'></span><span id='topic+dNmixture_BBP_steps'></span><span id='topic+dNmixture_BBNB_steps'></span>

<h3>Description</h3>

<p>None of these functions should be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimNmixPois_logFac(numN, ff, max_index = -1)

dNmixture_steps(
  x,
  lambda,
  Nmin,
  Nmax,
  sum_log_one_m_prob,
  sum_log_dbinom,
  usingAD = FALSE
)

dNmixture_BNB_steps(
  x,
  lambda,
  theta,
  Nmin,
  Nmax,
  sum_log_one_m_prob,
  sum_log_dbinom,
  usingAD = FALSE
)

dNmixture_BBP_steps(
  x,
  beta_m_x,
  lambda,
  s,
  Nmin,
  Nmax,
  sum_log_dbetabinom,
  usingAD = FALSE
)

dNmixture_BBNB_steps(
  x,
  beta_m_x,
  lambda,
  theta,
  s,
  Nmin,
  Nmax,
  sum_log_dbetabinom,
  usingAD = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dNmixture_steps_+3A_numn">numN</code></td>
<td>
<p>number of indices in the truncated sum for the N-mixture.</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_ff">ff</code></td>
<td>
<p>a derived vector of units calculated partway through the fast
N-mixture algorithm.</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_max_index">max_index</code></td>
<td>
<p>possibly the index of the max contribution to the summation.
For AD cases this is set by heuristic. For non-AD cases it is -1 and will
be determined automatically.</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_x">x</code></td>
<td>
<p>x from dNmixture distributions</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_lambda">lambda</code></td>
<td>
<p>lambda from dNmixture distributions</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_nmin">Nmin</code></td>
<td>
<p>start of summation over N</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_nmax">Nmax</code></td>
<td>
<p>end of summation over N</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_sum_log_one_m_prob">sum_log_one_m_prob</code></td>
<td>
<p>sum(log(1-prob)) from relevant dNmixture cases</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_sum_log_dbinom">sum_log_dbinom</code></td>
<td>
<p>sum(log(dbinom(...))) from relevant dNmixture cases</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_usingad">usingAD</code></td>
<td>
<p>TRUE if called from one of the dNmixtureAD distributions</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_theta">theta</code></td>
<td>
<p>theta from relevant dNmixture distributions</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_beta_m_x">beta_m_x</code></td>
<td>
<p>beta-x from relevant dNmixture cases</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_s">s</code></td>
<td>
<p>s from relevant dNmixture distributions</p>
</td></tr>
<tr><td><code id="dNmixture_steps_+3A_sum_log_dbetabinom">sum_log_dbetabinom</code></td>
<td>
<p>sum(log(dBetaBinom(...))) from relevant dNmixture
cases</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are helper functions for the N-mixture calculations. They
don't have an interpretation outside of that context and are not intended
to be called directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dNmixture">dNmixture</a></code>
</p>

<hr>
<h2 id='dNmixtureAD'>N-mixture distributions with AD support for use in <code>nimble</code> models</h2><span id='topic+dNmixtureAD'></span><span id='topic+dNmixtureAD_s'></span><span id='topic+dNmixtureAD_v'></span><span id='topic+rNmixtureAD_s'></span><span id='topic+rNmixtureAD_v'></span><span id='topic+dNmixtureAD_BNB_v'></span><span id='topic+dNmixtureAD_BNB_s'></span><span id='topic+dNmixtureAD_BNB_oneObs'></span><span id='topic+dNmixtureAD_BBP_v'></span><span id='topic+dNmixtureAD_BBP_s'></span><span id='topic+dNmixtureAD_BBP_oneObs'></span><span id='topic+dNmixtureAD_BBNB_v'></span><span id='topic+dNmixtureAD_BBNB_s'></span><span id='topic+rNmixtureAD_BBNB_oneObs'></span><span id='topic+rNmixtureAD_BNB_v'></span><span id='topic+rNmixtureAD_BNB_s'></span><span id='topic+rNmixtureAD_BNB_oneObs'></span><span id='topic+rNmixtureAD_BBP_v'></span><span id='topic+rNmixtureAD_BBP_s'></span><span id='topic+rNmixtureAD_BBP_oneObs'></span><span id='topic+rNmixtureAD_BBNB_v'></span><span id='topic+rNmixtureAD_BBNB_s'></span><span id='topic+dNmixtureAD_BBNB_oneObs'></span>

<h3>Description</h3>

<p><code>dNmixtureAD_s</code> and <code>dNmixtureAD_v</code> provide Poisson-Binomial
mixture distributions of abundance (&quot;N-mixture&quot;) for use in <code>nimble</code>
models when automatic differentiation may be needed by an algorithm.
Overdispersion alternatives are also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dNmixtureAD_v(x, lambda, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixtureAD_s(x, lambda, prob, Nmin = -1, Nmax = -1, len, log = 0)

rNmixtureAD_v(n, lambda, prob, Nmin, Nmax, len)

rNmixtureAD_s(n, lambda, prob, Nmin, Nmax, len)

dNmixtureAD_BNB_v(x, lambda, theta, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixtureAD_BNB_s(x, lambda, theta, prob, Nmin = -1, Nmax = -1, len, log = 0)

dNmixtureAD_BNB_oneObs(x, lambda, theta, prob, Nmin = -1, Nmax = -1, log = 0)

rNmixtureAD_BNB_oneObs(n, lambda, theta, prob, Nmin = -1, Nmax = -1)

dNmixtureAD_BBP_v(x, lambda, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixtureAD_BBP_s(x, lambda, prob, s, Nmin = -1, Nmax = -1, len, log = 0)

dNmixtureAD_BBP_oneObs(x, lambda, prob, s, Nmin = -1, Nmax = -1, log = 0)

dNmixtureAD_BBNB_v(
  x,
  lambda,
  theta,
  prob,
  s,
  Nmin = -1,
  Nmax = -1,
  len,
  log = 0
)

dNmixtureAD_BBNB_s(
  x,
  lambda,
  theta,
  prob,
  s,
  Nmin = -1,
  Nmax = -1,
  len,
  log = 0
)

dNmixtureAD_BBNB_oneObs(
  x,
  lambda,
  theta,
  prob,
  s,
  Nmin = -1,
  Nmax = -1,
  log = 0
)

rNmixtureAD_BNB_v(n, lambda, theta, prob, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BNB_s(n, lambda, theta, prob, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BNB_oneObs(n, lambda, theta, prob, Nmin = -1, Nmax = -1)

rNmixtureAD_BBP_v(n, lambda, prob, s, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BBP_s(n, lambda, prob, s, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BBP_oneObs(n, lambda, prob, s, Nmin = -1, Nmax = -1)

rNmixtureAD_BBNB_v(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BBNB_s(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1, len)

rNmixtureAD_BBNB_oneObs(n, lambda, theta, prob, s, Nmin = -1, Nmax = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dNmixtureAD_+3A_x">x</code></td>
<td>
<p>vector of integer counts from a series of sampling occasions.</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_lambda">lambda</code></td>
<td>
<p>expected value of the Poisson distribution of true abundance</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_prob">prob</code></td>
<td>
<p>detection probability (scalar for <code>dNmixture_s</code>, vector for <code>dNmixture_v</code>).</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_nmin">Nmin</code></td>
<td>
<p>minimum abundance to sum over for the mixture probability. Must be provided.</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_nmax">Nmax</code></td>
<td>
<p>maximum abundance to sum over for the mixture probability. Must be provided.</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_len">len</code></td>
<td>
<p>The length of the x vector</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to return probability.</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the
argument exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_theta">theta</code></td>
<td>
<p>abundance overdispersion parameter required for negative binomial
(*NB) N-mixture models. theta is parameterized such that variance of
the negative binomial variable x is <code>lambda^2 * theta + lambda</code></p>
</td></tr>
<tr><td><code id="dNmixtureAD_+3A_s">s</code></td>
<td>
<p>detection overdispersion parameter required for beta binomial (BB*)
N-mixture models. s is parameterized such that variance of the beta
binomial variable x is <code>V(x) = N \* prob \* (1-prob) \* (N +
s) / (s + 1)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be
used directly in R or in <code>nimble</code> hierarchical models (via
<code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code> and
<code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>See <code><a href="#topic+dNmixture">dNmixture</a></code> for more information about the N-mixture
distributions.
</p>
<p>The versions here can be used in models that will be used by algorithms that
use nimble's system for automatic differentiation (AD). The primary
difference is that <code>Nmin</code> and <code>Nmax</code> must be provided. There are no
automatic defaults for these.
</p>
<p>In the AD system some kinds of values are &quot;baked in&quot; (cannot be changed) to
the AD calculations from the first call, unless and until the AD calculations
are reset. For all variants of the <code>dNmixtureAD</code> distributions, the
sizes of the inputs as well as <code>Nmin</code> and <code>Nmax</code> are baked in.
These can be different for different iterations through a for loop (or nimble
model declarations with different indices, for example), but the sizes and
<code>Nmin</code> and <code>Nmax</code> values for each specific iteration will be
&quot;baked in&quot; after the first call.
</p>


<h3>Value</h3>

<p>The probability (or likelihood) or log probability of an observation
vector <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Lauren Ponisio, and Perry de Valpine
</p>

<hr>
<h2 id='dOcc'>Occupancy distribution suitable for use in <code>nimble</code> models</h2><span id='topic+dOcc'></span><span id='topic+dOcc_s'></span><span id='topic+dOcc_v'></span><span id='topic+rOcc_s'></span><span id='topic+rOcc_v'></span>

<h3>Description</h3>

<p><code>dOcc_*</code> and <code>rOcc_*</code> provide occupancy model
distributions that can be used directly from R or in <code>nimble</code>
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dOcc_s(x, probOcc, probDetect, len = 0, log = 0)

dOcc_v(x, probOcc, probDetect, len = 0, log = 0)

rOcc_s(n, probOcc, probDetect, len = 0)

rOcc_v(n, probOcc, probDetect, len = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dOcc_+3A_x">x</code></td>
<td>
<p>detection/non-detection vector of 0s (not detected) and 1s
(detected).</p>
</td></tr>
<tr><td><code id="dOcc_+3A_probocc">probOcc</code></td>
<td>
<p>occupancy probability (scalar).</p>
</td></tr>
<tr><td><code id="dOcc_+3A_probdetect">probDetect</code></td>
<td>
<p>detection probability (scalar for <code>dOcc_s</code>,
vector for <code>dOcc_v</code>).</p>
</td></tr>
<tr><td><code id="dOcc_+3A_len">len</code></td>
<td>
<p>length of detection/non-detection vector (see below).</p>
</td></tr>
<tr><td><code id="dOcc_+3A_log">log</code></td>
<td>
<p>TRUE or 1 to return log probability. FALSE or 0 to
return probability.</p>
</td></tr>
<tr><td><code id="dOcc_+3A_n">n</code></td>
<td>
<p>number of random draws, each returning a vector of length
<code>len</code>. Currently only <code>n = 1</code> is supported, but the
argument exists for standardization of &quot;<code>r</code>&quot; functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These nimbleFunctions provide distributions that can be used directly in R or
in <code>nimble</code> hierarchical models (via <code><a href="nimble.html#topic+nimbleCode">nimbleCode</a></code>
and <code><a href="nimble.html#topic+nimbleModel">nimbleModel</a></code>).
</p>
<p>The probability of observation vector <code>x</code> depends on
occupancy probability, <code>probOcc</code>, and detection probability,
<code>probDetect</code> or <code>probDetect[1:T]</code>.
</p>
<p>The letter following the 'dOcc_' indicates whether detection probability is
scalar (s, meaning <code>probDetect</code> is detection probability for every
<code>x[t]</code>) or vector (v, meaning <code>probDetect[t]</code> is detection
probability for <code>x[t]</code>).
</p>
<p>When used directly from R, the <code>len</code> argument to <code>dOcc_*</code> is not
necessary. It will default to the length of <code>x</code>.  When used in
<code>nimble</code> model code (via <code>nimbleCode</code>), <code>len</code> must be provided
(even though it may seem redundant).
</p>
<p>For more explanation, see package vignette
(<code>vignette("Introduction_to_nimbleEcology")</code>).
</p>
<p>Compared to writing <code>nimble</code> models with a discrete latent state for
true occupancy status and a separate scalar datum for each observation, use
of these distributions allows one to directly sum (marginalize) over the
discrete latent state and calculate the probability of all observations from
one site jointly.
</p>
<p>These are <code>nimbleFunction</code>s written in the format of user-defined
distributions for NIMBLE's extension of the BUGS model language. More
information can be found in the NIMBLE User Manual at
<a href="https://r-nimble.org">https://r-nimble.org</a>.
</p>
<p>When using these distributions in a <code>nimble</code> model, the left-hand side
will be used as <code>x</code>, and the user should not provide the <code>log</code>
argument.
</p>
<p>For example, in <code>nimble</code> model code,
</p>
<p><code>detections[i, 1:T] ~ dOcc_s(occupancyProbability,
detectionProbability, T)</code>
</p>
<p>declares that <code>detections[i, 1:T]</code> (detection history at site <code>i</code>,
for example) follows an occupancy distribution with parameters as indicated,
assuming all the parameters have been declared elsewhere in the model.  This
will invoke (something like) the following call to <code>dOcc_s</code> when
<code>nimble</code> uses the model such as for MCMC:
</p>
<p><code>dOcc_s(detections[i, 1:T], occupancyProbability,
detectionProbability, len = T, log = TRUE)</code>
</p>
<p>If an algorithm using a <code>nimble</code> model with this declaration
needs to generate a random draw for <code>detections[i, 1:T]</code>, it
will make a similar invocation of <code>rOcc_s</code>, with <code>n = 1</code>.
</p>
<p>If the detection probabilities are time-dependent, use:
</p>
<p><code>detections[i, 1:T] ~ dOcc_v(occupancyProbability,
detectionProbability[1:T], len = T)</code>
</p>


<h3>Value</h3>

<p>For <code>dOcc_*</code>: the probability (or likelihood) or log probability of observation vector <code>x</code>.
</p>
<p>For <code>rOcc_*</code>: a simulated detection history, <code>x</code>.
</p>


<h3>Notes for use with automatic differentiation</h3>

<p>The <code>dOcc_*</code> distributions should all work for models and algorithms
that use nimble's automatic differentiation (AD) system. In that system, some
kinds of values are &quot;baked in&quot; (cannot be changed) to the AD calculations
from the first call, unless and until the AD calculations are reset. For the
<code>dOcc_*</code> distributions, the lengths of vector inputs are baked in. These
can be different for different iterations through a for loop (or nimble model
declarations with different indices, for example), but the lengths for each
specific iteration will be &quot;baked in&quot; after the first call. <b>It is
safest if one can assume that <code>x</code> are data and are not going to change.</b>
</p>


<h3>Author(s)</h3>

<p>Ben Goldstein, Perry de Valpine, and Lauren Ponisio
</p>


<h3>See Also</h3>

<p>For dynamic occupancy models, see documentation for
<code><a href="#topic+dDynOcc">dDynOcc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up constants and initial values for defining the model
dat &lt;- c(1,1,0,0) # A vector of observations
probOcc &lt;- 0.6
probDetect &lt;- 0.4


# Define code for a nimbleModel
nc &lt;- nimbleCode({
  x[1:4] ~ dOcc_s(probOcc, probDetect, len = 4)
  probOcc ~ dunif(0,1)
  probDetect ~ dunif(0,1)
})

# Build the model, providing data and initial values
Occ_model &lt;- nimbleModel(nc, data = list(x = dat),
                         inits = list(probOcc = probOcc,
                                      probDetect = probDetect))

# Calculate log probability of data from the model
Occ_model$calculate()
# Use the model for a variety of other purposes...
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
