<!DOCTYPE html><html lang="en"><head><title>Help for package rayimage</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rayimage}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_image_overlay'><p>Add Overlay (Deprecated)</p></a></li>
<li><a href='#add_multi_padding'><p>add_multi_padding</p></a></li>
<li><a href='#add_padding'><p>add_padding</p></a></li>
<li><a href='#add_title'><p>Add Title Function (deprecated)</p></a></li>
<li><a href='#add_vignette'><p>Add Vignette Effect (Deprecated)</p></a></li>
<li><a href='#calc_bokeh_size'><p>Calculate Bokeh Size</p></a></li>
<li><a href='#convert_color'><p>Convert Color</p></a></li>
<li><a href='#convert_to_native_raster'><p>Plot Image</p></a></li>
<li><a href='#dragon'><p>Dragon Image</p></a></li>
<li><a href='#dragondepth'><p>Dragon Depthmap</p></a></li>
<li><a href='#expand_to_fit'><p>expand to fit</p></a></li>
<li><a href='#fliplr'><p>Flip Left-Right</p></a></li>
<li><a href='#flipud'><p>Flip Up-Down</p></a></li>
<li><a href='#generate_2d_disk'><p>Generate 2D Disk</p></a></li>
<li><a href='#generate_2d_exponential'><p>Generate 2D exponential Distribution</p></a></li>
<li><a href='#generate_2d_gaussian'><p>Generate 2D Gaussian Distribution</p></a></li>
<li><a href='#get_file_type'><p>Check Filename</p></a></li>
<li><a href='#get_string_dimensions'><p>Get String Dimensions</p></a></li>
<li><a href='#handle_image_output'><p>Handle Image Output</p></a></li>
<li><a href='#interpolate_array'><p>Matrix/Array Interpolation</p></a></li>
<li><a href='#make_vignette_overlay'><p>Make Vignette Overlay</p></a></li>
<li><a href='#pad_to_fit'><p>pad to fit</p></a></li>
<li><a href='#plot_asp_native_raster'><p>Plot Native Raster with Custom Aspect Ratio</p></a></li>
<li><a href='#plot_image'><p>Plot Image</p></a></li>
<li><a href='#plot_image_grid'><p>Plot Image Grid</p></a></li>
<li><a href='#preview_focus'><p>Preview Focus</p></a></li>
<li><a href='#ray_read_image'><p>Read Image</p></a></li>
<li><a href='#ray_write_image'><p>Write Image</p></a></li>
<li><a href='#render_bokeh'><p>Render Bokeh</p></a></li>
<li><a href='#render_boolean_distance'><p>Render Boolean Distance</p></a></li>
<li><a href='#render_bw'><p>Render Black and White</p></a></li>
<li><a href='#render_clamp'><p>Clamp Image</p></a></li>
<li><a href='#render_convolution'><p>Render Convolution</p></a></li>
<li><a href='#render_convolution_fft'><p>Render Convolution FFT</p></a></li>
<li><a href='#render_image_overlay'><p>Add Overlay</p></a></li>
<li><a href='#render_reorient'><p>Reorient Image</p></a></li>
<li><a href='#render_resized'><p>Resize Image</p></a></li>
<li><a href='#render_text_image'><p>Generate Text Image</p></a></li>
<li><a href='#render_title'><p>Render a Title on an Image</p></a></li>
<li><a href='#render_vignette'><p>Add Vignette Effect</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#save_png'><p>Save PNG</p></a></li>
<li><a href='#trim_padding'><p>trim_padding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Image Processing for Simulated Cameras</td>
</tr>
<tr>
<td>Version:</td>
<td>0.15.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses convolution-based techniques to generate simulated camera bokeh, depth of field, and other camera effects, using an image and an optional depth map. Accepts both filename inputs and in-memory array representations of images and matrices. Includes functions to perform 2D convolutions, reorient and resize images/matrices, add image and text overlays, generate camera vignette effects, and add titles to images. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, png, jpeg, grDevices, grid, tiff, systemfonts</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magick, testthat (&ge; 3.0.0), ragg</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, progress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rayimage.dev">https://www.rayimage.dev</a>,
<a href="https://github.com/tylermorganwall/rayimage">https://github.com/tylermorganwall/rayimage</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/rayimage/issues">https://github.com/tylermorganwall/rayimage/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/build/compilation-database:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 21:26:23 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Sean Barrett [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-01 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_image_overlay'>Add Overlay (Deprecated)</h2><span id='topic+add_image_overlay'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_image_overlay(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_image_overlay_+3A_...">...</code></td>
<td>
<p>to pass to <code>render_image_overlay()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(run_documentation()){
#Add an overlay of a red semi-transparent circle:
circlemat = generate_2d_disk(min(dim(dragon)[1:2]))
circlemat = circlemat/max(circlemat)

#Create RGBA image, with a transparency of 0.5
rgba_array = array(1, dim=c(nrow(circlemat),ncol(circlemat),4))
rgba_array[,,1] = circlemat
rgba_array[,,2] = 0
rgba_array[,,3] = 0
dragon_clipped = dragon
dragon_clipped[dragon_clipped &gt; 1] = 1
add_image_overlay(dragon_clipped, image_overlay = rgba_array,
                 alpha=0.5, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='add_multi_padding'>add_multi_padding</h2><span id='topic+add_multi_padding'></span>

<h3>Description</h3>

<p>Adds multiple levels padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_multi_padding(input, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_multi_padding_+3A_input">input</code></td>
<td>
<p>A two-dimensional matrix.</p>
</td></tr>
<tr><td><code id="add_multi_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with edges padded
</p>

<hr>
<h2 id='add_padding'>add_padding</h2><span id='topic+add_padding'></span>

<h3>Description</h3>

<p>Adds padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_padding(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_padding_+3A_input">input</code></td>
<td>
<p>A two-dimensional matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with edges padded
</p>

<hr>
<h2 id='add_title'>Add Title Function (deprecated)</h2><span id='topic+add_title'></span>

<h3>Description</h3>

<p>Add Title Function (deprecated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_title(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_title_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>render_title()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-layer RGB array of the processed image if <code>filename = NULL</code> and <code>preview = FALSE</code>.
Otherwise, writes the image to the specified file or displays it if <code>preview = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Deprecated add_title function. Will display a warning.
if(run_documentation()) {
render_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20)
}
</code></pre>

<hr>
<h2 id='add_vignette'>Add Vignette Effect (Deprecated)</h2><span id='topic+add_vignette'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds a camera vignette effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vignette(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_vignette_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>render_title()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(run_documentation()){
#Add a vignette effect:
add_vignette(dragon, preview = TRUE, vignette = 0.5)
}
</code></pre>

<hr>
<h2 id='calc_bokeh_size'>Calculate Bokeh Size</h2><span id='topic+calc_bokeh_size'></span>

<h3>Description</h3>

<p>Calculates the amount of blurring at each point with camera characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_bokeh_size(z, zfocus, f, N, ramp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_bokeh_size_+3A_z">z</code></td>
<td>
<p>Depth matrix.</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_zfocus">zfocus</code></td>
<td>
<p>Depth in which to blur. Minimum 0, maximum 1.</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_f">f</code></td>
<td>
<p>Focal length of the virtual camera. .</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_n">N</code></td>
<td>
<p>F-stop. Focal length of the virtual camera.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of bokeh sizes.
</p>

<hr>
<h2 id='convert_color'>Convert Color</h2><span id='topic+convert_color'></span>

<h3>Description</h3>

<p>Convert Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_color(color, as_hex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_color_+3A_color">color</code></td>
<td>
<p>The color to convert. Can be either a hexadecimal code, or a numeric rgb
vector listing three intensities between <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#none
</code></pre>

<hr>
<h2 id='convert_to_native_raster'>Plot Image</h2><span id='topic+convert_to_native_raster'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_native_raster(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_native_raster_+3A_input">input</code></td>
<td>
<p>Array to get converted to a native raster</p>
</td></tr>
</table>

<hr>
<h2 id='dragon'>Dragon Image</h2><span id='topic+dragon'></span>

<h3>Description</h3>

<p>Dragon Image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dragon
</code></pre>


<h3>Format</h3>

<p>An RGB 3-layer HDR array with 200 rows and 200 columns,
generated using the rayrender package.
</p>

<hr>
<h2 id='dragondepth'>Dragon Depthmap</h2><span id='topic+dragondepth'></span>

<h3>Description</h3>

<p>Dragon Depthmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dragondepth
</code></pre>


<h3>Format</h3>

<p>An matrix with 200 rows and 200 columns, representing
the depth into the <code>dragon</code> image scene. Generated using the rayrender package.
Distances range from 847 to 1411.
</p>

<hr>
<h2 id='expand_to_fit'>expand to fit</h2><span id='topic+expand_to_fit'></span>

<h3>Description</h3>

<p>Pads to a rect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_to_fit(dim, kernel)
</code></pre>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

<hr>
<h2 id='fliplr'>Flip Left-Right</h2><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Flip Left-Right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fliplr_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='flipud'>Flip Up-Down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip Up-Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_2d_disk'>Generate 2D Disk</h2><span id='topic+generate_2d_disk'></span>

<h3>Description</h3>

<p>Generates a 2D disk with a gradual falloff.
</p>
<p>Disk generated using the following formula:
</p>
(-22.35 * cos(1.68 * r<sup>2</sup>) + 85.91 * sin(1.68 * r<sup>2</sup>) ) * exp(-4.89 * r<sup>2</sup>) +
(35.91 * cos(4.99 * r<sup>2</sup>) - 28.87 * sin(4.99 * r<sup>2</sup>)) * exp(-4.71 * r<sup>2</sup>) +
(-13.21 * cos(8.24 * r<sup>2</sup>) - 1.57 * sin(8.24 * r<sup>2</sup>)) * exp(-4.05 * r<sup>2</sup>) +
(0.50 * cos(11.90 * r<sup>2</sup>) + 1.81 * sin(11.90 * r<sup>2</sup>)) * exp(-2.92 * r<sup>2</sup>) +
(0.13 * cos(16.11 * r<sup>2</sup>) - 0.01 * sin(16.11 * r<sup>2</sup>)) * exp(-1.51 * r<sup>2</sup>)
<p>The origin of the coordinate system is the center of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_disk(dim = c(11, 11), radius = 1, rescale_unity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_2d_disk_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_disk_+3A_radius">radius</code></td>
<td>
<p>Default <code>1</code>. Radius of the disk, compared to the dimensions. Should be less than one.</p>
</td></tr>
<tr><td><code id="generate_2d_disk_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
image(generate_2d_disk(101), asp=1)
}
</code></pre>

<hr>
<h2 id='generate_2d_exponential'>Generate 2D exponential Distribution</h2><span id='topic+generate_2d_exponential'></span>

<h3>Description</h3>

<p>Generates a 2D exponential distribution, with an optional
argument to take the exponential to a user-defined power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_exponential(
  falloff = 1,
  dim = c(11, 11),
  width = 3,
  rescale_unity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_2d_exponential_+3A_falloff">falloff</code></td>
<td>
<p>Default <code>1</code>. Falloff of the exponential.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_width">width</code></td>
<td>
<p>Default <code>3</code> (<code>-10</code> to <code>10</code>). The range in which to compute the distribution.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
image(generate_2d_exponential(1,31,3), asp=1)
}
</code></pre>

<hr>
<h2 id='generate_2d_gaussian'>Generate 2D Gaussian Distribution</h2><span id='topic+generate_2d_gaussian'></span>

<h3>Description</h3>

<p>Generates a 2D gaussian distribution, with an optional
argument to take the gaussian to a user-defined power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_gaussian(
  sd = 1,
  power = 1,
  dim = c(11, 11),
  width = 3,
  rescale_unity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_2d_gaussian_+3A_sd">sd</code></td>
<td>
<p>Default <code>1</code>. Standard deviation of the normal distribution</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_power">power</code></td>
<td>
<p>Default <code>1</code>. Power to take the distribution. Higher values will result in a sharper peak.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_width">width</code></td>
<td>
<p>Default <code>3</code> (<code>-10</code> to <code>10</code>). The range in which to compute the distribution.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
image(generate_2d_gaussian(1,1,31), asp=1)
}
</code></pre>

<hr>
<h2 id='get_file_type'>Check Filename</h2><span id='topic+get_file_type'></span>

<h3>Description</h3>

<p>Check Filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_file_type(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_file_type_+3A_file">file</code></td>
<td>
<p>Filename to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='get_string_dimensions'>Get String Dimensions</h2><span id='topic+get_string_dimensions'></span>

<h3>Description</h3>

<p>Calculates font metrics for a specified font, font size, and style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_string_dimensions(string, font = "sans", size = 12, align = "center", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_string_dimensions_+3A_string">string</code></td>
<td>
<p>The string to be measured.</p>
</td></tr>
<tr><td><code id="get_string_dimensions_+3A_font">font</code></td>
<td>
<p>Default <code>"sans"</code>.</p>
</td></tr>
<tr><td><code id="get_string_dimensions_+3A_size">size</code></td>
<td>
<p>A numeric value specifying the size of the font in points.</p>
</td></tr>
<tr><td><code id="get_string_dimensions_+3A_align">align</code></td>
<td>
<p>Default '&quot;left&quot;&ldquo;. The string alignment.</p>
</td></tr>
<tr><td><code id="get_string_dimensions_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to 'systemfonts::shape_string()&ldquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function renders specific characters (<code>"d"</code> for ascender, <code>"g"</code> for descender, <code>"x"</code> for neutral) using the specified font parameters. It calculates the bounding box of each character to determine the necessary adjustments for accurate text positioning.
</p>


<h3>Value</h3>

<p>A data.frame listing the string dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get height of basic sans font
get_string_dimensions("This is a string", size=24)
</code></pre>

<hr>
<h2 id='handle_image_output'>Handle Image Output</h2><span id='topic+handle_image_output'></span>

<h3>Description</h3>

<p>Handles image output logic: returning, saving to a file, or previewing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_image_output(image, filename = NULL, preview = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_image_output_+3A_image">image</code></td>
<td>
<p>3D array. The image data.</p>
</td></tr>
<tr><td><code id="handle_image_output_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. String specifying the file path to save the image.
If <code>NULL</code>, the image is returned or displayed.</p>
</td></tr>
<tr><td><code id="handle_image_output_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, the image is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>filename = NULL</code> and <code>preview = FALSE</code>, returns the image array invisibly.
Otherwise, saves to file or displays the image.
</p>

<hr>
<h2 id='interpolate_array'>Matrix/Array Interpolation</h2><span id='topic+interpolate_array'></span>

<h3>Description</h3>

<p>Given a series of X and Y coordinates and an array/matrix, interpolates the Z coordinate
using bilinear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_array(image, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_array_+3A_image">image</code></td>
<td>
<p>Image filename, a matrix, or a 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="interpolate_array_+3A_x">x</code></td>
<td>
<p>X indices (or fractional index) to interpolate.</p>
</td></tr>
<tr><td><code id="interpolate_array_+3A_y">y</code></td>
<td>
<p>Y indices (or fractional index) to interpolate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector of values (if image is a matrix) or a list of interpolated values
from each layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#if(interactive()){
#Interpolate a matrix
interpolate_array(volcano,c(10,10.1,11),c(30,30.5,33))
#Interpolate a 3-layer array (returns list for each channel)
interpolate_array(dragon,c(10,10.1,11),c(30,30.5,33))
#end}
</code></pre>

<hr>
<h2 id='make_vignette_overlay'>Make Vignette Overlay</h2><span id='topic+make_vignette_overlay'></span>

<h3>Description</h3>

<p>Makes an overlay to simulate vignetting in a camera
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_vignette_overlay(
  width,
  height,
  intensity = 0.3,
  radius_multiplier = 1.3,
  radius = NULL,
  color = "#000000"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_vignette_overlay_+3A_width">width</code></td>
<td>
<p>Width of the image.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_height">height</code></td>
<td>
<p>Height of the image.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_intensity">intensity</code></td>
<td>
<p>Default <code>0.4</code>. <code>1</code> is max intensity, <code>0</code> is min.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_radius_multiplier">radius_multiplier</code></td>
<td>
<p>Default <code>1.3</code>.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_radius">radius</code></td>
<td>
<p>Default <code>NULL</code>. Max of height or width, divided by 2.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_color">color</code></td>
<td>
<p>Default <code>black</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pad_to_fit'>pad to fit</h2><span id='topic+pad_to_fit'></span>

<h3>Description</h3>

<p>Pads to a rect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_to_fit(dim, kernel)
</code></pre>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

<hr>
<h2 id='plot_asp_native_raster'>Plot Native Raster with Custom Aspect Ratio</h2><span id='topic+plot_asp_native_raster'></span>

<h3>Description</h3>

<p>Plot Native Raster with Custom Aspect Ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_asp_native_raster(
  nr,
  asp = 1,
  show = FALSE,
  return_grob = FALSE,
  gp = grid::gpar()
)
</code></pre>

<hr>
<h2 id='plot_image'>Plot Image</h2><span id='topic+plot_image'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_image(
  image,
  rotate = 0,
  draw_grid = FALSE,
  ignore_alpha = FALSE,
  asp = 1,
  new_page = TRUE,
  return_grob = FALSE,
  gp = grid::gpar()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_image_+3A_image">image</code></td>
<td>
<p>Image array or filename of an image to be plotted.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_draw_grid">draw_grid</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will draw a grid in the background to help
disambiguate the actual image from the device (helpful if the image background is the same as the
device's background).</p>
</td></tr>
<tr><td><code id="plot_image_+3A_ignore_alpha">ignore_alpha</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to ignoe the alpha channel when plotting.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_asp">asp</code></td>
<td>
<p>Default <code>1</code>. Aspect ratio of the pixels in the plot. For example, an aspect ratio of <code>4/3</code> will
slightly widen the image.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_new_page">new_page</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to call <code>grid::grid.newpage()</code> before plotting the image.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_return_grob">return_grob</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to return the grob object.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_gp">gp</code></td>
<td>
<p>A <code>grid::gpar()</code> object to include for the grid viewport displaying the image.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#if(interactive()){
#Plot the dragon array
plot_image(dragon)
#Make pixels twice as wide as tall
plot_image(dragon, asp = 2)
#Plot non-square images
plot_image(dragon[1:100,,])
#Make pixels twice as tall as wide
plot_image(dragon[1:100,,], asp = 1/2)
#end}
</code></pre>

<hr>
<h2 id='plot_image_grid'>Plot Image Grid</h2><span id='topic+plot_image_grid'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_image_grid(
  input_list,
  dim = c(1, 1),
  asp = 1,
  draw_grid = FALSE,
  gp = grid::gpar()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_image_grid_+3A_input_list">input_list</code></td>
<td>
<p>List of array (or matrix) image inputs.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(1,1)</code>. Width by height of output grid.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_asp">asp</code></td>
<td>
<p>Default <code>1</code>. Aspect ratio of the pixels(s). For example, an aspect ratio of <code>4/3</code> will
slightly widen the image. This can also be a vector the same length of
<code>input_list</code> to specify an aspect ratio for each image in the grid.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_draw_grid">draw_grid</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will draw a grid in the background to help
disambiguate the actual image from the device (helpful if the image background is the same as the
device's background).</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_gp">gp</code></td>
<td>
<p>A <code>grid::gpar()</code> object to include for the grid viewport displaying the image.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon array
plot_image_grid(list(dragon, 1-dragon), dim = c(1,2))
}
if(run_documentation()){
plot_image_grid(list(dragon, 1-dragon), dim = c(2,1))
}
if(run_documentation()){
plot_image_grid(list(dragon, NULL, 1-dragon), dim = c(2,2), asp = c(2,1,1/2))
}
if(run_documentation()){
plot_image_grid(list(dragon, NULL, NULL, dragon), dim = c(2,2), asp = c(2,1,1,1/2))
}
if(run_documentation()){
#Plot alongside the depth matrix
dragon_depth_reoriented = render_reorient(dragondepth,
                                         transpose = TRUE,
                                         flipx = TRUE)/2000
plot_image_grid(list(dragondepth/2000, dragon, dragon, dragondepth/2000),
               dim = c(2,2))
}
</code></pre>

<hr>
<h2 id='preview_focus'>Preview Focus</h2><span id='topic+preview_focus'></span>

<h3>Description</h3>

<p>Displays the focal point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview_focus(image, depthmap, focus, imagetype, depthtype)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preview_focus_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="preview_focus_+3A_depthmap">depthmap</code></td>
<td>
<p>Depth map filename or 1d array.</p>
</td></tr>
<tr><td><code id="preview_focus_+3A_focus">focus</code></td>
<td>
<p>Defaults <code>0.5</code>. Depth in which to blur. Minimum 0, maximum 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Plot the dragon
</code></pre>

<hr>
<h2 id='ray_read_image'>Read Image</h2><span id='topic+ray_read_image'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_read_image(image, convert_to_array = TRUE, preview = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray_read_image_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="ray_read_image_+3A_convert_to_array">convert_to_array</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to convert 2D B&amp;W images/matrices to RGBA arrays.</p>
</td></tr>
<tr><td><code id="ray_read_image_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
<tr><td><code id="ray_read_image_+3A_...">...</code></td>
<td>
<p>Arguments to pass to either <code>jpeg::readJPEG</code>, <code>png::readPNG</code>, or <code>tiff::readTIFF</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Write as a png
tmparr = tempfile(fileext=".png")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr)
ray_read_image(tmparr) |&gt;
 plot_image()
}
if(run_documentation()){
#Write as a JPEG (passing quality arguments via ...)
tmparr = tempfile(fileext=".jpg")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr, quality = 0.2)
ray_read_image(tmparr) |&gt;
 plot_image()
}
if(run_documentation()){
#Write as a tiff
tmparr = tempfile(fileext=".tiff")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr)
ray_read_image(tmparr) |&gt;
  plot_image()
}
</code></pre>

<hr>
<h2 id='ray_write_image'>Write Image</h2><span id='topic+ray_write_image'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and writes it to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray_write_image(image, filename, clamp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ray_write_image_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="ray_write_image_+3A_filename">filename</code></td>
<td>
<p>File to write to, with filetype determined by extension. Filetype can be
<code>PNG</code>, <code>JPEG</code>, or <code>TIFF</code>.</p>
</td></tr>
<tr><td><code id="ray_write_image_+3A_clamp">clamp</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to clamp the image to 0-1. If the file extension is <code>PNG</code> of <code>JPEG</code>,
this is forced to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ray_write_image_+3A_...">...</code></td>
<td>
<p>Arguments to pass to either <code>jpeg::writeJPEG</code>, <code>png::writePNG</code>, or <code>tiff::writeTIFF</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Write as a png
tmparr = tempfile(fileext=".png")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr)
ray_read_image(tmparr) |&gt;
 plot_image()
}
if(run_documentation()){
#Write as a JPEG (passing quality arguments via ...)
tmparr = tempfile(fileext=".jpg")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr, quality = 0.2)
ray_read_image(tmparr) |&gt;
 plot_image()
}
if(run_documentation()){
#Write as a tiff
tmparr = tempfile(fileext=".tiff")
ray_read_image(dragon) |&gt;
 ray_write_image(tmparr)
ray_read_image(tmparr) |&gt;
  plot_image()
}
</code></pre>

<hr>
<h2 id='render_bokeh'>Render Bokeh</h2><span id='topic+render_bokeh'></span>

<h3>Description</h3>

<p>Takes an image and a depth map to render the image with depth of field
(i.e. similar to &quot;Portrait Mode&quot; in an iPhone). User can specify a custom bokeh shape,
or use one of the built-in bokeh types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_bokeh(
  image,
  depthmap,
  focus = 0.5,
  focallength = 100,
  fstop = 4,
  filename = NULL,
  preview = TRUE,
  preview_focus = FALSE,
  bokehshape = "circle",
  bokehintensity = 1,
  bokehlimit = 0.8,
  rotation = 0,
  aberration = 0,
  gamma_correction = TRUE,
  progress = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_bokeh_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_depthmap">depthmap</code></td>
<td>
<p>Depth map filename or 1d array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_focus">focus</code></td>
<td>
<p>Defaults <code>0.5</code>. Depth in which to blur.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_focallength">focallength</code></td>
<td>
<p>Default <code>100</code>. Focal length of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_fstop">fstop</code></td>
<td>
<p>Default <code>4</code>. F-stop of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_preview">preview</code></td>
<td>
<p>Default <code>TRUE</code>. If <code>FALSE</code>, it will not display the image and just return the RGB array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_preview_focus">preview_focus</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, a red line will be drawn across the image
showing where the camera will be focused.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehshape">bokehshape</code></td>
<td>
<p>Default <code>circle</code>. Also built-in: <code>hex</code>. The shape of the bokeh. If the user
passes in a 2D matrix, that matrix will control the shape of the bokeh.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehintensity">bokehintensity</code></td>
<td>
<p>Default <code>1</code>. Intensity of the bokeh when the pixel intensity is greater than <code>bokehlimit</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehlimit">bokehlimit</code></td>
<td>
<p>Default <code>0.8</code>. Limit after which the bokeh intensity is increased by <code>bokehintensity</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_rotation">rotation</code></td>
<td>
<p>Default <code>0</code>. Number of degrees to rotate the hexagonal bokeh shape.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_aberration">aberration</code></td>
<td>
<p>Default <code>0</code>. Adds chromatic aberration to the image. Maximum of <code>1</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>TRUE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_progress">progress</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to display a progress bar.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot_image()</code> if <code>preview = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(run_documentation()){
#Plot the depth map
plot_image(dragondepth/1500)
}
if(run_documentation()){
#Preview the focal plane:
render_bokeh(dragon, dragondepth, focus=950, preview_focus = TRUE)
}
if(run_documentation()){
#Change the focal length:
render_bokeh(dragon, dragondepth, focus=950, focallength=300)
}
if(run_documentation()){
#Add chromatic aberration:
render_bokeh(dragon, dragondepth, focus=950, focallength=300, aberration = 0.5)
}
if(run_documentation()){
#Change the focal distance:
render_bokeh(dragon, dragondepth, focus=600, focallength=300)
render_bokeh(dragon, dragondepth, focus=1300, focallength=300)
}
if(run_documentation()){
#Change the bokeh shape to a hexagon:
render_bokeh(dragon, dragondepth, bokehshape = "hex",
            focallength=300, focus=600)
}
if(run_documentation()){
#Change the bokeh intensity:
render_bokeh(dragon, dragondepth,
            focallength=400, focus=900, bokehintensity = 1)
render_bokeh(dragon, dragondepth,
            focallength=400, focus=900, bokehintensity = 3)
}
if(run_documentation()){
#Rotate the hexagonal shape:
render_bokeh(dragon, dragondepth, bokehshape = "hex", rotation=15,
            focallength=300, focus=600)
}
</code></pre>

<hr>
<h2 id='render_boolean_distance'>Render Boolean Distance</h2><span id='topic+render_boolean_distance'></span>

<h3>Description</h3>

<p>Takes an matrix (or  and returns the nearest distance to each TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_boolean_distance(boolean, rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_boolean_distance_+3A_boolean">boolean</code></td>
<td>
<p>Logical matrix (or matrix of 1s and 0s), where distance will be measured to the <code>TRUE</code> values.</p>
</td></tr>
<tr><td><code id="render_boolean_distance_+3A_rescale">rescale</code></td>
<td>
<p>Default <code>FALSE</code>. Rescales the calculated distance to a range of 0-1.
Useful for visualizing the distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of distance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Measure distance to
plot_image(render_boolean_distance(t(volcano) &gt; 150))
plot_image(render_boolean_distance(t(volcano) &lt; 150))
}
if(run_documentation()){
#If we want to rescale this to zero to one (to visualize like an image), set rescale=TRUE
plot_image(render_boolean_distance(t(volcano) &gt; 150,rescale=TRUE))
}
</code></pre>

<hr>
<h2 id='render_bw'>Render Black and White</h2><span id='topic+render_bw'></span>

<h3>Description</h3>

<p>Transforms an image to black and white, preserving luminance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_bw(
  image,
  rgb_coef = c(0.2126, 0.7152, 0.0722),
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_bw_+3A_image">image</code></td>
<td>
<p>Image filename, 3-layer RGB array, or matrix.</p>
</td></tr>
<tr><td><code id="render_bw_+3A_rgb_coef">rgb_coef</code></td>
<td>
<p>Default <code>c(0.2126, 0.7152, 0.0722)</code>.
Length-3 numeric vector listing coefficients to convert RGB to luminance.</p>
</td></tr>
<tr><td><code id="render_bw_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_bw_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB resized array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the image with a title
dragon |&gt;
 render_title("Dragon", title_offset=c(10,10), title_bar_color="black",
           title_size=20, title_color = "white") |&gt;
 render_bw(preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_clamp'>Clamp Image</h2><span id='topic+render_clamp'></span>

<h3>Description</h3>

<p>Clamps an image to a user-specified range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_clamp(image, min_value = 0, max_value = 1, preview = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_clamp_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_clamp_+3A_min_value">min_value</code></td>
<td>
<p>Default <code>0</code>. Minimum value to clamp the image to.</p>
</td></tr>
<tr><td><code id="render_clamp_+3A_max_value">max_value</code></td>
<td>
<p>Default <code>1</code>. Maximum value to clamp the image to.</p>
</td></tr>
<tr><td><code id="render_clamp_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
<tr><td><code id="render_clamp_+3A_...">...</code></td>
<td>
<p>Arguments to pass to either <code>jpeg::readJPEG</code>, <code>png::readPNG</code>, or <code>tiff::readTIFF</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#The rnage of the unchanged image
range(dragon)
}
if(run_documentation()){
#Clamp the maximum and minimum values to one and zero
render_clamp(dragon) |&gt;
 range()
}
</code></pre>

<hr>
<h2 id='render_convolution'>Render Convolution</h2><span id='topic+render_convolution'></span>

<h3>Description</h3>

<p>Takes an image and applys a convolution operation to it, using
a user-supplied or built-in kernel. Edges are calculated by limiting the size
of the kernel to only that overlapping the actual image (renormalizing the
kernel for the edges).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_convolution(
  image,
  kernel = "gaussian",
  kernel_dim = 11,
  kernel_extent = 3,
  absolute = TRUE,
  min_value = NULL,
  filename = NULL,
  preview = FALSE,
  gamma_correction = FALSE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_convolution_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel">kernel</code></td>
<td>
<p>Default <code>gaussian</code>. By default, an 11x11 Gaussian kernel with a mean
of <code>0</code> and a standard deviation of <code>1</code>, running from <code>-kernel_extent</code> to <code>kernel_extent</code>.
If numeric, this will be the standard deviation of the normal distribution. If a
matrix, it will be used directly as the convolution kernel (but resized always to be an odd number
of columns and rows).</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel_dim">kernel_dim</code></td>
<td>
<p>Default <code>11</code>. The dimension of the <code>gaussian</code> kernel. Ignored
if user specifies their own kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel_extent">kernel_extent</code></td>
<td>
<p>Default <code>3</code>. Extent over which to calculate the kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_absolute">absolute</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to take the absolute value of the convolution.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_min_value">min_value</code></td>
<td>
<p>Default <code>NULL</code>. If numeric, specifies he minimum value (for any color channel)
for a pixel to have the convolution performed.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_preview">preview</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>TRUE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_progress">progress</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to display a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Perform a convolution with the default gaussian kernel
plot_image(dragon)
}
if(run_documentation()){
#Perform a convolution with the default gaussian kernel
render_convolution(dragon, preview = TRUE)
}
if(run_documentation()){
#Increase the width of the kernel
render_convolution(dragon, kernel = 2, kernel_dim=21,kernel_extent=6, preview = TRUE)
}
if(run_documentation()){
#Perform edge detection using a edge detection kernel
edge = matrix(c(-1,-1,-1,-1,8,-1,-1,-1,-1),3,3)
render_convolution(render_bw(dragon), kernel = edge, preview = TRUE, absolute=FALSE)
}
if(run_documentation()){
#Perform edge detection with Sobel matrices
sobel1 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3)
sobel2 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3,byrow=TRUE)
sob1 = render_convolution(render_bw(dragon), kernel = sobel1)
sob2 = render_convolution(render_bw(dragon), kernel = sobel2)
sob_all = sob1 + sob2
plot_image(sob1)
plot_image(sob2)
plot_image(sob_all)
}

if(run_documentation()){
#Only perform the convolution on bright pixels (bloom)
render_convolution(dragon, kernel = 5, kernel_dim=24, kernel_extent=24,
                  min_value=1, preview = TRUE)
}
if(run_documentation()){
#Use a built-in kernel:
render_convolution(dragon, kernel = generate_2d_exponential(falloff=2, dim=31, width=21),
                  preview = TRUE)
}
if(run_documentation()){
#We can also apply this function to matrices:
volcano |&gt; image()
volcano |&gt;
 render_convolution(kernel=generate_2d_gaussian(sd=1,dim=31)) |&gt;
 image()
}
if(run_documentation()){
#Use a custom kernel (in this case, an X shape):
custom = diag(10) + (diag(10)[,10:1])
plot_image(custom)
render_convolution(dragon, kernel = custom, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_convolution_fft'>Render Convolution FFT</h2><span id='topic+render_convolution_fft'></span>

<h3>Description</h3>

<p>Takes an image and applys a convolution operation to it, using
a user-supplied or built-in kernel. This function uses a fast-fourier transform and
does the convolution in the frequency domain, so it should be faster for much larger kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_convolution_fft(
  image,
  kernel = "gaussian",
  kernel_dim = c(11, 11),
  kernel_extent = 3,
  absolute = TRUE,
  pad = 50,
  filename = NULL,
  preview = FALSE,
  gamma_correction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_convolution_fft_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel">kernel</code></td>
<td>
<p>Default <code>gaussian</code>. By default, an 11x11 Gaussian kernel with a mean
of <code>0</code> and a standard deviation of <code>1</code>, running from <code>-kernel_extent</code> to <code>kernel_extent</code>.
If numeric, this will be the standard deviation of the normal distribution. If a
matrix, it will be used directly as the convolution kernel (but resized always to be an odd number
of columns and rows).</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel_dim">kernel_dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimension of the <code>gaussian</code> kernel. Ignored
if user specifies their own kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel_extent">kernel_extent</code></td>
<td>
<p>Default <code>3</code>. Extent over which to calculate the kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_absolute">absolute</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to take the absolute value of the convolution.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_pad">pad</code></td>
<td>
<p>Default <code>50</code>. Amount to pad the image to remove edge effects.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>FALSE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Perform a convolution with the default gaussian kernel
plot_image(dragon)
}
if(run_documentation()){
#Perform a convolution with the default gaussian kernel
render_convolution_fft(dragon, kernel=0.1,preview = TRUE)
}
if(run_documentation()){
#Increase the width of the kernel
render_convolution_fft(dragon, kernel = 2, kernel_dim=21,kernel_extent=6, preview = TRUE)
}
if(run_documentation()){
#Use a built-in kernel:
render_convolution_fft(dragon, kernel = generate_2d_exponential(falloff=2, dim=31, width=21),
                      preview = TRUE)
}
if(run_documentation()){
#Perform edge detection
edge = matrix(c(-1,-1,-1,-1,8,-1,-1,-1,-1),3,3)
render_convolution_fft(render_bw(dragon), kernel = edge, preview = TRUE)
}
if(run_documentation()){
#Perform edge detection with Sobel matrices
sobel1 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3)
sobel2 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3,byrow=TRUE)
sob1 = render_convolution_fft(render_bw(dragon), kernel = sobel1)
sob2 = render_convolution_fft(render_bw(dragon), kernel = sobel2)
sob_all = sob1 + sob2
plot_image(sob1)
plot_image(sob2)
plot_image(sob_all)
}
if(run_documentation()){
#We can also apply this function to matrices:
volcano |&gt; image()
volcano |&gt;
 render_convolution_fft(kernel=generate_2d_gaussian(sd=1,dim=31)) |&gt;
 image()
}
if(run_documentation()){
# Because this function uses the fast-fourier transform, large kernels will be much faster
# than the same size kernels in `render_convolution()`
render_convolution_fft(dragon, kernel_dim = c(200,200) , preview = TRUE)
}
if(run_documentation()){
#Use a custom kernel (in this case, an X shape):
custom = diag(10) + (diag(10)[,10:1])
#Normalize
custom = custom / 20
plot_image(custom*20)
render_convolution_fft(dragon, kernel = custom, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_image_overlay'>Add Overlay</h2><span id='topic+render_image_overlay'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_image_overlay(
  image,
  image_overlay = NULL,
  rescale_original = FALSE,
  alpha = NULL,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_image_overlay_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_image_overlay_+3A_image_overlay">image_overlay</code></td>
<td>
<p>Default <code>NULL</code>. Either a string indicating the location of a png image to overlay
over the image (transparency included), or a 4-layer RGBA array. This image will be resized to the
dimension of the image if it does not match exactly.</p>
</td></tr>
<tr><td><code id="render_image_overlay_+3A_rescale_original">rescale_original</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, function will resize the original image to match
the overlay.</p>
</td></tr>
<tr><td><code id="render_image_overlay_+3A_alpha">alpha</code></td>
<td>
<p>Default <code>NULL</code>, using overlay's alpha channel. Otherwise, this sets the alpha transparency
by multiplying the existing alpha channel by this value (between 0 and 1).</p>
</td></tr>
<tr><td><code id="render_image_overlay_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. File to save the image to. If <code>NULL</code> and <code>preview = FALSE</code>,
returns an RGB array.</p>
</td></tr>
<tr><td><code id="render_image_overlay_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(run_documentation()){
#Add an overlay of a red semi-transparent circle:
circlemat = generate_2d_disk(min(dim(dragon)[1:2]))
circlemat = circlemat/max(circlemat)

#Create RGBA image, with a transparency of 0.5
rgba_array = array(1, dim=c(nrow(circlemat),ncol(circlemat),4))
rgba_array[,,1] = circlemat
rgba_array[,,2] = 0
rgba_array[,,3] = 0
dragon_clipped = dragon
dragon_clipped[dragon_clipped &gt; 1] = 1
render_image_overlay(dragon_clipped, image_overlay = rgba_array,
                 alpha=0.5, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_reorient'>Reorient Image</h2><span id='topic+render_reorient'></span>

<h3>Description</h3>

<p>Reorients an image or matrix. Transformations are applied in this order: x, y, and transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_reorient(
  image,
  flipx = FALSE,
  flipy = FALSE,
  transpose = FALSE,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_reorient_+3A_image">image</code></td>
<td>
<p>Image filename, 3-layer RGB array, or matrix.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_flipx">flipx</code></td>
<td>
<p>Default <code>FALSE</code>. Flip horizontally</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_flipy">flipy</code></td>
<td>
<p>Default <code>FALSE</code>. Flip vertically.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_transpose">transpose</code></td>
<td>
<p>Default <code>FALSE</code>. Transpose image.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB reoriented array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Original orientation
plot_image(dragon)
}
if(run_documentation()){
#Flip the dragon image horizontally
dragon |&gt;
 render_reorient(flipx = TRUE) |&gt;
 plot_image()
}
if(run_documentation()){
#Flip the dragon image vertically
dragon |&gt;
 render_reorient(flipy = TRUE) |&gt;
 plot_image()
}
if(run_documentation()){
#Transpose the dragon image
dragon |&gt;
 render_reorient(transpose = TRUE) |&gt;
 plot_image()
}
</code></pre>

<hr>
<h2 id='render_resized'>Resize Image</h2><span id='topic+render_resized'></span>

<h3>Description</h3>

<p>Resizes an image or a matrix, using bilinear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_resized(
  image,
  mag = 1,
  dims = NULL,
  filename = NULL,
  preview = FALSE,
  method = "tri"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_resized_+3A_image">image</code></td>
<td>
<p>Image filename, 3-layer RGB array, or matrix.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_mag">mag</code></td>
<td>
<p>Default <code>1</code>. Amount to magnify the image, preserving aspect ratio. Overridden if
<code>dim</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_dims">dims</code></td>
<td>
<p>Default <code>NULL</code>. Exact resized dimensions.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_method">method</code></td>
<td>
<p>Default <code>trilinear</code>. Filters to up/downsample the image. Options: <code>bilinear</code>, <code>box</code>, <code>trilinear</code>,
<code>catmull</code>, <code>mitchell</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB resized array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the image with a title
dragon |&gt;
 render_title("Dragon", title_offset=c(10,10), title_bar_color="black",
           title_size=20, title_color = "white") |&gt;
 plot_image()
}
if(run_documentation()){
#Half of the resolution
render_resized(dragon, mag = 1/2) |&gt;
 render_title("Dragon (half res)", title_offset=c(5,5), title_bar_color="black",
           title_size=10, title_color = "white") |&gt;
 plot_image()
}
if(run_documentation()){
#Double the resolution
render_resized(dragon, mag = 2) |&gt;
 render_title("Dragon (2x res)", title_offset=c(20,20), title_bar_color="black",
           title_size=40, title_color = "white") |&gt;
 plot_image()
}
if(run_documentation()){
#Specify the exact resulting dimensions
render_resized(dragon, dim = c(320,160)) |&gt;
 render_title("Dragon (custom size)", title_offset=c(10,10), title_bar_color="black",
           title_size=20, title_color = "white") |&gt;
 plot_image()
}
</code></pre>

<hr>
<h2 id='render_text_image'>Generate Text Image</h2><span id='topic+render_text_image'></span>

<h3>Description</h3>

<p>Generates an image which tightly fits text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_text_image(
  text,
  lineheight = 1,
  color = "black",
  size = 12,
  font = "sans",
  just = "left",
  background_color = "white",
  background_alpha = 1,
  use_ragg = TRUE,
  width = NA,
  height = NA,
  filename = NULL,
  check_text_width = TRUE,
  check_text_height = TRUE,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_text_image_+3A_text">text</code></td>
<td>
<p>Text to turn into an image.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_lineheight">lineheight</code></td>
<td>
<p>Default <code>1</code>. Multiplier for the lineheight.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_color">color</code></td>
<td>
<p>Default <code>"black"</code>. String specifying the color of the text.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_size">size</code></td>
<td>
<p>Default <code>12</code>. Numeric value specifying the font size of the text.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_font">font</code></td>
<td>
<p>Default <code>"sans"</code>. String specifying the font family for the text.
Common options include <code>"sans"</code>, <code>"mono"</code>, <code>"serif"</code>, <code>"Times"</code>, <code>"Helvetica"</code>, etc.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_just">just</code></td>
<td>
<p>Default <code>"left"</code>. Horizontal alignment of the text: <code>"left"</code>,
<code>"center"</code>, or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_background_color">background_color</code></td>
<td>
<p>Default <code>"white"</code>. Color of the background.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_background_alpha">background_alpha</code></td>
<td>
<p>Default <code>1</code>. Transparency of the background. A value
between <code>0</code> (fully transparent) and <code>1</code> (fully opaque).</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_use_ragg">use_ragg</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to use the <code>ragg</code> package as the graphics device. Required for emojis.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_width">width</code></td>
<td>
<p>Default <code>NA</code>. User-defined textbox width.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_height">height</code></td>
<td>
<p>Default <code>NA</code>. User-defined textbox width.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. String specifying the file path to save the resulting image.
If <code>NULL</code> and <code>preview = FALSE</code>, the function returns the processed RGB array.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_check_text_width">check_text_width</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to manually adjust the bounding
box of the resulting image to ensure the string bbox is wide enough for the text.
Not all systems provide accurate font sizes: this ensures the string is not cut off
at the edges, at the cost of needing to repeatedly render the image internally until
a suitable image is found.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_check_text_height">check_text_height</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to manually adjust the bounding
box of the resulting image to ensure the string bbox is tall enough for the text.
This will ensure a tight vertical bounding box on the text.</p>
</td></tr>
<tr><td><code id="render_text_image_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Boolean indicating whether to display the image after processing.
If <code>TRUE</code>, the image is displayed but not saved or returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-layer RGB array of the processed image if <code>filename = NULL</code> and <code>preview = FALSE</code>.
Otherwise, writes the image to the specified file or displays it if <code>preview = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (run_documentation()) {
  #Generate an image of some text
  render_text_image("Some text", preview = TRUE)
}
if (run_documentation()) {
  #Change the font size
  render_text_image("Some text", size = 100, preview = TRUE)
}
if (run_documentation()) {
  #Change the font color
  render_text_image("Some text", size = 100, color="red",preview = TRUE)
}
if (run_documentation()) {
  #Change the background color and transparency
  render_text_image("Some text", size = 50, color="purple",
                      background_color="purple", background_alpha = 0.5,
                      preview = TRUE)
}
if (run_documentation()) {
  # Plot an emoji with the agg device.
  render_text_image("\U0001F600\U0001F680", size = 50, color = "purple", use_ragg = TRUE,
                    background_alpha = 0,
                    preview = TRUE)
}

if (run_documentation()) {
  # Plot an emoji with the agg device and adjust the height and width (which
  # is on by default) to be a tight fit.
  render_text_image("\U0001F600\U0001F680", size = 50, color = "purple", use_ragg = TRUE,
                    background_alpha = 0, check_text_width = TRUE,
                    check_text_height = TRUE,
                    preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_title'>Render a Title on an Image</h2><span id='topic+render_title'></span>

<h3>Description</h3>

<p>Adds a title with optional styling and a title bar to an image.
The image can be previewed or saved to a file. Supports both the <code>grid</code>-based
method and (deprecated) <code>magick</code> package for rendering the title.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_title(
  image,
  title_text = "",
  title_size = 30,
  title_offset = rep(title_size/2, 2),
  title_lineheight = 1,
  title_color = "black",
  title_font = "Arial",
  title_style = "plain",
  title_bar_color = NA,
  title_bar_alpha = 0.5,
  title_bar_width = NULL,
  title_position = NA,
  title_just = "left",
  use_magick = FALSE,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_title_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array. Specifies the image to process.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_text">title_text</code></td>
<td>
<p>Default <code>""</code>. Text string to be added as the title to the image.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_size">title_size</code></td>
<td>
<p>Default <code>30</code>. Numeric value specifying the font size of the title text.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_offset">title_offset</code></td>
<td>
<p>Default <code>c(15,15)</code>. Numeric vector specifying the horizontal
and vertical offset of the title text, relative to its anchor position.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_lineheight">title_lineheight</code></td>
<td>
<p>Default <code>1</code>. Multiplier for the lineheight.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_color">title_color</code></td>
<td>
<p>Default <code>"black"</code>. String specifying the color of the title text.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_font">title_font</code></td>
<td>
<p>Default <code>"Arial"</code>. String specifying the font family for the title text.
Common options include <code>"sans"</code>, <code>"mono"</code>, <code>"serif"</code>, <code>"Times"</code>, <code>"Helvetica"</code>, etc.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_style">title_style</code></td>
<td>
<p>Default <code>"plain"</code>. String specifying the font style, such as
<code>"plain"</code>, <code>"italic"</code>, or <code>"bold"</code>.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default <code>NULL</code>. Color of the optional title bar. If <code>NULL</code>, no bar is added.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default <code>0.5</code>. Transparency level of the title bar. A value
between <code>0</code> (fully transparent) and <code>1</code> (fully opaque).</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_bar_width">title_bar_width</code></td>
<td>
<p>Default <code>NULL</code>. Numeric value for the height of the title bar in pixels.
If <code>NULL</code>, it is automatically calculated based on the text size and line breaks.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_position">title_position</code></td>
<td>
<p>Default <code>"northwest"</code>. String specifying the position of the title text.
Only used when <code>use_magick = TRUE</code>. Common options include <code>"northwest"</code>, <code>"center"</code>, <code>"south"</code>, etc.</p>
</td></tr>
<tr><td><code id="render_title_+3A_title_just">title_just</code></td>
<td>
<p>Default <code>"left"</code>. Horizontal alignment of the title text: <code>"left"</code>,
<code>"center"</code>, or <code>"right"</code>.</p>
</td></tr>
<tr><td><code id="render_title_+3A_use_magick">use_magick</code></td>
<td>
<p>Default <code>FALSE</code>. Boolean indicating whether to use the <code>magick</code> package for
rendering titles. This option will be deprecated in future versions.</p>
</td></tr>
<tr><td><code id="render_title_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. String specifying the file path to save the resulting image.
If <code>NULL</code> and <code>preview = FALSE</code>, the function returns the processed RGB array.</p>
</td></tr>
<tr><td><code id="render_title_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Boolean indicating whether to display the image after processing.
If <code>TRUE</code>, the image is displayed but not saved or returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-layer RGB array of the processed image if <code>filename = NULL</code> and <code>preview = FALSE</code>.
Otherwise, writes the image to the specified file or displays it if <code>preview = TRUE</code>.
</p>


<h3>Note</h3>

<p>The <code>use_magick</code> parameter and all functionality tied to the <code>magick</code> package are
planned for deprecation. It is recommended to use the <code>grid</code>-based method for
future compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
render_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20)
}
if(run_documentation()){
#That's hard to see--let's add a title bar:
render_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="white")
}
if(run_documentation()){
#Change the width of the bar:
render_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="white", title_offset = c(8,8))
}
if(run_documentation()){
#The width of the bar will also automatically adjust for newlines:
render_title(dragon, preview = TRUE, title_text = "Dragon\n(Blue)", title_size=20,
         title_bar_color="white")
}
if(run_documentation()){
#Change the color and title color:
render_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="red", title_color = "white")
}
if(run_documentation()){
#Change the transparency:
render_title(dragon, preview = TRUE, title_text = "Dragon",
            title_size=20, title_bar_alpha = 0.8,
            title_bar_color="red", title_color = "white")
}
if(run_documentation()){
#Read directly from a file
temp_image = tempfile(fileext = ".png")
ray_write_image(dragon, temp_image)
render_title(temp_image, preview = TRUE, title_text = "Dragon",
             title_size=20, title_bar_alpha = 0.8,
             title_bar_color="red", title_color = "white")
}
</code></pre>

<hr>
<h2 id='render_vignette'>Add Vignette Effect</h2><span id='topic+render_vignette'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds a camera vignette effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_vignette(
  image,
  vignette = 0.5,
  color = "#000000",
  radius = 1.3,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_vignette_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_vignette_+3A_vignette">vignette</code></td>
<td>
<p>Default <code>0.5</code>. A camera vignetting effect will be added to the image.
<code>1</code> is the darkest vignetting, while <code>0</code> is no vignetting. If vignette is a length-2 vector, the second entry will
control the blurriness of the vignette effect (<code>1</code> is the default, e.g. <code>2</code> would double the blurriness but would take
much longer to compute).</p>
</td></tr>
<tr><td><code id="render_vignette_+3A_color">color</code></td>
<td>
<p>Default <code>"#000000"</code> (black). Color of the vignette.</p>
</td></tr>
<tr><td><code id="render_vignette_+3A_radius">radius</code></td>
<td>
<p>Default <code>1.3</code>. Multiplier for the size of the vignette. If <code>1</code>, the vignette touches
the edge of the image.</p>
</td></tr>
<tr><td><code id="render_vignette_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. Filename which to save the image. If <code>NULL</code> and <code>preview = FALSE</code>,
returns an RGB array.</p>
</td></tr>
<tr><td><code id="render_vignette_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(run_documentation()){
#Add a vignette effect:
render_vignette(dragon, preview = TRUE, vignette = 0.5)
}
if(run_documentation()){
#Darken the vignette effect:
render_vignette(dragon, preview = TRUE, vignette = 1)
}
if(run_documentation()){
#Change the radius:
render_vignette(dragon, preview = TRUE, vignette = 1, radius=1.5)
render_vignette(dragon, preview = TRUE, vignette = 1, radius=0.5)
}
if(run_documentation()){
#Change the color:
render_vignette(dragon, preview = TRUE, vignette = 1, color="white")
}
if(run_documentation()){
#Increase the width of the blur by 50%:
render_vignette(dragon, preview = TRUE, vignette = c(1,1.5))
}
</code></pre>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>This function determines if the examples are being run in pkgdown. It is not meant to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>Boolean value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See if the documentation should be run.
run_documentation()
</code></pre>

<hr>
<h2 id='save_png'>Save PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Writes the hillshaded map to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(hillshade, filename, rotate = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_png_+3A_hillshade">hillshade</code></td>
<td>
<p>Array (or matrix) of hillshade to be written.</p>
</td></tr>
<tr><td><code id="save_png_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If <code>.png</code> is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_png_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#internal
</code></pre>

<hr>
<h2 id='trim_padding'>trim_padding</h2><span id='topic+trim_padding'></span>

<h3>Description</h3>

<p>Trims padding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_padding(input, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_padding_+3A_input">input</code></td>
<td>
<p>A two-dimensional matrix.</p>
</td></tr>
<tr><td><code id="trim_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with edges trimmed
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
