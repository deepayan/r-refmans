<!DOCTYPE html><html><head><title>Help for package rayimage</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rayimage}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_image_overlay'><p>Add Overlay</p></a></li>
<li><a href='#add_multi_padding'><p>add_multi_padding</p></a></li>
<li><a href='#add_padding'><p>add_padding</p></a></li>
<li><a href='#add_title'><p>Add Title</p></a></li>
<li><a href='#add_vignette'><p>Add Vignette Effect</p></a></li>
<li><a href='#calc_bokeh_size'><p>Calculate Bokeh Size</p></a></li>
<li><a href='#convert_color'><p>Convert Color</p></a></li>
<li><a href='#convert_to_native_raster'><p>Plot Image</p></a></li>
<li><a href='#dragon'><p>Dragon Image</p></a></li>
<li><a href='#dragondepth'><p>Dragon Depthmap</p></a></li>
<li><a href='#expand_to_fit'><p>expand to fit</p></a></li>
<li><a href='#fliplr'><p>Flip Left-Right</p></a></li>
<li><a href='#flipud'><p>Flip Up-Down</p></a></li>
<li><a href='#generate_2d_disk'><p>Generate 2D Disk</p></a></li>
<li><a href='#generate_2d_exponential'><p>Generate 2D exponential Distribution</p></a></li>
<li><a href='#generate_2d_gaussian'><p>Generate 2D Gaussian Distribution</p></a></li>
<li><a href='#get_file_type'><p>Check Filename</p></a></li>
<li><a href='#interpolate_array'><p>Matrix/Array Interpolation</p></a></li>
<li><a href='#make_vignette_overlay'><p>Make Vignette Overlay</p></a></li>
<li><a href='#pad_to_fit'><p>pad to fit</p></a></li>
<li><a href='#plot_asp_native_raster'><p>Plot Native Raster with Custom Aspect Ratio</p></a></li>
<li><a href='#plot_image'><p>Plot Image</p></a></li>
<li><a href='#plot_image_grid'><p>Plot Image Grid</p></a></li>
<li><a href='#preview_focus'><p>Preview Focus</p></a></li>
<li><a href='#render_bokeh'><p>Render Bokeh</p></a></li>
<li><a href='#render_boolean_distance'><p>Render Boolean Distance</p></a></li>
<li><a href='#render_convolution'><p>Render Convolution</p></a></li>
<li><a href='#render_convolution_fft'><p>Render Convolution FFT</p></a></li>
<li><a href='#render_reorient'><p>Reorient Image</p></a></li>
<li><a href='#render_resized'><p>Resize Image</p></a></li>
<li><a href='#run_documentation'><p>Run Documentation</p></a></li>
<li><a href='#save_png'><p>Save PNG</p></a></li>
<li><a href='#trim_padding'><p>trim_padding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Image Processing for Simulated Cameras</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler Morgan-Wall &lt;tylermw@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses convolution-based techniques to generate simulated camera bokeh, depth of field, and other camera effects, using an image and an optional depth map. Accepts both filename inputs and in-memory array representations of images and matrices. Includes functions to perform 2D convolutions, reorient and resize images/matrices, add image overlays, generate camera vignette effects, and add titles to images. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, png, jpeg, grDevices, grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magick, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, progress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rayimage.dev">https://www.rayimage.dev</a>,
<a href="https://github.com/tylermorganwall/rayimage">https://github.com/tylermorganwall/rayimage</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylermorganwall/rayimage/issues">https://github.com/tylermorganwall/rayimage/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 13:52:00 UTC; tyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler Morgan-Wall <a href="https://orcid.org/0000-0002-3131-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Sean Barrett [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-09 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_image_overlay'>Add Overlay</h2><span id='topic+add_image_overlay'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_image_overlay(
  image,
  image_overlay = NULL,
  rescale_original = FALSE,
  alpha = NULL,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_image_overlay_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="add_image_overlay_+3A_image_overlay">image_overlay</code></td>
<td>
<p>Default <code>NULL</code>. Either a string indicating the location of a png image to overlay
over the image (transparency included), or a 4-layer RGBA array. This image will be resized to the
dimension of the image if it does not match exactly.</p>
</td></tr>
<tr><td><code id="add_image_overlay_+3A_rescale_original">rescale_original</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, function will resize the original image to match
the overlay.</p>
</td></tr>
<tr><td><code id="add_image_overlay_+3A_alpha">alpha</code></td>
<td>
<p>Default <code>NULL</code>, using overlay's alpha channel. Otherwise, this sets the alpha transparency
by multiplying the existing alpha channel by this value (between 0 and 1).</p>
</td></tr>
<tr><td><code id="add_image_overlay_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. File to save the image to. If <code>NULL</code> and <code>preview = FALSE</code>,
returns an RGB array.</p>
</td></tr>
<tr><td><code id="add_image_overlay_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Add an overlay of a red semi-transparent circle:
circlemat = generate_2d_disk(min(dim(dragon)[1:2]))
circlemat = circlemat/max(circlemat)

#Create RGBA image, with a transparency of 0.5
rgba_array = array(1, dim=c(nrow(circlemat),ncol(circlemat),4))
rgba_array[,,1] = circlemat
rgba_array[,,2] = 0
rgba_array[,,3] = 0
dragon_clipped = dragon
dragon_clipped[dragon_clipped &gt; 1] = 1
add_image_overlay(dragon_clipped, image_overlay = rgba_array,
                 alpha=0.5, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='add_multi_padding'>add_multi_padding</h2><span id='topic+add_multi_padding'></span>

<h3>Description</h3>

<p>Adds multiple levels padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_multi_padding(heightmap, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_multi_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="add_multi_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges padded
</p>

<hr>
<h2 id='add_padding'>add_padding</h2><span id='topic+add_padding'></span>

<h3>Description</h3>

<p>Adds padding to the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_padding(heightmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges padded
</p>

<hr>
<h2 id='add_title'>Add Title</h2><span id='topic+add_title'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds a title with an optional titlebar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_title(
  image,
  title_text = "",
  title_offset = c(15, 15),
  title_color = "black",
  title_size = 30,
  title_font = "sans",
  title_style = "normal",
  title_bar_color = NULL,
  title_bar_alpha = 0.5,
  title_bar_width = NULL,
  title_position = "northwest",
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_title_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_text">title_text</code></td>
<td>
<p>Default <code>NULL</code>. Text. Adds a title to the image, using <code>magick::image_annotate()</code>.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_offset">title_offset</code></td>
<td>
<p>Default <code>c(15,15)</code>. Distance from the top-left (default, <code>gravity</code> direction in
image_annotate) corner to offset the title.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_color">title_color</code></td>
<td>
<p>Default <code>black</code>. Font color.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_size">title_size</code></td>
<td>
<p>Default <code>30</code>. Font size in pixels.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_font">title_font</code></td>
<td>
<p>Default <code>sans</code>. String with font family such as &quot;sans&quot;, &quot;mono&quot;, &quot;serif&quot;, &quot;Times&quot;, &quot;Helvetica&quot;,
&quot;Trebuchet&quot;, &quot;Georgia&quot;, &quot;Palatino&quot; or &quot;Comic Sans&quot;.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_style">title_style</code></td>
<td>
<p>Default <code>normal</code>. Font style (e.g. <code>italic</code>).</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_bar_color">title_bar_color</code></td>
<td>
<p>Default <code>NULL</code>. If a color, this will create a colored bar under the title.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_bar_alpha">title_bar_alpha</code></td>
<td>
<p>Default <code>0.5</code>. Transparency of the title bar.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_bar_width">title_bar_width</code></td>
<td>
<p>Default <code>NULL</code>, automaticly calculated from the size of the text and
the number of line breaks. Width of the title bar in pixels.</p>
</td></tr>
<tr><td><code id="add_title_+3A_title_position">title_position</code></td>
<td>
<p>Default <code>northwest</code>. Position of the title.</p>
</td></tr>
<tr><td><code id="add_title_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. File to save the image to. If <code>NULL</code> and <code>preview = FALSE</code>,
returns an RGB array.</p>
</td></tr>
<tr><td><code id="add_title_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the dragon
add_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20)
}
if(rayimage:::run_documentation()){
#That's hard to see--let's add a title bar:
add_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="white")
}
if(rayimage:::run_documentation()){
#Change the width of the bar:
add_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="white", title_offset = c(12,12))
}
if(rayimage:::run_documentation()){
#The width of the bar will also automatically adjust for newlines:
add_title(dragon, preview = TRUE, title_text = "Dragon\n(Blue)", title_size=20,
         title_bar_color="white", title_offset = c(12,12))
}
if(rayimage:::run_documentation()){
#Change the color and title color:
add_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20,
         title_bar_color="red", title_color = "white", title_offset = c(12,12))
}
if(rayimage:::run_documentation()){
#Change the transparency:
add_title(dragon, preview = TRUE, title_text = "Dragon", title_size=20, title_bar_alpha = 0.8,
         title_bar_color="red", title_color = "white", title_offset = c(12,12))
}
</code></pre>

<hr>
<h2 id='add_vignette'>Add Vignette Effect</h2><span id='topic+add_vignette'></span>

<h3>Description</h3>

<p>Takes an RGB array/filename and adds a camera vignette effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vignette(
  image,
  vignette = 0.5,
  color = "#000000",
  radius = 1.3,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_vignette_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="add_vignette_+3A_vignette">vignette</code></td>
<td>
<p>Default <code>0.5</code>. A camera vignetting effect will be added to the image.
<code>1</code> is the darkest vignetting, while <code>0</code> is no vignetting. If vignette is a length-2 vector, the second entry will
control the blurriness of the vignette effect (<code>1</code> is the default, e.g. <code>2</code> would double the blurriness but would take
much longer to compute).</p>
</td></tr>
<tr><td><code id="add_vignette_+3A_color">color</code></td>
<td>
<p>Default <code>"#000000"</code> (black). Color of the vignette.</p>
</td></tr>
<tr><td><code id="add_vignette_+3A_radius">radius</code></td>
<td>
<p>Default <code>1.3</code>. Multiplier for the size of the vignette. If <code>1</code>, the vignette touches
the edge of the image.</p>
</td></tr>
<tr><td><code id="add_vignette_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. Filename which to save the image. If <code>NULL</code> and <code>preview = FALSE</code>,
returns an RGB array.</p>
</td></tr>
<tr><td><code id="add_vignette_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, it will display the image in addition
to returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Add a vignette effect:
add_vignette(dragon, preview = TRUE, vignette = 0.5)
}
if(rayimage:::run_documentation()){
#Darken the vignette effect:
add_vignette(dragon, preview = TRUE, vignette = 1)
}
if(rayimage:::run_documentation()){
#Change the radius:
add_vignette(dragon, preview = TRUE, vignette = 1, radius=1.5)
add_vignette(dragon, preview = TRUE, vignette = 1, radius=0.5)
}
if(rayimage:::run_documentation()){
#Change the color:
add_vignette(dragon, preview = TRUE, vignette = 1, color="white")
}
if(rayimage:::run_documentation()){
#Increase the width of the blur by 50%:
add_vignette(dragon, preview = TRUE, vignette = c(1,1.5))
}
</code></pre>

<hr>
<h2 id='calc_bokeh_size'>Calculate Bokeh Size</h2><span id='topic+calc_bokeh_size'></span>

<h3>Description</h3>

<p>Calculates the amount of blurring at each point with camera characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_bokeh_size(z, zfocus, f, N, ramp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_bokeh_size_+3A_z">z</code></td>
<td>
<p>Depth matrix.</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_zfocus">zfocus</code></td>
<td>
<p>Depth in which to blur. Minimum 0, maximum 1.</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_f">f</code></td>
<td>
<p>Focal length of the virtual camera. .</p>
</td></tr>
<tr><td><code id="calc_bokeh_size_+3A_n">N</code></td>
<td>
<p>F-stop. Focal length of the virtual camera.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of bokeh sizes.
</p>

<hr>
<h2 id='convert_color'>Convert Color</h2><span id='topic+convert_color'></span>

<h3>Description</h3>

<p>Convert Color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_color(color, as_hex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_color_+3A_color">color</code></td>
<td>
<p>The color to convert. Can be either a hexadecimal code, or a numeric rgb
vector listing three intensities between <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#none
</code></pre>

<hr>
<h2 id='convert_to_native_raster'>Plot Image</h2><span id='topic+convert_to_native_raster'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_native_raster(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_native_raster_+3A_input">input</code></td>
<td>
<p>Array to get converted to a native raster</p>
</td></tr>
</table>

<hr>
<h2 id='dragon'>Dragon Image</h2><span id='topic+dragon'></span>

<h3>Description</h3>

<p>Dragon Image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dragon
</code></pre>


<h3>Format</h3>

<p>An RGB 3-layer HDR array with 200 rows and 200 columns,
generated using the rayrender package.
</p>

<hr>
<h2 id='dragondepth'>Dragon Depthmap</h2><span id='topic+dragondepth'></span>

<h3>Description</h3>

<p>Dragon Depthmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dragondepth
</code></pre>


<h3>Format</h3>

<p>An matrix with 200 rows and 200 columns, representing
the depth into the <code>dragon</code> image scene. Generated using the rayrender package.
Distances range from 847 to 1411.
</p>

<hr>
<h2 id='expand_to_fit'>expand to fit</h2><span id='topic+expand_to_fit'></span>

<h3>Description</h3>

<p>Pads to a rect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_to_fit(dim, kernel)
</code></pre>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

<hr>
<h2 id='fliplr'>Flip Left-Right</h2><span id='topic+fliplr'></span>

<h3>Description</h3>

<p>Flip Left-Right
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fliplr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fliplr_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='flipud'>Flip Up-Down</h2><span id='topic+flipud'></span>

<h3>Description</h3>

<p>Flip Up-Down
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipud(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipud_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='generate_2d_disk'>Generate 2D Disk</h2><span id='topic+generate_2d_disk'></span>

<h3>Description</h3>

<p>Generates a 2D disk with a gradual falloff.
</p>
<p>Disk generated using the following formula:
</p>
(-22.35 * cos(1.68 * r<sup>2</sup>) + 85.91 * sin(1.68 * r<sup>2</sup>) ) * exp(-4.89 * r<sup>2</sup>) +
(35.91 * cos(4.99 * r<sup>2</sup>) - 28.87 * sin(4.99 * r<sup>2</sup>)) * exp(-4.71 * r<sup>2</sup>) +
(-13.21 * cos(8.24 * r<sup>2</sup>) - 1.57 * sin(8.24 * r<sup>2</sup>)) * exp(-4.05 * r<sup>2</sup>) +
(0.50 * cos(11.90 * r<sup>2</sup>) + 1.81 * sin(11.90 * r<sup>2</sup>)) * exp(-2.92 * r<sup>2</sup>) +
(0.13 * cos(16.11 * r<sup>2</sup>) - 0.01 * sin(16.11 * r<sup>2</sup>)) * exp(-1.51 * r<sup>2</sup>)
<p>The origin of the coordinate system is the center of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_disk(dim = c(11, 11), radius = 1, rescale_unity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_2d_disk_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_disk_+3A_radius">radius</code></td>
<td>
<p>Default <code>1</code>. Radius of the disk, compared to the dimensions. Should be less than one.</p>
</td></tr>
<tr><td><code id="generate_2d_disk_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
image(generate_2d_disk(101), asp=1)
}
</code></pre>

<hr>
<h2 id='generate_2d_exponential'>Generate 2D exponential Distribution</h2><span id='topic+generate_2d_exponential'></span>

<h3>Description</h3>

<p>Generates a 2D exponential distribution, with an optional
argument to take the exponential to a user-defined power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_exponential(
  falloff = 1,
  dim = c(11, 11),
  width = 3,
  rescale_unity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_2d_exponential_+3A_falloff">falloff</code></td>
<td>
<p>Default <code>1</code>. Falloff of the exponential.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_width">width</code></td>
<td>
<p>Default <code>3</code> (<code>-10</code> to <code>10</code>). The range in which to compute the distribution.</p>
</td></tr>
<tr><td><code id="generate_2d_exponential_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
image(generate_2d_exponential(1,31,3), asp=1)
}
</code></pre>

<hr>
<h2 id='generate_2d_gaussian'>Generate 2D Gaussian Distribution</h2><span id='topic+generate_2d_gaussian'></span>

<h3>Description</h3>

<p>Generates a 2D gaussian distribution, with an optional
argument to take the gaussian to a user-defined power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2d_gaussian(
  sd = 1,
  power = 1,
  dim = c(11, 11),
  width = 3,
  rescale_unity = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_2d_gaussian_+3A_sd">sd</code></td>
<td>
<p>Default <code>1</code>. Standard deviation of the normal distribution</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_power">power</code></td>
<td>
<p>Default <code>1</code>. Power to take the distribution. Higher values will result in a sharper peak.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimensions of the matrix.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_width">width</code></td>
<td>
<p>Default <code>3</code> (<code>-10</code> to <code>10</code>). The range in which to compute the distribution.</p>
</td></tr>
<tr><td><code id="generate_2d_gaussian_+3A_rescale_unity">rescale_unity</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will rescale the max value to one. Useful
if wanting to plot the distribution with <code>plot_image()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
image(generate_2d_gaussian(1,1,31), asp=1)
}
</code></pre>

<hr>
<h2 id='get_file_type'>Check Filename</h2><span id='topic+get_file_type'></span>

<h3>Description</h3>

<p>Check Filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_file_type(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_file_type_+3A_file">file</code></td>
<td>
<p>Filename to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Flipped matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Fake example
</code></pre>

<hr>
<h2 id='interpolate_array'>Matrix/Array Interpolation</h2><span id='topic+interpolate_array'></span>

<h3>Description</h3>

<p>Given a series of X and Y coordinates and an array/matrix, interpolates the Z coordinate
using bilinear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_array(image, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_array_+3A_image">image</code></td>
<td>
<p>Image filename, a matrix, or a 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="interpolate_array_+3A_x">x</code></td>
<td>
<p>X indices (or fractional index) to interpolate.</p>
</td></tr>
<tr><td><code id="interpolate_array_+3A_y">y</code></td>
<td>
<p>Y indices (or fractional index) to interpolate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector of values (if image is a matrix) or a list of interpolated values
from each layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#if(interactive()){
#Interpolate a matrix
interpolate_array(volcano,c(10,10.1,11),c(30,30.5,33))
#Interpolate a 3-layer array (returns list for each channel)
interpolate_array(dragon,c(10,10.1,11),c(30,30.5,33))
#end}
</code></pre>

<hr>
<h2 id='make_vignette_overlay'>Make Vignette Overlay</h2><span id='topic+make_vignette_overlay'></span>

<h3>Description</h3>

<p>Makes an overlay to simulate vignetting in a camera
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_vignette_overlay(
  width,
  height,
  intensity = 0.3,
  radius_multiplier = 1.3,
  radius = NULL,
  color = "#000000"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_vignette_overlay_+3A_width">width</code></td>
<td>
<p>Width of the image.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_height">height</code></td>
<td>
<p>Height of the image.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_intensity">intensity</code></td>
<td>
<p>Default <code>0.4</code>. <code>1</code> is max intensity, <code>0</code> is min.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_radius_multiplier">radius_multiplier</code></td>
<td>
<p>Default <code>1.3</code>.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_radius">radius</code></td>
<td>
<p>Default <code>NULL</code>. Max of height or width, divided by 2.</p>
</td></tr>
<tr><td><code id="make_vignette_overlay_+3A_color">color</code></td>
<td>
<p>Default <code>black</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='pad_to_fit'>pad to fit</h2><span id='topic+pad_to_fit'></span>

<h3>Description</h3>

<p>Pads to a rect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_to_fit(dim, kernel)
</code></pre>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

<hr>
<h2 id='plot_asp_native_raster'>Plot Native Raster with Custom Aspect Ratio</h2><span id='topic+plot_asp_native_raster'></span>

<h3>Description</h3>

<p>Plot Native Raster with Custom Aspect Ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_asp_native_raster(nr, asp = 1, show = FALSE, return_grob = FALSE)
</code></pre>

<hr>
<h2 id='plot_image'>Plot Image</h2><span id='topic+plot_image'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_image(
  input,
  rotate = 0,
  draw_grid = FALSE,
  asp = 1,
  new_page = TRUE,
  return_grob = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_image_+3A_input">input</code></td>
<td>
<p>Image or filename of an image to be plotted.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_draw_grid">draw_grid</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will draw a grid in the background to help
disambiguate the actual image from the device (helpful if the image background is the same as the
device's background).</p>
</td></tr>
<tr><td><code id="plot_image_+3A_asp">asp</code></td>
<td>
<p>Default <code>1</code>. Aspect ratio of the pixels in the plot. For example, an aspect ratio of <code>4/3</code> will
slightly widen the image.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_new_page">new_page</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to call <code>grid::grid.newpage()</code> before plotting the image.</p>
</td></tr>
<tr><td><code id="plot_image_+3A_return_grob">return_grob</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to return the grob object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#if(interactive()){
#Plot the dragon array
plot_image(dragon)
#Make pixels twice as wide as tall
plot_image(dragon, asp = 2)
#Plot non-square images
plot_image(dragon[1:100,,])
#Make pixels twice as tall as wide
plot_image(dragon[1:100,,], asp = 1/2)
#end}
</code></pre>

<hr>
<h2 id='plot_image_grid'>Plot Image Grid</h2><span id='topic+plot_image_grid'></span>

<h3>Description</h3>

<p>Displays the image in the current device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_image_grid(input_list, dim = c(1, 1), asp = 1, draw_grid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_image_grid_+3A_input_list">input_list</code></td>
<td>
<p>List of array (or matrix) image inputs.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_dim">dim</code></td>
<td>
<p>Default <code>c(1,1)</code>. Width by height of output grid.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_asp">asp</code></td>
<td>
<p>Default <code>1</code>. Aspect ratio of the pixels(s). For example, an aspect ratio of <code>4/3</code> will
slightly widen the image. This can also be a vector the same length of
<code>input_list</code> to specify an aspect ratio for each image in the grid.</p>
</td></tr>
<tr><td><code id="plot_image_grid_+3A_draw_grid">draw_grid</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, this will draw a grid in the background to help
disambiguate the actual image from the device (helpful if the image background is the same as the
device's background).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the dragon array
plot_image_grid(list(dragon, 1-dragon), dim = c(1,2))
}
if(rayimage:::run_documentation()){
plot_image_grid(list(dragon, 1-dragon), dim = c(2,1))
}
if(rayimage:::run_documentation()){
plot_image_grid(list(dragon, NULL, 1-dragon), dim = c(2,2), asp = c(2,1,1/2))
}
if(rayimage:::run_documentation()){
plot_image_grid(list(dragon, NULL, NULL, dragon), dim = c(2,2), asp = c(2,1,1,1/2))
}
if(rayimage:::run_documentation()){
#Plot alongside the depth matrix
dragon_depth_reoriented = render_reorient(dragondepth,
                                         transpose = TRUE,
                                         flipx = TRUE)/2000
plot_image_grid(list(dragondepth/2000, dragon, dragon, dragondepth/2000),
               dim = c(2,2))
}
</code></pre>

<hr>
<h2 id='preview_focus'>Preview Focus</h2><span id='topic+preview_focus'></span>

<h3>Description</h3>

<p>Displays the focal point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preview_focus(image, depthmap, focus, imagetype, depthtype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preview_focus_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="preview_focus_+3A_depthmap">depthmap</code></td>
<td>
<p>Depth map filename or 1d array.</p>
</td></tr>
<tr><td><code id="preview_focus_+3A_focus">focus</code></td>
<td>
<p>Defaults <code>0.5</code>. Depth in which to blur. Minimum 0, maximum 1.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Plot the dragon
</code></pre>

<hr>
<h2 id='render_bokeh'>Render Bokeh</h2><span id='topic+render_bokeh'></span>

<h3>Description</h3>

<p>Takes an image and a depth map to render the image with depth of field
(i.e. similar to &quot;Portrait Mode&quot; in an iPhone). User can specify a custom bokeh shape,
or use one of the built-in bokeh types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_bokeh(
  image,
  depthmap,
  focus = 0.5,
  focallength = 100,
  fstop = 4,
  filename = NULL,
  preview = TRUE,
  preview_focus = FALSE,
  bokehshape = "circle",
  bokehintensity = 1,
  bokehlimit = 0.8,
  rotation = 0,
  aberration = 0,
  gamma_correction = TRUE,
  progress = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_bokeh_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_depthmap">depthmap</code></td>
<td>
<p>Depth map filename or 1d array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_focus">focus</code></td>
<td>
<p>Defaults <code>0.5</code>. Depth in which to blur.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_focallength">focallength</code></td>
<td>
<p>Default <code>100</code>. Focal length of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_fstop">fstop</code></td>
<td>
<p>Default <code>4</code>. F-stop of the virtual camera.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_preview">preview</code></td>
<td>
<p>Default <code>TRUE</code>. If <code>FALSE</code>, it will not display the image and just return the RGB array.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_preview_focus">preview_focus</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>TRUE</code>, a red line will be drawn across the image
showing where the camera will be focused.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehshape">bokehshape</code></td>
<td>
<p>Default <code>circle</code>. Also built-in: <code>hex</code>. The shape of the bokeh. If the user
passes in a 2D matrix, that matrix will control the shape of the bokeh.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehintensity">bokehintensity</code></td>
<td>
<p>Default <code>1</code>. Intensity of the bokeh when the pixel intensity is greater than <code>bokehlimit</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_bokehlimit">bokehlimit</code></td>
<td>
<p>Default <code>0.8</code>. Limit after which the bokeh intensity is increased by <code>bokehintensity</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_rotation">rotation</code></td>
<td>
<p>Default <code>0</code>. Number of degrees to rotate the hexagonal bokeh shape.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_aberration">aberration</code></td>
<td>
<p>Default <code>0</code>. Adds chromatic aberration to the image. Maximum of <code>1</code>.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>TRUE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_progress">progress</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to display a progress bar.</p>
</td></tr>
<tr><td><code id="render_bokeh_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot_image()</code> if <code>preview = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the dragon
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Plot the depth map
graphics::image(dragondepth, asp = 1, col = grDevices::heat.colors(256))
}
if(rayimage:::run_documentation()){
#Preview the focal plane:
render_bokeh(dragon, dragondepth, focus=950, preview_focus = TRUE)
}
if(rayimage:::run_documentation()){
#Change the focal length:
render_bokeh(dragon, dragondepth, focus=950, focallength=300)
}
if(rayimage:::run_documentation()){
#Add chromatic aberration:
render_bokeh(dragon, dragondepth, focus=950, focallength=300, aberration = 0.5)
}
if(rayimage:::run_documentation()){
#Change the focal distance:
render_bokeh(dragon, dragondepth, focus=600, focallength=300)
render_bokeh(dragon, dragondepth, focus=1300, focallength=300)
}
if(rayimage:::run_documentation()){
#Change the bokeh shape to a hexagon:
render_bokeh(dragon, dragondepth, bokehshape = "hex",
            focallength=300, focus=600)
}
if(rayimage:::run_documentation()){
#Change the bokeh intensity:
render_bokeh(dragon, dragondepth,
            focallength=400, focus=900, bokehintensity = 1)
render_bokeh(dragon, dragondepth,
            focallength=400, focus=900, bokehintensity = 3)
}
if(rayimage:::run_documentation()){
#Rotate the hexagonal shape:
render_bokeh(dragon, dragondepth, bokehshape = "hex", rotation=15,
            focallength=300, focus=600)
}
</code></pre>

<hr>
<h2 id='render_boolean_distance'>Render Boolean Distance</h2><span id='topic+render_boolean_distance'></span>

<h3>Description</h3>

<p>Takes an matrix (or  and returns the nearest distance to each TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_boolean_distance(boolean, rescale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_boolean_distance_+3A_boolean">boolean</code></td>
<td>
<p>Logical matrix (or matrix of 1s and 0s), where distance will be measured to the <code>TRUE</code> values.</p>
</td></tr>
<tr><td><code id="render_boolean_distance_+3A_rescale">rescale</code></td>
<td>
<p>Default <code>FALSE</code>. Rescales the calculated distance to a range of 0-1.
Useful for visualizing the distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of distance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Measure distance to
plot_image(render_boolean_distance(t(volcano) &gt; 150))
plot_image(render_boolean_distance(t(volcano) &lt; 150))
}
if(rayimage:::run_documentation()){
#If we want to rescale this to zero to one (to visualize like an image), set rescale=TRUE
plot_image(render_boolean_distance(t(volcano) &gt; 150,rescale=TRUE))
}
</code></pre>

<hr>
<h2 id='render_convolution'>Render Convolution</h2><span id='topic+render_convolution'></span>

<h3>Description</h3>

<p>Takes an image and applys a convolution operation to it, using
a user-supplied or built-in kernel. Edges are calculated by limiting the size
of the kernel to only that overlapping the actual image (renormalizing the
kernel for the edges).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_convolution(
  image,
  kernel = "gaussian",
  kernel_dim = 11,
  kernel_extent = 3,
  absolute = TRUE,
  min_value = NULL,
  filename = NULL,
  preview = FALSE,
  gamma_correction = FALSE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_convolution_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel">kernel</code></td>
<td>
<p>Default <code>gaussian</code>. By default, an 11x11 Gaussian kernel with a mean
of <code>0</code> and a standard deviation of <code>1</code>, running from <code>-kernel_extent</code> to <code>kernel_extent</code>.
If numeric, this will be the standard deviation of the normal distribution. If a
matrix, it will be used directly as the convolution kernel (but resized always to be an odd number
of columns and rows).</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel_dim">kernel_dim</code></td>
<td>
<p>Default <code>11</code>. The dimension of the <code>gaussian</code> kernel. Ignored
if user specifies their own kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_kernel_extent">kernel_extent</code></td>
<td>
<p>Default <code>3</code>. Extent over which to calculate the kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_absolute">absolute</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to take the absolute value of the convolution.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_min_value">min_value</code></td>
<td>
<p>Default <code>NULL</code>. If numeric, specifies he minimum value (for any color channel)
for a pixel to have the convolution performed.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_preview">preview</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>TRUE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
<tr><td><code id="render_convolution_+3A_progress">progress</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to display a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Perform a convolution with the default gaussian kernel
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Perform a convolution with the default gaussian kernel
render_convolution(dragon, preview = TRUE)
}
if(rayimage:::run_documentation()){
#Increase the width of the kernel
render_convolution(dragon, kernel = 2, kernel_dim=21,kernel_extent=6, preview = TRUE)
}
if(rayimage:::run_documentation()){
#Perform edge detection using a edge detection kernel
edge = matrix(c(-1,-1,-1,-1,8,-1,-1,-1,-1),3,3)
render_convolution(dragon, kernel = edge, preview = TRUE, absolute=FALSE)
}
if(rayimage:::run_documentation()){
#Perform edge detection with Sobel matrices
sobel1 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3)
sobel2 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3,byrow=TRUE)
sob1 = render_convolution(dragon, kernel = sobel1)
sob2 = render_convolution(dragon, kernel = sobel2)
sob_all = sob1 + sob2
plot_image(sob_all)
}
if(rayimage:::run_documentation()){
#Only perform the convolution on bright pixels (bloom)
render_convolution(dragon, kernel = 5, kernel_dim=24, kernel_extent=24,
                  min_value=1, preview = TRUE)
}
if(rayimage:::run_documentation()){
#Use a built-in kernel:
render_convolution(dragon, kernel = generate_2d_exponential(falloff=2, dim=31, width=21),
                  preview = TRUE)
}
if(rayimage:::run_documentation()){
#We can also apply this function to matrices:
volcano |&gt; image()
volcano |&gt;
 render_convolution(kernel=generate_2d_gaussian(sd=1,dim=31)) |&gt;
 image()
}
if(rayimage:::run_documentation()){
#Use a custom kernel (in this case, an X shape):
custom = diag(10) + (diag(10)[,10:1])
plot_image(custom)
render_convolution(dragon, kernel = custom, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_convolution_fft'>Render Convolution FFT</h2><span id='topic+render_convolution_fft'></span>

<h3>Description</h3>

<p>Takes an image and applys a convolution operation to it, using
a user-supplied or built-in kernel. This function uses a fast-fourier transform and
does the convolution in the frequency domain, so it should be faster for much larger kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_convolution_fft(
  image,
  kernel = "gaussian",
  kernel_dim = c(11, 11),
  kernel_extent = 3,
  absolute = TRUE,
  pad = 50,
  filename = NULL,
  preview = FALSE,
  gamma_correction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_convolution_fft_+3A_image">image</code></td>
<td>
<p>Image filename or 3-layer RGB array.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel">kernel</code></td>
<td>
<p>Default <code>gaussian</code>. By default, an 11x11 Gaussian kernel with a mean
of <code>0</code> and a standard deviation of <code>1</code>, running from <code>-kernel_extent</code> to <code>kernel_extent</code>.
If numeric, this will be the standard deviation of the normal distribution. If a
matrix, it will be used directly as the convolution kernel (but resized always to be an odd number
of columns and rows).</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel_dim">kernel_dim</code></td>
<td>
<p>Default <code>c(11, 11)</code>. The dimension of the <code>gaussian</code> kernel. Ignored
if user specifies their own kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_kernel_extent">kernel_extent</code></td>
<td>
<p>Default <code>3</code>. Extent over which to calculate the kernel.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_absolute">absolute</code></td>
<td>
<p>Default <code>TRUE</code>. Whether to take the absolute value of the convolution.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_pad">pad</code></td>
<td>
<p>Default <code>50</code>. Amount to pad the image to remove edge effects.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_convolution_fft_+3A_gamma_correction">gamma_correction</code></td>
<td>
<p>Default <code>FALSE</code>. Controls gamma correction when adding colors. Default exponent of 2.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB array of the processed image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Perform a convolution with the default gaussian kernel
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Perform a convolution with the default gaussian kernel
render_convolution_fft(dragon, kernel=0.1,preview = TRUE)
}
if(rayimage:::run_documentation()){
#Increase the width of the kernel
render_convolution_fft(dragon, kernel = 2, kernel_dim=21,kernel_extent=6, preview = TRUE)
}
if(rayimage:::run_documentation()){
#Use a built-in kernel:
render_convolution_fft(dragon, kernel = generate_2d_exponential(falloff=2, dim=31, width=21),
                  preview = TRUE)
}
if(rayimage:::run_documentation()){
#Perform edge detection
edge = matrix(c(-1,-1,-1,-1,8,-1,-1,-1,-1),3,3)
render_convolution_fft(dragon, kernel = edge, preview = TRUE)
}
if(rayimage:::run_documentation()){
#Perform edge detection with Sobel matrices
sobel1 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3)
sobel2 = matrix(c(1,2,1,0,0,0,-1,-2,-1),3,3,byrow=TRUE)
sob1 = render_convolution_fft(dragon, kernel = sobel1)
sob2 = render_convolution_fft(dragon, kernel = sobel2)
sob_all = sob1 + sob2
plot_image(sob_all)
}
if(rayimage:::run_documentation()){
#We can also apply this function to matrices:
volcano |&gt; image()
volcano |&gt;
 render_convolution_fft(kernel=generate_2d_gaussian(sd=1,dim=31)) |&gt;
 image()
}
if(rayimage:::run_documentation()){
#Because this function uses the fast-fourier transform, large kernels will be much faster.
render_convolution_fft(dragon, kernel = , preview = TRUE)
}
if(rayimage:::run_documentation()){
#Use a custom kernel (in this case, an X shape):
custom = diag(10) + (diag(10)[,10:1])
#Normalize
custom = custom / 20
plot_image(custom*20)
render_convolution_fft(dragon, kernel = custom, preview = TRUE)
}
</code></pre>

<hr>
<h2 id='render_reorient'>Reorient Image</h2><span id='topic+render_reorient'></span>

<h3>Description</h3>

<p>Reorients an image or matrix. Transformations are applied in this order: x, y, and transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_reorient(
  image,
  flipx = FALSE,
  flipy = FALSE,
  transpose = FALSE,
  filename = NULL,
  preview = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_reorient_+3A_image">image</code></td>
<td>
<p>Image filename, 3-layer RGB array, or matrix.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_flipx">flipx</code></td>
<td>
<p>Default <code>FALSE</code>. Flip horizontally</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_flipy">flipy</code></td>
<td>
<p>Default <code>FALSE</code>. Flip vertically.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_transpose">transpose</code></td>
<td>
<p>Default <code>FALSE</code>. Transpose image.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_reorient_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB reoriented array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Original orientation
plot_image(dragon)
}
if(rayimage:::run_documentation()){
#Flip the dragon image horizontally
dragon |&gt;
 render_reorient(flipx = TRUE) |&gt;
 plot_image()
}
if(rayimage:::run_documentation()){
#Flip the dragon image vertically
dragon |&gt;
 render_reorient(flipy = TRUE) |&gt;
 plot_image()
}
if(rayimage:::run_documentation()){
#Transpose the dragon image
dragon |&gt;
 render_reorient(transpose = TRUE) |&gt;
 plot_image()
}
</code></pre>

<hr>
<h2 id='render_resized'>Resize Image</h2><span id='topic+render_resized'></span>

<h3>Description</h3>

<p>Resizes an image or a matrix, using bilinear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_resized(
  image,
  mag = 1,
  dims = NULL,
  filename = NULL,
  preview = FALSE,
  method = "tri"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_resized_+3A_image">image</code></td>
<td>
<p>Image filename, 3-layer RGB array, or matrix.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_mag">mag</code></td>
<td>
<p>Default <code>1</code>. Amount to magnify the image, preserving aspect ratio. Overridden if
<code>dim</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_dims">dims</code></td>
<td>
<p>Default <code>NULL</code>. Exact resized dimensions.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_filename">filename</code></td>
<td>
<p>Default <code>NULL</code>. The filename of the image to be saved. If this is not given, the image will be plotted instead.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_preview">preview</code></td>
<td>
<p>Default <code>FALSE</code>. Whether to plot the convolved image, or just to return the values.</p>
</td></tr>
<tr><td><code id="render_resized_+3A_method">method</code></td>
<td>
<p>Default <code>trilinear</code>. Filters to up/downsample the image. Options: <code>bilinear</code>, <code>box</code>, <code>trilinear</code>,
<code>catmull</code>, <code>mitchell</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-layer RGB resized array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(rayimage:::run_documentation()){
#Plot the image with a title
dragon |&gt;
 add_title("Dragon", title_offset=c(10,10), title_bar_color="black",
           title_size=20, title_color = "white") |&gt;
 plot_image()
}
if(rayimage:::run_documentation()){
#Half of the resolution
render_resized(dragon, mag = 1/2) |&gt;
 add_title("Dragon (half res)", title_offset=c(5,5), title_bar_color="black",
           title_size=10, title_color = "white") |&gt;
 plot_image()
}
if(rayimage:::run_documentation()){
#Double the resolution
render_resized(dragon, mag = 2) |&gt;
 add_title("Dragon (2x res)", title_offset=c(20,20), title_bar_color="black",
           title_size=40, title_color = "white") |&gt;
 plot_image()
}
if(rayimage:::run_documentation()){
#Specify the exact resulting dimensions
render_resized(dragon, dim = c(320,160)) |&gt;
 add_title("Dragon (custom size)", title_offset=c(10,10), title_bar_color="black",
           title_size=20, title_color = "white") |&gt;
 plot_image()
}
</code></pre>

<hr>
<h2 id='run_documentation'>Run Documentation</h2><span id='topic+run_documentation'></span>

<h3>Description</h3>

<p>Run Documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_documentation()
</code></pre>


<h3>Value</h3>

<p>bool
</p>

<hr>
<h2 id='save_png'>Save PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Writes the hillshaded map to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(hillshade, filename, rotate = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_png_+3A_hillshade">hillshade</code></td>
<td>
<p>Array (or matrix) of hillshade to be written.</p>
</td></tr>
<tr><td><code id="save_png_+3A_filename">filename</code></td>
<td>
<p>String with the filename. If <code>.png</code> is not at the end of the string, it will be appended automatically.</p>
</td></tr>
<tr><td><code id="save_png_+3A_rotate">rotate</code></td>
<td>
<p>Default 0. Rotates the output. Possible values: 0, 90, 180, 270.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#internal
</code></pre>

<hr>
<h2 id='trim_padding'>trim_padding</h2><span id='topic+trim_padding'></span>

<h3>Description</h3>

<p>Trims padding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_padding(heightmap, pad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_padding_+3A_heightmap">heightmap</code></td>
<td>
<p>A two-dimensional matrix, where each entry in the matrix is the elevation at that point. All points are assumed to be evenly spaced.</p>
</td></tr>
<tr><td><code id="trim_padding_+3A_pad">pad</code></td>
<td>
<p>Number of padding entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hillshade with edges trimmed
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
