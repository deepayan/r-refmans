<!DOCTYPE html><html><head><title>Help for package socialranking</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {socialranking}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#appendMissingCoalitions'><p>Append missing coalitions</p></a></li>
<li><a href='#as.PowerRelation'><p>Create PowerRelation object</p></a></li>
<li><a href='#coalitionsAreIndifferent'><p>Are coalitions indifferent</p></a></li>
<li><a href='#copelandScores'><p>Copeland-like method</p></a></li>
<li><a href='#cpMajorityComparison'><p>CP-Majority relation</p></a></li>
<li><a href='#createPowerset'><p>Create powerset</p></a></li>
<li><a href='#cumulativeScores'><p>Cumulative scores</p></a></li>
<li><a href='#dominates'><p>Dominance</p></a></li>
<li><a href='#doRanking'><p>Create a <code>SocialRanking</code> object</p></a></li>
<li><a href='#elementLookup'><p>Element lookup</p></a></li>
<li><a href='#equivalenceClassIndex'><p>Get index of equivalence class containing a coalition</p></a></li>
<li><a href='#generateNextPartition'><p>Next partition</p></a></li>
<li><a href='#kramerSimpsonScores'><p>Kramer-Simpson-like method</p></a></li>
<li><a href='#L1Scores'><p>L1 Ranking</p></a></li>
<li><a href='#L2Scores'><p>L2 Ranking</p></a></li>
<li><a href='#lexcelScores'><p>Lexicographical Excellence</p></a></li>
<li><a href='#LPScores'><p>LP Ranking</p></a></li>
<li><a href='#LPSScores'><p>LP* Ranking</p></a></li>
<li><a href='#makePowerRelationMonotonic'><p>Make Power Relation monotonic</p></a></li>
<li><a href='#newPowerRelation'><p>New Power Relation</p></a></li>
<li><a href='#newPowerRelationFromString'><p>New <code>PowerRelation</code> object</p></a></li>
<li><a href='#ordinalBanzhafScores'><p>Ordinal Banzhaf ranking</p></a></li>
<li><a href='#PowerRelation'><p>PowerRelation object</p></a></li>
<li><a href='#powerRelationGenerator'><p>Generate power relations</p></a></li>
<li><a href='#powerRelationMatrix'><p>Create relation matrix</p></a></li>
<li><a href='#SocialRanking'><p><code>SocialRanking</code> object</p></a></li>
<li><a href='#socialrankingpackage'><p>socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions</p></a></li>
<li><a href='#testRelation'><p>Test relation between two elements</p></a></li>
<li><a href='#transitiveClosure'><p>Transitive Closure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Social Ranking Solutions for Power Relations on Coalitions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Fritz &lt;felix.fritz@dauphine.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The notion of power index has been widely used in literature to evaluate the influence of individual players (e.g., voters, political parties, nations, stockholders, etc.) involved in a collective decision situation like an electoral system, a parliament, a council, a management board, etc., where players may form coalitions. Traditionally this ranking is determined through numerical evaluation. More often than not however only ordinal data between coalitions is known. The package 'socialranking' offers a set of solutions to rank players based on a transitive ranking between coalitions, including through CP-Majority, ordinal Banzhaf or lexicographic excellence solution summarized by Tahar Allouche, Bruno Escoffier, Stefano Moretti and Meltem Öztürk (2020, &lt;<a href="https://doi.org/10.24963%2Fijcai.2020%2F3">doi:10.24963/ijcai.2020/3</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clipr (&ge; 0.8), testthat (&ge; 3.1.2), xfun (&ge; 0.30.0), knitr
(&ge; 1.40), rmarkdown (&ge; 2.17), covr (&ge; 3.6.1), partitions (&ge;
1.10.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>relations (&ge; 0.6.13), rlang (&ge; 1.0.6), Rdpack (&ge; 2.4)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jassler/socialranking">https://github.com/jassler/socialranking</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jassler/socialranking/issues">https://github.com/jassler/socialranking/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 12:38:13 UTC; felix</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Fritz [aut, cre],
  Jochen Staudacher [aut, cph, ths],
  Moretti Stefano [aut, cph, ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='appendMissingCoalitions'>Append missing coalitions</h2><span id='topic+appendMissingCoalitions'></span>

<h3>Description</h3>

<p>Append an equivalence class to a power relation with all coalitions of elements that do not appear in the power relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendMissingCoalitions(powerRelation, includeEmptySet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendMissingCoalitions_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="appendMissingCoalitions_+3A_includeemptyset">includeEmptySet</code></td>
<td>
<p>If <code>TRUE</code>, include the empty set in the last equivalence class if it is missing from the power relation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given set of elements <code class="reqn">N = \lbrace 1, ..., n \rbrace</code>, a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object describes a total preorder
of its subsets, or coalitions, <code class="reqn">\mathcal{P} \subseteq 2^N</code>, where <code class="reqn">2^N</code> is the superset of elements.
</p>
<p>If <code class="reqn">\mathcal{P} \neq 2^N</code>, that means that there are some coalitions <code class="reqn">S \in 2^N, S \notin \mathcal{P}</code>,
such that we cannot compare <code class="reqn">S \succsim T</code> or <code class="reqn">T \succsim S</code> for every <code class="reqn">T \in \mathcal{P}</code>.
</p>
<p>This may be caused by <code class="reqn">2^N</code> having too many coalitions to consider.
In certain cases, it may be more interesting to only consider the top ranking coalitions and &quot;shoving&quot; all remaining coalitions into the back.
</p>
<p>For this use-case, <code>appendMissingCoalitions()</code> takes the set <code class="reqn">2^N \setminus \mathcal{P}</code>
and attaches it in form of an equivalence class to the back of the power relation.
</p>
<p>I.e., take as an example <code class="reqn">12 \succ 13 \succ (1 \sim 2)</code>. Here, we have
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
2^N &amp;= \lbrace 123, 12, 13, 23, 1, 2, 3, \emptyset \rbrace\\
\mathcal{P} &amp;= \lbrace 12, 13, 1, 2 \rbrace\\
2^N \setminus \mathcal{P} &amp;= \lbrace 123, 23, 3, \emptyset \rbrace .
\end{aligned}
</code>
</p>

<p>Adding the missing coalitions to the power relation then gives us <code class="reqn">12 \succ 13 \succ (1 \sim 2) \succ (123 \sim 23 \sim 3 \sim \emptyset)</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+PowerRelation">PowerRelation</a></code> object containing the following values:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$elements&#8288;</code>: vector of elements
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$eqs&#8288;</code>: equivalence classes. Nested list of lists, each containing vectors representing groups of elements in the same equivalence class
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$coalitionLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(v)&#8288;</code> taking a coalition vector <code>v</code> and returning the equivalence class it belongs to. See <code><a href="#topic+coalitionLookup">coalitionLookup()</a></code> for more.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$elementLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(e)&#8288;</code> taking an element <code>e</code> and returning a list of 2-sized tuples. See <code><a href="#topic+elementLookup">elementLookup()</a></code> for more.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other helper functions for transforming power relations: 
<code><a href="#topic+makePowerRelationMonotonic">makePowerRelationMonotonic</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation(list(c(1,2), 3))
# 12 &gt; 3

appendMissingCoalitions(pr)
# 12 &gt; 3 &gt; (123 ~ 13 ~ 23 ~ 1 ~ 2 ~ {})

appendMissingCoalitions(pr, includeEmptySet = FALSE)
# 12 &gt; 3 &gt; (123 ~ 13 ~ 23 ~ 1 ~ 2)

</code></pre>

<hr>
<h2 id='as.PowerRelation'>Create PowerRelation object</h2><span id='topic+as.PowerRelation'></span><span id='topic+as.PowerRelation.character'></span><span id='topic+as.PowerRelation.list'></span>

<h3>Description</h3>

<p>Alternative ways of creating <code><a href="#topic+PowerRelation">PowerRelation</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.PowerRelation(x, ...)

## S3 method for class 'character'
as.PowerRelation(x, ...)

## S3 method for class 'list'
as.PowerRelation(x, ..., comparators = c("&gt;"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.PowerRelation_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="as.PowerRelation_+3A_...">...</code></td>
<td>
<p>Optional additional parameters</p>
</td></tr>
<tr><td><code id="as.PowerRelation_+3A_comparators">comparators</code></td>
<td>
<p>Vector of &quot;&gt;&quot; or &quot;~&quot; characters</p>
</td></tr>
</table>


<h3>Using a character string</h3>

<p>The same way a power relation <code class="reqn">\succsim</code> may be represented in literature (or printed by an <code><a href="#topic+PowerRelation">PowerRelation</a></code> object),
a simple string containing letters, numbers, <code>&gt;</code> or <code>~</code> can be used to input a new power relation.
</p>
<p>Every special character is ignored, with the exception of <code class="reqn">\succsim</code> (<code>"\u227B"</code>) and <code class="reqn">\sim</code> (<code>"\u223C"</code>).
</p>
<p>Every letter or number is assumed to be an individual element.
<code>"abc &gt; ac"</code> therefore would represent two coalitions, the first one of size 3 with the elements <code>a</code>, <code>b</code>, and <code>c</code>.
This method does not allow for elements to be entered that are supposed to be multiple characters long.
</p>
<p>An empty coalitions can be simply left blank (i.e., <code>"abc &gt; ~ ac"</code>),
though it is often clearer if curly braces are used to indicate such (i.e., <code>"abc &gt; {} ~ ac"</code>).
</p>


<h3>Using a list</h3>

<p>Create a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object with an unnested list of coalition <a href="base.html#topic+c">vectors</a>.
</p>
<p>By default, a linear order is assumed on the coalitions.
I.e., if it is given <code>list(c(1,2),1,2)</code>, these three coalitions are put into their own equivalence class,
producing <code style="white-space: pre;">&#8288;12 &gt; 1 &gt; 2&#8288;</code>.
</p>
<p>The comparators in-between can be adjusted to indicate
whether the relation between two coalitions is that of strict preference <code>&gt;</code> or indifference <code>~</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using character strings
as.PowerRelation("abc &gt; ab &gt; ({} ~ c) &gt; (a ~ b ~ ac) &gt; bc")
# abc &gt; ab &gt; ({} ~ c) &gt; (a ~ b ~ ac) &gt; bc

# using createPowerset(), then shifting coalitions up and down using Alt+Up and Alt+Down
if(interactive()) {
  createPowerset(1:2, result = "copy")
}
as.PowerRelation("
  12
  &gt; 1
  ~ {}
  &gt; 2
")

# Using lists
as.PowerRelation(list(c(1,2), 2, c(), 1))
# 12 &gt; 2 &gt; {} &gt; 1

as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c("~", "&gt;", "&gt;"))
# (12 ~ 2) &gt; {} &gt; 1

# the length of comparators doesn't necessarily matter.
# If comparators are missing, the existing ones are simply repeated...
as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = "~")
# (12 ~ 2 ~ {} ~ 1)

as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c("~", "&gt;"))
# (12 ~ 2) &gt; ({} ~ 1)

# ... or the rest is cut off
as.PowerRelation(list(c(1,2), 2, c(), 1), comparators = c("~", "&gt;", "~", "~", "&gt;"))
# (12 ~ 2) &gt; ({} ~ 1)
</code></pre>

<hr>
<h2 id='coalitionsAreIndifferent'>Are coalitions indifferent</h2><span id='topic+coalitionsAreIndifferent'></span>

<h3>Description</h3>

<p>Check if coalitions are indifferent to one another, or, in other words, if they appear in the same equivalence class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalitionsAreIndifferent(powerRelation, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalitionsAreIndifferent_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="coalitionsAreIndifferent_+3A_c1">c1</code></td>
<td>
<p>Coalition <a href="base.html#topic+c">vector</a></p>
</td></tr>
<tr><td><code id="coalitionsAreIndifferent_+3A_c2">c2</code></td>
<td>
<p>Coalition <a href="base.html#topic+c">vector</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value <code>TRUE</code> if <code>c1</code> and <code>c2</code> are in the same equivalence class, else <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p>Other lookup functions: 
<code><a href="#topic+elementLookup">elementLookup</a>()</code>,
<code><a href="#topic+equivalenceClassIndex">equivalenceClassIndex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- PowerRelation(list(list(c(1,2)), list(1, 2)))

stopifnot(coalitionsAreIndifferent(pr, c(1,2), c(1)) == FALSE)
stopifnot(coalitionsAreIndifferent(pr, 2, 1) == TRUE)

# Note that it doesn't fail with non-existing power relations
stopifnot(coalitionsAreIndifferent(pr, 1, c()) == FALSE)
stopifnot(coalitionsAreIndifferent(pr, 3, c(1,2,3)) == TRUE)

</code></pre>

<hr>
<h2 id='copelandScores'>Copeland-like method</h2><span id='topic+copelandScores'></span><span id='topic+copelandRanking'></span>

<h3>Description</h3>

<p>Based on <code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code>, add or subtract scores
based on how an element fares against the others.
</p>
<p><code>copelandRanking()</code> returns the corresponding ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copelandScores(powerRelation, elements = powerRelation$elements)

copelandRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copelandScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="copelandScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strongly inspired by the Copeland score of social choice theory (Copeland 1951),
the Copeland-like solution is based on the net flow of the CP-majority graph (Allouche et al. 2020).
</p>
<p>Individuals are ordered according to the number of pairwise winning comparisons, minus the number of pairwise losing comparisons,
over the set of all CP-comparisons.
</p>
<p>More formally, in a given <code style="white-space: pre;">&#8288;PowerRelation pr&#8288;</code> with element <code class="reqn">i</code>, count the number of elements
<code class="reqn">j \in N \setminus \lbrace i \rbrace</code> where
<code><a href="#topic+cpMajorityComparison">cpMajorityComparison</a></code><code style="white-space: pre;">&#8288;(pr, i, j) &gt;= 0&#8288;</code> and subtract those where
<code><a href="#topic+cpMajorityComparison">cpMajorityComparison</a></code><code style="white-space: pre;">&#8288;(pr, i, j) &lt;= 0&#8288;</code>.
</p>


<h3>Value</h3>

<p>Score function returns a list of type <code>CopelandScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified). Each element is a vector of 2 numbers,
the number of pairwise winning comparisons and the number of pairwise losing comparisons.
Those two numbers summed together gives us the actual ordinal Copeland score.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>References</h3>

<p>Allouche T, Escoffier B, Moretti S, Öztürk M (2020).
&ldquo;Social Ranking Manipulability for the CP-Majority, Banzhaf and Lexicographic Excellence Solutions.&rdquo;
In Bessiere C (ed.), <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 17&ndash;23.
<a href="https://doi.org/10.24963/ijcai.2020/3">doi:10.24963/ijcai.2020/3</a>, Main track.
</p>
<p>Copeland AH (1951).
&ldquo;A reasonable social welfare function.&rdquo;
mimeo, 1951. University of Michigan.
</p>


<h3>See Also</h3>

<p>Other CP-majority based functions: 
<code><a href="#topic+cpMajorityComparison">cpMajorityComparison</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>
</p>
<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (123 ~ 12 ~ 3 ~ 1) &gt; (2 ~ 23) &gt; 13
pr &lt;- PowerRelation(list(
  list(c(1,2,3), c(1,2), 3, 1),
  list(c(2,3), 2),
  list(c(1,3))
))

copelandScores(pr)
# `1` = c(2, -1)
# `2` = c(2, -2)
# `3` = c(1, -2)

# only calculate results for two elements
copelandScores(pr, c(1,3))
# `1` = c(2, -1)
# `3` = c(1, -2)

# or just one element
copelandScores(pr, 2)
# `2` = c(2, -2)

# 1 &gt; 2 &gt; 3
copelandRanking(pr)

</code></pre>

<hr>
<h2 id='cpMajorityComparison'>CP-Majority relation</h2><span id='topic+cpMajorityComparison'></span><span id='topic+cpMajorityComparisonScore'></span>

<h3>Description</h3>

<p>The Ceteris Paribus-majority relation compares the relative success between two players joining a coalition.
</p>
<p><code>cpMajorityComparisonScore()</code> only returns two numbers, a positive number of coalitions where <code>e1</code> beats <code>e2</code>,
and a negative number of coalitions where <code>e1</code> is beaten by <code>e2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpMajorityComparison(
  powerRelation,
  e1,
  e2,
  strictly = FALSE,
  includeEmptySet = TRUE
)

cpMajorityComparisonScore(
  powerRelation,
  e1,
  e2,
  strictly = FALSE,
  includeEmptySet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpMajorityComparison_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="cpMajorityComparison_+3A_e1">e1</code>, <code id="cpMajorityComparison_+3A_e2">e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td></tr>
<tr><td><code id="cpMajorityComparison_+3A_strictly">strictly</code></td>
<td>
<p>Only include <code class="reqn">D_{ij}(\succ)</code> and <code class="reqn">D_{ji}(\succ)</code>, i.e., coalitions
<code class="reqn">S \in 2^{N \setminus \lbrace i,j\rbrace}</code> where
<code class="reqn">S \cup \lbrace i\rbrace \succ S \cup \lbrace j\rbrace</code> and
vice versa.</p>
</td></tr>
<tr><td><code id="cpMajorityComparison_+3A_includeemptyset">includeEmptySet</code></td>
<td>
<p>If <code>TRUE</code>, check <code class="reqn">\lbrace i \rbrace \succsim \lbrace j \rbrace</code> even if
empty set is not part of the power relation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two elements <code class="reqn">i</code> and <code class="reqn">j</code>, go through each coalition <code class="reqn">S \in 2^{N \setminus \lbrace i, j \rbrace}</code>.
<code class="reqn">D_{ij}(\succsim)</code> then contains all coalitions <code class="reqn">S</code> where
<code class="reqn">S \cup \lbrace i \rbrace \succsim S \cup \lbrace j \rbrace</code> and <code class="reqn">D_{ji}(\succsim)</code> contains all coalitions where
<code class="reqn">S \cup \lbrace j \rbrace \succsim S \cup \lbrace i \rbrace</code>.
</p>
<p>The cardinalities
<code class="reqn">d_{ij}(\succsim) = |D_{ij}|</code> and
<code class="reqn">d_{ji}(\succsim) = |D_{ji}|</code> represent the score of the two elements, where
<code class="reqn">i \succ j</code>    if <code class="reqn">d_{ij}(\succsim)   &gt;  d_{ji}(\succsim)</code> and
<code class="reqn">i \sim  j</code>    if <code class="reqn">d_{ij}(\succsim)  ==  d_{ji}(\succsim)</code>.
</p>
<p><code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code> tries to retain all that information. The list returned contains the following information.
Note that in this context the two elements <code class="reqn">i</code> and <code class="reqn">j</code> refer to element 1 and element 2 respectively.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$e1&#8288;</code>: list of information about element 1
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$e1$name&#8288;</code>: name of element 1
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$e1$score&#8288;</code>: score <code class="reqn">d_{ij}(\succsim)</code>. <code class="reqn">d_{ij}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$e1$winningCoalitions&#8288;</code>: list of coalition <code><a href="base.html#topic+c">vectors</a></code> <code class="reqn">S \in D_{ij}(\succsim)</code>. <code class="reqn">S \in D_{ij}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li></ul>

</li>
<li> <p><code style="white-space: pre;">&#8288;$e2&#8288;</code>: list of information about element 2
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$e2$name&#8288;</code>: name of element 2
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$e1$score&#8288;</code>: score <code class="reqn">d_{ji}(\succsim)</code>. <code class="reqn">d_{ji}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$e1$winningCoalitions&#8288;</code>: list of coalition <code><a href="base.html#topic+c">vectors</a></code> <code class="reqn">S \in D_{ji}(\succsim)</code>.  <code class="reqn">S \in D_{ji}(\succ)</code> if <code>strictly == TRUE</code>
</p>
</li></ul>

</li>
<li> <p><code style="white-space: pre;">&#8288;$winner&#8288;</code>: name of higher scoring element. <code>NULL</code> if they are indifferent.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$loser&#8288;</code>: name of lower scoring element. <code>NULL</code> if they are indifferent.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$tuples&#8288;</code>: a list of coalitions <code class="reqn">S \in 2^{N \setminus \lbrace i, j \rbrace }</code> with:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$tuples[[x]]$coalition&#8288;</code>: <code><a href="base.html#topic+c">vector</a></code>, the coalition <code class="reqn">S</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$tuples[[x]]$included&#8288;</code>: logical, <code>TRUE</code> if <code class="reqn">S \cup \lbrace i \rbrace</code> and <code class="reqn">S \cup \lbrace j \rbrace</code> are in the power relation
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$tuples[[x]]$winner&#8288;</code>: name of the winning element <code class="reqn">i</code> where <code class="reqn">S \cup \lbrace i \rbrace \succ S \cup \lbrace j \rbrace</code>. It is <code>NULL</code> if <code class="reqn">S \cup \lbrace i \rbrace \sim S \cup \lbrace j \rbrace</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$tuples[[x]]$e1&#8288;</code>: index <code class="reqn">x_1</code> at which <code class="reqn">S \cup \lbrace i \rbrace \in \sum_{x_1}</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$tuples[[x]]$e2&#8288;</code>: index <code class="reqn">x_2</code> at which <code class="reqn">S \cup \lbrace j \rbrace \in \sum_{x_2}</code>
</p>
</li></ul>

</li></ul>

<p>The much more efficient <code><a href="#topic+cpMajorityComparisonScore">cpMajorityComparisonScore()</a></code> only calculates <code style="white-space: pre;">&#8288;$e1$score&#8288;</code>.
</p>
<p>Unlike Lexcel, Ordinal Banzhaf, etc., this power relation can introduce cycles. For this reason the function
<code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code> and <code><a href="#topic+cpMajorityComparisonScore">cpMajorityComparisonScore()</a></code> only offers direct comparisons between two elements
and not a ranking of all players. See the other CP-majority based functions that offer a way to rank all players.
</p>


<h3>Value</h3>

<p><code>cpMajorityComparison()</code> returns a list with elements described in the details.
</p>
<p><code>cpMajorityComparisonScore()</code> returns a vector of two numbers, a positive number of coalitions where <code>e1</code> beats <code>e2</code>
(<code class="reqn">d_{ij}(\succsim)</code>), and a negative number of coalitions where <code>e1</code> is beaten by <code>e2</code> (<code class="reqn">-d_{ji}(\succsim)</code>).
</p>


<h3>References</h3>

<p>Haret A, Khani H, Moretti S, Öztürk M (2018).
&ldquo;Ceteris paribus majority for social ranking.&rdquo;
In <em>27th International Joint Conference on Artificial Intelligence (IJCAI-ECAI-18)</em>, 303&ndash;309.
</p>
<p>Fayard N, Escoffier MÖ (2018).
&ldquo;Ordinal Social ranking: simulation for CP-majority rule.&rdquo;
In <em>DA2PL'2018 (From Multiple Criteria Decision Aid to Preference Learning)</em>.
</p>


<h3>See Also</h3>

<p>Other CP-majority based functions: 
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("ac &gt; (a ~ b) &gt; (c ~ bc)")

scores &lt;- cpMajorityComparison(pr, "a", "b")
scores
# a &gt; b
# D_ab = {c, {}}
# D_ba = {{}}
# Score of a = 2
# Score of b = 1

stopifnot(scores$e1$name == "a")
stopifnot(scores$e2$name == "b")
stopifnot(scores$e1$score == 2)
stopifnot(scores$e2$score == 1)
stopifnot(scores$e1$score == length(scores$e1$winningCoalitions))
stopifnot(scores$e2$score == length(scores$e2$winningCoalitions))

# get tuples with coalitions S in 2^(N - {i,j})
emptySetTuple &lt;- Filter(function(x) identical(x$coalition, c()), scores$tuples)[[1]]
playerCTuple  &lt;- Filter(function(x) identical(x$coalition, "c"), scores$tuples)[[1]]

# because {}u{a} ~ {}u{b}, there is no winner
stopifnot(is.null(emptySetTuple$winner))
stopifnot(emptySetTuple$e1 == emptySetTuple$e2)

# because {c}u{a} &gt; {c}u{b}, player "a" gets the score
stopifnot(playerCTuple$winner == "a")
stopifnot(playerCTuple$e1 &lt; playerCTuple$e2)
stopifnot(playerCTuple$e1 == 1L)
stopifnot(playerCTuple$e2 == 3L)

cpMajorityComparisonScore(pr, "a", "b") # c(1,0)
cpMajorityComparisonScore(pr, "b", "a") # c(0,-1)

</code></pre>

<hr>
<h2 id='createPowerset'>Create powerset</h2><span id='topic+createPowerset'></span>

<h3>Description</h3>

<p>Given a vector of elements generate a power set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPowerset(
  elements,
  includeEmptySet = TRUE,
  result = c("return", "print", "copy", "printCompact", "copyCompact")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createPowerset_+3A_elements">elements</code></td>
<td>
<p>vector of elements</p>
</td></tr>
<tr><td><code id="createPowerset_+3A_includeemptyset">includeEmptySet</code></td>
<td>
<p>If <code>TRUE</code>, an empty vector is added at the end</p>
</td></tr>
<tr><td><code id="createPowerset_+3A_result">result</code></td>
<td>
<p>What to do with the result. Can be either:
</p>

<ul>
<li> <p><code>"return"</code>: return list object
</p>
</li>
<li> <p><code>"print"</code>: create valid string to call <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code> and print it
</p>
</li>
<li> <p><code>"copy"</code>: create valid string to call <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code> and copy it to clipboard
</p>
</li>
<li> <p><code>"printCompact"</code> and <code>"copyCompact"</code>: same as <code>"print"</code> and <code>"copy"</code> but without newlines
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List of power set vectors.
If the parameter <code>result</code> is set to <code>"print"</code> or <code>"copy"</code>, nothing is returned.
Instead, a character string is generated that can be used in R to call and create a new <code><a href="#topic+PowerRelation">PowerRelation</a></code> object.
This string is either printed or copied to clipboard (see argument <code>result</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># normal return type is a list of vectors
createPowerset(c("Alice", "Bob"), includeEmptySet = FALSE)
## [[1]]
## [1] "Alice" "Bob"
##
## [[2]]
## [1] "Alice"
##
## [[3]]
## [1] "Bob"

# instead of creating a list, print the power set such that it can be copy-pasted
# and used to create a new PowerRelation object
createPowerset(letters[1:4], result = "print")
# prints
# as.PowerRelation("
#   abcd
#   &gt; abc
#   &gt; abd
#   &gt; acd
#   &gt; bcd
#   &gt; ab
#   ...
#   &gt; {}
# ")

createPowerset(letters[1:3], includeEmptySet = FALSE, result = "printCompact")
# as.PowerRelation("abc &gt; ab &gt; ac &gt; bc &gt; a &gt; b &gt; c")

# create the same string as before, but now copy it to the clipboard instead
if(interactive()) {
  createPowerset(1:3, result = "copyCompact")
}

# Note that as.PowerRelation(character) only assumes single-char elements.
# As such, the generated function call string with multi-character names
# looks a little different.
createPowerset(c("Alice", "Bob"), result = "print")
# PowerRelation(rlang::list2(
#   list(c("Alice", "Bob")),
#   list(c("Alice")),
#   list(c("Bob")),
#   list(c()),
# ))

</code></pre>

<hr>
<h2 id='cumulativeScores'>Cumulative scores</h2><span id='topic+cumulativeScores'></span><span id='topic+cumulativelyDominates'></span>

<h3>Description</h3>

<p>Calculate cumulative score vectors for each element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulativeScores(powerRelation, elements = powerRelation$elements)

cumulativelyDominates(powerRelation, e1, e2, strictly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulativeScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="cumulativeScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
<tr><td><code id="cumulativeScores_+3A_e1">e1</code>, <code id="cumulativeScores_+3A_e2">e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td></tr>
<tr><td><code id="cumulativeScores_+3A_strictly">strictly</code></td>
<td>
<p>If <code>TRUE</code>, check if <code>p1</code> <em>strictly</em> dominates <code>p2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An element's cumulative score vector is calculated by cumulatively adding up the
amount of times it appears in each equivalence class in the <code>powerRelation</code>.
I.e., in a linear power relation with eight coalitions, if element 1 appears in coalitions placed at 1, 3, and 6,
its score vector is [1, 1, 2, 2, 2, 3, 3, 3].
</p>


<h3>Value</h3>

<p>Score function returns a list of type <code>CumulativeScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>powerRelation$eqs</code>, cumulatively counting up the number of
times the given element appears in each equivalence class.
</p>
<p><code>cumulativelyDominates()</code> returns <code>TRUE</code> if <code>e1</code> cumulatively dominates <code>e2</code>, else <code>FALSE</code>.
</p>


<h3>Dominance</h3>

<p><code class="reqn">i</code> dominates <code class="reqn">j</code> if, for each index
<code class="reqn">x, \textrm{Score}(i)_x \geq \textrm{Score}(j)_x</code>.
</p>
<p><code class="reqn">i</code> <em>strictly</em> dominates <code class="reqn">j</code> if there exists an <code class="reqn">x</code> such that
<code class="reqn">\textrm{Score}(i)_x &gt; \textrm{Score}(j)_x</code>.
</p>


<h3>References</h3>

<p>Moretti S (2015).
&ldquo;An axiomatic approach to social ranking under coalitional power relations.&rdquo;
<em>Homo Oeconomicus</em>, <b>32</b>(2), 183&ndash;208.
</p>
<p>Moretti S, Öztürk M (2017).
&ldquo;Some axiomatic and algorithmic perspectives on the social ranking problem.&rdquo;
In <em>International Conference on Algorithmic Decision Theory</em>, 166&ndash;181.
Springer.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; 1 &gt; 2")

# `1`: c(1, 2, 2)
# `2`: c(1, 1, 2)
cumulativeScores(pr)

# calculate for selected number of elements
cumulativeScores(pr, c(2))

# TRUE
d1 &lt;- cumulativelyDominates(pr, 1, 2)

# TRUE
d2 &lt;- cumulativelyDominates(pr, 1, 1)

# FALSE
d3 &lt;- cumulativelyDominates(pr, 1, 1, strictly = TRUE)

stopifnot(all(d1, d2, !d3))

</code></pre>

<hr>
<h2 id='dominates'>Dominance</h2><span id='topic+dominates'></span>

<h3>Description</h3>

<p>Check if one element dominates the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominates(powerRelation, e1, e2, strictly = FALSE, includeEmptySet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominates_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="dominates_+3A_e1">e1</code>, <code id="dominates_+3A_e2">e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td></tr>
<tr><td><code id="dominates_+3A_strictly">strictly</code></td>
<td>
<p>If <code>TRUE</code>, check if <code>p1</code> <em>strictly</em> dominates <code>p2</code></p>
</td></tr>
<tr><td><code id="dominates_+3A_includeemptyset">includeEmptySet</code></td>
<td>
<p>If <code>TRUE</code>, check <code class="reqn">\lbrace i \rbrace \succsim \lbrace j \rbrace</code> even if
empty set is not part of the power relation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">i</code> is said to dominate <code class="reqn">j</code> if
<code class="reqn">S \cup \lbrace i \rbrace \succsim S \cup \lbrace j \rbrace</code> for all
<code class="reqn">S \in 2^{N \setminus \lbrace i,j \rbrace}</code>.
</p>
<p><code class="reqn">i</code> <em>strictly</em> dominates <code class="reqn">j</code> if there also exists an
<code class="reqn">S \in 2^{N \setminus \lbrace i,j \rbrace}</code> such that
<code class="reqn">S \cup \lbrace i \rbrace \succ S \cup \lbrace j \rbrace</code>.
</p>


<h3>Value</h3>

<p>Logical value <code>TRUE</code> if <code>e1</code> dominates <code>e2</code>, else <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; 1 &gt; 2")

# TRUE
d1 &lt;- dominates(pr, 1, 2)

# FALSE
d2 &lt;- dominates(pr, 2, 1)

# TRUE (because it's not strict dominance)
d3 &lt;- dominates(pr, 1, 1)

# FALSE
d4 &lt;- dominates(pr, 1, 1, strictly = TRUE)

stopifnot(all(d1, !d2, d3, !d4))

</code></pre>

<hr>
<h2 id='doRanking'>Create a <code>SocialRanking</code> object</h2><span id='topic+doRanking'></span>

<h3>Description</h3>

<p>Rank elements based on their scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doRanking(scores, compare = NULL, decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doRanking_+3A_scores">scores</code></td>
<td>
<p>A vector or list representing each element's score. If <code>names(scores)</code> is not <code>NULL</code>, those will be used as element names.
Else a number sequence corresponding to the elements is generated.</p>
</td></tr>
<tr><td><code id="doRanking_+3A_compare">compare</code></td>
<td>
<p>Optional comparison function taking in two elements and returning a numerical value based on the relation between
these two elements. If set to <code>NULL</code>, the default <code><a href="base.html#topic+order">order()</a></code> function is called. See details for more information.</p>
</td></tr>
<tr><td><code id="doRanking_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code> (default), elements with higher scores are ranked higher.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All ranking solutions in the package are tied to the scores or score vectors of the elements.
For these kinds of solutions, <code>doRanking()</code> offers a simple way that turns a (named) vector or list of scores for each element into a <code>SocialRanking</code> object.
For example, <code>doRanking(c(a=1,b=2))</code> produces <code>b &gt; a</code> (<code class="reqn">b P^\succsim a</code>), because <code>b</code> with a score of <code>2</code> should be placed higher than <code>a</code> with a score of <code>1</code>.
</p>
<p>Ranking solutions in the package include <code><a href="#topic+lexcelRanking">lexcelRanking()</a></code>, <code><a href="#topic+ordinalBanzhafRanking">ordinalBanzhafRanking()</a></code> and <code><a href="#topic+L1Ranking">L1Ranking()</a></code>, among others.
These functions take a power relation, calculate the scores of each element and returns a <code>SocialRanking</code> object.
</p>
<p>R natively supports sorting for <a href="base.html#topic+c">vectors</a>, but not for <a href="base.html#topic+list">lists</a>.
If the use of lists is necessary, or if the native sort method in vectors does not produce the desired results, there are two possible ways to solve this:
</p>

<ol>
<li><p> by the introduction of custom S3 classes, or
</p>
</li>
<li><p> by setting the <code>compare</code> parameter in <code>doRanking()</code>.
</p>
</li></ol>

<p>For S3 classes, the class for the score object has to be set and the <code>==</code> and <code>&gt;</code> (and <code>[</code> for lists) operators overloaded.
I.e., <code><a href="#topic+lexcelScores">lexcelScores()</a></code> returns a list with the custom class <code>LexcelScores</code> that implements <code style="white-space: pre;">&#8288;==.LexcelScores&#8288;</code>, <code style="white-space: pre;">&#8288;&gt;.LexcelScores&#8288;</code>, <code style="white-space: pre;">&#8288;[.LexcelScores&#8288;</code> and <code>is.na.LexcelScores</code>.
</p>
<p>In cases where we only want to experiment, introducing new S3 classes can be cumbersome.
As an alternative, the <code>compare</code> parameter can be assigned a function.
This function must take two parameters, i.e., <code style="white-space: pre;">&#8288;function(a, b)&#8288;</code>, where <code>a</code> and <code>b</code> are the scores of two arbitrary elements.
The function then must return one of the following:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (positive value) if score <code>a</code> is ranked higher than score <code>b</code>,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;&lt; 0&#8288;</code> (negative value) if score <code>a</code> is ranked lower than score <code>b</code>, or
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;= 0&#8288;</code> if both scores <code>a</code> and <code>b</code> are considered equal.
</p>
</li></ul>

<p>In <code>doRanking(c(a=3,b=2,c=2), compare = function(a,b) a - b)</code>, the compare function returns a positive value of the first parameter is larger than the second.
<code>a</code> has the highest value and will there for be ranked highest, <code>a &gt; b ~ c</code>.
</p>
<p>Conversely, <code>doRanking(c(a=3,b=2,c=2), compare = function(a,b) b - a)</code> favors elements with lower scores, resulting in the element ranking <code>b ~ c &gt; a</code>.
</p>


<h3>Value</h3>

<p>A list of type <code>SocialRanking</code>.
Each element of the list contains a <a href="base.html#topic+c">vector</a> of elements in <code>powerRelation$elements</code> that are indifferent to one another.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SocialRanking">SocialRanking()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doRanking(c(a=1,b=2))
# b &gt; a

doRanking(c(a=2,b=2))
# a ~ b

# a custom ranking function. Here, we implement the following ranking solution:
# disregard any big coalitions and only rank elements based on their individual performances
# iRj if and only if {i} &gt;= {j}
singletonRanking &lt;- function(pr) {
  scores &lt;- sapply(pr$elements, equivalenceClassIndex, powerRelation = pr)
  # note that coalitions in higher indexed equivalence classes are less preferable
  # hence, scores should be sorted in an increasing order
  doRanking(scores, decreasing = FALSE)
}

pr &lt;- as.PowerRelation("abc &gt; ab &gt; ac &gt; b ~ c ~ bc &gt; a")
singletonRanking(pr)
# b ~ c &gt; a

# a reverse lexcel ranking, where vectors are compared right to left
# here, we introduce a compare function. It returns:
# * 0, if a and b are identical
# * a positive value, if a[i] &gt; b[i] and every value after that is equal
# * a negative value, if a[i] &lt; b[i] and every value after that is equal
reverseLexcelCompare &lt;- function(a, b) {
  i &lt;- which(a != b) |&gt; rev()
  if(length(i) == 0) 0
  else a[i[1]] - b[i[1]]
}

scores &lt;- unclass(cumulativeScores(pr))

# R cannot natively sort a class. Instead:
# Method 1 - utilize the compare parameter
doRanking(scores, compare = reverseLexcelCompare)


# Method 2 - introduce S3 class
`[.RevLex` &lt;- function(x, i, ...) structure(unclass(x)[i], class = "RevLex")
`==.RevLex` &lt;- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) == 0
`&gt;.RevLex` &lt;- function(a, b) reverseLexcelCompare(a[[1]],b[[1]]) &gt; 0
is.na.RevLex &lt;- function(x) FALSE
doRanking(structure(scores, class = "RevLex"))

stopifnot(
  doRanking(scores, compare = reverseLexcelCompare) ==
  doRanking(structure(scores, class = "RevLex"))
)

</code></pre>

<hr>
<h2 id='elementLookup'>Element lookup</h2><span id='topic+elementLookup'></span>

<h3>Description</h3>

<p>List coalitions that an element appears in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elementLookup(powerRelation, element)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elementLookup_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="elementLookup_+3A_element">element</code></td>
<td>
<p>an element in <code>powerRelation$elements</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>powerRelation$elementLookup(element)</code>.
The returned list contains tuples containing the index to find the corresponding coalitions in <code>powerRelation$eqs</code>.
</p>
<p>If  <code>elementLookup(powerRelation, 2)</code> returns <code>list(c(1,1), c(1,2), c(3,1))</code>, we can determine that the element <code>2</code>
appears twice in equivalence class <code>1</code> and once in equivalence class <code>3</code>.
The specific coalition then can be accessed with <code>powerRelation$eqs[[i]][[j]]</code>, where <code>i</code> is the equivalence class index
and <code>j</code> is the coalition in that equivalence class containing the element.
</p>


<h3>Value</h3>

<p>List of tuples, each of size 2.
First value of a tuple indicates the equivalence class index,
the second value the index inside that equivalence class with the coalition containing the element.
Returns <code>NULL</code> if the element does not exist.
</p>


<h3>See Also</h3>

<p>Other lookup functions: 
<code><a href="#topic+coalitionsAreIndifferent">coalitionsAreIndifferent</a>()</code>,
<code><a href="#topic+equivalenceClassIndex">equivalenceClassIndex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; 2 ~ 1")

l &lt;- elementLookup(pr, 1)
l
# (1,1), (2,2)

sapply(l, function(tuple) 1 %in% pr$eqs[[tuple[1]]][[tuple[2]]]) |&gt; all() |&gt; stopifnot()

# if element does not exist, it returns NULL
elementLookup(pr, 3) |&gt; is.null() |&gt; stopifnot()

</code></pre>

<hr>
<h2 id='equivalenceClassIndex'>Get index of equivalence class containing a coalition</h2><span id='topic+equivalenceClassIndex'></span><span id='topic+coalitionLookup'></span>

<h3>Description</h3>

<p>Given a <code>coalition</code> <a href="base.html#topic+c">vector</a>, return the equivalence class index it appears in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalenceClassIndex(powerRelation, coalition)

coalitionLookup(powerRelation, coalition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalenceClassIndex_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="equivalenceClassIndex_+3A_coalition">coalition</code></td>
<td>
<p>a coalition <a href="base.html#topic+c">vector</a> or that is part of <code>powerRelation</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>powerRelation$coalitionLookup(coalition)</code>.
</p>
<p><code>equivalenceClassIndex()</code> serves as an alias to <code>coalitionLookup()</code>.
</p>


<h3>Value</h3>

<p>Numeric value, equivalence class index containing <code>coalition</code>.
<code>NULL</code> if the coalition does not exist.
If the <code>powerRelation</code> contains cycles, it is possible that multiple values are returned.
</p>


<h3>See Also</h3>

<p>Other lookup functions: 
<code><a href="#topic+coalitionsAreIndifferent">coalitionsAreIndifferent</a>()</code>,
<code><a href="#topic+elementLookup">elementLookup</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; 2 ~ 1")

(e1 &lt;- equivalenceClassIndex(pr, c(1, 2)))
# 1

(e2 &lt;- equivalenceClassIndex(pr, c(1)))
# 2

(e3 &lt;- equivalenceClassIndex(pr, c(2)))
# 2

(e4 &lt;- equivalenceClassIndex(pr, c()))
# NULL &lt;- empty set does not exist

stopifnot(all(c(e1,e2,e3,e4) == c(1,2,2)))

</code></pre>

<hr>
<h2 id='generateNextPartition'>Next partition</h2><span id='topic+generateNextPartition'></span>

<h3>Description</h3>

<p>Skip to the next partition of the generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNextPartition(gen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateNextPartition_+3A_gen">gen</code></td>
<td>
<p>A generator object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generator function.
If the generator is already down to its last partition, it will throw an error.
</p>


<h3>See Also</h3>

<p>Other generator functions: 
<code><a href="#topic+powerRelationGenerator">powerRelationGenerator</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coalitions &lt;- createPowerset(c('a','b'), includeEmptySet = FALSE)
# list(c('a','b'), 'a', 'b')

gen &lt;- powerRelationGenerator(coalitions)
gen()
# (ab ~ a ~ b)

gen()
# (ab ~ b) &gt; a

# skipping partition of size two, where the first partition has
# 2 coalitions and the second partition has 1 coalition
gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; (a ~ b)

# only remaining partition is one of size 3, wherein each
# equivalence class is of size 1
gen &lt;- generateNextPartition(gen)
gen()
# ab &gt; a &gt; b

# went through all partitions, it will only generate NULL now
gen &lt;- generateNextPartition(gen)
stopifnot(is.null(gen()))

</code></pre>

<hr>
<h2 id='kramerSimpsonScores'>Kramer-Simpson-like method</h2><span id='topic+kramerSimpsonScores'></span><span id='topic+kramerSimpsonRanking'></span>

<h3>Description</h3>

<p>Calculate the Kramer-Simpson-like scores.
Higher scores are better.
</p>
<p><code>kramerSimpsonRanking()</code> returns the corresponding ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kramerSimpsonScores(powerRelation, elements = powerRelation$elements)

kramerSimpsonRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kramerSimpsonScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="kramerSimpsonScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by the Kramer-Simpson method of social choice theory (Simpson 1969) (Kramer 1975), the <em>Kramer-Simpson-like</em>
method compares each element against all other elements using the CP-Majority rule.
</p>
<p>For a given element <code class="reqn">i</code>, calculate the <code><a href="#topic+cpMajorityComparisonScore">cpMajorityComparisonScore()</a></code>
against all elements <code class="reqn">j</code>, <code class="reqn">d_{ji}(\succsim)</code> (notice that <code class="reqn">i</code> and
<code class="reqn">j</code> are in reverse order).
<code class="reqn">-\max_{j \in N \setminus \lbrace i \rbrace}(d_{ji}(\succsim))</code> then
determines the final score, where higher scoring elements are ranked higher (notice the negative symbol in front of the <code class="reqn">\max</code> statement).
</p>
<p>The implementation slightly differs from the original definition in Allouche T, Escoffier B, Moretti S, Öztürk M (2020).
&ldquo;Social Ranking Manipulability for the CP-Majority, Banzhaf and Lexicographic Excellence Solutions.&rdquo;
In Bessiere C (ed.), <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 17&ndash;23.
<a href="https://doi.org/10.24963/ijcai.2020/3">doi:10.24963/ijcai.2020/3</a>, Main track..
While the ranking solution itself is the same, the scores for this package are intentionally multiplied by -1,
as this significantly improves performance when sorting the elements, as well as making simple comparisons between elements more logical to the user.
</p>


<h3>Value</h3>

<p>Score function returns a vector of type <code>KramerSimpsonScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified). Higher scoring elements are ranked higher.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>References</h3>

<p>Allouche T, Escoffier B, Moretti S, Öztürk M (2020).
&ldquo;Social Ranking Manipulability for the CP-Majority, Banzhaf and Lexicographic Excellence Solutions.&rdquo;
In Bessiere C (ed.), <em>Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20</em>, 17&ndash;23.
<a href="https://doi.org/10.24963/ijcai.2020/3">doi:10.24963/ijcai.2020/3</a>, Main track.
</p>
<p>Simpson PB (1969).
&ldquo;On defining areas of voter choice: Professor Tullock on stable voting.&rdquo;
<em>The Quarterly Journal of Economics</em>, <b>83</b>(3), 478&ndash;490.
</p>
<p>Kramer GH (1975).
&ldquo;A dynamical model of political equilibrium.&rdquo;
<em>Journal of Economic Theory</em>, <b>16</b>(2), 310&ndash;334.
</p>


<h3>See Also</h3>

<p>Other CP-majority based functions: 
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cpMajorityComparison">cpMajorityComparison</a>()</code>
</p>
<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 &gt; (1 ~ 3) &gt; 12 &gt; (13 ~ 23) &gt; {} &gt; 123
pr &lt;- as.PowerRelation("2 &gt; (1~3) &gt; 12 &gt; (13~23) &gt; {} &gt; 123")

# get scores for all elements
# cpMajorityComparisonScore(pr, 2, 1, strictly = TRUE)[1] = 1
# cpMajorityComparisonScore(pr, 3, 1, strictly = TRUE)[1] = 0
# therefore the Kramer-Simpson-Score for element
# `1` = -max(0, 1) = -1
#
# Score analogous for the other elements
# `2` = 0
# `3` = -2
kramerSimpsonScores(pr)

# get scores for two elements
# `1` = 1
# `3` = 2
kramerSimpsonScores(pr, c(1,3))

# or single element
# result is still a list
kramerSimpsonScores(pr, 2)

# 2 &gt; 1 &gt; 3
kramerSimpsonRanking(pr)

</code></pre>

<hr>
<h2 id='L1Scores'>L1 Ranking</h2><span id='topic+L1Scores'></span><span id='topic+L1Ranking'></span><span id='topic+lexcel1Scores'></span><span id='topic+lexcel1Ranking'></span>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{(1)}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1Scores(powerRelation, elements = powerRelation$elements)

L1Ranking(powerRelation)

lexcel1Scores(powerRelation, elements = powerRelation$elements)

lexcel1Ranking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1Scores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="L1Scores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <code><a href="#topic+lexcelRanking">lexcelRanking()</a></code>, the number of times an element appears in each equivalence class is counted.
In addition, we now also consider the size of the coalitions.
</p>
<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>The <code class="reqn">L^{(1)}</code> rewards elements that appear in higher ranking coalitions as well as in smaller coalitions.
When comparing two matrices for a power relation, if <code class="reqn">M^\succsim_i &gt;_{L^{(1)}} M^\succsim_j</code>,
this suggests that there exists a <code class="reqn">p^0 \in \{1, \dots, |N|\}</code> and <code class="reqn">q^0 \in \{1, \dots, m\}</code> such that the following holds:
</p>

<ol>
<li> <p><code class="reqn">(M^\succsim_i)_{p^0,q^0} &gt; (M^\succsim_j)_{p^0,q^0}</code>
</p>
</li>
<li> <p><code class="reqn">(M^\succsim_i)_{p,q^0} = (M^\succsim_j)_{p,q^0}</code> for all <code class="reqn">p &lt; p^0</code>
</p>
</li>
<li> <p><code class="reqn">(M^\succsim_i)_{p,q} = (M^\succsim_j)_{p,q}</code> for all <code class="reqn">q &lt; q^0</code> and <code class="reqn">p \in \{1, \dots, |N|\}</code>
</p>
</li></ol>



<h3>Value</h3>

<p>Score function returns a list of type <code>L1Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>powerRelation$eqs</code>, the number of
times the given element appears in each equivalence class.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 13 \sim 2) \succ (12 \sim 1 \sim 3) \succ (23 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 1 &amp; 0\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p>From <code class="reqn">(M^\succsim_2)_{1,1} &gt; (M^\succsim_1)_{1,1}</code> and <code class="reqn">(M^\succsim_2)_{1,1} &gt; (M^\succsim_3)_{1,1}</code> it
immediately follows that <code class="reqn">2</code> is ranked above <code class="reqn">1</code> and <code class="reqn">3</code> according to <code class="reqn">L^{(1)}</code>.
</p>
<p>Comparing <code class="reqn">1</code> against <code class="reqn">3</code> we can set <code class="reqn">p^0 = 2</code> and <code class="reqn">q^0 = 2</code>.
Following the constraints from the definition above, we can verify that the entire column 1 is identical.
In column 2, we determine that <code class="reqn">(M^\succsim_1)_{1,q^0} = (M^\succsim_3)_{1,q^0}</code>, whereas
<code class="reqn">(M^\succsim_1)_{p^0,q^0} &gt; (M^\succsim_3)_{p^0,q^0}</code>, indicating that <code class="reqn">1</code>
is ranked higher than <code class="reqn">3</code>, hence <code class="reqn">2 \succ 1 \succ 3</code> according to <code class="reqn">L^{(1)}</code>.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcel1Scores()</code> and <code>lexcel1Ranking()</code> serve as aliases for <code>L1Scores()</code> and <code>L1Ranking()</code>, respectively.
</p>


<h3>References</h3>

<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
&ldquo;Lexicographic solutions for coalitional rankings.&rdquo;
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1&ndash;33.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("(123 ~ 13 ~ 2) &gt; (12 ~ 1 ~ 3) &gt; (23 ~ {})")
scores &lt;- L1Scores(pr)
scores$`1`
#      [,1] [,2] [,3]
# [1,]    0    1    0
# [2,]    1    1    0
# [3,]    1    0    0

L1Ranking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>

<hr>
<h2 id='L2Scores'>L2 Ranking</h2><span id='topic+L2Scores'></span><span id='topic+L2Ranking'></span><span id='topic+lexcel2Scores'></span><span id='topic+lexcel2Ranking'></span>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{(2)}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2Scores(powerRelation, elements = powerRelation$elements)

L2Ranking(powerRelation)

lexcel2Scores(powerRelation, elements = powerRelation$elements)

lexcel2Ranking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L2Scores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="L2Scores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>Given two elements <code class="reqn">i, j \in N</code>, <code class="reqn">L^{(2)}</code> then ranks
<code class="reqn">i</code> <em>strictly above</em> <code class="reqn">j</code> if there is some row
<code class="reqn">p^0 \in \lbrace 1, \dots, |N| \rbrace</code> and column
<code class="reqn">q^0 \in \lbrace 1, \dots, m \rbrace</code> such that
</p>

<ol>
<li> <p><code class="reqn">\sum_{p = 1}^{|N|} (M^\succsim_i)_{p,q} = \sum_{p = 1}^{|N|} (M^\succsim_j)_{p,q}\text{ for all } q &lt; q^0</code>,
</p>
</li>
<li> <p><code class="reqn">\begin{cases}
\text{(i)\hphantom{i} either } &amp; \sum_{p=1}^{|N|} (M^\succsim_i)_{p,q^0} &gt; \sum_{p=1}^{|N|} (M^\succsim_j)_{p,q^0}\\[5pt]
\text{(ii) or } &amp; (M^\succsim_i)_{p^0,q^0} &gt; (M^\succsim_j)_{p^0,q^0} \text{ and } (M^\succsim_i)_{p,q^0} = (M^\succsim_j)_{p,q^0} \text{ for all } p &lt; p^0
\end{cases}</code>
</p>
</li></ol>

<p>Note that the conditions are very similar to <code><a href="#topic+L1Ranking">L1Ranking()</a></code>, with the difference that condition 3.(i)
also ranks an element over another if they simply appear more often in an equivalence class, regardless of coalition size.
This implies that a row <code class="reqn">p^0</code> for condition 3.(ii) to be satisfied may not have to exist.
</p>


<h3>Value</h3>

<p>Score function returns a list of type <code>L2Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a matrix with <code>length(powerRelation$eqs)</code> columns and <code>1 + length(powerRelation$elements)</code> rows.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">N = \lbrace 1, 2, 3, 4 \rbrace</code> and <code class="reqn">\succsim: (123 \sim 12 \sim 13 \sim 14 \sim 2 \sim 4) \succ S</code>,
where <code class="reqn">S</code> is every other coalition not present in the first equivalence class.
From this, we get the following four matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 1\\
3 &amp; 0\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0\\
1 &amp; 2\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 1\\
1 &amp; 2\\
1 &amp; 2\\
0 &amp; 1
\end{bmatrix}
M^\succsim_4 = \begin{bmatrix}
1 &amp; 0\\
1 &amp; 2\\
0 &amp; 3\\
0 &amp; 1
\end{bmatrix}
</code>
</p>

<p>For the sums in column 1, we get
</p>
<p style="text-align: center;"><code class="reqn">\begin{aligned}\sum_{p=1}^{4} (M^\succsim_1)_{p,1} &amp;= 4,\\\sum_{p=1}^{4} (M^\succsim_2)_{p,1} &amp;= 3,\\\sum_{p=1}^{4} (M^\succsim_3)_{p,1} = \sum_{p=1}^{4} (M^\succsim_4)_{p,1} &amp;= 2\end{aligned}.</code>
</p>

<p>This immediately puts <code class="reqn">1</code> above all other elements and <code class="reqn">2</code> above <code class="reqn">3</code> and <code class="reqn">4</code> according to the <code class="reqn">L^{(2)}</code>.
<code class="reqn">L^{(1)}</code> would in this case prefer <code class="reqn">2</code> over <code class="reqn">1</code>, simply because <code class="reqn">2</code> appears once in a coalition of size 1 and <code class="reqn">1</code> doesn't.
</p>
<p>Since the column sum for <code class="reqn">3</code> and <code class="reqn">4</code> is the same, we can next evaluate if the individual row values are also the same.
Here, since <code class="reqn">(M^\succsim_4)_{1,1} &gt; (M^\succsim_3)_{1,1}</code>, this gives an edge of element <code class="reqn">4</code> over <code class="reqn">3</code>.
</p>
<p>Note that, if the column was identical for <code class="reqn">3</code> and <code class="reqn">4</code>, we would go to the next column and repeat the process.
Elements are only then considered indifferent from each other, if the entire matrix is identical between the two.
</p>


<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
&ldquo;Lexicographic solutions for coalitional rankings based on individual and collective performances.&rdquo;
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code><a href="#topic+L1Scores">L1Scores()</a></code> function.
</p>
<p>For less complexity, another row is prepended to the matrix showing the sum of each column.
Through this, a simple <code class="reqn">L^{(1)}</code> comparison can be applied.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcel2Scores()</code> and <code>lexcel2Ranking()</code> serve as aliases for <code>L2Scores()</code> and <code>L2Ranking()</code>, respectively.
</p>


<h3>References</h3>

<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
&ldquo;Lexicographic solutions for coalitional rankings.&rdquo;
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1&ndash;33.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("123 ~ 12 ~ 13 ~ 14 ~ 2 ~ 4")
pr &lt;- appendMissingCoalitions(pr)
scores &lt;- L2Scores(pr)
scores$`1`
#      [,1] [,2]
# [1,]    0    1
# [2,]    3    0
# [3,]    1    2
# [3,]    0    1

L2Ranking(pr)
# 1 &gt; 2 &gt; 4 &gt; 3

L1Ranking(pr)
# 2 &gt; 4 &gt; 1 &gt; 3

</code></pre>

<hr>
<h2 id='lexcelScores'>Lexicographical Excellence</h2><span id='topic+lexcelScores'></span><span id='topic+lexcelRanking'></span><span id='topic+dualLexcelRanking'></span>

<h3>Description</h3>

<p>Calculate the Lexicographical Excellence (or Lexcel) score.
</p>
<p><code>lexcelRanking()</code> returns the corresponding ranking.
</p>
<p><code>dualLexcelRanking()</code> uses the same score vectors but instead of rewarding
participation, it punishes mediocrity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lexcelScores(powerRelation, elements = powerRelation$elements)

lexcelRanking(powerRelation)

dualLexcelRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lexcelScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="lexcelScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An equivalence class <code class="reqn">\sum_i</code> contains coalitions that are indifferent to one another.
In a given power relation created with <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code>, the equivalence classes are saved in <code style="white-space: pre;">&#8288;$eqs&#8288;</code>.
</p>
<p>As an example, consider the power relation
<code class="reqn">\succsim: 123 \succ (12 \sim 13 \sim 1 \sim \emptyset) \succ (23 \sim 1 \sim 2)</code>.
The corresponding equivalence classes are:
</p>
<p style="text-align: center;"><code class="reqn">
\sum_1 = \lbrace 123 \rbrace, \sum_2 = \lbrace 12, 13, 1, \emptyset \rbrace, \sum_3 = \lbrace 23, 1, 2 \rbrace.
</code>
</p>

<p>The lexcel score of an element is a vector wherein each index indicates the number of times that element appears in the equivalence class.
From our example, we would get
</p>
<p style="text-align: center;"><code class="reqn">\textrm{lexcel}(1) = [ 1, 3, 1 ], \textrm{lexcel}(2) = [ 1, 1, 2 ], \textrm{lexcel}(3) = [ 1, 1, 1 ].</code>
</p>



<h3>Value</h3>

<p>Score function returns a list of type <code>LexcelScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>powerRelation$eqs</code>, the number of
times the given element appears in each equivalence class.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>Lexcel Ranking</h3>

<p>The most &quot;excellent contribution&quot; of an element determines its ranking against the other elements.
Given two Lexcel score vectors <code class="reqn">\textrm{Score}(i)</code>
and <code class="reqn">\textrm{Score}(j)</code>, the first index <code class="reqn">x</code> where
<code class="reqn">\textrm{Score}(i)_x \neq \textrm{Score}(j)_x</code>
determines which element should be ranked higher.
</p>
<p>From the previous example this would be <code class="reqn">1 &gt; 2 &gt; 3</code>, because:
</p>
<p><code class="reqn">\textrm{Score}(1)_2 = 3 &gt; \textrm{Score}(2)_2 = \textrm{Score}(3)_2 = 1</code>,
<code class="reqn">\textrm{Score}(2)_3 = 2 &gt; \textrm{Score}(3)_3 = 1</code>.
</p>


<h3>Dual Lexcel Ranking</h3>

<p>The dual lexcel works in reverse order and, instead of rewarding high
scores, punishes mediocrity. In that case we get <code class="reqn">3 &gt; 1 &gt; 2</code>
because:
</p>
<p><code class="reqn">\textrm{Score}(3)_3 &lt; \textrm{Score}(2)_3</code> and
<code class="reqn">\textrm{Score}(3)_2 &lt; \textrm{Score}(1)_2</code>,
<code class="reqn">\textrm{Score}(1)_3 &lt; \textrm{Score}(2)_3</code>.
</p>


<h3>References</h3>

<p>Bernardi G, Lucchetti R, Moretti S (2019).
&ldquo;Ranking objects from a preference relation over their subsets.&rdquo;
<em>Social Choice and Welfare</em>, <b>52</b>(4), 589&ndash;606.
</p>
<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
&ldquo;Lexicographic solutions for coalitional rankings.&rdquo;
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1&ndash;33.
</p>
<p>Serramia M, López-Sánchez M, Moretti S, Rodríguez-Aguilar JA (2021).
&ldquo;On the dominant set selection problem and its application to value alignment.&rdquo;
<em>Autonomous Agents and Multi-Agent Systems</em>, <b>35</b>(2), 1&ndash;38.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note that the coalition {1} appears twice
# 123 &gt; 12 ~ 13 ~ 1 ~ {} &gt; 23 ~ 1 ~ 2
# E = {123} &gt; {12, 13, 1, {}} &gt; {23, 1, 2}
pr &lt;- suppressWarnings(as.PowerRelation(
  "123 &gt; (12 ~ 13 ~ 1 ~ {}) &gt; (23 ~ 1 ~ 2)"
))

# lexcel scores for all elements
# `1` = c(1, 3, 1)
# `2` = c(1, 1, 2)
# `3` = c(1, 1, 1)
lexcelScores(pr)

# lexcel scores for a subset of all elements
lexcelScores(pr, c(1, 3))
lexcelScores(pr, 2)

# 1 &gt; 2 &gt; 3
lexcelRanking(pr)

# 3 &gt; 1 &gt; 2
dualLexcelRanking(pr)

</code></pre>

<hr>
<h2 id='LPScores'>LP Ranking</h2><span id='topic+LPScores'></span><span id='topic+LPRanking'></span><span id='topic+lexcelPScores'></span><span id='topic+lexcelPRanking'></span>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{p}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPScores(powerRelation, elements = powerRelation$elements)

LPRanking(powerRelation)

lexcelPScores(powerRelation, elements = powerRelation$elements)

lexcelPRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="LPScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>For <code class="reqn">i, j \in N</code>, the social ranking solution <code class="reqn">L^p</code> then ranks <code class="reqn">i</code> strictly above <code class="reqn">j</code> if one of the following conditions hold:
</p>

<ol>
<li> <p><code class="reqn">\lbrace i \rbrace \succ \lbrace j \rbrace</code>;
</p>
</li>
<li> <p><code class="reqn">\lbrace i \rbrace, \lbrace j \rbrace \in \Sigma_k</code> and there exists a row <code class="reqn">p_0 \in \lbrace 2, \dots, |N|\rbrace</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{q &lt; k} (M^\succsim_i)_{p,q} = \sum_{q &lt; k} (M^\succsim_j)_{p,q}\quad \forall p &lt; p_0,\text{ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{q &lt; k} (M^\succsim_i)_{p_0,q} &gt; \sum_{q &lt; k} (M^\succsim_j)_{p_0,q}.</code>
</p>

</li></ol>

<p>In <code>R</code>, given two matrices <code>M_i</code> and <code>M_j</code>, this comparison could be expressed as
</p>
<pre>
# function that returns TRUE if i should be ranked strictly above j
k_i &lt;- which(M_i[1,] == 1)
k_j &lt;- which(M_j[1,] == 1)
if(k_i != k_j) return(k_i &lt; k_j)
if(k_i == 1)   return(FALSE)
# get sum for each row
# removing the first row implies that we start in row 2
sums_i &lt;- apply(M_i[-1,seq(k_i-1)], 1, sum)
sums_j &lt;- apply(M_j[-1,seq(k_j-1)], 1, sum)
# apply lexcel comparison
i &lt;- which(a != b)
return(length(i) &gt; 0 &amp;&amp; a[i[1]] &gt; b[i[1]])
</pre>


<h3>Value</h3>

<p>Score function returns a list of type <code>LPScores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a vector of length <code>length(powerRelation$elements)</code>.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 12 \sim 2) \succ (13 \sim 23) \succ (1 \sim 3 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
0 &amp; 2 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p><code class="reqn">(M^\succsim_2)_{2,3}</code> in this context refers to the value in the second row and third column of element 2, in this case <code class="reqn">1</code>.
</p>
<p>In the example, <code class="reqn">2</code> will be immediately put above <code class="reqn">1</code> and <code class="reqn">3</code> because <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 1 \rbrace</code> and <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 3 \rbrace</code>.
Since <code class="reqn">\lbrace 1 \rbrace \sim \lbrace 3 \rbrace</code>, we next consider the coalitions of size 2. Here, it turns out that <code class="reqn">(M^\succsim_1)_{2,1} + (M^\succsim_1)_{2,2} = 1 + 1</code>
is equal to <code class="reqn">(M^\succsim_3)_{2,1} + (M^\succsim_3)_{2,2} = 0 + 2</code>.
For obvious reasons the grand coalition does not have to be considered, thus <code class="reqn">1</code> and <code class="reqn">3</code> are considered equally powerful by the <code class="reqn">L^p</code> solution.
</p>
<p><code class="reqn">L^{p}</code> is a social ranking solution belonging to the family of lexicographical ranking functions.
While related to <code><a href="#topic+L1Ranking">L1Ranking()</a></code>, it incorporates the property of &quot;standardness&quot;, stating that if the
singleton coalition <code class="reqn">\lbrace i\rbrace \succ \lbrace j\rbrace</code>, then the ranking solution
should also prefer <code class="reqn">i</code> over <code class="reqn">j</code>.
</p>
<p>If <code class="reqn">\lbrace i\rbrace \sim \lbrace j\rbrace</code>, then all coalitions from size 2 and upward are inspected,
giving higher precedence to coalitions with a lower number of elements.
While this preference is similar to the <code class="reqn">L^{(1)}</code>, it differs in two notable ways:
</p>

<ol>
<li><p> If <code class="reqn">\lbrace i\rbrace, \lbrace j\rbrace \in \Sigma_k</code>, then only coalitions
<code class="reqn">S \succsim (\lbrace i \rbrace \sim \lbrace j \rbrace)</code> are considered,
</p>
</li>
<li><p> From this subset of coalitions, consider the total number of coalitions <code class="reqn">i</code> (or <code class="reqn">j</code>) belongs to, given each coalition size.
This may ignore information about the distribution of these coalitions within the different equivalence classes,
which <code class="reqn">L^{(1)}</code> and the slight variation <code class="reqn">L^{p^*}</code> of the <code class="reqn">L^p</code> solution take into account.
</p>
</li></ol>



<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
&ldquo;Lexicographic solutions for coalitional rankings based on individual and collective performances.&rdquo;
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code><a href="#topic+L1Scores">L1Scores()</a></code> function.
</p>
<p>For efficiency, <code>LPScores()</code> discards much of the redundant information.
Instead of a matrix for each element, it returns a vector of size <code class="reqn">|N|</code>.
</p>
<p>Given a score vector <code>v</code> for an element <code>i</code>, <code>v[1]</code> is the position of the singleton coalition <code>{i}</code>.
This implies that if <code>v[1] &lt; w[1]</code>, where <code>w</code> is the score vector of an element <code>j</code>, then <code>i</code> is ranked strictly above <code>j</code>.
</p>
<p><code>v[2]</code>, <code>v[3]</code>, ..., <code>v[n]</code> then indicates the number of coalitions of size <code>2</code>, <code>3</code>, ..., <code>n</code> that the element <code>i</code> appears in.
</p>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcelPScores()</code> and <code>lexcelPRanking()</code> serve as aliases for <code>LPScores()</code> and <code>LPRanking()</code>, respectively.
</p>


<h3>References</h3>

<p>Béal S, Rémila E, Solal P (2022).
&ldquo;Lexicographic solutions for coalitional rankings based on individual and collective performances.&rdquo;
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("(123 ~ 13 ~ 2) &gt; (12 ~ 1 ~ 3) &gt; (23 ~ {})")
scores &lt;- LPScores(pr)
scores$`2`
# [1] 1 0 0

LPRanking(pr)
# 2 &gt; 1 ~ 3

# Since L^(1) also the relation {1,2}, which ranks above {2,3}, it will place 1 above 3
L1Ranking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>

<hr>
<h2 id='LPSScores'>LP* Ranking</h2><span id='topic+LPSScores'></span><span id='topic+LPSRanking'></span><span id='topic+lexcelPSScores'></span><span id='topic+lexcelPSRanking'></span>

<h3>Description</h3>

<p>Calculate the <code class="reqn">L^{p^*}</code> scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPSScores(powerRelation, elements = powerRelation$elements)

LPSRanking(powerRelation)

lexcelPSScores(powerRelation, elements = powerRelation$elements)

lexcelPSRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPSScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="LPSScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">N</code> be a set of elements, <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code> a power relation,
and <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code> its corresponding quotient order.
</p>
<p>For an element <code class="reqn">i \in N</code>, construct a matrix <code class="reqn">M^\succsim_i</code> with <code class="reqn">m</code> columns and <code class="reqn">|N|</code> rows.
Whereas each column <code class="reqn">q</code> represents an equivalence class, each row <code class="reqn">p</code> corresponds to the coalition size.
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = |\lbrace S \in \Sigma_q: |S| = p \text{ and } i \in S\rbrace|</code>
</p>

<p>For <code class="reqn">i, j \in N</code>, the social ranking solution <code class="reqn">L^{p^*}</code> then ranks <code class="reqn">i</code> strictly above <code class="reqn">j</code> if one of the following conditions hold:
</p>

<ol>
<li> <p><code class="reqn">\lbrace i \rbrace \succ \lbrace j \rbrace</code>;
</p>
</li>
<li> <p><code class="reqn">\lbrace i \rbrace, \lbrace j \rbrace \in \Sigma_k</code> and there exists a row <code class="reqn">p_0 \in \lbrace 2, \dots, |N|\rbrace</code> and column <code class="reqn">q_0 \in \lbrace 1, \dots, k-1\rbrace</code> such that:
</p>
<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p,q} = (M^\succsim_j)_{p,q}\quad \forall p &lt; p_0, q &lt; k,</code>
</p>

<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p_0,q} = (M^\succsim_j)_{p_0,q}\quad \forall q &lt; q_0,\text{ and}</code>
</p>

<p style="text-align: center;"><code class="reqn">(M^\succsim_i)_{p_0,q_0} &gt; (M^\succsim_j)_{p_0,q_0}.</code>
</p>

</li></ol>



<h3>Value</h3>

<p>Score function returns a list of type <code>LP*Scores</code> and length of <code>powerRelation$elements</code>
(unless parameter <code>elements</code> is specified).
Each index contains a matrix with <code>length(powerRelation$elements)</code> rows and a variable number of columns, depending on the equivalence class index containing the singleton coalition of that element (matrix can have 0 columns).
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>Example</h3>

<p>Let <code class="reqn">\succsim: (123 \sim 12 \sim 2) \succ (13 \sim 23) \succ (1 \sim 3 \sim \{\})</code>.
From this, we get the following three matrices:
</p>
<p style="text-align: center;"><code class="reqn">
M^\succsim_1 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
1 &amp; 1 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_2 = \begin{bmatrix}
1 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 1\\
1 &amp; 0 &amp; 0
\end{bmatrix}
M^\succsim_3 = \begin{bmatrix}
0 &amp; 0 &amp; 1\\
0 &amp; 2 &amp; 0\\
1 &amp; 0 &amp; 0
\end{bmatrix}
</code>
</p>

<p><code class="reqn">(M^\succsim_2)_{2,3}</code> in this context refers to the value in the second row and third column of element 2, in this case <code class="reqn">1</code>.
</p>
<p>In the example, <code class="reqn">2</code> will be immediately put above <code class="reqn">1</code> and <code class="reqn">3</code> because <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 1 \rbrace</code> and <code class="reqn">\lbrace 2 \rbrace \succ \lbrace 3 \rbrace</code>.
Since <code class="reqn">\lbrace 1 \rbrace \sim \lbrace 3 \rbrace</code>, we next consider the coalitions of size 2. Here, it turns out that <code class="reqn">(M^\succsim_1)_{2,1} = 1 &gt; 0 = (M^\succsim_3)_{2,1}</code>,
setting <code class="reqn">3</code> to be the least preferred option (this is opposed to the <code class="reqn">L^p</code> relation, which has no strict preference of <code class="reqn">1</code> over <code class="reqn">3</code>).
</p>
<p>As alluded to, <code class="reqn">L^{p^*}</code> is similar to <code class="reqn">L^p</code>, <code><a href="#topic+LPRanking">LPRanking()</a></code>, in that it first considers the singleton coalitions, then sequentially every coalition of size 2 and above that ranks better than the corresponding singleton.
It can be assumed, however, that <code class="reqn">L^{p^*}</code> is more granular, as it doesn't throw away any information about <em>which</em> equivalence class these bigger coalitions belong to.
</p>


<h3>Alterations</h3>

<p>The matrices as described above and in Béal S, Rémila E, Solal P (2022).
&ldquo;Lexicographic solutions for coalitional rankings based on individual and collective performances.&rdquo;
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738. can be investigated with the <code><a href="#topic+L1Scores">L1Scores()</a></code> function.
</p>
<p><code>LPSScores()</code> discards some redundant information, most notably all columns from each element's singleton class and the ones thereafter.
The first row is also removed, as all values there are guaranteed to be 0.
</p>
<p>For the example above, this would actually result in the matrices
</p>
<pre>
matrix(c(1,1, 1,0), nrow=2)
matrix(numeric(), nrow=2)
matrix(c(0,1, 2,0), nrow=2)
</pre>


<h3>Aliases</h3>

<p>For better discoverability, <code>lexcelPSScores()</code> and <code>lexcelPSRanking()</code> serve as aliases for <code>LPSScores()</code> and <code>LPSRanking()</code>, respectively.
</p>


<h3>References</h3>

<p>Béal S, Rémila E, Solal P (2022).
&ldquo;Lexicographic solutions for coalitional rankings based on individual and collective performances.&rdquo;
<em>Journal of Mathematical Economics</em>, <b>102</b>, 102738.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>,
<code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("(123 ~ 12 ~ 2) &gt; (13 ~ 23) &gt; (1 ~ 3 ~ {})")
scores &lt;- LPSScores(pr)
scores$`1`
#      [,1] [,2]
# [1,]    1    1
# [2,]    1    0

scores$`2`
#
# [1,]
# [2,]

LPSRanking(pr)
# 2 &gt; 1 &gt; 3

</code></pre>

<hr>
<h2 id='makePowerRelationMonotonic'>Make Power Relation monotonic</h2><span id='topic+makePowerRelationMonotonic'></span>

<h3>Description</h3>

<p>Given a <code>powerRelation</code> object, make its order monotonic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePowerRelationMonotonic(powerRelation, addMissingCoalitions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePowerRelationMonotonic_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="makePowerRelationMonotonic_+3A_addmissingcoalitions">addMissingCoalitions</code></td>
<td>
<p>If <code>TRUE</code>, also include all coalitions in the power set of <code>powerRelation$elements</code> that are not present in the current power relation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A power relation is monotonic if
</p>
<p style="text-align: center;"><code class="reqn">T \subset S \Leftrightarrow S \succsim T.</code>
</p>

<p>for every coalition <code class="reqn">S \subseteq N</code>.
</p>
<p>Calling <code>makePowerRelationMonotonic()</code> on some <code><a href="#topic+PowerRelation">PowerRelation</a></code> object moves or adds coalitions to certain equivalence classes
so that the power relation becomes monotonic.
</p>


<h3>Value</h3>

<p><code><a href="#topic+PowerRelation">PowerRelation</a></code> object containing the following values:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$elements&#8288;</code>: vector of elements
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$eqs&#8288;</code>: equivalence classes. Nested list of lists, each containing vectors representing groups of elements in the same equivalence class
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$coalitionLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(v)&#8288;</code> taking a coalition vector <code>v</code> and returning the equivalence class it belongs to. See <code><a href="#topic+coalitionLookup">coalitionLookup()</a></code> for more.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$elementLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(e)&#8288;</code> taking an element <code>e</code> and returning a list of 2-sized tuples. See <code><a href="#topic+elementLookup">elementLookup()</a></code> for more.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other helper functions for transforming power relations: 
<code><a href="#topic+appendMissingCoalitions">appendMissingCoalitions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("ab &gt; ac &gt; abc &gt; b &gt; a &gt; {} &gt; c &gt; bc")
makePowerRelationMonotonic(pr)
# (abc ~ ab) &gt; ac &gt; (bc ~ b) &gt; a &gt; (c ~ {})

# notice that missing coalitions are automatically added,
# except for the empty set
pr &lt;- as.PowerRelation("a &gt; b &gt; c")
makePowerRelationMonotonic(pr)
# (abc ~ ab ~ ac ~ a) &gt; (bc ~ b) &gt; c

# setting addMissingCoalitions to FALSE changes this behavior
pr &lt;- as.PowerRelation("a &gt; ab &gt; c ~ {} &gt; b")
makePowerRelationMonotonic(pr, addMissingCoalitions = FALSE)
# (ab ~ a) &gt; (b ~ c ~ {})

# notice that an equivalence class containing an empty coalition
# automatically moves all remaining coalitions to that equivalence class.
pr &lt;- as.PowerRelation("a &gt; {} &gt; b &gt; c")
makePowerRelationMonotonic(pr)
# (abc ~ ab ~ ac ~ a) &gt; (bc ~ b ~ c ~ {})

</code></pre>

<hr>
<h2 id='newPowerRelation'>New Power Relation</h2><span id='topic+newPowerRelation'></span>

<h3>Description</h3>

<p>Deprecated. Use <code><a href="#topic+PowerRelation">PowerRelation()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPowerRelation(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPowerRelation_+3A_...">...</code></td>
<td>
<p>Any parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='newPowerRelationFromString'>New <code><a href="#topic+PowerRelation">PowerRelation</a></code> object</h2><span id='topic+newPowerRelationFromString'></span>

<h3>Description</h3>

<p>Deprecated. Use <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPowerRelationFromString(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPowerRelationFromString_+3A_...">...</code></td>
<td>
<p>Any parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='ordinalBanzhafScores'>Ordinal Banzhaf ranking</h2><span id='topic+ordinalBanzhafScores'></span><span id='topic+ordinalBanzhafRanking'></span>

<h3>Description</h3>

<p>Calculate the Ordinal Banzhaf scores, the number of positive and the number of negative marginal contributions.
</p>
<p><code>ordinalBanzhafRanking()</code> returns the corresponding ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalBanzhafScores(powerRelation, elements = powerRelation$elements)

ordinalBanzhafRanking(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinalBanzhafScores_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="ordinalBanzhafScores_+3A_elements">elements</code></td>
<td>
<p>Vector of elements of which to calculate their scores.
By default, the scores of all elements in <code>powerRelation$elements</code> are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by the Banzhaf index (Banzhaf III 1964), the Ordinal Banzhaf
determines the score of element <code class="reqn">i</code> by adding the amount of coalitions
<code class="reqn">S \subseteq N \setminus \lbrace i \rbrace</code>
its contribution impacts positively (<code class="reqn">S \cup \lbrace i \rbrace \succ S</code>)
and subtracting the amount of coalitions where its contribution
had a negative impact (<code class="reqn">S \succ S \cup \lbrace i \rbrace</code>)(Khani et al. 2019).
</p>
<p>The original definition only takes total power relations into account, where either <code class="reqn">S \succsim T</code> or <code class="reqn">T \succsim S</code>
for every <code class="reqn">S,T \subseteq N</code>.
If coalitions are missing from the power relation, we may not be able to perform certain comparisons.
To indicate these missing comparisons, the ordinal Banzhaf score of an element <code class="reqn">i</code> also includes that number at index <code>3</code>.
I.e., if the ordinal Banzhaf score of an element is <code>c(4, -2, 1)</code>, it means that it contributed positively to <code>4</code> coalitions and negatively to <code>2</code> others.
For one coalition, no comparison could be made.
</p>


<h3>Value</h3>

<p>Score function returns list of class type <code>OrdinalBanzhafScores</code> and length of <code>powerRelation$elements</code>.
Each index contains a vector of three numbers, the number of positive marginal contributions, the number of negative marginal contributions, and the number of coalitions for which no comparison could be done.
The first two numbers summed together gives us the actual ordinal Banzhaf score.
</p>
<p>Ranking function returns corresponding <code><a href="#topic+SocialRanking">SocialRanking</a></code> object.
</p>


<h3>References</h3>

<p>Khani H, Moretti S, Öztürk M (2019).
&ldquo;An ordinal banzhaf index for social ranking.&rdquo;
In <em>28th International Joint Conference on Artificial Intelligence (IJCAI 2019)</em>, 378&ndash;384.
</p>
<p>Banzhaf III JF (1964).
&ldquo;Weighted voting doesn't work: A mathematical analysis.&rdquo;
<em>Rutgers L. Rev.</em>, <b>19</b>, 317.
</p>


<h3>See Also</h3>

<p>Other ranking solution functions: 
<code><a href="#topic+L1Scores">L1Scores</a>()</code>,
<code><a href="#topic+L2Scores">L2Scores</a>()</code>,
<code><a href="#topic+LPSScores">LPSScores</a>()</code>,
<code><a href="#topic+LPScores">LPScores</a>()</code>,
<code><a href="#topic+copelandScores">copelandScores</a>()</code>,
<code><a href="#topic+cumulativeScores">cumulativeScores</a>()</code>,
<code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores</a>()</code>,
<code><a href="#topic+lexcelScores">lexcelScores</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; (2 ~ {}) &gt; 1")

# Player 1 contributes positively to {2}
# Player 1 contributes negatively to {empty set}
# Therefore player 1 has a score of 1 - 1 = 0
#
# Player 2 contributes positively to {1}
# Player 2 does NOT have an impact on {empty set}
# Therefore player 2 has a score of 1 - 0 = 0
ordinalBanzhafScores(pr)
# `1` = c(1, -1, 0)
# `2` = c(1, 0, 0)

ordinalBanzhafRanking(pr)
# 1 &gt; 2

</code></pre>

<hr>
<h2 id='PowerRelation'>PowerRelation object</h2><span id='topic+PowerRelation'></span><span id='topic+is.PowerRelation'></span><span id='topic+print.PowerRelation'></span>

<h3>Description</h3>

<p>Create a <code>PowerRelation</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PowerRelation(
  equivalenceClasses,
  elements = NULL,
  coalitionLookup = NULL,
  elementLookup = NULL
)

is.PowerRelation(x, ...)

## S3 method for class 'PowerRelation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PowerRelation_+3A_equivalenceclasses">equivalenceClasses</code></td>
<td>
<p>A nested list of lists, each containing coalitions or groups represented as vectors that are in the same equivalence class.</p>
</td></tr>
<tr><td><code id="PowerRelation_+3A_elements">elements</code></td>
<td>
<p>Vector of elements in power relation. Only set this value if you know what you are doing. See Details for more.</p>
</td></tr>
<tr><td><code id="PowerRelation_+3A_coalitionlookup">coalitionLookup</code></td>
<td>
<p>A function taking a vector parameter and returning an index. See return value for more details. Only set this value if you know what you are doing.</p>
</td></tr>
<tr><td><code id="PowerRelation_+3A_elementlookup">elementLookup</code></td>
<td>
<p>A function taking an element and returning a list of 2-sized tuples. See return value for more details. Only set this value if you know what you are doing.</p>
</td></tr>
<tr><td><code id="PowerRelation_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="PowerRelation_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A power relation describes the ordinal information between elements.
Here specifically, we are interested in the power relation between coalitions, or groups of elements.
Each coalition is assumed to be a <a href="base.html#topic+c">vector</a> containing zero (empty coalition), one (singleton) or more elements.
</p>
<p><code><a href="#topic+createPowerset">createPowerset()</a></code> offers a convenient way of creating a power set over a set of elements that can be used to call <code>PowerRelation()</code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code>.
</p>
<p>Trying to figure out what equivalence class certain coalitions or elements belong to is quite common.
For these sets of problems, the functions <code style="white-space: pre;">&#8288;$coalitionLookup(v)&#8288;</code> and <code style="white-space: pre;">&#8288;$elementLookup(e)&#8288;</code> should be utilized.
We use some redundancy to speed up the lookup methods.
As such, it is highly discouraged to edit a <code>PowerRelation</code> object directly, as the different power relation representations will fall out of sync.
For more information, see the vignette: <code>vignette(package = 'socialranking')</code>
</p>
<p>The <code>PowerRelation()</code> function expects a nested list of coalitions as input. For alternatives, see <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+PowerRelation">PowerRelation</a></code> object containing the following values:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$elements&#8288;</code>: vector of elements
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$eqs&#8288;</code>: equivalence classes. Nested list of lists, each containing vectors representing groups of elements in the same equivalence class
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$coalitionLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(v)&#8288;</code> taking a coalition vector <code>v</code> and returning the equivalence class it belongs to. See <code><a href="#topic+coalitionLookup">coalitionLookup()</a></code> for more.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$elementLookup&#8288;</code>: <code style="white-space: pre;">&#8288;function(e)&#8288;</code> taking an element <code>e</code> and returning a list of 2-sized tuples. See <code><a href="#topic+elementLookup">elementLookup()</a></code> for more.
</p>
</li></ul>



<h3>Mathematical background</h3>

<p>Let <code class="reqn">N = \lbrace 1, ..., n \rbrace</code> be a finite set of <em>elements</em> (also called players).
Any subset <code class="reqn">S \subseteq N</code> is considered to be a group or coalition of elements,
where <code class="reqn">\{\}</code> is referred to as the empty coalition, <code class="reqn">\{i\}</code> as a singleton (a coalition of size 1), and <code class="reqn">N</code> as the grand coalition.
The power set <code class="reqn">2^N</code> denotes the set of all subsets over <code class="reqn">N</code>.
</p>
<p>Let <code class="reqn">\mathcal{P} \subseteq 2^N</code> be a collection of coalitions.
A <em>power relation</em> on <code class="reqn">\mathcal{P}</code> is a total preorder <code class="reqn">\succsim \subseteq \mathcal{P} \times \mathcal{P}</code>.
That is, for any two coalitions <code class="reqn">S, T \in \mathcal{P}</code>, either <code class="reqn">(S,T) \in \succsim</code>, or <code class="reqn">(T,S) \in \succsim</code>, or both.
In other words, we can compare any two groups of elements in <code class="reqn">\mathcal{P}</code> and determine, if one group is better than, worse than, or equivalent to the other.
</p>
<p>More commonly, the relation <code class="reqn">(S,T) \in \succsim</code> is notated as <code class="reqn">S \succsim T</code>.
</p>
<p><code class="reqn">\mathcal{T}(\mathcal{P})</code> denotes the family of all power relations on every collection <code class="reqn">\mathcal{P} \subseteq 2^N</code>.
Given a power relation <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code>, <code class="reqn">\sim</code> denotes its symmetric part whereas <code class="reqn">\succ</code> its asymmetric part.
Let <code class="reqn">S, T \in \mathcal{P}</code>.
Then,
</p>
<p style="text-align: center;"><code class="reqn">
S \sim T \textrm{ if } S \succsim T \textrm{ and } T \succsim S,\\
S \succ T \textrm{ if } S \succsim T \textrm{ and not } T \succsim S.
</code>
</p>

<p>Coalitions which are deemed equivalent (<code class="reqn">S \sim T</code>) can be collected into an equivalence class <code class="reqn">\Sigma_i</code>.
The list of equivalence classes forms a linear order, <code class="reqn">\Sigma_1 \succ \Sigma_2 \succ \dots \succ \Sigma_m</code>.
</p>


<h3>Mathematical example</h3>

<p>As an example, consider the elements <code class="reqn">N = \{\textrm{apple}, \textrm{banana}, \textrm{chocolate}\}</code>.
Each of them individually may go well with pancakes, but we are also interested in the combination of condiments.
If we consider all possibilities, we will have to compare the sets
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{P} = 2^N = \{\{a,b,c\}, \{a,b\}, \{a,c\}, \{b,c\}, \{a\}, \{b\}, \{c\}, \{\}\}.</code>
</p>

<p>Looking for a way to rank this group of objects, one may arrive at the following total preorder <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code>:
</p>
<p style="text-align: center;"><code class="reqn">\{b,c\} \succ (\{a\} \sim \{c\}) \succ \{b\} \succ \{\} \succ (\{a,b,c\} \sim \{a,b\} \sim \{a, c\}).</code>
</p>

<p>In this particular case, we get five equivalence classes.
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_1 = \{\{b,c\}\}\\
\Sigma_2 = \{\{a\}, \{c\}\}\\
\Sigma_3 = \{\{b\}\}\\
\Sigma_4 = \{\{\}\}\\
\Sigma_5 = \{\{a,b,c\},\{a,b\},\{a,c\}\}
</code>
</p>

<p>The power relation <code class="reqn">\succsim</code> can be copy-pasted as a character string to the <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code> function (it should accept the special characters <code class="reqn">\succsim</code> and <code class="reqn">\sim</code>).
</p>
<p><code>as.PowerRelation("{b,c} &gt; ({a} ~ {c}) &gt; {b} &gt; {} &gt; ({a,b,c} ~ {a,b} ~ {a,c})")</code>
</p>


<h3>References</h3>

<p>Moretti S, Öztürk M (2017).
&ldquo;Some axiomatic and algorithmic perspectives on the social ranking problem.&rdquo;
In <em>International Conference on Algorithmic Decision Theory</em>, 166&ndash;181.
Springer.
</p>
<p>Bernardi G, Lucchetti R, Moretti S (2019).
&ldquo;Ranking objects from a preference relation over their subsets.&rdquo;
<em>Social Choice and Welfare</em>, <b>52</b>(4), 589&ndash;606.
</p>
<p>Algaba E, Moretti S, Rémila E, Solal P (2021).
&ldquo;Lexicographic solutions for coalitional rankings.&rdquo;
<em>Social Choice and Welfare</em>, <b>57</b>(4), 1&ndash;33.
</p>


<h3>See Also</h3>

<p>Other ways to create a <code>PowerRelation()</code> object using <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- PowerRelation(list(
  list(c(1,2,3)),
  list(c(1, 2), 2, 3),
  list(c(2, 3), c()),
  list(c(1, 3)),
  list(1)
))

pr
# 123 &gt; (12 ~ 2 ~ 3) &gt; (23 ~ {}) &gt; 13 &gt; 1

stopifnot(pr$elements == 1:3)
stopifnot(pr$coalitionLookup(1) == 5)
stopifnot(pr$coalitionLookup(c()) == 3)
stopifnot(pr$coalitionLookup(c(1,2)) == 2)

# find coalitions an element appears in
for(t in pr$elementLookup(2)) {
  stopifnot(2 %in% pr$eqs[[t[1]]][[t[2]]])
}

# use createPowerset to help generate a valid function call
if(interactive())
  createPowerset(letters[1:3], result = "copy")

# pasted, rearranged using alt+up / alt+down in RStudio

# note that the function call looks different if elements are multiple characters long
if(interactive())
  createPowerset(c("apple", "banana", "chocolate"), result = "copy")

# pasted clipboard
PowerRelation(rlang::list2(
  list(c("banana", "chocolate")),
  list(c("apple"),
       c("chocolate")),
  list(c("banana")),
  list(c()),
  list(c("apple", "banana", "chocolate"),
       c("apple", "banana"),
       c("apple", "chocolate")),
))
# {banana, chocolate} &gt; ({apple} ~ {chocolate}) &gt; {banana} &gt; {} &gt; ...

</code></pre>

<hr>
<h2 id='powerRelationGenerator'>Generate power relations</h2><span id='topic+powerRelationGenerator'></span>

<h3>Description</h3>

<p>Based on a list of coalitions, create a generator function that returns a new <code><a href="#topic+PowerRelation">PowerRelation</a></code> object with every call.
<code>NULL</code> is returned once every possible power relation has been generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerRelationGenerator(coalitions, startWithLinearOrder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerRelationGenerator_+3A_coalitions">coalitions</code></td>
<td>
<p>List of coalition vectors. An empty coalition can be set with <code>c()</code>.</p>
</td></tr>
<tr><td><code id="powerRelationGenerator_+3A_startwithlinearorder">startWithLinearOrder</code></td>
<td>
<p>If set to <code>TRUE</code>, the first <code><a href="#topic+PowerRelation">PowerRelation</a></code> object generated will be a linear order in the order of the list of <code>coalitions</code> they are given.
If set to <code>FALSE</code>, the first <code><a href="#topic+PowerRelation">PowerRelation</a></code> object generated will have a single equivalence class containing all coalitions, as in, every coalition is equally powerful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the <code>partitions</code> library, <code><a href="partitions.html#topic+parts">partitions::compositions()</a></code> is used to create all possible partitions over the set of coalitions.
For every partition, <code><a href="partitions.html#topic+parts">partitions::multinomial()</a></code> is used to create all permutations over the order of the coalitions.
</p>
<p>Note that the number of power relations (or total preorders) grows incredibly fast.
</p>
<p>The Stirling number of second kind <code class="reqn">S(n,k)</code> gives us the number of <code class="reqn">k</code> partitions over <code class="reqn">n</code> elements.
</p>
<p style="text-align: center;"><code class="reqn">S(n,k) = \frac{1}{k!}\sum_{j=0}^{k} (-1)^j \binom{k}{j}(k-j)^n</code>
</p>

<p>For example, with 4 coalitions (n = 4) there are 6 ways to split it into k = 3 partitions.
The sum of all partitions of any size is also known as the Bell number (<code class="reqn">B_n = \sum_{k=0}^n S(n,k)</code>, see also <code><a href="numbers.html#topic+bell">numbers::bell()</a></code>).
</p>
<p>Regarding total preorders <code class="reqn">\mathcal{T}(X)</code> over a set <code class="reqn">X</code>, the Stirling number of second kind can be used to determine the number of all possible total preorders <code class="reqn">|\mathcal{T}(X)|</code>.
</p>
<p style="text-align: center;"><code class="reqn">|\mathcal{T}(X)| = \sum_{k=0}^{|X|} k! * S(|X|, k)</code>
</p>

<p>In literature, it is referred to as the ordered Bell number or Fubini number.
</p>
<p>In the context of social rankings we may consider total preorders over the set of coalitions <code class="reqn">2^N</code> for a given set of elements or players <code class="reqn">N</code>.
Here, the number of coalitions doubles with every new element.
The number of preorders then are:</p>

<table>
<tr>
 <td style="text-align: left;">
   # of elements </td><td style="text-align: left;"> # of coalitions </td><td style="text-align: left;"> # of total preorders </td><td style="text-align: left;"> 1ms / computation </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> 1ms </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> 3ms </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 75 </td><td style="text-align: left;"> 75ms </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 7 (w/o empty set) </td><td style="text-align: left;"> 47,293 </td><td style="text-align: left;"> 47 seconds </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 8 </td><td style="text-align: left;"> 545,835 </td><td style="text-align: left;"> 9 minutes </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> 15 (w/o empty set) </td><td style="text-align: left;"> 230,283,190,977,853 </td><td style="text-align: left;"> 7,302 years </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> 16 </td><td style="text-align: left;"> 5,315,654,681,981,355 </td><td style="text-align: left;"> 168,558 years </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A generator function.
Every time this generator function is called, a different <code><a href="#topic+PowerRelation">PowerRelation</a></code> object is returned.
Once all possible power relations have been generated, the generator function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other generator functions: 
<code><a href="#topic+generateNextPartition">generateNextPartition</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coalitions &lt;- createPowerset(c('a','b'), includeEmptySet = FALSE)
# list(c('a','b'), 'a', 'b')

gen &lt;- powerRelationGenerator(coalitions)

while(!is.null(pr &lt;- gen())) {
  print(pr)
}
# (ab ~ a ~ b)
# (ab ~ a) &gt; b
# (ab ~ b) &gt; a
# (a ~ b) &gt; ab
# ab &gt; (a ~ b)
# a &gt; (ab ~ b)
# b &gt; (ab ~ a)
# ab &gt; a &gt; b
# ab &gt; b &gt; a
# a &gt; ab &gt; b
# b &gt; ab &gt; a
# a &gt; b &gt; ab
# b &gt; a &gt; ab

# from now on, gen() always returns NULL
gen()
# NULL

# Use generateNextPartition() to skip certain partitions
gen &lt;- powerRelationGenerator(coalitions)

gen &lt;- generateNextPartition(gen)
gen &lt;- generateNextPartition(gen)
gen()

</code></pre>

<hr>
<h2 id='powerRelationMatrix'>Create relation matrix</h2><span id='topic+powerRelationMatrix'></span><span id='topic+as.relation.PowerRelation'></span>

<h3>Description</h3>

<p>For a given <code><a href="#topic+PowerRelation">PowerRelation</a></code> object create a <code><a href="relations.html#topic+relation">relations::relation()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerRelationMatrix(
  powerRelation,
  domainNames = c("pretty", "numericPrec", "numeric")
)

## S3 method for class 'PowerRelation'
as.relation(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerRelationMatrix_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="powerRelationMatrix_+3A_domainnames">domainNames</code></td>
<td>
<p>How should the row and column names be formatted?
</p>

<ul>
<li> <p><code>pretty</code>: Coalitions such as c(1,2) are formatted as 12. To ensure that it's correctly sorted alphabetically, every name is preceded by a certain amount of the invisible Unicode character \u200b
</p>
</li>
<li> <p><code>numericPrec</code>: Coalitions such as c(1,2) are formatted as 1{12}, the number in front of the curly brace marking its sorted spot. While less pretty, it won't use Unicode characters.
</p>
</li>
<li> <p><code>numeric</code>: Drop coalition names, only count from 1 upwards. Each number corresponds to the index in TODO <code>powerRelation$rankingCoalitions</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;function(x)&#8288;</code>: A custom function that is passed a number from <code>1</code> through <code>length(powerRelation$rankingCoalitions)</code>. Must return a <code>character</code> object.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerRelationMatrix_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object</p>
</td></tr>
<tr><td><code id="powerRelationMatrix_+3A_...">...</code></td>
<td>
<p>Further parameters (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Turn a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object into a <code><a href="relations.html#topic+relation">relations::relation()</a></code> object. The incidence matrix can be viewed with
<code><a href="relations.html#topic+incidence">relations::relation_incidence()</a></code>.
</p>
<p>The columns and rows of a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object are ordered by TODO <code>powerRelation$rankingCoalitions</code>.
The <code>relations</code> package automatically sorts the columns and rows by their domain names, which is the reason the
parameter <code>domainNames</code> is included. This way we ensure that the columns and rows are sorted by
the order of the power relation.
</p>


<h3>Value</h3>

<p><code><a href="relations.html#topic+relation">relations::relation()</a></code> object to the corresponding power relation.
</p>


<h3>Cycles</h3>

<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object is defined as being transitive. If a power relation includes a cycle,
meaning that the same coalition appears twice in the ranking, all coalitions within that cycle will be considered
to be indifferent from one another.
</p>
<p>For example, given the power relation <code class="reqn">1 \succ 2 \succ 3 \succ 1 \succ 12</code>,
the relation is somewhat equivalent to <code class="reqn">1 \sim 2 \sim 3 \succ 12</code>. There is no way
to check for cycles in the incidence matrix only.
</p>
<p>Call <code><a href="#topic+transitiveClosure">transitiveClosure()</a></code> to remove cycles in a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="relations.html#topic+relation">relations::as.relation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("12 &gt; 1 &gt; 2")
relation &lt;- powerRelationMatrix(pr)

# do relation stuff
# Incidence matrix
# 111
# 011
# 001
relations::relation_incidence(relation)

# all TRUE
stopifnot(all(
  relations::relation_is_acyclic(relation),
  relations::relation_is_antisymmetric(relation),
  relations::relation_is_linear_order(relation),
  relations::relation_is_complete(relation),
  relations::relation_is_reflexive(relation),
  relations::relation_is_transitive(relation)
))


# a power relation where coalitions {1} and {2} are indifferent
pr &lt;- as.PowerRelation("12 &gt; (1 ~ 2)")
relation &lt;- powerRelationMatrix(pr)

# Incidence matrix
# 111
# 011
# 011
relations::relation_incidence(relation)

# FALSE
stopifnot(!any(
  relations::relation_is_acyclic(relation),
  relations::relation_is_antisymmetric(relation),
  relations::relation_is_linear_order(relation)
))
# TRUE
stopifnot(all(
  relations::relation_is_complete(relation),
  relations::relation_is_reflexive(relation),
  relations::relation_is_transitive(relation)
))


# a pr with cycles
pr &lt;- suppressWarnings(as.PowerRelation("12 &gt; 1 &gt; 2 &gt; 1"))
relation &lt;- powerRelationMatrix(pr)

# Incidence matrix
# 1111
# 0111
# 0111
# 0111
relations::relation_incidence(relation)

# custom naming convention
relation &lt;- powerRelationMatrix(
  pr,
  function(x) paste0(letters[x], ":", paste(pr$rankingCoalitions[[x]], collapse = "|"))
)

relations::relation_incidence(relation)
# Incidences:
#       a:1|2 b:1 c:2 d:1
# a:1|2     1   1   1   1
# b:1       0   1   1   1
# c:2       0   1   1   1
# d:1       0   1   1   1

</code></pre>

<hr>
<h2 id='SocialRanking'><code>SocialRanking</code> object</h2><span id='topic+SocialRanking'></span>

<h3>Description</h3>

<p>Create a <code>SocialRanking</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SocialRanking(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SocialRanking_+3A_l">l</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to <code><a href="#topic+PowerRelation">PowerRelation()</a></code>, <code>SocialRanking</code> expects expects a list to represent a power relation.
Unlike <code><a href="#topic+PowerRelation">PowerRelation()</a></code> however, this list should not be nested and should only contain vectors, each vector containing elements that are deemed equally preferable.
</p>
<p>Use <code><a href="#topic+doRanking">doRanking()</a></code> to rank elements based on arbitrary score objects.
</p>
<p>A social ranking solution, or ranking solution, or solution, maps each power relation between coalitions to a power relation between its elements.
I.e., from the power relation <code class="reqn">\succsim: \{1,2\} \succ \{2\} \succ \{1\}</code>, we may expect the result of a ranking solution <code class="reqn">R^\succsim</code>
to rank element 2 over 1. Therefore <code class="reqn">2 R^\succsim 1</code> will be present, but not <code class="reqn">1 R^\succsim 2</code>.
</p>
<p>Formally, a ranking solution <code class="reqn">R: \mathcal{T}(\mathcal{P}) \rightarrow \mathcal{T}(N)</code> is a function that,
given a power relation <code class="reqn">\succsim \in \mathcal{T}(\mathcal{P})</code>, always produces a power relation
<code class="reqn">R(\succsim)</code> (or <code class="reqn">R^\succsim</code>) over its set of elements.
For two elements <code class="reqn">i, j \in N</code>, <code class="reqn">i R^\succsim j</code> means that applying the solution <code class="reqn">R</code> on the ranking <code class="reqn">\succsim</code>
makes <code class="reqn">i</code> at least as preferable as <code class="reqn">j</code>.
Often times <code class="reqn">iI^\succsim j</code> and <code class="reqn">iP^\succsim j</code> are used to indicate its symmetric and asymmetric part, respectively.
As in, <code class="reqn">iI^\succsim j</code> implies that <code class="reqn">iR^\succsim j</code> and <code class="reqn">jR^\succsim i</code>,
whereas <code class="reqn">iP^\succsim j</code> implies that <code class="reqn">iR^\succsim j</code> but not <code class="reqn">jR^\succsim i</code>.
</p>


<h3>Value</h3>

<p>A list of type <code>SocialRanking</code>.
Each element of the list contains a <a href="base.html#topic+c">vector</a> of elements in <code>powerRelation$elements</code> that are indifferent to one another.
</p>


<h3>See Also</h3>

<p>Function that ranks elements based on their scores, <code><a href="#topic+doRanking">doRanking()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SocialRanking(list(c("a", "b"), "f", c("c", "d")))
# a ~ b &gt; f &gt; c ~ d

</code></pre>

<hr>
<h2 id='socialrankingpackage'>socialranking: A package for constructing ordinal power relations and evaluating social ranking solutions</h2><span id='topic+socialrankingpackage'></span><span id='topic+socialranking-package'></span>

<h3>Description</h3>

<p>The package <code>socialranking</code> offers functions to represent ordinal
information of coalitions and calculate the power relation between elements or players.
</p>


<h3>Details</h3>

<p><code><a href="#topic+PowerRelation">PowerRelation()</a></code> creates a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object. <code><a href="#topic+createPowerset">createPowerset()</a></code>
is a convenient function to generate a <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code> function call
for all possible coalitions.
</p>
<p>The functions used to analyze power relations can be grouped into comparison functions,
score functions and ranking solutions. Ranking solutions produce a <code>SocialRanking</code> object.</p>

<table>
<tr>
 <td style="text-align: left;">
   Comparison Functions </td><td style="text-align: left;"> Score Functions </td><td style="text-align: left;"> Ranking Solutions </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+dominates">dominates()</a></code> </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+cumulativelyDominates">cumulativelyDominates()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+cumulativeScores">cumulativeScores()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code>^1 </td><td style="text-align: left;"> <code><a href="#topic+copelandScores">copelandScores()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+copelandRanking">copelandRanking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+kramerSimpsonRanking">kramerSimpsonRanking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code><a href="#topic+lexcelScores">lexcelScores()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+lexcelRanking">lexcelRanking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code><a href="#topic+dualLexcelRanking">dualLexcelRanking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code><a href="#topic+L1Scores">L1Scores()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+L1Ranking">L1Ranking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores()</a></code> </td><td style="text-align: left;"> <code><a href="#topic+ordinalBanzhafRanking">ordinalBanzhafRanking()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>^1 <code><a href="#topic+cpMajorityComparisonScore">cpMajorityComparisonScore()</a></code> is a faster alternative to <code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code>, but it produces less data.
</p>
<p><code><a href="#topic+powerRelationMatrix">powerRelationMatrix()</a></code> uses <code><a href="relations.html#topic+relation">relations::relation()</a></code> to create
an incidence matrix between all competing coalitions. The incidence
matrix can be displayed with <code><a href="relations.html#topic+incidence">relations::relation_incidence()</a></code>.
</p>
<p>Use <code>browseVignettes("socialranking")</code> for more information.
</p>

<hr>
<h2 id='testRelation'>Test relation between two elements</h2><span id='topic+testRelation'></span><span id='topic++25+3A+25'></span><span id='topic++25+3E+3Ddom+25'></span><span id='topic++25+3Edom+25'></span><span id='topic++25+3E+3Dcumuldom+25'></span><span id='topic++25+3Ecumuldom+25'></span><span id='topic++25+3E+3Dcp+25'></span><span id='topic++25+3Ecp+25'></span><span id='topic++25+3E+3Dbanz+25'></span><span id='topic++25+3Ebanz+25'></span><span id='topic++25+3E+3Dcop+25'></span><span id='topic++25+3Ecop+25'></span><span id='topic++25+3E+3Dks+25'></span><span id='topic++25+3Eks+25'></span><span id='topic++25+3E+3Dlex+25'></span><span id='topic++25+3Elex+25'></span><span id='topic++25+3E+3Dduallex+25'></span><span id='topic++25+3Eduallex+25'></span><span id='topic++25+3E+3DL1+25'></span><span id='topic++25+3EL1+25'></span><span id='topic++25+3E+3DL2+25'></span><span id='topic++25+3EL2+25'></span><span id='topic++25+3E+3DLP+25'></span><span id='topic++25+3ELP+25'></span><span id='topic++25+3E+3DLPS+25'></span><span id='topic++25+3ELPS+25'></span>

<h3>Description</h3>

<p>On a given <code><a href="#topic+PowerRelation">PowerRelation</a></code> object <code>pr</code>, check if <code>e1</code> relates to <code>e2</code> based on the given social ranking solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testRelation(powerRelation, e1)

powerRelation %:% e1

pr_e1 %&gt;=dom% e2

pr_e1 %&gt;dom% e2

pr_e1 %&gt;=cumuldom% e2

pr_e1 %&gt;cumuldom% e2

pr_e1 %&gt;=cp% e2

pr_e1 %&gt;cp% e2

pr_e1 %&gt;=banz% e2

pr_e1 %&gt;banz% e2

pr_e1 %&gt;=cop% e2

pr_e1 %&gt;cop% e2

pr_e1 %&gt;=ks% e2

pr_e1 %&gt;ks% e2

pr_e1 %&gt;=lex% e2

pr_e1 %&gt;lex% e2

pr_e1 %&gt;=duallex% e2

pr_e1 %&gt;duallex% e2

pr_e1 %&gt;=L1% e2

pr_e1 %&gt;L1% e2

pr_e1 %&gt;=L2% e2

pr_e1 %&gt;L2% e2

pr_e1 %&gt;=LP% e2

pr_e1 %&gt;LP% e2

pr_e1 %&gt;=LPS% e2

pr_e1 %&gt;LPS% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testRelation_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
<tr><td><code id="testRelation_+3A_e1">e1</code>, <code id="testRelation_+3A_e2">e2</code></td>
<td>
<p>Elements in <code>powerRelation$elements</code></p>
</td></tr>
<tr><td><code id="testRelation_+3A_pr_e1">pr_e1</code></td>
<td>
<p><code><a href="#topic+PowerRelation">PowerRelation</a></code> and <code>e1</code> element, packed into a list using <code>pr %:% e1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>testRelation</code> is somewhat only used to make the offered comparison operators in the package better discoverable.
</p>
<p><code>testRelation(pr, e1)</code> is equivalent to <code>pr %:% e1</code> and <code>list(pr, e1)</code>. It should be used together with one of the
comparison operators listed in the usage section.
</p>


<h3>Value</h3>

<p><code>testRelation()</code> and <code style="white-space: pre;">&#8288;%:%&#8288;</code> returns <code>list(powerRelation, e1)</code>.
</p>
<p>Followed by a <code style="white-space: pre;">&#8288;%&gt;=comparison%&#8288;</code> or <code style="white-space: pre;">&#8288;%&gt;comparison%&#8288;</code> it returns <code>TRUE</code> or <code>FALSE</code>, depending on the relation between
<code>e1</code> and <code>e2</code>.
</p>


<h3>See Also</h3>

<p>Comparison function: <code><a href="#topic+dominates">dominates()</a></code>, <code><a href="#topic+cumulativelyDominates">cumulativelyDominates()</a></code>, <code><a href="#topic+cpMajorityComparison">cpMajorityComparison()</a></code>.
</p>
<p>Score Functions: <code><a href="#topic+ordinalBanzhafScores">ordinalBanzhafScores()</a></code>, <code><a href="#topic+copelandScores">copelandScores()</a></code>, <code><a href="#topic+kramerSimpsonScores">kramerSimpsonScores()</a></code>, <code><a href="#topic+lexcelScores">lexcelScores()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("123 &gt; 12 ~ 13 ~ 23 &gt; 3 &gt; 1 ~ 2 &gt; {}")

# Dominance
stopifnot(pr %:% 1 %&gt;=dom% 2)

# Strict dominance
stopifnot((pr %:% 1 %&gt;dom% 2) == FALSE)

# Cumulative dominance
stopifnot(pr %:% 1 %&gt;=cumuldom% 2)

# Strict cumulative dominance
stopifnot((pr %:% 1 %&gt;cumuldom% 2) == FALSE)

# CP-Majority relation
stopifnot(pr %:% 1 %&gt;=cp% 2)

# Strict CP-Majority relation
stopifnot((pr %:% 1 %&gt;cp% 2) == FALSE)

# Ordinal banzhaf relation
stopifnot(pr %:% 1 %&gt;=banz% 2)

# Strict ordinal banzhaf relation
# (meaning 1 had a strictly higher positive contribution than 2)
stopifnot((pr %:% 1 %&gt;banz% 2) == FALSE)

# Copeland-like method
stopifnot(pr %:% 1 %&gt;=cop% 2)
stopifnot(pr %:% 2 %&gt;=cop% 1)

# Strict Copeland-like method
# (meaning pairwise winning minus pairwise losing comparison of
# 1 is strictly higher than of 2)
stopifnot((pr %:% 1 %&gt;cop% 2) == FALSE)
stopifnot((pr %:% 2 %&gt;cop% 1) == FALSE)
stopifnot(pr %:% 3 %&gt;cop% 1)

# Kramer-Simpson-like method
stopifnot(pr %:% 1 %&gt;=ks% 2)
stopifnot(pr %:% 2 %&gt;=ks% 1)

# Strict Kramer-Simpson-like method
# (meaning ks-score of 1 is actually higher than 2)
stopifnot((pr %:% 2 %&gt;ks% 1) == FALSE)
stopifnot((pr %:% 1 %&gt;ks% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;ks% 1)

# Lexicographical and dual lexicographical excellence
stopifnot(pr %:% 3 %&gt;=lex% 1)
stopifnot(pr %:% 3 %&gt;=duallex% 1)

# Strict lexicographical and dual lexicographical excellence
# (meaning their lexicographical scores don't match)
stopifnot(pr %:% 3 %&gt;lex% 1)
stopifnot(pr %:% 3 %&gt;duallex% 1)

# L^(1) and L^(2)
stopifnot(pr %:% 1 %&gt;=L1% 2)
stopifnot(pr %:% 1 %&gt;=L2% 2)

# Strict L^(1) and L^(2)
stopifnot((pr %:% 1 %&gt;L1% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;L1% 1)

stopifnot((pr %:% 1 %&gt;L2% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;L2% 1)

# L^p and L^p*
stopifnot(pr %:% 1 %&gt;=LP% 2)
stopifnot(pr %:% 1 %&gt;=LPS% 2)

# Strict L^(1) and L^(2)
stopifnot((pr %:% 1 %&gt;LP% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;LP% 1)

stopifnot((pr %:% 1 %&gt;LPS% 2) == FALSE)
stopifnot(pr %:% 3 %&gt;LPS% 1)

</code></pre>

<hr>
<h2 id='transitiveClosure'>Transitive Closure</h2><span id='topic+transitiveClosure'></span>

<h3>Description</h3>

<p>Apply transitive closure over power relation that has cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitiveClosure(powerRelation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitiveClosure_+3A_powerrelation">powerRelation</code></td>
<td>
<p>A <code><a href="#topic+PowerRelation">PowerRelation</a></code> object created by <code><a href="#topic+PowerRelation">PowerRelation()</a></code> or <code><a href="#topic+as.PowerRelation">as.PowerRelation()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A power relation is a binary relationship between coalitions that is transitive.
For coalitions <code class="reqn">a, b, c \in 2^N</code>, this means that if <code class="reqn">a \succ b</code> and
<code class="reqn">b \succ c</code>, then <code class="reqn">a \succ c</code>.
</p>
<p>A power relation with cycles is not transitive. A transitive closure over a power relation removes all cycles and turns it into a
transitive relation, placing all coalitions within a cycle in the same equivalence class.
If <code class="reqn">a \succ b \succ a</code>, from the symmetric definition in <code><a href="#topic+PowerRelation">PowerRelation()</a></code> we
therefore assume that <code class="reqn">a \sim b</code>. Similarly, if
<code class="reqn">a \succ b_1 \succ b_2 \succ \dots \succ b_n \succ a</code>, the transitive closure turns it into
<code class="reqn">a \sim b_1 \sim b_2 \sim \dots \sim b_n</code>.
</p>
<p><code>transitiveClosure()</code> transforms a <code><a href="#topic+PowerRelation">PowerRelation</a></code> object with cycles into a <code>PowerRelation</code> object without cycles.
As described above, all coalitions within a cycle then are put into the same equivalence class
and all duplicate coalitions are removed.
</p>


<h3>Value</h3>

<p><code><a href="#topic+PowerRelation">PowerRelation</a></code> object with no cycles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- as.PowerRelation("1 &gt; 2")

# nothing changes
transitiveClosure(pr)


pr &lt;- suppressWarnings(as.PowerRelation("1 &gt; 2 &gt; 1"))

# 1 ~ 2
transitiveClosure(pr)


pr &lt;- suppressWarnings(
  as.PowerRelation("1 &gt; 3 &gt; 1 &gt; 2 &gt; 23 &gt; 2")
)

# 1 &gt; 3 &gt; 1 &gt; 2 &gt; 23 &gt; 2 =&gt;
# 1 ~ 3 &gt; 2 ~ 23
transitiveClosure(pr)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
