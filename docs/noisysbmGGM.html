<!DOCTYPE html><html lang="en"><head><title>Help for package noisysbmGGM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {noisysbmGGM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#noisysbmGGM-package'><p>noisysbmGGM: Noisy Stochastic Block Mode: Graph and GGM Inference by Multiple Testing and Greedy Bayesian Algorithm</p></a></li>
<li><a href='#ARI'><p>Evalute the adjusted Rand index</p></a></li>
<li><a href='#GGMtest'><p>GGM for test</p></a></li>
<li><a href='#main_noisySBM'><p>Graph Inference from Noisy Data by Multiple Testing</p></a></li>
<li><a href='#main_noisySBM_GGM'><p>GGM Inference from Noisy Data by Multiple Testing using SILGGM and Drton test statistics</p></a></li>
<li><a href='#matrixToVec'><p>matrixToVec</p></a></li>
<li><a href='#NSBMtest'><p>NoisySBM for test</p></a></li>
<li><a href='#plotGraphs'><p>plot the data matrix, the inferred graph and/or the true binary graph</p></a></li>
<li><a href='#rnsbm'><p>return a random NSBM</p></a></li>
<li><a href='#vecToMatrix'><p>vecToMatrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Noisy Stochastic Block Model for GGM Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Kilian [aut, cre],
  Fanny Villers [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Kilian &lt;valentin.kilian@ens-rennes.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Greedy Bayesian algorithm to fit the noisy stochastic block model to an observed sparse graph. Moreover, a graph inference procedure to recover Gaussian Graphical Model (GGM) from real data. This procedure comes with a control of the false discovery rate. The method is described in the article "Enhancing the Power of Gaussian Graphical Model Inference by Modeling the Graph Structure" by Kilian, Rebafka, and Villers (2024) &lt;<a href="https://doi.org/10.48550/arXiv.2402.19021">doi:10.48550/arXiv.2402.19021</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel,ppcor,SILGGM,stats,igraph,huge,Rcpp,RcppArmadillo,MASS,RColorBrewer</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 14:56:30 UTC; vkilian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='noisysbmGGM-package'>noisysbmGGM: Noisy Stochastic Block Mode: Graph and GGM Inference by Multiple Testing and Greedy Bayesian Algorithm</h2><span id='topic+noisysbmGGM'></span><span id='topic+noisysbmGGM-package'></span>

<h3>Description</h3>

<p>Greedy Bayesian algorithm to fit the noisy stochastic block model to an observed sparse graph. Moreover, a graph inference procedure to recover Gaussian Graphical Model from real data. This procedure comes with a control of the false discovery rate. The method is described in the article &quot;Enhancing the Power of Gaussian Graphical Model Inference by Modeling the Graph Structure&quot; by Kilian, Rebafka, and Villers (2024) <a href="https://arxiv.org/abs/2402.19021">arXiv:2402.19021</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Valentin Kilian <a href="mailto:valentin.kilian@ens-rennes.fr">valentin.kilian@ens-rennes.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Fanny Villers <a href="mailto:fanny.villers@upmc.fr">fanny.villers@upmc.fr</a>
</p>
</li></ul>


<hr>
<h2 id='ARI'>Evalute the adjusted Rand index</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Compute the adjusted Rand index to compare two partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARI_+3A_x">x</code></td>
<td>
<p>vector (of length n) or matrix (with n columns) providing a partition</p>
</td></tr>
<tr><td><code id="ARI_+3A_y">y</code></td>
<td>
<p>vector or matrix providing a partition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the partitions may be provided as n-vectors containing the cluster memeberships
of n entities, or by Qxn - matrices whose entries are all
0 and 1 where 1 indicates the cluster membership
</p>


<h3>Value</h3>

<p>the value of the adjusted Rand index
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clust1 &lt;- c(1,2,1,2)
clust2 &lt;- c(2,1,2,1)
ARI(clust1, clust2)

clust3 &lt;- matrix(c(1,1,0,0, 0,0,1,1), nrow=2, byrow=TRUE)
clust4 &lt;- matrix(c(1,0,0,0, 0,1,0,0, 0,0,1,1), nrow=3, byrow=TRUE)
ARI(clust3, clust4)
</code></pre>

<hr>
<h2 id='GGMtest'>GGM for test</h2><span id='topic+GGMtest'></span>

<h3>Description</h3>

<p>Example of a GGM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGMtest
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>dataMatrix</code></dt><dd><p>A n-sample of a p Gaussian Vector associated to a GGM G</p>
</dd>
<dt><code>Z.true</code></dt><dd><p>True latent clustering</p>
</dd>
<dt><code>A.true</code></dt><dd><p>True latent adjacency matrix of the graph G</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>main_noisySBM_GGM(GGMtest$dataMatrix,Meth="Ren",NIG=TRUE,Qup=10,nbOfZ=1,nbCores=1)

#Note : These data were created using the following instructions
n=30
p=10
u=0.1
v=0.3
theta=list(pi=c(1/3,2/3),w=0.25*cbind(c(1/6,1/120),c(1/120,1/6)))
Q=2
Z &lt;- sample(1:Q, p, replace=TRUE, prob=theta$pi)
A &lt;- matrix(0, p, p)
for (i in 1:(p-1)){
    A[i,(i+1):p] &lt;- stats::rbinom(p-i, 1, theta$w[Z[i],Z[(i+1):p]])}
 A.true &lt;- A + t(A)
Omega &lt;- A.true*v
diag(Omega) = abs(min(eigen(Omega)$values)) + 0.1 + u
Sigma = stats::cov2cor(solve(Omega))
X = MASS::mvrnorm(n, rep(0, p), Sigma)
GGMtest=list(dataMatrix=X,Z.true=Z,A.true=A.true)
</code></pre>

<hr>
<h2 id='main_noisySBM'>Graph Inference from Noisy Data by Multiple Testing</h2><span id='topic+main_noisySBM'></span>

<h3>Description</h3>

<p>The <code>main_noisySBM()</code> function is a core component of the <code>noisysbmGGM</code> package,
responsible for applying the greedy algorithm to estimate model parameters, perform node clustering,
and conduct a multiple testing procedure to infer the underlying graph. This function is versatile,
offering various options and providing useful outputs for further analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main_noisySBM(
  X,
  NIG = FALSE,
  threshold = 0.5,
  Nbrepet = 2,
  rho = NULL,
  tau = NULL,
  a = NULL,
  b = NULL,
  c = NULL,
  d = NULL,
  n0 = 1,
  eta0 = 1,
  zeta0 = 1,
  alpha = 0.1,
  Qup = NULL,
  nbCores = parallel::detectCores(),
  nbOfZ = 12,
  sigma0 = 1,
  sigma1 = 1,
  percentageOfPerturbation = 0.3,
  verbatim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="main_noisySBM_+3A_x">X</code></td>
<td>
<p>A p-square matrix containing the data</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_nig">NIG</code></td>
<td>
<p>A Boolean. If FALSE (by default), the variance under the alternative hypothesis in assumed to be known. If TRUE, the variances under the alternatives are unknown and estimated with the NIG method</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_threshold">threshold</code></td>
<td>
<p>Threshold use when updating the latent graphs structure from l-values (by default threshold=0.5)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_nbrepet">Nbrepet</code></td>
<td>
<p>Number of times the algorithm is repeated (by default Nbrepet=2)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_rho">rho</code></td>
<td>
<p>Hyperparameter of the non-NIG method (by default rho=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_tau">tau</code></td>
<td>
<p>Hyperparameter of the non-NIG method (by default tau=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_a">a</code></td>
<td>
<p>Hyperparameter of the NIG method (by default a=0)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_b">b</code></td>
<td>
<p>Hyperparameter of the NIG method (by default b=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_c">c</code></td>
<td>
<p>Hyperparameter of the NIG method (by default c=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_d">d</code></td>
<td>
<p>Hyperparameter of the NIG method (by default d=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_n0">n0</code></td>
<td>
<p>Hyperparameter (by default n0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_eta0">eta0</code></td>
<td>
<p>Hyperparameter (by default eta0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_zeta0">zeta0</code></td>
<td>
<p>Hyperparameter (by default zeta0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance of the multiple testing procedure (by default alpha=0.1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_qup">Qup</code></td>
<td>
<p>Maximal number of cluster (by default Qup =10)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_nbcores">nbCores</code></td>
<td>
<p>Nb of cores to be used during calculations (by default nbCores=parallel::detectCores())</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_nbofz">nbOfZ</code></td>
<td>
<p>Nb of initialization (by default nbOfZ=12)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_sigma0">sigma0</code></td>
<td>
<p>standard deviation under the null hypothesis (by default sigma0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_sigma1">sigma1</code></td>
<td>
<p>standard deviation under the alternative hypothesis in the non-NIG method (by default sigma1=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_percentageofperturbation">percentageOfPerturbation</code></td>
<td>
<p>perturbation during initialization  (by default percentageOfPerturbation=0.3)</p>
</td></tr>
<tr><td><code id="main_noisySBM_+3A_verbatim">verbatim</code></td>
<td>
<p>print information messages</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>the adjacency matrix of the inferred graph</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the inferred clustering</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the parameters of the noisySBM at the end</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the number of clusters at the end</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>main_noisySBM(NSBMtest$dataMatrix,NIG=TRUE,Qup=10,nbOfZ=1,nbCores=1)
</code></pre>

<hr>
<h2 id='main_noisySBM_GGM'>GGM Inference from Noisy Data by Multiple Testing using SILGGM and Drton test statistics</h2><span id='topic+main_noisySBM_GGM'></span>

<h3>Description</h3>

<p>The <code>main_noisySBM_GGM()</code> function is a key feature of the <code>noisysbmGGM</code> package,
dedicated to Gaussian Graphical Model (GGM) inference. This function takes an $n$-sample of a Gaussian vector
of dimension $p$ and provides the GGM associated with the partial correlation structure of the vector.
GGM inference is essential in capturing the underlying relationships between the vector's coefficients,
helping users uncover meaningful interactions while controlling the number of false discoveries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main_noisySBM_GGM(
  X,
  Meth = "Ren",
  NIG = NULL,
  threshold = 0.5,
  Nbrepet = 2,
  rho = NULL,
  tau = NULL,
  a = NULL,
  b = NULL,
  c = NULL,
  d = NULL,
  n0 = 1,
  eta0 = 1,
  zeta0 = 1,
  alpha = 0.1,
  Qup = NULL,
  nbCores = parallel::detectCores(),
  nbOfZ = 12,
  sigma0 = 1,
  sigma1 = 1,
  percentageOfPerturbation = 0.3,
  verbatim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="main_noisySBM_GGM_+3A_x">X</code></td>
<td>
<p>A n by p matrix containing a n-sample of a p-vector</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_meth">Meth</code></td>
<td>
<p>Choice of test statistics between &quot;Ren&quot;, &quot;Jankova_NW&quot;, &quot;Jankova_GL&quot;, &quot;Liu_SL&quot;, &quot;Liu_L&quot;, and &quot;zTransform&quot; (warning &quot;zTransform&quot; only work if n&gt;p)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_nig">NIG</code></td>
<td>
<p>A Boolean (automatically chosen according to the selected method : NIG=FALSE except for &quot;Liu_SL&quot; and &quot;Liu_L&quot; test statistics as input). If FALSE, the variance under the alternative hypothesis in assumed to be known. If TRUE, the variances under the alternatives are unknown and estimated with the NIG method.</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_threshold">threshold</code></td>
<td>
<p>Threshold use when updating the latent graphs structure from l-values (by default threshold=0.5)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_nbrepet">Nbrepet</code></td>
<td>
<p>Number of times the algorithm is repeated (by default Nbrepet=2)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_rho">rho</code></td>
<td>
<p>Hyperparameter of the non-NIG method (by default rho=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_tau">tau</code></td>
<td>
<p>Hyperparameter of the non-NIG method (by default tau=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_a">a</code></td>
<td>
<p>Hyperparameter of the NIG method (by default a=0)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_b">b</code></td>
<td>
<p>Hyperparameter of the NIG method (by default b=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_c">c</code></td>
<td>
<p>Hyperparameter of the NIG method (by default c=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_d">d</code></td>
<td>
<p>Hyperparameter of the NIG method (by default d=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_n0">n0</code></td>
<td>
<p>Hyperparameter (by default n0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_eta0">eta0</code></td>
<td>
<p>Hyperparameter (by default eta0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_zeta0">zeta0</code></td>
<td>
<p>Hyperparameter (by default zeta0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_alpha">alpha</code></td>
<td>
<p>Level of significance of the multiple testing procedure (by default alpha=0.1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_qup">Qup</code></td>
<td>
<p>Maximal number of cluster (by default Qup =10)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_nbcores">nbCores</code></td>
<td>
<p>Nb of cores to be used during calculations (by default nbCores=parallel::detectCores())</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_nbofz">nbOfZ</code></td>
<td>
<p>Nb of initialization (by default nbOfZ=12)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_sigma0">sigma0</code></td>
<td>
<p>standard deviation under the null hypothesis (by default sigma0=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_sigma1">sigma1</code></td>
<td>
<p>standard deviation under the alternative hypothesis in the non-NIG method (by default sigma1=1)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_percentageofperturbation">percentageOfPerturbation</code></td>
<td>
<p>perturbation during initialization  (by default percentageOfPerturbation=0.3)</p>
</td></tr>
<tr><td><code id="main_noisySBM_GGM_+3A_verbatim">verbatim</code></td>
<td>
<p>print information messages</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>the adjacency matrix of the inferred graph</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the inferred clustering</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the parameters of the noisySBM at the end</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the number of clusters at the end</p>
</td></tr>
</table>
<p>#' @examples
main_noisySBM_GGM(GGMtest$dataMatrix,Meth=&quot;Ren&quot;,NIG=TRUE,Qup=10,nbOfZ=1)
</p>


<h3>See Also</h3>

<p>main_noisySBM
</p>

<hr>
<h2 id='matrixToVec'>matrixToVec</h2><span id='topic+matrixToVec'></span>

<h3>Description</h3>

<p>matrixToVec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToVec(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixToVec_+3A_x">X</code></td>
<td>
<p>a SYMETRIC matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector  contenting the coefficient of the upper triangle of the matrix X
from left to right and from top to bottom.
</p>

<hr>
<h2 id='NSBMtest'>NoisySBM for test</h2><span id='topic+NSBMtest'></span>

<h3>Description</h3>

<p>Example of NoisySBM data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSBMtest
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>dataMatrix</code></dt><dd><p>A square matrix containing the observation of the graph</p>
</dd>
<dt><code>theta</code></dt><dd><p>True NSBM parameters</p>
</dd>
<dt><code>latentZ</code></dt><dd><p>True latent clustering</p>
</dd>
<dt><code>latentAdj</code></dt><dd><p>True latent adjacency matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>main_noisySBM(NSBMtest$dataMatrix,NIG=TRUE,Qup=10,nbOfZ=1,nbCores=1)

#Note : These data were created using the following instructions
p=50
Q=6
pi=c(1/6,1/6,1/6,1/6,1/6,1/6)
w=c(0.811,0.001,0.001,0.001,0.001,0.001,0.811,0.011,0.001,0.001,0.001,
0.811,0.001,0.001,0.001,0.811,0.001,0.001,0.811,0.011,0.811)
theta=list(pi=pi,w=w,nu0=c(0,1))
theta$nu &lt;- array(0, dim = c(Q*(Q+1)/2, 2))
theta$nu[,1] &lt;- rep(2,21)
theta$nu[,2] &lt;- rep(2,21)
NSBMtest=rnsbm(p,theta)

</code></pre>

<hr>
<h2 id='plotGraphs'>plot the data matrix, the inferred graph and/or the true binary graph</h2><span id='topic+plotGraphs'></span>

<h3>Description</h3>

<p>plot the data matrix, the inferred graph and/or the true binary graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGraphs(dataMatrix = NULL, inferredGraph = NULL, binaryTruth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGraphs_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>observed data matrix</p>
</td></tr>
<tr><td><code id="plotGraphs_+3A_inferredgraph">inferredGraph</code></td>
<td>
<p>graph inferred by the multiple testing procedure via graphInference()</p>
</td></tr>
<tr><td><code id="plotGraphs_+3A_binarytruth">binaryTruth</code></td>
<td>
<p>true binary graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of FDR and TDR values, if possible
</p>

<hr>
<h2 id='rnsbm'>return a random NSBM</h2><span id='topic+rnsbm'></span>

<h3>Description</h3>

<p>return a random NSBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnsbm(p, theta, modelFamily = "Gauss")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnsbm_+3A_p">p</code></td>
<td>
<p>(interger) number of node in the network</p>
</td></tr>
<tr><td><code id="rnsbm_+3A_theta">theta</code></td>
<td>
<p>=(pi;w;nu0;nu) parameter of the model</p>
</td></tr>
<tr><td><code id="rnsbm_+3A_modelfamily">modelFamily</code></td>
<td>
<p>the distribution family of the noise under the null hypothesis,
which can be &quot;Gauss&quot; (Gaussian), &quot;Gamma&quot;, or &quot;Poisson&quot;, by default it's 'Gauss'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X the noisy matrix
</p>
<p>theta
</p>
<p>latentZ the latent clustering
</p>
<p>latentA the latent adjacency matrix
latent variables
we strat by sampling the latent variable Z which is the vector containing the family of each nodes
adjacency matrix
then we sample the adjacency matrix, conditionally to Z the coordinate of A follow a binomial
of a parameter contain in theta$w
noisy observations under the null
we create a matrix (n,n) X and we initialize all its entry (half of them is undirected)
with a sampling of the law under the null
then for each entry where A is none zero we sample it according to the law under the alternative
</p>

<hr>
<h2 id='vecToMatrix'>vecToMatrix</h2><span id='topic+vecToMatrix'></span>

<h3>Description</h3>

<p>vecToMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecToMatrix(X, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecToMatrix_+3A_x">X</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="vecToMatrix_+3A_p">p</code></td>
<td>
<p>(integer) the dimension of the square matrix returned by the function
be careful the length of the vector X must be equal to p(p+1)/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p by p symetric matrix whose upper triangle coefficients from left to right and
from top to bottom are the entries of the vector X
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
