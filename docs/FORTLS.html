<!DOCTYPE html><html><head><title>Help for package FORTLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FORTLS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#angle_count_cpp'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#correlations'>
<p>Correlation Between Field Estimations and TLS Metrics</p></a></li>
<li><a href='#distance.sampling'><p>Distance Sampling Methods for Correcting Occlusions Effects</p></a></li>
<li><a href='#estimation.plot.size'><p>Assess Consistency of Metrics for Simulated TLS Plots</p></a></li>
<li><a href='#fixed_area_cpp'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#FORTLS-package'><p>FORTLS: Automatic Processing of Terrestrial-Based Technologies Point Cloud Data for Forestry Purposes</p></a></li>
<li><a href='#height_perc_cpp'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#k_tree_cpp'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#metrics.variables'><p>Compute Metrics and Variables for Terrestrial-Based Technologies Point Clouds</p></a></li>
<li><a href='#ncr_point_cloud_double'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#normalize'><p>Relative Coordinates and Density Reduction for Terrestrial-Based Technologies Point Clouds</p></a></li>
<li><a href='#optimize.plot.design'>
<p>Optimize Plot Design Based on Optimal Correlations</p></a></li>
<li><a href='#relative.bias'>
<p>Relative Bias Between Field Estimations and TLS metrics</p></a></li>
<li><a href='#Rioja.data'><p>Inventoried Plots Data for a Stand Case Study in La Rioja</p></a></li>
<li><a href='#Rioja.simulations'><p>Simulated Metrics and Variables for a Stand Case Study in La Rioja</p></a></li>
<li><a href='#simulations'>
<p>Compute Metrics and Variables for Simulated TLS and Field Plots</p></a></li>
<li><a href='#tree.detection.multi.scan'><p>Tree-Level Variables Estimation</p></a></li>
<li><a href='#tree.detection.several.plots'><p>Tree-Level Variables Estimation for Several Plots</p></a></li>
<li><a href='#tree.detection.single.scan'><p>Tree-Level Variables Estimation for TLS Single-Scan Approach</p></a></li>
<li><a href='#ver_point_cloud_double'><p>Calculate dominant diameters and heights for simulations for angle-count plots.</p></a></li>
<li><a href='#weighted_mean_arit'><p>Calculate weighted arithmetic mean.</p></a></li>
<li><a href='#weighted_mean_geom'><p>Calculate weighted geometric mean.</p></a></li>
<li><a href='#weighted_mean_harm'><p>Calculate weighted harmonic mean.</p></a></li>
<li><a href='#weighted_mean_sqrt'><p>Calculate weighted quadratic mean.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Automatic Processing of Terrestrial-Based Technologies Point
Cloud Data for Forestry Purposes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Alberto Molina-Valero [aut, cph, cre],
  Adela Martínez-Calvo [aut, com],
  Arunima Singh [aut, com],
  Gokul Kottilapurath Surendran [aut, com],
  Juan Gabriel Álvarez-González [aut, ths],
  Fernando Montes [aut],
  César Pérez-Cruzado [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Alberto Molina-Valero &lt;jamolinavalero@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Process automation of point cloud data derived from terrestrial-based technologies such as Terrestrial Laser Scanner (TLS) or Mobile Laser Scanner. 'FORTLS' enables (i) detection of trees and estimation of tree-level attributes (e.g. diameters and heights), (ii) estimation of stand-level variables (e.g. density, basal area, mean and dominant height), (iii) computation of metrics related to important forest attributes estimated in Forest Inventories at stand-level, and (iv) optimization of plot design for combining TLS data and field measured data. Documentation about 'FORTLS' is described in Molina-Valero et al. (2022, &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2022.105337">doi:10.1016/j.envsoft.2022.105337</a>&gt;). </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Molina-Valero/FORTLS">https://github.com/Molina-Valero/FORTLS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Molina-Valero/FORTLS/issues">https://github.com/Molina-Valero/FORTLS/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dbscan, Distance, htmlwidgets, lidR, methods,
moments, parallel, plotly, progress, raster, Rcpp(&ge; 1.0.10),
RCSF, reticulate, scales, sf, tidyr, VoxR, vroom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, kableExtra, knitr, rmarkdown, systemfonts, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 16:34:21 UTC; JUAN</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 17:02:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='angle_count_cpp'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+angle_count_cpp'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_count_cpp(baf_seq, baf, d, h, num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_count_cpp_+3A_baf_seq">baf_seq</code></td>
<td>
<p>BAF sequence for simulations</p>
</td></tr>
<tr><td><code id="angle_count_cpp_+3A_baf">baf</code></td>
<td>
<p>BAF masimum for simulations</p>
</td></tr>
<tr><td><code id="angle_count_cpp_+3A_d">d</code></td>
<td>
<p>vector with diameters opf trees</p>
</td></tr>
<tr><td><code id="angle_count_cpp_+3A_h">h</code></td>
<td>
<p>vector with heights of trees</p>
</td></tr>
<tr><td><code id="angle_count_cpp_+3A_num">num</code></td>
<td>
<p>number of trees considered for calculating diameter and dominant height</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='correlations'>
Correlation Between Field Estimations and TLS Metrics
</h2><span id='topic+correlations'></span>

<h3>Description</h3>

<p>Computes correlations between variables estimates from field data and
metrics derived from TLS data. Field estimates and TLS metrics for a common
set of plots are required in order to compute correlations. These data must
be obtained from any of the three different plot designs currently available (fixed
area, k-tree and angle-count), and correspond to plots with incremental values
for the plot design parameter (radius, k and BAF, respectively). Two
correlation measures are implemented: Pearson's correlation coefficient and
Spearman's <em>rho</em>. In addition to estimating these measures, tests for
association are also executed, and interactive line charts graphically
representing correlations are generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlations(simulations,
             variables = c("N", "G", "V", "d", "dg", "d.0", "h", "h.0"),
             method = c("pearson", "spearman"), save.result = TRUE,
             dir.result = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlations_+3A_simulations">simulations</code></td>
<td>

<p>List including estimated variables based on field data and metrics
derived from TLS data. The structure and format must be analogous to output
returned by the <code><a href="#topic+simulations">simulations</a></code> function. Specifically, it must have
at least one of the following named elements:
</p>

<ul>
<li> <p><code>fixed.area.plot</code>: data frame with field estimates and TLS
metrics under a circular fixed area plot design. Each row corresponds to
a (plot, radius) pair, and all or any of the following
columns are included:
</p>
<p>Plot identification and radius:
</p>

<ul>
<li> <p><code>id</code>, <code>radius</code>: same description and format as
indicated for same named columns of <code>fixed.area.plot</code> in
<code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>Variables estimated on the basis of simulated field plots:
</p>

<ul>
<li> <p><code>N</code>, <code>G</code>, <code>V</code>, <code>d</code>, <code>dg</code>,
<code>dgeom</code>, <code>dharm</code>, <code>h</code>, <code>hg</code>, <code>hgeom</code>,
<code>hharm</code>, <code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>,
<code>dharm.0</code>, <code>h.0</code>, <code>hg.0</code>, <code>hgeom.0</code>,
<code>hharm.0</code>: same description and format as indicated for same
named columns of <code>fixed.area.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>, <code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>,
<code>N.hr.cov</code>, <code>N.sh</code>, <code>num.points</code>, <br />
<code>num.points.est</code>, <code>num.points.hom</code>,
<code>num.points.hom.est</code>, <code>G.tls</code>, <br /> <code>G.hn</code>,
<code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>, <code>G.sh</code>,
<code>V.tls</code>, <code>V.hn</code>, <code>V.hr</code>, <code>V.hn.cov</code>, <br />
<code>V.hr.cov</code>, <code>V.sh</code>, <code>d.tls</code>, <code>dg.tls</code>,
<code>dgeom.tls</code>, <code>dharm.tls</code>, <code>h.tls</code>, <br /> <code>hg.tls</code>,
<code>hgeom.tls</code>, <code>hharm.tls</code>, <code>d.0.tls</code>, <code>dg.0.tls</code>,
<code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <code>h.0.tls</code>,
<code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <code>hharm.0.tls</code>, <code>P01</code>,
<code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>,
<code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>,
<code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: same description and
format as indicated for same named columns of <code>fixed.area.plot</code>
in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>If the <code>fixed.area.plot</code> element is included in <code>simulations</code>
argument, it must contain at least <code>id</code> and <code>radius</code> columns,
one of the field estimates columns and one of the TLS metrics
columns.
</p>
</li>
<li> <p><code>k.tree.plot</code>: data frame with field estimates and TLS
metrics under the k-tree plot design. Each row corresponds to a
(plot, k) pair, and all or any of the following columns are included:
</p>
<p>Plot identification and k:
</p>

<ul>
<li> <p><code>id</code>, <code>k</code>: same description and format as indicated
for same named columns of <code>k.tree.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>Variables estimates on the basis of simulated field plots:
</p>

<ul>
<li> <p><code>N</code>, <code>G</code>, <code>V</code>, <code>d</code>, <code>dg</code>,
<code>dgeom</code>, <code>dharm</code>, <code>h</code>, <code>hg</code>, <code>hgeom</code>,
<code>hharm</code>, <code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>,
<code>dharm.0</code>, <code>h.0</code>, <code>hg.0</code>, <code>hgeom.0</code>,
<code>hharm.0</code>: same description and format as indicated for same
named columns of <code>k.tree.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>, <code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>,
<code>N.hr.cov</code>, <code>N.sh</code>, <code>num.points</code>, <br />
<code>num.points.est</code>, <code>num.points.hom</code>,
<code>num.points.hom.est</code>, <code>G.tls</code>, <br /> <code>G.hn</code>,
<code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>, <code>G.sh</code>,
<code>V.tls</code>, <code>V.hn</code>, <code>V.hr</code>, <br /> <code>V.hn.cov</code>,
<code>V.hr.cov</code>, <code>V.sh</code>, <code>d.tls</code>, <code>dg.tls</code>,
<code>dgeom.tls</code>, <code>dharm.tls</code>, <code>h.tls</code>, <code>hg.tls</code>,
<code>hgeom.tls</code>, <code>hharm.tls</code>, <code>d.0.tls</code>, <code>dg.0.tls</code>,
<br /> <code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <code>h.0.tls</code>,
<code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <br /> <code>hharm.0.tls</code>,
<code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>,
<code>P30</code>, <code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>,
<code>P75</code>, <code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: same
description and format as indicated for same named columns of
<code>k.tree.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>If a <code>k.tree.plot</code> element is included in the <code>simulations</code> argument,
it must include at least <code>id</code> and <code>k</code> columns, one of the field
estimate columns, and one of the TLS metrics columns.
</p>
</li>
<li> <p><code>angle.count.plot</code>: data frame with field estimates and TLS
metrics under the angle-count plot design. Each row corresponds
to a (plot, BAF) pair, and all or one of the following
columns are included:
</p>
<p>Plot identification and BAF:
</p>

<ul>
<li> <p><code>id</code>, <code>BAF</code>: same description and format as indicated
for same named columns of <code>angle.count.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>Variables estimated on the basis of simulated field plots:
</p>

<ul>
<li> <p><code>N</code>, <code>G</code>, <code>V</code>, <code>d</code>, <code>dg</code>,
<code>dgeom</code>, <code>dharm</code>, <code>h</code>, <code>hg</code>, <code>hgeom</code>,
<code>hharm</code>, <code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>,
<code>dharm.0</code>, <code>h.0</code>, <code>hg.0</code>, <code>hgeom.0</code>,
<code>hharm.0</code>: same description and format as indicated for same
named columns of <code>angle.count.plot</code> in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>, <code>N.pam</code>, <code>num.points</code>,
<code>num.points.est</code>, <code>num.points.hom</code>, <br />
<code>num.points.hom.est</code>, <code>G.tls</code>, <code>G.pam</code>, <code>V.tls</code>,
<code>V.pam</code>, <code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>,
<code>dharm.tls</code>, <code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>,
<code>hharm.tls</code>, <br /> <code>d.0.tls</code>, <code>dg.0.tls</code>,
<code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <code>h.0.tls</code>, <br />
<code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <code>hharm.0.tls</code>, <code>P01</code>,
<code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>,
<code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>,
<code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: same description and
format as indicated for same named columns of <code>angle.count.plot</code>
in <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

<p>If the <code>angle.count.plot</code> element is included in the <code>simulations</code>
argument, it must contain at least <code>id</code> and <code>BAF</code> columns, one
of the field estimates columns and one of the TLS metrics columns.
</p>
</li></ul>

</td></tr>
<tr><td><code id="correlations_+3A_variables">variables</code></td>
<td>

<p>Optional character vector naming field estimates for which correlations
between these and all the available TLS metrics will be computed. If
this argument is specified by the user, it must include at least one of the
following character strings: &ldquo;<code>N</code>&rdquo;, &ldquo;<code>G</code>&rdquo;,
&ldquo;<code>V</code>&rdquo;, &ldquo;<code>d</code>&rdquo;, &ldquo;<code>dg</code>&rdquo;,
&ldquo;<code>dgeom</code>&rdquo;, &ldquo;<code>dharm</code>&rdquo;, &ldquo;<code>d.0</code>&rdquo;,
&ldquo;<code>dg.0</code>&rdquo;, &ldquo;<code>dgeom.0</code>&rdquo;, &ldquo;<code>dharm.0</code>&rdquo;,
&ldquo;<code>h</code>&rdquo;, &ldquo;<code>hg</code>&rdquo;, &ldquo;<code>hgeom</code>&rdquo;,
&ldquo;<code>hharm</code>&rdquo;, &ldquo;<code>h.0</code>&rdquo;, &ldquo;<code>hg.0</code>&rdquo;,
&ldquo;<code>hgeom.0</code>&rdquo;, or &ldquo;<code>hharm.0</code>&rdquo;. If this argument is not
specified by the user, it will be set to
</p>
<p><code>c("N", "G", "V", "d", "dg", "d.0", "h", "h.0")</code> by default. In both
cases all the elements in the <code>simulations</code> argument
must include at least the columns corresponding to the field estimates specified in the
<code>variables</code> argument.
</p>
</td></tr>
<tr><td><code id="correlations_+3A_method">method</code></td>
<td>

<p>Optional character vector naming which correlation measurements will be used.
If this argument is specified by the user, it must include at least one of
the following character strings: &ldquo;<code>pearson</code>&rdquo; or
&ldquo;<code>spearman</code>&rdquo;. If this argument is not specified by the user, it
will be set to <code>c("pearson", "spearman")</code> by default.
</p>
</td></tr>
<tr><td><code id="correlations_+3A_save.result">save.result</code></td>
<td>

<p>Optional logical indicating wheter or not the output files described in
&lsquo;Output Files&rsquo; section must be saved in <code>dir.result</code> or not. If
this argument is not specified by the user, it will be set to <code>TRUE</code> by
default and, as a consequence, the output files will be saved.
</p>
</td></tr>
<tr><td><code id="correlations_+3A_dir.result">dir.result</code></td>
<td>

<p>Optional character string naming the absolute path of an existing directory
where files described in the &lsquo;Output Files&rsquo; section will be saved.
<code>.Platform$file.sep</code> must be used as the path separator in
<code>dir.result</code>. If this argument is not specified by the user, and
<code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and,
as consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be
assigned to <code>dir.result</code> during execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each radius, k or BAF value (according to the currently available plot
designs: circular fixed area, k-tree and angle-count), this function computes
correlations between each variable estimated from field data
specified in the <code>variables</code> argument and all the metrics derived from TLS
data existing in the data frames included in the <code>simulations</code> argument.
</p>
<p>Two correlation measures are implemented at present: Pearson's correlation
coefficient and Spearman's <em>rho</em>. For each method, in addition to the
estimated measure, the p-value of a test for association is also returned.
The <code><a href="stats.html#topic+cor.test">cor.test</a></code> function from the <span class="pkg">utils</span> package is used to compute
both the estimated correlations and the p-values of the associated tests; more
details about these measures and their tests for association can be found in
the corresponding documentation. There cannot be
missing data for three or more plots, and there cannot be zero standard deviation,
in order to prevent missing correlation values for each (field estimation, TLS
metric) pair and plot design parameter (radius, k or BAF).
</p>
<p>Apart from estimated correlations and their corresponding p-values, for ecah method, the
function also returns the plot design parameter and field
estimates, the value of the optimal correlation (i.e. the maximum of the
absolute value of available correlations) and the TLS metric to which it
corresponds.
</p>


<h3>Value</h3>

<table>
<tr><td><code>correlations</code></td>
<td>

<p>A list including the estimated correlations for each measure specified in the
<code>method</code> argument will be generated. This will include all or any of the following named
elements:
</p>

<ul>
<li> <p><code>pearson</code>: if &ldquo;<code>pearson</code>&rdquo; is not included in
<code>method</code> parameter, missing; otherwise, the list will include the
estimated Pearson's correlations for each plot design specified in the
<code>simulations</code> argument. In the latter case, the list will include all or any
of the following named elements:
</p>

<ul>
<li> <p><code>fixed.area.plot</code>: if the <code>simulations</code> argument does not
have an element named &ldquo;<code>fixed.area.plot</code>&rdquo;, missing;
otherwise, the matrix will include the estimated Pearson's correlations
for a circular fixed area plot design. Each row will correspond to a
radius value, and the following columns will be included:
</p>

<ul>
<li> <p><code>radius</code>: radius (m) of the simulated plots used for
computing the estimated correlations.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: numeric column(s)
containing estimated Pearson's correlations between
&lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimate, and &lsquo;<code>&lt;y&gt;</code>&rsquo;,
a TLS metric.
</p>
</li></ul>

</li>
<li> <p><code>k.tree.plot</code>: if the <code>simulations</code> argument does not
include an element named &ldquo;<code>k.tree.plot</code>&rdquo;, missing;
otherwise, the matrix will include the estimated Pearson's correlations
for a k-tree plot design. Each row will correspond to a k
value, and the following columns will be included:
</p>

<ul>
<li> <p><code>k</code>: number of trees (trees) of the simulated plots
used for computing the estimated correlations.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: same description and
format as indicated in
<code>correlations$pearson$fixed.area.plot</code> element.
</p>
</li></ul>

</li>
<li> <p><code>angle.count.plot</code>: if the <code>simulations</code> argument does
not have any element named &ldquo;<code>angle.count</code>&rdquo;,  missing;
otherwise, the matrix will include the estimated Pearson's correlations
for the angle-count plot design. Each row will correspond to a
BAF value, and the following columns will be included:
</p>

<ul>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plots used for
computing the estimated correlations.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: same description
and format as indicated in
<code>correlations$pearson$fixed.area.plot</code> element.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>spearman</code>: if &ldquo;<code>spearman</code>&rdquo; is not included in
<code>method</code> parameter, missing; otherwise, the list will include the
estimated Spearman's correlations for each plot design specified in
<code>simulations</code> argument. In the latter case, the structure and format
will be analogous to that indicated for the previous element but
estimated Pearson's correlations will be replaced by Spearman's correlations.
</p>
</li></ul>

</td></tr>
<tr><td><code>correlations.pval</code></td>
<td>

<p>List containing the p-value of the test for association corresponding to each
measure specified in <code>method</code> argument. The structure and format will be
the same as indicated for the previous element but estimated
correlations will be replaced by p-values for their corresponding tests for association.
</p>
</td></tr>
<tr><td><code>opt.correlations</code></td>
<td>

<p>List containing the optimal correlations, and the names of the TLS metrics to
which they correspond, for each measure specified in <code>method</code> argument.
The list will will include all or any of the following named elements:
</p>

<ul>
<li> <p><code>pearson</code>: if &ldquo;<code>pearson</code>&rdquo; is not included in
<code>method</code> parameter, missing; otherwise, the list will include the optimal
Pearson's correlations, and the names of the TLS metrics to which they
correspond, for each plot design specified in <code>simulations</code>
argument. In the latter case, it will include all or any of the following
named elements:
</p>

<ul>
<li> <p><code>fixed.area.plot</code>: if <code>simulations</code> argument does not
have any element named &ldquo;<code>fixed.area.plot</code>&rdquo;, missing;
otherwise, the data frame will include the optimal Pearson's correlations,
and the names of the TLS metrics to which they correspond, for a
circular fixed area plot design. Each row will correspond to a radius
value, and the following columns will be included:
</p>

<ul>
<li> <p><code>radius</code>: radius (m) of the simulated plots used for
computing the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: the former, numeric column(s)
including optimal Pearson's correlations between
&lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimate, and all the available
TLS metrics; and the latter, character column(s) will include names
of the TLS metrics to which they correspond.
</p>
</li></ul>

</li>
<li> <p><code>k.tree.plot</code>: if the <code>simulations</code> argument does not
have any element named &ldquo;<code>k.tree.plot</code>&rdquo;, missing;
otherwise, the data frame will include the optimal Pearson's correlations
and the names of the TLS metrics to which they correspond for the
k-tree plot design. Each row will correspond to a k value,
and the following columns will be included:
</p>

<ul>
<li> <p><code>k</code>: number of trees (trees) of the simulated plots
used for computing the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: same description and format as
indicated in <code>opt.correlations$pearson$fixed.area.plot</code>
element.
</p>
</li></ul>

</li>
<li> <p><code>angle.count.plot</code>: if the <code>simulations</code> argument does
not have any element named &ldquo;<code>angle.count</code>&rdquo;, missing;
otherwise, the data frame will include the optimal Pearson's correlations,
and the names of the TLS metrics to which they correspond for the
angle-count plot design. Each row will correspond to a BAF
value, and the following columns will be included:
</p>

<ul>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plots used for
computing the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: same description and format as
indicated in <code>opt.correlations$pearson$fixed.area.plot</code>
element.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>spearman</code>: if &ldquo;<code>spearman</code>&rdquo; is not included in
<code>method</code> parameter, missing; otherwise, the list will include the
optimal Spearman's correlations, and the names of the TLS metrics to
which they correspond, for each plot design specified in
<code>simulations</code> argument. In the latter case, the structure and
format will be analogous to that indicated for the previous element, but
optimal Pearson's correlations will be replaced by Spearman's correlations.
</p>
</li></ul>

</td></tr>
</table>


<h3>Output Files</h3>

<p>During the execution, if the <code>save.result</code> argument is <code>TRUE</code>, the
function prints to files the matrices and data frames included in
<code>correlations</code> and <code>opt.correlations</code> elements described in
&lsquo;Value&rsquo;. Both are written without row names in
<code>dir.result</code> directory by using the <code><a href="utils.html#topic+write.csv">write.csv</a></code> function in the
<span class="pkg">utils</span> package. The patterns used for naming these files are
&lsquo;<span class="file">correlations.&lt;plot design&gt;.&lt;method&gt;.csv</span>&rsquo; and
&lsquo;<span class="file">opt.correlations.&lt;plot design&gt;.plot.&lt;method&gt;.csv</span>&rsquo; for correlation
matrices and optimal correlation data frames, respectively, where
&lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; is equal to &ldquo;<code>fixed.area.plot</code>&rdquo;,
&ldquo;<code>k.tree.plot</code>&rdquo; or &ldquo;<code>angle.count.plot</code>&rdquo; according to
plot design, and &lsquo;<span class="file">&lt;method&gt;</span>&rsquo; equals &ldquo;<code>pearson</code>&rdquo; or
&ldquo;<code>spearman</code>&rdquo; according to the correlation measure.
</p>
<p>Furthermore, if the <code>save.result</code> argument is <code>TRUE</code>, interactive line
charts graphically representing correlations will also be created and saved
in the <code>dir.result</code> directory by means of <code><a href="htmlwidgets.html#topic+saveWidget">saveWidget</a></code> function
in the <a href="https://CRAN.R-project.org/package=htmlwidgets"><span class="pkg">htmlwidgets</span></a> package. Generated widgets enable users to
consult correlation data directly on the plots, select/deselect different
sets of traces, to zoom and scroll, etc. The pattern used for naming
these files is &lsquo;<span class="file">correlations.&lt;x&gt;.&lt;plot design&gt;.&lt;method&gt;.html</span>&rsquo;, where both
&lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; and &lsquo;<span class="file">&lt;method&gt;</span>&rsquo; are as indicated for the previous
described files, and &lsquo;<span class="file">&lt;x&gt;</span>&rsquo; is equal to any of elements specified in the
<code>variables</code> argument.
</p>


<h3>Note</h3>

<p>This function is particularly useful for further steps related to model-based
and model-assisted approaches, as correlations measure the strength of a relationship between two variables (linear for
Pearson's correlation, monotonic for Spearman's correlation).
</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulations">simulations</a></code>, <code><a href="#topic+optimize.plot.design">optimize.plot.design</a></code>.
</p>
<p><code><a href="stats.html#topic+cor.test">cor.test</a></code> in <span class="pkg">utils</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load field estimates and TLS metrics corresponding to Rioja data set

data("Rioja.simulations")


# Establish directory where correlation results corresponding to the Rioja example
# will be saved. For instance, current working directory

# dir.result &lt;- getwd()


# Compute correlations between field estimates and TLS metrics corresponding
# to Rioja example
# Pearson's and Spearman's correlations for variables by default

# corr &lt;- correlations(simulations = Rioja.simulations, dir.result = dir.result)


# Pearson's and Spearman's correlations for variable 'N'

# corr &lt;- correlations(simulations = Rioja.simulations, variables = "N",
#                      dir.result = dir.result)


# Only Pearson's correlations for variables by default

# corr &lt;- correlations(simulations = Rioja.simulations, method = "pearson",
#                      dir.result = dir.result)


# Pearson's and Spearman's correlations corresponding to angle-count design for
# all available variables

# corr &lt;- correlations(simulations = Rioja.simulations["angle.count"],
#                      variables &lt;- c("N", "G", "V", "d", "dg", "dgeom", "dharm",
#                                     "d.0", "dg.0", "dgeom.0", "dharm.0", "h",
#                                     "hg", "hgeom", "hharm", "h.0", "hg.0",
#                                     "hgeom.0", "hharm.0"),
#                      dir.result = dir.result)

  

</code></pre>

<hr>
<h2 id='distance.sampling'>Distance Sampling Methods for Correcting Occlusions Effects</h2><span id='topic+distance.sampling'></span>

<h3>Description</h3>

<p>Calculation of the probability of detection of every tree by using distance sampling methodologies (more specifically point transects methods), by means of fitting detection functions to the histogram of tree distribution according to their distance to TLS. Use both half normal and hazard rate functions, without and with <em>dbh</em> as covariate. These probabilities are used for correcting estimation bias caused by lack of detection of trees due to occlusion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance.sampling(tree.tls,
                  id.plots = NULL,
                  strata.attributes = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance.sampling_+3A_tree.tls">tree.tls</code></td>
<td>
<p>Data frame with a list of trees detected and their <em>dbh</em> and horizontal distances from TLS with the same structure and format as <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code> &lsquo;Value&rsquo;.</p>
</td></tr>
<tr><td><code id="distance.sampling_+3A_id.plots">id.plots</code></td>
<td>
<p>Optional vector with plot identification encoded as character string or numeric for the plots considered. In this case, <code>tree.tls</code> argument must include a common column named &lsquo;id&rsquo;. If this argument is not specified by the user, it will be set to NULL by default, and as a consequence, all plots will be considered.</p>
</td></tr>
<tr><td><code id="distance.sampling_+3A_strata.attributes">strata.attributes</code></td>
<td>
<p>Optional data frame inluding plot radius considered at strata level. It must contain a column named &lsquo;stratum&rsquo; (numeric) with encoding coinciding with that used in previous functions (<code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>) for identifying strata. Therefore, strata must heve been included previously in &lsquo;tree.tls&rsquo;. Another column named &lsquo;plot.radius&rsquo; (numeric) will be required to set maximum horizontal distance (m) considered for fitting detection probability functions. If this argument is not specified by the user, it will be set to NULL by default, and as a consequence, all trees will be included.</p>
</td></tr></table>


<h3>Details</h3>

<p>All internal functions related to distance sampling methodologies are fitted with the <code><a href="Distance.html#topic+ds">ds</a></code> function included in the <a href="https://CRAN.R-project.org/package=Distance"><span class="pkg">Distance</span></a> package.
</p>
<p>Detection functions are left-truncated at 1 m, according to Astrup et al., (2014).
</p>
<p>Same warning messages as <code><a href="Distance.html#topic+ds">ds</a></code> function are provided when fits do not converge or another warnings occur.
</p>
<p>For further details on these point transects methods  and similar sampling methodologies, as well as their application with R, see Buckland et al., (2001); Marques &amp; Buckland, (2003); Miller &amp; Thomas, (2015) and Clark (2016). Examples of distance sampling analyses, as well as lectures, are available at <a href="http://examples.distancesampling.org/">http://examples.distancesampling.org/</a> and <a href="http://workshops.distancesampling.org/">http://workshops.distancesampling.org/</a>.</p>


<h3>Value</h3>

<p>List containing the following elements:
</p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>Data frame with detection probabilities for every tree and method.</p>
</td></tr>
</table>

<ul>
<li> <p><code>stratum</code>: stratum identification (coincident with strata of <code>tree.tls</code>). If there are not strata, it will be set as a single stratum encoded as 1 (numeric).
</p>
</li>
<li> <p><code>id</code>: plot identification (coincident with id of <code>tree.tls</code>).
</p>
</li>
<li> <p><code>tree</code>: tree numbering (coincident with <code>tree</code> of <code>tree.tls</code>).
</p>
</li>
<li> <p><code>P.hn</code>: tree detection probability according to half normal function.
</p>
</li>
<li> <p><code>P.hn.cov</code>: tree detection probability according to half normal function with <em>dbh</em> as covariate.
</p>
</li>
<li> <p><code>P.hr</code>: tree detection probability according to half rate function.
</p>
</li>
<li> <p><code>P.hr.cov</code>: tree detection probability according to half rate function with <em>dbh</em> as covariate.</p>
</li></ul>

<table>
<tr><td><code>parameters</code></td>
<td>
<p>Data frame with parameters estimated for detection functions (see references for understanding their meaning).</p>
</td></tr>
</table>

<ul>
<li> <p><code>P.hn.scale</code>: scale parameter for half normal function (sigma).
</p>
</li>
<li> <p><code>P.hn.cov.scale.intercept</code>: alpha.0 parameter of scale parameter for half normal function with <em>dbh</em> as covariate.
</p>
</li>
<li> <p><code>P.hn.cov.dbh</code>: alpha.1 parameter of scale parameter for half normal function with <em>dbh</em> as covariate.
</p>
</li>
<li> <p><code>P.hr.scale</code>: scale parameter for half rate function (sigma).
</p>
</li>
<li> <p><code>P.hr.shape</code>: shape parameter for half rate function (b).
</p>
</li>
<li> <p><code>P.hr.cov.scale.intercept</code>: alpha.0 parameter of scale parameter for half normal function with <em>dbh</em> as covariate.
</p>
</li>
<li> <p><code>P.hr.cov.dbh</code>: alpha.1 parameter of scale parameter for half normal function with <em>dbh</em> as covariate.
</p>
</li>
<li> <p><code>P.hr.cov.shape</code>: shape parameter for half rate function with <em>dbh</em> as covariate (b).</p>
</li></ul>

<table>
<tr><td><code>AIC</code></td>
<td>
<p>Data frame with Akaike information criterions (AIC) of every detection function fit.</p>
</td></tr>
</table>

<ul>
<li> <p><code>P.hn</code>: AIC of half normal function fit.
</p>
</li>
<li> <p><code>P.hn.cov</code>:  AIC of half normal function with <em>dbh</em> as covariate fit.
</p>
</li>
<li> <p><code>P.hr</code>:  AIC of half rate function fit.
</p>
</li>
<li> <p><code>P.hr.cov</code>:  AIC of half rate function with <em>dbh</em> as covariate fit.</p>
</li></ul>


<h3>Note</h3>

<p>Although this step is optional for other functionalities of <span class="pkg">FORTLS</span>, such as obtaining metrics and assessing the best plot designs (implemented in <code><a href="#topic+metrics.variables">metrics.variables</a></code>, <code><a href="#topic+correlations">correlations</a></code>, <code><a href="#topic+relative.bias">relative.bias</a></code> and <code><a href="#topic+optimize.plot.design">optimize.plot.design</a></code>), its inclusion is highly recommended, especially with high rates of occlusions.
</p>
<p>Note that this function could be more useful after assessing the best possible plot design with <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code>, <code><a href="#topic+correlations">correlations</a></code>, <code><a href="#topic+relative.bias">relative.bias</a></code> or <code><a href="#topic+optimize.plot.design">optimize.plot.design</a></code> functions.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero
and Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Astrup, R., Ducey, M. J., Granhus, A., Ritter, T., &amp; von Lüpke, N. (2014). Approaches for estimating stand-level volume using terrestrial laser scanning in a single-scan mode. <em>Canadian Journal of Forest Research</em>, <b>44(6)</b>, 666-676. <a href="https://doi.org/10.1139/cjfr-2013-0535">doi:10.1139/cjfr-2013-0535</a>.
</p>
<p>Buckland, S. T., Anderson, D. R., Burnham, K. P., Laake, J. L., Borchers, D. L., &amp; Thomas, L. (2001). <em>Introduction to distance sampling: estimating abundance of biological populations</em>, Oxford, United Kindown, Oxford University Press.
</p>
<p>Clark, R. G. (2016). Statistical efficiency in distance sampling. <em>PloS one</em>, <b>11(3)</b>, e0149298. <a href="https://doi.org/10.1371/journal.pone.0149298">doi:10.1371/journal.pone.0149298</a>.
</p>
<p>Marques, F. F., &amp; Buckland, S. T. (2003). Incorporating covariates into standard line transect analyses. <em>Biometrics</em>, <b>59(4)</b>, 924-935. <a href="https://doi.org/10.1111/j.0006-341X.2003.00107.x">doi:10.1111/j.0006-341X.2003.00107.x</a>.
</p>
<p>Miller, D. L., &amp; Thomas, L. (2015). Mixture models for distance sampling detection functions. <em>PloS one</em>, <b>10(3)</b>, e0118726. <a href="https://doi.org/10.1371/journal.pone.0118726">doi:10.1371/journal.pone.0118726</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>, <code><a href="#topic+metrics.variables">metrics.variables</a></code>, <code><a href="#topic+simulations">simulations</a></code>.
</p>
<p><code><a href="Distance.html#topic+ds">ds</a></code> in <a href="https://CRAN.R-project.org/package=Distance"><span class="pkg">Distance</span></a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Loading example data

data(Rioja.data)

tree.tls &lt;- Rioja.data$tree.tls

# Whithout considering maximum distance

ds &lt;- distance.sampling(tree.tls)


  

</code></pre>

<hr>
<h2 id='estimation.plot.size'>Assess Consistency of Metrics for Simulated TLS Plots</h2><span id='topic+estimation.plot.size'></span>

<h3>Description</h3>

<p>Plots empirical linear charts of density (<em>N</em>, trees/ha) and basal area (<em>G</em>, <code class="reqn">{m}^{2}/ha</code>) estimates (derived from simulated TLS plots) as a function of plot size (estimation-size charts) for different plot designs (circular fixed area, k-tree and angle-count), through continuous size increments (radius, k and BAF respectively). Size increments are set at 0.1 m, 1 tree and 0.1 <code class="reqn">{m}^{2}/ha</code> for fixed area, k-tree and angle-count plot designs, respectively. These size-estimation line charts represent the consistency in predicting the stand variables across different values of radius, k and BAF. Size-estimation charts can be drawn for individual sample plots (including all plots together in the same charts) or for mean values (global mean computed for all the sample plots, or for group means if different strata are considered). Finally,
different plot designs can be compared if specified in the arguments, producing one size-estimation chart per variable (<em>N</em> and <em>G</em>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimation.plot.size(tree.tls,
                     plot.parameters = data.frame(radius.max = 25,
                                                  k.max = 50,
                                                  BAF.max = 4),
                     dbh.min = 4,
                     average = FALSE, all.plot.designs = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimation.plot.size_+3A_tree.tls">tree.tls</code></td>
<td>
<p>Data frame with information of trees detected from TLS point cloud data in the same format as <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> &lsquo;Value&rsquo;.</p>
</td></tr>
<tr><td><code id="estimation.plot.size_+3A_plot.parameters">plot.parameters</code></td>
<td>
<p>Optional data frame containing parameters for circular fixed area, k-tree and angle-count plot designs. The parameters are as follows:</p>
</td></tr>
</table>

<ul>
<li><p><code>radius.max</code>: maximum plot radius (m) considered for circular fixed area plots. If the <code>radius.max</code> specified is larger than the farthest tree from the plot centre, the horizontal distance from the farthest tree will be considered the maximum <code>radius</code>. By default, the <code>radius.max</code> will be 25 m.
</p>
</li>
<li><p><code>k.tree.max</code>: maximum number of trees considered for k-tree plots. If <code>k.tree.max</code> specified is larger than the maximum number of trees of the densest plot, this number of trees will be considered the maximum <code>k.tree.max</code>. By default, <code>k.tree.max</code> is 50.
</p>
</li>
<li><p><code>BAF.max</code>: maximum basal area factor (<code class="reqn">{m}^{2}/ha</code>) considered for angle-count plots. By default, <code>BAF.max</code> is 4.</p>
</li></ul>

<table>
<tr><td><code id="estimation.plot.size_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="estimation.plot.size_+3A_average">average</code></td>
<td>
<p>Logical; if <code>TRUE</code>, plot means values and standard deviation of estimations will be represented. By default, it will be set as <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimation.plot.size_+3A_all.plot.designs">all.plot.designs</code></td>
<td>
<p>Logical; if <code>TRUE</code>, charts for each plot design are drawn together. By default, it will be set as <code>FALSE</code>.</p>
</td></tr></table>


<h3>Details</h3>

<p>If there are strata in the <code>tree.tls</code> argument, they will be differentiated in charts with different colours. Strata must be specified in a numeric column named <code>stratum</code>.
</p>
<p>The <code>all.plot.designs</code> argument only works for single strata, and therefore if there are additional strata in the <code>tree.tls</code> argument, they will be considered equal.
</p>
<p>The outputs of this function are inspired by Fig. 3 of Brunner and Gizachew (2014).</p>


<h3>Value</h3>

<p><code>Invisible NULL</code></p>


<h3>Note</h3>

<p>Mean values are relevant when plots are representing homogenous strata.
</p>
<p>Note that this is an option for choosing the best plot design when  field data are not available. Otherwise, using <code><a href="#topic+correlations">correlations</a></code>, <code><a href="#topic+relative.bias">relative.bias</a></code> and <code><a href="#topic+optimize.plot.design">optimize.plot.design</a></code> will be more desirable for obtaining the best possible plot design.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Brunner, A., &amp; Gizachew, B. (2014). Rapid detection of stand density, tree positions, and tree diameter with a 2D terrestrial laser scanner. <em>European Journal of Forest Research</em>, <b>133(5)</b>, 819-831.</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Loading dataset with trees detected from TLS single-scans

data("Rioja.data")

tree.tls &lt;- Rioja.data$tree.tls


# Without strata and plot parameters by default

estimation.plot.size(tree.tls)

estimation.plot.size(tree.tls, average = TRUE)

estimation.plot.size(tree.tls, all.plot.designs = TRUE)


  

</code></pre>

<hr>
<h2 id='fixed_area_cpp'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+fixed_area_cpp'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fixed_area_cpp(radius_seq, hdist, d, h, num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed_area_cpp_+3A_radius_seq">radius_seq</code></td>
<td>
<p>BAF sequence for simulations</p>
</td></tr>
<tr><td><code id="fixed_area_cpp_+3A_hdist">hdist</code></td>
<td>
<p>BAF masimum for simulations</p>
</td></tr>
<tr><td><code id="fixed_area_cpp_+3A_d">d</code></td>
<td>
<p>vector with diameters opf trees</p>
</td></tr>
<tr><td><code id="fixed_area_cpp_+3A_h">h</code></td>
<td>
<p>vector with heights of trees</p>
</td></tr>
<tr><td><code id="fixed_area_cpp_+3A_num">num</code></td>
<td>
<p>number of trees considered for calculating diameter and dominant height</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='FORTLS-package'>FORTLS: Automatic Processing of Terrestrial-Based Technologies Point Cloud Data for Forestry Purposes</h2><span id='topic+FORTLS'></span><span id='topic+FORTLS-package'></span>

<h3>Description</h3>

<p>Process automation of point cloud data derived from terrestrial-based technologies such as Terrestrial Laser Scanner (TLS) or Mobile Laser Scanner. 'FORTLS' enables (i) detection of trees and estimation of tree-level attributes (e.g. diameters and heights), (ii) estimation of stand-level variables (e.g. density, basal area, mean and dominant height), (iii) computation of metrics related to important forest attributes estimated in Forest Inventories at stand-level, and (iv) optimization of plot design for combining TLS data and field measured data. Documentation about 'FORTLS' is described in Molina-Valero et al. (2022, &lt;doi:10.1016/j.envsoft.2022.105337&gt;). 
</p>


<h3>Details</h3>

<p>Usage of <span class="pkg">FORTLS</span> includes the following functionalities:
</p>

<ul>
<li><p>Tree detection: this is the first and necessary step for the other functionalities of <span class="pkg">FORTLS</span>. This can be achieved using the following functions:
</p>

<ol>
<li><p><code><a href="#topic+normalize">normalize</a></code>: mandatory first step for obtaining the relative coordinates of a TLS point cloud.
</p>
</li>
<li><p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>: detects as many trees as possible from a normalized TLS single-scan point clouds.
</p>
</li>
<li><p><code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>: detects as many trees as possible from a normalized TLS multi-scan, SLAM, or similar terrestrial-based technologies point clouds.
</p>
</li>
<li><p><code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>: includes the two previous functions for a better workflow when there are several plots to be sequentially analyzed.</p>
</li></ol>

</li>
<li><p>Estimation of variables when no field data are available: this is the main functionality of <span class="pkg">FORTLS</span> and can be achieved using the following functions:
</p>

<ol>
<li><p><code><a href="#topic+distance.sampling">distance.sampling</a></code>: optional function which can be used for considering methodologies for correcting occlusion effects in estimating variables.
</p>
</li>
<li><p><code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code>: enables the best plot design to be determined on the basis of TLS data only.
</p>
</li>
<li><p><code><a href="#topic+metrics.variables">metrics.variables</a></code>: is used for estimating metrics and variables potentially related to forest attributes at stand level.</p>
</li></ol>

</li>
<li><p>Estimation of variables when field data are available: this is the main and most desirable functionality of <span class="pkg">FORTLS</span> and can be achieved using the following functions:
</p>

<ol>
<li><p><code><a href="#topic+distance.sampling">distance.sampling</a></code>: as before.
</p>
</li>
<li><p><code><a href="#topic+simulations">simulations</a></code>: computes simulations of TLS and field data for different plot designs. This is a prior step to the next functions.
</p>
</li>
<li><p><code><a href="#topic+relative.bias">relative.bias</a></code>: uses <code><a href="#topic+simulations">simulations</a></code> output to assess the accuracy of direct estimations of variables according to homologous TLS and field data.
</p>
</li>
<li><p><code><a href="#topic+correlations">correlations</a></code>: uses <code><a href="#topic+simulations">simulations</a></code> output to assess correlations among metrics and variables obtained from TLS data, and variables of interest estimated from field data.
</p>
</li>
<li><p><code><a href="#topic+optimize.plot.design">optimize.plot.design</a></code>: using <code><a href="#topic+correlations">correlations</a></code> output, represents the best correlations for variables of interest according to the plot design. It is thus possible to select the best plot design for estimating forest attributes from TLS data. 
</p>
</li>
<li><p><code><a href="#topic+metrics.variables">metrics.variables</a></code>: as before, but in this case plot parameters will be choosen on the basis of field data and better estimates will therefore be obtained.</p>
</li></ol>
</li></ul>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Juan Alberto Molina-Valero <a href="mailto:juanalberto.molina.valero@usc.es">juanalberto.molina.valero@usc.es</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> María José Ginzo Villamayor [contributor]
</p>
</li>
<li><p> Manuel Antonio Novo Pérez [contributor]
</p>
</li>
<li><p> Adela Martínez-Calvo [contributor]
</p>
</li>
<li><p> Juan Gabriel Álvarez-González [contributor]
</p>
</li>
<li><p> Fernando Montes [contributor]
</p>
</li>
<li><p> César Pérez-Cruzado [contributor]
</p>
</li></ul>


<h3>References</h3>

<p>Molina-Valero J. A., Ginzo-Villamayor M. J., Novo Pérez M. A., Martínez-Calvo A., Álvarez-González J. G., Montes F., &amp; Pérez-Cruzado C. (2019). FORTLS: an R package for processing TLS data and estimating stand variables in forest inventories. <em>The 1st International Electronic Conference on Forests — Forests for a Better Future: Sustainability, Innovation, Interdisciplinarity</em>. <a href="https://doi.org/10.3390/IECF2020-08066">doi:10.3390/IECF2020-08066</a></p>

<hr>
<h2 id='height_perc_cpp'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+height_perc_cpp'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  height_perc_cpp(rho_seq, z, rho)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="height_perc_cpp_+3A_rho_seq">rho_seq</code></td>
<td>
<p>BAF sequence for simulations</p>
</td></tr>
<tr><td><code id="height_perc_cpp_+3A_z">z</code></td>
<td>
<p>vector with heights of trees</p>
</td></tr>
<tr><td><code id="height_perc_cpp_+3A_rho">rho</code></td>
<td>
<p>number of trees considered for calculating diameter and dominant height</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='k_tree_cpp'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+k_tree_cpp'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  k_tree_cpp(k_seq, radius_seq, k, d, h, num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_tree_cpp_+3A_k_seq">k_seq</code></td>
<td>
<p>BAF sequence for simulations</p>
</td></tr>
<tr><td><code id="k_tree_cpp_+3A_radius_seq">radius_seq</code></td>
<td>
<p>BAF sequence for simulations</p>
</td></tr>
<tr><td><code id="k_tree_cpp_+3A_k">k</code></td>
<td>
<p>BAF masimum for simulations</p>
</td></tr>
<tr><td><code id="k_tree_cpp_+3A_d">d</code></td>
<td>
<p>vector with diameters opf trees</p>
</td></tr>
<tr><td><code id="k_tree_cpp_+3A_h">h</code></td>
<td>
<p>vector with heights of trees</p>
</td></tr>
<tr><td><code id="k_tree_cpp_+3A_num">num</code></td>
<td>
<p>number of trees considered for calculating diameter and dominant height</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='metrics.variables'>Compute Metrics and Variables for Terrestrial-Based Technologies Point Clouds</h2><span id='topic+metrics.variables'></span>

<h3>Description</h3>

<p>This function computes a set of metrics and variables from the Terrestrial-Based Technologies point cloud data, which have a high potential to be related or used as direct estimates (in the case of variables) of forest attributes at plot level. These can be obtained for different plot designs (circular fixed area, k-tree and angle-count plots). This function also includes methodologies for correcting occlusions generated in TLS single-scan point clouds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics.variables(tree.tls, tree.ds = NULL, tree.field = NULL,
                  plot.design = c("fixed.area", "k.tree", "angle.count"),
                  plot.parameters = data.frame(radius = 25, k = 10, BAF = 2),
                  scan.approach = "single",
                  var.metr = list(tls = NULL, field = NULL),
                  v.calc = "parab", dbh.min = 4, h.min = 1.3,
                  max.dist = Inf, dir.data = NULL,
                  save.result = TRUE, dir.result = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics.variables_+3A_tree.tls">tree.tls</code></td>
<td>
<p>Data frame with information about trees detected from terrestrial-based technologies point clouds data in the same format as <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> or <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> &lsquo;Values&rsquo;.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_tree.ds">tree.ds</code></td>
<td>
<p>Optional list containing detection probabilities of trees with distance sampling methods. The format must be the same as the &lsquo;Value&rsquo; obtained with <code><a href="#topic+distance.sampling">distance.sampling</a></code>. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, TLS metrics using distance sampling based correction will not be calculated for circular fixed area and k-tree plot designs.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_tree.field">tree.field</code></td>
<td>

<p>Data frame with information about trees measured in the field plots. Each
row must correspond to a (plot, tree) pair, and it must include at least the
following columns:
</p>

<ul>
<li> <p><code>id</code>: plot identification encoded as character string or
numeric. Plot identifications must coincide with those
included in <code>id</code> column of the <code>tree.tls</code> argument.
</p>
</li>
<li> <p><code>tree</code>: trees numbering.
</p>
</li>
<li> <p><code>h.dist</code>: horizontal distance (m) from plot
centre to tree centre. Centres of the field plots must coincide with
centres of their corresponding Terrestrial-based technologies plots.
</p>
</li>
<li> <p><code>dbh</code>: tree diameter (cm) at breast height (1.3 m).
</p>
</li>
<li> <p><code>h</code>: tree total height (m).
</p>
</li>
<li> <p><code>h.blc</code>: height based live crown (m) (optional).
</p>
</li>
<li> <p><code>h.bdc</code>: height based dead crown (m) (optional).
</p>
</li>
<li> <p><code>v.user</code>: tree volume (m^3) (optional).
</p>
</li>
<li> <p><code>w.user</code>: tree biomass (Mg) (optional).
</p>
</li>
<li> <p><code>dead</code>: integer value indicating for each tree if it is dead
(1) or not (NA).
</p>
</li></ul>

</td></tr>
<tr><td><code id="metrics.variables_+3A_plot.design">plot.design</code></td>
<td>
<p>Vector containing the plot designs considered. By default, all plot designs will be considered (circular fixed area, k-tree and angle-count plots).</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_plot.parameters">plot.parameters</code></td>
<td>
<p>Data frame containing parameters for circular fixed area, k-tree and angle-count plot designs. If there is a <code>stratum</code> column in the <code>tree.list.tls</code> argument, it must have the same number of rows as strata values and they must be named using strata encoding. If plot parameters are not specified, the corresponding plot designs will not be considered in the function. If no parameter is specified, the function will stop giving an error message! The parameters are as follows:</p>
</td></tr>
</table>

<ul>
<li><p><code>radius</code>: plot radius (m) considered for circular fixed area plots. Absence of this argument rules out this plot design.
</p>
</li>
<li><p><code>k.tree</code>: number of trees (trees) considered for k-tree plots. Absence of this argument rules out this plot design.
</p>
</li>
<li><p><code>BAF</code>: basal area factor (<code class="reqn">{m}^{2}/ha</code>) considered for angle-count plots. Absence of this argument rules out this plot design.
</p>
</li>
<li><p><code>num.trees</code>: number of dominant trees per ha (tree/ha), i.e. those with largest <em>dbh</em>, considered for calculating dominant diameters and heights. In the absence of this argument, the number will be assumed to be 100 trees/ha.</p>
</li></ul>

<table>
<tr><td><code id="metrics.variables_+3A_scan.approach">scan.approach</code></td>
<td>
<p>Character parameter indicating TLS single-scan (&lsquo;single&rsquo;) or TLS multi-scan approach or SLAM point clouds (&lsquo;multi&rsquo;) approaches. If this argument is not specified by the user, it will be set to &lsquo;multi&rsquo; approach.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_var.metr">var.metr</code></td>
<td>
<p>Optional vector containing all the metrics and variables of interest. By default it will be set as NULL and thus, all the metrics and variables available will be generated.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_v.calc">v.calc</code></td>
<td>
<p>Optional parameter to calculate volume when is not included in tree.tls input data.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_h.min">h.min</code></td>
<td>
<p>Optional minimum <em>h</em> (m) considered for detecting trees. By default it will be set at 1.3 m.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_max.dist">max.dist</code></td>
<td>
<p>Optional argument to specify the maximum horizontal distance considered in which trees will be included.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_dir.data">dir.data</code></td>
<td>
<p>Optional character string naming the absolute path of the directory where TXT
files containing TLS point clouds are located. <code>.Platform$file.sep</code> must
be used as the path separator in <code>dir.data</code>, and TXT files in the
directory must have the same description and format as indicated for TXT
files in <code><a href="#topic+normalize">normalize</a></code> &lsquo;Output Files&rsquo;. If this
argument is not specified by the user, it will be set to <code>NULL</code> by default
and, as consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be
assigned to <code>dir.dat</code> during the execution.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_save.result">save.result</code></td>
<td>
<p>Optional logical which indicates whether or not the output files described in &lsquo;Output Files&rsquo; section must be saved in <code>dir.result</code>. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the output files will be saved.</p>
</td></tr>
<tr><td><code id="metrics.variables_+3A_dir.result">dir.result</code></td>
<td>
<p>Optional character string naming the absolute path of an existing directory where files described in &lsquo;Output Files&rsquo; section will be saved. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.result</code>. If this argument is not specified by the user, and <code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function also works for several plots. In this case, a column named &quot;id&quot; to identify plots (string character or numeric) must be included in the <code>tree.list.tls</code> database argument. This must coincide with the corresponding &quot;id&quot; assigned in <code><a href="#topic+normalize">normalize</a></code> to TXT files saved in <code>dir.data</code> (for more details see <code><a href="#topic+normalize">normalize</a></code>). In addition, if there are several strata, they can be processed separately according to <code>plot.parameters</code> values (where each row will represent one stratum). If <code>tree.list.tls</code> does not include a specific &quot;stratum&quot; column, it will be assumed to have only one stratum, which will be encoded according to <code>rownames(plot.parameters)[1]</code>.
</p>
<p>Using TLS data, this function computes metrics and estimations of variables (see &lsquo;Value&rsquo;) for plot design specified in the <code>plot.parameters</code> argument. The notation used for variables is based on IUFRO (1959).
</p>
<p>At this stage, three plot designs are available:
</p>

<ul>
<li><p> Circular fixed area plots, simulated only if a <code>radius</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li>
<li><p> k-tree plots, simulated only if a <code>k.tree</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li>
<li><p> Angle-count plots, simulated only if a <code>BAF</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li></ul>

<p>Volume is estimated modelling stem profile as a paraboloid and calculating the volumes of revolution; where trees <em>dbh</em> are estimated in <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, and total heights are estimated as percentile 99 of z coordinate of points delimited by Voronoi polygons.
</p>
<p>Regarding occlusion corrections for estimating variables, apart from distance sampling methods considered in <code><a href="#topic+distance.sampling">distance.sampling</a></code>, another occlusion corection based on correcting the shadowing effect (Seidel &amp; Ammer, 2014) has been included to estimate some variables in circular fixed area and k-tree plots. In the case of angle-count plots, occlusion corrections are based on gap probability attenuation with distance to TLS depending on Poisson model (Strahler et al., 2008; Lovell et al., 2011).</p>


<h3>Value</h3>

<p>List including TLS-based metrics and variables computed for plot designs considered. The list will contain one element per plot design considered (fixed.area.plot, k.tree.plot and angle.count.plot):
</p>
<table>
<tr><td><code>fixed.area.plot</code></td>
<td>
<p>If no value for <code>plot.radius</code> is specified in the <code>plot.parameters</code> argument, <code>NULL</code>; otherwise, the data frame will include TLS metrics and variables estimated in a circular fixed area plot design (rows represent simulations). The data frame will have the following columns:
</p>
<p>Stratum, plot identification and radius:
</p>

<ul>
<li> <p><code>stratum</code>: stratum identification encoded as a character string or
numeric. It must coincide with those included in the <code>stratum</code> column of <code>tree.list.tls</code>.
</p>
</li>
<li> <p><code>id</code>: plot identification encoded as character string or
numeric. It will coincide with those included in the <code>id</code>
column of <code>tree.list.tls</code> and, if applicable, the
<code>distance.sampling</code> argument.
</p>
</li>
<li> <p><code>radius</code>: radius (m) of the simulated plot.</p>
</li></ul>

<p>Terrestrial-Based Technologies variables:
</p>

<ul>
<li> <p><code>N.tls</code>: stand density (trees/ha) without occlusion
corrections.
</p>
</li>
<li> <p><code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>, <code>N.hr.cov</code>: stand
density (trees/ha) with occlusion corrections based on distance sampling
methodologies (see <code><a href="#topic+distance.sampling">distance.sampling</a></code>). These columns will not appear if the <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>N.sh</code>: stand density (trees/ha) with correction of the
shadowing effect.
respectively).
</p>
</li>
<li> <p><code>G.tls</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) without occlusion
corrections.
</p>
</li>
<li> <p><code>G.hn</code>, <code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>: stand
basal area (<code class="reqn">{m}^{2}/ha</code>) with occlusion corrections based on distance sampling
methodologies (see <code><a href="#topic+distance.sampling">distance.sampling</a></code>). These columns are missing if <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>G.sh</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) with correction of the
shadowing effect.
</p>
</li>
<li> <p><code>V.tls</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>) without occlusion corrections.
</p>
</li>
<li> <p><code>V.hn</code>, <code>V.hr</code>, <code>V.hn.cov</code>, <code>V.hr.cov</code>: stand
volume (<code class="reqn">{m}^{3}/ha</code>) with occlusion corrections based on distance sampling
methodologies (see <code><a href="#topic+distance.sampling">distance.sampling</a></code>). These  columns will be missing if the <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>V.sh</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>) with correction of the
shadowing effect.
</p>
</li>
<li> <p><code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>, <code>dharm.tls</code>:
mean tree diameters (cm) at breast height (1.3 m), calculated from the arithmetic mean,
quadratic mean, geometric mean and harmonic mean, respectively.
</p>
</li>
<li> <p><code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>, <code>hharm.tls</code>:
mean tree heights (m), calculated from the arithmetic mean, quadratic mean, geometric
mean and harmonic mean, respectively.
</p>
</li>
<li> <p><code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>,
<code>dharm.0.tls</code>: dominant mean tree diameters (cm) at breast height
(1.3 m), calculated from the arithmetic mean, quadratic mean, geometric mean and
harmonic mean, respectively.
</p>
</li>
<li> <p><code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>,
<code>hharm.0.tls</code>: dominant mean tree heights (m), calculated from the arithmetic
mean, quadratic mean, geometric mean and harmonic mean, respectively.</p>
</li></ul>

<p>Terrestrial-Based Technologies metrics:
</p>

<ul>
<li> <p><code>n.pts</code>, <code>n.pts.est</code>, <code>n.pts.red</code>, <code>n.pts.red.est</code>: number of points and estimated number of
points (points) belonging to trees normal sections (+/- 5 cm) in the
original point cloud (<code>n.pts</code> and <code>n.pts.est</code>,
respectively); and number of points and estimated number of points
(points) belonging to trees normal sections (+/- 5 cm) in the reduced
point cloud (<code>n.pts.red</code> and <code>n.pts.red.est</code>,
respectively).
</p>
</li>
<li> <p><code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>,
<code>P30</code>, <code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>,
<code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: height percentiles
derived from z coordinates of TLS point clouds relative to ground level (m).
</p>
</li>
<li> <p><code>mean.arit.z/rho/phi</code>, <code>mean.qua.z/rho/phi</code>, <code>mean.geom.z/rho/phi</code>, <code>mean.harm.z/rho/phi</code>, <code>median.z/rho/phi</code>, <code>mode.z/rho/phi</code>: central tendency statistics for z, rho (horizontal distance) and r (euclidean distance) coordinates (arithmetic, quadratic, geometrical and harmonic means, median and mode, respectively).
</p>
</li>
<li> <p><code>var.z/rho/phi</code>, <code>sd.z/rho/phi</code>, <code>CV.z/rho/phi</code>, <code>D.z/rho/phi</code>, <code>ID.z/rho/phi</code>, <code>max.z/rho/phi</code>, <code>min.z/rho/phi</code>: dispersion tendency statistics for z, rho and r coordinates (variance, standar deviation, coefficient of variation, range, interquartile range, maximum and minimum, respectively).
</p>
</li>
<li> <p><code>kurt.z/rho/phi</code>, <code>skw.z/rho/phi</code>: curtosis and skewness, respectively.
</p>
</li>
<li> <p><code>L1.z/rho/phi</code>, <code>L2.z/rho/phi</code>, <code>L3.z/rho/phi</code>, <code>L4.z/rho/phi</code>, <code>L-CV.z/rho/phi</code>, <code>MAD-median.z/rho/phi</code>, <code>MAD-mode.z/rho/phi</code>: L-moments of order 2, 3 and 4, median of the absolute deviations from the overall median and mode of the absolute deviations from the overall mode, respectively.
</p>
</li>
<li> <p><code>L3.mu.z/rho/phi</code>, <code>L4.mu.z/rho/phi</code>: third and fourth central moments, respectively.
</p>
</li>
<li> <p><code>PA.2m</code>, <code>PA.mean.z</code>, <code>PA.mode.z</code>: percentage of laser returns above 2 m, mean and mode, respectively.
</p>
</li>
<li> <p><code>PB.2m</code>, <code>PB.mean.z</code>, <code>PB.median.z</code>, <code>PB.mode.z</code>: percentage of laser returns below 2 m, mean and mode, respectively.
</p>
</li>
<li> <p><code>weibull.b.z/rho/phi</code>, <code>weibull.c.z/rho/phi</code>: scale and shape parameters, respectively, for Weibull distribution fitted for z coordinates of TLS point clouds relative to ground level.</p>
</li></ul>
</td></tr>
<tr><td><code>k.tree.plot</code></td>
<td>
<p>If no value for <code>k.tree</code> is specified in the <code>plot.parameters</code> argument, <code>NULL</code>; otherwise, the data frame will include TLS metrics and variables estimated in the k-tree plot design (rows represent simulations). The data frame will include the following columns (same description and format as indicated in <code>fixed.area.plot</code> element):
</p>
<p>Stratum, plot identification and k:
</p>

<ul>
<li> <p><code>stratum</code>: stratum identification encoded as character string or
numeric. It must coincide with those included in the <code>stratum</code> column of <code>tree.list.tls</code>.
</p>
</li>
<li> <p><code>id</code>: plot identification encoded as character string or numeric value. It will coincide with those included in <code>id</code>
column of <code>tree.list.tls</code> or, if applicable, the
<code>distance.sampling</code> argument.
</p>
</li>
<li> <p><code>k</code>: number of trees in the simulated plot.</p>
</li></ul>

<p>Terrestrial-Based Technologies variables:
</p>

<ul>
<li> <p><code>N.tls</code>, <code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>,
<code>N.hr.cov</code>, <code>N.sh</code>, <br />
<code>G.tls</code>, <code>G.hn</code>, <code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>,
<code>G.sh</code>, <br /> <code>V.tls</code>, <code>V.hn</code>, <code>V.hr</code>, <code>V.hn.cov</code>,
<code>V.hr.cov</code>, <code>V.sh</code>, <br /> <code>d.tls</code>, <code>dg.tls</code>,
<code>dgeom.tls</code>, <code>dharm.tls</code>, <br /> <code>h.tls</code>, <code>hg.tls</code>,
<code>hgeom.tls</code>, <code>hharm.tls</code>, <br /> <code>d.0.tls</code>, <code>dg.0.tls</code>,
<code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <br /> <code>h.0.tls</code>, <code>hg.0.tls</code>,
<code>hgeom.0.tls</code>, <code>hharm.0.tls</code></p>
</li></ul>

<p>Terrestrial-Based Technologies metrics:
</p>

<ul>
<li> <p><code>num.points</code>,
<code>num.points.est</code>, <code>num.points.hom</code>, <code>num.points.hom.est</code>, <br />          <code>P01</code>,<code>P05</code>,
<code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>, <code>P40</code>, <code>P50</code>,
<code>P60</code>, <code>P70</code>, <code>P75</code>, <code>P80</code>, <code>P90</code>, <code>P95</code>,
<code>P99</code>: same description and format
as indicated in fixed.area.plot element.</p>
</li></ul>
</td></tr>
<tr><td><code>angle.count.plot</code></td>
<td>
<p>If no value for <code>BAF</code> is specified in the <code>plot.parameters</code> argument, <code>NULL</code>; otherwise, the data frame will include TLS metrics and variables estimated in the angle-count plot design (rows represent simulations). The data frame will include the following columns:
</p>
<p>Stratum, plot identification and BAF:
</p>

<ul>
<li> <p><code>stratum</code>: stratum identification encoded as character string or
numeric. It must coincide with those included in <code>stratum</code> column of <code>tree.list.tls</code>.
</p>
</li>
<li> <p><code>id</code>: plot identification encoded as character string or numeric. It will coincide with those included in the <code>id</code> column of <code>tree.list.tls</code>.
</p>
</li>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plot.</p>
</li></ul>

<p>Terrestrial-Based Technologies variables:
</p>

<ul>
<li> <p><code>N.tls</code>: same description and format as indicated in the
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>N.pam</code>: stand density (trees/ha) with occlusion correction
based on gap probability attenuation with distance to TLS.
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>G.tls</code>: same description and format as indicated for the
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>G.pam</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) with occlusion correction
based on gap probability attenuation with distance from TLS.
</p>
</li>
<li> <p><code>V.tls</code>: same description and format as indicated for the
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>V.pam</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>) with occlusion correction based
on gap probability attenuation with distance from TLS.
</p>
</li>
<li> <p><code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>, <code>dharm.tls</code>, <br />
<code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>, <code>hharm.tls</code>, <br />
<code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <br />
<code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <code>hharm.0.tls</code></p>
</li></ul>

<p>Terrestrial-Based Technologies metrics:
</p>

<ul>
<li> <p><code>num.points</code>, <code>num.points.est</code>, <code>num.points.hom</code>,
<code>num.points.hom.est</code>, <br />
<code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>,
<code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>, <code>P80</code>,
<code>P90</code>, <code>P95</code>, <code>P99</code>: same description and format as
indicated for the <code>fixed.area.plot</code> element.</p>
</li></ul>
</td></tr></table>


<h3>Output Files</h3>

<p>After computing metrics and variables, if the <code>save.result</code> argument is <code>TRUE</code>, the function will save the elements in the list described in &lsquo;Value&rsquo; (<code>fixed.area.plot</code>, <code>k.tree.plot</code> and <code>angle.count.plot</code>), which are different from <code>NULL</code> as CSV files.  Data frames are written without row names in the <code>dir.result</code> directory by using <code><a href="utils.html#topic+write.csv">write.csv</a></code> function from the <span class="pkg">utils</span> package. The pattern used for naming these files is ‘metrics.variables.&lt;plot design&gt;.csv’,
being ‘&lt;plot design&gt;’ equal to “fixed.area.plot”, “k.tree.plot” or “angle.count.plot”
according to the plot design.</p>


<h3>Note</h3>

<p>In order to optimize plot designs and, therefore, for better use of <code><a href="#topic+metrics.variables">metrics.variables</a></code>, other functions such as <code><a href="#topic+correlations">correlations</a></code>, <code><a href="#topic+relative.bias">relative.bias</a></code> and <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code> should be used.
</p>
<p>This function will be updated as new metrics are developed.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>IUFRO (1959). Standarization of symbols in forest mensuration. Vienna, Austria, IUFRO.
</p>
<p>Lovell, J. L., Jupp, D. L. B., Newnham, G. J., &amp; Culvenor, D. S. (2011). Measuring tree stem diameters using intensity profiles from ground-based scanning lidar from a fixed viewpoint. <em>ISPRS Journal of Photogrammetry and Remote Sensing</em>, <b>66(1)</b>, 46-55. <a href="https://doi.org/10.1016/j.isprsjprs.2010.08.006">doi:10.1016/j.isprsjprs.2010.08.006</a>
</p>
<p>Seidel, D., &amp; Ammer, C. (2014). Efficient measurements of basal area in short rotation forests based on terrestrial laser scanning under special consideration of shadowing. <em>iForest-Biogeosciences and Forestry</em>, <b>7(4)</b>, 227. <a href="https://doi.org/10.3832/ifor1084-007">doi:10.3832/ifor1084-007</a>
</p>
<p>Strahler, A. H., Jupp, D. L. B., Woodcock, C. E., Schaaf, C. B., Yao, T., Zhao,
F., Yang, X., Lovell, J., Culvenor, D., Newnham, G., Ni-Miester, W., &amp;
Boykin-Morris, W. (2008). Retrieval of forest structural parameters using a
ground-based lidar instrument (Echidna®). <em>Canadian Journal of Remote
Sensing</em>, <b>34(sup2)</b>, S426-S440. <a href="https://doi.org/10.5589/m08-046">doi:10.5589/m08-046</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>, <code><a href="#topic+distance.sampling">distance.sampling</a></code>,
<code><a href="#topic+normalize">normalize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Establishment of working directories (optional)
# By default here we propose the current working directory of the R process

dir.data &lt;- getwd()
dir.result &lt;- getwd()


# Loading example data included in FORTLS

data("Rioja.data")
tree.tls &lt;- Rioja.data$tree.tls
tree.tls &lt;- tree.tls[tree.tls$id == "1", ]

# Download example of TXT file corresponding to plot 1 from Rioja data set

download.file(url = "https://www.dropbox.com/s/w4fgcyezr2olj9m/Rioja_1.txt?dl=1",
              destfile = file.path(dir.data, "1.txt"), mode = "wb")


# Considering distance sampling methods (only for single-scan approaches)

# ds &lt;- distance.sampling(tree.tls)

met.var.TLS &lt;- metrics.variables(tree.tls = tree.tls,
                                 # tree.ds = ds,
                                 plot.parameters = data.frame(radius = 10, k = 10, BAF = 2),
                                 dir.data = dir.data, dir.result = dir.result)


  

</code></pre>

<hr>
<h2 id='ncr_point_cloud_double'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+ncr_point_cloud_double'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ncr_point_cloud_double(m)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncr_point_cloud_double_+3A_m">m</code></td>
<td>
<p>matrix with points.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='normalize'>Relative Coordinates and Density Reduction for Terrestrial-Based Technologies Point Clouds</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>This function obtains coordinates relative to the plot centre speciefied for Terrestrial Laser Scanner (TLS) and Mobile Laser Scanner (MLS) point clouds (supplied as LAS or LAZ files). Point clouds obtained from other devices/approaches (e.g. photogrammetry) can be also used, but the guarantee of good performance is likely to be lower. In addition, the point cropping process developed by Molina-Valero et al., (2019) is applied as a criterion for reducing point density homogeneously in space and proportionally to object size when TLS single-scans are provided.</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(las, normalized = NULL,
          x.center = NULL, y.center = NULL,
          x.side = NULL, y.side = NULL,
          max.dist = NULL, min.height = NULL, max.height = 50,
          algorithm.dtm = "knnidw", res.dtm = 0.2,
          csf = list(cloth_resolution = 0.5),
          intensity = NULL, RGB = NULL,
          scan.approach = "single",
          id = NULL, file = NULL, plot = TRUE,
          dir.data = NULL, save.result = TRUE, dir.result = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_las">las</code></td>
<td>
<p>Character string containing the name of LAS file belonging to TLS point cloud, including .las extension (see &lsquo;Examples&rsquo;). Planimetric coordinates of point cloud data must be in local, representing TLS scan point the origin with Cartesian coordinates x and y as (0, 0).</p>
</td></tr>
<tr><td><code id="normalize_+3A_normalized">normalized</code></td>
<td>
<p>Optional argument to establish as <code>TRUE</code> when point cloud is already normalized.</p>
</td></tr>
<tr><td><code id="normalize_+3A_x.center">x.center</code></td>
<td>
<p>Planimetric x center coordinate of point cloud data.</p>
</td></tr>
<tr><td><code id="normalize_+3A_y.center">y.center</code></td>
<td>
<p>Planimetric y center coordinate of point cloud data.</p>
</td></tr>
<tr><td><code id="normalize_+3A_x.side">x.side</code></td>
<td>
<p>x-side (m) of the plot when the plot is square or rectangular.</p>
</td></tr>
<tr><td><code id="normalize_+3A_y.side">y.side</code></td>
<td>
<p>y-side (m) of the plot when the plot is square or rectangular.</p>
</td></tr>
<tr><td><code id="normalize_+3A_max.dist">max.dist</code></td>
<td>
<p>Optional maximum horizontal distance (m) considered from the plot centre. All points farther than <code>max.dist</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>max.dist</code> representing the farthest point.</p>
</td></tr>
<tr><td><code id="normalize_+3A_min.height">min.height</code></td>
<td>
<p>Optional minimum height (m) considered from ground level. All points below <code>min.height</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>min.height</code> representing the lowest point.</p>
</td></tr>
<tr><td><code id="normalize_+3A_max.height">max.height</code></td>
<td>
<p>Optional maximum height (m) considered from ground level. All points above <code>max.height</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>max.height</code> representing the highest point.</p>
</td></tr>
<tr><td><code id="normalize_+3A_algorithm.dtm">algorithm.dtm</code></td>
<td>
<p>Algorithm used to generate the digital terrain model (DTM) from the TLS point cloud. There are two posible options based on spatial interpolation: &lsquo;tin&rsquo; and &lsquo;knnidw&rsquo; (see &lsquo;Details&rsquo;). If this argument is not specified by the user, it will be set to &lsquo;knnidw&rsquo; algorithm.</p>
</td></tr>
<tr><td><code id="normalize_+3A_res.dtm">res.dtm</code></td>
<td>
<p>Numeric parameter. Resolution of the DTM generated to normalize point cloud (see &lsquo;Details&rsquo;). If this argument is not specified by the user, it will be set to 0.2 m.</p>
</td></tr>
<tr><td><code id="normalize_+3A_csf">csf</code></td>
<td>
<p>List containing parameters of CSF algorithm:</p>
</td></tr>
</table>

<ul>
<li> <p><code>cloth_resolution</code>: by default 0.5.</p>
</li></ul>

<table>
<tr><td><code id="normalize_+3A_scan.approach">scan.approach</code></td>
<td>
<p>Character parameter indicating TLS single-scan (&lsquo;single&rsquo;) or TLS multi-scan approach or SLAM point clouds (&lsquo;multi&rsquo;) approaches. If this argument is not specified by the user, it will be set to &lsquo;multi&rsquo; approach.</p>
</td></tr>
<tr><td><code id="normalize_+3A_intensity">intensity</code></td>
<td>
<p>Logical parameter useful when point clouds have LiDAR intesinty values.</p>
</td></tr>
<tr><td><code id="normalize_+3A_rgb">RGB</code></td>
<td>
<p>Logical parameter useful when point clouds are colorized, thus including values of RGB colors. It is based on the Green Leaf Algorithm (GLA) (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="normalize_+3A_id">id</code></td>
<td>
<p>Optional plot identification encoded as character string or numeric. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the plot will be encoded as 1.</p>
</td></tr>
<tr><td><code id="normalize_+3A_file">file</code></td>
<td>
<p>Optional file name identification encoded as character string or numeric value. If it is null, file will be encoded as <code>id</code> by default.</p>
</td></tr>
<tr><td><code id="normalize_+3A_plot">plot</code></td>
<td>
<p>Optional logical which indicates whether or not the normalized point cloud will be plot. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the normalized point cloud will be plot.</p>
</td></tr>
<tr><td><code id="normalize_+3A_dir.data">dir.data</code></td>
<td>
<p>Optional character string naming the absolute path of the directory where LAS files containing TLS point clouds are located. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.data</code>. If this argument is not specified by the user, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.data</code> during the execution.</p>
</td></tr>
<tr><td><code id="normalize_+3A_save.result">save.result</code></td>
<td>
<p>Optional logical which indicates whether or not the output files described in &lsquo;Output Files&rsquo; section must be saved in <code>dir.result</code>. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the output files will be saved.</p>
</td></tr>
<tr><td><code id="normalize_+3A_dir.result">dir.result</code></td>
<td>
<p>Optional character string naming the absolute path of an existing directory where files described in &lsquo;Output Files&rsquo; section will be saved. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.result</code>. If this argument is not specified by the user, and <code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.</p>
</td></tr></table>


<h3>Details</h3>

<p>Relative coordinates are obtained by means of a normalization process, generating a digital terrain model (DTM) from the TLS point cloud, with the ground height set at 0 m. The DTM is generated by spatial interpolation of ground points classified with the CSF algorithm (Zhang et al., (2016)). Two algorithms are available for that purpose: (i) spatial interpolation based on a Delaunay triangulation, which performs a linear interpolation within each triangle (&lsquo;tin&rsquo;); (ii) spatial interpolation using a k-nearest neighbour (KNN) approach with inverse-distance weighting (IDW) (&lsquo;knnidw&rsquo;). Note that normalization process is based on <a href="https://CRAN.R-project.org/package=lidR"><span class="pkg">lidR</span></a> package functions: <code><a href="lidR.html#topic+classify_ground">classify_ground</a></code>, <code><a href="lidR.html#topic+grid_terrain">grid_terrain</a></code> and <code><a href="lidR.html#topic+normalize_height">normalize_height</a></code>.
</p>
<p>The point cropping process reduces the point cloud density proportionally to the likelihood that objects will receive points according to their distance from TLS and their size, which is determined by angle aperture (the farther they are, the lower the density is). The result is an approximately homogeneous point cloud in three-dimensional space (for more details see Molina-Valero et al., (2019)).
</p>
<p>The Green Leaf Algorithm (GLA) is calculated according to Louhaichi et al., (2001)as follows:
</p>
<p>Those points with values below 0 are clasified as woody parts, thus retained for tree detection in further functions.</p>


<h3>Value</h3>

<p>Data frame of normalized point cloud including the following columns (each row corresponds to one point):
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Plot identification encoded as a character string or numeric in the argument <code>id</code>.</p>
</td></tr>
<tr><td><code>file</code></td>
<td>
<p>File name identification encoded as character string or numeric, corresponding to the normalized and reduced point clouds saved. This coincides with the TXT file in the absolute path specified in <code>dir.result</code> (if <code>save.result</code> is set to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>Coordinates</code></td>
<td>

<p>Cartesian (according to <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">https://en.wikipedia.org/wiki/Cartesian_coordinate_system</a> notation):
</p>

<ul>
<li> <p><code>x</code>: x axis distance (m).
</p>
</li>
<li> <p><code>y</code>: y axis distance (m).
</p>
</li>
<li> <p><code>z</code>: height (m).
</p>
</li></ul>

<p>Cylindrical (according to <a href="https://en.wikipedia.org/wiki/Cylindrical_coordinate_system">https://en.wikipedia.org/wiki/Cylindrical_coordinate_system</a> notation):
</p>

<ul>
<li> <p><code>rho</code>: horizontal distance (m).
</p>
</li>
<li> <p><code>phi</code>: angular coordinate (rad).
</p>
</li>
<li> <p><code>z</code>: height (m).
</p>
</li></ul>

<p>Spherical (according to <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">https://en.wikipedia.org/wiki/Spherical_coordinate_system</a> notation):
</p>

<ul>
<li> <p><code>r</code>: radial distance (m).
</p>
</li>
<li> <p><code>theta</code>: polar angle (rad).
</p>
</li>
<li> <p><code>phi</code>: azimuthal angle (rad)
</p>
</li></ul>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the terrain (rad).</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>
<p>Intensity (only if point cloud has intensity values and specified in arguments).</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Red (only if point cloud is colorized and specified in arguments).</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Green (only if point cloud is colorized and specified in arguments).</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Blue (only if point cloud is colorized and specified in arguments).</p>
</td></tr>
<tr><td><code>GLA</code></td>
<td>
<p>Green Leaf Algorithm (only if point cloud is colorized and specified in arguments).</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>selection probability assigned in point cropping process (0-1]. Only the farthest will have probability of 1.</p>
</td></tr>
<tr><td><code>prob.select</code></td>
<td>
<p>final selection probability assigned in point cropping process. Selected (1) and discarded point (0).</p>
</td></tr></table>


<h3>Output Files</h3>

<p>At the end of the normalization process, if the <code>save.result</code> argument is <code>TRUE</code>, the function will save the reduced point cloud as TXT file and encoded according to <code>file</code> argument. The format is the same as data frame described in &lsquo;Value&rsquo;, except for a <code>prob</code> column, which is removed because all points selected after the point cropping process have a final selection probability of 1. The data frame is written without row names in <code>dir.result</code> directory using the <code><a href="vroom.html#topic+vroom_write">vroom_write</a></code> function in the <a href="https://CRAN.R-project.org/package=vroom"><span class="pkg">vroom</span></a> package.</p>


<h3>Note</h3>

<p>Note that <code>max.dist</code>, <code>min.height</code> and <code>max.height</code> arguments may be useful for optimizing computing time as well as for removing unnecessary and/or outlier points. These values may be selected more appropriately when inventory data are already available, or the user has some knowledge about autoecology of scanned tree species.
</p>
<p>Note also that the linear interpolation algorithm (&lsquo;tin&rsquo; in this package) showed the highest accuracy in Liang et al., (2018) in DTM generation with single-scans. In this work a DTM resolution of 0.2 m was also considered adequately for square plots of 32 x 32 m.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Liang, X., Hyyppä, J., Kaartinen, H., Lehtomäki, M., Pyörälä, J., Pfeifer, N., ... &amp; Wang, Y. (2018). International benchmarking of terrestrial laser scanning approaches for forest inventories. <em>ISPRS journal of photogrammetry and remote sensing</em>, <b>144</b>, 137-179. <a href="https://doi.org/10.1016/j.isprsjprs.2018.06.021">doi:10.1016/j.isprsjprs.2018.06.021</a>
</p>
<p>Louhaichi, M., Borman, M. M., &amp; Johnson, D. E. (2001). Spatially located platform and aerial photography for documentation of grazing impacts on wheat. <em>Geocarto International</em>, <b>16(1)</b>, 65-70. <a href="https://doi.org/10.1080/10106040108542184">doi:10.1080/10106040108542184</a>
</p>
<p>Molina-Valero J. A., Ginzo-Villamayor M. J., Novo Pérez M. A., Álvarez-González J. G., &amp; Pérez-Cruzado C. (2019). Estimación del área basimétrica en masas maduras de Pinus sylvestris en base a una única medición del escáner laser terrestre (TLS). <em>Cuadernos de la Sociedad Espanola de Ciencias Forestales</em>, <b>45(3)</b>, 97-116. <a href="https://doi.org/10.31167/csecfv0i45.19887">doi:10.31167/csecfv0i45.19887</a>.
</p>
<p>Zhang, W., Qi, J., Wan, P., Wang, H., Xie, D., Wang, X., &amp; Yan, G. (2016). An easy-to-use airborne LiDAR data filtering method based on cloth simulation. <em>Remote Sensing</em>, <b>8(6)</b>, 501. <a href="https://doi.org/10.3390/rs8060501">doi:10.3390/rs8060501</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Establishment of working directories (optional)
# By default here we propose the current working directory of the R process

dir.data &lt;- getwd()
dir.result &lt;- getwd()


# TLS SINGLE-SCAN APPROACH

# Loading example TLS data (LAZ file) to dir.data

download.file("https://www.dropbox.com/s/17yl25pbrapat52/PinusRadiata.laz?dl=1",
              destfile = file.path(dir.data, "PinusRadiata.laz"),
              mode = "wb")


# Normalizing the whole point cloud data without considering arguments

pcd &lt;- normalize(las = "PinusRadiata.laz",

                 id = "PinusRadiata",

                 dir.data = dir.data, dir.result = dir.result)


# MLS OR TLS MULTI-SCAN APPROACHES

# Loading example MLS data (LAZ file) to dir.data

download.file(
"www.dropbox.com/scl/fi/es5pfj87wj0g6y8414dpo/PiceaAbies.laz?rlkey=ayt21mbndc6i6fyiz2e7z6oap&amp;dl=1",
              destfile = file.path(dir.data, "PiceaAbies.laz"),
              mode = "wb")

# Normalizing the whole point cloud data without considering arguments

pcd &lt;- normalize(las = "PiceaAbies.laz",

                 id = "PiceaAbies",

                 scan.approach = "multi",

                 dir.data = dir.data, dir.result = dir.result)

  

</code></pre>

<hr>
<h2 id='optimize.plot.design'>
Optimize Plot Design Based on Optimal Correlations
</h2><span id='topic+optimize.plot.design'></span>

<h3>Description</h3>

<p>Generation of interactive heatmaps graphically represent the optimal
correlations between variables estimated from field data, and metrics
derived from TLS data. These data must be derived from any of the three different
plot designs currently available (circular fixed area, k-tree and angle-count) and
correspond to plots with incremental values for the plot design parameter
(radius, k and BAF, respectively). In addition, correlation measures that are currently
admissible are Pearson's correlation coefficient and/or Spearman's <em>rho</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize.plot.design(correlations,
                     variables = c("N", "G", "V", "d", "dg", "d.0", "h", "h.0"),
                     dir.result = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize.plot.design_+3A_correlations">correlations</code></td>
<td>

<p>List including the optimal correlations between field estimations and TLS
metrics. The structure and format must be analogous to the
<code>opt.correlations</code> element in the output returned by the
<code><a href="#topic+correlations">correlations</a></code> function. In particular, the list must include at least one
of the following named elements:
</p>

<ul>
<li> <p><code>pearson</code>: list containing the optimal Pearson's correlations,
and the names of the TLS metrics to which they correspond. It must include
at least one of the following named elements:
</p>

<ul>
<li> <p><code>fixed.area.plot</code>: data frame containing the optimal
Pearson's correlations, and the names of the TLS metrics to which
they correspond, under circular fixed area plot design. Each row will
correspond to a radius value, and the data frame will include the following columns:
</p>

<ul>
<li> <p><code>radius</code>: radius (m) of the simulated plots used for
computing the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: the former, numeric column(s)
containing optimal Pearson's correlations between
&lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimate, and the available TLS
metrics when <code><a href="#topic+correlations">correlations</a></code> function was executed;
and the latter, character column(s) containing names of the TLS
metrics to which they correspond.
</p>
</li></ul>

<p>If <code>fixed.area.plot</code> is included in <code>pearson</code> element, it
must contain at least the <code>radius</code> column and a
(&lsquo;<code>&lt;x&gt;.cor</code>&rsquo;, &lsquo;<code>&lt;x&gt;.metric</code>&rsquo;) pair of
columns corresponding to the same field estimation.
</p>
</li>
<li> <p><code>k.tree.plot</code>: data frame including the optimal Pearson's
correlations and the names of the TLS metrics to which they
correspond, under the k-tree plot design. Each row will
correspond to a k value, and the following columns will be included:
</p>

<ul>
<li> <p><code>k</code>: number of trees (trees) of the simulated plots
used for computing the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: same description and format as
indicated in <code>correlations$pearson$fixed.area.plot</code> element.
</p>
</li></ul>

<p>If <code>k.tree.plot</code> is included in <code>pearson</code> element, it must
contain at least <code>k</code> column, and a (&lsquo;<code>&lt;x&gt;.cor</code>&rsquo;,
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;) pair of columns corresponding to the same
field estimation.
</p>
</li>
<li> <p><code>angle.count.plot</code>: data frame including the optimal
Pearson's correlations and the names of the TLS metrics to which
they correspond, for the angle-count plot design. Each row will
correspond to a BAF value, and the data frame will include the following columns:
</p>

<ul>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plots used to
compute the estimated correlations.
</p>
</li>
<li><p> Columns &lsquo;<code>&lt;x&gt;.cor</code>&rsquo; and
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;: same description and format as
indicated in <code>correlations$pearson$fixed.area.plot</code> element.
</p>
</li></ul>

<p>If the <code>angle.count.plot</code> is included in the <code>pearson</code> element, it
must include at least the <code>BAF</code> column and a
(&lsquo;<code>&lt;x&gt;.cor</code>&rsquo;, &lsquo;<code>&lt;x&gt;.metric</code>&rsquo;) pair of columns
corresponding to the same field estimation.
</p>
</li></ul>

</li>
<li> <p><code>spearman</code>: list containing the optimal Spearman's
correlations, and the names of the TLS metrics to which they correspond.
The structure and format will be analogous to that indicated for the
previous element but with optimal Pearson's correlations replaced by
Spearman's correlations.
</p>
</li></ul>

</td></tr>
<tr><td><code id="optimize.plot.design_+3A_variables">variables</code></td>
<td>

<p>Optional character vector naming field estimations whose optimal correlations
will be represented graphically in the heatmaps generated during the
execution. If this argument is specified by the user, it must include at
least one of the following character strings: &ldquo;<code>N</code>&rdquo;,
&ldquo;<code>G</code>&rdquo;, &ldquo;<code>V</code>&rdquo;, &ldquo;<code>d</code>&rdquo;, &ldquo;<code>dg</code>&rdquo;,
&ldquo;<code>dgeom</code>&rdquo;, &ldquo;<code>dharm</code>&rdquo;, &ldquo;<code>d.0</code>&rdquo;,
&ldquo;<code>dg.0</code>&rdquo;, &ldquo;<code>dgeom.0</code>&rdquo;, &ldquo;<code>dharm.0</code>&rdquo;,
&ldquo;<code>h</code>&rdquo;, &ldquo;<code>hg</code>&rdquo;, &ldquo;<code>hgeom</code>&rdquo;,
&ldquo;<code>hharm</code>&rdquo;, &ldquo;<code>h.0</code>&rdquo;, &ldquo;<code>hg.0</code>&rdquo;,
&ldquo;<code>hgeom.0</code>&rdquo;, or &ldquo;<code>hharm.0</code>&rdquo;. If this argument is not
specified by the user, it will be set to
<code>c("N", "G", "V", "d", "dg", "d.0", "h", "h.0")</code> by default. In both
cases, all data frames in the <code>correlations</code>
argument must have at least the (&lsquo;<code>&lt;x&gt;.cor</code>&rsquo;,
&lsquo;<code>&lt;x&gt;.metric</code>&rsquo;) pairs corresponding to the field estimations
specified in the <code>variables</code> argument.
</p>
</td></tr>
<tr><td><code id="optimize.plot.design_+3A_dir.result">dir.result</code></td>
<td>

<p>Optional character string naming the absolute path of an existing directory
where files described in &lsquo;Output Files&rsquo; section will be saved.
<code>.Platform$file.sep</code> must be used as the path separator in
<code>dir.result</code>. If this argument is not specified by the user, it will be set
to <code>NULL</code> by default and, as consequence, the current working directory
of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function represents graphically, by means of interactive heatmaps, the strongest correlations (positive or negative) for each plot design and size simulated, between the
estimated variables based on field data specified in the <code>variables</code>
argument, and metrics derived from TLS data, under circular fixed area, k-tree and/or
angle-count plot designs.
</p>
<p>Two correlation measures are implemented at present: Pearson’s correlation
coefficient and Spearman’s rho. Hence, only optimal correlations based on <code>correlations</code> arguments will be taken into account during the
execution.
</p>
<p>For each correlation measure and plot design, at least one no missing value for optimal correlations must be represented;
otherwise, execution will be stopped, and an error message will appear. In
addition, at least two different no missing values for
optimal correlations are required to ensure that the colour palette is
correctly applied when the heatmap is generated.
</p>


<h3>Value</h3>

<p>Invisible <code>NULL</code>.
</p>


<h3>Output Files</h3>

<p>During the execution, interactive heatmaps graphically representing optimal
correlations values between field estimations and TLS metrics are created and
saved in <code>dir.result</code> directory by means of the <code><a href="htmlwidgets.html#topic+saveWidget">saveWidget</a></code>
function in the <a href="https://CRAN.R-project.org/package=htmlwidgets"><span class="pkg">htmlwidgets</span></a> package. The widgets generated allow users
to consult optimal correlations values and TLS metrics to which they correspond
directly on the plots, to zoom and scroll, and so on. The pattern used for
naming these files is &lsquo;<span class="file">opt.correlations.&lt;plot design&gt;.&lt;method&gt;.html</span>&rsquo;,
where &lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; equals &ldquo;<code>fixed.area.plot</code>&rdquo;,
&ldquo;<code>k.tree.plot</code>&rdquo; or &ldquo;<code>angle.count.plot</code>&rdquo; according to
plot design, and &lsquo;<span class="file">&lt;method&gt;</span>&rsquo; equals &ldquo;<code>pearson</code>&rdquo; or
&ldquo;<code>spearman</code>&rdquo; according to correlation measure.
</p>


<h3>Note</h3>

<p>This function is key to choosing the best possible plot design (in terms of
correlation measures) considering all variables of interest before establishing
definitive sampling design.
</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlations">correlations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load field estimations and TLS metrics corresponding to Rioja data set

data("Rioja.simulations")


# Compute correlations between field estimations and TLS metrics corresponding
# to Rioja example, and select optimal correlations results

corr &lt;- correlations(simulations = Rioja.simulations,
                     variables = c("N", "G", "d", "dg", "dgeom","dharm",
                                   "d.0", "dg.0", "dgeom.0", "dharm.0", "h",
                                   "hg", "hgeom", "hharm", "h.0", "hg.0",
                                   "hgeom.0", "hharm.0"),
                     save.result = FALSE)

opt.corr &lt;- corr$opt.correlations


# Establish directory where optimal correlations heatmaps corresponding to Rioja
# example will be saved. For instance, current working directory

dir.result &lt;- getwd()


# Generate heatmaps for optimal correlations between field estimations and TLS
# metrics corresponding to Rioja example
# Optimal Pearson's and Spearman's correlations for variables by default

# optimize.plot.design(correlations = opt.corr, dir.result = dir.result)


# Optimal Pearson's and Spearman's correlations for variables 'N' and 'G'

optimize.plot.design(correlations = opt.corr, variables = c("N", "G"),
                     dir.result = dir.result)


  
</code></pre>

<hr>
<h2 id='relative.bias'>
Relative Bias Between Field Estimations and TLS metrics
</h2><span id='topic+relative.bias'></span>

<h3>Description</h3>

<p>Computes relative bias between variables estimated from field data and
their TLS counterparts derived from TLS data. Field estimates and TLS metrics
for a common set of plots are required in order to compute relative bias. These
data must come from any of the three different plot designs currently available
(circular fixed area, k-tree and angle-count) and correspond to plots with incremental
values for the plot design parameter (radius, k and BAF, respectively). In
addition to computing relative bias, interactive line charts graphically
representing the values obtained between each field estimate and its related
TLS metrics are also generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative.bias(simulations,
              variables = c("N", "G", "V", "d", "dg", "d.0", "h", "h.0"),
              save.result = TRUE, dir.result = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relative.bias_+3A_simulations">simulations</code></td>
<td>

<p>List containing variables estimated from field data and metrics
derived from TLS data. The structure and format must be analogous to output
returned by the <code><a href="#topic+simulations">simulations</a></code> function. In particular, teh list must include
at least one of the following named elements:
</p>

<ul>
<li> <p><code>fixed.area.plot</code>: same description and format as indicated
for same named element in <code>simulations</code> argument of
<code><a href="#topic+correlations">correlations</a></code> function. The only difference is the
columns required when it is included in the argument: in adittion to <code>id</code>,
<code>radius</code> and at least one of the field estimate columns, it must
include at least one TLS counterpart for each field estimate condidered.
</p>
</li>
<li> <p><code>k.tree.plot</code>: same description and format as indicated for
same named element in <code>simulations</code> argument of
<code><a href="#topic+correlations">correlations</a></code> function. The only difference is the columns required when it is included in the argument: in adittion to <code>id</code>, <code>k</code>
and at least one of the field estimate columns, it must include at
least one TLS counterpart for each field estimate considered.
</p>
</li>
<li> <p><code>angle.count.plot</code>: same description and format as indicated
for the same named element in the <code>simulations</code> argument of
<code><a href="#topic+correlations">correlations</a></code> function. The only difference is the columns that are required when this element is included in the argument: in adittion to <code>id</code>,
<code>BAF</code> and at least one of the field estimate columns, it must
contain at least one TLS counterpart for each field estimate considered.
</p>
</li></ul>

</td></tr>
<tr><td><code id="relative.bias_+3A_variables">variables</code></td>
<td>

<p>Optional character vector naming field estimates for which the relative bias
between them and all their available TLS counterparts will be computed. If
this argument is specified by the user, it must contain at least one of the
following character strings: &ldquo;<code>N</code>&rdquo;, &ldquo;<code>G</code>&rdquo;,
&ldquo;<code>V</code>&rdquo;, &ldquo;<code>d</code>&rdquo;, &ldquo;<code>dg</code>&rdquo;,
&ldquo;<code>dgeom</code>&rdquo;, &ldquo;<code>dharm</code>&rdquo;, &ldquo;<code>d.0</code>&rdquo;,
&ldquo;<code>dg.0</code>&rdquo;, &ldquo;<code>dgeom.0</code>&rdquo;, &ldquo;<code>dharm.0</code>&rdquo;,
&ldquo;<code>h</code>&rdquo;, &ldquo;<code>hg</code>&rdquo;, &ldquo;<code>hgeom</code>&rdquo;,
&ldquo;<code>hharm</code>&rdquo;, &ldquo;<code>h.0</code>&rdquo;, &ldquo;<code>hg.0</code>&rdquo;, <br />
&ldquo;<code>hgeom.0</code>&rdquo;, or &ldquo;<code>hharm.0</code>&rdquo;. If this argument is not
specified by the user, it will be set to
<code>c("N", "G", "V", "d", "dg", "d.0", "h", "h.0")</code> by default. In both
cases, all the elements in <code>simulations</code> argument
must include at least the columns corresponding to the field estimations specified in the
<code>variables</code> argument.
</p>
</td></tr>
<tr><td><code id="relative.bias_+3A_save.result">save.result</code></td>
<td>

<p>Optional logical which indicates whether or not the output files described in
&lsquo;Output Files&rsquo; section must be saved in <code>dir.result</code>. If
this argument is not specified by the user, it will be set to <code>TRUE</code> by
default and, as a consequence, the output files will be saved.
</p>
</td></tr>
<tr><td><code id="relative.bias_+3A_dir.result">dir.result</code></td>
<td>

<p>Optional character string naming the absolute path of an existing directory
where files described in &lsquo;Output Files&rsquo; section will be saved.
<code>.Platform$file.sep</code> must be used as the path separator in
<code>dir.result</code>. If this argument is not specified by the user, and
<code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and,
as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be
assigned to <code>dir.result</code> during the execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each radius, k or BAF value (according to the currently available plot
designs: circular fixed area, k-tree and angle-count), this function computes the relative
bias between each variable estimated from field data, and specified in the
<code>variables</code> argument, and their counterparts derived from TLS data, and
existing in the data frames included in the <code>simulations</code> argument. TLS
metrics considered <em>counterparts</em> for each field estimate are
detailed below (see <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo; function
for details about used notation):
</p>

<ul>
<li><p> TLS counterparts for <code>N</code> are <code>N.tls</code>, <code>N.hn</code>,
<code>N.hr</code>, <code>N.hn.cov</code>, <code>N.hr.cov</code> and <code>N.sh</code> in the fixed
area and k-tree plot designs; and <code>N.tls</code> and <code>N.pam</code> in the
angle-count plot design.
</p>
</li>
<li><p> TLS counterparts for <code>G</code> are <code>G.tls</code>, <code>G.hn</code>,
<code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code> and <code>G.sh</code> in the fixed
area and k-tree plot designs; and <code>G.tls</code> and <code>G.pam</code> in the
angle-count plot design.
</p>
</li>
<li><p> TLS counterparts for <code>V</code> are <code>V.tls</code>, <code>V.hn</code>,
<code>V.hr</code>, <code>V.hn.cov</code>, <code>V.hr.cov</code> and <code>V.sh</code> in the fixed
area and k-tree plot designs; and <code>V.tls</code> and <code>V.pam</code> in the
angle-count plot design.
</p>
</li>
<li><p> TLS counterparts for <code>d</code>, <code>dg</code>, <code>dgeom</code>, <code>dharm</code>,
<code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>, and <code>dharm.0</code> are,
respectively: <code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>,
<code>dharm.tls</code>, <code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>, <br />
and <code>dharm.0.tls</code> in any of the three available plot designs.
</p>
</li>
<li><p> TLS counterparts for <code>h</code>, <code>hg</code>, <code>hgeom</code>, <code>hharm</code>,
<code>h.0</code>, <code>hg.0</code>, <code>hgeom.0</code>, and <code>hharm.0</code> are,
respectively <code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>,
<code>hharm.tls</code>, <code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>, and
<br /> <code>hharm.0.tls</code> in any of the three available plot designs. In adittion, <code>P99</code> is also taken into account as a counterpart for all
these field estimates.
</p>
</li></ul>

<p>The relative bias between a field estimation and any of its TLS counterparts is
estimated as follows
</p>
<p style="text-align: center;"><code class="reqn">\frac{\frac{1}{n}\sum_{i = 1}^{n}{y_{i}} -
\frac{1}{n}\sum_{i = 1}^{n}{x_{i}}}{\frac{1}{n}\sum_{i = 1}^{n}{x_{i}}} * 100</code>
</p>

<p>where <code class="reqn">x_{i}</code> and <code class="reqn">y_{i}</code>  are the values of the field
estimate and its TLS counterpart, respectively, corresponding to plot
<code class="reqn">i</code> for <code class="reqn">i = 1, \ldots, n</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fixed.area.plot</code></td>
<td>

<p>If no &ldquo;<code>fixed.area.plot</code>&rdquo; element exists in <code>simulations</code>
argument, missing; otherwise, the matrix will include estimates of the the relative bias
under circular fixed area plot design between each field estimation specified in
<code>variables</code> argument and its TLS counterpart(s) existing in the
&ldquo;<code>fixed.area.plot</code>&rdquo; element in the <code>simulations</code> argument. Each
row will correspond to a radius value, and the following columns will be included:
</p>

<ul>
<li> <p><code>radius</code>: radius (m) of the simulated plots used for computing
the estimated relative bias.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: numeric column(s) containing
estimated relative bias between &lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimation,
and &lsquo;<code>&lt;y&gt;</code>&rsquo;, a TLS counterpart.
</p>
</li></ul>

</td></tr>
<tr><td><code>k.tree.plot</code></td>
<td>

<p>If no &ldquo;<code>k.tree.plot</code>&rdquo; element exists in the <code>simulations</code>
argument, missing; otherwise, the matrix will include the relative bias estimated
in the k-tree plot design between each field estimation specified in
<code>variables</code> argument and its TLS counterpart(s) existing in
&ldquo;<code>k.tree.plot</code>&rdquo; element in <code>simulations</code> argument. Each row will correspond to a k value, and the following columns will be included:
</p>

<ul>
<li> <p><code>k</code>: number of trees (trees) of the simulated plots used for
computing the estimated relative bias.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: numeric column(s) containing
estimated relative bias between &lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimation,
and &lsquo;<code>&lt;y&gt;</code>&rsquo;, a TLS counterpart.
</p>
</li></ul>

</td></tr>
<tr><td><code>angle.count.plot</code></td>
<td>

<p>If no &ldquo;<code>angle.count</code>&rdquo; element exists in <code>simulations</code>
argument, missing; otherwise, the matrix will contain estimated relative bias under
angle-count plot design between each field estimation specified in the
<code>variables</code> argument and its TLS counterpart(s) existing in the
&ldquo;<code>angle.count.plot</code>&rdquo; element in the <code>simulations</code> argument. Each
row will correspond to a BAF value, and the following
columns will be included:
</p>

<ul>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plots used for computing
the estimated relative bias.
</p>
</li>
<li><p> Column(s) &lsquo;<code>&lt;x&gt;.&lt;y&gt;</code>&rsquo;: numeric column(s) containing
estimated relative bias between &lsquo;<code>&lt;x&gt;</code>&rsquo;, a field estimation,
and &lsquo;<code>&lt;y&gt;</code>&rsquo;, a TLS counterpart.
</p>
</li></ul>

</td></tr>
</table>


<h3>Output Files</h3>

<p>During the execution, if the <code>save.result</code> argument is <code>TRUE</code>, the
function will print the matrices described in the &lsquo;Value&rsquo; section to files. These
are written without row names in <code>dir.result</code> directory using
<code><a href="utils.html#topic+write.csv">write.csv</a></code> function from the <span class="pkg">utils</span> package. The pattern used
for naming these files is &lsquo;<span class="file">RB.&lt;plot design&gt;.csv</span>&rsquo;, where
&lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; is equal to &ldquo;<code>fixed.area.plot</code>&rdquo;,
&ldquo;<code>k.tree.plot</code>&rdquo; or &ldquo;<code>angle.count.plot</code>&rdquo; is according to the
plot design.
</p>
<p>Furthermore, if the <code>save.result</code> argument is <code>TRUE</code>, interactive line
charts graphically representing relative bias values will also be created and saved
in the <code>dir.result</code> directory by means of the <code><a href="htmlwidgets.html#topic+saveWidget">saveWidget</a></code> function
in the <a href="https://CRAN.R-project.org/package=htmlwidgets"><span class="pkg">htmlwidgets</span></a> package. Generated widgets allow users to
consult relative bias data directly on the plots, select/deselect different
sets of traces, to zoom and scroll, and so on. The pattern used for naming
these files is &lsquo;<span class="file">RB.&lt;x&gt;.&lt;plot design&gt;.html</span>&rsquo;, where &lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; is
indicated for the previously described files, and &lsquo;<span class="file">&lt;x&gt;</span>&rsquo; equals <code>N</code>,
<code>G</code>, <code>V</code>, <code>d</code> and/or <code>h</code> according to the <code>variables</code>
argument. All relative biases related to diameters are
plotted in the same chart (files named as &lsquo;<span class="file">RB.d.&lt;plot design&gt;.html</span>&rsquo;), and
the same applies to those related to heights (files named as
&lsquo;<span class="file">RB.h.&lt;plot design&gt;.html</span>&rsquo;).
</p>


<h3>Note</h3>

<p>The results obtained using this function are
merely descriptive, and they do not guarantee any type of statistical accuracy
in using TLS metrics instead of field estimations in order to estimate forest
attributes of interest.
</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulations">simulations</a></code>, <code><a href="#topic+correlations">correlations</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load variables estimated from field data, and TLS metrics
# corresponding to Rioja data set

data("Rioja.simulations")


# Establish directory where relative bias results corresponding to Rioja example
# will be saved. For instance, current working directory

dir.result &lt;- getwd()


# Compute relative bias between field-based estimates of TLS metrics
# corresponding to Rioja example
# Relative bias for variables by default

rb &lt;- relative.bias(simulations = Rioja.simulations, dir.result = dir.result)


# Relative bias for variable 'N'

rb &lt;- relative.bias(simulations = Rioja.simulations, variables = "N",
                    dir.result = dir.result)


# Relative bias corresponding to angle-count design for all available variables

rb &lt;- relative.bias(simulations = Rioja.simulations["angle.count"],
                    variables &lt;- c("N", "G", "V", "d", "dg", "dgeom", "dharm",
                                   "d.0", "dg.0", "dgeom.0", "dharm.0", "h",
                                   "hg", "hgeom", "hharm", "h.0", "hg.0",
                                   "hgeom.0", "hharm.0"),
                    dir.result = dir.result)
  
</code></pre>

<hr>
<h2 id='Rioja.data'>Inventoried Plots Data for a Stand Case Study in La Rioja</h2><span id='topic+Rioja.data'></span>

<h3>Description</h3>

<p>This list includes trees detected with TLS for 16 single scans corresponding to plots located in La Rioja, a region of Spain, in the north of the Iberian Peninsula (first element), as well as those inventoried in the field for these 16 plots (second element). Plot attributes related to stand stratum are also included (third element).
</p>
<p>The elements of the list are as follows:
</p>

<ol>
<li> <p><code>tree.tls</code>: data frame that includes the list of trees detected with <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> for 16 TLS single-scan sampling points. The following
variables are provided for each tree (see <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> &lsquo;Value&rsquo; for more details):
</p>

<table>
<tr>
 <td style="text-align: right;">
[,1] </td><td style="text-align: left;"> id   </td><td style="text-align: left;"> character/numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,2] </td><td style="text-align: left;"> file   </td><td style="text-align: left;"> character</td>
</tr>
<tr>
 <td style="text-align: right;">
[,3] </td><td style="text-align: left;"> tree    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,4] </td><td style="text-align: left;"> x    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,5] </td><td style="text-align: left;"> y   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,6:8] </td><td style="text-align: left;"> phi, phi.left, phi.right     </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,9] </td><td style="text-align: left;"> h.dist   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,10] </td><td style="text-align: left;"> dbh   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,11] </td><td style="text-align: left;"> h   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,12] </td><td style="text-align: left;"> v   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,13:16] </td><td style="text-align: left;"> n.pts, n.pts.red, n.pts.est, n.pts.red.est   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
[,15] </td><td style="text-align: left;"> partial.occlusion   </td><td style="text-align: left;"> numeric</td>
</tr>

</table>

</li>
<li> <p><code>tree.list.field</code>: data frame that includes the list of trees measured in 16 circular fixed area plots of radius 20 m, whose centres coincide with TLS single-scans points. The following variables are provided for each tree:
</p>

<table>
<tr>
 <td style="text-align: right;">
[,1] </td><td style="text-align: left;"> id   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> plot identification (coincident to TLS scans)</td>
</tr>
<tr>
 <td style="text-align: right;">
[,2] </td><td style="text-align: left;"> tree    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> trees numbering</td>
</tr>
<tr>
 <td style="text-align: right;">
[,3] </td><td style="text-align: left;"> Sp    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> specie code according to NFI ()</td>
</tr>
<tr>
 <td style="text-align: right;">
[,4] </td><td style="text-align: left;"> x    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> x cartesian coordinate</td>
</tr>
<tr>
 <td style="text-align: right;">
[,5] </td><td style="text-align: left;"> y   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> 7 cartesian coordinate</td>
</tr>
<tr>
 <td style="text-align: right;">
[,6] </td><td style="text-align: left;"> h.dist   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> horizontal distance (m) from plot center to tree center</td>
</tr>
<tr>
 <td style="text-align: right;">
[,7] </td><td style="text-align: left;"> dbh   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> tree diameter (cm) at breast height (1.3 m)</td>
</tr>
<tr>
 <td style="text-align: right;">
[,8] </td><td style="text-align: left;"> h   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> tree total height (m)</td>
</tr>
<tr>
 <td style="text-align: right;">
[,9] </td><td style="text-align: left;"> dead   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> dead (1) or not (NA)</td>
</tr>
<tr>
 <td style="text-align: right;">
[,10] </td><td style="text-align: left;"> v.user    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> stem volume (m^3) estimated with allometric equations</td>
</tr>
<tr>
 <td style="text-align: right;">
[,11] </td><td style="text-align: left;"> w.user   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> stem biomass (Mg) estimated with allometric equations</td>
</tr>

</table>
</li></ol>


<h3>Usage</h3>

<pre><code class='language-R'>data(Rioja.data)</code></pre>


<h3>Format</h3>

<p>List with 2 data frames containing 604 observations and 17 variables (tree.tls) and 659 observations and 11 variables (tree.field).</p>

<hr>
<h2 id='Rioja.simulations'>Simulated Metrics and Variables for a Stand Case Study in La Rioja</h2><span id='topic+Rioja.simulations'></span>

<h3>Description</h3>

<p>This list contains metrics and variables estimated from field data and TLS data from <code><a href="#topic+Rioja.data">Rioja.data</a></code>.
</p>
<p>The elements on this list correspond to <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo;, as follows:
</p>

<ol>
<li> <p><code>fixed.area</code>: data frame with TLS metrics and variables estimated on the basis of simulated plots in a fixed area plot design with radius increment of 0.1 m (from smallest possible radius to 20 m). The following variables are provided for each pair (plot, radius) (see <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo; for more details):
</p>

<table>
<tr>
 <td style="text-align: right;">
      [,1] </td><td style="text-align: left;"> id   </td><td style="text-align: left;"> character/numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,2] </td><td style="text-align: left;"> radius    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,3:5] </td><td style="text-align: left;"> N, G, V    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,6:9] </td><td style="text-align: left;"> d, dg, dgeom, dharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,10:13] </td><td style="text-align: left;"> h, hg, hgeom, hharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,14:17] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0,  dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,18:21] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,22:27] </td><td style="text-align: left;"> N.tls, N.hn.tls, N.hr.tls, N.hn.cov.tls, N.hr.cov.tls, N.sh.tls  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,28:31] </td><td style="text-align: left;"> num.points, num.points.est, num.points.hom, num.points.hom.est   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,32:37] </td><td style="text-align: left;"> G.tls, G.hn.tls, G.hr.tls, G.hn.cov.tls, G.hr.cov.tls, G.sh.tls  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,38:43] </td><td style="text-align: left;"> V.tls, V.hn.tls, V.hr.tls, V.hn.cov.tls, V.hr.cov.tls, V.sh.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,44:47] </td><td style="text-align: left;"> d.tls, dg.tls, dgeom.tls, dharm.tls   </td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: right;">
      [,48:51] </td><td style="text-align: left;"> h.tls, hg.tls, hgeom.tls, hharm.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,52:55] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0, dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,56:59] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,60:74] </td><td style="text-align: left;"> P01, P05, P10, P20, P25, P30, P40, P50, P60, P70, P75, P80, P90, P95, P99   </td><td style="text-align: left;"> numeric</td>
</tr>

</table>

</li>
<li> <p><code>k.tree</code>: data frame with TLS metrics and variables estimated on the basis of simulated plots under k-tree plot design for incremental values of 1 tree (from 1 to largest number of trees in one plot). The following variables are provided for each pair (plot, k) (see <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo; for more details):
</p>

<table>
<tr>
 <td style="text-align: right;">
      [,1] </td><td style="text-align: left;"> id   </td><td style="text-align: left;"> character/numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,2] </td><td style="text-align: left;"> k    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,3:5] </td><td style="text-align: left;"> N, G, V    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,6:9] </td><td style="text-align: left;"> d, dg, dgeom, dharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,10:13] </td><td style="text-align: left;"> h, hg, hgeom, hharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,14:17] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0,  dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,18:21] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,22:27] </td><td style="text-align: left;"> N.tls, N.hn.tls, N.hr.tls, N.hn.cov.tls, N.hr.cov.tls, N.sh.tls  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,28:31] </td><td style="text-align: left;"> num.points, num.points.est, num.points.hom, num.points.hom.est   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,32:37] </td><td style="text-align: left;"> G.tls, G.hn.tls, G.hr.tls, G.hn.cov.tls, G.hr.cov.tls, G.sh.tls  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,38:43] </td><td style="text-align: left;"> V.tls, V.hn.tls, V.hr.tls, V.hn.cov.tls, V.hr.cov.tls, V.sh.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,44:47] </td><td style="text-align: left;"> d.tls, dg.tls, dgeom.tls, dharm.tls   </td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: right;">
      [,48:51] </td><td style="text-align: left;"> h.tls, hg.tls, hgeom.tls, hharm.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,52:55] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0, dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,56:59] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,60:74] </td><td style="text-align: left;"> P01, P05, P10, P20, P25, P30, P40, P50, P60, P70, P75, P80, P90, P95, P99   </td><td style="text-align: left;"> numeric</td>
</tr>

</table>

</li>
<li> <p><code>angle.count</code>: data frame with TLS metrics and variables estimated on the basis of simulated
plots in an angle-count plot design. They plots are simulated for correlative angle-count plots and incremental values of 0.1 <code class="reqn">{m}^{2}/ha</code> for BAF. The following variables are provided for each pair (plot, BAF) (see <code><a href="#topic+simulations">simulations</a></code> &lsquo;Value&rsquo; for more details):
</p>

<table>
<tr>
 <td style="text-align: right;">
      [,1] </td><td style="text-align: left;"> id   </td><td style="text-align: left;"> character/numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,2] </td><td style="text-align: left;"> BAF    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,3:5] </td><td style="text-align: left;"> N, G, V    </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,6:9] </td><td style="text-align: left;"> d, dg, dgeom, dharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,10:13] </td><td style="text-align: left;"> h, hg, hgeom, hharm   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,14:17] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0,  dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,18:21] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,22:23] </td><td style="text-align: left;"> N.tls, N.pam.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,24:27] </td><td style="text-align: left;"> num.points, num.points.est, num.points.hom, num.points.hom.est   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,28:29] </td><td style="text-align: left;"> G.tls, G.pam.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,30:31] </td><td style="text-align: left;"> V.tls, V.pam.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,32:35] </td><td style="text-align: left;"> d.tls, dg.tls, dgeom.tls, dharm.tls   </td><td style="text-align: left;"> numeric </td>
</tr>
<tr>
 <td style="text-align: right;">
      [,48:51] </td><td style="text-align: left;"> h.tls, hg.tls, hgeom.tls, hharm.tls   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,36:39] </td><td style="text-align: left;"> d.0, dg.0, dgeom.0, dharm.0  </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,40:43] </td><td style="text-align: left;"> h.0, hg.0, hgeom.0, hharm.0   </td><td style="text-align: left;"> numeric</td>
</tr>
<tr>
 <td style="text-align: right;">
      [,44:62] </td><td style="text-align: left;"> P01, P05, P10, P20, P25, P30, P40, P50, P60, P70, P75, P80, P90, P95, P99   </td><td style="text-align: left;"> numeric</td>
</tr>

</table>
</li></ol>


<h3>Usage</h3>

<pre><code class='language-R'>data(Rioja.simulations)</code></pre>


<h3>Format</h3>

<p>List with 3 data frames containing 2224 observations and 74 variables (simulations.fixed.area.plot), 272 observations and 74 variables (simulations.k.tree.plot), and 576 observations and 62 variables (simulations.angle.count.plot).</p>

<hr>
<h2 id='simulations'>
Compute Metrics and Variables for Simulated TLS and Field Plots
</h2><span id='topic+simulations'></span>

<h3>Description</h3>

<p>Computes TLS metrics derived from simulated TLS plots and variables estimated on the basis of simulated field plots. Real TLS and field data from the same
set of plots are required in order to build simulated plots. Three different
plot designs are currently available: circular fixed area, k-tree and angle-count.
During the simulation process, plots with incremental values for radius, k and
BAF are simulated for circular fixed area, k-tree and angle-count designs, respectively,
according to the parameters specified in the <code>plot.parameters</code> argument. For
TLS metrics, different method are included for correcting occlusions generated in
TLS point clouds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulations(tree.tls, tree.ds = NULL, tree.field,
            plot.design = c("fixed.area", "k.tree", "angle.count"),
            plot.parameters = data.frame(radius.max = 25, k.max = 50, BAF.max = 4),
            scan.approach = "single", var.metr = list(tls = NULL, field = NULL),
            v.calc = "parab", dbh.min = 4, h.min = 1.3, max.dist = Inf,
            dir.data = NULL, save.result = TRUE, dir.result = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulations_+3A_tree.tls">tree.tls</code></td>
<td>

<p>Data frame with information about trees detected from TLS point cloud data. The
structure and format must be analogous to output  returned by
<code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> (or <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>) functions. In particular, each row must
correspond to a (plot, tree) pair, and it must include at least the following columns:
</p>

<ul>
<li> <p><code>id</code>, <code>file</code>, <code>tree</code>, <code>x</code>, <code>y</code>,
<code>phi.left</code>, <code>phi.right</code>, <code>horizontal.distance</code>,
<code>dbh</code>, <code>num.points</code>, <code>num.points.hom</code>,
<code>num.points.est</code>, <code>num.points.hom.est</code>,
<code>partial.occlusion</code>: same description and format as indicated for the
same named columns in <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> &lsquo;Value&rsquo;.
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulations_+3A_tree.ds">tree.ds</code></td>
<td>

<p>An optional list containing results arises from the application of distance
sampling methodologies. The structure and format must be analogous to output
returned by <code><a href="#topic+distance.sampling">distance.sampling</a></code> function. In particular, it must
include at least the following elements:
</p>

<ul>
<li> <p><code>tree</code>: data frame with detection probabilities for each tree
using distance sampling methodologies. Each row must correspond
to a (plot, tree) pair, and it must include at least the following columns:
</p>

<ul>
<li> <p><code>id</code>, <code>tree</code>, <code>P.hn</code>, <code>P.hn.cov</code>,
<code>P.hr</code>, <code>P.hr.cov</code>: same description and format as
indicated for same named columns of <code>tree</code> in <code><a href="#topic+distance.sampling">distance.sampling</a></code> &lsquo;Value&rsquo;. In addition, plot
identification and tree numbering included in <code>id</code> and
<code>tree</code> columns must coincide with those included in the same
named columns of <code>tree.tls</code> argument.
</p>
</li></ul>

<p>If this argument is not specified by the user, it will be set to <code>NULL</code> by
default and, as a consequence, the TLS metrics using distance sampling based
correction will not be calculated for a circular fixed area or k-tree plot designs.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulations_+3A_tree.field">tree.field</code></td>
<td>

<p>Data frame with information about trees measured in the field plots. Each
row must correspond to a (plot, tree) pair, and it must include at least the
following columns:
</p>

<ul>
<li> <p><code>id</code>: plot identification encoded as character string or
numeric. Plot identifications must coincide with those
included in <code>id</code> column of the <code>tree.tls</code> argument.
</p>
</li>
<li> <p><code>tree</code>: trees numbering.
</p>
</li>
<li> <p><code>horizontal.distance</code>: horizontal distance (m) from plot
centre to tree centre. Centres of the field plots must coincide with
centres of their corresponding TLS plots.
</p>
</li>
<li> <p><code>dbh</code>: tree diameter (cm) at breast height (1.3 m).
</p>
</li>
<li> <p><code>total.height</code>: tree total height (m).
</p>
</li>
<li> <p><code>dead</code>: integer value indicating for each tree if it is dead
(1) or not (NA).
</p>
</li></ul>

</td></tr>
<tr><td><code id="simulations_+3A_plot.design">plot.design</code></td>
<td>
<p>Vector containing the plot designs considered. By default, all plot designs will be considered (circular fixed area, k-tree and angle-count plots).</p>
</td></tr>
<tr><td><code id="simulations_+3A_plot.parameters">plot.parameters</code></td>
<td>

<p>Optional list containing parameters for circular fixed area, k-tree and angle-count
plot designs. User can set all or any of the following parameters specifying
them as named elements of the list:
</p>

<ul>
<li> <p><code>radius.max</code>: maximum radius (m) allowed for the increasing
sequence of radius values to be used in the simulation process of TLS and
field plots under circular fixed area plot design. If this element is not included
in the argument, circular fixed area plots will not be simulated.
</p>
</li>
<li> <p><code>radius.increment</code>: positive increment (m) for the increasing
sequence of radius values to be used in the simulation process of TLS and
field plots in a circular fixed area plot design. If this element is not included
in the argument, it is set to 0.1 m by default.
</p>
</li>
<li> <p><code>k.tree.max</code>: maximum number of trees (trees) allowed for the
increasing sequence of k values to be used in the simulation process of
TLS and field plots under k-tree plot design. If this element is not
included in the argument, k-tree plots will not be simulated.
</p>
</li>
<li> <p><code>BAF.max</code>: maximum BAF (<code class="reqn">{m}^{2}/ha</code>) allowed for the increasing
sequence of BAF values to be used in the simulation process of TLS and
field plots in an angle-count plot design. If this element is not
included in the argument, angle-count plots will not be simulated.
</p>
</li>
<li> <p><code>BAF.increment</code>: positive increment (<code class="reqn">{m}^{2}/ha</code>) for the increasing
sequence of BAF values to be used in the simulation process of TLS and
field plots under angle-count plot design. If this element is not
included in the argument, it is set to 0.1 <code class="reqn">{m}^{2}/ha</code> by default.
</p>
</li>
<li> <p><code>num.trees</code>: number of dominant trees per ha (tree/ha) to be
used for calculating dominant diameters and heights during the simulation
process of TLS and field plots under all the available plot designs.
Dominant trees are those with the largest diameter at breast height. If
this element is not included in <code>plot.parameters</code> argument, it is
set to 100 trees/ha by default.
</p>
</li></ul>

<p>If this argument is specified by the user, it must include at least one of
the following elements: <code>radius.max</code>, <code>k.tree.max</code> or
<code>BAF.max</code>. If this argument is not specified by the user, it is set to
<code>list(radius.max = 25, k.tree.max = 50, BAF.max = 4)</code> by default and, as a
consequence, the three available plot designs will be simulated.
</p>
</td></tr>
<tr><td><code id="simulations_+3A_scan.approach">scan.approach</code></td>
<td>
<p>Character parameter indicating TLS single-scan (&lsquo;single&rsquo;) or TLS multi-scan approach or SLAM point clouds (&lsquo;multi&rsquo;) approaches. If this argument is not specified by the user, it will be set to &lsquo;multi&rsquo; approach.</p>
</td></tr>
<tr><td><code id="simulations_+3A_var.metr">var.metr</code></td>
<td>
<p>Optional vector containing all the metrics and variables of interest. By default it will be set as NULL and thus, all the metrics and variables available will be generated.</p>
</td></tr>
<tr><td><code id="simulations_+3A_v.calc">v.calc</code></td>
<td>
<p>Optional parameter to calculate volume when is not included in tree.tls input data.</p>
</td></tr>
<tr><td><code id="simulations_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="simulations_+3A_h.min">h.min</code></td>
<td>
<p>Optional minimum <em>h</em> (m) considered for detecting trees. By default it will be set at 1.3 m.</p>
</td></tr>
<tr><td><code id="simulations_+3A_max.dist">max.dist</code></td>
<td>
<p>Optional argument to specify the maximum horizontal distance considered in which trees will be included.</p>
</td></tr>
<tr><td><code id="simulations_+3A_dir.data">dir.data</code></td>
<td>

<p>Optional character string naming the absolute path of the directory where TXT
files containing TLS point clouds are located. <code>.Platform$file.sep</code> must
be used as the path separator in <code>dir.dat</code>, and TXT files in the
directory must have the same description and format as indicated for TXT
files in <code><a href="#topic+normalize">normalize</a></code> &lsquo;Output Files&rsquo;. If this
argument is not specified by the user, it will be set to <code>NULL</code> by default
and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be
assigned to <code>dir.dat</code> during the execution.
</p>
</td></tr>
<tr><td><code id="simulations_+3A_save.result">save.result</code></td>
<td>

<p>Optional logical which indicates wheter or not the output files described in
&lsquo;Output Files&rsquo; section must be saved in <code>dir.result</code>. If
this argument is not specified by the user, it will be set to <code>TRUE</code> by
default and, as a consequence, the output files are saved.
</p>
</td></tr>
<tr><td><code id="simulations_+3A_dir.result">dir.result</code></td>
<td>

<p>Optional character string naming the absolute path of an existing directory
where files described in &lsquo;Output Files&rsquo; section will be saved.
<code>.Platform$file.sep</code> must be used as the path separator in
<code>dir.result</code>. If this argument is not specified by the user, and
<code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and,
as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be
assigned to <code>dir.result</code> during the execution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using real TLS and field data from the same set of plots, this function enables construction
of simulated plots under different plot designs and computation of the
corresponding TLS metrics and estimated variables. The notation used for
variables is based on IUFRO (1959).
</p>
<p>At this stage, three plot designs are available:
</p>

<ul>
<li><p> Circular fixed area plots, simulated only if a <code>radius.max</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li>
<li><p> k-tree plots, simulated only if a <code>k.tree.max</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li>
<li><p> Angle-count plots, simulated only if a <code>BAF.max</code> value is
specified in the <code>plot.parameters</code> argument.
</p>
</li></ul>

<p>For each real plot, a simulation process is run under each of the plot designs
specified by means of elements of the <code>plot.parameters</code> argument. Although there
are some minor differences depending on the plot design, the rough outline of
the simulation process is similar for all, and it consists of the
following main steps:
</p>

<ol>
<li><p> Define an increasing sequence of the plot design parameter (radius,
k or BAF) according to the maximum value and, if applicable, the positive
increment set in <code>plot.parameters</code> argument.
</p>
</li>
<li><p> Build simulated plots for each parameter value in the previous
sequence based on either TLS or field data.
</p>
</li>
<li><p> Compute either TLS metrics or variables estimated on the basis of
simulated plots for each parameter value (see &lsquo;Value&rsquo; section for
details). For the simulated TLS plots, note that in
addition to the counterparts of variables computed for the simulated field
plots, the function also computes the following:
</p>

<ul>
<li><p> Metrics related to the number of points belonging to normal tree
sections.
</p>
</li>
<li><p> Metrics with occlusion corrections based on the following:
</p>

<ul>
<li><p> Distance sampling methodologies (Astrup et al., 2014) for
circular fixed area and k-tree plot designs, if the <code>distance.sampling</code>
argument is not <code>NULL</code>.
</p>
</li>
<li><p> Correction of the shadowing effect (Seidel &amp; Ammer, 2014) for
circular fixed area and k-tree plot designs.
</p>
</li>
<li><p> Gap probability attenuation with distance to TLS (Strahler et
al., 2008; Lovell et al., 2011) for angle-count plot design.
</p>
</li></ul>

</li>
<li><p> Height percentiles derived from z coordinates of TLS point clouds
relative to ground level.
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>List with field estimates and TLS metrics for plot designs considered. It will contain one element per plot design considered (fixed.area.plot, k.tree.plot and angle.count.plot)
</p>
<table>
<tr><td><code>fixed.area.plot</code></td>
<td>

<p>If no value for <code>radius.max</code> is specified in the <code>plot.parameters</code>
argument, <code>NULL</code>; otherwise, data frame with TLS metrics and variables will be estiamted on the basis of simulated plots in a circular fixed area plot design. Each row will correspond to a (plot, radius) pair, and the
following columns will be included:
</p>
<p>Plot identification and radius:
</p>

<ul>
<li> <p><code>id</code>: plot identification encoded as a character string or
numeric. It will coincide with those included in the <code>id</code>
column of <code>tree.tls</code>, <code>tree.field</code> or, if applicable,
<code>distance.sampling</code> arguments.
</p>
</li>
<li> <p><code>radius</code>: radius (m) of the simulated plot.
</p>
</li></ul>

<p>Variables estimated on the basis of simulated field plots:
</p>

<ul>
<li> <p><code>N</code>: stand density (trees/ha).
</p>
</li>
<li> <p><code>G</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>).
</p>
</li>
<li> <p><code>V</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>).
</p>
</li>
<li> <p><code>d</code>, <code>dg</code>, <code>dgeom</code>, <code>dharm</code>: mean tree
diameters (cm) at breast height (1.3 m), calculated from the arithmetic mean, quadratic
mean, geometric mean and harmonic mean, respectively.
</p>
</li>
<li> <p><code>h</code>, <code>hg</code>, <code>hgeom</code>, <code>hharm</code>: mean tree
heights (m), calculated from the arithmetic mean, quadratic mean, geometric mean and
harmonic mean, respectively.
</p>
</li>
<li> <p><code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>, <code>dharm.0</code>: dominant
mean tree diameters (cm) at breast height (1.3 m), calcualted from the arithmetic mean,
quadratic mean, geometric mean and harmonic mean, respectively.
</p>
</li>
<li> <p><code>h.0</code>, <code>hg.0</code>, <code>hgeom.0</code>, <code>hharm.0</code>: dominant
mean tree heights (m), calculated from the arithmetic mean, quadratic mean, geometric
mean and harmonic mean, respectively.
</p>
</li></ul>

<p>TLS variables derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>: stand density (trees/ha) without occlusion
corrections.
</p>
</li>
<li> <p><code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>, <code>N.hr.cov</code>: stand
density (trees/ha) with occlusion corrections based on distance sampling
methodologies. These columns will be missing if the <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>N.sh</code>: stand density (trees/ha) with correction of the
shadowing effect.
</p>
</li>
<li> <p><code>G.tls</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) without occlusion
corrections.
</p>
</li>
<li> <p><code>G.hn</code>, <code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>: stand
basal area (<code class="reqn">{m}^{2}/ha</code>) with occlusion corrections based on distance sampling
methodologies. These columns will be missing if the <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>G.sh</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) with correction of the
shadowing effect.
</p>
</li>
<li> <p><code>V.tls</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>) without occlusion corrections.
</p>
</li>
<li> <p><code>V.hn</code>, <code>V.hr</code>, <code>V.hn.cov</code>, <code>V.hr.cov</code>: stand
volume (<code class="reqn">{m}^{3}/ha</code>) with occlusion corrections based on distance sampling
methodologies. These  columns will be missing if the <code>distance.sampling</code>
argument is <code>NULL</code>.
</p>
</li>
<li> <p><code>V.sh</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>) with correction of the
shadowing effect.
</p>
</li>
<li> <p><code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>, <code>dharm.tls</code>:
mean tree diameters (cm) at breast height (1.3 m), calculated from the arithmetic mean,
quadratic mean geometric mean, and harmonic mean, respectively.
</p>
</li>
<li> <p><code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>, <code>hharm.tls</code>:
mean tree heights (m), calculated from the arithmetic mean, quadratic mean, geometric
mean and harmonic mean, respectively.
</p>
</li>
<li> <p><code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>,
<code>dharm.0.tls</code>: dominant mean tree diameters (cm) at breast height
(1.3 m), calculated from the arithmetic mean, quadratic mean, geometric mean and
harmonic mean, respectively.
</p>
</li>
<li> <p><code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>,
<code>hharm.0.tls</code>: dominant mean tree heights (m), calculated from the arithmetic
mean, quadratic mean, geometric mean and harmonic mean, respectively.
</p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>num.points</code>, <code>num.points.est</code>, <code>num.points.hom</code>,
<code>num.points.hom.est</code>: number of points and estimated number of
points (points) belonging to trees with normal sections (+/- 5 cm) in the
original point cloud (<code>num.points</code> and <code>num.points.est</code>,
respectively); and number of points and estimated number of points
(points) belonging to trees normal sections (+/- 5 cm) in the reduced
point cloud (<code>num.points.hom</code> and <code>num.points.hom.est</code>,
respectively).
</p>
</li>
<li> <p><code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>,
<code>P30</code>, <code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>,
<code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: height percentiles
derived from z coordinates of TLS point clouds relative to ground level.
</p>
</li></ul>

</td></tr>
<tr><td><code>k.tree.plot</code></td>
<td>

<p>If no value for <code>k.tree.max</code> is specified in the <code>plot.parameters</code>
argument, <code>NULL</code>; otherwise the data frame with TLS metrics and estimations
of variables will be based on simulated plots in the k-tree plot design. Each of row will correspond to a (plot, k) pair, and the following
columns will be included:
</p>
<p>Plot identification and k:
</p>

<ul>
<li> <p><code>id</code>: plot identification encoded as character string or
numeric. The <code>id</code> will coincide with those included in the <code>id</code>
column of <code>tree.tls</code>, <code>tree.field</code> or, if applicable,
<code>distance.sampling</code> arguments.
</p>
</li>
<li> <p><code>k</code>: number of trees (trees) in the simulated plot.
</p>
</li></ul>

<p>Estimated variables based on simulated field plots:
</p>

<ul>
<li> <p><code>N</code>, <code>G</code>, <code>V</code>, <code>d</code>, <code>dg</code>, <code>dgeom</code>,
<code>dharm</code>, <code>h</code>, <code>hg</code>, <code>hgeom</code>, <code>hharm</code>,
<code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>, <br /> <code>dharm.0</code>, <code>h.0</code>,
<code>hg.0</code>, <code>hgeom.0</code>, <code>hharm.0</code>: same description and format
as indicated in the <code>fixed.area.plot</code> element.
</p>
</li></ul>

<p>TLS variables derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>, <code>N.hn</code>, <code>N.hr</code>, <code>N.hn.cov</code>, <code>N.hr.cov</code>, <code>N.sh</code>, <br />
<code>G.tls</code>, <code>G.hn</code>, <code>G.hr</code>, <code>G.hn.cov</code>, <code>G.hr.cov</code>, <code>G.sh</code>, <br />
<code>V.tls</code>, <code>V.hn</code>, <code>V.hr</code>, <code>V.hn.cov</code>, <code>V.hr.cov</code>, <code>V.sh</code>, <br />
<code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>, <code>dharm.tls</code>, <br />
<code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>, <code>hharm.tls</code>, <br />
<code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <br />
<code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <code>hharm.0.tls</code></p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>num.points</code>, <code>num.points.est</code>, <code>num.points.hom</code>, <code>num.points.hom.est</code>, <br />
<code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>, <code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>, <code>P80</code>, <code>P90</code>, <code>P95</code>, <code>P99</code>: same description and format as indicated in
<code>fixed.area.plot</code> element.</p>
</li></ul>
</td></tr>
<tr><td><code>angle.count.plot</code></td>
<td>

<p>If no value for <code>BAF.max</code> is specified in the <code>plot.parameters</code>
argument, <code>NULL</code>; otherwise the data frame will include TLS metrics and estimated
variables based on simulated plots in the angle-count plot design. Each
row will correspond to a (plot, BAF) pair, and the
following columns will be included:
</p>
<p>Plot identification and BAF:
</p>

<ul>
<li> <p><code>id</code>: plot identification encoded as character string or
numeric. The <code>id</code> will coincide with those included in the <code>id</code>
column of <code>tree.tls</code> and <code>tree.field</code>.
</p>
</li>
<li> <p><code>BAF</code>: BAF (<code class="reqn">{m}^{2}/ha</code>) of the simulated plot.
</p>
</li></ul>

<p>Estimated variables based on simulated field plots:
</p>

<ul>
<li> <p><code>N</code>, <code>G</code>, <code>V</code>, <code>d</code>, <code>dg</code>, <code>dgeom</code>,
<code>dharm</code>, <code>h</code>, <code>hg</code>, <code>hgeom</code>, <code>hharm</code>,
<code>d.0</code>, <code>dg.0</code>, <code>dgeom.0</code>, <br /> <code>dharm.0</code>, <code>h.0</code>,
<code>hg.0</code>, <code>hgeom.0</code>, <code>hharm.0</code>: same description and format
as indicated in the <code>fixed.area.plot</code> element.
</p>
</li></ul>

<p>TLS variables derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>N.tls</code>: same description and format as indicated in the
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>N.pam</code>: stand density (trees/ha) with occlusion correction
based on gap probability attenuation with distance to TLS.
</p>
</li>
<li> <p><code>G.tls</code>: same description and format as indicated in
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>G.pam</code>: stand basal area (<code class="reqn">{m}^{2}/ha</code>) with occlusion correction
based on gap probability attenuation with distance to TLS.
</p>
</li>
<li> <p><code>V.tls</code>: same description and format as indicated in
<code>fixed.area.plot</code> element.
</p>
</li>
<li> <p><code>V.pam</code>: stand volume (<code class="reqn">{m}^{3}/ha</code>)with occlusion correction based
on gap probability attenuation with distance to TLS.
</p>
</li>
<li> <p><code>d.tls</code>, <code>dg.tls</code>, <code>dgeom.tls</code>, <code>dharm.tls</code>, <br />
<code>h.tls</code>, <code>hg.tls</code>, <code>hgeom.tls</code>, <code>hharm.tls</code>, <br />
<code>d.0.tls</code>, <code>dg.0.tls</code>, <code>dgeom.0.tls</code>, <code>dharm.0.tls</code>, <br />
<code>h.0.tls</code>, <code>hg.0.tls</code>, <code>hgeom.0.tls</code>, <code>hharm.0.tls</code>
</p>
</li></ul>

<p>TLS metrics derived from simulated TLS plots:
</p>

<ul>
<li> <p><code>num.points</code>, <code>num.points.est</code>, <code>num.points.hom</code>,
<code>num.points.hom.est</code>, <br />
<code>P01</code>, <code>P05</code>, <code>P10</code>, <code>P20</code>, <code>P25</code>, <code>P30</code>,
<code>P40</code>, <code>P50</code>, <code>P60</code>, <code>P70</code>, <code>P75</code>, <code>P80</code>,
<code>P90</code>, <code>P95</code>, <code>P99</code>: same description and format as
indicated in <code>fixed.area.plot</code> element.
</p>
</li></ul>

</td></tr>
</table>


<h3>Output Files</h3>

<p>At the end of the simulation process, if the <code>save.result</code> argument is
<code>TRUE</code>, the function will print all the elements described in
&lsquo;Value&rsquo; section and which are different from <code>NULL</code> to files. Data frames are
written without row names in <code>dir.result</code> directory using
the <code><a href="utils.html#topic+write.csv">write.csv</a></code> function from the <span class="pkg">utils</span> package. The pattern used
for naming these files is &lsquo;<span class="file">simulations.&lt;plot design&gt;.csv</span>&rsquo;, where
&lsquo;<span class="file">&lt;plot design&gt;</span>&rsquo; is equal to &ldquo;<code>fixed.area.plot</code>&rdquo;,
&ldquo;<code>k.tree.plot</code>&rdquo; or &ldquo;<code>angle.count.plot</code>&rdquo; according to
plot design.
</p>


<h3>Note</h3>

<p>The simulation process implemented in this function is computationally intensive.
Although the function currently uses the <code><a href="vroom.html#topic+vroom">vroom</a></code> function from the <a href="https://CRAN.R-project.org/package=vroom"><span class="pkg">vroom</span></a> package for reading large files and contains fast implementations of
several critical calculations (C++ via <a href="https://CRAN.R-project.org/package=Rcpp"><span class="pkg">Rcpp</span></a> package), long
computation times may be required when a large number of plots are considered,
number of points in TLS point clouds are very high, or the radius, k
or BAF sequences used in the simulation process are very long.
</p>
<p>Using reduced point clouds (according to point cropping process implemented in the
<code><a href="#topic+normalize">normalize</a></code> function), rather than original ones, may be
recommended in order to cut down on computing time. Another possibility would
be to specify large increments for radius
and BAF, and/or low maximum values for radius, number of trees and BAF in the <code>plot.parameters</code> argument. This
would make the function more efficient, though there may be a notable
loss of detail in the results generated.
</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero and
Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Astrup, R., Ducey, M. J., Granhus, A., Ritter, T., &amp; von Lüpke, N. (2014).
Approaches for estimating stand level volume using terrestrial laser scanning
in a single-scan mode. <em>Canadian Journal of Forest Research</em>,
<b>44(6)</b>, 666-676. <a href="https://doi.org/10.1139/cjfr-2013-0535">doi:10.1139/cjfr-2013-0535</a>
</p>
<p>IUFRO (1959). <em>Standarization of symbols in forest mensuration</em>. IUFRO,
Wien, 32 pp.
</p>
<p>Lovell, J. L., Jupp, D. L. B., Newnham, G. J., &amp; Culvenor, D. S. (2011).
Measuring tree stem diameters using intensity profiles from ground-based
scanning lidar from a fixed viewpoint. <em>ISPRS Journal of Photogrammetry
and Remote Sensing</em>, <b>66(1)</b>, 46-55. <a href="https://doi.org/10.1016/j.isprsjprs.2010.08.006">doi:10.1016/j.isprsjprs.2010.08.006</a>
</p>
<p>Seidel, D., &amp; Ammer, C. (2014). Efficient measurements of basal area in short
rotation forests based on terrestrial laser scanning under special
consideration of shadowing. <em>iForest-Biogeosciences and Forestry</em>,
<b>7(4)</b>, 227. <a href="https://doi.org/10.3832/ifor1084-007">doi:10.3832/ifor1084-007</a>
</p>
<p>Strahler, A. H., Jupp, D. L. B., Woodcock, C. E., Schaaf, C. B., Yao, T., Zhao,
F., Yang, X., Lovell, J., Culvenor, D., Newnham, G., Ni-Miester, W., &amp;
Boykin-Morris, W. (2008). Retrieval of forest structural parameters using a
ground-based lidar instrument (Echidna®). <em>Canadian Journal of Remote
Sensing</em>, <b>34(sup2)</b>, S426-S440. <a href="https://doi.org/10.5589/m08-046">doi:10.5589/m08-046</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>, <code><a href="#topic+distance.sampling">distance.sampling</a></code>,
<code><a href="#topic+normalize">normalize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load information of trees detected from TLS point clouds data corresponding to
# plots 1 and 2 from Rioja data set

data("Rioja.data")
example.tls &lt;- subset(Rioja.data$tree.tls, id &lt; 3)

# Compute detection probabilities using distance sampling methods

example.ds &lt;- distance.sampling(example.tls)

# Load information of trees measured in field plots corresponding to plot 1 and 2
# from Rioja data set

example.field &lt;- subset(Rioja.data$tree.field, id &lt; 3)

# Establish directory where TXT file containing TLS point cloud corresponding to
# plot 1 from Rioja data set is located. For instance, current working directory

dir.data &lt;- getwd()

# Download example of TXT file corresponding to plots 1 and 2 from Rioja data set

download.file(url = "https://www.dropbox.com/s/w4fgcyezr2olj9m/Rioja_1.txt?dl=1",
              destfile = file.path(dir.data, "1.txt"), mode = "wb")

download.file(url = "https://www.dropbox.com/s/sghmw3zud424s11/Rioja_2.txt?dl=1",
              destfile = file.path(dir.data, "2.txt"), mode = "wb")

# Establish directory where simulation results corresponding to plots 1 and 2
# from Rioja data set will be saved. For instance, current working directory

dir.result &lt;- getwd()

# Compute metrics and variables for simulated TLS and field plots corresponding
# to plots 1 and 2 from Rioja data set
# Without occlusion correction based on distance sampling methods

sim &lt;- simulations(tree.tls = example.tls, tree.field = example.field,
                   plot.parameters = data.frame(radius.max = 10, k.max = 20,
                                                BAF.max = 2),
                   dir.data = dir.data, dir.result = dir.result)



</code></pre>

<hr>
<h2 id='tree.detection.multi.scan'>Tree-Level Variables Estimation</h2><span id='topic+tree.detection.multi.scan'></span>

<h3>Description</h3>

<p>Detects trees from point clouds corresponding to TLS multi-scan approaches and SLAM devices. For each tree detected, the function calculates the central coordinates and estimates the diameter at 1.3 m above ground level (which is known as <em>dbh</em>, diameter at breast height) and classifies it as fully visible or partially occluded. Finally, the function obtains the number of points belonging to normal sections of trees (those corresponding to <em>dbh</em> +/- 5 cm) and estimates them for both original and reduced (with random selection process) point clouds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.detection.multi.scan(data, single.tree = NULL,
                          dbh.min = 4, dbh.max = 200, h.min = 1.3,
                          ncr.threshold = 0.1,
                          tls.precision = NULL,
                          density.reduction = 2,
                          stem.section = c(0.7, 3.5), stem.range = NULL, breaks = NULL,
                          slice = 0.1, understory = NULL, bark.roughness = 1,
                          den.type = 1, d.top = NULL,
                          plot.attributes = NULL, plot = TRUE,
                          save.result = TRUE, dir.result = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.detection.multi.scan_+3A_data">data</code></td>
<td>
<p>Data frame with same description and format as indicated for <code><a href="#topic+normalize">normalize</a></code> &lsquo;Value&rsquo;.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_single.tree">single.tree</code></td>
<td>
<p>Optional argument to indicate if there is only one tree.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_dbh.max">dbh.max</code></td>
<td>
<p>Optional maximum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 200 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_h.min">h.min</code></td>
<td>
<p>Optional minimum <em>h</em> (m) considered for detecting trees. By default it will be set at 1.3 m.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_ncr.threshold">ncr.threshold</code></td>
<td>
<p>Local surface variation (also known as normal change rate, NCR). By default it will be set as 0.1. For better understanding of this argument see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_tls.precision">tls.precision</code></td>
<td>
<p>Average point cloud precision in cm.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_density.reduction">density.reduction</code></td>
<td>
<p>Density reduction intensity.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_stem.section">stem.section</code></td>
<td>
<p>Section free of noise (shurb, branches, etc.) considered to detect trees. If not specified, an automatic internal algorithm will be applied (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_stem.range">stem.range</code></td>
<td>
<p>Section considered to estimate straightness tree attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_breaks">breaks</code></td>
<td>
<p>Height above ground level (m) of slices considered for detecting trees. By default it will be considered all possible sections from 0.4 m to maximum height by 0.3 m intervals (+/- 5 cm).</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_slice">slice</code></td>
<td>
<p>Slice width considered for detecting trees. By default it will be considered as 0.1 m.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_understory">understory</code></td>
<td>
<p>Optional argument to indicate if there is dense understory vegetation.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_bark.roughness">bark.roughness</code></td>
<td>
<p>Bark roughness established in 3 degrees (1 &lt; 2 &lt; 3). By default it will be considered as 1.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_den.type">den.type</code></td>
<td>
<p>Numeric argument indicating the dendrometic type used to estimate volumen when there are not sections enough to fit a taper equation. Dendrometrics types available are the following: cylinder = 0, paraboloid = 1 (by default), cone = 2 and neiloid = 3.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_d.top">d.top</code></td>
<td>
<p>Top stem diameter (cm) considered to estimate commercial timber volume.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_plot.attributes">plot.attributes</code></td>
<td>
<p>Data frame with attributes at plot level. It must contain a column named <code>id</code> (character string or numeric value) with encoding coinciding with that used in <code>id</code> argument of <code><a href="#topic+normalize">normalize</a></code> for identifying plots. If there are strata, another column named &lsquo;stratum&rsquo; (numeric) will be required for other functionalities of <span class="pkg">FORTLS</span> (see, for instance, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code> or <code><a href="#topic+metrics.variables">metrics.variables</a></code>). If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the function will not add these possible plot attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_plot">plot</code></td>
<td>
<p>Optional logical which indicates whether or not the normalized point cloud will be plot. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the normalized point cloud will be plot.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_save.result">save.result</code></td>
<td>
<p>Optional logical which indicates whether or not the output files described in &lsquo;Output Files&rsquo; section should be saved in <code>dir.result</code>. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as a consequence, the output files will be saved.</p>
</td></tr>
<tr><td><code id="tree.detection.multi.scan_+3A_dir.result">dir.result</code></td>
<td>
<p>Optional character string naming the absolute path of an existing directory where the files described in &lsquo;Output Files&rsquo; section will be saved. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.result</code>. If this argument is not specified by the user, and the <code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.</p>
</td></tr></table>


<h3>Details</h3>

<p>Slices determined by <code>breaks</code> argument are clustered using the DBSCAN algorithm (Ester et al., 1996) on the horizontal plane according to Cartesian coordinates (x, y). Before and after this process, several algorithms are used to remove noisy points and apply classification criteria to select the clusters of trees.
</p>
<p><em>dbh</em> is directly estimated for the section of 1.3 m above ground level, and estimated from other sections using <em>dbh</em>~<em>breaks</em> linear regression. Finally, the mean value of all estimates is provided in &lsquo;Value&rsquo; as the <em>dbh</em> of the tree section.
</p>
<p>Volume is estimated modelling stem profile as a paraboloid and calculating the volumes of revolution; where trees <em>dbh</em> are estimated in <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, and total heights are estimated as percentile 99 of z coordinate of points delimited by Voronoi polygons.
</p>
<p>The number of points corresponding to a normal section (+/- 5 cm) is estimated in proportion to <em>dbh</em>, using the average number of points per radius unit as reference. In this respect, only tree sections fully visible at 1.3 m above ground level will be considered for estimating the average number of points.
</p>
<p>Local surface variation (also known as normal change rate ,NCR), is a quantitative measure of curvature feature (Pauly et al., 2002). This is useful for distinguishing points belonging to fine branches and foliage (e.g. leaves, shrubs) and stem points (e.g. Jin et al., 2016; Zhang et al., 2019). Just as we considered 5 cm as suitable for calculating local surface variation for the stem separation in forests, according to other authors (Ma et al., 2015; Xia et al., 2015), we also established the NCR threshold as 0.1, according to Zhang et al. (2019). However, this argument (<code>ncr.threshold</code>) may be modified in order to use more appropriate values.</p>


<h3>Value</h3>

<p>Data frame with the following columns for every tree detected (each row corresponds to one tree detected):
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Optional plot identification encoded as a character string or numeric. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the plot will be encoded as 1.</p>
</td></tr>
<tr><td><code>file</code></td>
<td>
<p>Optional file name identification encoded as character string or numeric. If it is null, the file will be encoded as <code>id</code> by default.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>tree numbering</p>
</td></tr>
<tr><td><code>Coordinates</code></td>
<td>

<p>Cartesian (according to <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">https://en.wikipedia.org/wiki/Cartesian_coordinate_system</a> notation):</p>
</td></tr>
</table>

<ul>
<li> <p><code>x</code>: distance on x axis (m) of tree centre.
</p>
</li>
<li> <p><code>y</code>: distance on y axis (m) of tree centre.</p>
</li></ul>

<p>Azimuthal angles:
</p>

<ul>
<li> <p><code>phi</code>: angular coordinate (rad) of tree centre.</p>
</li></ul>

<table>
<tr><td><code>h.dist</code></td>
<td>
<p>horizontal distance (m) from plot centre to tree centre.</p>
</td></tr>
<tr><td><code>\emph{dbh}</code></td>
<td>
<p>estimated tree diameter (cm) at breast height (1.3 m).</p>
</td></tr>
<tr><td><code>\emph{h}</code></td>
<td>
<p>estimated tree total height (m).</p>
</td></tr>
<tr><td><code>\emph{h.com}</code></td>
<td>
<p>estimated commercial tree height (m) according to the top diameter defined in the argument <code>d.top</code>.</p>
</td></tr>
<tr><td><code>\emph{v}</code></td>
<td>
<p>estimated tree stem volume (m^3).</p>
</td></tr>
<tr><td><code>\emph{v.com}</code></td>
<td>
<p>estimated commercial tree stem volume (m^3) according to the top diameter defined in the argument <code>d.top</code>.</p>
</td></tr>
<tr><td><code>n.pts</code></td>
<td>
<p>number of points corresponding to a normal section (+/- 5 cm) in the original point cloud.</p>
</td></tr>
<tr><td><code>n.pts.red</code></td>
<td>
<p>number of points corresponding to a normal section (+/- 5 cm) in the point cloud reduced by the point cropping process.</p>
</td></tr>
<tr><td><code>n.pts.est</code></td>
<td>
<p>number of points estimated for a normal section (+/- 5 cm) in the original point cloud.</p>
</td></tr>
<tr><td><code>n.pts.red.est</code></td>
<td>
<p>number of points estimated for a normal section (+/- 5 cm) in the point cloud reduced by the point cropping process.</p>
</td></tr>
<tr><td><code>partial.occlusion</code></td>
<td>
<p>yes (1) or no (0)</p>
</td></tr></table>


<h3>Output Files</h3>

<p>At the end of the tree detection process, if the <code>save.result</code> argument is <code>TRUE</code>, the function will save the data frame described in &lsquo;Value&rsquo; as a CSV file named &lsquo;tree.tls.csv&rsquo;. The data frame will be written without row names in the <code>dir.result</code> directory by using <code><a href="utils.html#topic+write.csv">write.csv</a></code> function from the <span class="pkg">utils</span> package.</p>


<h3>Note</h3>

<p>Although <code>tree.detection.multi.scan</code> also works with reduced point clouds, thus reducing the computing time, use of the original point cloud is recommended in order to detect more trees. This will also depend on forest conditions, especially those related to visibility. The more distant the trees are, the lower the density of points will be, and using reduced point clouds will therefore complicate detection of the most distant trees.
</p>
<p>Note that <code>dbh.min</code> and <code>dbh.max</code> are important for avoiding outlier values when inventory data are used for reference purposes. Otherwise, knowledge about the autoecology of species could be used for filtering anomalous values of <em>dbh</em>.
</p>
<p>The argument <code>breaks = 1.3</code> could be sufficient for detecting trees visible at <em>dbh</em>, involving lower computational cost. However, those trees not detected at <em>dbh</em>, may be estimated from lower and/or higher sections. Considering the three default sections in the argument <code>breaks = c(1.0, 1.3, 1.6)</code> maintains a good balance in the case study of this package.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero
and Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Ester, M., Kriegel, H. P., Sander, J., &amp; Xu, X. (1996). A density-based algorithm for discovering clusters in large spatial databases with noise. In Kdd (Vol. 96, No. 34, pp. 226-231).
</p>
<p>Jin, S., Tamura, M., &amp; Susaki, J. (2016). A new approach to retrieve leaf normal distribution using terrestrial laser scanners. J. <em>Journal of Forestry Research</em>, <b>27(3)</b>, 631-638. <a href="https://doi.org/10.1007/s11676-015-0204-z">doi:10.1007/s11676-015-0204-z</a>
</p>
<p>Ma, L., Zheng, G., Eitel, J. U., Moskal, L. M., He, W., &amp; Huang, H. (2015). Improved salient feature-based approach for automatically separating photosynthetic and nonphotosynthetic components within terrestrial lidar point cloud data of forest canopies. <em>IEEE Transactions Geoscience Remote Sensing</em>, <b>54(2)</b>, 679-696. <a href="https://doi.org/10.1109/TGRS.2015.2459716">doi:10.1109/TGRS.2015.2459716</a>
</p>
<p>Pauly, M., Gross, M., &amp; Kobbelt, L. P., (2002). Efficient simplification of point-sampled surfaces. In IEEE Conference on Visualization. (pp. 163-170). Boston, USA. <a href="https://doi.org/10.1109/VISUAL.2002.1183771">doi:10.1109/VISUAL.2002.1183771</a>
</p>
<p>Xia, S., Wang, C., Pan, F., Xi, X., Zeng, H., &amp; Liu, H. (2015). Detecting stems in dense and homogeneous forest using single-scan TLS. <em>Forests</em>. <b>6(11)</b>, 3923-3945. <a href="https://doi.org/10.3390/f6113923">doi:10.3390/f6113923</a>
</p>
<p>Zhang, W., Wan, P., Wang, T., Cai, S., Chen, Y., Jin, X., &amp; Yan, G. (2019). A novel approach for the detection of standing tree stems from plot-level terrestrial laser scanning data. <em>Remote Sens</em>. <b>11(2)</b>, 211. <a href="https://doi.org/10.3390/rs11020211">doi:10.3390/rs11020211</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>, <code><a href="#topic+distance.sampling">distance.sampling</a></code>, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code>, <code><a href="#topic+simulations">simulations</a></code>, <code><a href="#topic+metrics.variables">metrics.variables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Establishment of working directories (optional)
# By default here we propose the current working directory of the R process

dir.data &lt;- getwd()
dir.result &lt;- getwd()


# Loading example data of TLS multi-scan approach point cloud (LAZ file) to dir.data

download.file(
"www.dropbox.com/scl/fi/es5pfj87wj0g6y8414dpo/PiceaAbies.laz?rlkey=ayt21mbndc6i6fyiz2e7z6oap&amp;dl=1",
              destfile = file.path(dir.data, "PiceaAbies.laz"),
              mode = "wb")

# Normalizing the whole point cloud data without considering arguments

pcd &lt;- normalize(las = "PiceaAbies.laz",

                 id = "PiceaAbies",

                 scan.approach = "multi",

                 dir.data = dir.data, dir.result = dir.result)


# Tree detection without considering arguments

tree.tls &lt;- tree.detection.multi.scan(data = pcd,

                                      slice = 0.2,

                                      breaks = c(1, 1.3, 1.6),

                                      dir.result = dir.result)

  

</code></pre>

<hr>
<h2 id='tree.detection.several.plots'>Tree-Level Variables Estimation for Several Plots</h2><span id='topic+tree.detection.several.plots'></span>

<h3>Description</h3>

<p>This function integrates both, the <code><a href="#topic+normalize">normalize</a></code> and <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> or <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> functions, generating the same &lsquo;Output Files&rsquo; as indicated for these, and it returs the same &lsquo;Value&rsquo; as described for <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> or <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> respectively. However, this function is designed for working with several plots, producing a list of all scans considered automatically from LAS files.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.detection.several.plots(las.list, id.list = NULL, file = NULL,

                             scan.approach = "single",
                             pcd.red = NULL, normalized = NULL,
                             center.coord = NULL,
                             x.side = NULL, y.side = NULL,
                             max.dist = NULL, min.height = NULL, max.height = 50,
                             algorithm.dtm = "knnidw", res.dtm = 0.2,
                             csf = list(cloth_resolution = 0.5),
                             intensity = NULL, RGB = NULL,

                             single.tree = NULL,
                             dbh.min = 4, dbh.max = 200, h.min = 1.3,
                             ncr.threshold = 0.1,
                             tls.resolution = NULL, tls.precision = NULL,
                             density.reduction = 2,
                             stem.section = c(0.7, 3.5), stem.range = NULL, breaks = NULL,
                             slice = 0.1, understory = NULL, bark.roughness = 1,
                             den.type = 1, d.top = NULL,

                             plot.attributes = NULL, plot = NULL,

                             dir.data = NULL, save.result = TRUE, dir.result = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.detection.several.plots_+3A_las.list">las.list</code></td>
<td>
<p>Character vector containing the names of all LAS files for analysis and belonging to TLS point cloud, including .las extension (see &lsquo;Examples&rsquo;)</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_id.list">id.list</code></td>
<td>
<p>Optional vector with plots identification encoded as character string or numeric. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the plots will be encoded with correlative numbers from 1 to n plots.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_file">file</code></td>
<td>
<p>Optional vector containing files name identification encoded as character string or numeric value. If it is null, file will be encoded as <code>id</code> by default.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_scan.approach">scan.approach</code></td>
<td>
<p>Character parameter indicating TLS single-scan (&lsquo;single&rsquo;) or TLS multi-scan approach or SLAM point clouds (&lsquo;multi&rsquo;) approaches. If this argument is not specified by the user, it will be set to &lsquo;multi&rsquo; approach.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_pcd.red">pcd.red</code></td>
<td>
<p>Optional argument to indicate if point cloud density must be reduced to detect trees.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_normalized">normalized</code></td>
<td>
<p>Optional argument to establish as <code>TRUE</code> when point cloud is already normalized.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_center.coord">center.coord</code></td>
<td>
<p>Planimetric x and y center coordinate of the plots. They has to be introduced as a data frame object with the following columns names: 'id',  'x' and 'y'. They represent plot id, and center coordinates respectively.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_x.side">x.side</code></td>
<td>
<p>x-side (m) of the plot when the plot is square or rectangular.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_y.side">y.side</code></td>
<td>
<p>y-side (m) of the plot when the plot is square or rectangular.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_max.dist">max.dist</code></td>
<td>
<p>Optional maximum horizontal distance (m) considered from the plot centre. All points farther than <code>max.dist</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>max.dist</code> representing the farthest point.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_min.height">min.height</code></td>
<td>
<p>Optional minimum height (m) considered from ground level. All points below <code>min.height</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>min.height</code> representing the lowest point.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_max.height">max.height</code></td>
<td>
<p>Optional maximum height (m) considered from ground level. All points above <code>max.height</code> will be discarded after the normalization process. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, all points will be used in processing, with <code>max.height</code> representing the highest point.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_algorithm.dtm">algorithm.dtm</code></td>
<td>
<p>Algorithm used to generate the digital terrain model (DTM) from the TLS point cloud. There are two posible options based on spatial interpolation: &lsquo;tin&rsquo; and &lsquo;knnidw&rsquo; (see &lsquo;Details&rsquo;). If this argument is not specified by the user, it will be set to &lsquo;knnidw&rsquo; algorithm.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_res.dtm">res.dtm</code></td>
<td>
<p>Numeric parameter. Resolution of the DTM generated to normalize point cloud (see &lsquo;Details&rsquo;). If this argument is not specified by the user, it will be set to 0.2 m.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_csf">csf</code></td>
<td>
<p>List containing parameters of CSF algorithm:</p>
</td></tr>
</table>

<ul>
<li> <p><code>cloth_resolution</code>: by default 0.5.</p>
</li></ul>

<table>
<tr><td><code id="tree.detection.several.plots_+3A_intensity">intensity</code></td>
<td>
<p>Logical parameter useful when point clouds have intensity values. It may be useful in some internal process to filter data.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_rgb">RGB</code></td>
<td>
<p>Logical parameter useful when point clouds are colorized, thus including values of RGB colors. It is based on the Green Leaf Algorithm (GLA) (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_single.tree">single.tree</code></td>
<td>
<p>Optional argument to indicate if there is only one tree.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_dbh.max">dbh.max</code></td>
<td>
<p>Optional maximum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 200 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_h.min">h.min</code></td>
<td>
<p>Optional minimum <em>h</em> (m) considered for detecting trees. By default it will be set at 1.3 m.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_ncr.threshold">ncr.threshold</code></td>
<td>
<p>Local surface variation (also known as normal change rate, NCR). By default it will be set as 0.1. For better understanding of this argument see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_tls.resolution">tls.resolution</code></td>
<td>
<p>List containing parameters of TLS resolution. This can be defined by the angle aperture:</p>
</td></tr>
</table>

<ul>
<li> <p><code>horizontal.angle</code>: horizontal angle aperture (degrees).
</p>
</li>
<li> <p><code>vertical.angle</code>: vertical angle aperture (degrees).
</p>
</li>
<li> <p><code>point.dist</code>: distance (mm) between two consecutive points.
</p>
</li>
<li> <p><code>tls.dist</code>: distance (m) from TLS at which two consecutive points are separated by <code>point.dist</code>.
</p>
<p>If this argument is not specified by the user, it will be set to NULL by default and, as a consequence the function will stop giving an error message.</p>
</li></ul>

<table>
<tr><td><code id="tree.detection.several.plots_+3A_tls.precision">tls.precision</code></td>
<td>
<p>Optional argument indicating the average point cloud precision in cm.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_density.reduction">density.reduction</code></td>
<td>
<p>Density reduction intensity.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_stem.section">stem.section</code></td>
<td>
<p>Section free of noise (shurb, branches, etc.) considered to detect trees. If not specified, an automatic internal algorithm will be applied (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_breaks">breaks</code></td>
<td>
<p>Height above ground level (m) of slices considered for detecting trees. By default it will be considered all possible sections from 0.1 m to maximum height by 0.3 m intervals (+/- 5 cm).</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_stem.range">stem.range</code></td>
<td>
<p>Section considered to estimate straightness tree attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_slice">slice</code></td>
<td>
<p>Slice width considered for detecting trees. By default it will be considered as 0.1 m.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_understory">understory</code></td>
<td>
<p>Optional argument to indicate if there is dense understory vegetation.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_bark.roughness">bark.roughness</code></td>
<td>
<p>Bark roughness established in 3 degrees (1 &lt; 2 &lt; 3). By default it will be considered as 2.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_den.type">den.type</code></td>
<td>
<p>Numeric argument indicating the dendrometic type used to estimate volumen when there are not sections enough to fit a taper equation. Dendrometrics types available are the following: cylinder = 0, paraboloid = 1 (by default), cone = 2 and neiloid = 3.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_d.top">d.top</code></td>
<td>
<p>Top stem diameter (cm) considered to estimate commercial timber volume.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_plot.attributes">plot.attributes</code></td>
<td>
<p>Data frame with attributes at plot level. It must contain a column named <code>id</code> (character string or numeric value) with encoding coinciding with that used in <code>id</code> argument of <code><a href="#topic+normalize">normalize</a></code> for identifying plots. If there are strata, another column named &lsquo;stratum&rsquo; (numeric) will be required for other functionalities of <span class="pkg">FORTLS</span> (see, for instance, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code> or <code><a href="#topic+metrics.variables">metrics.variables</a></code>). If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the function will not add these possible plot attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_plot">plot</code></td>
<td>
<p>Optional logical which indicates whether or not the normalized point cloud will be plot. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the normalized point cloud will be plot.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_dir.data">dir.data</code></td>
<td>
<p>Optional character string naming the absolute path of the directory where LAS files containing TLS point clouds are located. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.dat</code>. If this argument is not specified by the user, it will be set to <code>NULL</code> by default and, as consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.dat</code> during the execution.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_save.result">save.result</code></td>
<td>
<p>Optional logical which indicates whether or not the output files described in &lsquo;Output Files&rsquo; section should be saved in the <code>dir.result</code>. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as a consequence, the output files will be saved.</p>
</td></tr>
<tr><td><code id="tree.detection.several.plots_+3A_dir.result">dir.result</code></td>
<td>
<p>Optional character string naming the absolute path of an existing directory where files described in &lsquo;Output Files&rsquo; section will be saved. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.result</code>. If this argument is not specified by the user, and <code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.</p>
</td></tr></table>


<h3>Details</h3>

<p>See <code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> for further details.</p>


<h3>Value</h3>

<p>Data frame with the same description and format as <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> and <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> &lsquo;Values&rsquo;. In this case, the <code>id</code> of plots will be encoded with correlative numbers from 1 to n, where n is the number of LAS files included in <code>files</code> argument, and <code>file</code> column will be encoded as <code>id</code>, but including .las extension.</p>


<h3>Output Files</h3>

<p>At the end of the tree detection process, if the <code>save.result</code> argument is <code>TRUE</code>, the function will save both, the reduced point clouds as TXT files encoded according to <code>file</code> column of &lsquo;Value&rsquo;; and the data frame with the tree list described in &lsquo;Value&rsquo; as CSV file (see <code><a href="#topic+normalize">normalize</a></code> and <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code> or <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code> &lsquo;Output files&rsquo;). All outputs are written without row names in the <code>dir.result</code> directory using <code><a href="vroom.html#topic+vroom_write">vroom_write</a></code> function from <a href="https://CRAN.R-project.org/package=vroom"><span class="pkg">vroom</span></a> package.</p>


<h3>Note</h3>

<p>This function has been developed for working with several plots, which will be the most common situation in forest inventory approaches. Nevertheless, several LAS files are not provided as examples due to problems with memory capacity.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero
and Adela Martínez-Calvo.</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+tree.detection.single.scan">tree.detection.single.scan</a></code>,<code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+distance.sampling">distance.sampling</a></code>, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code>, <code><a href="#topic+simulations">simulations</a></code>, <code><a href="#topic+metrics.variables">metrics.variables</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Establishment of working directories (optional)
# By default here we propose the current working directory of the R process

dir.data &lt;- getwd()
dir.result &lt;- getwd()

# Loading example data (LAZ files) to dir.data

download.file(
"www.dropbox.com/scl/fi/hzzrt0a39crdy6uvcj9el/PinusSylve1.laz?rlkey=svpwvorkm8889fgbnj14ns1f2&amp;dl=1",
              destfile = file.path(dir.data, "PinusSylvestris1.laz"),
              mode = "wb")

download.file(
"www.dropbox.com/scl/fi/zeszze31jh5m1g4o3ns1o/PinusSylve2.laz?rlkey=wx72bi6ggdc7wedwgzupekp9k&amp;dl=1",
              destfile = file.path(dir.data, "PinusSylvestris2.laz"),
              mode = "wb")


# Obtaining a vector with names of LAZ files located in dir.data

files &lt;- list.files(pattern = "laz$", path = dir.data)


# Tree detection (TLS single-scan aproach)

tree.tls &lt;- tree.detection.several.plots(las.list =
                                           c("PinusSylvestris1.laz",
                                             "PinusSylvestris2.laz"),

                                         id = c("PinusSylvestris1",
                                                "PinusSylvestris2"),

                                         tls.resolution = list(point.dist = 7.67, tls.dist = 10),

                                         breaks = c(1, 1.3, 1.6), stem.section = c(0.5, 4.5))

  
</code></pre>

<hr>
<h2 id='tree.detection.single.scan'>Tree-Level Variables Estimation for TLS Single-Scan Approach</h2><span id='topic+tree.detection.single.scan'></span>

<h3>Description</h3>

<p>Detects trees from TLS point clouds corresponding to a single scan. For each tree detected, the function calculates the central coordinates and estimates the diameter at 1.3 m above ground level (which is known as <em>dbh</em>, diameter at breast height) and classifies it as fully visible or partially occluded. Finally, the function obtains the number of points belonging to normal sections of trees (those corresponding to <em>dbh</em> +/- 5 cm) and estimates them for both original and reduced (with point cropping process) point clouds.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.detection.single.scan(data, single.tree = NULL,
                           dbh.min = 4, dbh.max = 200, h.min = 1.3,
                           ncr.threshold = 0.1,
                           tls.resolution = list(),
                           tls.precision = NULL,
                           density.reduction = 2,
                           stem.section = c(0.7, 3.5), stem.range = NULL, breaks = NULL,
                           slice = 0.1, understory = NULL, bark.roughness = 1,
                           den.type = 1, d.top = NULL,
                           plot.attributes = NULL, plot = TRUE,
                           save.result = TRUE, dir.result = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.detection.single.scan_+3A_data">data</code></td>
<td>
<p>Data frame with same description and format as indicated for <code><a href="#topic+normalize">normalize</a></code> &lsquo;Value&rsquo;.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_single.tree">single.tree</code></td>
<td>
<p>Optional argument to indicate if there is only one tree.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_dbh.min">dbh.min</code></td>
<td>
<p>Optional minimum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 4 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_dbh.max">dbh.max</code></td>
<td>
<p>Optional maximum <em>dbh</em> (cm) considered for detecting trees. By default it will be set at 200 cm.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_h.min">h.min</code></td>
<td>
<p>Optional minimum <em>h</em> (m) considered for detecting trees. By default it will be set at 1.3 m.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_ncr.threshold">ncr.threshold</code></td>
<td>
<p>Local surface variation (also known as normal change rate, NCR). By default it will be set as 0.1. For better understanding of this argument see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_tls.resolution">tls.resolution</code></td>
<td>
<p>List containing parameters of TLS resolution. This can be defined by the angle aperture:</p>
</td></tr>
</table>

<ul>
<li> <p><code>horizontal.angle</code>: horizontal angle aperture (degrees).
</p>
</li>
<li> <p><code>vertical.angle</code>: vertical angle aperture (degrees).
</p>
</li>
<li> <p><code>point.dist</code>: distance (mm) between two consecutive points.
</p>
</li>
<li> <p><code>tls.dist</code>: distance (m) from TLS at which two consecutive points are separated by <code>point.dist</code>.
</p>
<p>If this argument is not specified by the user, it will be set to NULL by default and, as a consequence the function will stop giving an error message.</p>
</li></ul>

<table>
<tr><td><code id="tree.detection.single.scan_+3A_tls.precision">tls.precision</code></td>
<td>
<p>Average point cloud precision in cm.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_density.reduction">density.reduction</code></td>
<td>
<p>Density reduction intensity.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_stem.section">stem.section</code></td>
<td>
<p>Section free of noise (shurb, branches, etc.) considered to detect trees. If not specified, an automatic internal algorithm will be applied (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_stem.range">stem.range</code></td>
<td>
<p>Section considered to estimate straightness tree attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_breaks">breaks</code></td>
<td>
<p>Height above ground level (m) of slices considered for detecting trees. By default it will be considered all possible sections from 0.1 m to maximum height by 0.3 m intervals (+/- 5 cm).</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_slice">slice</code></td>
<td>
<p>Slice width considered for detecting trees. By default it will be considered as 0.1 m.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_understory">understory</code></td>
<td>
<p>Optional argument to indicate if there is dense understory vegetation.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_bark.roughness">bark.roughness</code></td>
<td>
<p>Bark roughness established in 3 degrees (1 &lt; 2 &lt; 3). By default it will be considered as 1.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_den.type">den.type</code></td>
<td>
<p>Numeric argument indicating the dendrometic type used to estimate volumen when there are not sections enough to fit a taper equation. Dendrometrics types available are the following: cylinder = 0, paraboloid = 1 (by default), cone = 2 and neiloid = 3.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_d.top">d.top</code></td>
<td>
<p>Top stem diameter (cm) considered to estimate commercial timber volume.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_plot.attributes">plot.attributes</code></td>
<td>
<p>Data frame with attributes at plot level. It must contain a column named <code>id</code> (character string or numeric value) with encoding coinciding with that used in <code>id</code> argument of <code><a href="#topic+normalize">normalize</a></code> for identifying plots. If there are strata, another column named &lsquo;stratum&rsquo; (numeric) will be required for other functionalities of <span class="pkg">FORTLS</span> (see, for instance, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code> or <code><a href="#topic+metrics.variables">metrics.variables</a></code>). If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the function will not add these possible plot attributes.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_plot">plot</code></td>
<td>
<p>Optional logical which indicates whether or not the normalized point cloud will be plot. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as consequence, the normalized point cloud will be plot.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_save.result">save.result</code></td>
<td>
<p>Optional logical which indicates whether or not the output files described in &lsquo;Output Files&rsquo; section should be saved in <code>dir.result</code>. If this argument is not specified by the user, it will be set to <code>TRUE</code> by default and, as a consequence, the output files will be saved.</p>
</td></tr>
<tr><td><code id="tree.detection.single.scan_+3A_dir.result">dir.result</code></td>
<td>
<p>Optional character string naming the absolute path of an existing directory where the files described in &lsquo;Output Files&rsquo; section will be saved. <code>.Platform$file.sep</code> must be used as the path separator in <code>dir.result</code>. If this argument is not specified by the user, and the <code>save.result</code> is <code>TRUE</code>, it will be set to <code>NULL</code> by default and, as a consequence, the current working directory of the <span class="rlang"><b>R</b></span> process will be assigned to <code>dir.result</code> during the execution.</p>
</td></tr></table>


<h3>Details</h3>

<p>Slices determined by <code>breaks</code> argument are clustered using the DBSCAN algorithm (Ester et al., 1996) on the horizontal plane according to Cartesian coordinates (x, y). Before and after this process, several algorithms are used to remove noisy points and apply classification criteria to select the clusters of trees.
</p>
<p><em>dbh</em> is directly estimated for the section of 1.3 m above ground level, and estimated from other sections using <em>dbh</em>~<em>breaks</em> linear regression. Finally, the mean value of all estimates is provided in &lsquo;Value&rsquo; as the <em>dbh</em> of the tree section.
</p>
<p>The number of points corresponding to a normal section (+/- 5 cm) is estimated in proportion to <em>dbh</em>, using the average number of points per radius unit as reference. In this respect, only tree sections fully visible at 1.3 m above ground level will be considered for estimating the average number of points.
</p>
<p>Local surface variation (also known as normal change rate ,NCR), is a quantitative measure of curvature feature (Pauly et al., 2002). This is useful for distinguishing points belonging to fine branches and foliage (e.g. leaves, shrubs) and stem points (e.g. Jin et al., 2016; Zhang et al., 2019). Just as we considered 5 cm as suitable for calculating local surface variation for the stem separation in forests, according to other authors (Ma et al., 2015; Xia et al., 2015), we also established the NCR threshold as 0.1, according to Zhang et al. (2019). However, this argument (<code>ncr.threshold</code>) may be modified in order to use more appropriate values.</p>


<h3>Value</h3>

<p>Data frame with the following columns for every tree detected (each row corresponds to one tree detected):
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Optional plot identification encoded as a character string or numeric. If this argument is not specified by the user, it will be set to NULL by default and, as a consequence, the plot will be encoded as 1.</p>
</td></tr>
<tr><td><code>file</code></td>
<td>
<p>Optional file name identification encoded as character string or numeric. If it is null, the file will be encoded as <code>id</code> by default.</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>tree numbering</p>
</td></tr>
<tr><td><code>Coordinates</code></td>
<td>

<p>Cartesian (according to <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">https://en.wikipedia.org/wiki/Cartesian_coordinate_system</a> notation):</p>
</td></tr>
</table>

<ul>
<li> <p><code>x</code>: distance on x axis (m) of tree centre.
</p>
</li>
<li> <p><code>y</code>: distance on y axis (m) of tree centre.</p>
</li></ul>

<p>Azimuthal angles:
</p>

<ul>
<li> <p><code>phi</code>: angular coordinate (rad) of tree centre.
</p>
</li>
<li> <p><code>phi.left</code>: angular coordinate (rad) of left border of tree section.
</p>
</li>
<li> <p><code>phi.right</code>: angular coordinate (rad) of right border of tree section</p>
</li></ul>

<table>
<tr><td><code>h.dist</code></td>
<td>
<p>horizontal distance (m) from plot centre to tree centre.</p>
</td></tr>
<tr><td><code>\emph{dbh}</code></td>
<td>
<p>estimated tree diameter (cm) at breast height (1.3 m).</p>
</td></tr>
<tr><td><code>\emph{h}</code></td>
<td>
<p>estimated tree total height (m).</p>
</td></tr>
<tr><td><code>\emph{h.com}</code></td>
<td>
<p>estimated commercial tree height (m) according to the top diameter defined in the argument <code>d.top</code>.</p>
</td></tr>
<tr><td><code>\emph{v}</code></td>
<td>
<p>estimated tree stem volume (m^3).</p>
</td></tr>
<tr><td><code>\emph{v.com}</code></td>
<td>
<p>estimated commercial tree stem volume (m^3) according to the top diameter defined in the argument <code>d.top</code>.</p>
</td></tr>
<tr><td><code>n.pts</code></td>
<td>
<p>number of points corresponding to a normal section (+/- 5 cm) in the original point cloud.</p>
</td></tr>
<tr><td><code>n.pts.red</code></td>
<td>
<p>number of points corresponding to a normal section (+/- 5 cm) in the point cloud reduced by the point cropping process.</p>
</td></tr>
<tr><td><code>n.pts.est</code></td>
<td>
<p>number of points estimated for a normal section (+/- 5 cm) in the original point cloud.</p>
</td></tr>
<tr><td><code>n.pts.red.est</code></td>
<td>
<p>number of points estimated for a normal section (+/- 5 cm) in the point cloud reduced by the point cropping process.</p>
</td></tr>
<tr><td><code>partial.occlusion</code></td>
<td>
<p>yes (1) or no (0)</p>
</td></tr></table>


<h3>Output Files</h3>

<p>At the end of the tree detection process, if the <code>save.result</code> argument is <code>TRUE</code>, the function will save the data frame described in &lsquo;Value&rsquo; as a CSV file named &lsquo;tree.tls.csv&rsquo;. The data frame will be written without row names in the <code>dir.result</code> directory by using <code><a href="utils.html#topic+write.csv">write.csv</a></code> function from the <span class="pkg">utils</span> package.</p>


<h3>Note</h3>

<p>Although <code>tree.detection</code> also works with reduced point clouds, thus reducing the computing time, use of the original point cloud is recommended in order to detect more trees. This will also depend on forest conditions, especially those related to visibility. The more distant the trees are, the lower the density of points will be, and using reduced point clouds will therefore complicate detection of the most distant trees.
</p>
<p>Note that <code>dbh.min</code> and <code>dbh.max</code> are important for avoiding outlier values when inventory data are used for reference purposes. Otherwise, knowledge about the autoecology of species could be used for filtering anomalous values of <em>dbh</em>.
</p>
<p>The argument <code>breaks = 1.3</code> could be sufficient for detecting trees visible at <em>dbh</em>, involving lower computational cost. However, those trees not detected at <em>dbh</em>, may be estimated from lower and/or higher sections. Considering the three default sections in the argument <code>breaks = c(1.0, 1.3, 1.6)</code> maintains a good balance in the case study of this package.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero
and Adela Martínez-Calvo.</p>


<h3>References</h3>

<p>Ester, M., Kriegel, H. P., Sander, J., &amp; Xu, X. (1996). A density-based algorithm for discovering clusters in large spatial databases with noise. In Kdd (Vol. 96, No. 34, pp. 226-231).
</p>
<p>Jin, S., Tamura, M., &amp; Susaki, J. (2016). A new approach to retrieve leaf normal distribution using terrestrial laser scanners. J. <em>Journal of Forestry Research</em>, <b>27(3)</b>, 631-638. <a href="https://doi.org/10.1007/s11676-015-0204-z">doi:10.1007/s11676-015-0204-z</a>
</p>
<p>Ma, L., Zheng, G., Eitel, J. U., Moskal, L. M., He, W., &amp; Huang, H. (2015). Improved salient feature-based approach for automatically separating photosynthetic and nonphotosynthetic components within terrestrial lidar point cloud data of forest canopies. <em>IEEE Transactions Geoscience Remote Sensing</em>, <b>54(2)</b>, 679-696. <a href="https://doi.org/10.1109/TGRS.2015.2459716">doi:10.1109/TGRS.2015.2459716</a>
</p>
<p>Pauly, M., Gross, M., &amp; Kobbelt, L. P., (2002). Efficient simplification of point-sampled surfaces. In IEEE Conference on Visualization. (pp. 163-170). Boston, USA. <a href="https://doi.org/10.1109/VISUAL.2002.1183771">doi:10.1109/VISUAL.2002.1183771</a>
</p>
<p>Xia, S., Wang, C., Pan, F., Xi, X., Zeng, H., &amp; Liu, H. (2015). Detecting stems in dense and homogeneous forest using single-scan TLS. <em>Forests</em>. <b>6(11)</b>, 3923-3945. <a href="https://doi.org/10.3390/f6113923">doi:10.3390/f6113923</a>
</p>
<p>Zhang, W., Wan, P., Wang, T., Cai, S., Chen, Y., Jin, X., &amp; Yan, G. (2019). A novel approach for the detection of standing tree stems from plot-level terrestrial laser scanning data. <em>Remote Sens</em>. <b>11(2)</b>, 211. <a href="https://doi.org/10.3390/rs11020211">doi:10.3390/rs11020211</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+tree.detection.multi.scan">tree.detection.multi.scan</a></code>, <code><a href="#topic+tree.detection.several.plots">tree.detection.several.plots</a></code>, <code><a href="#topic+distance.sampling">distance.sampling</a></code>, <code><a href="#topic+estimation.plot.size">estimation.plot.size</a></code>, <code><a href="#topic+simulations">simulations</a></code>, <code><a href="#topic+metrics.variables">metrics.variables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Establishment of working directories (optional)
# By default here we propose the current working directory of the R process

dir.data &lt;- getwd()
dir.result &lt;- getwd()


# Loading example data (LAZ file) to dir.data

download.file("https://www.dropbox.com/s/17yl25pbrapat52/PinusRadiata.laz?dl=1",
              destfile = file.path(dir.data, "PinusRadiata.laz"),
              mode = "wb")


# Normalizing the whole point cloud data without considering arguments

pcd &lt;- normalize(las = "PinusRadiata.laz",

                 id = "PinusRadiata",

                 dir.data = dir.data, dir.result = dir.result)


# Tree detection without considering arguments
# For this case study, TLS resolution was established as:
# point.dist = 6.34 mm and tls.dist = 10 m

tree.tls &lt;- tree.detection.single.scan(data = pcd,

                                       tls.resolution = list(point.dist = 6.34, tls.dist = 10),

                                       breaks = c(1, 1.3, 1.6),

                                       dir.result = dir.result)

  

</code></pre>

<hr>
<h2 id='ver_point_cloud_double'>Calculate dominant diameters and heights for simulations for angle-count plots.</h2><span id='topic+ver_point_cloud_double'></span>

<h3>Description</h3>

<p>Calculate dominant diameters and heights for simulations for angle-count plots.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ver_point_cloud_double(m)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ver_point_cloud_double_+3A_m">m</code></td>
<td>
<p>matrix with points.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='weighted_mean_arit'>Calculate weighted arithmetic mean.</h2><span id='topic+weighted_mean_arit'></span>

<h3>Description</h3>

<p>Calculate weighted arithmetic mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  weighted_mean_arit(x, w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_arit_+3A_x">x</code></td>
<td>
<p>attribute for which calculate mean.</p>
</td></tr>
<tr><td><code id="weighted_mean_arit_+3A_w">w</code></td>
<td>
<p>vector with weights associated to x.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='weighted_mean_geom'>Calculate weighted geometric mean.</h2><span id='topic+weighted_mean_geom'></span>

<h3>Description</h3>

<p>Calculate weighted geometric mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  weighted_mean_geom(x, w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_geom_+3A_x">x</code></td>
<td>
<p>attribute for which calculate mean.</p>
</td></tr>
<tr><td><code id="weighted_mean_geom_+3A_w">w</code></td>
<td>
<p>vector with weights associated to x.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='weighted_mean_harm'>Calculate weighted harmonic mean.</h2><span id='topic+weighted_mean_harm'></span>

<h3>Description</h3>

<p>Calculate weighted harmonic mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  weighted_mean_harm(x, w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_harm_+3A_x">x</code></td>
<td>
<p>attribute for which calculate mean.</p>
</td></tr>
<tr><td><code id="weighted_mean_harm_+3A_w">w</code></td>
<td>
<p>vector with weights associated to x.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

<hr>
<h2 id='weighted_mean_sqrt'>Calculate weighted quadratic mean.</h2><span id='topic+weighted_mean_sqrt'></span>

<h3>Description</h3>

<p>Calculate weighted quadratic mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  weighted_mean_sqrt(x, w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_sqrt_+3A_x">x</code></td>
<td>
<p>attribute for which calculate mean.</p>
</td></tr>
<tr><td><code id="weighted_mean_sqrt_+3A_w">w</code></td>
<td>
<p>vector with weights associated to x.</p>
</td></tr></table>


<h3>Value</h3>

<p>Data frame.</p>


<h3>Author(s)</h3>

<p>Juan Alberto Molina-Valero,
María José Ginzo Villamayor,
Manuel Antonio Novo Pérez,
Adela Martínez-Calvo,
Juan Gabriel Álvarez-González,
Fernando Montes and
César Pérez-Cruzado.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
