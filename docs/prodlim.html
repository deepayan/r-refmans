<!DOCTYPE html><html><head><title>Help for package prodlim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prodlim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#atRisk'><p>Drawing numbers of subjects at-risk of experiencing an event below</p>
Kaplan-Meier and Aalen-Johansen plots.</a></li>
<li><a href='#backGround'><p>Background and grid color control.</p></a></li>
<li><a href='#checkCauses'><p>Check availability of a cause in competing risk settings</p></a></li>
<li><a href='#confInt'><p>Add point-wise confidence limits to the graphs of Kaplan-Meier and</p>
Aalen-Johansen estimates.</a></li>
<li><a href='#crModel'><p>Competing risks model for simulation</p></a></li>
<li><a href='#dimColor'><p>Dim a given color to a specified density</p></a></li>
<li><a href='#EventHistory.frame'><p>Event history frame</p></a></li>
<li><a href='#getEvent'><p>Extract a column from an event history object.</p></a></li>
<li><a href='#getStates'><p>States of a multi-state model</p></a></li>
<li><a href='#Hist'><p>Create an event history response variable</p></a></li>
<li><a href='#jackknife'><p>Compute jackknife pseudo values.</p></a></li>
<li><a href='#leaveOneOut'><p>Compute jackknife pseudo values.</p></a></li>
<li><a href='#List2Matrix'><p>Reduce list to a matrix or data.frame with names as new columns</p></a></li>
<li><a href='#markTime'><p>Marking product-limit plots at the censored times.</p></a></li>
<li><a href='#meanNeighbors'><p>Helper function to obtain running means for prodlim objects.</p></a></li>
<li><a href='#model.design'><p>Extract a design matrix and specials from a model.frame</p></a></li>
<li><a href='#neighborhood'><p>Nearest neighborhoods for kernel smoothing</p></a></li>
<li><a href='#parseSpecialNames'><p>Parse special terms</p></a></li>
<li><a href='#PercentAxis'><p>Percentage-labeled axis.</p></a></li>
<li><a href='#plot.Hist'><p>Box-arrow diagrams for multi-state models.</p></a></li>
<li><a href='#plot.prodlim'><p>Plotting event probabilities over time</p></a></li>
<li><a href='#plotCompetingRiskModel'><p>Plotting a competing-risk-model.</p></a></li>
<li><a href='#plotIllnessDeathModel'><p>Plotting an illness-death-model.</p></a></li>
<li><a href='#predict.prodlim'><p>Predicting event probabilities from product limit estimates</p></a></li>
<li><a href='#predictSurvIndividual'><p>Predict individual survival probabilities</p></a></li>
<li><a href='#print.prodlim'><p>Print objects in the prodlim library</p></a></li>
<li><a href='#prodlim'><p>product limit method</p></a></li>
<li><a href='#prodlim-package'><p>Kaplan-Meier and Aalen-Johansen method</p></a></li>
<li><a href='#quantile.prodlim'><p>Quantiles for Kaplan-Meier and Aalen-Johansen estimates.</p></a></li>
<li><a href='#redist'><p>Calculation of Efron's re-distribution to the right algorithm to obtain the</p>
Kaplan-Meier estimate.</a></li>
<li><a href='#row.match'><p>Identifying rows in a matrix or data.frame</p></a></li>
<li><a href='#SimCompRisk'><p>Simulate competing risks data</p></a></li>
<li><a href='#SimSurv'><p>Simulate survival data</p></a></li>
<li><a href='#sindex'><p>Index for evaluation of step functions.</p></a></li>
<li><a href='#SmartControl'><p>Function to facilitate the control of arguments passed to subroutines.</p></a></li>
<li><a href='#stopTime'><p>Stop the time of an event history object</p></a></li>
<li><a href='#strip.terms'><p>Strip special functions from terms</p></a></li>
<li><a href='#summary.Hist'><p>Summary of event histories</p></a></li>
<li><a href='#summary.prodlim'><p>Summary method for prodlim objects.</p></a></li>
<li><a href='#survModel'><p>Survival model for simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Product-Limit Estimation for Censored Event History Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.08.28</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas A. Gerds</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast and user friendly implementation of nonparametric estimators
    for censored event history (survival) analysis. Kaplan-Meier and
    Aalen-Johansen method.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.5), stats, data.table, grDevices, graphics,
diagram, survival, KernSmooth, lava</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 09:26:22 UTC; tag</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 11:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='atRisk'>Drawing numbers of subjects at-risk of experiencing an event below
Kaplan-Meier and Aalen-Johansen plots.</h2><span id='topic+atRisk'></span>

<h3>Description</h3>

<p>This function is invoked and controlled by <code>plot.prodlim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atRisk(
  x,
  newdata,
  times,
  line,
  col,
  labelcol = NULL,
  interspace,
  cex,
  labels,
  title = "",
  titlecol = NULL,
  pos,
  adj,
  dist,
  xdist,
  adjust.labels = TRUE,
  show.censored = FALSE,
  unit = "npc",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atRisk_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;prodlim&rsquo; as returned by the
<code>prodlim</code> function.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_newdata">newdata</code></td>
<td>
<p>see <code>plot.prodlim</code></p>
</td></tr>
<tr><td><code id="atRisk_+3A_times">times</code></td>
<td>
<p>Where to compute the atrisk numbers.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_line">line</code></td>
<td>
<p>Distance of the atrisk numbers from the inner plot.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_col">col</code></td>
<td>
<p>The color of the text.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_labelcol">labelcol</code></td>
<td>
<p>The color for the labels. Defaults to col.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_interspace">interspace</code></td>
<td>
<p>Distance between rows of atrisk numbers.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_cex">cex</code></td>
<td>
<p>Passed on to <code>mtext</code> for both atrisk numbers and
labels.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_labels">labels</code></td>
<td>
<p>Labels for the at-risk rows.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_title">title</code></td>
<td>
<p>Title for the at-risk labels</p>
</td></tr>
<tr><td><code id="atRisk_+3A_titlecol">titlecol</code></td>
<td>
<p>The color for the title. Defaults to 1 (black).</p>
</td></tr>
<tr><td><code id="atRisk_+3A_pos">pos</code></td>
<td>
<p>The value is passed on to the <code>mtext</code> argument
<code>at</code> for the labels (not the atrisk numbers).</p>
</td></tr>
<tr><td><code id="atRisk_+3A_adj">adj</code></td>
<td>
<p>Passed on to <code>mtext</code> for the labels (not the atriks
numbers).</p>
</td></tr>
<tr><td><code id="atRisk_+3A_dist">dist</code></td>
<td>
<p>If <code>line</code> is missing, the distance of the upper
most atrisk row from the inner plotting region: par()$mgp[2].</p>
</td></tr>
<tr><td><code id="atRisk_+3A_xdist">xdist</code></td>
<td>
<p>Distance in x-axis direction to define the distance between the labels
and the numbers at-risk. Deftaults to <code>strwidth("MM",cex=cex)</code>.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_adjust.labels">adjust.labels</code></td>
<td>
<p>If <code>TRUE</code> the labels are left adjusted.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_show.censored">show.censored</code></td>
<td>
<p>If <code>TRUE</code> the cumulative number of subjects
lost to follow up is shown in parentheses.</p>
</td></tr>
<tr><td><code id="atRisk_+3A_unit">unit</code></td>
<td>
<p>The graphical coordinate systems unit to convert from when line2user is calling <code>grconvertX</code> and <code>grconvertY</code>.
Default is <code>'npc'</code></p>
</td></tr>
<tr><td><code id="atRisk_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the function
<code>mtext</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly. The arguments can be specified
as <code>atRisk.arg</code> in the call to <code>plot.prodlim</code>.
</p>


<h3>Value</h3>

<p>Nil
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.prodlim">plot.prodlim</a></code>, <code><a href="#topic+confInt">confInt</a></code>,
<code><a href="#topic+markTime">markTime</a></code>
</p>

<hr>
<h2 id='backGround'>Background and grid color control.</h2><span id='topic+backGround'></span>

<h3>Description</h3>

<p>Some users like background colors, and it may be helpful to have grid lines
to read off e.g. probabilities from a Kaplan-Meier graph. Both things can be
controlled with this function. However, it mainly serves
<code><a href="#topic+plot.prodlim">plot.prodlim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backGround(
  xlim,
  ylim,
  bg = "white",
  fg = "gray77",
  horizontal = NULL,
  vertical = NULL,
  border = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backGround_+3A_xlim">xlim</code></td>
<td>
<p>Limits for the xaxis, defaults to par(&quot;usr&quot;)[1:2].</p>
</td></tr>
<tr><td><code id="backGround_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the yaxis, defaults to par(&quot;usr&quot;)[3:4].</p>
</td></tr>
<tr><td><code id="backGround_+3A_bg">bg</code></td>
<td>
<p>Background color. Can be multiple colors which are then switched
at each horizontal line.</p>
</td></tr>
<tr><td><code id="backGround_+3A_fg">fg</code></td>
<td>
<p>Grid line color.</p>
</td></tr>
<tr><td><code id="backGround_+3A_horizontal">horizontal</code></td>
<td>
<p>Numerical values at which horizontal grid lines are
plotted.</p>
</td></tr>
<tr><td><code id="backGround_+3A_vertical">vertical</code></td>
<td>
<p>Numerical values at which vertical grid lines are plotted.</p>
</td></tr>
<tr><td><code id="backGround_+3A_border">border</code></td>
<td>
<p>The color of the border around the background.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(0,0)
backGround(bg="beige",fg="red",vertical=0,horizontal=0)

plot(0,0)
backGround(bg=c("yellow","green"),fg="red",xlim=c(-1,1),ylim=c(-1,1),horizontal=seq(0,1,.1))
backGround(bg=c("yellow","green"),fg="red",horizontal=seq(0,1,.1))

</code></pre>

<hr>
<h2 id='checkCauses'>Check availability of a cause in competing risk settings</h2><span id='topic+checkCauses'></span>

<h3>Description</h3>

<p>For competing risk settings, check if the requested cause is known to the object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCauses(cause, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkCauses_+3A_cause">cause</code></td>
<td>
<p>cause of interest</p>
</td></tr>
<tr><td><code id="checkCauses_+3A_object">object</code></td>
<td>
<p>object either obtained with <code>Hist</code> or <code>prodlim</code></p>
</td></tr>
</table>

<hr>
<h2 id='confInt'>Add point-wise confidence limits to the graphs of Kaplan-Meier and
Aalen-Johansen estimates.</h2><span id='topic+confInt'></span>

<h3>Description</h3>

<p>This function is invoked and controlled by <code>plot.prodlim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confInt(ci, citype, col, lty, lwd, density = 55, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confInt_+3A_ci">ci</code></td>
<td>
<p>A <code>data.table</code> with columns <code>time</code>, <code>lower</code> and <code>upper</code>.</p>
</td></tr>
<tr><td><code id="confInt_+3A_citype">citype</code></td>
<td>
<p>If <code>"shadow"</code> then confidence limits are drawn as colored
shadows.  Otherwise, dotted lines are used to show the upper and lower
confidence limits.</p>
</td></tr>
<tr><td><code id="confInt_+3A_col">col</code></td>
<td>
<p>the colour of the lines.</p>
</td></tr>
<tr><td><code id="confInt_+3A_lty">lty</code></td>
<td>
<p>the line type of the lines.</p>
</td></tr>
<tr><td><code id="confInt_+3A_lwd">lwd</code></td>
<td>
<p>the line thickness of the lines.</p>
</td></tr>
<tr><td><code id="confInt_+3A_density">density</code></td>
<td>
<p>For <code>citype="shadow"</code>, the density of the shade. Default
is 55 percent.</p>
</td></tr>
<tr><td><code id="confInt_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the function
<code>segments</code> if <code>type=="bars"</code> and to <code>lines</code> else.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly. The arguments can be specified
as <code>Confint.arg</code> in the call to <code>plot.prodlim</code>.
</p>


<h3>Value</h3>

<p>Nil
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.prodlim">plot.prodlim</a></code>, <code><a href="#topic+atRisk">atRisk</a></code>,
<code><a href="#topic+markTime">markTime</a></code>
</p>

<hr>
<h2 id='crModel'>Competing risks model for simulation</h2><span id='topic+crModel'></span>

<h3>Description</h3>

<p>Competing risks model for simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crModel()
</code></pre>


<h3>Details</h3>

<p>Create a competing risks model with to causes to simulate a right censored event time data without
covariates
</p>
<p>This function requires the <code>lava</code> package.
</p>


<h3>Value</h3>

<p>A structural equation model initialized with four variables: the
latent event times of two causes, the latent right censored time, and the observed
right censored event time.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
m &lt;- crModel()
d &lt;- sim(m,6)
print(d)

</code></pre>

<hr>
<h2 id='dimColor'>Dim a given color to a specified density</h2><span id='topic+dimColor'></span>

<h3>Description</h3>

<p>This function calls first <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code> on a color name and then 
uses <code><a href="grDevices.html#topic+rgb">rgb</a></code> to adjust the intensity of the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimColor(col, density = 55)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimColor_+3A_col">col</code></td>
<td>
<p>Color name or number passed to <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.</p>
</td></tr>
<tr><td><code id="dimColor_+3A_density">density</code></td>
<td>
<p>Integer value passed as alpha coefficient to
<code><a href="grDevices.html#topic+rgb">rgb</a></code> between 0 and 255</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the color code. See <code>rgb</code> for details.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>rgb col2rgb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimColor(2,33)
dimColor("green",133)
</code></pre>

<hr>
<h2 id='EventHistory.frame'>Event history frame</h2><span id='topic+EventHistory.frame'></span>

<h3>Description</h3>

<p>Extract event history data and design matrix including specials from call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EventHistory.frame(
  formula,
  data,
  unspecialsDesign = TRUE,
  specials,
  specialsFactor = TRUE,
  specialsDesign = FALSE,
  stripSpecials = NULL,
  stripArguments = NULL,
  stripAlias = NULL,
  stripUnspecials = NULL,
  dropIntercept = TRUE,
  check.formula = TRUE,
  response = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EventHistory.frame_+3A_formula">formula</code></td>
<td>
<p>Formula whose left hand side specifies the event
history, i.e., either via Surv() or Hist().</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_data">data</code></td>
<td>
<p>Data frame in which the formula is interpreted</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_unspecialsdesign">unspecialsDesign</code></td>
<td>
<p>Passed as is to
<code><a href="#topic+model.design">model.design</a></code>.</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_specials">specials</code></td>
<td>
<p>Character vector of special function names.
Usually the body of the special functions is function(x)x but
e.g., <code><a href="survival.html#topic+strata">strata</a></code> from the survival package does treat
the values</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_specialsfactor">specialsFactor</code></td>
<td>
<p>Passed as is to <code><a href="#topic+model.design">model.design</a></code>.</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_specialsdesign">specialsDesign</code></td>
<td>
<p>Passed as is to <code><a href="#topic+model.design">model.design</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_stripspecials">stripSpecials</code></td>
<td>
<p>Passed as <code>specials</code> to
<code><a href="#topic+strip.terms">strip.terms</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_striparguments">stripArguments</code></td>
<td>
<p>Passed as <code>arguments</code> to
<code><a href="#topic+strip.terms">strip.terms</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_stripalias">stripAlias</code></td>
<td>
<p>Passed as <code>alias.names</code> to
<code><a href="#topic+strip.terms">strip.terms</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_stripunspecials">stripUnspecials</code></td>
<td>
<p>Passed as <code>unspecials</code> to
<code><a href="#topic+strip.terms">strip.terms</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_dropintercept">dropIntercept</code></td>
<td>
<p>Passed as is to <code><a href="#topic+model.design">model.design</a></code></p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_check.formula">check.formula</code></td>
<td>
<p>If TRUE check if formula is a Surv or Hist
thing.</p>
</td></tr>
<tr><td><code id="EventHistory.frame_+3A_response">response</code></td>
<td>
<p>If FALSE do not get response data (event.history).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain a list with the data used for event history regression analysis. This
function cannot be used directly on the user level but inside a function
to prepare data for survival analysis.
</p>


<h3>Value</h3>

<p>A list which contains
- the event.history (see <code><a href="#topic+Hist">Hist</a></code>)
- the design matrix (see <code><a href="#topic+model.design">model.design</a></code>)
- one entry for each special (see <code><a href="#topic+model.design">model.design</a></code>)
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>model.frame model.design Hist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Here are some data with an event time and no competing risks
## and two covariates X1 and X2.
## Suppose we want to declare that variable X1 is treated differently
## than variable X2. For example, X1 could be a cluster variable, or
## X1 should have a proportional effect on the outcome.
dsurv &lt;- data.frame(time=1:7,
                    status=c(0,1,1,0,0,0,1),
                    X2=c(2.24,3.22,9.59,4.4,3.54,6.81,5.05),
                    X3=c(1,1,1,1,0,0,1),
                    X4=c(44.69,37.41,68.54,38.85,35.9,27.02,41.84),
                    X1=factor(c("a","b","a","c","c","a","b"),
                        levels=c("c","a","b")))
## We pass a formula and the data
e &lt;- EventHistory.frame(Hist(time,status)~prop(X1)+X2+cluster(X3)+X4,
                        data=dsurv,
                        specials=c("prop","cluster"),
                        stripSpecials=c("prop","cluster"))
names(e)
## The first element is the event.history which is result of the left hand
## side of the formula:
e$event.history
## same as
with(dsurv,Hist(time,status))
## to see the structure do 
colnames(e$event.history)
unclass(e$event.history)
## in case of competing risks there will be an additional column called event,
## see help(Hist) for more details

## The other elements are the design, i.e., model.matrix for the non-special covariates
e$design
## and a data.frame for the special covariates
e$prop
## The special covariates can be returned as a model.matrix
e2 &lt;- EventHistory.frame(Hist(time,status)~prop(X1)+X2+cluster(X3)+X4,
                         data=dsurv,
                         specials=c("prop","cluster"),
                         stripSpecials=c("prop","cluster"),
                         specialsDesign=TRUE)
e2$prop
## and the non-special covariates can be returned as a data.frame
e3 &lt;- EventHistory.frame(Hist(time,status)~prop(X1)+X2+cluster(X3)+X4,
                         data=dsurv,
                         specials=c("prop","cluster"),
                         stripSpecials=c("prop","cluster"),
                         specialsDesign=TRUE,
                         unspecialsDesign=FALSE)
e3$design

## the general idea is that the function is used to parse the combination of
## formula and data inside another function. Here is an example with
## competing risks
SampleRegression &lt;- function(formula,data=parent.frame()){
    thecall &lt;- match.call()
    ehf &lt;- EventHistory.frame(formula=formula,
                              data=data,
                              stripSpecials=c("prop","cluster","timevar"),
                              specials=c("prop","timevar","cluster"))
    time &lt;- ehf$event.history[,"time"]
    status &lt;- ehf$event.history[,"status"]
    ## event as a factor
    if (attr(ehf$event.history,"model")=="competing.risks"){
        event &lt;- ehf$event.history[,"event"]
        Event &lt;- getEvent(ehf$event.history)
        list(response=data.frame(time,status,event,Event),X=ehf[-1])
    }
    else{ # no competing risks
        list(response=data.frame(time,status),X=ehf[-1])
    }
}
dsurv$outcome &lt;- c("cause1","0","cause2","cause1","cause2","cause2","0")
SampleRegression(Hist(time,outcome)~prop(X1)+X2+cluster(X3)+X4,dsurv)

## let's test if the parsing works
form1 &lt;- Hist(time,outcome!="0")~prop(X1)+X2+cluster(X3)+X4
form2 &lt;- Hist(time,outcome)~prop(X1)+cluster(X3)+X4
ff &lt;- list(form1,form2)
lapply(ff,function(f){SampleRegression(f,dsurv)})


## here is what the riskRegression package uses to
## distinguish between covariates with
## time-proportional effects and covariates with
## time-varying effects:
## Not run: 
library(riskRegression)
data(Melanoma)
f &lt;- Hist(time,status)~prop(thick)+strata(sex)+age+prop(ulcer,power=1)+timevar(invasion,test=1)
## here the unspecial terms, i.e., the term age is treated as prop
## also, strata is an alias for timvar

EHF &lt;- prodlim::EventHistory.frame(formula,
                                   Melanoma[1:10],
                                   specials=c("timevar","strata","prop","const","tp"),
                                   stripSpecials=c("timevar","prop"),
                                   stripArguments=list("prop"=list("power"=0),
                                       "timevar"=list("test"=0)),
                                   stripAlias=list("timevar"=c("strata"),
                                       "prop"=c("tp","const")),
                                   stripUnspecials="prop",
                                   specialsDesign=TRUE,
                                   dropIntercept=TRUE)       
EHF$prop
EHF$timevar

## End(Not run)
</code></pre>

<hr>
<h2 id='getEvent'>Extract a column from an event history object.</h2><span id='topic+getEvent'></span>

<h3>Description</h3>

<p>Extract a column from an event history object, as obtained with the function
<code><a href="#topic+Hist">Hist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEvent(object, mode = "factor", column = "event")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEvent_+3A_object">object</code></td>
<td>
<p>Object of class <code>"Hist"</code>.</p>
</td></tr>
<tr><td><code id="getEvent_+3A_mode">mode</code></td>
<td>
<p>Return mode. One of <code>"numeric"</code>, <code>"character"</code>, or
<code>"factor"</code>.</p>
</td></tr>
<tr><td><code id="getEvent_+3A_column">column</code></td>
<td>
<p>Name of the column to extract from the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since objects of class <code>"Hist"</code> are also matrices, all columns are
numeric or integer valued. To extract a correctly labeled version, the
attribute <code>states</code> of the object is used to generate factor levels.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hist">Hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  dat= data.frame(time=1:5,event=letters[1:5])
  x=with(dat,Hist(time,event))
  ## inside integer
  unclass(x)
  ## extract event (the extra level "unknown" is for censored data)
  getEvent(x)

</code></pre>

<hr>
<h2 id='getStates'>States of a multi-state model</h2><span id='topic+getStates'></span>

<h3>Description</h3>

<p>Extract the states of a multi-state model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStates(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStates_+3A_object">object</code></td>
<td>
<p>Object of class <code>prodlim</code> or <code>Hist</code> .</p>
</td></tr>
<tr><td><code id="getStates_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applying this function to the fit of prodlim means to apply
it to <code>fit$model.response</code>.
</p>


<h3>Value</h3>

<p>A character vector with the states of the model.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds
</p>

<hr>
<h2 id='Hist'>Create an event history response variable</h2><span id='topic+Hist'></span>

<h3>Description</h3>

<p>Functionality for managing censored event history response data. The
function can be used as the left hand side of a formula: <code>Hist</code> serves
<code><a href="#topic+prodlim">prodlim</a></code> in a similar way as <code><a href="survival.html#topic+Surv">Surv</a></code> from the
survival package serves &lsquo;survfit&rsquo;.  <code>Hist</code> provides the suitable
extensions for dealing with right censored and interval censored data from
competing risks and other multi state models. Objects generated with
<code>Hist</code> have a print and a plot method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hist(
  time,
  event,
  entry = NULL,
  id = NULL,
  cens.code = "0",
  addInitialState = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hist_+3A_time">time</code></td>
<td>
<p>for right censored data a numeric vector of event times &ndash; for
interval censored data a list or a data.frame providing two numeric vectors
the left and right endpoints of the intervals.  See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_event">event</code></td>
<td>
<p>A vector or a factor that specifies the events that occurred at
the corresponding value of <code>time</code>. Numeric, character and logical
values are recognized.  It can also be a list or a data.frame for the
longitudinal form of storing the data of a multi state model &ndash; see
<code>Details</code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_entry">entry</code></td>
<td>
<p>Vector of delayed entry times (left-truncation) or list of two
times when the entry time is interval censored.</p>
</td></tr>
<tr><td><code id="Hist_+3A_id">id</code></td>
<td>
<p>Identifies the subjects to which multiple events belong for the
longitudinal form of storing the data of a multi state model &ndash; see
<code>Details</code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_cens.code">cens.code</code></td>
<td>
<p>A character or numeric vector to identify the right
censored observations in the values of <code>event</code>.  Defaults to &quot;0&quot; which
is equivalent to 0.</p>
</td></tr>
<tr><td><code id="Hist_+3A_addinitialstate">addInitialState</code></td>
<td>
<p>If TRUE, an initial state is added to all ids for the
longitudinal input form of a multi-state model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>*Specification of the event times*
</p>
<p>If <code>time</code> is a numeric vector then the values are interpreted as right
censored event times, ie as the minimum of the event times and the censoring
times.
</p>
<p>If <code>time</code> is a list with two elements or data frame with two numeric
columns The first element (column) is used as the left endpoints of interval
censored observations and the second as the corresponding right endpoints.
When the two endpoints are equal, then this observation is treated as an
exact uncensored observation of the event time.  If the value of the right
interval endpoint is either <code>NA</code> or <code>Inf</code>, then this observation
is treated as a right censored observation. Right censored observations can
also be specified by setting the value of <code>event</code> to <code>cens.code</code>.
This latter specification of right censored event times overwrites the
former: if <code>event</code> equals <code>cens.code</code> the observation is treated
as right censored no matter what the value of the right interval endpoint
is.
</p>
<p>*Specification of the events*
</p>
<p>If <code>event</code> is a numeric, character or logical vector then the order of
the attribute &quot;state&quot; given to the <code>value</code> of <code>Hist</code> is determined
by the order in which the values appear.  If it is a factor then the order
from the levels of the factor is used instead.
</p>
<p>**Normal form of a multi state model**
</p>
<p>If <code>event</code> is a list or a data.frame with exactly two elements, then
these describe the transitions in a multi state model that occurred at the
corresponding <code>time</code> as follows: The values of the first element are
interpreted as the <code>from</code> states of the transition and values of the
second as the corresponding <code>to</code> states.
</p>
<p>**Longitudinal form of a multi state model**
</p>
<p>If <code>id</code> is given then <code>event</code> must be a vector. In this case two
subsequent values of <code>event</code> belonging to the same value of <code>id</code>
are treated as the <code>from</code> and <code>to</code> states of the transitions.
</p>


<h3>Value</h3>

<p>An object of class <code>Hist</code> for which there are print and plot
methods.  The object's internal is a matrix with some of the following
columns: </p>
<table>
<tr><td><code>time</code></td>
<td>
<p> the right censored times</p>
</td></tr> <tr><td><code>L</code></td>
<td>
<p>the left endpoints
of internal censored event times</p>
</td></tr> <tr><td><code>R</code></td>
<td>
<p>the right endpoints of internal
censored event times</p>
</td></tr> <tr><td><code>status</code></td>
<td>
<p><code>0</code> for right censored, <code>1</code>
for exact, and <code>2</code> for interval censored event times.</p>
</td></tr> <tr><td><code>event</code></td>
<td>
<p>an
integer valued numeric vector that codes the events.</p>
</td></tr> <tr><td><code>from</code></td>
<td>
<p>an integer
valued numeric vector that codes the <code>from</code> states of a transition in a
multi state model.</p>
</td></tr> <tr><td><code>to</code></td>
<td>
<p>an integer valued numeric vector that codes
the <code>to</code> states of a transition in a multi state model.</p>
</td></tr>
</table>
<p>Further information is stored in <code><a href="base.html#topic+attributes">attributes</a></code>.  The key to the
official names given to the events and the from and to states is stored in
an attribute &quot;states&quot;.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>, Arthur Allignol
<a href="mailto:arthur.allignol@fdm.uni-freiburg.de">arthur.allignol@fdm.uni-freiburg.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Hist">plot.Hist</a></code>, <code><a href="#topic+summary.Hist">summary.Hist</a></code>,
<code><a href="#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Right censored responses of a two state model
## ---------------------------------------------

Hist(time=1:10,event=c(0,1,0,0,0,1,0,1,0,0))

## change the code for events and censored observations

Hist(time=1:10,event=c(99,"event",99,99,99,"event",99,"event",99,99),cens.code=99)

TwoStateFrame &lt;- SimSurv(10)
SurvHist &lt;- with(TwoStateFrame,Hist(time,status))
summary(SurvHist)
plot(SurvHist)

## Right censored data from a competing risk model
## --------------------------------------------------

CompRiskFrame &lt;- data.frame(time=1:10,event=c(1,2,0,3,0,1,2,1,2,1))
CRHist &lt;- with(CompRiskFrame,Hist(time,event))
summary(CRHist)
plot(CRHist)

## Interval censored data from a survival model
icensFrame &lt;- data.frame(L=c(1,1,3,4,6),R=c(2,NA,3,6,9),event=c(1,1,1,2,2))
with(icensFrame,Hist(time=list(L,R)))

## Interval censored data from a competing risk model
with(icensFrame,Hist(time=list(L,R),event))

## Multi state model
MultiStateFrame &lt;- data.frame(time=1:10,
			      from=c(1,1,3,1,2,4,1,1,2,1),
			      to=c(2,3,1,2,4,2,3,2,4,4))
with(MultiStateFrame,Hist(time,event=list(from,to)))

##  MultiState with right censored observations

MultiStateFrame1 &lt;- data.frame(time=1:10,
			      from=c(1,1,3,2,1,4,1,1,3,1),
			      to=c(2,3,1,0,2,2,3,2,0,4))
with(MultiStateFrame1,Hist(time,event=list(from,to)))

## Using the longitudinal input method 
MultiStateFrame2 &lt;- data.frame(time=c(0,1,2,3,4,0,1,2,0,1),
			      event=c(1,2,3,0,1,2,4,2,1,2),
			      id=c(1,1,1,1,2,2,2,2,3,3))
 with(MultiStateFrame2,Hist(time,event=event,id=id))

</code></pre>

<hr>
<h2 id='jackknife'>Compute jackknife pseudo values.</h2><span id='topic+jackknife'></span><span id='topic+jackknife.survival'></span><span id='topic+jackknife.competing.risks'></span>

<h3>Description</h3>

<p>Compute jackknife pseudo values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife(object, times, cause, keepResponse = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jackknife_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prodlim"</code>.</p>
</td></tr>
<tr><td><code id="jackknife_+3A_times">times</code></td>
<td>
<p>Time points at which to compute pseudo values.</p>
</td></tr>
<tr><td><code id="jackknife_+3A_cause">cause</code></td>
<td>
<p>Character (other classes are converted with <code>as.character</code>).
For competing risks the cause of failure.</p>
</td></tr>
<tr><td><code id="jackknife_+3A_keepresponse">keepResponse</code></td>
<td>
<p>If <code>TRUE</code> add the model response,
i.e. event time, event status, etc. to the result.</p>
</td></tr>
<tr><td><code id="jackknife_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute jackknife pseudo values based on marginal Kaplan-Meier estimate of
survival, or based on marginal Aalen-Johansen estimate of the absolute risks, i.e., the cumulative
incidence function.
</p>


<h3>Note</h3>

<p>The R-package pseudo does a similar job, and appears to be a little faster in small samples, but much slower in large samples. See examples.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>References</h3>

<p>Andersen PK &amp; Perme MP (2010). Pseudo-observations in survival
analysis Statistical Methods in Medical Research, 19(1), 71-99.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## pseudo-values for survival models

d=SimSurv(20) 
f=prodlim(Hist(time,status)~1,data=d) 
jackknife(f,times=c(3,5))

## in some situations it may be useful to attach the
## the event time history to the result
jackknife(f,times=c(3,5),keepResponse=TRUE)

# pseudo-values for competing risk models
set.seed(15)
d=SimCompRisk(15) 
f=prodlim(Hist(time,event)~1,data=d) 
jackknife(f,times=c(3,5),cause=1)
jackknife(f,times=c(1,3,5),cause=2)

</code></pre>

<hr>
<h2 id='leaveOneOut'>Compute jackknife pseudo values.</h2><span id='topic+leaveOneOut'></span><span id='topic+leaveOneOut.survival'></span><span id='topic+leaveOneOut.competing.risks'></span>

<h3>Description</h3>

<p>Compute leave-one-out estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveOneOut(object, times, cause, lag = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaveOneOut_+3A_object">object</code></td>
<td>
<p>Object of class <code>"prodlim"</code>.</p>
</td></tr>
<tr><td><code id="leaveOneOut_+3A_times">times</code></td>
<td>
<p>time points at which to compute leave-one-out
event/survival probabilities.</p>
</td></tr>
<tr><td><code id="leaveOneOut_+3A_cause">cause</code></td>
<td>
<p>Character (other classes are converted with <code>as.character</code>).
For competing risks the cause of interest.</p>
</td></tr>
<tr><td><code id="leaveOneOut_+3A_lag">lag</code></td>
<td>
<p>For survival models only. If <code>TRUE</code> lag the result, i.e. compute
S(t-) instead of S(t).</p>
</td></tr>
<tr><td><code id="leaveOneOut_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the work-horse for <code>jackknife</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jackknife">jackknife</a></code>
</p>

<hr>
<h2 id='List2Matrix'>Reduce list to a matrix or data.frame with names as new columns</h2><span id='topic+List2Matrix'></span>

<h3>Description</h3>

<p>This function is used by summary.prodlim to deal with results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>List2Matrix(list, depth, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="List2Matrix_+3A_list">list</code></td>
<td>
<p>A named list which contains nested lists</p>
</td></tr>
<tr><td><code id="List2Matrix_+3A_depth">depth</code></td>
<td>
<p>The depth in the list hierarchy until an rbindable object</p>
</td></tr>
<tr><td><code id="List2Matrix_+3A_names">names</code></td>
<td>
<p>Names for the list variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reduction is done with rbind.
</p>


<h3>Value</h3>

<p>Matrix or data.frame.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=list(a=data.frame(u=1,b=2,c=3),b=data.frame(u=3,b=4,c=6))
List2Matrix(x,depth=1,"X")
</code></pre>

<hr>
<h2 id='markTime'>Marking product-limit plots at the censored times.</h2><span id='topic+markTime'></span>

<h3>Description</h3>

<p>This function is invoked and controlled by <code>plot.prodlim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markTime(x, times, nlost, pch, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markTime_+3A_x">x</code></td>
<td>
<p>The values of the curves at <code>times</code>.</p>
</td></tr>
<tr><td><code id="markTime_+3A_times">times</code></td>
<td>
<p>The times where there curves are plotted.</p>
</td></tr>
<tr><td><code id="markTime_+3A_nlost">nlost</code></td>
<td>
<p>The number of subjects lost to follow-up (censored) at
<code>times</code>.</p>
</td></tr>
<tr><td><code id="markTime_+3A_pch">pch</code></td>
<td>
<p>The symbol used to mark the curves.</p>
</td></tr>
<tr><td><code id="markTime_+3A_col">col</code></td>
<td>
<p>The color of the symbols.</p>
</td></tr>
<tr><td><code id="markTime_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>points</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly. The arguments can be specified
as <code>atRisk.arg</code> in the call to <code>plot.prodlim</code>.
</p>


<h3>Value</h3>

<p>Nil
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.prodlim">plot.prodlim</a></code>, <code><a href="#topic+confInt">confInt</a></code>,
<code><a href="#topic+atRisk">atRisk</a></code>
</p>

<hr>
<h2 id='meanNeighbors'>Helper function to obtain running means for prodlim objects.</h2><span id='topic+meanNeighbors'></span>

<h3>Description</h3>

<p>Compute average values of a variable according to neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanNeighbors(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanNeighbors_+3A_x">x</code></td>
<td>
<p>Object of class <code>"neighborhood"</code>.</p>
</td></tr>
<tr><td><code id="meanNeighbors_+3A_y">y</code></td>
<td>
<p>Vector of numeric values.</p>
</td></tr>
<tr><td><code id="meanNeighbors_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+neighborhood">neighborhood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
meanNeighbors(x=1:10,y=c(1,10,100,1000,1001,1001,1001,1002,1002,1002))

</code></pre>

<hr>
<h2 id='model.design'>Extract a design matrix and specials from a model.frame</h2><span id='topic+model.design'></span>

<h3>Description</h3>

<p>Extract design matrix and data specials from a model.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.design(
  terms,
  data,
  xlev = NULL,
  dropIntercept = FALSE,
  maxOrder = 1,
  unspecialsDesign = TRUE,
  specialsFactor = FALSE,
  specialsDesign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.design_+3A_terms">terms</code></td>
<td>
<p>terms object as obtained either with function <code>terms</code> or <code>strip.terms</code>.</p>
</td></tr>
<tr><td><code id="model.design_+3A_data">data</code></td>
<td>
<p>A data set in which terms are defined.</p>
</td></tr>
<tr><td><code id="model.design_+3A_xlev">xlev</code></td>
<td>
<p>a named list of character vectors giving the full set of levels to be assumed for the factors.
Can have less elements, in which case the other levels are learned from the <code>data</code>.</p>
</td></tr>
<tr><td><code id="model.design_+3A_dropintercept">dropIntercept</code></td>
<td>
<p>If TRUE drop intercept term from the design
matrix</p>
</td></tr>
<tr><td><code id="model.design_+3A_maxorder">maxOrder</code></td>
<td>
<p>An error is produced if special variables are
involved in interaction terms of order higher than max.order.</p>
</td></tr>
<tr><td><code id="model.design_+3A_unspecialsdesign">unspecialsDesign</code></td>
<td>
<p>A logical value: if <code>TRUE</code> apply
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> to unspecial covariates. If
<code>FALSE</code> extract unspecial covariates from data.</p>
</td></tr>
<tr><td><code id="model.design_+3A_specialsfactor">specialsFactor</code></td>
<td>
<p>A character vector containing special
variables which should be coerced into a single factor. If
<code>TRUE</code> all specials are treated in this way, if <code>FALSE</code>
none of the specials is treated in this way.</p>
</td></tr>
<tr><td><code id="model.design_+3A_specialsdesign">specialsDesign</code></td>
<td>
<p>A character vector containing special
variables which should be transformed into a design matrix via
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.  If <code>TRUE</code> all specials are
treated in this way.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function separates special terms from the unspecial terms and returns
a list of design matrices, one for unspecial terms and one for each special.
Some special specials cannot or should not be evaluated in
data. E.g., <code>y~a+dummy(x)+strata(v)</code> the function strata can and should be evaluated,
but in order to have <code>model.frame</code> also evaluate dummy(x) one would be to define
and export the function <code>dummy</code>. Still the term <code>dummy(x)</code> can be used
to identify a special treatment of the variable <code>x</code>. To deal with this case,
one can specify <code>stripSpecials="dummy"</code>. In addition,  the data
should include variables <code>strata(z)</code> and <code>x</code>, not <code>dummy(x)</code>.
See examples.
The function <code>untangle.specials</code> of the survival function does a similar job.
</p>


<h3>Value</h3>

<p>A list which contains
- the design matrix with the levels of the variables stored in attribute 'levels' 
- separate data.frames which contain the values of the special variables.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EventHistory.frame">EventHistory.frame</a></code> model.frame terms model.matrix .getXlevels
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specials that are evaluated. here ID needs to be defined 
set.seed(8)
d &lt;- data.frame(y=rnorm(5),x=factor(c("a","b","b","a","c")),z=c(2,2,7,7,7),v=sample(letters)[1:5])
d$z &lt;- factor(d$z,levels=c(1:8))
ID &lt;- function(x)x
f &lt;- formula(y~x+ID(z))
t &lt;- terms(f,special="ID",data=d)
mda &lt;- model.design(terms(t),data=d,specialsFactor=TRUE)
mda$ID
mda$design
## 
mdb &lt;- model.design(terms(t),data=d,specialsFactor=TRUE,unspecialsDesign=FALSE)
mdb$ID
mdb$design

# set x-levels
attr(mdb$ID,"levels")
attr(model.design(terms(t),data=d,xlev=list("ID(z)"=1:10),
     specialsFactor=TRUE)$ID,"levels")

# special specials (avoid define function SP)
f &lt;- formula(y~x+SP(z)+factor(v))
t &lt;- terms(f,specials="SP",data=d)
st &lt;- strip.terms(t,specials="SP",arguments=NULL)
md2a &lt;- model.design(st,data=d,specialsFactor=TRUE,specialsDesign="SP")
md2a$SP
md2b &lt;- model.design(st,data=d,specialsFactor=TRUE,specialsDesign=FALSE)
md2b$SP

# special function with argument
f2 &lt;- formula(y~x+treat(z,power=2)+treat(v,power=-1))
t2 &lt;- terms(f2,special="treat")
st2 &lt;- strip.terms(t2,specials="treat",arguments=list("treat"=list("power")))
model.design(st2,data=d,specialsFactor=FALSE)
model.design(st2,data=d,specialsFactor=TRUE)
model.design(st2,data=d,specialsDesign=TRUE)

library(survival)
data(pbc)
t3 &lt;- terms(Surv(time,status!=0)~factor(edema)*age+strata(I(log(bili)&gt;1))+strata(sex),
            specials=c("strata","cluster"))
st3 &lt;- strip.terms(t3,specials=c("strata"),arguments=NULL)
md3 &lt;- model.design(terms=st3,data=pbc[1:4,])
md3$strata
md3$cluster

f4 &lt;- Surv(time,status)~age+const(factor(edema))+strata(sex,test=0)+prop(bili,power=1)+tp(albumin)
t4 &lt;- terms(f4,specials=c("prop","timevar","strata","tp","const"))
st4 &lt;- strip.terms(t4,
                   specials=c("prop","timevar"),
                   unspecials="prop",
                   alias.names=list("timevar"="strata","prop"=c("const","tp")),
                   arguments=list("prop"=list("power"=0),"timevar"=list("test"=0)))
formula(st4)
md4 &lt;- model.design(st4,data=pbc[1:4,],specialsDesign=TRUE)
md4$prop
md4$timevar

</code></pre>

<hr>
<h2 id='neighborhood'>Nearest neighborhoods for kernel smoothing</h2><span id='topic+neighborhood'></span>

<h3>Description</h3>

<p>Nearest neighborhoods for the values of a continuous predictor. The result
is used for the conditional Kaplan-Meier estimator and other conditional
product limit estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood(x, bandwidth = NULL, kernel = "box")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhood_+3A_x">x</code></td>
<td>
<p>Numeric vector &ndash; typically the observations of a continuous random
variate.</p>
</td></tr>
<tr><td><code id="neighborhood_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Controls the distance between neighbors in a neighborhood.
It can be a decimal, i.e.\ the bandwidth, or the string &lsquo;&quot;smooth&quot;&rsquo;, in which
case <code>N^{-1/4}</code> is used, <code>N</code> being the sample size, or <code>NULL</code>
in which case the <code><a href="KernSmooth.html#topic+dpik">dpik</a></code> function of the package KernSmooth is
used to find the optimal bandwidth.</p>
</td></tr>
<tr><td><code id="neighborhood_+3A_kernel">kernel</code></td>
<td>
<p>Only the rectangular kernel (&quot;box&quot;) is implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'neighborhood'.  The value is a list that
includes the unique values of &lsquo;x&rsquo; (<code>values</code>) for which a neighborhood,
consisting of the nearest neighbors, is defined by the first neighbor
(<code>first.nbh</code>) of the usually very long vector <code>neighbors</code> and the
size of the neighborhood (<code>size.nbh</code>).
</p>
<p>Further values are the arguments <code>bandwidth</code>, <code>kernel</code>, the total
sample size <code>n</code> and the number of unique values <code>nu</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Gerds
</p>


<h3>References</h3>

<p>Stute, W. &quot;Asymptotic Normality of Nearest Neighbor Regression
Function Estimates&quot;, <em>The Annals of Statistics</em>, 1984,12,917&ndash;926.
</p>


<h3>See Also</h3>

<p><code><a href="KernSmooth.html#topic+dpik">dpik</a></code>, <code><a href="#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- SimSurv(20)
neighborhood(d$X2)
</code></pre>

<hr>
<h2 id='parseSpecialNames'>Parse special terms</h2><span id='topic+parseSpecialNames'></span>

<h3>Description</h3>

<p>Extract from a vector of character strings the names of special functions and auxiliary arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseSpecialNames(x, special, arguments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseSpecialNames_+3A_x">x</code></td>
<td>
<p>Vector of character strings.</p>
</td></tr>
<tr><td><code id="parseSpecialNames_+3A_special">special</code></td>
<td>
<p>A character string: the name of the special argument.</p>
</td></tr>
<tr><td><code id="parseSpecialNames_+3A_arguments">arguments</code></td>
<td>
<p>A vector which contains the arguments of the special function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Signals an error if an element has more arguments than specified by argument arguments.
</p>


<h3>Value</h3>

<p>A named list of parsed arguments. The names of the list are the special variable names, the elements
are lists of arguments.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>model.design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ignore arguments
parseSpecialNames("treat(Z)",special="treat")
## set default to 0
parseSpecialNames(c("log(Z)","a","log(B)"),special="log",arguments=list("base"=0))
## set default to 0
parseSpecialNames(c("log(Z,3)","a","log(B,base=1)"),special="log",arguments=list("base"=0))
## different combinations of order and names
parseSpecialNames(c("log(Z,3)","a","log(B,1)"),
                  special="log",
                  arguments=list("base"=0))
parseSpecialNames(c("log(Z,1,3)","a","log(B,u=3)"),
                  special="log",
                  arguments=list("base"=0,"u"=1))
parseSpecialNames(c("log(Z,u=1,base=3)","a","log(B,u=3)"),
                  special="log",
                  arguments=list("base"=0,"u"=1))
parseSpecialNames(c("log(Z,u=1,base=3)","a","log(B,base=8,u=3)"),
                  special="log",
                  arguments=list("base"=0,"u"=1))
parseSpecialNames("treat(Z,u=2)",
                  special="treat",
                  arguments=list("u"=1,"k"=1))
parseSpecialNames(c("treat(Z,1,u=2)","treat(B,u=2,k=3)"),
                  special="treat",
                  arguments=list("u"=NA,"k"=NULL))
## does not work to set default to NULL:
parseSpecialNames(c("treat(Z,1,u=2)","treat(B,u=2)"),
                  special="treat",
                  arguments=list("u"=NA,"k"=NULL))
</code></pre>

<hr>
<h2 id='PercentAxis'>Percentage-labeled axis.</h2><span id='topic+PercentAxis'></span>

<h3>Description</h3>

<p>Use percentages instead of decimals to label the an axis with a probability
scale .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PercentAxis(x, at, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PercentAxis_+3A_x">x</code></td>
<td>
<p>Side of the axis</p>
</td></tr>
<tr><td><code id="PercentAxis_+3A_at">at</code></td>
<td>
<p>Positions (decimals) at which to label the axis.</p>
</td></tr>
<tr><td><code id="PercentAxis_+3A_...">...</code></td>
<td>
<p>Given to <code>axis</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.prodlim">plot.prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  plot(0,0,xlim=c(0,1),ylim=c(0,1),axes=FALSE)
  PercentAxis(1,at=seq(0,1,.25))
  PercentAxis(2,at=seq(0,1,.25))

</code></pre>

<hr>
<h2 id='plot.Hist'>Box-arrow diagrams for multi-state models.</h2><span id='topic+plot.Hist'></span>

<h3>Description</h3>

<p>Automated plotting of the states and transitions that characterize a multi
states model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hist'
plot(
  x,
  nrow,
  ncol,
  box.width,
  box.height,
  box.padding,
  xbox.position,
  ybox.position,
  stateLabels,
  arrowLabels,
  arrowLabelStyle = "symbolic",
  arrowLabelSymbol = "lambda",
  changeArrowLabelSide,
  curved,
  tagBoxes = FALSE,
  startCountZero = TRUE,
  oneFitsAll,
  margin,
  cex,
  rasta = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Hist_+3A_x">x</code></td>
<td>
<p>An object of class <code>Hist</code>.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_nrow">nrow</code></td>
<td>
<p>the number of graphic rows</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_ncol">ncol</code></td>
<td>
<p>the number of graphic columns</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_box.width">box.width</code></td>
<td>
<p>the widths of the boxes on the scale from 0 to 100</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_box.height">box.height</code></td>
<td>
<p>the heights of the boxes on the scale from 0 to 100</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_box.padding">box.padding</code></td>
<td>
<p>how much room there should be between the label and the border of a box.
Two values on the scale from 0 to 100: the first for the horizontal
x-direction and the second for the vertical y-direction padding.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_xbox.position">xbox.position</code></td>
<td>
<p>the x box positions (left lower corner) on the scale from 0 to 100.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_ybox.position">ybox.position</code></td>
<td>
<p>the y box positions (left lower corner) on the scale from 0 to 100.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_statelabels">stateLabels</code></td>
<td>
<p>Vector of names to appear in the boxes (states).
Defaults to attr(x,&quot;state.names&quot;).  The boxes can also be
individually labeled by smart arguments of the form
<code>box3.label="diseased"</code>, see examples.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_arrowlabels">arrowLabels</code></td>
<td>
<p>Vector of labels to appear in the boxes
(states). One for each arrow.  The arrows can also be
individually labeled by smart arguments of the form
<code>arrow1.label=paste(expression(eta(s,u)))</code>, see examples.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_arrowlabelstyle">arrowLabelStyle</code></td>
<td>
<p>Either &quot;symbolic&quot; for automated symbolic
arrow labels, or &quot;count&quot; for arrow labels that reflect the
number of transitions in the data.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_arrowlabelsymbol">arrowLabelSymbol</code></td>
<td>
<p>Symbol for automated symbolic arrow
labels. Defaults to &quot;lambda&quot;.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_changearrowlabelside">changeArrowLabelSide</code></td>
<td>
<p>A vector of mode logical (TRUE,FALSE)
one for each arrow to change the side of the arrow on which the
label is placed.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_curved">curved</code></td>
<td>
<p>The curvature of curved arrows via diagram::curvedarrow. Experimental. Values between 0 (no curvature) and 1 are meaningful.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_tagboxes">tagBoxes</code></td>
<td>
<p>Logical. If TRUE the boxes are numbered in the
upper left corner. The size can be controlled with smart
argument boxtags.cex. The default is boxtags.cex=1.28.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_startcountzero">startCountZero</code></td>
<td>
<p>Control states numbers for symbolic arrow
labels and box tags.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_onefitsall">oneFitsAll</code></td>
<td>
<p>If <code>FALSE</code> then boxes have individual size,
depending on the size of the label, otherwise all boxes have
the same size dependent on the largest label.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_margin">margin</code></td>
<td>
<p>Set the figure margin via
<code>par(mar=margin)</code>. Less than 4 values are repeated.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_cex">cex</code></td>
<td>
<p>Initial cex value for the state and the arrow
<code>labels</code>.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_rasta">rasta</code></td>
<td>
<p>For construction purposes.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE echo various things.</p>
</td></tr>
<tr><td><code id="plot.Hist_+3A_...">...</code></td>
<td>
<p>Smart control of arguments for the subroutines text
(box label), rect (box), arrows, text (arrow label). Thus the
three dots can be used to draw individual boxes with individual
labels, arrows and arrow labels. E.g. arrow2.label=&quot;any label&quot;
changes the label of the second arrow.  See examples.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use the functionality of the unix program &lsquo;dot&rsquo;
http://www.graphviz.org/About.php via R package Rgraphviz to
obtain more complex graphs.
</p>


<h3>Author(s)</h3>

<p>Thomas A Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hist">Hist</a></code><code><a href="#topic+SmartControl">SmartControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A simple survival model

SurvFrame &lt;- data.frame(time=1:10,status=c(0,1,1,0,0,1,0,0,1,0))
SurvHist &lt;- with(SurvFrame,Hist(time,status))
plot(SurvHist)
plot(SurvHist,box2.col=2,box2.label="experienced\nR user")
plot(SurvHist,
     box2.col=2,
     box1.label="newby",
     box2.label="experienced\nR user",
     oneFitsAll=FALSE,
     arrow1.length=.5,
     arrow1.label="",
     arrow1.lwd=4)

## change the cex of all box labels:
plot(SurvHist,
     box2.col=2,
     box1.label="newby",
     box2.label="experienced\nR user",
     oneFitsAll=FALSE,
     arrow1.length=.5,
     arrow1.label="",
     arrow1.lwd=4,
     label.cex=1)

## change the cex of single box labels:
plot(SurvHist,
     box2.col=2,
     box1.label="newby",
     box2.label="experienced\nR user",
     oneFitsAll=FALSE,
     arrow1.length=.5,
     arrow1.label="",
     arrow1.lwd=4,
     label1.cex=1,
     label2.cex=2)


## The pbc data set from the survival package
library(survival)
data(pbc)
plot(with(pbc,Hist(time,status)),
     stateLabels=c("randomized","transplant","dead"),
     arrowLabelStyle="count")

## two competing risks
comprisk.model &lt;- data.frame(time=1:3,status=1:3)
CRHist &lt;- with(comprisk.model,Hist(time,status,cens.code=2))
plot(CRHist)
plot(CRHist,arrow1.label=paste(expression(eta(s,u))))

plot(CRHist,box2.label="This\nis\nstate 2",arrow1.label=paste(expression(gamma[1](t))))
plot(CRHist,box3.label="Any\nLabel",arrow2.label="any\nlabel")

## change the layout
plot(CRHist,
     box1.label="Alive",
     box2.label="Dead\n cause 1",
     box3.label="Dead\n cause 2",
     arrow1.label=paste(expression(gamma[1](t))),
     arrow2.label=paste(expression(eta[2](t))),
     box1.col=2,
     box2.col=3,
     box3.col=4,
     nrow=2,
     ncol=3,
     box1.row=1,
     box1.column=2,
     box2.row=2,
     box2.column=1,
     box3.row=2,
     box3.column=3)

## more competing risks
comprisk.model2 &lt;- data.frame(time=1:4,status=1:4)
CRHist2 &lt;- with(comprisk.model2,Hist(time,status,cens.code=2))
plot(CRHist2,box1.row=2)

## illness-death models
illness.death.frame &lt;- data.frame(time=1:4,
				  from=c("Disease\nfree",
                                      "Disease\nfree",
                                      "Diseased",
                                      "Disease\nfree"),
				  to=c("0","Diseased","Dead","Dead"))
IDHist &lt;- with(illness.death.frame,Hist(time,event=list(from,to)))
plot(IDHist)

## illness-death with recovery
illness.death.frame2 &lt;- data.frame(time=1:5,
from=c("Disease\nfree","Disease\nfree","Diseased","Diseased","Disease\nfree"),
to=c("0","Diseased","Disease\nfree","Dead","Dead"))
IDHist2 &lt;- with(illness.death.frame2,Hist(time,event=list(from,to)))
plot(IDHist2)

## 4 state models
x=data.frame(from=c(1,2,1,3,4),to=c(2,1,3,4,1),time=1:5)
y=with(x,Hist(time=time,event=list(from=from,to=to)))
plot(y)

## moving the label of some arrows

d &lt;- data.frame(time=1:5,from=c(1,1,1,2,2),to=c(2,3,4,3,4))
h &lt;- with(d,Hist(time,event=list(from,to)))
plot(h,box.padding=c(5,2),
tagBoxes=TRUE,
stateLabels=c("Remission\nwithout\nGvHD",
    "Remission\nwith\nGvHD",
    "Relapse",
    "Death\nwithout\nrelapse"),
arrowLabelSymbol='alpha',
arrowlabel3.x=35,
arrowlabel3.y=53,
arrowlabel4.y=54,
arrowlabel4.x=68)

##'
</code></pre>

<hr>
<h2 id='plot.prodlim'>Plotting event probabilities over time</h2><span id='topic+plot.prodlim'></span><span id='topic+lines.prodlim'></span>

<h3>Description</h3>

<p>Function to plot survival probabilities or absolute risks (cumulative incidence function) against time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prodlim'
plot(
  x,
  type,
  cause,
  select,
  newdata,
  add = FALSE,
  col,
  lty,
  lwd,
  ylim,
  xlim,
  ylab,
  xlab = "Time",
  num.digits = 2,
  timeconverter,
  legend = TRUE,
  short.labels = TRUE,
  logrank = FALSE,
  marktime = FALSE,
  confint = TRUE,
  automar,
  atrisk = ifelse(add, FALSE, TRUE),
  timeOrigin = 0,
  axes = TRUE,
  background = TRUE,
  percent = TRUE,
  minAtrisk = 0,
  limit = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prodlim_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;prodlim&rsquo; as returned by the
<code>prodlim</code> function.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_type">type</code></td>
<td>
<p>Either <code>"surv"</code> or <code>"risk"</code> AKA <code>"cuminc"</code>. Controls what
part of the object is plotted.  Defaults to <code>object$type</code>.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_cause">cause</code></td>
<td>
<p>For competing risk models. Character (other classes are converted with <code>as.character</code>).
The argument <code>cause</code> determines the event of interest. Currently one cause is allowed at a time, but you can
call the function again with <code>add=TRUE</code> to add the lines of the other
causes. Also, if <code>cause="stacked"</code> is specified the absolute risks of all causes are stacked.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_select">select</code></td>
<td>
<p>Select which lines to plot. This can be used when
there are many strata or many competing risks to select a
subset of the lines.  However, a more clean way to select
covariate strata is to use the argument <code>newdata</code>. Another
application is when there are several competing risks and the 
stacked plot (<code>cause="stacked"</code>) should only show a selected subset
of the available causes.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing covariate strata for which
to show curves. When omitted element <code>X</code> of object
<code>x</code> is used.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> curves are added to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_col">col</code></td>
<td>
<p>color for curves. Default is <code>1:number(curves)</code></p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_lty">lty</code></td>
<td>
<p>line type for curves. Default is 1.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_lwd">lwd</code></td>
<td>
<p>line width for all curves. Default is 3.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_ylim">ylim</code></td>
<td>
<p>limits of the y-axis</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_xlim">xlim</code></td>
<td>
<p>limits of the x-axis</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_num.digits">num.digits</code></td>
<td>
<p>Number of digits when rounding off numerical values for legend and at-risk tables.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_timeconverter">timeconverter</code></td>
<td>
<p>The following options are supported:
&quot;days2years&quot; (conversion factor: 1/365.25)
&quot;months2years&quot; (conversion factor: 1/12)
&quot;days2months&quot; (conversion factor 1/30.4368499)
&quot;years2days&quot; (conversion factor 365.25)
&quot;years2months&quot; (conversion factor 12)
&quot;months2days&quot; (conversion factor 30.4368499)</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_legend">legend</code></td>
<td>
<p>if TRUE a legend is plotted by calling the function
legend.  Optional arguments of the function <code>legend</code> can
be given in the form <code>legend.x=val</code> where x is the name of
the argument and val the desired value. See also Details.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_short.labels">short.labels</code></td>
<td>
<p>Logical. When <code>FALSE</code> construct labels as cause=1, var1=v1, var2=v2 else as 1, v1, v2.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_logrank">logrank</code></td>
<td>
<p>If TRUE, the logrank p-value will be extracted from
a call to <code>survdiff</code> and added to the legend. This works
only for survival models, i.e. Kaplan-Meier with discrete
predictors.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_marktime">marktime</code></td>
<td>
<p>if TRUE the curves are tick-marked at right
censoring times by invoking the function
<code>markTime</code>. Optional arguments of the function
<code>markTime</code> can be given in the form <code>confint.x=val</code>
as with legend. See also Details.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_confint">confint</code></td>
<td>
<p>if TRUE pointwise confidence intervals are plotted
by invoking the function <code>confInt</code>. Optional arguments of
the function <code>confInt</code> can be given in the form
<code>confint.x=val</code> as with legend.  See also Details.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_automar">automar</code></td>
<td>
<p>If TRUE the function trys to find suitable values
for the figure margins around the main plotting region.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_atrisk">atrisk</code></td>
<td>
<p>if TRUE display numbers of subjects at risk by
invoking the function <code>atRisk</code>. Optional arguments of the
function <code>atRisk</code> can be given in the form
<code>atrisk.x=val</code> as with legend. See also Details.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_timeorigin">timeOrigin</code></td>
<td>
<p>Start of the time axis</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_axes">axes</code></td>
<td>
<p>If true axes are drawn. See details.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_background">background</code></td>
<td>
<p>If <code>TRUE</code> the background color and grid
color can be controlled using smart arguments SmartControl,
such as background.bg=&quot;yellow&quot; or
background.bg=c(&quot;gray66&quot;,&quot;gray88&quot;).  The following defaults are
passed to <code>background</code> by <code>plot.prodlim</code>:
horizontal=seq(0,1,.25), vertical=NULL, bg=&quot;gray77&quot;,
fg=&quot;white&quot;.  See <code>background</code> for all arguments, and the
examples below.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_percent">percent</code></td>
<td>
<p>If true the y-axis is labeled in percent.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_minatrisk">minAtrisk</code></td>
<td>
<p>Integer. Show the curve only until the number
at-risk is at least <code>minAtrisk</code></p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_limit">limit</code></td>
<td>
<p>When newdata is not specified and the number of lines
in element <code>X</code> of object <code>x</code> exceeds limits, only the
results for covariate constellations of the first, the middle
and the last row in <code>X</code> are shown. Otherwise all lines of
<code>X</code> are shown.</p>
</td></tr>
<tr><td><code id="plot.prodlim_+3A_...">...</code></td>
<td>
<p>Parameters that are filtered by
<code><a href="#topic+SmartControl">SmartControl</a></code> and then passed to the functions
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+legend">legend</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="#topic+atRisk">atRisk</a></code>, <code><a href="#topic+confInt">confInt</a></code>,
<code><a href="#topic+markTime">markTime</a></code>, <code><a href="#topic+backGround">backGround</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>From version 1.1.3 on the arguments legend.args, atrisk.args, confint.args
are obsolete and only available for backward compatibility. Instead
arguments for the invoked functions <code>atRisk</code>, <code>legend</code>,
<code>confInt</code>, <code>markTime</code>, <code>axis</code> are simply specified as
<code>atrisk.cex=2</code>. The specification is not case sensitive, thus
<code>atRisk.cex=2</code> or <code>atRISK.cex=2</code> will have the same effect.  The
function <code>axis</code> is called twice, and arguments of the form
<code>axis1.labels</code>, <code>axis1.at</code> are used for the time axis whereas
<code>axis2.pos</code>, <code>axis1.labels</code>, etc. are used for the y-axis.
</p>
<p>These arguments are processed via <code>...{}</code> of <code>plot.prodlim</code> and
inside by using the function <code>SmartControl</code>.  Documentation of these
arguments can be found in the help pages of the corresponding functions.
</p>


<h3>Value</h3>

<p>The (invisible) object.
</p>


<h3>Note</h3>

<p>Similar functionality is provided by the function
<code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> of the survival library
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+legend">legend</a></code>,
<code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="#topic+prodlim">prodlim</a></code>,<code><a href="#topic+plot.Hist">plot.Hist</a></code>,<code><a href="#topic+summary.prodlim">summary.prodlim</a></code>,
<code><a href="#topic+neighborhood">neighborhood</a></code>, <code><a href="#topic+atRisk">atRisk</a></code>,
<code><a href="#topic+confInt">confInt</a></code>, <code><a href="#topic+markTime">markTime</a></code>,
<code><a href="#topic+backGround">backGround</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate right censored data from a two state model 
set.seed(100)
dat &lt;- SimSurv(100)
# with(dat,plot(Hist(time,status)))

### marginal Kaplan-Meier estimator
kmfit &lt;- prodlim(Hist(time, status) ~ 1, data = dat)
plot(kmfit)
plot(kmfit,atrisk.show.censored=1L,atrisk.at=seq(0,12,3))
plot(kmfit,timeconverter="years2months")

# change time range
plot(kmfit,xlim=c(0,4))

# change scale of y-axis
plot(kmfit,percent=FALSE)

# mortality instead of survival
plot(kmfit,type="risk")

# change axis label and position of ticks
plot(kmfit,
     xlim=c(0,10),
     axis1.at=seq(0,10,1),
     axis1.labels=0:10,
     xlab="Years",
     axis2.las=2,
     atrisk.at=seq(0,10,2.5),
     atrisk.title="")

# change background color
plot(kmfit,
     xlim=c(0,10),
     confint.citype="shadow",
     col=1,
     axis1.at=0:10,
     axis1.labels=0:10,
     xlab="Years",
     axis2.las=2,
     atrisk.at=seq(0,10,2.5),
     atrisk.title="",
     background=TRUE,
     background.fg="white",
     background.horizontal=seq(0,1,.25/2),
     background.vertical=seq(0,10,2.5),
     background.bg=c("gray88"))

# change type of confidence limits
plot(kmfit,
     xlim=c(0,10),
     confint.citype="dots",
     col=4,
     background=TRUE,
     background.bg=c("white","gray88"),
     background.fg="gray77",
     background.horizontal=seq(0,1,.25/2),
     background.vertical=seq(0,10,2))


### Kaplan-Meier in discrete strata
kmfitX &lt;- prodlim(Hist(time, status) ~ X1, data = dat)
plot(kmfitX,atrisk.show.censored=1L)
# move legend
plot(kmfitX,legend.x="bottomleft",atRisk.cex=1.3,
     atrisk.title="No. subjects")

## Control the order of strata
## since version 1.5.1 prodlim does  obey the order of
## factor levels
dat$group &lt;- factor(cut(dat$X2,c(-Inf,0,0.5,Inf)),
                    labels=c("High","Intermediate","Low"))
kmfitG &lt;- prodlim(Hist(time, status) ~ group, data = dat)
plot(kmfitG)

## relevel 
dat$group2 &lt;- factor(cut(dat$X2,c(-Inf,0,0.5,Inf)),
                     levels=c("(0.5, Inf]","(0,0.5]","(-Inf,0]"),
                     labels=c("Low","Intermediate","High"))
kmfitG2 &lt;- prodlim(Hist(time, status) ~ group2, data = dat)
plot(kmfitG2)

# add log-rank test to legend
plot(kmfitX,
     atRisk.cex=1.3,
     logrank=TRUE,
     legend.x="topright",
     atrisk.title="at-risk")

# change atrisk labels
plot(kmfitX,
     legend.x="bottomleft",
     atrisk.title="Patients",
     atrisk.cex=0.9,
     atrisk.labels=c("X1=0","X1=1"))

# multiple categorical factors

kmfitXG &lt;- prodlim(Hist(time,status)~X1+group2,data=dat)
plot(kmfitXG,select=1:2)

### Kaplan-Meier in continuous strata
kmfitX2 &lt;- prodlim(Hist(time, status) ~ X2, data = dat)
plot(kmfitX2,xlim=c(0,10))

# specify values of X2 for which to show the curves 
plot(kmfitX2,xlim=c(0,10),newdata=data.frame(X2=c(-1.8,0,1.2)))

### Cluster-correlated data
library(survival)
cdat &lt;- cbind(SimSurv(20),patnr=sample(1:5,size=20,replace=TRUE))
kmfitC &lt;- prodlim(Hist(time, status) ~ cluster(patnr), data = cdat)
plot(kmfitC)
plot(kmfitC,atrisk.labels=c("Units","Patients"))

kmfitC2 &lt;- prodlim(Hist(time, status) ~ X1+cluster(patnr), data = cdat)
plot(kmfitC2)
plot(kmfitC2,atrisk.labels=c("Teeth","Patients","Teeth","Patients"),
     atrisk.col=c(1,1,2,2))


### Cluster-correlated data with strata
n = 50
foo = runif(n)
bar = rexp(n)
baz = rexp(n,1/2)
d = stack(data.frame(foo,bar,baz))
d$cl = sample(10, 3*n, replace=TRUE)
fit = prodlim(Surv(values) ~ ind + cluster(cl), data=d)
plot(fit)


## simulate right censored data from a competing risk model 
datCR &lt;- SimCompRisk(100)
with(datCR,plot(Hist(time,event)))

### marginal Aalen-Johansen estimator
ajfit &lt;- prodlim(Hist(time, event) ~ 1, data = datCR)
plot(ajfit) # same as plot(ajfit,cause=1)
plot(ajfit,atrisk.show.censored=1L)

# cause 2
plot(ajfit,cause=2)

# both in one
plot(ajfit,cause=1)
plot(ajfit,cause=2,add=TRUE,col=2)

### stacked plot

plot(ajfit,cause="stacked",select=2)

### stratified Aalen-Johansen estimator
ajfitX1 &lt;- prodlim(Hist(time, event) ~ X1, data = datCR)
plot(ajfitX1)

## add total number at-risk to a stratified curve
ttt = 1:10
plot(ajfitX1,atrisk.at=ttt,col=2:3)
plot(ajfit,add=TRUE,col=1)
atRisk(ajfit,newdata=datCR,col=1,times=ttt,line=3,labels="Total")


## stratified Aalen-Johansen estimator in nearest neighborhoods
## of a continuous variable
ajfitX &lt;- prodlim(Hist(time, event) ~ X1+X2, data = datCR)
plot(ajfitX,newdata=data.frame(X1=c(1,1,0),X2=c(4,10,10)))
plot(ajfitX,newdata=data.frame(X1=c(1,1,0),X2=c(4,10,10)),cause=2)

## stacked plot

plot(ajfitX,
     newdata=data.frame(X1=0,X2=0.1),
     cause="stacked",
     legend.title="X1=0,X2=0.1",
     legend.legend=paste("cause:",getStates(ajfitX$model.response)),
     plot.main="Subject specific stacked plot")
 
</code></pre>

<hr>
<h2 id='plotCompetingRiskModel'>Plotting a competing-risk-model.</h2><span id='topic+plotCompetingRiskModel'></span>

<h3>Description</h3>

<p>Plotting a competing-risk-model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCompetingRiskModel(stateLabels, horizontal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCompetingRiskModel_+3A_statelabels">stateLabels</code></td>
<td>
<p>Labels for the boxes.</p>
</td></tr>
<tr><td><code id="plotCompetingRiskModel_+3A_horizontal">horizontal</code></td>
<td>
<p>The orientation of the plot.</p>
</td></tr>
<tr><td><code id="plotCompetingRiskModel_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+plot.Hist">plot.Hist</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotIllnessDeathModel">plotIllnessDeathModel</a></code>, <code><a href="#topic+plot.Hist">plot.Hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotCompetingRiskModel()
plotCompetingRiskModel(labels=c("a","b"))
plotCompetingRiskModel(labels=c("a","b","c"))

</code></pre>

<hr>
<h2 id='plotIllnessDeathModel'>Plotting an illness-death-model.</h2><span id='topic+plotIllnessDeathModel'></span>

<h3>Description</h3>

<p>Plotting an illness-death-model using <code>plot.Hist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIllnessDeathModel(stateLabels, style = 1, recovery = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIllnessDeathModel_+3A_statelabels">stateLabels</code></td>
<td>
<p>Labels for the three boxes.</p>
</td></tr>
<tr><td><code id="plotIllnessDeathModel_+3A_style">style</code></td>
<td>
<p>Either <code>1</code> or anything else, switches the orientation of
the graph. Hard to explain in words, see examples.</p>
</td></tr>
<tr><td><code id="plotIllnessDeathModel_+3A_recovery">recovery</code></td>
<td>
<p>Logical. If <code>TRUE</code> there will be an arrow from the
illness state to the initial state.</p>
</td></tr>
<tr><td><code id="plotIllnessDeathModel_+3A_...">...</code></td>
<td>
<p>Arguments passed to plot.Hist.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCompetingRiskModel">plotCompetingRiskModel</a></code>, <code><a href="#topic+plot.Hist">plot.Hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotIllnessDeathModel()
plotIllnessDeathModel(style=2)
plotIllnessDeathModel(style=2,
                      stateLabels=c("a","b\nc","d"),
                      box1.col="yellow",
                      box2.col="green",
                      box3.col="red")
</code></pre>

<hr>
<h2 id='predict.prodlim'>Predicting event probabilities from product limit estimates</h2><span id='topic+predict.prodlim'></span><span id='topic+predictSurv'></span><span id='topic+predictAbsrisk'></span><span id='topic+predictCuminc'></span>

<h3>Description</h3>

<p>Evaluation of estimated survival or event probabilities at given times and
covariate constellations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prodlim'
predict(
  object,
  times,
  newdata,
  level.chaos = 1,
  type = c("surv", "risk", "cuminc", "list"),
  mode = "list",
  bytime = FALSE,
  cause,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.prodlim_+3A_object">object</code></td>
<td>
<p>A fitted object of class &quot;prodlim&quot;.</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated probabilities (survival or absolute event risks).</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that
appear on the right hand side of the 'prodlim' formula.  If there are
covariates this argument is required.</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_level.chaos">level.chaos</code></td>
<td>
<p>Integer specifying the sorting of the output: &lsquo;0&rsquo; sort by
time and newdata; &lsquo;1&rsquo; only by time; &lsquo;2&rsquo; no sorting at all</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_type">type</code></td>
<td>
<p>Choice between &quot;surv&quot;,&quot;risk&quot;,&quot;cuminc&quot;,&quot;list&quot;:
</p>
<p>&quot;surv&quot;: predict survival probabilities only survival models
</p>
<p>&quot;risk&quot;/&quot;cuminc&quot;: predict absolute risk, i.e., cumulative incidence function.
</p>
<p>&quot;list&quot;: find the indices corresponding to times and newdata. See value.
</p>
<p>Defaults to &quot;surv&quot; for two-state models and to &quot;risk&quot; for competing risk
models.</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_mode">mode</code></td>
<td>
<p>Only for <code>type=="surv"</code> and <code>type=="risk"</code>. Can
either be &quot;list&quot; or &quot;matrix&quot;. For &quot;matrix&quot; the predicted probabilities will
be returned in matrix form.</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_bytime">bytime</code></td>
<td>
<p>Logical. If TRUE and <code>mode=="matrix"</code> the matrix with
predicted probabilities will have a column for each time and a row for each
newdata. Only when <code>object$covariate.type&gt;1</code> and more than one time is
given.</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_cause">cause</code></td>
<td>
<p>Character (other classes are converted with <code>as.character</code>).
The cause for predicting the absolute risk of an event, i.e., the cause-specific cumulative
incidence function, in competing risk models. At any time after time zero this is the absolute risk of 
an event of type <code>cause</code> to occur between time zero and <code>times</code> .</p>
</td></tr>
<tr><td><code id="predict.prodlim_+3A_...">...</code></td>
<td>
<p>Only for compatibility reasons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicted (survival) probabilities are returned that can be plotted,
summarized and used for inverse of probability of censoring weighting.
</p>


<h3>Value</h3>

<p><code>type=="surv"</code> A list or a matrix with survival probabilities
for all times and all newdata.
</p>
<p><code>type=="risk"</code> or <code>type=="cuminc"</code> A list or a matrix with cumulative incidences for all
times and all newdata.
</p>
<p><code>type=="list"</code> A list with the following components:
</p>
<table>
<tr><td><code>times</code></td>
<td>
<p>The argument <code>times</code> carried forward</p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>The relevant part of the argument <code>newdata</code>.</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p> A list with the following components
</p>
<p><code>time</code>: Where to find values corresponding to the requested times
<code>strata</code>: Where to find values corresponding to the values of the
variables in newdata.  Together time and strata show where to find the
predicted probabilities.  </p>
</td></tr> <tr><td><code>dimensions</code></td>
<td>
<p> a list with the following
components: <code>time</code> : The length of <code>times</code> <code>strata</code> : The
number of rows in <code>newdata</code> <code>names.strata</code> : Labels for the
covariate values.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictSurvIndividual">predictSurvIndividual</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

dat &lt;- SimSurv(400)
fit &lt;- prodlim(Hist(time,status)~1,data=dat)

## predict the survival probs at selected times 
predict(fit,times=c(3,5,10))

## NA is returned when the time point is beyond the
## range of definition of the Kaplan-Meier estimator:
predict(fit,times=c(-1,0,10,100,1000,10000))

## when there are strata, newdata is required 
## or neighborhoods (i.e. overlapping strata)
mfit &lt;- prodlim(Hist(time,status)~X1+X2,data=dat)
predict(mfit,times=c(-1,0,10,100,1000,10000),newdata=dat[18:21,])

## this can be requested in matrix form
predict(mfit,times=c(-1,0,10,100,1000,10000),newdata=dat[18:21,],mode="matrix")

## and even transposed
predict(mfit,times=c(-1,0,10,100,1000,10000),newdata=dat[18:21,],mode="matrix",bytime=TRUE)

</code></pre>

<hr>
<h2 id='predictSurvIndividual'>Predict individual survival probabilities</h2><span id='topic+predictSurvIndividual'></span>

<h3>Description</h3>

<p>Function to extract the predicted probabilities at the individual event
times that have been used for fitting a prodlim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictSurvIndividual(object, lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSurvIndividual_+3A_object">object</code></td>
<td>
<p>A fitted object of class &quot;prodlim&quot;.</p>
</td></tr>
<tr><td><code id="predictSurvIndividual_+3A_lag">lag</code></td>
<td>
<p>Integer. &lsquo;0&rsquo; means predictions at the individual times, 1 means
just before the individual times, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of survival probabilities.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.prodlim">predict.prodlim</a></code>,<code><a href="#topic+predictSurv">predictSurv</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 SurvFrame &lt;- data.frame(time=1:10,status=rbinom(10,1,.5))
 x &lt;- prodlim(formula=Hist(time=time,status!=0)~1,data=SurvFrame)
 predictSurvIndividual(x,lag=1)

</code></pre>

<hr>
<h2 id='print.prodlim'>Print objects in the prodlim library</h2><span id='topic+print.prodlim'></span><span id='topic+print.neighborhood'></span><span id='topic+print.Hist'></span>

<h3>Description</h3>

<p>Pretty printing of objects created with the functionality of the &lsquo;prodlim&rsquo;
library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prodlim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prodlim_+3A_x">x</code></td>
<td>
<p>Object of class <code>prodlim</code>, <code>Hist</code> and
<code>neighborhood</code>.</p>
</td></tr>
<tr><td><code id="print.prodlim_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.prodlim">summary.prodlim</a></code>, <code><a href="#topic+predict.prodlim">predict.prodlim</a></code>
</p>

<hr>
<h2 id='prodlim'>product limit method</h2><span id='topic+prodlim'></span>

<h3>Description</h3>

<p>Nonparametric estimation in event history analysis. Featuring fast
algorithms and user friendly syntax adapted from the survival package.  The
product limit algorithm is used for right censored data; the
self-consistency algorithm for interval censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodlim(
  formula,
  data = parent.frame(),
  subset,
  na.action = NULL,
  reverse = FALSE,
  conf.int = 0.95,
  bandwidth = NULL,
  caseweights,
  discrete.level = 3,
  x = TRUE,
  maxiter = 1000,
  grid,
  tol = 7,
  method = c("npmle", "one.step", "impute.midpoint", "impute.right"),
  exact = TRUE,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodlim_+3A_formula">formula</code></td>
<td>
<p>A formula whose left hand side is a <code>Hist</code>
object. In some special cases it can also be a <code>Surv</code>
response object, see the details section. The right hand side is
as usual a linear combination of covariates which may contain at
most one continuous factor. Whether or not a covariate is
recognized as continuous or discrete depends on its class and on
the argument <code>discrete.level</code>. The right hand side may also
be used to specify clusters, see the details section.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_data">data</code></td>
<td>
<p>A data.frame in which all the variables of
<code>formula</code> can be interpreted.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_subset">subset</code></td>
<td>
<p>Passed as argument <code>subset</code> to function
<code>subset</code> which applied to <code>data</code> before the formula is
processed.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_na.action">na.action</code></td>
<td>
<p>All lines in data with any missing values in the
variables of formula are removed.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_reverse">reverse</code></td>
<td>
<p>For right censored data, if reverse=TRUE then the
censoring distribution is estimated.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_conf.int">conf.int</code></td>
<td>
<p>The level (between 0 and 1) for two-sided
pointwise confidence intervals. Defaults to 0.95. Remark: only
plain Wald-type confidence limits are available.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Smoothing parameter for nearest neighborhoods
based on the values of a continuous covariate. See function
<code>neighborhood</code> for details.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_caseweights">caseweights</code></td>
<td>
<p>Weights applied to the contribution of each
subject to change the number of events and the number at
risk. This can be used for bootstrap and survey analysis. Should
be a vector of the same length and the same order as <code>data</code>.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_discrete.level">discrete.level</code></td>
<td>
<p>Numeric covariates are treated as factors
when their number of unique values exceeds not
<code>discrete.level</code>. Otherwise the product limit method is
applied, in overlapping neighborhoods according to the bandwidth.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_x">x</code></td>
<td>
<p>logical value: if <code>TRUE</code>, the full covariate matrix
with is returned in component <code>model.matrix</code>.  The reduced
matrix contains unique rows of the full covariate matrix and is
always returned in component <code>X</code>.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_maxiter">maxiter</code></td>
<td>
<p>For interval censored data only.  Maximal number of
iterations to obtain the nonparametric maximum likelihood
estimate.  Defaults to 1000.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_grid">grid</code></td>
<td>
<p>For interval censored data only. When method=one.step
grid for one-step product limit estimate. Defaults to sorted list
of unique left and right endpoints of the observed intervals.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_tol">tol</code></td>
<td>
<p>For interval censored data only. Numeric value whose
negative exponential is used as convergence criterion for finding
the nonparametric maximum likelihood estimate.  Defaults to 7
meaning exp(-7).</p>
</td></tr>
<tr><td><code id="prodlim_+3A_method">method</code></td>
<td>
<p>For interval censored data only.  If equal to
<code>"npmle"</code> (the default) use the usual Turnbull algorithm,
else the product limit version of the self-consistent estimate.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_exact">exact</code></td>
<td>
<p>If TRUE the grid of time points used for estimation
includes all the L and R endpoints of the observed intervals.</p>
</td></tr>
<tr><td><code id="prodlim_+3A_type">type</code></td>
<td>
<p>In two state models either <code>"surv"</code> for the Kaplan-Meier estimate of the survival
function or <code>"risk"</code> for 1-Kaplan-Meier. Default is <code>"surv"</code> when <code>reverse==FALSE</code> and <code>"risk"</code> when <code>reverse==TRUE</code>.
In competing risks models it has to be <code>"risk"</code>
Aalen-Johansen estimate of the cumulative incidence function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The response of <code>formula</code> (ie the left hand side of the &lsquo;~&rsquo; operator)
specifies the model.
</p>
<p>In two-state models &ndash; the classical survival case &ndash; the standard
Kaplan-Meier method is applied.  For this the response can be specified as a
<code><a href="survival.html#topic+Surv">Surv</a></code> or as a <code><a href="#topic+Hist">Hist</a></code> object. The <code><a href="#topic+Hist">Hist</a></code>
function allows you to change the code for censored observations, e.g.
<code>Hist(time,status,cens.code="4")</code>.
</p>
<p>Besides a slight gain of computing efficiency, there are some extensions
that are not included in the current version of the survival package:
</p>
<p>(0) The Kaplan-Meier estimator for the censoring times <code>reverse=TRUE</code>
is correctly estimated when there are ties between event and censoring
times.
</p>
<p>(1) A conditional version of the kernel smoothed Kaplan-Meier estimator for at most one
continuous predictors using nearest neighborhoods (Beran 1981,
Stute 1984, Akritas 1994).
</p>
<p>(2) For cluster-correlated data the right hand side of <code>formula</code> may
identify a <code><a href="survival.html#topic+cluster">cluster</a></code> variable. In that case Greenwood's variance
formula is replaced by the formula of Ying and Wei (1994).
</p>
<p>(3) Competing risk models can be specified via <code><a href="#topic+Hist">Hist</a></code> response
objects in <code>formula</code>.
</p>
<p>The Aalen-Johansen estimator is applied for estimating the absolute risk of the competing causes, i.e., the cumulative
incidence functions. 
</p>
<p>Under construction:
</p>
<p>(U0) Interval censored event times specified via <code><a href="#topic+Hist">Hist</a></code> are used
to find the nonparametric maximum likelihood estimate. Currently this works
only for two-state models and the results should match with those from the
package &lsquo;Icens&rsquo;.
</p>
<p>(U1) Extensions to more complex multi-states models
</p>
<p>(U2) The nonparametric maximum likelihood estimate for interval censored
observations of competing risks models.
</p>


<h3>Value</h3>

<p>Object of class &quot;prodlim&quot;. See <code><a href="#topic+print.prodlim">print.prodlim</a></code>, <code><a href="#topic+predict.prodlim">predict.prodlim</a></code>, predict,
<code><a href="#topic+summary.prodlim">summary.prodlim</a></code>, <code><a href="#topic+plot.prodlim">plot.prodlim</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Andersen, Borgan, Gill, Keiding (1993) Springer 'Statistical
Models Based on Counting Processes'
</p>
<p>Akritas (1994) The Annals of Statistics 22, 1299-1327 Nearest neighbor
estimation of a bivariate distribution under random censoring.
</p>
<p>R Beran (1981) http://anson.ucdavis.edu/~beran/paper.html 'Nonparametric
regression with randomly censored survival data'
</p>
<p>Stute (1984) The Annals of Statistics 12, 917&ndash;926 'Asymptotic Normality of
Nearest Neighbor Regression Function Estimates'
</p>
<p>Ying, Wei (1994) Journal of Multivariate Analysis 50, 17-29 The Kaplan-Meier
estimate for dependent failure time observations
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictSurv">predictSurv</a></code>, <code><a href="#topic+predictSurvIndividual">predictSurvIndividual</a></code>,
<code><a href="#topic+predictAbsrisk">predictAbsrisk</a></code>, <code><a href="#topic+Hist">Hist</a></code>, <code><a href="#topic+neighborhood">neighborhood</a></code>,
<code><a href="survival.html#topic+Surv">Surv</a></code>, <code><a href="survival.html#topic+survfit">survfit</a></code>, <code><a href="survival.html#topic+strata">strata</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##---------------------two-state survival model------------
dat &lt;- SimSurv(30)
with(dat,plot(Hist(time,status)))
fit &lt;- prodlim(Hist(time,status)~1,data=dat)
print(fit)
plot(fit)
summary(fit)
quantile(fit)

## Subset
fit1a &lt;- prodlim(Hist(time,status)~1,data=dat,subset=dat$X1==1)
fit1b &lt;- prodlim(Hist(time,status)~1,data=dat,subset=dat$X1==1 &amp; dat$X2&gt;0)

## --------------------clustered data---------------------
library(survival)
cdat &lt;- cbind(SimSurv(30),patnr=sample(1:5,size=30,replace=TRUE))
fit &lt;- prodlim(Hist(time,status)~cluster(patnr),data=cdat)
print(fit)
plot(fit)
summary(fit)


##-----------compare Kaplan-Meier to survival package---------

dat &lt;- SimSurv(30)
pfit &lt;- prodlim(Surv(time,status)~1,data=dat)
pfit &lt;- prodlim(Hist(time,status)~1,data=dat) ## same thing
sfit &lt;- survfit(Surv(time,status)~1,data=dat,conf.type="plain")
##  same result for the survival distribution function 
all(round(pfit$surv,12)==round(sfit$surv,12))
summary(pfit,digits=3)
summary(sfit,times=quantile(unique(dat$time)))

##-----------estimating the censoring survival function----------------

rdat &lt;- data.frame(time=c(1,2,3,3,3,4,5,5,6,7),status=c(1,0,0,1,0,1,0,1,1,0))
rpfit &lt;- prodlim(Hist(time,status)~1,data=rdat,reverse=TRUE)
rsfit &lt;- survfit(Surv(time,1-status)~1,data=rdat,conf.type="plain")
## When there are ties between times at which events are observed
## times at which subjects are right censored, then the convention
## is that events come first. This is not obeyed by the above call to survfit,
## and hence only prodlim delivers the correct reverse Kaplan-Meier:
cbind("Wrong:"=rsfit$surv,"Correct:"=rpfit$surv)

##-------------------stratified Kaplan-Meier---------------------

pfit.X2 &lt;- prodlim(Surv(time,status)~X2,data=dat)
summary(pfit.X2)
summary(pfit.X2,intervals=TRUE)
plot(pfit.X2)

##----------continuous covariate: Stone-Beran estimate------------

prodlim(Surv(time,status)~X1,data=dat)

##-------------both discrete and continuous covariates------------

prodlim(Surv(time,status)~X2+X1,data=dat)

##----------------------interval censored data----------------------

dat &lt;- data.frame(L=1:10,R=c(2,3,12,8,9,10,7,12,12,12),status=c(1,1,0,1,1,1,1,0,0,0))
with(dat,Hist(time=list(L,R),event=status))

dat$event=1
npmle.fitml &lt;- prodlim(Hist(time=list(L,R),event)~1,data=dat)

##-------------competing risks-------------------

CompRiskFrame &lt;- data.frame(time=1:100,event=rbinom(100,2,.5),X=rbinom(100,1,.5))
crFit &lt;- prodlim(Hist(time,event)~X,data=CompRiskFrame)
summary(crFit)
plot(crFit)
summary(crFit,cause=2)
plot(crFit,cause=2)


# Changing the cens.code:
dat &lt;- data.frame(time=1:10,status=c(1,2,1,2,5,5,1,1,2,2))
fit &lt;- prodlim(Hist(time,status)~1,data=dat)
print(fit$model.response)
fit &lt;- prodlim(Hist(time,status,cens.code="2")~1,data=dat)
print(fit$model.response)
plot(fit)
plot(fit,cause="5")


##------------delayed entry----------------------

## left-truncated event times with competing risk endpoint 

dat &lt;- data.frame(entry=c(7,3,11,12,11,2,1,7,15,17,3),time=10:20,status=c(1,0,2,2,0,0,1,2,0,2,0))
fitd &lt;- prodlim(Hist(time=time,event=status,entry=entry)~1,data=dat)
summary(fitd)
plot(fitd)

</code></pre>

<hr>
<h2 id='prodlim-package'>Kaplan-Meier and Aalen-Johansen method</h2><span id='topic+prodlim-package'></span>

<h3>Description</h3>

<p>Fast and user friendly implementation
of nonparametric estimators for censored
event history (survival) analysis.
</p>

<hr>
<h2 id='quantile.prodlim'>Quantiles for Kaplan-Meier and Aalen-Johansen estimates.</h2><span id='topic+quantile.prodlim'></span>

<h3>Description</h3>

<p>Quantiles for Kaplan-Meier and Aalen-Johansen estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prodlim'
quantile(x, q, cause = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.prodlim_+3A_x">x</code></td>
<td>
<p>Object of class <code>"prodlim"</code>.</p>
</td></tr>
<tr><td><code id="quantile.prodlim_+3A_q">q</code></td>
<td>
<p>Quantiles. Vector of values between 0 and 1.</p>
</td></tr>
<tr><td><code id="quantile.prodlim_+3A_cause">cause</code></td>
<td>
<p>For competing risks the cause of interest.</p>
</td></tr>
<tr><td><code id="quantile.prodlim_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
set.seed(1)
d=SimSurv(30)

# Quantiles of the potential followup time
g=prodlim(Hist(time,status)~1,data=d,reverse=TRUE)
quantile(g)

# survival time
f=prodlim(Hist(time,status)~1,data=d)
f1=prodlim(Hist(time,status)~X1,data=d)
# default: median and IQR
quantile(f)
quantile(f1)
# median alone
quantile(f,.5)
quantile(f1,.5)

# competing risks
set.seed(3)
dd = SimCompRisk(30)
ff=prodlim(Hist(time,event)~1,data=dd)
ff1=prodlim(Hist(time,event)~X1,data=dd)
## default: median and IQR
quantile(ff)
quantile(ff1)

print(quantile(ff1),na.val="NA")
print(quantile(ff1),na.val="Not reached")

</code></pre>

<hr>
<h2 id='redist'>Calculation of Efron's re-distribution to the right algorithm to obtain the
Kaplan-Meier estimate.</h2><span id='topic+redist'></span>

<h3>Description</h3>

<p>Calculation of Efron's re-distribution to the right algorithm to obtain the
Kaplan-Meier estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redist(time, status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redist_+3A_time">time</code></td>
<td>
<p>A numeric vector of event times.</p>
</td></tr>
<tr><td><code id="redist_+3A_status">status</code></td>
<td>
<p>The event status vector takes the value <code>1</code> for observed events and 
the value <code>0</code> for right censored times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculations needed to
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>prodlim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redist(time=c(.35,0.4,.51,.51,.7,.73),status=c(0,1,1,0,0,1))
</code></pre>

<hr>
<h2 id='row.match'>Identifying rows in a matrix or data.frame</h2><span id='topic+row.match'></span>

<h3>Description</h3>

<p>Function for finding matching rows between two matrices or data.frames.
First the matrices or data.frames are vectorized by row wise pasting
together the elements. Then it uses the function match.  Thus the function
returns a vector with the row numbers of (first) matches of its first
argument in its second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row.match(x, table, nomatch = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row.match_+3A_x">x</code></td>
<td>
<p>Vector or matrix whose rows are to be matched</p>
</td></tr>
<tr><td><code id="row.match_+3A_table">table</code></td>
<td>
<p>Matrix or data.frame that contain the rows to be matched
against.</p>
</td></tr>
<tr><td><code id="row.match_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found.
Note that it is coerced to 'integer'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as 'x'.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds
</p>


<h3>See Also</h3>

<p><code>match</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tab &lt;- data.frame(num=1:26,abc=letters)
x &lt;- c(3,"c")
row.match(x,tab)
x &lt;- data.frame(n=c(3,8),z=c("c","h"))
row.match(x,tab)

</code></pre>

<hr>
<h2 id='SimCompRisk'>Simulate competing risks data</h2><span id='topic+SimCompRisk'></span>

<h3>Description</h3>

<p>Simulate right censored competing risks data with two covariates X1 and X2. Both covariates have effect exp(1) on the hazards of event 1 and zero effect on the hazard of event 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimCompRisk(N, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimCompRisk_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="SimCompRisk_+3A_...">...</code></td>
<td>
<p>do nothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>crModel</code>, then adds covariates and finally calls <code>sim.lvm</code>.
</p>


<h3>Value</h3>

<p>data.frame with simulated data
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SimCompRisk(10)
            
</code></pre>

<hr>
<h2 id='SimSurv'>Simulate survival data</h2><span id='topic+SimSurv'></span>

<h3>Description</h3>

<p>Simulate right censored survival data with two covariates X1 and X2, both have effect exp(1) on the hazard of the unobserved event time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimSurv(N, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimSurv_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="SimSurv_+3A_...">...</code></td>
<td>
<p>do nothing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code>survModel</code>, then adds  covariates and finally calls <code>sim.lvm</code>.
</p>


<h3>Value</h3>

<p>data.frame with simulated data
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds
</p>


<h3>References</h3>

<p>Bender, Augustin &amp; Blettner. Generating survival times to simulate Cox proportional hazards models. Statistics in Medicine, 24: 1713-1723, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SimSurv(10)

</code></pre>

<hr>
<h2 id='sindex'>Index for evaluation of step functions.</h2><span id='topic+sindex'></span>

<h3>Description</h3>

<p>Returns an index of positions. Intended for evaluating a step function at
selected times. The function counts how many elements of a vector, e.g. the
jump times of the step function, are smaller or equal to the elements in a
second vector, e.g. the times where the step function should be evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sindex(jump.times, eval.times, comp = "smaller", strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sindex_+3A_jump.times">jump.times</code></td>
<td>
<p>Numeric vector: e.g. the unique jump times of a step
function.</p>
</td></tr>
<tr><td><code id="sindex_+3A_eval.times">eval.times</code></td>
<td>
<p>Numeric vector: e.g. the times where the step function
should be evaluated</p>
</td></tr>
<tr><td><code id="sindex_+3A_comp">comp</code></td>
<td>
<p>If &quot;greater&quot; count the number of jump times that are greater
(greater or equal when strict==FALSE) than the eval times</p>
</td></tr>
<tr><td><code id="sindex_+3A_strict">strict</code></td>
<td>
<p>If TRUE make the comparison of jump times and eval times
strict</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If all <code>jump.times</code> are greater than a particular <code>eval.time</code> the
sindex returns <code>0</code>. This must be considered when sindex is used for
subsetting, see the Examples below.
</p>


<h3>Value</h3>

<p>Index of the same length as <code>eval.times</code> containing the numbers
of the <code>jump.times</code> that are smaller than or equal to
<code>eval.times</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

test &lt;- list(time = c(1, 1,5,5,2,7,9),
		status = c(1,0,1,0,1,1,0))
fit &lt;- prodlim(Hist(time,status)~1,data=test)
jtimes &lt;- fit$time
etimes &lt;- c(0,.5,2,8,10)
fit$surv
c(1,fit$surv)[1+sindex(jtimes,etimes)]

</code></pre>

<hr>
<h2 id='SmartControl'>Function to facilitate the control of arguments passed to subroutines.</h2><span id='topic+SmartControl'></span>

<h3>Description</h3>

<p>Many R functions need to pass several arguments to several different
subroutines. Such arguments can are given as part of the three magic dots
&quot;...&quot;. The function SmartControl reads the dots together with a list of
default values and returns for each subroutine a list of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmartControl(
  call,
  keys,
  ignore,
  defaults,
  forced,
  split,
  ignore.case = TRUE,
  replaceDefaults,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmartControl_+3A_call">call</code></td>
<td>
<p>A list of named arguments, as for example can be obtained via
<code>list(...)</code>.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_keys">keys</code></td>
<td>
<p>A vector of names of subroutines.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_ignore">ignore</code></td>
<td>
<p>A list of names which are removed from the argument
<code>call</code> before processing.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_defaults">defaults</code></td>
<td>
<p>A named list of default argument lists for the subroutines.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_forced">forced</code></td>
<td>
<p>A named list of forced arguments for the subroutines.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_split">split</code></td>
<td>
<p>Regular expression used for splitting keys from arguments.
Default is <code>"\."</code>.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_ignore.case">ignore.case</code></td>
<td>
<p>If <code>TRUE</code> then all matching and splitting is not
case sensitive.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_replacedefaults">replaceDefaults</code></td>
<td>
<p>If <code>TRUE</code> default arguments are replaced by
given arguments. Can also be a named list with entries for each subroutine.</p>
</td></tr>
<tr><td><code id="SmartControl_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> warning messages are given for arguments in
<code>call</code> that are not ignored via argument <code>ignore</code> and that do not
match any <code>key</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.prodlim">plot.prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

myPlot = function(...){
 ## set defaults
 plot.DefaultArgs=list(x=0,y=0,type="n")
 lines.DefaultArgs=list(x=1:10,lwd=3)
 ## apply smartcontrol
 x=SmartControl(call=list(...),
           defaults=list("plot"=plot.DefaultArgs, "lines"=lines.DefaultArgs),
        ignore.case=TRUE,keys=c("plot","axis2","lines"),
             forced=list("plot"=list(axes=FALSE),"axis2"=list(side=2)))
 ## call subroutines
 do.call("plot",x$plot)
 do.call("lines",x$lines)
 do.call("axis",x$axis2)
}
myPlot(plot.ylim=c(0,5),plot.xlim=c(0,20),lines.lty=3,axis2.At=c(0,3,4))

</code></pre>

<hr>
<h2 id='stopTime'>Stop the time of an event history object</h2><span id='topic+stopTime'></span>

<h3>Description</h3>

<p>All event times are stopped at a given time point and
corresponding events are censored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopTime(object, stop.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopTime_+3A_object">object</code></td>
<td>
<p>Event history object as obtained with <code>Hist</code></p>
</td></tr>
<tr><td><code id="stopTime_+3A_stop.time">stop.time</code></td>
<td>
<p>Time point at which to stop the event history object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stopped event history object where all times are censored 
at <code>stop.time</code>. All observations with times greater than <code>stop.time</code>
are set to <code>stop.time</code> and the event status is set to <code>attr(object,"cens.code")</code>.
A new column <code>"stop.time"</code> is equal to <code>1</code> for stopped observations
and equal to <code>0</code> for the other observations.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>Hist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(29)
d &lt;- SimSurv(10)
h &lt;- with(d,Hist(time,status))
h
stopTime(h,8)
stopTime(h,5)

## works also with Surv objects
library(survival)
s &lt;- with(d,Surv(time,status))
stopTime(s,5)

## competing risks
set.seed(29)
dr &lt;- SimCompRisk(10)
hr &lt;- with(dr,Hist(time,event))
hr
stopTime(hr,8)
stopTime(hr,5)

</code></pre>

<hr>
<h2 id='strip.terms'>Strip special functions from terms</h2><span id='topic+strip.terms'></span>

<h3>Description</h3>

<p>Reformulate a terms object such that some specials are stripped off
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.terms(
  terms,
  specials,
  alias.names = NULL,
  unspecials = NULL,
  arguments,
  keep.response = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip.terms_+3A_terms">terms</code></td>
<td>
<p>Terms object</p>
</td></tr>
<tr><td><code id="strip.terms_+3A_specials">specials</code></td>
<td>
<p>Character vector of specials which should be
stripped off</p>
</td></tr>
<tr><td><code id="strip.terms_+3A_alias.names">alias.names</code></td>
<td>
<p>Optional. A named list with alias names for the specials.</p>
</td></tr>
<tr><td><code id="strip.terms_+3A_unspecials">unspecials</code></td>
<td>
<p>Optional. A special name for treating all the unspecial terms.</p>
</td></tr>
<tr><td><code id="strip.terms_+3A_arguments">arguments</code></td>
<td>
<p>A named list of arguments, one for each element
of specials. Elements are passed to <code>parseSpecialNames</code>.</p>
</td></tr>
<tr><td><code id="strip.terms_+3A_keep.response">keep.response</code></td>
<td>
<p>Keep the response in the resulting object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove special specials, i.e., those
which cannot or should not be evaluated. 
IMPORTANT: the unstripped terms need to know about all specials including the aliases.
See examples.
</p>


<h3>Value</h3>

<p>Reformulated terms object with an additional attribute which contains the <code>stripped.specials</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>parseSpecialNames reformulate drop.terms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## parse a survival formula and identify terms which
## should be treated as proportional or timevarying:
f &lt;- Surv(time,status)~age+prop(factor(edema))+timevar(sex,test=0)+prop(bili,power=1)
tt &lt;- terms(f,specials=c("prop","timevar"))
attr(tt,"specials")
st &lt;- strip.terms(tt,specials=c("prop","timevar"),arguments=NULL)
formula(st)
attr(st,"specials")
attr(st,"stripped.specials")

## provide a default value for argument power of proportional treatment
## and argument test of timevarying treatment: 
st2 &lt;- strip.terms(tt,
                   specials=c("prop","timevar"),
                   arguments=list("prop"=list("power"=0),"timevar"=list("test"=0)))
formula(st2)
attr(st2,"stripped.specials")
attr(st2,"stripped.arguments")

## treat all unspecial terms as proportional
st3 &lt;- strip.terms(tt,
                   unspecials="prop",
                   specials=c("prop","timevar"),
                   arguments=list("prop"=list("power"=0),"timevar"=list("test"=0)))
formula(st3)
attr(st3,"stripped.specials")
attr(st3,"stripped.arguments")

## allow alias names: strata for timevar and tp, const for prop.
## IMPORTANT: the unstripped terms need to know about
## all specials including the aliases
f &lt;- Surv(time,status)~age+const(factor(edema))+strata(sex,test=0)+prop(bili,power=1)+tp(albumin)
tt2 &lt;- terms(f,specials=c("prop","timevar","strata","tp","const"))
st4 &lt;- strip.terms(tt2,
                   specials=c("prop","timevar"),
                   unspecials="prop",
                   alias.names=list("timevar"="strata","prop"=c("const","tp")),
                   arguments=list("prop"=list("power"=0),"timevar"=list("test"=0)))
formula(st4)
attr(st4,"stripped.specials")
attr(st4,"stripped.arguments")

## test if alias works also without unspecial argument
st5 &lt;- strip.terms(tt2,
                   specials=c("prop","timevar"),
                   alias.names=list("timevar"="strata","prop"=c("const","tp")),
                   arguments=list("prop"=list("power"=0),"timevar"=list("test"=0)))
formula(st5)
attr(st5,"stripped.specials")
attr(st5,"stripped.arguments")

library(survival)
data(pbc)
model.design(st4,data=pbc[1:3,],specialsDesign=TRUE)
model.design(st5,data=pbc[1:3,],specialsDesign=TRUE)


</code></pre>

<hr>
<h2 id='summary.Hist'>Summary of event histories</h2><span id='topic+summary.Hist'></span>

<h3>Description</h3>

<p>Describe events and censoring patterns of an event history.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Hist'
summary(object, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Hist_+3A_object">object</code></td>
<td>
<p>An object with class &lsquo;Hist&rsquo; derived with <code><a href="#topic+Hist">Hist</a></code></p>
</td></tr>
<tr><td><code id="summary.Hist_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If FALSE any printing is supressed.</p>
</td></tr>
<tr><td><code id="summary.Hist_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> for survival and competing risk models.  For other
multi-state models, it is a list with the following entries:
</p>
<table>
<tr><td><code>states</code></td>
<td>
<p>the states of the model</p>
</td></tr> <tr><td><code>transitions</code></td>
<td>
<p>the transitions
between the states</p>
</td></tr> <tr><td><code>trans.frame</code></td>
<td>
<p>a data.frame with the from and to
states of the transitions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hist">Hist</a></code>, <code><a href="#topic+plot.Hist">plot.Hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
icensFrame &lt;- data.frame(L=c(1,1,3,4,6),R=c(2,NA,3,6,9),event=c(1,1,1,2,2))
with(icensFrame,summary(Hist(time=list(L,R))))

</code></pre>

<hr>
<h2 id='summary.prodlim'>Summary method for prodlim objects.</h2><span id='topic+summary.prodlim'></span>

<h3>Description</h3>

<p>Summarizing the result of the product limit method in life-table format.
Calculates the number of subjects at risk and counts events and censored
observations at specified times or in specified time intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prodlim'
summary(
  object,
  times,
  newdata,
  max.tables = 20,
  surv = TRUE,
  cause,
  intervals = FALSE,
  percent = FALSE,
  format = "df",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prodlim_+3A_object">object</code></td>
<td>
<p>An object with class &lsquo;prodlim&rsquo; derived with
<code><a href="#topic+prodlim">prodlim</a></code></p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated
probabilities.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those
that appear on the right hand side of the 'prodlim' formula.
Defaults to <code>object$X</code>.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_max.tables">max.tables</code></td>
<td>
<p>Integer. If <code>newdata</code> is not given the value
of <code>max.tables</code> decides about the maximal number of tables to
be shown.  Defaults to 20.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_surv">surv</code></td>
<td>
<p>Logical. If FALSE report event probabilities instead of
survival probabilities. Only available for
<code>object$model=="survival"</code>.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_cause">cause</code></td>
<td>
<p>For competing risk models. The event of interest for which predictions of the absolute risks are obtained by evaluating the cause-specific cumulative
incidence functions at  <code>times</code>.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_intervals">intervals</code></td>
<td>
<p>Logical. If TRUE count events and censored in
intervals between the values of <code>times</code>.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_percent">percent</code></td>
<td>
<p>Logical. If TRUE all estimated values are multiplied
by 100 and thus interpretable on a percent scale.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_format">format</code></td>
<td>
<p>Control format of output. Since May 2021,
the result is a data.table and data.frame with attributes. When there are multiple
covariate strata or competing risks, these are indicated by columns.
Set format to <code>"list"</code> to get the old behaviour.</p>
</td></tr>
<tr><td><code id="summary.prodlim_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the print
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For cluster-correlated data the number of clusters at-risk are are also
given. Confidence intervals are displayed when they are part of the fitted
object.
</p>


<h3>Value</h3>

<p>A data.frame with the relevant information.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prodlim">prodlim</a></code>, <code><a href="#topic+summary.Hist">summary.Hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lava)
set.seed(17)
m &lt;- survModel()
distribution(m,~age) &lt;- uniform.lvm(30,80)
distribution(m,~sex) &lt;- binomial.lvm()
m &lt;- categorical(m,~z,K=3)
regression(m,eventtime~age) &lt;- 0.01
regression(m,eventtime~sex) &lt;- -0.4
d &lt;- sim(m,50)
d$sex &lt;- factor(d$sex,levels=c(0,1),labels=c("female","male"))
d$Z &lt;- factor(d$z,levels=c(1,0,2),labels=c("B","A","C"))

# Univariate Kaplan-Meier
# -----------------------------------------------------------------------------------------
fit0 &lt;- prodlim(Hist(time,event)~1,data=d)
summary(fit0)

## show survival probabilities as percentage and
## count number of events within intervals of a
## given time-grid:
summary(fit0,times=c(1,5,10,12),percent=TRUE,intervals=TRUE)

## the result of summary has a print function
## which passes ... to print and print.listof
sx &lt;- summary(fit0,times=c(1,5,10,12),percent=TRUE,intervals=TRUE)
print(sx,digits=3)

## show absolute risks, i.e., cumulative incidences (1-survival)
summary(fit0,times=c(1,5,10,12),surv=FALSE,percent=TRUE,intervals=TRUE)

# Stratified Kaplan-Meier
# -----------------------------------------------------------------------------------------

fit1 &lt;- prodlim(Hist(time,event)~sex,data=d)
print(summary(fit1,times=c(1,5,10),intervals=TRUE,percent=TRUE),digits=3)
# old behaviour
print(summary(fit1,times=c(1,5,10),intervals=TRUE,percent=TRUE,format="list"),digits=3)

summary(fit1,times=c(1,5,10),intervals=TRUE,percent=TRUE)

fit2 &lt;- prodlim(Hist(time,event)~Z,data=d)
print(summary(fit2,times=c(1,5,10),intervals=TRUE,percent=TRUE),digits=3)

## Continuous strata (Beran estimator)
# -----------------------------------------------------------------------------------------
fit3 &lt;- prodlim(Hist(time,event)~age,data=d)
print(summary(fit3,
              times=c(1,5,10),
              newdata=data.frame(age=c(20,50,70)),
              intervals=TRUE,
              percent=TRUE),digits=3)

## stratified Beran estimator
# -----------------------------------------------------------------------------------------
fit4 &lt;- prodlim(Hist(time,event)~age+sex,data=d)
print(summary(fit4,
              times=c(1,5,10),
              newdata=data.frame(age=c(20,50,70),sex=c("female","male","male")),
              intervals=TRUE,
              percent=TRUE),digits=3)

print(summary(fit4,
              times=c(1,5,10),
              newdata=data.frame(age=c(20,50,70),sex=c("female","male","male")),
              intervals=TRUE,
              percent=TRUE),digits=3)

## assess results from summary
x &lt;- summary(fit4,times=10,newdata=expand.grid(age=c(60,40,50),sex=c("male","female")))
cbind(names(x$table),do.call("rbind",lapply(x$table,round,2)))

x &lt;- summary(fit4,times=10,newdata=expand.grid(age=c(60,40,50),sex=c("male","female")))

## Competing risks: Aalen-Johansen
# -----------------------------------------------------------------------------------------
d &lt;- SimCompRisk(30)
crfit &lt;- prodlim(Hist(time,event)~X1,data=d)
summary(crfit,times=c(1,2,5))
summary(crfit,times=c(1,2,5),cause=1,intervals=TRUE)
summary(crfit,times=c(1,2,5),cause=1)
summary(crfit,times=c(1,2,5),cause=1:2)


# extract the actual tables from the summary 
sumfit &lt;- summary(crfit,times=c(1,2,5),print=FALSE)
sumfit$table[[1]] # cause 1
sumfit$table[[2]] # cause 2


# '
</code></pre>

<hr>
<h2 id='survModel'>Survival model for simulation</h2><span id='topic+survModel'></span>

<h3>Description</h3>

<p>Create a survival model to simulate a right censored event time data without
covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survModel()
</code></pre>


<h3>Details</h3>

<p>This function requires the <code>lava</code> package.
</p>


<h3>Value</h3>

<p>A structural equation model initialized with three variables: the
latent event time, the latent right censored time, and the observed
right censored event time.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
