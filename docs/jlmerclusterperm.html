<!DOCTYPE html><html><head><title>Help for package jlmerclusterperm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jlmerclusterperm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jlmerclusterperm-package'><p>jlmerclusterperm: Cluster-Based Permutation Analysis for Densely Sampled Time Data</p></a></li>
<li><a href='#calculate_clusters_pvalues'><p>Calculate bootstrapped p-values of cluster-mass statistics</p></a></li>
<li><a href='#cluster_permutation_tidiers'><p>Tidiers for cluster permutation test objects</p></a></li>
<li><a href='#clusterpermute'><p>Conduct a cluster-based permutation test</p></a></li>
<li><a href='#compute_timewise_statistics'><p>Fit Julia regression models to each time point of a time series data</p></a></li>
<li><a href='#extract_empirical_clusters'><p>Detect largest clusters from a time sequence of predictor statistics</p></a></li>
<li><a href='#extract_null_cluster_dists'><p>Construct a null distribution of cluster-mass statistics</p></a></li>
<li><a href='#jlmer'><p>Fit a Julia regression model using jlmer specifications</p></a></li>
<li><a href='#jlmerclusterperm_setup'><p>Initial setup for the jlmerclusterperm package</p></a></li>
<li><a href='#julia_model_tidiers'><p>Tidier methods for Julia regression models</p></a></li>
<li><a href='#julia_progress'><p>Set/get options for Julia progress bar</p></a></li>
<li><a href='#julia_rng'><p>Interface to the Julia RNG</p></a></li>
<li><a href='#julia_setup_ok'><p>Check Julia requirements for jlmerclusterperm</p></a></li>
<li><a href='#make_jlmer_spec'><p>Create a specifications object for fitting regression models in Julia</p></a></li>
<li><a href='#permute_by_predictor'><p>Permute data while respecting grouping structure(s) of observations</p></a></li>
<li><a href='#permute_timewise_statistics'><p>Simulate cluster-mass statistics via bootstrapped permutations</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#to_jlmer'><p>Fit a Julia regression model using lme4 syntax</p></a></li>
<li><a href='#walk_threshold_steps'><p>Test the probability of cluster-mass statistics over a range of threshold values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cluster-Based Permutation Analysis for Densely Sampled Time Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of fast cluster-based permutation analysis
    (CPA) for densely-sampled time data developed in Maris &amp; Oostenveld,
    2007 &lt;<a href="https://doi.org/10.1016%2Fj.jneumeth.2007.03.024">doi:10.1016/j.jneumeth.2007.03.024</a>&gt;. Supports (generalized,
    mixed-effects) regression models for the calculation of timewise
    statistics. Provides both a wholesale and a piecemeal interface to the
    CPA procedure with an emphasis on interpretability and diagnostics.
    Integrates 'Julia' libraries 'MixedModels.jl' and 'GLM.jl' for
    performance improvements, with additional functionalities for
    interfacing with 'Julia' from 'R' powered by the 'JuliaConnectoR'
    package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yjunechoe/jlmerclusterperm">https://github.com/yjunechoe/jlmerclusterperm</a>,
<a href="https://yjunechoe.github.io/jlmerclusterperm/">https://yjunechoe.github.io/jlmerclusterperm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yjunechoe/jlmerclusterperm/issues">https://github.com/yjunechoe/jlmerclusterperm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports (&ge; 1.1.7), cli, generics, JuliaConnectoR, lme4,
stats, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom, broom.mixed, covr, dplyr, eyetrackingR, forcats,
future, ggplot2, knitr, MASS, patchwork, readr, rmarkdown,
scales, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Julia (&gt;= 1.8)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'jlmerclusterperm-package.R' 'aaa.R' 'utils.R'
'interop-utils.R' 'interop-utils-unexported.R' 'julia_rng.R'
'jlmer_spec.R' 'jlmer.R' 'compute_timewise_statistics.R'
'permute.R' 'permute_timewise_statistics.R'
'clusters_methods.R' 'extract_clusters.R' 'calculate_pvalue.R'
'clusterpermute.R' 'threshold_search.R' 'tidy.R' 'zzz.R'
'srr-stats-standards.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 15:03:56 UTC; jchoe</td>
</tr>
<tr>
<td>Author:</td>
<td>June Choe <a href="https://orcid.org/0000-0002-0701-921X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>June Choe &lt;jchoe001@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jlmerclusterperm-package'>jlmerclusterperm: Cluster-Based Permutation Analysis for Densely Sampled Time Data</h2><span id='topic+jlmerclusterperm'></span><span id='topic+jlmerclusterperm-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>An implementation of fast cluster-based permutation analysis (CPA) for densely-sampled time data developed in Maris &amp; Oostenveld, 2007 <a href="https://doi.org/10.1016/j.jneumeth.2007.03.024">doi:10.1016/j.jneumeth.2007.03.024</a>. Supports (generalized, mixed-effects) regression models for the calculation of timewise statistics. Provides both a wholesale and a piecemeal interface to the CPA procedure with an emphasis on interpretability and diagnostics. Integrates 'Julia' libraries 'MixedModels.jl' and 'GLM.jl' for performance improvements, with additional functionalities for interfacing with 'Julia' from 'R' powered by the 'JuliaConnectoR' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: June Choe <a href="mailto:jchoe001@gmail.com">jchoe001@gmail.com</a> (<a href="https://orcid.org/0000-0002-0701-921X">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/yjunechoe/jlmerclusterperm">https://github.com/yjunechoe/jlmerclusterperm</a>
</p>
</li>
<li> <p><a href="https://yjunechoe.github.io/jlmerclusterperm/">https://yjunechoe.github.io/jlmerclusterperm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/yjunechoe/jlmerclusterperm/issues">https://github.com/yjunechoe/jlmerclusterperm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calculate_clusters_pvalues'>Calculate bootstrapped p-values of cluster-mass statistics</h2><span id='topic+calculate_clusters_pvalues'></span><span id='topic+clusters_are_comparable'></span>

<h3>Description</h3>

<p>Calculate bootstrapped p-values of cluster-mass statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_clusters_pvalues(
  empirical_clusters,
  null_cluster_dists,
  add1 = FALSE
)

clusters_are_comparable(empirical_clusters, null_cluster_dists, error = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_clusters_pvalues_+3A_empirical_clusters">empirical_clusters</code></td>
<td>
<p>A <code>empirical_clusters</code> object</p>
</td></tr>
<tr><td><code id="calculate_clusters_pvalues_+3A_null_cluster_dists">null_cluster_dists</code></td>
<td>
<p>A <code>null_cluster_dists</code> object</p>
</td></tr>
<tr><td><code id="calculate_clusters_pvalues_+3A_add1">add1</code></td>
<td>
<p>Whether to add 1 to the numerator and denominator when calculating the p-value.
Use <code>TRUE</code> to effectively count the observed statistic as part of the permuted
null distribution (recommended with larger <code>nsim</code> prior to publishing results).</p>
</td></tr>
<tr><td><code id="calculate_clusters_pvalues_+3A_error">error</code></td>
<td>
<p>Whether to throw an error if incompatible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>empirical_clusters</code> object augmented with p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_empirical_clusters">extract_empirical_clusters()</a></code>, <code><a href="#topic+extract_null_cluster_dists">extract_null_cluster_dists()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Make empirical clusters
empirical_statistics &lt;- compute_timewise_statistics(spec)
empirical_clusters &lt;- extract_empirical_clusters(empirical_statistics, threshold = 2)
empirical_clusters

# Make null cluster-mass distribution
reset_rng_state()
null_statistics &lt;- permute_timewise_statistics(spec, nsim = 100)
null_cluster_dists &lt;- extract_null_cluster_dists(null_statistics, threshold = 2)

# Significance test the empirical cluster(s) from each predictor against the simulated null
calculate_clusters_pvalues(empirical_clusters, null_cluster_dists)

# Set `add1 = TRUE` to normalize by adding 1 to numerator and denominator
calculate_clusters_pvalues(empirical_clusters, null_cluster_dists, add1 = TRUE)

# This sequence of procedures is equivalent to `clusterpermute()`
reset_rng_state()
clusterpermute(spec, threshold = 2, nsim = 100, progress = FALSE)

# The empirical clusters and the null cluster-mass distribution must be comparable
empirical_clusters2 &lt;- extract_empirical_clusters(empirical_statistics, threshold = 3)
# For example, below code errors because thresholds are different (2 vs. 3)
try( calculate_clusters_pvalues(empirical_clusters2, null_cluster_dists) )

# Check for compatibility with `clusters_are_comparable()`
clusters_are_comparable(empirical_clusters, null_cluster_dists)
clusters_are_comparable(empirical_clusters2, null_cluster_dists)




</code></pre>

<hr>
<h2 id='cluster_permutation_tidiers'>Tidiers for cluster permutation test objects</h2><span id='topic+cluster_permutation_tidiers'></span><span id='topic+tidy.timewise_statistics'></span><span id='topic+tidy.empirical_clusters'></span><span id='topic+tidy.null_cluster_dists'></span>

<h3>Description</h3>

<p>Tidiers for cluster permutation test objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timewise_statistics'
tidy(x, ...)

## S3 method for class 'empirical_clusters'
tidy(x, ...)

## S3 method for class 'null_cluster_dists'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_permutation_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code style="white-space: pre;">&#8288;&lt;timewise_statistics&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;&lt;empirical_clusters&gt;&#8288;</code>, or <code style="white-space: pre;">&#8288;&lt;null_cluster_dists&gt;&#8288;</code></p>
</td></tr>
<tr><td><code id="cluster_permutation_tidiers_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Method for `&lt;timewise_statistics&gt;`
empirical_statistics &lt;- compute_timewise_statistics(spec)
class(empirical_statistics)
tidy(empirical_statistics)

reset_rng_state()
null_statistics &lt;- permute_timewise_statistics(spec, nsim = 100)
class(null_statistics)
tidy(null_statistics)

# Method for `&lt;empirical_clusters&gt;`
empirical_clusters &lt;- extract_empirical_clusters(empirical_statistics, threshold = 2)
class(empirical_clusters)
tidy(empirical_clusters)

# Method for `&lt;null_cluster_dists&gt;`
null_cluster_dists &lt;- extract_null_cluster_dists(null_statistics, threshold = 2)
class(null_cluster_dists)
tidy(null_cluster_dists)




</code></pre>

<hr>
<h2 id='clusterpermute'>Conduct a cluster-based permutation test</h2><span id='topic+clusterpermute'></span>

<h3>Description</h3>

<p>Conduct a cluster-based permutation test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterpermute(
  jlmer_spec,
  family = c("gaussian", "binomial"),
  statistic = c("t", "chisq"),
  threshold,
  nsim = 100L,
  predictors = NULL,
  binned = FALSE,
  top_n = Inf,
  add1 = TRUE,
  ...,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterpermute_+3A_jlmer_spec">jlmer_spec</code></td>
<td>
<p>Data prepped for jlmer from <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_family">family</code></td>
<td>
<p>A GLM family. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_statistic">statistic</code></td>
<td>
<p>Test statistic for calculating cluster mass.
Can be one of <code>"t"</code> (default) from the regression model output or
<code>"chisq"</code> from a likelihood ratio test (takes about twice as long to calculate).</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value that the statistic must pass to contribute to cluster mass.
Interpretation differs on the choice of statistic (more below):
</p>

<ul>
<li><p> If <code>statistic = "t"</code>, the threshold for t-value (beta/std.err) from the regression model.
</p>
</li>
<li><p> If <code>statistic = "chisq"</code>, the threshold for the p-value of chi-squared statistics from likelihood ratio tests.
</p>
</li></ul>
</td></tr>
<tr><td><code id="clusterpermute_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations description</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_predictors">predictors</code></td>
<td>
<p>(Optional) a subset of predictors to test. Defaults to <code>NULL</code> which tests all predictors.</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_binned">binned</code></td>
<td>
<p>Whether the data has been aggregated/collapsed into time bins. Defaults to <code>FALSE</code>,
which requires a cluster to span at least two time points. If <code>TRUE</code>, allows length-1 clusters to exist.</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_top_n">top_n</code></td>
<td>
<p>How many clusters to return, in the order of the size of the cluster-mass statistic.
Defaults to <code>Inf</code> which return all detected clusters.</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_add1">add1</code></td>
<td>
<p>Whether to add 1 to the numerator and denominator when calculating the p-value.
Use <code>TRUE</code> to effectively count the observed statistic as part of the permuted
null distribution (recommended with larger <code>nsim</code> prior to publishing results).</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to Julia for model fitting.
Defaults to <code>fast = TRUE</code> (when <code>family = "binomial"</code>) and <code>progress = FALSE</code>.</p>
</td></tr>
<tr><td><code id="clusterpermute_+3A_progress">progress</code></td>
<td>
<p>Defaults to <code>TRUE</code>, which prints progress on each step of the cluster permutation test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>null_cluster_dists</code> and <code>empirical_clusters</code> with p-values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_timewise_statistics">compute_timewise_statistics()</a></code>, <code><a href="#topic+permute_timewise_statistics">permute_timewise_statistics()</a></code>,
<code><a href="#topic+extract_empirical_clusters">extract_empirical_clusters()</a></code>, <code><a href="#topic+extract_null_cluster_dists">extract_null_cluster_dists()</a></code>,
<code><a href="#topic+calculate_clusters_pvalues">calculate_clusters_pvalues()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Should minimally provide `threshold` and `nsim`, in addition to the spec object
reset_rng_state()
CPA &lt;- clusterpermute(spec, threshold = 2, nsim = 100, progress = FALSE)
CPA

# CPA is a list of `&lt;null_cluster_dists&gt;` and `&lt;empirical_clusters&gt;` objects
sapply(CPA, class)

# You can extract the individual components for further inspection
CPA$null_cluster_dists
CPA$empirical_clusters




</code></pre>

<hr>
<h2 id='compute_timewise_statistics'>Fit Julia regression models to each time point of a time series data</h2><span id='topic+compute_timewise_statistics'></span>

<h3>Description</h3>

<p>Fit Julia regression models to each time point of a time series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_timewise_statistics(
  jlmer_spec,
  family = c("gaussian", "binomial"),
  statistic = c("t", "chisq"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_timewise_statistics_+3A_jlmer_spec">jlmer_spec</code></td>
<td>
<p>Data prepped for jlmer from <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="compute_timewise_statistics_+3A_family">family</code></td>
<td>
<p>A GLM family. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="compute_timewise_statistics_+3A_statistic">statistic</code></td>
<td>
<p>Test statistic for calculating cluster mass.
Can be one of <code>"t"</code> (default) from the regression model output or
<code>"chisq"</code> from a likelihood ratio test (takes about twice as long to calculate).</p>
</td></tr>
<tr><td><code id="compute_timewise_statistics_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to Julia for model fitting.
Defaults to <code>fast = TRUE</code> (when <code>family = "binomial"</code>) and <code>progress = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A predictor-by-time matrix of cluster statistics, of class <code>timewise_statistics</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jlmer">jlmer()</a></code>, <code><a href="#topic+make_jlmer_spec">make_jlmer_spec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Predictor x Time matrix of t-statistics from regression output
empirical_statistics &lt;- compute_timewise_statistics(spec)
round(empirical_statistics, 2)

# Collect as dataframe with `tidy()`
empirical_statistics_df &lt;- tidy(empirical_statistics)
empirical_statistics_df

# Timewise statistics are from regression models fitted to each time point
# - Note the identical statistics at `Time == 0`
empirical_statistics_df %&gt;%
  filter(time == 0)
to_jlmer(weight ~ 1 + Diet, filter(ChickWeight, Time == 0)) %&gt;%
  tidy() %&gt;%
  select(term, statistic)




</code></pre>

<hr>
<h2 id='extract_empirical_clusters'>Detect largest clusters from a time sequence of predictor statistics</h2><span id='topic+extract_empirical_clusters'></span>

<h3>Description</h3>

<p>Detect largest clusters from a time sequence of predictor statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_empirical_clusters(
  empirical_statistics,
  threshold,
  binned = FALSE,
  top_n = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_empirical_clusters_+3A_empirical_statistics">empirical_statistics</code></td>
<td>
<p>A predictor-by-time matrix of empirical timewise statistics.</p>
</td></tr>
<tr><td><code id="extract_empirical_clusters_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value that the statistic must pass to contribute to cluster mass.
Interpretation differs on the choice of statistic (more below):
</p>

<ul>
<li><p> If <code>statistic = "t"</code>, the threshold for t-value (beta/std.err) from the regression model.
</p>
</li>
<li><p> If <code>statistic = "chisq"</code>, the threshold for the p-value of chi-squared statistics from likelihood ratio tests.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_empirical_clusters_+3A_binned">binned</code></td>
<td>
<p>Whether the data has been aggregated/collapsed into time bins. Defaults to <code>FALSE</code>,
which requires a cluster to span at least two time points. If <code>TRUE</code>, allows length-1 clusters to exist.</p>
</td></tr>
<tr><td><code id="extract_empirical_clusters_+3A_top_n">top_n</code></td>
<td>
<p>How many clusters to return, in the order of the size of the cluster-mass statistic.
Defaults to <code>Inf</code> which return all detected clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>empirical_clusters</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_timewise_statistics">compute_timewise_statistics()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Empirical clusters are derived from the timewise statistics
empirical_statistics &lt;- compute_timewise_statistics(spec)
empirical_clusters &lt;- extract_empirical_clusters(empirical_statistics, threshold = 2)
empirical_clusters

# Collect as dataframe with `tidy()`
empirical_clusters_df &lt;- tidy(empirical_clusters)
empirical_clusters_df

# Changing the `threshold` value identifies different clusters
extract_empirical_clusters(empirical_statistics, threshold = 1)

# A predictor can have zero or multiple clusters associated with it
extract_empirical_clusters(empirical_statistics, threshold = 3)




</code></pre>

<hr>
<h2 id='extract_null_cluster_dists'>Construct a null distribution of cluster-mass statistics</h2><span id='topic+extract_null_cluster_dists'></span>

<h3>Description</h3>

<p>Construct a null distribution of cluster-mass statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_null_cluster_dists(null_statistics, threshold, binned = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_null_cluster_dists_+3A_null_statistics">null_statistics</code></td>
<td>
<p>A simulation-by-time-by-predictor 3D array of null (permuted) timewise statistics.</p>
</td></tr>
<tr><td><code id="extract_null_cluster_dists_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value that the statistic must pass to contribute to cluster mass.
Interpretation differs on the choice of statistic (more below):
</p>

<ul>
<li><p> If <code>statistic = "t"</code>, the threshold for t-value (beta/std.err) from the regression model.
</p>
</li>
<li><p> If <code>statistic = "chisq"</code>, the threshold for the p-value of chi-squared statistics from likelihood ratio tests.
</p>
</li></ul>
</td></tr>
<tr><td><code id="extract_null_cluster_dists_+3A_binned">binned</code></td>
<td>
<p>Whether the data has been aggregated/collapsed into time bins. Defaults to <code>FALSE</code>,
which requires a cluster to span at least two time points. If <code>TRUE</code>, allows length-1 clusters to exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>null_cluster_dists</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permute_timewise_statistics">permute_timewise_statistics()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Null cluster-mass distributions are derived from the permuted timewise statistics
reset_rng_state()
null_statistics &lt;- permute_timewise_statistics(spec, nsim = 100)
null_cluster_dists &lt;- extract_null_cluster_dists(null_statistics, threshold = 2)
null_cluster_dists

# Collect as dataframe with `tidy()`
# - Each simulation contributes one (largest) cluster-mass statistic to the null
# - When no clusters are found, the `sum_statistic` value is zero
null_cluster_dists_df &lt;- tidy(null_cluster_dists)
null_cluster_dists_df

# Changing the `threshold` value changes the shape of the null
extract_null_cluster_dists(null_statistics, threshold = 1)
extract_null_cluster_dists(null_statistics, threshold = 3)




</code></pre>

<hr>
<h2 id='jlmer'>Fit a Julia regression model using jlmer specifications</h2><span id='topic+jlmer'></span>

<h3>Description</h3>

<p>Fit a Julia regression model using jlmer specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jlmer(jlmer_spec, family = c("gaussian", "binomial"), ..., progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jlmer_+3A_jlmer_spec">jlmer_spec</code></td>
<td>
<p>Data prepped for jlmer from <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="jlmer_+3A_family">family</code></td>
<td>
<p>A GLM family. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="jlmer_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to Julia for model fitting.</p>
</td></tr>
<tr><td><code id="jlmer_+3A_progress">progress</code></td>
<td>
<p>If <code>TRUE</code>, prints the timing of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>jlmer_mod</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_jlmer_spec">make_jlmer_spec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Fitting a regression model with a specification object
spec &lt;- make_jlmer_spec(weight ~ 1 + Diet, ChickWeight)
jlmer(spec)

# `lm()` equivalent
summary(lm(weight ~ 1 + Diet, ChickWeight))$coef




</code></pre>

<hr>
<h2 id='jlmerclusterperm_setup'>Initial setup for the jlmerclusterperm package</h2><span id='topic+jlmerclusterperm_setup'></span>

<h3>Description</h3>

<p>Initial setup for the jlmerclusterperm package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jlmerclusterperm_setup(..., cache_dir = NULL, restart = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jlmerclusterperm_setup_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="jlmerclusterperm_setup_+3A_cache_dir">cache_dir</code></td>
<td>
<p>The location to write out package cache files (namely, Manifest.toml).
If <code>NULL</code> (default), attempts to write to the package's cache directory discovered via
<code>R_user_dir()</code> and falls back to <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="jlmerclusterperm_setup_+3A_restart">restart</code></td>
<td>
<p>Whether to set up a fresh Julia session, given that one is already running.
If <code>FALSE</code> and <code>jlmerclusterperm_setup()</code> has already been called, nothing happens.</p>
</td></tr>
<tr><td><code id="jlmerclusterperm_setup_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress and messages from Julia in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

options("jlmerclusterperm.nthreads" = 2)
jlmerclusterperm_setup(cache_dir = tempdir(), verbose = FALSE)




</code></pre>

<hr>
<h2 id='julia_model_tidiers'>Tidier methods for Julia regression models</h2><span id='topic+julia_model_tidiers'></span><span id='topic+tidy.jlmer_mod'></span><span id='topic+glance.jlmer_mod'></span>

<h3>Description</h3>

<p>Tidier methods for Julia regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'jlmer_mod'
tidy(x, effects = c("var_model", "ran_pars", "fixed"), ...)

## S3 method for class 'jlmer_mod'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="julia_model_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>jlmer_mod</code></p>
</td></tr>
<tr><td><code id="julia_model_tidiers_+3A_effects">effects</code></td>
<td>
<p>One of &quot;var_model&quot;, &quot;ran_pars&quot;, or &quot;fixed&quot;</p>
</td></tr>
<tr><td><code id="julia_model_tidiers_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Fixed-effects only model
mod1 &lt;- to_jlmer(weight ~ 1 + Diet, ChickWeight)
tidy(mod1)
glance(mod1)

# Mixed model
mod2 &lt;- to_jlmer(weight ~ 1 + Diet + (1 | Chick), ChickWeight)
tidy(mod2)
glance(mod2)

# Select which of fixed/random effects to return
tidy(mod2, effects = "fixed")
tidy(mod2, effects = "ran_pars")




</code></pre>

<hr>
<h2 id='julia_progress'>Set/get options for Julia progress bar</h2><span id='topic+julia_progress'></span>

<h3>Description</h3>

<p>Set/get options for Julia progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julia_progress(show, width)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="julia_progress_+3A_show">show</code></td>
<td>
<p>Whether to show the progress bar. You may also pass in a list of <code>"show"</code> and <code>"width"</code>.</p>
</td></tr>
<tr><td><code id="julia_progress_+3A_width">width</code></td>
<td>
<p>Width of the progress bar. If <code>"auto"</code>, adjusts the progress bar width to fit the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Previous values for <code>show</code> and <code>width</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Show current progress options
julia_progress()

# Set options and save previous options
old_progress_opts &lt;- julia_progress(show = FALSE, width = 100)
julia_progress()

# Restoring progress settings by passing a list of old options
old_progress_opts
julia_progress(old_progress_opts)
identical(julia_progress(), old_progress_opts)

# Alternatively, reset to default settings using this syntax:
julia_progress(show = TRUE, width = "auto")




</code></pre>

<hr>
<h2 id='julia_rng'>Interface to the Julia RNG</h2><span id='topic+julia_rng'></span><span id='topic+set_rng_state'></span><span id='topic+reset_rng_state'></span><span id='topic+get_rng_state'></span><span id='topic+set_rng_seed'></span><span id='topic+get_rng_seed'></span>

<h3>Description</h3>

<p>Interface to the Julia RNG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_rng_state(i)

reset_rng_state()

get_rng_state()

set_rng_seed(seed)

get_rng_seed()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="julia_rng_+3A_i">i</code></td>
<td>
<p>Counter number</p>
</td></tr>
<tr><td><code id="julia_rng_+3A_seed">seed</code></td>
<td>
<p>Seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The current seed or counter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# RNG initializes to seed=1 counter=0
get_rng_seed()
get_rng_state()

# setter/getter for RNG counter
set_rng_state(123)
get_rng_state()

# setter/getter for RNG seed
set_rng_seed(2)
get_rng_seed()

# restore to initial setting (seed=1, counter=0)
set_rng_seed(1)
set_rng_state(0)




</code></pre>

<hr>
<h2 id='julia_setup_ok'>Check Julia requirements for jlmerclusterperm</h2><span id='topic+julia_setup_ok'></span>

<h3>Description</h3>

<p>Check Julia requirements for jlmerclusterperm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julia_setup_ok()
</code></pre>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>julia_setup_ok()
</code></pre>

<hr>
<h2 id='make_jlmer_spec'>Create a specifications object for fitting regression models in Julia</h2><span id='topic+make_jlmer_spec'></span>

<h3>Description</h3>

<p>Create a specifications object for fitting regression models in Julia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_jlmer_spec(
  formula,
  data,
  subject = NULL,
  trial = NULL,
  time = NULL,
  drop_terms = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_jlmer_spec_+3A_formula">formula</code></td>
<td>
<p>Model formula in R syntax</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_subject">subject</code></td>
<td>
<p>Column for subjects in the data.</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_trial">trial</code></td>
<td>
<p>Column for trials in the data. Must uniquely identify a time series within subject
(for example, the column for items in a counterbalanced design where each subject sees exactly one item).</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_time">time</code></td>
<td>
<p>Column for time in the data.</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_drop_terms">drop_terms</code></td>
<td>
<p>(Optional) any terms to drop from the reconstructed model formula</p>
</td></tr>
<tr><td><code id="make_jlmer_spec_+3A_...">...</code></td>
<td>
<p>Unused, for extensibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>jlmer_spec</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bare specification object (minimal spec for fitting a global model)
spec &lt;- make_jlmer_spec(weight ~ 1 + Diet, ChickWeight)
spec

# Constraints on specification for CPA:
# 1) The combination of `subject`, `trial`, and `time` must uniquely identify rows in the data
# 2) `time` must have constant sampling rate (i.e., evenly spaced values)
spec_wrong &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, ChickWeight,
  time = "Time"
)
unique(ChickWeight$Time)

# Corrected specification for the above
spec_correct &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, subset(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec_correct

</code></pre>

<hr>
<h2 id='permute_by_predictor'>Permute data while respecting grouping structure(s) of observations</h2><span id='topic+permute_by_predictor'></span>

<h3>Description</h3>

<p>Permute data while respecting grouping structure(s) of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_by_predictor(
  jlmer_spec,
  predictors,
  predictor_type = c("guess", "between_participant", "within_participant"),
  n = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_by_predictor_+3A_jlmer_spec">jlmer_spec</code></td>
<td>
<p>Data prepped for jlmer from <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="permute_by_predictor_+3A_predictors">predictors</code></td>
<td>
<p>A vector of terms from the model. If multiple, the must form the levels of one predictor.</p>
</td></tr>
<tr><td><code id="permute_by_predictor_+3A_predictor_type">predictor_type</code></td>
<td>
<p>Whether the predictor is <code>"between_participant"</code> or <code>"within_participant"</code>. Defaults to <code>"guess"</code>.</p>
</td></tr>
<tr><td><code id="permute_by_predictor_+3A_n">n</code></td>
<td>
<p>Number of permuted samples of the data to generate. Defaults to <code>1L</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long dataframe of permuted re-samples with <code>.id</code> column representing replication IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Example data setup
chickweights_df &lt;- ChickWeight
chickweights_df &lt;- chickweights_df[chickweights_df$Time &lt;= 20, ]
chickweights_df$DietInt &lt;- as.integer(chickweights_df$Diet)
head(chickweights_df)

# Example 1: Spec object using the continuous `DietInt` predictor
chickweights_spec1 &lt;- make_jlmer_spec(
  formula = weight ~ 1 + DietInt,
  data = chickweights_df,
  subject = "Chick", time = "Time"
)
chickweights_spec1

# Shuffling `DietInt` values guesses `predictor_type = "between_participant"`
reset_rng_state()
spec1_perm1 &lt;- permute_by_predictor(chickweights_spec1, predictors = "DietInt")
# This calls the same shuffling algorithm for CPA in Julia, so counter is incremented
get_rng_state()

# Shuffling under shared RNG state reproduces the same permutation of the data
reset_rng_state()
spec1_perm2 &lt;- permute_by_predictor(chickweights_spec1, predictors = "DietInt")
identical(spec1_perm1, spec1_perm2)

# Example 2: Spec object using the multilevel `Diet` predictor
chickweights_spec2 &lt;- make_jlmer_spec(
  formula = weight ~ 1 + Diet,
  data = chickweights_df,
  subject = "Chick", time = "Time"
)
chickweights_spec2

# Levels of a category are automatically shuffled together
reset_rng_state()
spec2_perm1 &lt;- permute_by_predictor(chickweights_spec2, predictors = "Diet2")
reset_rng_state()
spec2_perm2 &lt;- permute_by_predictor(chickweights_spec2, predictors = c("Diet2", "Diet3", "Diet4"))
identical(spec2_perm1, spec2_perm2)




</code></pre>

<hr>
<h2 id='permute_timewise_statistics'>Simulate cluster-mass statistics via bootstrapped permutations</h2><span id='topic+permute_timewise_statistics'></span>

<h3>Description</h3>

<p>Simulate cluster-mass statistics via bootstrapped permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_timewise_statistics(
  jlmer_spec,
  family = c("gaussian", "binomial"),
  statistic = c("t", "chisq"),
  nsim = 100L,
  predictors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_timewise_statistics_+3A_jlmer_spec">jlmer_spec</code></td>
<td>
<p>Data prepped for jlmer from <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="permute_timewise_statistics_+3A_family">family</code></td>
<td>
<p>A GLM family. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="permute_timewise_statistics_+3A_statistic">statistic</code></td>
<td>
<p>Test statistic for calculating cluster mass.
Can be one of <code>"t"</code> (default) from the regression model output or
<code>"chisq"</code> from a likelihood ratio test (takes about twice as long to calculate).</p>
</td></tr>
<tr><td><code id="permute_timewise_statistics_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations description</p>
</td></tr>
<tr><td><code id="permute_timewise_statistics_+3A_predictors">predictors</code></td>
<td>
<p>(Optional) a subset of predictors to test. Defaults to <code>NULL</code> which tests all predictors.</p>
</td></tr>
<tr><td><code id="permute_timewise_statistics_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to Julia for model fitting.
Defaults to <code>fast = TRUE</code> (when <code>family = "binomial"</code>) and <code>progress = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulation-by-time-by-predictor 3D array of cluster statistics, of class <code>timewise_statistics</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_jlmer_spec">make_jlmer_spec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



library(dplyr, warn.conflicts = FALSE)

# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, filter(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Simulation x Time x Predictor array of t-statistics from regression output
reset_rng_state()
null_statistics &lt;- permute_timewise_statistics(spec, nsim = 3)
round(null_statistics, 2)

# Collect as dataframe with `tidy()`
permuted_timewise_stats_df &lt;- tidy(null_statistics)
permuted_timewise_stats_df

# Permutations ran under the same RNG state are identical
reset_rng_state()
null_statistics2 &lt;- permute_timewise_statistics(spec, nsim = 3)
identical(null_statistics, null_statistics2)

get_rng_state()
null_statistics3 &lt;- permute_timewise_statistics(spec, nsim = 3)
identical(null_statistics, null_statistics3)




</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+stopJulia'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>JuliaConnectoR</dt><dd><p><code><a href="JuliaConnectoR.html#topic+stopJulia">stopJulia</a></code></p>
</dd>
</dl>

<hr>
<h2 id='to_jlmer'>Fit a Julia regression model using lme4 syntax</h2><span id='topic+to_jlmer'></span>

<h3>Description</h3>

<p>Fit a Julia regression model using lme4 syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_jlmer(
  formula,
  data,
  family = c("gaussian", "binomial"),
  jlmer_spec_opts = list(),
  ...,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_jlmer_+3A_formula">formula</code></td>
<td>
<p>Model formula in R syntax</p>
</td></tr>
<tr><td><code id="to_jlmer_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="to_jlmer_+3A_family">family</code></td>
<td>
<p>A GLM family. Currently supports &quot;gaussian&quot; and &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="to_jlmer_+3A_jlmer_spec_opts">jlmer_spec_opts</code></td>
<td>
<p>List of options passed to <code>make_jlmer_spec()</code></p>
</td></tr>
<tr><td><code id="to_jlmer_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to Julia for model fitting.</p>
</td></tr>
<tr><td><code id="to_jlmer_+3A_progress">progress</code></td>
<td>
<p>If <code>TRUE</code>, prints the timing of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>jlmer_mod</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jlmer">jlmer()</a></code>, <code><a href="#topic+make_jlmer_spec">make_jlmer_spec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Fitting a regression model with R formula syntax
to_jlmer(weight ~ 1 + Diet, ChickWeight)

# `lm()` equivalent
summary(lm(weight ~ 1 + Diet, ChickWeight))$coef

# Fitting a mixed model with {lme4} syntax
to_jlmer(weight ~ 1 + Diet + (1 | Chick), ChickWeight)

# Passing MixedModels.jl fit options to the `...`
to_jlmer(weight ~ 1 + Diet + (1 | Chick), ChickWeight, REML = TRUE)




</code></pre>

<hr>
<h2 id='walk_threshold_steps'>Test the probability of cluster-mass statistics over a range of threshold values</h2><span id='topic+walk_threshold_steps'></span>

<h3>Description</h3>

<p>Test the probability of cluster-mass statistics over a range of threshold values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walk_threshold_steps(
  empirical_statistics,
  null_statistics,
  steps,
  top_n = Inf,
  binned = FALSE,
  add1 = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk_threshold_steps_+3A_empirical_statistics">empirical_statistics</code></td>
<td>
<p>A predictor-by-time matrix of empirical timewise statistics.</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_null_statistics">null_statistics</code></td>
<td>
<p>A simulation-by-time-by-predictor 3D array of null (permuted) timewise statistics.</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_steps">steps</code></td>
<td>
<p>A vector of threshold values to test</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_top_n">top_n</code></td>
<td>
<p>How many clusters to return, in the order of the size of the cluster-mass statistic.
Defaults to <code>Inf</code> which return all detected clusters.</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_binned">binned</code></td>
<td>
<p>Whether the data has been aggregated/collapsed into time bins. Defaults to <code>FALSE</code>,
which requires a cluster to span at least two time points. If <code>TRUE</code>, allows length-1 clusters to exist.</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_add1">add1</code></td>
<td>
<p>Whether to add 1 to the numerator and denominator when calculating the p-value.
Use <code>TRUE</code> to effectively count the observed statistic as part of the permuted
null distribution (recommended with larger <code>nsim</code> prior to publishing results).</p>
</td></tr>
<tr><td><code id="walk_threshold_steps_+3A_progress">progress</code></td>
<td>
<p>Whether to display a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of predictor clusters-mass statistics by threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Specification object
spec &lt;- make_jlmer_spec(
  weight ~ 1 + Diet, subset(ChickWeight, Time &lt;= 20),
  subject = "Chick", time = "Time"
)
spec

# Compute timewise statistics for the observed and permuted data
empirical_statistics &lt;- compute_timewise_statistics(spec)
null_statistics &lt;- permute_timewise_statistics(spec, nsim = 100)

# Test cluster mass/probability under different threshold values
walk_threshold_steps(empirical_statistics, null_statistics, steps = 1:3,
                     progress = FALSE)




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
