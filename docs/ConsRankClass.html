<!DOCTYPE html><html lang="en"><head><title>Help for package ConsRankClass</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ConsRankClass}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cca'><p>K-Median Cluster Component Analysis</p></a></li>
<li><a href='#ccacontrol'><p>Utility function</p></a></li>
<li><a href='#EVS'>
<p>European Values Studies (EVS) data</p></a></li>
<li><a href='#fuzzyconcordance'><p>Normalized Degree of Concordance (NDC) and Adjusted Concordance Index (ACI)</p></a></li>
<li><a href='#getsubtree'><p>Determine a tree from the main tree-based structure</p></a></li>
<li><a href='#Irish'>
<p>Irish Election data set</p></a></li>
<li><a href='#layouttree'><p>Utility function</p></a></li>
<li><a href='#nodepath'><p>Path of a terminal node</p></a></li>
<li><a href='#plot.ranktree'><p>Plot tree-based structure or pruning sequence of ranktree</p></a></li>
<li><a href='#predict.ranktree'><p>Predict the median rankings for new observations</p></a></li>
<li><a href='#print.cca'><p>S3 methods for cca</p></a></li>
<li><a href='#print.ranktree'><p>S3 methods for ranktree</p></a></li>
<li><a href='#ranktree'><p>Recursive partitioning method for the prediction of preference rankings based upon Kemeny distances</p></a></li>
<li><a href='#ranktreecontrol'><p>Utility function</p></a></li>
<li><a href='#summary.cca'><p>S3 methods for ranktree</p></a></li>
<li><a href='#summary.ranktree'><p>S3 methods for ranktree</p></a></li>
<li><a href='#treepaths'><p>Path of a terminal node</p></a></li>
<li><a href='#Univranks'>
<p>University rankings dataset.</p></a></li>
<li><a href='#validatetree'><p>Validation of the tree for preference rankings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classification and Clustering of Preference Rankings</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio D'Ambrosio &lt;antdambr@unina.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ConsRank</td>
</tr>
<tr>
<td>Imports:</td>
<td>janitor, methods, pracma, rlist, proxy</td>
</tr>
<tr>
<td>Description:</td>
<td>Tree-based classification and soft-clustering method for preference rankings, with tools for external validation of fuzzy clustering.
    It contains the recursive partitioning algorithm for preference rankings, non-parametric tree-based method for a matrix of preference rankings as a response variable. It contains also the distribution-free soft clustering method for preference rankings, namely the K-median cluster component analysis (CCA). 
    The package depends on the 'ConsRank' R package.
    Options for validate the tree-based method are both test-set procedure and V-fold cross validation.
    The package contains the routines to compute the adjusted concordance index (a fuzzy version of the adjusted rand index) and the normalized degree of concordance (the corresponding fuzzy version of the rand index).
    Essential references:
    D'Ambrosio, A., Amodio, S., Iorio, C., Pandolfo, G., and Siciliano, R. (2021) &lt;<a href="https://doi.org/10.1007%2Fs00357-020-09367-0">doi:10.1007/s00357-020-09367-0</a>&gt;
    D'Ambrosio, A., and Heiser, W.J. (2019) &lt;<a href="https://doi.org/10.1007%2Fs41237-018-0069-5">doi:10.1007/s41237-018-0069-5</a>&gt;;    
    D'Ambrosio, A., and Heiser W.J. (2016) &lt;<a href="https://doi.org/10.1007%2Fs11336-016-9505-1">doi:10.1007/s11336-016-9505-1</a>&gt;;
    Hullermeier, E., Rifqi, M., Henzgen, S., and Senge, R. (2012) &lt;<a href="https://doi.org/10.1109%2FTFUZZ.2011.2179303">doi:10.1109/TFUZZ.2011.2179303</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org/">https://www.r-project.org/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-28 09:53:29 UTC; Antonio</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio D'Ambrosio [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-28 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cca'>K-Median Cluster Component Analysis</h2><span id='topic+cca'></span>

<h3>Description</h3>

<p>K-Median Cluster Component Analysis, a distribution-free soft-clustering method
for preference rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cca(X, k, control = ccacontrol(...), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cca_+3A_x">X</code></td>
<td>
<p>A n by m data matrix containing preference rankings, in which there are n judges and m objects to be judged. Each row is a ranking of the objects which are represented by the columns.</p>
</td></tr>
<tr><td><code id="cca_+3A_k">k</code></td>
<td>
<p>The number of cluster components</p>
</td></tr>
<tr><td><code id="cca_+3A_control">control</code></td>
<td>
<p>a list of options that control details of the <code>cca</code> algorithm governed by the function
<code>ccacontrol</code>. The options govern maximum number of iterations of <code>cca</code> (itercca=1 is the default), the algorithm chosen to 
compute the median ranking (default, &quot;quick&quot;), and other options related
to the consrank algorithm, which is called by <code>cca</code></p>
</td></tr>
<tr><td><code id="cca_+3A_...">...</code></td>
<td>
<p>arguments passed bypassing <code>ccacontrol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can use any algorithm implemented in the <code>consrank</code> function from the <span class="pkg">ConsRank</span> package. All algorithms allow the user to set the option 'full=TRUE' 
if the median ranking(s) must be searched in the restricted space of permutations instead of in the unconstrained universe of rankings of n items including all possible ties. 
There are two classification uncertainty measures: Us and Uprods. &quot;Us&quot; is the geometric
mean of the membership probabilities of each individual, normalized in such a way that
in the case of maximum uncertainty Us=1. &quot;Ucca&quot; is the average of all the &quot;Us&quot;.
&quot;Uprods&quot; is the product of the membership probabilities of each individual, normalized in such a way that
in the case of maximum uncertainty Uprods=1. &quot;Uprodscca&quot; is the average of all the &quot;Uprods&quot;.
</p>


<h3>Value</h3>

<p>An object of the class &quot;cca&quot;. It contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
pk</td><td style="text-align: left;"> </td><td style="text-align: left;"> the membership probability matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
clc</td><td style="text-align: left;"> </td><td style="text-align: left;">  cluster centers</td>
</tr>
<tr>
 <td style="text-align: left;">
oclc </td><td style="text-align: left;"> </td><td style="text-align: left;"> cluster centers in terms of orderings</td>
</tr>
<tr>
 <td style="text-align: left;">
idc</td><td style="text-align: left;">  </td><td style="text-align: left;"> crisp partition: id of the cluster component associated with the highest membership probability</td>
</tr>
<tr>
 <td style="text-align: left;">
Hcca  </td><td style="text-align: left;"> </td><td style="text-align: left;"> Global homogeneity measure (tau_X rank correlation coefficient) </td>
</tr>
<tr>
 <td style="text-align: left;">
hk </td><td style="text-align: left;"> </td><td style="text-align: left;"> Homogeneity within cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
props </td><td style="text-align: left;"> </td><td style="text-align: left;"> estimated proportion of cases within cluster</td>
</tr>
<tr>
 <td style="text-align: left;">
Us </td><td style="text-align: left;"> </td><td style="text-align: left;"> Uncertainty measure per-individual (see details)</td>
</tr>
<tr>
 <td style="text-align: left;">
Ucca </td><td style="text-align: left;"> </td><td style="text-align: left;"> Global uncertainty measure</td>
</tr>
<tr>
 <td style="text-align: left;">
Uprods </td><td style="text-align: left;"> </td><td style="text-align: left;"> Uncertainty measure per-individual (see details)</td>
</tr>
<tr>
 <td style="text-align: left;">
Uprodscca </td><td style="text-align: left;"> </td><td style="text-align: left;"> Global uncertainty measure</td>
</tr>
<tr>
 <td style="text-align: left;">
consrankout </td><td style="text-align: left;"> </td><td style="text-align: left;"> complete output of rank aggregation algorithm, containing eventually multiple median rankings
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>References</h3>

<p>D'Ambrosio, A. and Heiser, W.J. (2019). A Distribution-free Soft Clustering Method for Preference Rankings. Behaviormetrika , vol. 46(2), pp. 333–351, DOI: 10.1007/s41237-018-0069-5
</p>
<p>Heiser W.J., and D'Ambrosio A. (2013). Clustering and Prediction of Rankings within a Kemeny Distance Framework. 
In Berthold, L., Van den Poel, D, Ultsch, A. (eds). Algorithms from and for Nature and Life.pp-19-31. Springer international. DOI: 10.1007/978-3-319-00035-0_2.
</p>
<p>Ben-Israel, A., and Iyigun, C. (2008). Probabilistic d-clustering. Journal of Classification, 25(1), pp.5-26. DOI: 10.1007/s00357-008-9002-z
</p>


<h3>See Also</h3>

<p><code>ccacontrol</code>
</p>
<p><code>ranktree</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Irish)
set.seed(135) #for reproducibility
# CCA with four components
ccares &lt;- cca(Irish$rankings, 4, itercca=10)
summary(ccares)



</code></pre>

<hr>
<h2 id='ccacontrol'>Utility function</h2><span id='topic+ccacontrol'></span>

<h3>Description</h3>

<p>Utility function to use to set the control arguments of <code>cca</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccacontrol(
  algorithm = "quick",
  full = FALSE,
  itercca = 1,
  consrankitermax = 10,
  np = 15,
  gl = 100,
  ff = 0.4,
  cr = 0.9,
  proc = FALSE,
  ps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccacontrol_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm used to compute the median ranking. One among&quot;BB&quot;, &quot;quick&quot; (default), &quot;fast&quot; and &quot;decor&quot;</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_full">full</code></td>
<td>
<p>Specifies if the median ranking must be searched in the universe of rankings including all the possible ties. Default: FALSE</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_itercca">itercca</code></td>
<td>
<p>Number of iterations of cca</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_consrankitermax">consrankitermax</code></td>
<td>
<p>Number of iterations for &quot;fast&quot; and &quot;decor&quot; algorithms. itermax=10 is the default option.</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_np">np</code></td>
<td>
<p>(for &quot;decor&quot; only) the number of population individuals. np=15 is the default option.</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_gl">gl</code></td>
<td>
<p>(for&quot;decor&quot; only) generations limit, maximum number of consecutive generations without improvement. gl=100 is the default option.</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_ff">ff</code></td>
<td>
<p>(for&quot;decor&quot; only) the scaling rate for mutation. Must be in [0,1]. ff=0.4 is the default option.</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_cr">cr</code></td>
<td>
<p>(for&quot;decor&quot; only) the crossover range. Must be in [0,1]. cr=0.9 is the default option.</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_proc">proc</code></td>
<td>
<p>(for &quot;BB&quot; only) proc=TRUE allows the branch and bound algorithm to work in difficult cases, i.e. when the number of objects is larger than 15 or 25. proc=FALSE is the default option</p>
</td></tr>
<tr><td><code id="ccacontrol_+3A_ps">ps</code></td>
<td>
<p>If PS=TRUE, on the screen some information about how many branches are processed are displayed. Default value: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all the control parameters
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca">cca</a></code>
</p>

<hr>
<h2 id='EVS'>
European Values Studies (EVS) data
</h2><span id='topic+EVS'></span>

<h3>Description</h3>

<p>Random sub-sample of 3584 cases of the survey conducted in 1999 in 32 countries analyzed by Vermunt (2003). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("EVS")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
</p>
<p>$ data:'data.frame':	1911 obs. of  11 variables:
</p>
<p>country, gender ,yearbird, mstatus (marital status), eduage (age of education completion), employment (Employment status: ordinal scale 1-8), householdinc (Household income: ordinal scale 1-10), A (Maintain order in Nation),Give people more say in Government decisions, (C) Fight rising prices, (D) Protect freedom of speech. 
</p>
<p>$ predictors:'data.frame' with all the predictors
</p>
<p>$ rankings  : matrix with the preferencres for &quot;A&quot; (Maintain order in Nation),  &quot;B&quot; (Give people more say in Government decisions), &quot;C&quot; (Fight rising prices), &quot;D&quot; (Protect freedom of speech).
</p>


<h3>Details</h3>

<p>Rankings were obtained by applying the post-materialism scale developed by Inglehart (1977). The scale is based upon an experiment of the type “pick 2 out of 4” most important political goals for your Governments. For this reason, replace the 'NA's with 3 before using the rankings with codes 'ranktree' or 'cca' (see D'Ambrosio and Heiser, 2016). 
About the predictors, the coding of the Countries are: G1 (Austria, Denmark, Netherlands, Sweden), G2 (Belgium, Croatia, France, Greece, Ireland, Northern Ireland, Spain), G3 (Bulgaria, Czechnia, East, Germany, Finland, Iceland, Luxembourg, Malta, Portugal, Romania, Slovenia, West Germany), G4 (Belarus, Estonia, Hungary, Latvia, Lithuania, Poland, Russia, Slovakia, Ukraine).
Coding of predictor &quot;mstatus&quot; are: mar (married), wid (widowed),  div (divorced), sep (separated), nevm (never married).
</p>


<h3>Source</h3>

<p>http://statisticalinnovations.com/technicalsupport/choice_datasets.html
</p>


<h3>References</h3>

<p>Vermunt, J. K. (2003). Multilevel latent class models. Sociological Methodology, 33(1), 213–239.
</p>
<p>Inglehart, R. (1977). The silent revolution: Changing values and political styles among Western Publics. Princeton, NJ: Princeton University Press.
</p>
<p>D'Ambrosio, A., and Heiser W.J. (2016). A recursive partitioning method for the prediction of preference rankings based upon Kemeny distances. Psychometrika, vol. 81 (3), pp.774-94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EVS)

# EVS$rankings[is.na(EVS$rankings)] &lt;- 3 #place unranked objects in a tie to the third position
# ccares &lt;- cca(EVS$rankings,4) #solution with 4 components

</code></pre>

<hr>
<h2 id='fuzzyconcordance'>Normalized Degree of Concordance (NDC) and Adjusted Concordance Index (ACI)</h2><span id='topic+fuzzyconcordance'></span>

<h3>Description</h3>

<p>Given two fuzzy (Ruspini) partitions, it compute the NDC and the ACI. NDC is the fuzzy version
of the Rand Index, as well as ACI is the fuzzy version of the Adjusted Rand Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzyconcordance(P, Q, nperms = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzyconcordance_+3A_p">P</code></td>
<td>
<p>A fuzzy partition. It has to be a matrix with n rows and k columns. 
Each column is expression of the degree of membership of the i-th row over the k partitions (see details).</p>
</td></tr>
<tr><td><code id="fuzzyconcordance_+3A_q">Q</code></td>
<td>
<p>A fuzzy partition. It has to be a matrix with n rows and h columns. 
Each column is expression of the degree of membership of the i-th row over the h partitions (see details).</p>
</td></tr>
<tr><td><code id="fuzzyconcordance_+3A_nperms">nperms</code></td>
<td>
<p>number of permutations necessary to compute ACI. Default: 1000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both P and Q, or only one of those, can be crisp (or hard) partitions. In this case, each row must contain
either 0 or 1, and the sum of the i-th row must be 1. In other words, either P or Q (or both) are
expressed in terms of dummy coding. If both partitions are crisp, then NDC is equal to Rand Index 
and ACI is equal to Adjusted Rand Index.
This function can be used to externally validate the output of any fuzzy clustering method
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
ACI </td><td style="text-align: left;"> </td><td style="text-align: left;"> the Adjusted Concordance Index</td>
</tr>
<tr>
 <td style="text-align: left;">
NDC </td><td style="text-align: left;"> </td><td style="text-align: left;"> the Normalized Degree of Concordance
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>References</h3>

<p>D’Ambrosio, A., Amodio, S., Iorio, C., Pandolfo, G. and Siciliano, R. (2021).
Adjusted Concordance Index: an Extension of the Adjusted Rand Index to Fuzzy Partitions. 
Journal of Classification vol. 38(1), pp. 112–128 (2021). DOI: 10.1007/s00357-020-09367-0
</p>
<p>Hullermeier, E., Rifqi, M., Henzgen, S., and Senge, R. (2012). Comparing fuzzy partitions: a generalization of the 
Rand index and related measures. IEEE Transactions on Fuzzy Systems, 20(3), 546–556. DOI: 10.1109/TFUZZ.2011.2179303
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca">cca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#two random fuzzy partitions
P = rbind(c(0.5259,  0.1656,    0.3085),
c(0.5623,    0.1036,    0.3341),
c(0.2508,    0.1849,    0.5643),
c(0.5654,    0.1934,    0.2413),
c(0.4529,    0.1679,    0.3792),
c(0.2390,    0.1758,    0.5852),
c(0.3114,    0.1743,    0.5143),
c(0.4188,    0.1392,    0.4420),
c(0.5830,    0.1655,    0.2514),
c(0.5860,    0.1171,    0.2969),
c(0.2630,    0.1706,    0.5664),
c(0.5882,    0.1032,    0.3086),
c(0.5829,    0.1277,    0.2894),
c(0.3942,    0.1046,    0.5012),
c(0.5201,    0.1097,    0.3702),
c(0.2568,    0.1823,    0.5609),
c(0.3687,    0.1695,    0.4618),
c(0.5663,    0.1317,    0.3020),
c(0.5169,    0.1950,    0.2881),
c(0.5838,    0.1034,    0.3128))

Q = rbind(c(0.4494,    0.3755,    0.1751),
c(0.5219,    0.3526,    0.1255),
c(0.3432,    0.5062,    0.1506),
c(0.3120,    0.5181,    0.1699),
c(0.5362,    0.2747,    0.1891),
c(0.4082,    0.3959,    0.1959),
c(0.4670,    0.3782,    0.1547),
c(0.4276,    0.4585,    0.1139),
c(0.4013,    0.4837,    0.1149),
c(0.3724,    0.5019,    0.1258),
c(0.5055,    0.3104,    0.1841),
c(0.4027,    0.4719,    0.1254),
c(0.3565,    0.4620,    0.1814),
c(0.6106,    0.2650,    0.1244),
c(0.5595,    0.2476,    0.1929),
c(0.4657,    0.3993,    0.1350),
c(0.2964,    0.5839,    0.1197),
c(0.5387,    0.3362,    0.1251),
c(0.4043,    0.4341,    0.1616),
c(0.5631,    0.2895,    0.1473))
         
ci &lt;- fuzzyconcordance(P,Q) 

#generate a random fuzzy partition with two components (clusters)
Q2 &lt;- matrix(runif(20),ncol=1)
Q2 &lt;- cbind(Q2,1-Q2)

ci2 &lt;- fuzzyconcordance(P,Q2)

#generate a random crisp partition
P2 &lt;- t(rmultinom(20,1,c(0.3,0.3,0.4)))

ci3 &lt;- fuzzyconcordance(P2,Q)
#--------------------
## Not run: 
# install.packages("Rankcluster")
library("Rankcluster") # model-based clustering algorithm for
                     #  ranking data by Biernacki and Jacques (2013)
                     #  &lt;doi:10.1016/j.csda.2012.08.008&gt;
data(APA)
set.seed(136) #for reproducibility
rcres &lt;- rankclust(APA$data,K=3)  # solution with 3 centers, it takes about 75 seconds
##
ccares &lt;- cca(APA$data,k=3) #solution with 3 components, it takes about 7 seconds
##
ci &lt;- fuzzyconcordance(rcres[3]@tik,ccares$pk)
ci$ACI  # 0.0226 means that the two partitions are similar (see NDC below), 
        # but their similarity is mainly due to chance
ci$NDC

## End(Not run)
 
  
    
</code></pre>

<hr>
<h2 id='getsubtree'>Determine a tree from the main tree-based structure</h2><span id='topic+getsubtree'></span>

<h3>Description</h3>

<p>Given a tree belonging to the class &quot;ranktree&quot;, determine a subtree with a given number of terminal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsubtree(Tree, cut, tokeep = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getsubtree_+3A_tree">Tree</code></td>
<td>
<p>An object of the class &quot;ranktree&quot; coming form te function <code>ranktree</code></p>
</td></tr>
<tr><td><code id="getsubtree_+3A_cut">cut</code></td>
<td>
<p>The maximum number of terminal nodes that the Tree must have</p>
</td></tr>
<tr><td><code id="getsubtree_+3A_tokeep">tokeep</code></td>
<td>
<p>parameter invoked by other internal functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the pruning sequence returns a series of subtrees with, say, 1,2,4,7,9 terminal nodes and the user set cut=8, 
the function extract the subtree with 7 terminal nodes.
</p>


<h3>Value</h3>

<p>An object of the class &quot;ranktree&quot;, containing the same information of the output of the function <code>ranktree</code>
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Univranks")
tree &lt;- ranktree(Univranks$rankings,Univranks$predictors,num=50)
#see how many terminal nodes have the trees compomimg the nested sequence of subtrees
infoprun &lt;- tree$pruneinfo$termnodes
#select the tree with, say, 6 terminal nodes
tree6 &lt;- getsubtree(tree,6)


</code></pre>

<hr>
<h2 id='Irish'>
Irish Election data set
</h2><span id='topic+Irish'></span>

<h3>Description</h3>

<p>An opinion poll conducted by Irish Marketing Surveys one month prior to the election in 1997. Interviews were conducted on about 1100 respondents, drawn from 100 sampling areas. Interviews took place at randomly located homes, with respondents selected according to a socioeconomic quota. A range of sociological questions was asked of each respondent, as was their voting preference, if any, for each of the candidates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Irish")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
</p>
<p>$ IrishElection: 'data.frame':	1083 obs. of  11 variables:
Gender (male, housewife, nonhousewife),  marital status (single, married, separated), age, socialclass (five unordered categories), Area (rural, city, town), government satisfaction (no opinion,m satisfied, dissatisfied), Bano , Roch, McAl, Nall, Scal
</p>
<p>$ predictors   :'data.frame' with all the predictors
</p>
<p>$ rankings     : matrix with the preferencres for &quot;Bano&quot; &quot;Roch&quot; &quot;McAl&quot; &quot;Nall&quot; 
</p>


<h3>Details</h3>

<p>In the original version of the data, the ranking matrix contains NAs. Here, NAs are replaced with the number 7, to indicate that all the non-stated preferences are in a tie at the last position (see D'Ambrosio and Heiser, 2016). For details about the data set see Gormley and Murphy, 2008.
</p>


<h3>Source</h3>

<p>https://projecteuclid.org/journals/annals-of-applied-statistics/volume-2/issue-4/A-mixture-of-experts-model-for-rank-data-with/10.1214/08-AOAS178.full?tab=ArticleLinkSupplemental
</p>


<h3>References</h3>

<p>Gormley, I.C., and Murphy, T.B. (2008). A mixture of experts model for rank data withapplications in election studies. Annals of Applied Statistics 2(4): 1452-1477. DOI: 10.1214/08-AOAS178
</p>
<p>D'Ambrosio, A., and Heiser W.J. (2016). A recursive partitioning method for the prediction of preference rankings based upon Kemeny distances. Psychometrika, vol. 81 (3), pp.774-94. DOI: 10.1007/s11336-016-9505-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Irish)
</code></pre>

<hr>
<h2 id='layouttree'>Utility function</h2><span id='topic+layouttree'></span>

<h3>Description</h3>

<p>A utility function completing the output of the function <code>ranktree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layouttree(Tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layouttree_+3A_tree">Tree</code></td>
<td>
<p>an object of the class &quot;ranktree&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the class &quot;ranktree&quot; completing the output of the function <code>ranktree</code>
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>

<hr>
<h2 id='nodepath'>Path of a terminal node</h2><span id='topic+nodepath'></span>

<h3>Description</h3>

<p>Given an object of the class &quot;ranktree&quot;, it visualize the path leading to the terminal node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodepath(termnode, Tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodepath_+3A_termnode">termnode</code></td>
<td>
<p>The terminal node of which the path has to be extracted</p>
</td></tr>
<tr><td><code id="nodepath_+3A_tree">Tree</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path leading to the terminal node
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranktree">ranktree</a></code>, <code><a href="#topic+treepaths">treepaths</a></code>, <code><a href="#topic+getsubtree">getsubtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Irish)
#build the tree with default options
tree &lt;- ranktree(Irish$rankings,Irish$predictors)
#get information about all the paths leading to terminal nodes
paths &lt;- treepaths(tree)
#see the path for terminal node number 8
nodepath(termnode=8,tree)

 
</code></pre>

<hr>
<h2 id='plot.ranktree'>Plot tree-based structure or pruning sequence of ranktree</h2><span id='topic+plot.ranktree'></span>

<h3>Description</h3>

<p>Plot the tree coming from the <code>ranktree</code> or the pruning sequence of the <code>ranktree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranktree'
plot(
  x,
  plot.type = "tree",
  dispclass = FALSE,
  valtree = NULL,
  taos = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ranktree_+3A_x">x</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
<tr><td><code id="plot.ranktree_+3A_plot.type">plot.type</code></td>
<td>
<p>One among &quot;tree&quot; or &quot;pruningseq&quot;</p>
</td></tr>
<tr><td><code id="plot.ranktree_+3A_dispclass">dispclass</code></td>
<td>
<p>Display the median ranking above terminal nodes. Default option: FALSE</p>
</td></tr>
<tr><td><code id="plot.ranktree_+3A_valtree">valtree</code></td>
<td>
<p>If plot.type=&quot;pruningseq&quot;, it shows the Tau_x rank correlation coefficient or the error along the pruning sequence on the training set. If valtree is the output of the function <code>validatetree</code>, it shows either the Tau_x rank correlation coefficient or the error along the pruning sequence of also the decision tree (validated by wither test set or cross-validation)</p>
</td></tr>
<tr><td><code id="plot.ranktree_+3A_taos">taos</code></td>
<td>
<p>If plot.type=&quot;pruningseq&quot;, it plots the Tau_x rank correlation coefficient along the pruning sequence. If taos=FALSE, it plots the error.</p>
</td></tr>
<tr><td><code id="plot.ranktree_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the plot of either the tree or the pruning sequence
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranktree">ranktree</a></code>,  <code><a href="#topic+validatetree">validatetree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Univranks")
tree &lt;- ranktree(Univranks$rankings,Univranks$predictors,num=50)
plot(tree,dispclass=TRUE)
  

data(EVS)
EVS$rankings[is.na(EVS$rankings)] &lt;- 3
set.seed(654)
training=sample(1911,1434)
tree &lt;- ranktree(EVS$rankings[training,],EVS$predictors[training,],decrmin=0.001,num=50)
plot(tree,dispclass=TRUE)
#test set validation
vtreetest &lt;- validatetree(tree,testX=EVS$predictors[-training,],EVS$rankings[-training,]) 
dtree &lt;- getsubtree(tree,vtreetest$best_tau)
plot(dtree,dispclass=TRUE)
#see the global weigthted tau_X rank correlation coefficients
plot(tree,plot.type="pruningseq",valtree=vtreetest)
#see the error rates
plot(tree,plot.type="pruningseq",valtree=vtreetest, taos=FALSE)


</code></pre>

<hr>
<h2 id='predict.ranktree'>Predict the median rankings for new observations</h2><span id='topic+predict.ranktree'></span>

<h3>Description</h3>

<p>Predict the median rankings in a tree-based structure built with <code>ranktree</code> for new observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranktree'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ranktree_+3A_object">object</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
<tr><td><code id="predict.ranktree_+3A_newx">newx</code></td>
<td>
<p>A dataframe of the same nature of the predictor dataframe with which the tree has been built</p>
</td></tr>
<tr><td><code id="predict.ranktree_+3A_...">...</code></td>
<td>
<p>System reserved (No specific usage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
rankings </td><td style="text-align: left;"> </td><td style="text-align: left;"> the fit in terms of rankings</td>
</tr>
<tr>
 <td style="text-align: left;">
orderings </td><td style="text-align: left;">  </td><td style="text-align: left;"> the fit in terms of orderings</td>
</tr>
<tr>
 <td style="text-align: left;">
info</td><td style="text-align: left;"> </td><td style="text-align: left;"> dataframe containing the terminal nodes in which the new x fall down, then the new x and the fit (in terms of rankings)
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranktree">ranktree</a></code>  <code><a href="#topic+validatetree">validatetree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EVS)
EVS$rankings[is.na(EVS$rankings)] &lt;- 3
set.seed(654)
training=sample(1911,1434)
tree &lt;- ranktree(EVS$rankings[training,],EVS$predictors[training,],decrmin=0.001,num=50)
#use the function predict ro predict rankings for new predictors
rankfit &lt;- predict(tree,newx=EVS$predictors[-training,])
#fit in terms of rankings
rankfit$rankings
#fit in terms of orderings
rankfit$orderings
# information about the fit (terminal node, predictor and fit (in terms of rankings))
rankfit$info




</code></pre>

<hr>
<h2 id='print.cca'>S3 methods for cca</h2><span id='topic+print.cca'></span>

<h3>Description</h3>

<p>Print methods for objects of class <code>cca</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cca'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cca_+3A_x">x</code></td>
<td>
<p>An object of the class &quot;cca&quot;</p>
</td></tr>
<tr><td><code id="print.cca_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print a brief summary of the CCA
</p>

<hr>
<h2 id='print.ranktree'>S3 methods for ranktree</h2><span id='topic+print.ranktree'></span>

<h3>Description</h3>

<p>Print methods for objects of class <code>ranktree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranktree'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ranktree_+3A_x">x</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
<tr><td><code id="print.ranktree_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print a brief summary of the prediction tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Univranks")
tree &lt;- ranktree(Univranks$rankings,Univranks$predictors,num=50)
tree



</code></pre>

<hr>
<h2 id='ranktree'>Recursive partitioning method for the prediction of preference rankings based upon Kemeny distances</h2><span id='topic+ranktree'></span>

<h3>Description</h3>

<p>Recursive partitioning method for the prediction of preference rankings based upon Kemeny distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranktree(Y, X, prunplot = FALSE, control = ranktreecontrol(...), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranktree_+3A_y">Y</code></td>
<td>
<p>A n by m data matrix, in which there are n judges and m objects to be judged. Each row is a ranking of the objects which are represented by the columns.</p>
</td></tr>
<tr><td><code id="ranktree_+3A_x">X</code></td>
<td>
<p>A dataframe containing the predictor, that must have n rows.</p>
</td></tr>
<tr><td><code id="ranktree_+3A_prunplot">prunplot</code></td>
<td>
<p>prunplot=TRUE returns the plot of the pruning sequence. Default value: FALSE</p>
</td></tr>
<tr><td><code id="ranktree_+3A_control">control</code></td>
<td>
<p>a list of options that control details of the <code>ranktree</code> algorithm governed by the function
<code>ranktreecontrol</code>. The options govern the minimum size within node to split (the default value is 0.1*n, where n is the total sample size), the bound on the decrease in impurity,
(default, 0.01), the algorithm chosen to compute the median ranking (default, &quot;quick&quot;), and other options related
to the consrank algorithm, which is called by <code>ranktree</code></p>
</td></tr>
<tr><td><code id="ranktree_+3A_...">...</code></td>
<td>
<p>arguments passed bypassing <code>ranktreecontrol</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can use any algorithm implemented in the <code>consrank</code> function from the <span class="pkg">ConsRank</span> package. All algorithms allow the user to set the option 'full=TRUE' 
if the median ranking(s) must be searched in the restricted space of permutations instead of in the unconstrained universe of rankings of n items including all possible ties. 
The output consists in a object of the class &quot;ranktree&quot;. It contains:
</p>

<table>
<tr>
 <td style="text-align: left;">
X</td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> the predictors: it must be a dataframe</td>
</tr>
<tr>
 <td style="text-align: left;">
Y</td><td style="text-align: left;"> </td><td style="text-align: left;">  </td><td style="text-align: left;"> the response variable: the matrix of the rankings</td>
</tr>
<tr>
 <td style="text-align: left;">
node</td><td style="text-align: left;">  </td><td style="text-align: left;"> </td><td style="text-align: left;"> a list containing teh tree-based structure:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> number </td><td style="text-align: left;"> </td><td style="text-align: left;"> node number </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> terminal </td><td style="text-align: left;"> </td><td style="text-align: left;"> logical: TRUE is terminal node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> father </td><td style="text-align: left;"> </td><td style="text-align: left;"> father node number of the current node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> idfather </td><td style="text-align: left;"> </td><td style="text-align: left;"> id of the father node of the current node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> size </td><td style="text-align: left;"> </td><td style="text-align: left;"> sample size within node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> impur </td><td style="text-align: left;"> </td><td style="text-align: left;"> impurity at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> wimpur </td><td style="text-align: left;"> </td><td style="text-align: left;"> weighted impurity at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> idatnode </td><td style="text-align: left;"> </td><td style="text-align: left;"> id of the observations within node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> class </td><td style="text-align: left;"> </td><td style="text-align: left;"> median ranking within node in terms of orderings</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> nclass </td><td style="text-align: left;"> </td><td style="text-align: left;"> median ranking within node in terms of rankings</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> mclass </td><td style="text-align: left;"> </td><td style="text-align: left;"> eventual multiple median rankings</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> tau </td><td style="text-align: left;"> </td><td style="text-align: left;"> Tau_x rank correlation coefficient at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> wtau </td><td style="text-align: left;"> </td><td style="text-align: left;"> weighted Tau_x rank correlation coefficient at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> error </td><td style="text-align: left;"> </td><td style="text-align: left;"> error at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> werror </td><td style="text-align: left;"> </td><td style="text-align: left;"> weighted error at node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> varsplit </td><td style="text-align: left;"> </td><td style="text-align: left;"> variables generating split</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> varsplitid </td><td style="text-align: left;"> </td><td style="text-align: left;"> id of variables generating split</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> cutspli </td><td style="text-align: left;"> </td><td style="text-align: left;"> splitting point</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> children </td><td style="text-align: left;"> </td><td style="text-align: left;"> children nodes generated by current node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> idchildren </td><td style="text-align: left;"> </td><td style="text-align: left;"> id of children nodes generated by current node</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> ... </td><td style="text-align: left;"> </td><td style="text-align: left;"> other info about node</td>
</tr>
<tr>
 <td style="text-align: left;">
control </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> parameters used to build the tree</td>
</tr>
<tr>
 <td style="text-align: left;">
numnodes </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of nodes of the tree</td>
</tr>
<tr>
 <td style="text-align: left;">
tsynt </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> list containing the synthesis of the tree:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> children </td><td style="text-align: left;"> </td><td style="text-align: left;"> list containing all information about leaves</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> parents </td><td style="text-align: left;"> </td><td style="text-align: left;"> list containing all information about parent nodes</td>
</tr>
<tr>
 <td style="text-align: left;">
geneaoly </td><td style="text-align: left;">  </td><td style="text-align: left;"> </td><td style="text-align: left;"> data frame containing information about all nodes</td>
</tr>
<tr>
 <td style="text-align: left;">
idgenealogy </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> data frame containing information about all nodes in terms of nodes id</td>
</tr>
<tr>
 <td style="text-align: left;">
idparents </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> id of the parents of all the nodes</td>
</tr>
<tr>
 <td style="text-align: left;">
goodness </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> goodness -and badness- of fit measures of the tree: Tau_X, error, impurity</td>
</tr>
<tr>
 <td style="text-align: left;">
nomin </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> information about nature of the predictors</td>
</tr>
<tr>
 <td style="text-align: left;"> 
alpha </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> alpha parameter for pruning sequence</td>
</tr>
<tr>
 <td style="text-align: left;">
pruneinfo </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> list containing information about the pruning sequence:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> prunelist </td><td style="text-align: left;"> </td><td style="text-align: left;"> information about the pruning</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> tau </td><td style="text-align: left;"> </td><td style="text-align: left;"> tau_X rank correlation coefficient of each subtree</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> error </td><td style="text-align: left;"> </td><td style="text-align: left;"> error of each subtree</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> termnodes </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of terminal nodes of each subtree</td>
</tr>
<tr>
 <td style="text-align: left;">
subtrees </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td><td style="text-align: left;"> list of each subtree created with the cost-complexity pruning procedure
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of the class ranktree. See details for detailed information.
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>References</h3>

<p>D'Ambrosio, A., and Heiser W.J. (2016). A recursive partitioning method for the prediction of preference rankings based upon Kemeny distances. Psychometrika, vol. 81 (3), pp.774-94.
</p>


<h3>See Also</h3>

<p><code>ranktreecontrol</code>, <code>plot.ranktree</code>, <code>summary.ranktree</code>, <code>getsubtree</code>, <code>validatetree</code>, <code>treepaths</code>, <code>nodepath</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Univranks")
tree &lt;- ranktree(Univranks$rankings,Univranks$predictors,num=50)


data(Irish)
#build the tree with default options
tree &lt;- ranktree(Irish$rankings,Irish$predictors)

#plot the tree
plot(tree,dispclass=TRUE)

#visualize information
summary(tree)

#get information about the paths leading to terminal nodes (all the paths)
infopaths &lt;- treepaths(tree)

#the terminal nodes
infopaths$leaves

#sample size within each terminal node
infopaths$size

#visualize the path of the second leave (terminal node number 8)
infopaths$paths[[2]]

#alternatively
nodepath(termnode=8,tree)


set.seed(132) #for reproducibility
#validation of the tree via v-fold cross-validation (default value of V=5)
vtree &lt;- validatetree(tree,method="cv")

#extract the "best" tree
dtree &lt;- getsubtree(tree,vtree$best_tau)

summary(dtree)

#plot the validated tree
plot(dtree,dispclass=TRUE)

#predicted rankings
rankfit &lt;- predict(dtree,newx=Irish$predictors)

#fit of rankings
rankfit$rankings

#fit in terms of orderings
rankfit$orderings

#all info about the fit (id og the leaf, predictor values, and fit)
rankfit$orderings



</code></pre>

<hr>
<h2 id='ranktreecontrol'>Utility function</h2><span id='topic+ranktreecontrol'></span>

<h3>Description</h3>

<p>Utility function to use to set the control arguments of <code>ranktree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranktreecontrol(
  num = NULL,
  decrmin = 0.01,
  algorithm = "quick",
  full = FALSE,
  itermax = 10,
  np = 15,
  gl = 100,
  ff = 0.4,
  cr = 0.9,
  proc = FALSE,
  ps = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranktreecontrol_+3A_num">num</code></td>
<td>
<p>The maximum number of observations in a node to be split: default, 10% of the sample size</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_decrmin">decrmin</code></td>
<td>
<p>Minimum decrease in impurity</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm used to compute the median ranking. One among&quot;BB&quot;, &quot;quick&quot; (default), &quot;fast&quot; and &quot;decor&quot;</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_full">full</code></td>
<td>
<p>Specifies if the median ranking must be searched in the universe of rankings including all the possible ties. Default: FALSE</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_itermax">itermax</code></td>
<td>
<p>Number of iterations for &quot;fast&quot; and &quot;decor&quot; algorithms. itermax=10 is the default option.</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_np">np</code></td>
<td>
<p>(for &quot;decor&quot; only) the number of population individuals. np=15 is the default option.</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_gl">gl</code></td>
<td>
<p>(for&quot;decor&quot; only) generations limit, maximum number of consecutive generations without improvement. gl=100 is the default option.</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_ff">ff</code></td>
<td>
<p>(for&quot;decor&quot; only) the scaling rate for mutation. Must be in [0,1]. ff=0.4 is the default option.</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_cr">cr</code></td>
<td>
<p>(for&quot;decor&quot; only) the crossover range. Must be in [0,1]. cr=0.9 is the default option.</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_proc">proc</code></td>
<td>
<p>(for &quot;BB&quot; only) proc=TRUE allows the branch and bound algorithm to work in difficult cases, i.e. when the number of objects is larger than 15 or 25. proc=FALSE is the default option</p>
</td></tr>
<tr><td><code id="ranktreecontrol_+3A_ps">ps</code></td>
<td>
<p>If PS=TRUE, on the screen some information about how many branches are processed are displayed. Default value: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all the control parameters
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranktree">ranktree</a></code>
</p>

<hr>
<h2 id='summary.cca'>S3 methods for ranktree</h2><span id='topic+summary.cca'></span>

<h3>Description</h3>

<p>Summary methods for objects of class <code>cca</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cca'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cca_+3A_object">object</code></td>
<td>
<p>An object of the class &quot;cca&quot;</p>
</td></tr>
<tr><td><code id="summary.cca_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it shows the summary of the prediction tree
</p>

<hr>
<h2 id='summary.ranktree'>S3 methods for ranktree</h2><span id='topic+summary.ranktree'></span>

<h3>Description</h3>

<p>Summary methods for objects of class <code>ranktree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranktree'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ranktree_+3A_object">object</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
<tr><td><code id="summary.ranktree_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it shows the summary of the prediction tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Univranks")
tree &lt;- ranktree(Univranks$rankings,Univranks$predictors,num=50)
summary(tree)

</code></pre>

<hr>
<h2 id='treepaths'>Path of a terminal node</h2><span id='topic+treepaths'></span>

<h3>Description</h3>

<p>Given an object of the class &quot;ranktree&quot;, it extracts the paths of all terminal nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treepaths(Tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treepaths_+3A_tree">Tree</code></td>
<td>
<p>An object of the class &quot;ranktree&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
leaves</td><td style="text-align: left;"> </td><td style="text-align: left;"> the number of the terminal nodes</td>
</tr>
<tr>
 <td style="text-align: left;">
size</td><td style="text-align: left;">  </td><td style="text-align: left;"> the sample size within each terminal nodes</td>
</tr>
<tr>
 <td style="text-align: left;">
paths</td><td style="text-align: left;"> </td><td style="text-align: left;"> a list containing all the paths</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranktree">ranktree</a></code>, <code><a href="#topic+nodepath">nodepath</a></code>, <code><a href="#topic+getsubtree">getsubtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Irish)
#build the tree with default options
tree &lt;- ranktree(Irish$rankings,Irish$predictors)
#get information about all the paths leading to terminal nodes
paths &lt;- treepaths(tree)
#
#the terminal nodes
paths$leaves
#
#sample size within each terminal node
paths$size
#
#visualize the path of the second leave (terminal node number 8)
paths$paths[[2]]



</code></pre>

<hr>
<h2 id='Univranks'>
University rankings dataset.
</h2><span id='topic+Univranks'></span>

<h3>Description</h3>

<p>University rankings dataset was analysed by Dittrich, Hatzinger and Katzenbeisser (1998) to investigate paired comparison data concerning European universities and student's characteristics with the goal to show that university rankings are different for different groups of students. Here both raw data (with paired comparisons) and the version with rankings are preesented (see details). A survey of 303 students studying at the Vienna University of Economics was carried out to examine the student's preference of six universities, namely London, Paris, Milan, St. Gallen, Barcelona and Stockholm. The data set contains 23 variables. The first 15 digits in each row indicate the preferences of a student. For a given comparison, responses were coded by 1 if the first preference was preferred, by 2 if the second university was preferred, and by 3 if universities are tied. All rows containing missing ranked Universities were skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Univranks")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
</p>
<p>$ rawdata: 'data.frame':	212 obs. of  23 variables: the first 15 are the paired comparisons coded as follows: (1: the first is preferred to the second; 2: the second is preferred to the fisrt; 3 tied)
</p>
<p>$ LP  : comparison of London to Paris 
</p>
<p>$ LM  : comparison of London to Milan
</p>
<p>$ PM  : comparison of London to Milan
</p>
<p>$ LSg : comparison of London to St. Gallen
</p>
<p>$ PSg : comparison of Paris to St. Gallen
</p>
<p>$ MSg : comparison of  Milan to St. Gallen
</p>
<p>$ LB  : comparison of London to Barcelona
</p>
<p>$ PB  : comparison of Paris to Barcelona
</p>
<p>$ MB  : comparison of Milan to Barcelona
</p>
<p>$ SgB : comparison of St. Gallen to Barcelona
</p>
<p>$ LSt : comparison of London to Stockholm
</p>
<p>$ PSt : comparison of Paris to Stockholm
</p>
<p>$ MSt : comparison of Milan to Stockholm
</p>
<p>$ SgSt: comparison of St. Gallen to Stockholm
</p>
<p>$ BSt : comparison of Barcelona to Stockholm
</p>
<p>$ Stud: Factor w/ 2 levels &quot;commerce&quot;,&quot;other&quot; 
</p>
<p>$ Eng : Factor w/ 2 levels &quot;good&quot;,&quot;poor&quot;&quot;
</p>
<p>$ Fra : Factor w/ 2 levels &quot;good&quot;,&quot;poor&quot;
</p>
<p>$ Spa : Factor w/ 2 levels &quot;good&quot;,&quot;poor&quot;
</p>
<p>$ Ita : Factor w/ 2 levels &quot;good&quot;,&quot;poor&quot;
</p>
<p>$ Wor : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;
</p>
<p>$ Deg : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;
</p>
<p>$ Sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;
</p>
<p>$ predictors:'data.frame':	212 obs. of  8 variables( the last 8 variables of the &quot;rawdata&quot; dataframe
</p>
<p>$ rankings  : matrix of preference rankings. The columns are: &quot;L&quot; (London), &quot;P&quot; (Paris), &quot;M&quot; (Milan), &quot;Sg&quot; (St. Gallen), &quot;B&quot; (Barcerlona), &quot;St&quot; (Stockholm)
</p>


<h3>Details</h3>

<p>To obtain the preference rankings from the paired comparisons the procedure has been the following: the first row of the raw data is [1  3  2   1   2   1  1  2  1   1   1   2   1    1   2]. London is preferred to Paris, St. Gallen, Barcelona Stockholm (LP, LM, LSg, LB and LSt are always equal to 1), and there is no preference between London and Milan (they are tied); Milan is preferred to Paris (PM = 2), St. Gallen, Barcelona and Stockholm; and so on. The first ordering is then &lt;L M Sg St B P&gt; corresponding to a ranking [1,5,1,2,4,3], where the columns indicate L  P  M Sg  B St.  
</p>


<h3>Source</h3>

<p>http://www.blackwellpublishers.co.uk/rss
</p>


<h3>References</h3>

<p>Dittrich, R., Hatzinger, R., and Katzenbeisser, W. (1998). Modelling the effect of subject-specific covariates in paired comparison studies with an application to university rankings. Journal of the Royal Statistical Society: Series C (Applied Statistics), 47(4), 511-525. DOI: 10.1111/1467-9876.00125
</p>
<p>D'Ambrosio, A. (2008). Tree based methods for data editing and preference rankings. Ph.D. thesis, University of Naples Federico II. <a href="https://www.doi.org/10.6092/UNINA/FEDOA/2746">https://www.doi.org/10.6092/UNINA/FEDOA/2746</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Univranks)
</code></pre>

<hr>
<h2 id='validatetree'>Validation of the tree for preference rankings</h2><span id='topic+validatetree'></span>

<h3>Description</h3>

<p>Validation of the tree either with a test set procedure or with v-fold cross validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validatetree(
  Tree,
  testX = NULL,
  testY = NULL,
  method = "test",
  V = 5,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validatetree_+3A_tree">Tree</code></td>
<td>
<p>An object of the class &quot;ranktree&quot; coming form te function <code>ranktree</code></p>
</td></tr>
<tr><td><code id="validatetree_+3A_testx">testX</code></td>
<td>
<p>The data frame containing the test set (predictors)</p>
</td></tr>
<tr><td><code id="validatetree_+3A_testy">testY</code></td>
<td>
<p>The matrix ontaining the test set (response)</p>
</td></tr>
<tr><td><code id="validatetree_+3A_method">method</code></td>
<td>
<p>One between &quot;test&quot; (default) or &quot;cv&quot;</p>
</td></tr>
<tr><td><code id="validatetree_+3A_v">V</code></td>
<td>
<p>The cross-validation parameter. Default V=5</p>
</td></tr>
<tr><td><code id="validatetree_+3A_plotting">plotting</code></td>
<td>
<p>With the defaul option plotting=TRUE, the pruning sequence plot is visualized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
tau </td><td style="text-align: left;"> </td><td style="text-align: left;"> the Tau_x rank correlation coefficient of the sequence of the trees</td>
</tr>
<tr>
 <td style="text-align: left;">
error </td><td style="text-align: left;">  </td><td style="text-align: left;"> the error of the sequence of the trees</td>
</tr>
<tr>
 <td style="text-align: left;">
termnodes</td><td style="text-align: left;"> </td><td style="text-align: left;"> the number of terminal nodes of the sequence of the trees</td>
</tr>
<tr>
 <td style="text-align: left;">
best_tau </td><td style="text-align: left;"> </td><td style="text-align: left;"> the best tree in terms of Tau_x rank correlation coefficient</td>
</tr>
<tr>
 <td style="text-align: left;">
best_error </td><td style="text-align: left;"> </td><td style="text-align: left;"> the best tree in terms of error (it is the same)</td>
</tr>
<tr>
 <td style="text-align: left;">
validation </td><td style="text-align: left;"> </td><td style="text-align: left;"> information about the validation procedure</td>
</tr>

</table>
<p>#'
</p>


<h3>Author(s)</h3>

<p>Antonio D'Ambrosio <a href="mailto:antdambr@unina.it">antdambr@unina.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(EVS)
EVS$rankings[is.na(EVS$rankings)] &lt;- 3
set.seed(654)
training=sample(1911,1434)
tree &lt;- ranktree(EVS$rankings[training,],EVS$predictors[training,],decrmin=0.001,num=50)
#test set validation
vtreetest &lt;- validatetree(tree,testX=EVS$predictors[-training,],EVS$rankings[-training,]) 
#cross-validation
vtreecv &lt;- validatetree(tree,method="cv",V=10) 


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
