<!DOCTYPE html><html lang="en"><head><title>Help for package websocket</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {websocket}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WebSocket'><p>Create a WebSocket client</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Title:</td>
<td>'WebSocket' Client Library</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a 'WebSocket' client interface for R.
    'WebSocket' is a protocol for low-overhead real-time communication:
    <a href="https://en.wikipedia.org/wiki/WebSocket">https://en.wikipedia.org/wiki/WebSocket</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, later (&ge; 1.2.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, AsioHeaders, later</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/websocket/issues">https://github.com/rstudio/websocket/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, OpenSSL &gt;= 1.0.2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httpuv, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-22 17:16:18 UTC; winston</td>
</tr>
<tr>
<td>Author:</td>
<td>Winston Chang [aut, cre],
  Joe Cheng [aut],
  Alan Dipert [aut],
  Barbara Borges [aut],
  Posit, PBC [cph],
  Peter Thorson [ctb, cph] (WebSocket++ library),
  Ren√© Nyffenegger [ctb, cph] (Base 64 library),
  Micael Hildenborg [ctb, cph] (SHA1 library),
  Aladdin Enterprises [cph] (MD5 library),
  Bjoern Hoehrmann [ctb, cph] (UTF8 Validation library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Winston Chang &lt;winston@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-22 22:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='WebSocket'>Create a WebSocket client</h2><span id='topic+WebSocket'></span>

<h3>Description</h3>

<pre>
WebSocket$new(url,
  protocols = character(0),
  headers = NULL,
  autoConnect = TRUE,
  accessLogChannels = c("none"),
  errorLogChannels = NULL,
  maxMessageSize = 32 * 1024 * 1024)
</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WebSocket_+3A_url">url</code></td>
<td>
<p>The WebSocket URL. Should begin with <code>ws://</code> or <code>wss://</code>.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_protocols">protocols</code></td>
<td>
<p>Zero or more WebSocket sub-protocol names to offer to the server
during the opening handshake.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_headers">headers</code></td>
<td>
<p>A named list or character vector representing keys and values
of headers in the initial HTTP request.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_autoconnect">autoConnect</code></td>
<td>
<p>If set to 'FALSE', then constructing the WebSocket object
will not automatically cause the connection to be established. This can be
used if control will return to R before event handlers can be set on the
WebSocket object (i.e. you are constructing a WebSocket object manually at
an interactive R console); after you are done attaching event handlers, you
must call 'ws$connect()' to establish the WebSocket connection.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_accesslogchannels">accessLogChannels</code></td>
<td>
<p>A character vector of access log channels that are
enabled.  Defaults to <code>"none"</code>, which displays no normal, websocketpp logging activity.
Setting <code>accessLogChannels = NULL</code> will use default websocketpp behavior.
Multiple access logging levels may be passed in for them to be enabled.
</p>
<p>A few commonly used access logging values are:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>Special aggregate value representing &quot;all levels&quot;</p>
</dd>
<dt><code>"none"</code></dt><dd><p>Special aggregate value representing &quot;no levels&quot;</p>
</dd>
<dt><code>"rerror"</code></dt><dd><p>Recoverable error. Recovery may mean cleanly closing the connection
with an appropriate error code to the remote endpoint.</p>
</dd>
<dt><code>"fatal"</code></dt><dd><p>Unrecoverable error. This error will trigger immediate unclean
termination of the connection or endpoint.</p>
</dd>
</dl>

<p>All logging levels are explained in more detail at <a href="https://docs.websocketpp.org/reference_8logging.html">https://docs.websocketpp.org/reference_8logging.html</a>.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_errorlogchannels">errorLogChannels</code></td>
<td>
<p>A character vector of error log channels that are
displayed.  The default value is <code>NULL</code>, which will use default websocketpp behavior.
Multiple error logging levels may be passed in for them to be enabled.
</p>
<p>A few commonly used error logging values are:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>Special aggregate value representing &quot;all levels&quot;</p>
</dd>
<dt><code>"none"</code></dt><dd><p>Special aggregate value representing &quot;no levels&quot;</p>
</dd>
<dt><code>"connect"</code></dt><dd><p>One line for each new connection that is opened</p>
</dd>
<dt><code>"disconnect"</code></dt><dd><p>One line for each new connection that is closed</p>
</dd>
</dl>

<p>All logging levels are explained in more detail at <a href="https://docs.websocketpp.org/reference_8logging.html">https://docs.websocketpp.org/reference_8logging.html</a>.</p>
</td></tr>
<tr><td><code id="WebSocket_+3A_maxmessagesize">maxMessageSize</code></td>
<td>
<p>The maximum size of a message in bytes. If a message
larger than this is sent, the connection will fail with the <code>message_too_big</code>
protocol error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A WebSocket object has four events you can listen for, by calling the
corresponding 'onXXX' method and passing it a callback function. All callback
functions must take a single 'event' argument. The 'event' argument is a
named list that always contains a 'target' element that is the WebSocket
object that originated the event, plus any other relevant data as detailed
below.
</p>

<dl>
<dt><code>onMessage</code></dt><dd><p>Called each time a message is received from the
server. The event will have a 'data' element, which is the message
content. If the message is text, the 'data' will be a one-element
character vector; if the message is binary, it will be a raw vector.</p>
</dd>
<dt><code>onOpen</code></dt><dd><p>Called when the connection is established.</p>
</dd>
<dt><code>onClose</code></dt><dd><p>Called when a previously-opened connection is closed.
The event will have 'code' (integer) and 'reason' (one-element character)
elements that describe the remote's reason for closing.</p>
</dd>
<dt><code>onError</code></dt><dd><p>Called when the connection fails to be established.
The event will have an 'message' element, a character vector of length 1
describing the reason for the error.</p>
</dd>
</dl>

<p>Each 'onXXX' method can be called multiple times to register multiple
callbacks. Each time an 'onXXX' is called, its (invisible) return value is a
function that can be invoked to cancel that particular registration.
</p>
<p>A WebSocket object also has the following methods:
</p>

<dl>
<dt><code>connect()</code></dt><dd><p>Initiates the connection to the server. (This does
not need to be called unless you have passed 'autoConnect=FALSE' to the
constructor.)</p>
</dd>
<dt><code>send(msg)</code></dt><dd><p>Sends a message to the server.</p>
</dd>
<dt><code>close()</code></dt><dd><p>Closes the connection.</p>
</dd>
<dt><code>readyState()</code></dt><dd><p>Returns an integer representing the state of the
connection.
</p>

<dl>
<dt><code>0L</code>: Connecting</dt><dd><p>The WebSocket has not yet established a
connection with the server.</p>
</dd>
<dt><code>1L</code>: Open</dt><dd><p>The WebSocket has connected and can send and
receive messages.</p>
</dd>
<dt><code>2L</code>: Closing</dt><dd><p>The WebSocket is in the process of closing.</p>
</dd>
<dt><code>3L</code>: Closed</dt><dd><p>The WebSocket has closed, or failed to open.</p>
</dd>
</dl>
</dd>
<dt>setAccessLogChannels(channels)</dt><dd><p>Enable the websocket Access channels after the
websocket's creation.  A value of <code>NULL</code> will not enable any new Access channels.</p>
</dd>
<dt>setErrorLogChannels(channels)</dt><dd><p>Enable the websocket Error channels after the
websocket's creation.  A value of <code>NULL</code> will not enable any new Error channels.</p>
</dd>
<dt>clearAccessLogChannels(channels)</dt><dd><p>Disable the websocket Access channels after the
websocket's creation.  A value of <code>NULL</code> will not clear any existing Access channels.</p>
</dd>
<dt>clearErrorLogChannels(channels)</dt><dd><p>Disable the websocket Error channels after the
websocket's creation.  A value of <code>NULL</code> will not clear any existing Error channels.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Only run this example in interactive R sessions
if (interactive()) {

# Create a websocket using the websocket.org test server
ws &lt;- WebSocket$new("ws://echo.websocket.org/")
ws$onMessage(function(event) {
  cat("Client got msg:", event$data, "\n")
})
ws$onClose(function(event) {
  cat("Client disconnected\n")
})
ws$onOpen(function(event) {
  cat("Client connected\n")
})

# Try sending a message with ws$send("hello").
# Close the websocket with ws$close() after you're done with it.
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
