<!DOCTYPE html><html><head><title>Help for package labelled</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {labelled}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#copy_labels'><p>Copy variable and value labels and SPSS-style missing value</p></a></li>
<li><a href='#drop_unused_value_labels'><p>Drop unused value labels</p></a></li>
<li><a href='#is_prefixed'><p>Check if a factor is prefixed</p></a></li>
<li><a href='#look_for'><p>Look for keywords variable names and descriptions / Create a data dictionary</p></a></li>
<li><a href='#na_values'><p>Get / Set SPSS missing values</p></a></li>
<li><a href='#names_prefixed_by_values'><p>Turn a named vector into a vector of names prefixed by values</p></a></li>
<li><a href='#nolabel_to_na'><p>Recode values with no label to NA</p></a></li>
<li><a href='#recode_if'><p>Recode some values based on condition</p></a></li>
<li><a href='#recode.haven_labelled'><p>Recode values</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_attributes'><p>Remove attributes</p></a></li>
<li><a href='#remove_labels'><p>Remove variable label, value labels and user defined missing values</p></a></li>
<li><a href='#sort_val_labels'><p>Sort value labels</p></a></li>
<li><a href='#tagged_na_to_user_na'><p>Convert tagged NAs into user NAs</p></a></li>
<li><a href='#to_character'><p>Convert input to a character vector</p></a></li>
<li><a href='#to_factor'><p>Convert input to a factor.</p></a></li>
<li><a href='#to_labelled'><p>Convert to labelled data</p></a></li>
<li><a href='#unique_tagged_na'><p>Unique elements, duplicated, ordering and sorting with tagged NAs</p></a></li>
<li><a href='#update_labelled'><p>Update labelled data to last version</p></a></li>
<li><a href='#val_labels'><p>Get / Set value labels</p></a></li>
<li><a href='#val_labels_to_na'><p>Recode value labels  to NA</p></a></li>
<li><a href='#var_label'><p>Get / Set a variable label</p></a></li>
<li><a href='#x_haven_2.0'><p>Datasets for testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Manipulating Labelled Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.12.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Larmarange &lt;joseph@larmarange.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Work with labelled data imported from 'SPSS'
    or 'Stata' with 'haven' or 'foreign'. This package
    provides useful functions to deal with "haven_labelled" and
    "haven_labelled_spss" classes introduced by 'haven' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>haven (&ge; 2.4.1), dplyr (&ge; 1.0.0), lifecycle, rlang, vctrs,
stringr, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, questionr, snakecase, utf8, covr,
spelling</td>
</tr>
<tr>
<td>Enhances:</td>
<td>memisc</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://larmarange.github.io/labelled/">https://larmarange.github.io/labelled/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/larmarange/labelled/issues">https://github.com/larmarange/labelled/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-21 13:32:27 UTC; josep</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Larmarange <a href="https://orcid.org/0000-0001-7097-700X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Daniel Ludecke [ctb],
  Hadley Wickham [ctb],
  Michal Bojanowski [ctb],
  François Briatte [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-21 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='copy_labels'>Copy variable and value labels and SPSS-style missing value</h2><span id='topic+copy_labels'></span><span id='topic+copy_labels_from'></span>

<h3>Description</h3>

<p>This function copies variable and value labels (including missing values)
from one vector to another or from one data frame to another data frame.
For data frame, labels are copied according to variable names, and only
if variables are the same type in both data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_labels(from, to, .strict = TRUE)

copy_labels_from(to, from, .strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_labels_+3A_from">from</code></td>
<td>
<p>A vector or a data.frame (or tibble) to copy labels from.</p>
</td></tr>
<tr><td><code id="copy_labels_+3A_to">to</code></td>
<td>
<p>A vector or data.frame (or tibble) to copy labels to.</p>
</td></tr>
<tr><td><code id="copy_labels_+3A_.strict">.strict</code></td>
<td>
<p>When <code>from</code> is a labelled vector, <code>to</code> have to be of the same
type (numeric or character) in order to copy value labels and SPSS-style
missing values. If this is not the case and <code>.strict = TRUE</code>, an error
will be produced. If <code>.strict = FALSE</code>, only variable label will be
copied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some base <span class="rlang"><b>R</b></span> functions like <code><a href="base.html#topic+subset">base::subset()</a></code> drop variable and
value labels attached to a variable. <code>copy_labels</code> could be used
to restore these attributes.
</p>
<p><code>copy_labels_from</code> is intended to be used with <span class="pkg">dplyr</span> syntax,
see examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- tibble(
  id = 1:3,
  happy = factor(c('yes', 'no', 'yes')),
  gender = labelled(c(1, 1, 2), c(female = 1, male = 2))
) %&gt;%
set_variable_labels(
  id = "Individual ID",
  happy = "Are you happy?",
  gender = "Gender of respondent"
)
var_label(df)
fdf &lt;- df %&gt;% filter(id &lt; 3)
var_label(fdf) # some variable labels have been lost
fdf &lt;- fdf %&gt;% copy_labels_from(df)
var_label(fdf)

# Alternative syntax
fdf &lt;- subset(df, id &lt; 3)
fdf &lt;- copy_labels(from = df, to = fdf)
</code></pre>

<hr>
<h2 id='drop_unused_value_labels'>Drop unused value labels</h2><span id='topic+drop_unused_value_labels'></span>

<h3>Description</h3>

<p>Drop value labels associated to a value not present in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_unused_value_labels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_unused_value_labels_+3A_x">x</code></td>
<td>
<p>A vector or a data frame.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- labelled(c(1, 2, 2, 1), c(yes = 1, no = 2, maybe = 3))
x
drop_unused_value_labels(x)
</code></pre>

<hr>
<h2 id='is_prefixed'>Check if a factor is prefixed</h2><span id='topic+is_prefixed'></span>

<h3>Description</h3>

<p>Check if a factor is prefixed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_prefixed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_prefixed_+3A_x">x</code></td>
<td>
<p>a factor</p>
</td></tr>
</table>

<hr>
<h2 id='look_for'>Look for keywords variable names and descriptions / Create a data dictionary</h2><span id='topic+look_for'></span><span id='topic+lookfor'></span><span id='topic+generate_dictionary'></span><span id='topic+print.look_for'></span><span id='topic+look_for_and_select'></span><span id='topic+convert_list_columns_to_character'></span><span id='topic+lookfor_to_long_format'></span>

<h3>Description</h3>

<p><code>look_for</code> emulates the <code>lookfor</code> Stata command in <span class="rlang"><b>R</b></span>. It supports
searching into the variable names of regular <span class="rlang"><b>R</b></span> data frames as well as into
variable labels descriptions, factor levels and value labels.
The command is meant to help users finding variables in large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>look_for(
  data,
  ...,
  labels = TRUE,
  values = TRUE,
  ignore.case = TRUE,
  details = c("basic", "none", "full")
)

lookfor(
  data,
  ...,
  labels = TRUE,
  values = TRUE,
  ignore.case = TRUE,
  details = c("basic", "none", "full")
)

generate_dictionary(
  data,
  ...,
  labels = TRUE,
  values = TRUE,
  ignore.case = TRUE,
  details = c("basic", "none", "full")
)

## S3 method for class 'look_for'
print(x, ...)

look_for_and_select(
  data,
  ...,
  labels = TRUE,
  values = TRUE,
  ignore.case = TRUE
)

convert_list_columns_to_character(x)

lookfor_to_long_format(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="look_for_+3A_data">data</code></td>
<td>
<p>a data frame or a survey object</p>
</td></tr>
<tr><td><code id="look_for_+3A_...">...</code></td>
<td>
<p>optional list of keywords, a character string (or several
character strings), which can be formatted as a regular expression suitable
for a <code><a href="base.html#topic+grep">base::grep()</a></code> pattern, or a vector of keywords;
displays all variables if not specified</p>
</td></tr>
<tr><td><code id="look_for_+3A_labels">labels</code></td>
<td>
<p>whether or not to search variable labels (descriptions);
<code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="look_for_+3A_values">values</code></td>
<td>
<p>whether or not to search within values (factor levels or value
labels); <code>TRUE</code> by default</p>
</td></tr>
<tr><td><code id="look_for_+3A_ignore.case">ignore.case</code></td>
<td>
<p>whether or not to make the keywords case sensitive;
<code>TRUE</code> by default (case is ignored during matching)</p>
</td></tr>
<tr><td><code id="look_for_+3A_details">details</code></td>
<td>
<p>add details about each variable (full details could be time
consuming for big data frames, <code>FALSE</code> is equivalent to <code>"none"</code>
and <code>TRUE</code> to <code>"full"</code>)</p>
</td></tr>
<tr><td><code id="look_for_+3A_x">x</code></td>
<td>
<p>a tibble returned by <code>look_for()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no keyword is provided, it will produce a data dictionary of the overall
data frame.
</p>
<p>The function looks into the variable names for matches to the
keywords. If available, variable labels are included in the search scope.
Variable labels of data.frame imported with <span class="pkg">foreign</span> or
<span class="pkg">memisc</span> packages will also be taken into account (see <code><a href="#topic+to_labelled">to_labelled()</a></code>).
If no keyword is provided, it will return all variables of <code>data</code>.
</p>
<p><code>look_for()</code>, <code>lookfor()</code> and <code>generate_dictionary()</code> are equivalent.
</p>
<p>By default, results will be summarized when printing. To deactivate default
printing, use <code>dplyr::as_tibble()</code>.
</p>
<p><code>lookfor_to_long_format()</code> could be used to transform results with one row
per factor level and per value label.
</p>
<p>Use <code>convert_list_columns_to_character()</code> to convert named list columns into
character vectors (see examples).
</p>
<p><code>look_for_and_select()</code> is a shortcut for selecting some variables and
applying <code>dplyr::select()</code> to return a data frame with only the selected
variables.
</p>


<h3>Value</h3>

<p>a tibble data frame featuring the variable position, name and
description (if it exists) in the original data frame
</p>


<h3>Author(s)</h3>

<p>François Briatte <a href="mailto:f.briatte@gmail.com">f.briatte@gmail.com</a>,
Joseph Larmarange <a href="mailto:joseph@larmarange.net">joseph@larmarange.net</a>
</p>


<h3>Source</h3>

<p>Inspired by the <code>lookfor</code> command in Stata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>look_for(iris)

# Look for a single keyword.
look_for(iris, "petal")
look_for(iris, "s")
iris %&gt;% look_for_and_select("s") %&gt;% head()

# Look for with a regular expression
look_for(iris, "petal|species")
look_for(iris, "s$")

# Look for with several keywords
look_for(iris, "pet", "sp")
look_for(iris, "pet", "sp", "width")
look_for(iris, "Pet", "sp", "width", ignore.case = FALSE)

# Look_for can search within factor levels or value labels
look_for(iris, "vers")

# Quicker search without variable details
look_for(iris, details = "none")

# To obtain more details about each variable
look_for(iris, details = "full")

# To deactivate default printing, convert to tibble
look_for(iris, details = "full") %&gt;%
  dplyr::as_tibble()

# To convert named lists into character vectors
look_for(iris) %&gt;% convert_list_columns_to_character()

# Long format with one row per factor and per value label
look_for(iris) %&gt;% lookfor_to_long_format()

# Both functions can be combined
look_for(iris) %&gt;%
  lookfor_to_long_format() %&gt;%
  convert_list_columns_to_character()

# Labelled data
d &lt;- dplyr::tibble(
  region = labelled_spss(
    c(1, 2, 1, 9, 2, 3),
    c(north = 1, south = 2, center = 3, missing = 9),
    na_values = 9,
    label = "Region of the respondent"
  ),
  sex = labelled(
    c("f", "f", "m", "m", "m", "f"),
    c(female = "f", male = "m"),
    label = "Sex of the respondent"
  )
)
look_for(d)
d %&gt;%
  look_for() %&gt;%
  lookfor_to_long_format() %&gt;%
  convert_list_columns_to_character()
</code></pre>

<hr>
<h2 id='na_values'>Get / Set SPSS missing values</h2><span id='topic+na_values'></span><span id='topic+na_values+3C-'></span><span id='topic+na_range'></span><span id='topic+na_range+3C-'></span><span id='topic+get_na_values'></span><span id='topic+get_na_range'></span><span id='topic+set_na_values'></span><span id='topic+set_na_range'></span><span id='topic+is_user_na'></span><span id='topic+is_regular_na'></span><span id='topic+user_na_to_na'></span><span id='topic+user_na_to_regular_na'></span><span id='topic+user_na_to_tagged_na'></span>

<h3>Description</h3>

<p>Get / Set SPSS missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_values(x)

na_values(x) &lt;- value

na_range(x)

na_range(x) &lt;- value

get_na_values(x)

get_na_range(x)

set_na_values(.data, ..., .values = NA, .strict = TRUE)

set_na_range(.data, ..., .values = NA, .strict = TRUE)

is_user_na(x)

is_regular_na(x)

user_na_to_na(x)

user_na_to_regular_na(x)

user_na_to_tagged_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_values_+3A_x">x</code></td>
<td>
<p>A vector (or a data frame).</p>
</td></tr>
<tr><td><code id="na_values_+3A_value">value</code></td>
<td>
<p>A vector of values that should also be considered as missing
(for <code>na_values</code>) or a numeric vector of length two giving the (inclusive)
extents of the range (for <code>na_values</code>, use <code>-Inf</code> and <code>Inf</code> if you
want the range to be open ended).</p>
</td></tr>
<tr><td><code id="na_values_+3A_.data">.data</code></td>
<td>
<p>a data frame or a vector</p>
</td></tr>
<tr><td><code id="na_values_+3A_...">...</code></td>
<td>
<p>name-value pairs of missing values (see examples)</p>
</td></tr>
<tr><td><code id="na_values_+3A_.values">.values</code></td>
<td>
<p>missing values to be applied to the data.frame,
using the same syntax as <code>value</code> in <code>na_values(df) &lt;- value</code> or
<code>na_range(df) &lt;- value</code>.</p>
</td></tr>
<tr><td><code id="na_values_+3A_.strict">.strict</code></td>
<td>
<p>should an error be returned if some labels
doesn't correspond to a column of <code>x</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="haven.html#topic+labelled_spss">haven::labelled_spss()</a></code> for a presentation of SPSS's user defined
missing values.
</p>
<p>Note that <code><a href="base.html#topic+NA">base::is.na()</a></code> will return <code>TRUE</code> for user defined missing values.
It will also return <code>TRUE</code> for regular <code>NA</code> values. If you want to test if a
specific value is a user NA but not a regular <code>NA</code>, use <code>is_user_na()</code>.
If you want to test if a value is a regular <code>NA</code> but not a user NA, not a
tagged NA, use <code>is_regular_na()</code>.
</p>
<p>You can use <code><a href="#topic+user_na_to_na">user_na_to_na()</a></code> to convert user defined missing values to
regular <code>NA</code>. Note that any value label attached to a user defined missing
value will be lost.
<code><a href="#topic+user_na_to_regular_na">user_na_to_regular_na()</a></code> is a synonym of <code><a href="#topic+user_na_to_na">user_na_to_na()</a></code>.
</p>
<p>The method <code><a href="#topic+user_na_to_tagged_na">user_na_to_tagged_na()</a></code> will convert user defined missing values
into <code><a href="haven.html#topic+tagged_na">haven::tagged_na()</a></code>, preserving value labels. Please note that
<code><a href="haven.html#topic+tagged_na">haven::tagged_na()</a></code> are defined only for double vectors. Therefore, integer
<code>haven_labelled_spss</code> vectors will be converted into double <code>haven_labelled</code>
vectors; and <code><a href="#topic+user_na_to_tagged_na">user_na_to_tagged_na()</a></code> cannot be applied to a character
<code>haven_labelled_spss</code> vector.
</p>
<p><code><a href="#topic+tagged_na_to_user_na">tagged_na_to_user_na()</a></code> is the opposite of <code><a href="#topic+user_na_to_tagged_na">user_na_to_tagged_na()</a></code> and
convert tagged <code>NA</code> into user defined missing values.
</p>


<h3>Value</h3>

<p><code>na_values()</code> will return a vector of values that should also be
considered as missing.
<code>na_range()</code> will return a numeric vector of length two giving the
(inclusive) extents of the range.
</p>
<p><code>set_na_values()</code> and <code>set_na_range()</code> will return an updated
copy of <code>.data</code>.
</p>


<h3>Note</h3>

<p><code>get_na_values()</code> is identical to <code>na_values()</code> and <code>get_na_range()</code>
to <code>na_range()</code>.
</p>
<p><code>set_na_values()</code> and <code>set_na_range()</code> could be used with <span class="pkg">dplyr</span>
syntax.
</p>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+labelled_spss">haven::labelled_spss()</a></code>, <code><a href="#topic+user_na_to_na">user_na_to_na()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, "don't know" = 9))
v
na_values(v) &lt;- 9
na_values(v)
v

is.na(v) # TRUE for the 6th and 10th values
is_user_na(v) # TRUE only for the 6th value

user_na_to_na(v)
na_values(v) &lt;- NULL
v
na_range(v) &lt;- c(5, Inf)
na_range(v)
v
user_na_to_na(v)
user_na_to_tagged_na(v)

# it is not recommended to mix user NAs and tagged NAs
x &lt;- c(NA, 9, tagged_na("a"))
na_values(x) &lt;- 9
x
is.na(x)
is_user_na(x)
is_tagged_na(x)
is_regular_na(x)

if (require(dplyr)) {
  # setting value label and user NAs
  df &lt;- tibble(s1 = c("M", "M", "F", "F"), s2 = c(1, 1, 2, 9)) %&gt;%
    set_value_labels(s2 = c(yes = 1, no = 2)) %&gt;%
    set_na_values(s2 = 9)
  na_values(df)

  # removing missing values
  df &lt;- df %&gt;% set_na_values(s2 = NULL)
  df$s2

  # example with a vector
  v &lt;- 1:10
  v &lt;- v %&gt;% set_na_values(5, 6, 7)
  v
  v %&gt;% set_na_range(8, 10)
  v %&gt;% set_na_range(.values = c(9, 10))
  v %&gt;% set_na_values(NULL)
}
</code></pre>

<hr>
<h2 id='names_prefixed_by_values'>Turn a named vector into a vector of names prefixed by values</h2><span id='topic+names_prefixed_by_values'></span>

<h3>Description</h3>

<p>Turn a named vector into a vector of names prefixed by values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>names_prefixed_by_values(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_prefixed_by_values_+3A_x">x</code></td>
<td>
<p>vector to be prefixed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- dplyr::tibble(
  c1 = labelled(c("M", "M", "F"), c(Male = "M", Female = "F")),
  c2 = labelled(c(1, 1, 2), c(Yes = 1, No = 2))
)
val_labels(df$c1)
val_labels(df$c1) %&gt;% names_prefixed_by_values()
val_labels(df)
val_labels(df) %&gt;% names_prefixed_by_values()
</code></pre>

<hr>
<h2 id='nolabel_to_na'>Recode values with no label to NA</h2><span id='topic+nolabel_to_na'></span>

<h3>Description</h3>

<p>For labelled variables, values with no label will be recoded to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nolabel_to_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nolabel_to_na_+3A_x">x</code></td>
<td>
<p>Object to recode.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1, 2, 9, 1, 9), c(yes = 1, no = 2))
nolabel_to_na(v)
</code></pre>

<hr>
<h2 id='recode_if'>Recode some values based on condition</h2><span id='topic+recode_if'></span>

<h3>Description</h3>

<p>Recode some values based on condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_if(x, condition, true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_if_+3A_x">x</code></td>
<td>
<p>vector to be recoded</p>
</td></tr>
<tr><td><code id="recode_if_+3A_condition">condition</code></td>
<td>
<p>logical vector of same length as <code>x</code></p>
</td></tr>
<tr><td><code id="recode_if_+3A_true">true</code></td>
<td>
<p>values to use for <code>TRUE</code> values of <code>condition</code>. It must be
either the same length as <code>x</code>, or length 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> with values replaced by <code>true</code> when <code>condition</code> is
<code>TRUE</code> and unchanged when <code>condition</code> is <code>FALSE</code> or <code>NA</code>. Variable and value
labels are preserved unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1,2,2,9), c(yes = 1, no = 2))
v %&gt;% recode_if(v == 9, NA)
if (require(dplyr)) {
  df &lt;- tibble(s1 = c("M", "M", "F"), s2 = c(1, 2, 1)) %&gt;%
    set_value_labels(
      s1 = c(Male = "M", Female = "F"),
      s2 = c(A = 1, B = 2)
    ) %&gt;%
    set_variable_labels(s1 = "Gender", s2 = "Group")

  df &lt;- df %&gt;%
    mutate(
      s3 = s2 %&gt;% recode_if(s1 == "F", 2),
      s4 = s2 %&gt;% recode_if(s1 == "M", s2 + 10)
    )
  df
  df %&gt;% look_for()
}
</code></pre>

<hr>
<h2 id='recode.haven_labelled'>Recode values</h2><span id='topic+recode.haven_labelled'></span>

<h3>Description</h3>

<p>Extend <code><a href="dplyr.html#topic+recode">dplyr::recode()</a></code> method from <span class="pkg">dplyr</span> to
works with labelled vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haven_labelled'
recode(
  .x,
  ...,
  .default = NULL,
  .missing = NULL,
  .keep_value_labels = TRUE,
  .combine_value_labels = FALSE,
  .sep = " / "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode.haven_labelled_+3A_.x">.x</code></td>
<td>
<p>A vector to modify</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt; Replacements. For character and factor <code>.x</code>, these should be named
and replacement is based only on their name. For numeric <code>.x</code>, these can be
named or not. If not named, the replacement is done based on position i.e.
<code>.x</code> represents positions to look for in replacements. See examples.
</p>
<p>When named, the argument names should be the current values to be replaced, and the
argument values should be the new (replacement) values.
</p>
<p>All replacements must be the same type, and must have either
length one or the same length as <code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_.default">.default</code></td>
<td>
<p>If supplied, all values not otherwise matched will
be given this value. If not supplied and if the replacements are
the same type as the original values in <code>.x</code>, unmatched
values are not changed. If not supplied and if the replacements
are not compatible, unmatched values are replaced with <code>NA</code>.
</p>
<p><code>.default</code> must be either length 1 or the same length as
<code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_.missing">.missing</code></td>
<td>
<p>If supplied, any missing values in <code>.x</code> will be
replaced by this value. Must be either length 1 or the same length as
<code>.x</code>.</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_.keep_value_labels">.keep_value_labels</code></td>
<td>
<p>If TRUE, keep original value labels.
If FALSE, remove value labels.</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_.combine_value_labels">.combine_value_labels</code></td>
<td>
<p>If TRUE, will combine original value labels
to generate new value labels. Note that unexpected results could be
obtained if a same old value is recoded into several different new values.</p>
</td></tr>
<tr><td><code id="recode.haven_labelled_+3A_.sep">.sep</code></td>
<td>
<p>Separator to be used when combining value labels.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+recode">dplyr::recode()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- labelled(1:3, c(yes = 1, no = 2))
x
dplyr::recode(x, `3` = 2L)

# do not keep value labels
dplyr::recode(x, `3` = 2L, .keep_value_labels = FALSE)

# be careful, changes are not of the same type (here integers),
# NA arecreated
dplyr::recode(x, `3` = 2)

# except if you provide .default or new values for all old values
dplyr::recode(x, `1` = 1, `2` = 1,`3` = 2)

# if you change the type of the vector (here transformed into character)
# value labels are lost
dplyr::recode(x, `3` = "b", .default = "a")

# use .keep_value_labels = FALSE to avoid a warning
dplyr::recode(x, `3` = "b", .default = "a", .keep_value_labels = FALSE)

# combine value labels
x &lt;- labelled(
  1:4,
  c(
    "strongly agree" = 1,
    "agree" = 2,
    "disagree" = 3,
    "strongly disagree" = 4)
  )
dplyr::recode(
  x,
  `1` = 1L,
  `2` = 1L,
  `3` = 2L,
  `4` = 2L,
  .combine_value_labels = TRUE
)
dplyr::recode(
  x,
  `2` = 1L,
  `4` = 3L,
  .combine_value_labels = TRUE
)
dplyr::recode(
  x,
  `2` = 1L,
  `4` = 3L,
  .combine_value_labels = TRUE,
  .sep = " or "
)
dplyr::recode(
  x,
  `2` = 1L,
  .default = 2L,
 .combine_value_labels = TRUE
)

# example when combining some values without a label
y &lt;- labelled(1:4, c("strongly agree" = 1))
dplyr::recode(y, `2` = 1L, `4` = 3L, .combine_value_labels = TRUE)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+labelled'></span><span id='topic+is.labelled'></span><span id='topic+labelled_spss'></span><span id='topic+print_labels'></span><span id='topic++25+3E+25'></span><span id='topic+tagged_na'></span><span id='topic+na_tag'></span><span id='topic+is_tagged_na'></span><span id='topic+format_tagged_na'></span><span id='topic+print_tagged_na'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>haven</dt><dd><p><code><a href="haven.html#topic+tagged_na">format_tagged_na</a></code>, <code><a href="haven.html#topic+labelled">is.labelled</a></code>, <code><a href="haven.html#topic+tagged_na">is_tagged_na</a></code>, <code><a href="haven.html#topic+labelled">labelled</a></code>, <code><a href="haven.html#topic+labelled_spss">labelled_spss</a></code>, <code><a href="haven.html#topic+tagged_na">na_tag</a></code>, <code><a href="haven.html#topic+print_labels">print_labels</a></code>, <code><a href="haven.html#topic+tagged_na">print_tagged_na</a></code>, <code><a href="haven.html#topic+tagged_na">tagged_na</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_attributes'>Remove attributes</h2><span id='topic+remove_attributes'></span>

<h3>Description</h3>

<p>This function removes specified attributes. When applied to a data.frame, it
will also remove recursively the specified attributes to each column of the
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_attributes(x, attributes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_attributes_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="remove_attributes_+3A_attributes">attributes</code></td>
<td>
<p>a character vector indicating attributes to remove</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(haven)
path &lt;- system.file("examples", "iris.sav", package = "haven")
d &lt;- read_sav(path)
str(d)
d &lt;- remove_attributes(d, "format.spss")
str(d)
## End(Not run)
</code></pre>

<hr>
<h2 id='remove_labels'>Remove variable label, value labels and user defined missing values</h2><span id='topic+remove_labels'></span><span id='topic+remove_var_label'></span><span id='topic+remove_val_labels'></span><span id='topic+remove_user_na'></span>

<h3>Description</h3>

<p>Use <code>remove_var_label()</code> to remove variable label, <code>remove_val_labels()</code>
to remove value labels, <code>remove_user_na()</code> to remove user defined missing
values (<em>na_values</em> and <em>na_range</em>) and <code>remove_labels()</code> to remove all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_labels(
  x,
  user_na_to_na = FALSE,
  keep_var_label = FALSE,
  user_na_to_tagged_na = FALSE
)

remove_var_label(x)

remove_val_labels(x)

remove_user_na(x, user_na_to_na = FALSE, user_na_to_tagged_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_labels_+3A_x">x</code></td>
<td>
<p>A vector or a data frame.</p>
</td></tr>
<tr><td><code id="remove_labels_+3A_user_na_to_na">user_na_to_na</code></td>
<td>
<p>Convert user defined missing values into <code>NA</code>?</p>
</td></tr>
<tr><td><code id="remove_labels_+3A_keep_var_label">keep_var_label</code></td>
<td>
<p>Keep variable label?</p>
</td></tr>
<tr><td><code id="remove_labels_+3A_user_na_to_tagged_na">user_na_to_tagged_na</code></td>
<td>
<p>Convert user defined missing values into
tagged <code>NA</code>? It could be applied only to numeric vectors. Note that integer
labelled vectors will be converted to double labelled vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful with <code>remove_user_na()</code> and <code>remove_labels()</code>, user defined
missing values will not be automatically converted to <code>NA</code>, except if you
specify <code>user_na_to_na = TRUE</code>.
<code>user_na_to_na(x)</code> is an equivalent of
<code>remove_user_na(x, user_na_to_na = TRUE)</code>.
</p>
<p>If you prefer to convert variables with value labels into factors, use
<code><a href="#topic+to_factor">to_factor()</a></code> or use <code><a href="#topic+unlabelled">unlabelled()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- labelled_spss(1:10, c(Good = 1, Bad = 8), na_values = c(9, 10))
var_label(x) &lt;- "A variable"
x

remove_labels(x)
remove_labels(x, user_na_to_na = TRUE)
remove_user_na(x, user_na_to_na = TRUE)
remove_user_na(x, user_na_to_tagged_na = TRUE)
</code></pre>

<hr>
<h2 id='sort_val_labels'>Sort value labels</h2><span id='topic+sort_val_labels'></span>

<h3>Description</h3>

<p>Sort value labels according to values or to labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_val_labels(x, according_to = c("values", "labels"), decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_val_labels_+3A_x">x</code></td>
<td>
<p>A labelled vector or a data.frame</p>
</td></tr>
<tr><td><code id="sort_val_labels_+3A_according_to">according_to</code></td>
<td>
<p>According to values or to labels?</p>
</td></tr>
<tr><td><code id="sort_val_labels_+3A_decreasing">decreasing</code></td>
<td>
<p>In decreasing order?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1, 2, 3), c(maybe = 2, yes = 1, no = 3))
v
sort_val_labels(v)
sort_val_labels(v, decreasing = TRUE)
sort_val_labels(v, 'l')
sort_val_labels(v, 'l', TRUE)
</code></pre>

<hr>
<h2 id='tagged_na_to_user_na'>Convert tagged NAs into user NAs</h2><span id='topic+tagged_na_to_user_na'></span><span id='topic+tagged_na_to_regular_na'></span>

<h3>Description</h3>

<p><code><a href="#topic+tagged_na_to_user_na">tagged_na_to_user_na()</a></code> is the opposite of <code><a href="#topic+user_na_to_tagged_na">user_na_to_tagged_na()</a></code> and
convert tagged <code>NA</code> into user defined missing values (see <code><a href="#topic+labelled_spss">labelled_spss()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tagged_na_to_user_na(x, user_na_start = NULL)

tagged_na_to_regular_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tagged_na_to_user_na_+3A_x">x</code></td>
<td>
<p>a vector or a data frame</p>
</td></tr>
<tr><td><code id="tagged_na_to_user_na_+3A_user_na_start">user_na_start</code></td>
<td>
<p>minimum value of the new user na, if <code>NULL</code>,
computed automatically (maximum of observed values + 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+tagged_na_to_regular_na">tagged_na_to_regular_na()</a></code> converts tagged NAs into regular NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:5, tagged_na("a"), tagged_na("z"), NA)
x
print_tagged_na(x)
tagged_na_to_user_na(x)
tagged_na_to_user_na(x, user_na_start = 10)

y &lt;- c(1, 0, 1, tagged_na("r"), 0, tagged_na("d"))
val_labels(y) &lt;- c(
  no = 0, yes = 1,
  "don't know" = tagged_na("d"),
  refusal = tagged_na("r")
)
y
tagged_na_to_user_na(y, user_na_start = 8)
tagged_na_to_regular_na(y)
tagged_na_to_regular_na(y) %&gt;% is_tagged_na()
</code></pre>

<hr>
<h2 id='to_character'>Convert input to a character vector</h2><span id='topic+to_character'></span><span id='topic+to_character.double'></span><span id='topic+to_character.haven_labelled'></span><span id='topic+to_character.data.frame'></span>

<h3>Description</h3>

<p>By default, <code>to_character()</code> is a wrapper for <code><a href="base.html#topic+character">base::as.character()</a></code>.
For labelled vector, to_character allows to specify if value, labels or
labels prefixed with values should be used for conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_character(x, ...)

## S3 method for class 'double'
to_character(x, explicit_tagged_na = FALSE, ...)

## S3 method for class 'haven_labelled'
to_character(
  x,
  levels = c("labels", "values", "prefixed"),
  nolabel_to_na = FALSE,
  user_na_to_na = FALSE,
  explicit_tagged_na = FALSE,
  ...
)

## S3 method for class 'data.frame'
to_character(
  x,
  levels = c("labels", "values", "prefixed"),
  nolabel_to_na = FALSE,
  user_na_to_na = FALSE,
  explicit_tagged_na = FALSE,
  labelled_only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_character_+3A_x">x</code></td>
<td>
<p>Object to coerce to a character vector.</p>
</td></tr>
<tr><td><code id="to_character_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
<tr><td><code id="to_character_+3A_explicit_tagged_na">explicit_tagged_na</code></td>
<td>
<p>should tagged NA be kept?</p>
</td></tr>
<tr><td><code id="to_character_+3A_levels">levels</code></td>
<td>
<p>What should be used for the factor levels: the labels, the
values or labels prefixed with values?</p>
</td></tr>
<tr><td><code id="to_character_+3A_nolabel_to_na">nolabel_to_na</code></td>
<td>
<p>Should values with no label be converted to <code>NA</code>?</p>
</td></tr>
<tr><td><code id="to_character_+3A_user_na_to_na">user_na_to_na</code></td>
<td>
<p>user defined missing values into NA?</p>
</td></tr>
<tr><td><code id="to_character_+3A_labelled_only">labelled_only</code></td>
<td>
<p>for a data.frame, convert only labelled variables to
factors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some values doesn't have a label, automatic labels will be created,
except if <code>nolabel_to_na</code> is <code>TRUE</code>.
</p>
<p>When applied to a data.frame, only labelled vectors are converted by
default to character. Use <code>labelled_only = FALSE</code> to convert all variables
to characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, "don't know" = 9))
to_character(v)
to_character(v, nolabel_to_na = TRUE)
to_character(v, "v")
to_character(v, "p")

df &lt;- data.frame(
  a = labelled(c(1, 1, 2, 3), labels = c(No = 1, Yes = 2)),
  b = labelled(c(1, 1, 2, 3), labels = c(No = 1, Yes = 2, DK = 3)),
  c = labelled(
    c("a", "a", "b", "c"),
    labels = c(No = "a", Maybe = "b", Yes = "c")
  ),
  d = 1:4,
  e = factor(c("item1", "item2", "item1", "item2")),
  f = c("itemA", "itemA", "itemB", "itemB"),
  stringsAsFactors = FALSE
)

if (require(dplyr)) {
  glimpse(df)
  glimpse(to_character(df))
  glimpse(to_character(df, labelled_only = FALSE))
}
</code></pre>

<hr>
<h2 id='to_factor'>Convert input to a factor.</h2><span id='topic+to_factor'></span><span id='topic+to_factor.haven_labelled'></span><span id='topic+to_factor.data.frame'></span><span id='topic+unlabelled'></span>

<h3>Description</h3>

<p>The base function <code><a href="base.html#topic+factor">base::as.factor()</a></code> is not a generic, but this variant
is. By default, <code>to_factor()</code> is a wrapper for <code><a href="base.html#topic+factor">base::as.factor()</a></code>.
Please note that <code>to_factor()</code> differs slightly from <code><a href="haven.html#topic+as_factor">haven::as_factor()</a></code>
method provided by <span class="pkg">haven</span> package.
</p>
<p><code>unlabelled(x)</code> is a shortcut for
<code>to_factor(x, strict = TRUE, unclass = TRUE, labelled_only = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_factor(x, ...)

## S3 method for class 'haven_labelled'
to_factor(
  x,
  levels = c("labels", "values", "prefixed"),
  ordered = FALSE,
  nolabel_to_na = FALSE,
  sort_levels = c("auto", "none", "labels", "values"),
  decreasing = FALSE,
  drop_unused_labels = FALSE,
  user_na_to_na = FALSE,
  strict = FALSE,
  unclass = FALSE,
  explicit_tagged_na = FALSE,
  ...
)

## S3 method for class 'data.frame'
to_factor(
  x,
  levels = c("labels", "values", "prefixed"),
  ordered = FALSE,
  nolabel_to_na = FALSE,
  sort_levels = c("auto", "none", "labels", "values"),
  decreasing = FALSE,
  labelled_only = TRUE,
  drop_unused_labels = FALSE,
  strict = FALSE,
  unclass = FALSE,
  explicit_tagged_na = FALSE,
  ...
)

unlabelled(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_factor_+3A_x">x</code></td>
<td>
<p>Object to coerce to a factor.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_levels">levels</code></td>
<td>
<p>What should be used for the factor levels: the labels, the
values or labels prefixed with values?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_ordered">ordered</code></td>
<td>
<p><code>TRUE</code> for ordinal factors, <code>FALSE</code> (default) for nominal
factors.</p>
</td></tr>
<tr><td><code id="to_factor_+3A_nolabel_to_na">nolabel_to_na</code></td>
<td>
<p>Should values with no label be converted to <code>NA</code>?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_sort_levels">sort_levels</code></td>
<td>
<p>How the factor levels should be sorted? (see Details)</p>
</td></tr>
<tr><td><code id="to_factor_+3A_decreasing">decreasing</code></td>
<td>
<p>Should levels be sorted in decreasing order?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_drop_unused_labels">drop_unused_labels</code></td>
<td>
<p>Should unused value labels be dropped?
(applied only if <code>strict = FALSE</code>)</p>
</td></tr>
<tr><td><code id="to_factor_+3A_user_na_to_na">user_na_to_na</code></td>
<td>
<p>Convert user defined missing values into <code>NA</code>?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_strict">strict</code></td>
<td>
<p>Convert to factor only if all values have a defined label?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_unclass">unclass</code></td>
<td>
<p>If not converted to a factor (when <code>strict = TRUE</code>),
convert to a character or a numeric factor by applying <code><a href="base.html#topic+class">base::unclass()</a></code>?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_explicit_tagged_na">explicit_tagged_na</code></td>
<td>
<p>Should tagged NA (cf. <code><a href="haven.html#topic+tagged_na">haven::tagged_na()</a></code>) be
kept as explicit factor levels?</p>
</td></tr>
<tr><td><code id="to_factor_+3A_labelled_only">labelled_only</code></td>
<td>
<p>for a data.frame, convert only labelled variables to
factors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some values doesn't have a label, automatic labels will be created,
except if <code>nolabel_to_na</code> is <code>TRUE</code>.
</p>
<p>If <code>sort_levels == 'values'</code>, the levels will be sorted according to the
values of <code>x</code>.
If <code>sort_levels == 'labels'</code>, the levels will be sorted according to
labels' names.
If <code>sort_levels == 'none'</code>, the levels will be in the order the value
labels are defined in <code>x</code>. If some labels are automatically created, they
will be added at the end.
If <code>sort_levels == 'auto'</code>, <code>sort_levels == 'none'</code> will be used, except
if some values doesn't have a defined label. In such case,
<code>sort_levels == 'values'</code> will be applied.
</p>
<p>When applied to a data.frame, only labelled vectors are converted by
default to a factor. Use <code>labelled_only = FALSE</code> to convert all variables
to factors.
</p>
<p><code>unlabelled()</code> is a shortcut for quickly removing value labels of a vector
or of a data.frame. If all observed values have a value label, then the
vector will be converted into a factor. Otherwise, the vector will be
unclassed.
If you want to remove value labels in all cases, use <code><a href="#topic+remove_val_labels">remove_val_labels()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, "don't know" = 9))
to_factor(v)
to_factor(v, nolabel_to_na = TRUE)
to_factor(v, 'p')
to_factor(v, sort_levels = 'v')
to_factor(v, sort_levels = 'n')
to_factor(v, sort_levels = 'l')

x &lt;- labelled(c('H', 'M', 'H', 'L'), c(low = 'L', medium = 'M', high = 'H'))
to_factor(x, ordered = TRUE)

# Strict conversion
v &lt;- labelled(c(1, 1, 2, 3), labels = c(No = 1, Yes = 2))
to_factor(v)
to_factor(v, strict = TRUE) # Not converted because 3 does not have a label
to_factor(v, strict = TRUE, unclass = TRUE)

df &lt;- data.frame(
  a = labelled(c(1, 1, 2, 3), labels = c(No = 1, Yes = 2)),
  b = labelled(c(1, 1, 2, 3), labels = c(No = 1, Yes = 2, DK = 3)),
  c = labelled(
    c("a", "a", "b", "c"),
    labels = c(No = "a", Maybe = "b", Yes = "c")
  ),
  d = 1:4,
  e = factor(c("item1", "item2", "item1", "item2")),
  f = c("itemA", "itemA", "itemB", "itemB"),
  stringsAsFactors = FALSE
)
if (require(dplyr)) {
  glimpse(df)
  glimpse(unlabelled(df))
}
</code></pre>

<hr>
<h2 id='to_labelled'>Convert to labelled data</h2><span id='topic+to_labelled'></span><span id='topic+to_labelled.data.frame'></span><span id='topic+to_labelled.list'></span><span id='topic+to_labelled.data.set'></span><span id='topic+to_labelled.importer'></span><span id='topic+foreign_to_labelled'></span><span id='topic+memisc_to_labelled'></span><span id='topic+to_labelled.factor'></span>

<h3>Description</h3>

<p>Convert a factor or data imported with <span class="pkg">foreign</span> or <span class="pkg">memisc</span> to
labelled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_labelled(x, ...)

## S3 method for class 'data.frame'
to_labelled(x, ...)

## S3 method for class 'list'
to_labelled(x, ...)

## S3 method for class 'data.set'
to_labelled(x, ...)

## S3 method for class 'importer'
to_labelled(x, ...)

foreign_to_labelled(x)

memisc_to_labelled(x)

## S3 method for class 'factor'
to_labelled(x, labels = NULL, .quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_labelled_+3A_x">x</code></td>
<td>
<p>Factor or dataset to convert to labelled data frame</p>
</td></tr>
<tr><td><code id="to_labelled_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="to_labelled_+3A_labels">labels</code></td>
<td>
<p>When converting a factor only:
an optional named vector indicating how factor levels should be coded.
If a factor level is not found in <code>labels</code>, it will be converted to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="to_labelled_+3A_.quiet">.quiet</code></td>
<td>
<p>do not display warnings for prefixed factors with duplicated
codes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>to_labelled()</code> is a general wrapper calling the appropriate sub-functions.
</p>
<p><code>memisc_to_labelled()</code> converts a <code>memisc::data.set()</code>]' object created with
<span class="pkg">memisc</span> package to a labelled data frame.
</p>
<p><code>foreign_to_labelled()</code> converts data imported with <code><a href="foreign.html#topic+read.spss">foreign::read.spss()</a></code>
or <code><a href="foreign.html#topic+read.dta">foreign::read.dta()</a></code> from <span class="pkg">foreign</span> package to a labelled data frame,
i.e. using <code><a href="haven.html#topic+labelled">haven::labelled()</a></code>.
Factors will not be converted. Therefore, you should use
<code>use.value.labels = FALSE</code> when importing with <code><a href="foreign.html#topic+read.spss">foreign::read.spss()</a></code> or
<code>convert.factors = FALSE</code> when importing with <code><a href="foreign.html#topic+read.dta">foreign::read.dta()</a></code>.
</p>
<p>To convert correctly defined missing values imported with
<code><a href="foreign.html#topic+read.spss">foreign::read.spss()</a></code>, you should have used <code>to.data.frame = FALSE</code> and
<code>use.missings = FALSE</code>. If you used the option <code>to.data.frame = TRUE</code>,
meta data describing missing values will not be attached to the import.
If you used <code>use.missings = TRUE</code>, missing values would have been converted
to <code>NA</code>.
</p>
<p>So far, missing values defined in <strong>Stata</strong> are always imported as <code>NA</code> by
<code><a href="foreign.html#topic+read.dta">foreign::read.dta()</a></code> and could not be retrieved by <code>foreign_to_labelled()</code>.
</p>
<p>If you convert a labelled vector into a factor with prefix, i.e. by using
<a href="#topic+to_factor">to_factor(levels = &quot;prefixed&quot;)</a>, <code>to_labelled.factor()</code> is able
to reconvert it to a labelled vector with same values and labels.
</p>


<h3>Value</h3>

<p>A tbl data frame or a labelled vector.
</p>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+labelled">haven::labelled()</a></code>, <code><a href="foreign.html#topic+read.spss">foreign::read.spss()</a></code>,
<code><a href="foreign.html#topic+read.dta">foreign::read.dta()</a></code>, <code>memisc::data.set()</code>,
<code>memisc::importer</code>, <code><a href="#topic+to_factor">to_factor()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # from foreign
  library(foreign)
  sav &lt;- system.file("files", "electric.sav", package = "foreign")
  df &lt;- to_labelled(read.spss(
    sav,
    to.data.frame = FALSE,
    use.value.labels = FALSE,
    use.missings = FALSE
 ))

 # from memisc
 library(memisc)
 nes1948.por &lt;- UnZip('anes/NES1948.ZIP', 'NES1948.POR', package='memisc')
 nes1948 &lt;- spss.portable.file(nes1948.por)
 ds &lt;- as.data.set(nes1948)
 df &lt;- to_labelled(ds)

## End(Not run)

# Converting factors to labelled vectors
f &lt;- factor(
  c("yes", "yes", "no", "no", "don't know", "no", "yes", "don't know")
)
to_labelled(f)
to_labelled(f, c("yes" = 1, "no" = 2, "don't know" = 9))
to_labelled(f, c("yes" = 1, "no" = 2))
to_labelled(f, c("yes" = "Y", "no" = "N", "don't know" = "DK"))

s1 &lt;- labelled(c('M', 'M', 'F'), c(Male = 'M', Female = 'F'))
labels &lt;- val_labels(s1)
f1 &lt;- to_factor(s1)
f1

to_labelled(f1)
identical(s1, to_labelled(f1))
to_labelled(f1, labels)
identical(s1, to_labelled(f1, labels))

l &lt;- labelled(
  c(1, 1, 2, 2, 9, 2, 1, 9),
  c("yes" = 1, "no" = 2, "don't know" = 9)
)
f &lt;- to_factor(l, levels = "p")
f
to_labelled(f)
identical(to_labelled(f), l)
</code></pre>

<hr>
<h2 id='unique_tagged_na'>Unique elements, duplicated, ordering and sorting with tagged NAs</h2><span id='topic+unique_tagged_na'></span><span id='topic+duplicated_tagged_na'></span><span id='topic+order_tagged_na'></span><span id='topic+sort_tagged_na'></span>

<h3>Description</h3>

<p>These adaptations of <code><a href="base.html#topic+unique">base::unique()</a></code>, <code><a href="base.html#topic+duplicated">base::duplicated()</a></code>,
<code><a href="base.html#topic+order">base::order()</a></code> and <code><a href="base.html#topic+sort">base::sort()</a></code> treats tagged NAs as distinct
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_tagged_na(x, fromLast = FALSE)

duplicated_tagged_na(x, fromLast = FALSE)

order_tagged_na(
  x,
  na.last = TRUE,
  decreasing = FALSE,
  method = c("auto", "shell", "radix"),
  na_decreasing = decreasing,
  untagged_na_last = TRUE
)

sort_tagged_na(
  x,
  decreasing = FALSE,
  na.last = TRUE,
  na_decreasing = decreasing,
  untagged_na_last = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_tagged_na_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_fromlast">fromLast</code></td>
<td>
<p>logical indicating if duplication should be
considered from the last</p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_na.last">na.last</code></td>
<td>
<p>if <code>TRUE</code>, missing values in the data are put last;
if <code>FALSE</code>, they are put first</p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_decreasing">decreasing</code></td>
<td>
<p>should the sort order be increasing or decreasing?</p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_method">method</code></td>
<td>
<p>the method to be used, see <code><a href="base.html#topic+order">base::order()</a></code></p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_na_decreasing">na_decreasing</code></td>
<td>
<p>should the sort order for tagged NAs value be</p>
</td></tr>
<tr><td><code id="unique_tagged_na_+3A_untagged_na_last">untagged_na_last</code></td>
<td>
<p>should untagged <code>NA</code>s be sorted after tagged <code>NA</code>s?
increasing or decreasing?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, tagged_na("a"), 1, tagged_na("z"), 2, tagged_na("a"), NA)
x %&gt;% print_tagged_na()

unique(x) %&gt;% print_tagged_na()
unique_tagged_na(x) %&gt;% print_tagged_na()

duplicated(x)
duplicated_tagged_na(x)

order(x)
order_tagged_na(x)

sort(x, na.last = TRUE) %&gt;% print_tagged_na()
sort_tagged_na(x) %&gt;% print_tagged_na()
</code></pre>

<hr>
<h2 id='update_labelled'>Update labelled data to last version</h2><span id='topic+update_labelled'></span><span id='topic+update_labelled.labelled'></span><span id='topic+update_labelled.haven_labelled_spss'></span><span id='topic+update_labelled.haven_labelled'></span><span id='topic+update_labelled.data.frame'></span>

<h3>Description</h3>

<p>Labelled data imported with <span class="pkg">haven</span> version 1.1.2 or before or
created with <code><a href="haven.html#topic+labelled">haven::labelled()</a></code> version 1.1.0 or before was using
&quot;labelled&quot; and &quot;labelled_spss&quot; classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_labelled(x)

## S3 method for class 'labelled'
update_labelled(x)

## S3 method for class 'haven_labelled_spss'
update_labelled(x)

## S3 method for class 'haven_labelled'
update_labelled(x)

## S3 method for class 'data.frame'
update_labelled(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_labelled_+3A_x">x</code></td>
<td>
<p>An object (vector or data.frame) to convert.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since version 2.0.0 of these two packages, &quot;haven_labelled&quot; and
&quot;haven_labelled_spss&quot; are used instead.
</p>
<p>Since haven 2.3.0, &quot;haven_labelled&quot; class has been evolving
using now <span class="pkg">vctrs</span> package.
</p>
<p><code>update_labelled()</code> convert labelled vectors
from the old to the new classes and to reconstruct all
labelled vectors with the last version of the package.
</p>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+labelled">haven::labelled()</a></code>, <code><a href="haven.html#topic+labelled_spss">haven::labelled_spss()</a></code>
</p>

<hr>
<h2 id='val_labels'>Get / Set value labels</h2><span id='topic+val_labels'></span><span id='topic+val_labels+3C-'></span><span id='topic+val_label'></span><span id='topic+val_label+3C-'></span><span id='topic+get_value_labels'></span><span id='topic+set_value_labels'></span><span id='topic+add_value_labels'></span><span id='topic+remove_value_labels'></span>

<h3>Description</h3>

<p>Get / Set value labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_labels(x, prefixed = FALSE)

val_labels(x) &lt;- value

val_label(x, v, prefixed = FALSE)

val_label(x, v) &lt;- value

get_value_labels(x, prefixed = FALSE)

set_value_labels(.data, ..., .labels = NA, .strict = TRUE)

add_value_labels(.data, ..., .strict = TRUE)

remove_value_labels(.data, ..., .strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val_labels_+3A_x">x</code></td>
<td>
<p>A vector or a data.frame</p>
</td></tr>
<tr><td><code id="val_labels_+3A_prefixed">prefixed</code></td>
<td>
<p>Should labels be prefixed with values?</p>
</td></tr>
<tr><td><code id="val_labels_+3A_value">value</code></td>
<td>
<p>A named vector for <code>val_labels()</code> (see <code><a href="haven.html#topic+labelled">haven::labelled()</a></code>) or
a character string for <code>val_label()</code>. <code>NULL</code> to remove the labels.
For data frames, it could also be a named list with a vector of value
labels per variable.</p>
</td></tr>
<tr><td><code id="val_labels_+3A_v">v</code></td>
<td>
<p>A single value.</p>
</td></tr>
<tr><td><code id="val_labels_+3A_.data">.data</code></td>
<td>
<p>a data frame or a vector</p>
</td></tr>
<tr><td><code id="val_labels_+3A_...">...</code></td>
<td>
<p>name-value pairs of value labels (see examples)</p>
</td></tr>
<tr><td><code id="val_labels_+3A_.labels">.labels</code></td>
<td>
<p>value labels to be applied to the data.frame,
using the same syntax as <code>value</code> in <code>val_labels(df) &lt;- value</code>.</p>
</td></tr>
<tr><td><code id="val_labels_+3A_.strict">.strict</code></td>
<td>
<p>should an error be returned if some labels
doesn't correspond to a column of <code>x</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>val_labels()</code> will return a named vector.
<code>val_label()</code> will return a single character string.
</p>
<p><code>set_value_labels()</code>, <code>add_value_labels()</code> and <code>remove_value_labels()</code> will
return an updated copy of <code>.data</code>.
</p>


<h3>Note</h3>

<p><code>get_value_labels()</code> is identical to <code>val_labels()</code>.
</p>
<p><code>set_value_labels()</code>, <code>add_value_labels()</code> and <code>remove_value_labels()</code>
could be used with <span class="pkg">dplyr</span> syntax.
While <code>set_value_labels()</code> will replace the list of value labels,
<code>add_value_labels()</code> and <code>remove_value_labels()</code> will update that list
(see examples).
</p>
<p><code>set_value_labels()</code> could also be applied to a vector / a data.frame column.
In such case, you can provide a vector of value labels using <code>.labels</code> or
several name-value pairs of value labels (see example).
Similarly, <code>add_value_labels()</code> and <code>remove_value_labels()</code> could also be
applied on vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1,2,2,2,3,9,1,3,2,NA), c(yes = 1, no = 3, "don't know" = 9))
val_labels(v)
val_labels(v, prefixed = TRUE)
val_label(v, 2)
val_label(v, 2) &lt;- 'maybe'
val_label(v, 9) &lt;- NULL
val_labels(v) &lt;- NULL
if (require(dplyr)) {
  # setting value labels
  df &lt;- tibble(s1 = c("M", "M", "F"), s2 = c(1, 1, 2)) %&gt;%
    set_value_labels(
      s1 = c(Male = "M", Female = "F"),
      s2 = c(Yes = 1, No = 2)
    )
  val_labels(df)

  # updating value labels
  df &lt;- df %&gt;% add_value_labels(s2 = c(Unknown = 9))
  df$s2

  # removing a value labels
  df &lt;- df %&gt;% remove_value_labels(s2 = 9)
  df$s2

  # removing all value labels
  df &lt;- df %&gt;% set_value_labels(s2 = NULL)
  df$s2

  # example on a vector
  v &lt;- 1:4
  v &lt;- set_value_labels(v, min = 1, max = 4)
  v
  v %&gt;% set_value_labels(middle = 3)
  v %&gt;% set_value_labels(NULL)
  v %&gt;% set_value_labels(.labels = c(a = 1, b = 2, c= 3, d = 4))
  v %&gt;% add_value_labels(between = 2)
  v %&gt;% remove_value_labels(4)
}
</code></pre>

<hr>
<h2 id='val_labels_to_na'>Recode value labels  to NA</h2><span id='topic+val_labels_to_na'></span>

<h3>Description</h3>

<p>For labelled variables, values with a label will be recoded to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_labels_to_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val_labels_to_na_+3A_x">x</code></td>
<td>
<p>Object to recode.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+zap_labels">haven::zap_labels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- labelled(c(1, 2, 9, 1, 9), c(dk = 9))
val_labels_to_na(v)
</code></pre>

<hr>
<h2 id='var_label'>Get / Set a variable label</h2><span id='topic+var_label'></span><span id='topic+var_label.data.frame'></span><span id='topic+var_label+3C-'></span><span id='topic+get_variable_labels'></span><span id='topic+set_variable_labels'></span><span id='topic+label_attribute'></span><span id='topic+get_label_attribute'></span><span id='topic+set_label_attribute'></span><span id='topic+label_attribute+3C-'></span>

<h3>Description</h3>

<p>Get / Set a variable label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_label(x, ...)

## S3 method for class 'data.frame'
var_label(
  x,
  unlist = FALSE,
  null_action = c("keep", "fill", "skip"),
  recurse = FALSE,
  ...
)

var_label(x) &lt;- value

get_variable_labels(x, ...)

set_variable_labels(.data, ..., .labels = NA, .strict = TRUE)

label_attribute(x)

get_label_attribute(x)

set_label_attribute(x, value)

label_attribute(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_label_+3A_x">x</code></td>
<td>
<p>a vector or a data.frame</p>
</td></tr>
<tr><td><code id="var_label_+3A_...">...</code></td>
<td>
<p>name-value pairs of variable labels (see examples)</p>
</td></tr>
<tr><td><code id="var_label_+3A_unlist">unlist</code></td>
<td>
<p>for data frames, return a named vector instead of a list</p>
</td></tr>
<tr><td><code id="var_label_+3A_null_action">null_action</code></td>
<td>
<p>for data frames, by default <code>NULL</code> will be returned for
columns with no variable label. Use <code>"fill"</code> to populate with the column name
instead, or <code>"skip"</code> to remove such values from the returned list.</p>
</td></tr>
<tr><td><code id="var_label_+3A_recurse">recurse</code></td>
<td>
<p>if <code>TRUE</code>, will apply <code>var_label()</code> on packed columns
(see <code><a href="tidyr.html#topic+pack">tidyr::pack()</a></code>) to return the variable labels of each sub-column;
otherwise, the label of the group of columns will be returned.</p>
</td></tr>
<tr><td><code id="var_label_+3A_value">value</code></td>
<td>
<p>a character string or <code>NULL</code> to remove the label
For data frames, with <code>var_labels()</code>, it could also be a named list or a
character vector of same length as the number of columns in <code>x</code>.</p>
</td></tr>
<tr><td><code id="var_label_+3A_.data">.data</code></td>
<td>
<p>a data frame or a vector</p>
</td></tr>
<tr><td><code id="var_label_+3A_.labels">.labels</code></td>
<td>
<p>variable labels to be applied to the data.frame,
using the same syntax as <code>value</code> in <code>var_label(df) &lt;- value</code>.</p>
</td></tr>
<tr><td><code id="var_label_+3A_.strict">.strict</code></td>
<td>
<p>should an error be returned if some labels
doesn't correspond to a column of <code>x</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_variable_labels()</code> is identical to <code>var_label()</code>.
</p>
<p>For data frames, if you are using <code style="white-space: pre;">&#8288;var_label()&lt;-&#8288;</code> and if <code>value</code> is a
named list, only elements whose name will match a column of the data frame
will be taken into account. If <code>value</code> is a character vector, labels should
be in the same order as the columns of the data.frame.
</p>
<p>If you are using <code style="white-space: pre;">&#8288;label_attribute()&lt;-&#8288;</code> or <code>set_label_attribute()</code> on a data
frame, the label attribute will be attached to the data frame itself, not
to a column of the data frame.
</p>
<p>If you are using packed columns (see <code><a href="tidyr.html#topic+pack">tidyr::pack()</a></code>), please read the
dedicated vignette.
</p>


<h3>Value</h3>

<p><code>set_variable_labels()</code> will return an updated copy of <code>.data</code>.
</p>


<h3>Note</h3>

<p><code>set_variable_labels()</code> could be used with <span class="pkg">dplyr</span> syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_label(iris$Sepal.Length)
var_label(iris$Sepal.Length) &lt;- 'Length of the sepal'
## Not run: 
 View(iris)

## End(Not run)
# To remove a variable label
var_label(iris$Sepal.Length) &lt;- NULL
# To change several variable labels at once
var_label(iris) &lt;- c(
  "sepal length", "sepal width", "petal length",
  "petal width", "species"
)
var_label(iris)
var_label(iris) &lt;- list(
  Petal.Width = "width of the petal",
  Petal.Length = "length of the petal",
  Sepal.Width = NULL,
  Sepal.Length = NULL
)
var_label(iris)
var_label(iris, null_action = "fill")
var_label(iris, null_action = "skip")
var_label(iris, unlist = TRUE)

if (require(dplyr)) {
  # adding some variable labels
  df &lt;- tibble(s1 = c("M", "M", "F"), s2 = c(1, 1, 2)) %&gt;%
    set_variable_labels(s1 = "Sex", s2 = "Yes or No?")
  var_label(df)

  # removing a variable label
  df &lt;- df %&gt;% set_variable_labels(s2 = NULL)
  var_label(df$s2)

  # Set labels from dictionary, e.g. as read from external file
  # One description is missing, one has no match
  description = tibble(
    name = c(
      "Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width",
      "Something"),
    label = c(
      "Sepal length", "Sepal width",  "Petal length", "Petal width",
      "something")
  )
  var_labels &lt;- setNames(as.list(description$label), description$name)
  iris_labelled &lt;- iris %&gt;%
    set_variable_labels(.labels = var_labels, .strict = FALSE)
  var_label(iris_labelled)

  # defining variable labels derived from variable names
  if (require(snakecase)) {
    iris &lt;- iris %&gt;%
      set_variable_labels(.labels = to_sentence_case(names(iris)))
    var_label(iris)
  }

  # example with a vector
  v &lt;- 1:5
  v &lt;- v %&gt;% set_variable_labels("a variable label")
  v
  v %&gt;% set_variable_labels(NULL)
}
</code></pre>

<hr>
<h2 id='x_haven_2.0'>Datasets for testing</h2><span id='topic+x_haven_2.0'></span><span id='topic+x_spss_haven_2.0'></span><span id='topic+spss_file'></span><span id='topic+dta_file'></span>

<h3>Description</h3>

<p>These datasets are used to test compatibility with foreign (spss_foreign),
or haven_2.0 (x_haven_2.0, x_spss_haven_2.0) packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_haven_2.0

x_spss_haven_2.0

spss_file

dta_file
</code></pre>


<h3>Format</h3>

<p>An object of class <code>haven_labelled</code> of length 6.
</p>
<p>An object of class <code>haven_labelled_spss</code> (inherits from <code>haven_labelled</code>) of length 10.
</p>
<p>An object of class <code>list</code> of length 13.
</p>
<p>An object of class <code>data.frame</code> with 47 rows and 6 columns.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
