<!DOCTYPE html><html><head><title>Help for package simcausal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simcausal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A'><p>Subsetting/Indexing Actions Defined for <code>DAG</code> Object</p></a></li>
<li><a href='#add.action'><p>Define and Add Actions (Interventions)</p></a></li>
<li><a href='#add.nodes'><p>Adding Node(s) to DAG</p></a></li>
<li><a href='#DAG.empty'><p>Initialize an empty DAG object</p></a></li>
<li><a href='#Define_sVar'><p>Class for defining and evaluating user-specified summary measures (exprs_list)</p></a></li>
<li><a href='#DF.to.long'><p>Convert Data from Wide to Long Format Using <code>reshape</code></p></a></li>
<li><a href='#DF.to.longDT'><p>Faster Conversion of Data from Wide to Long Format Using <code>dcast.data.table</code></p></a></li>
<li><a href='#distr.list'><p>List All Custom Distribution Functions in <code>simcausal</code>.</p></a></li>
<li><a href='#doLTCF'><p>Missing Variable Imputation with Last Time Point Value Carried Forward (LTCF)</p></a></li>
<li><a href='#eval.target'><p>Evaluate the True Value of the Causal Target Parameter</p></a></li>
<li><a href='#igraph.to.sparseAdjMat'><p>Convert igraph Network Object into Sparse Adjacency Matrix</p></a></li>
<li><a href='#N'><p>Subsetting/Indexing <code>DAG</code> Nodes</p></a></li>
<li><a href='#net.list'><p>List All Custom Network Generator Functions in <code>simcausal</code>.</p></a></li>
<li><a href='#NetInd.to.sparseAdjMat'><p>Convert Network IDs Matrix into Sparse Adjacency Matrix</p></a></li>
<li><a href='#NetIndClass'><p>R6 class for creating and storing a friend matrix (network IDs) for network data</p></a></li>
<li><a href='#network'><p>Define a Network Generator</p></a></li>
<li><a href='#node'><p>Create Node Object(s)</p></a></li>
<li><a href='#parents'><p>Show Node Parents Given DAG Object</p></a></li>
<li><a href='#plotDAG'><p>Plot DAG</p></a></li>
<li><a href='#plotSurvEst'><p>(EXPERIMENTAL) Plot Discrete Survival Function(s)</p></a></li>
<li><a href='#print.DAG'><p>Print DAG Object</p></a></li>
<li><a href='#print.DAG.action'><p>Print Action Object</p></a></li>
<li><a href='#print.DAG.node'><p>Print DAG.node Object</p></a></li>
<li><a href='#rbern'><p>Random Sample from Bernoulli Distribution</p></a></li>
<li><a href='#rcat.factor'><p>Random Sample for a Categorical Factor</p></a></li>
<li><a href='#rcategor.int'><p>Random Sample from Base 1 (rcat.b1) or Base 0 (rcat.b0) Categorical (Integer) Distribution</p></a></li>
<li><a href='#rconst'><p>Constant (Degenerate) Distribution (Returns its Own Argument <code>const</code>)</p></a></li>
<li><a href='#rdistr.template'><p>Template for Writing Custom Distribution Functions</p></a></li>
<li><a href='#rnet.gnm'><p>Call <code>igraph::sample_gnm</code> to Generate Random Graph Object According to the G(n,m) Erdos-Renyi Model</p></a></li>
<li><a href='#rnet.gnp'><p>Call <code>igraph::sample_gnp</code> to Generate Random Graph Object According to the G(n,p) Erdos-Renyi Model</p></a></li>
<li><a href='#rnet.SmWorld'><p>Call <code>igraph::sample_smallworld</code> to Generate Random Graph Object from the Watts-Strogatz Small-World Model</p></a></li>
<li><a href='#set.DAG'><p>Create and Lock DAG Object</p></a></li>
<li><a href='#set.targetE'><p>Define Non-Parametric Causal Parameters</p></a></li>
<li><a href='#set.targetMSM'><p>Define Causal Parameters with a Working Marginal Structural Model (MSM)</p></a></li>
<li><a href='#sim'><p>Simulate Observed or Full Data from <code>DAG</code> Object</p></a></li>
<li><a href='#simcausal'><p>Simulating Longitudinal Data with Causal Inference Applications</p></a></li>
<li><a href='#simfull'><p>Simulate Full Data (From Action DAG(s))</p></a></li>
<li><a href='#simobs'><p>Simulate Observed Data</p></a></li>
<li><a href='#sparseAdjMat.to.igraph'><p>Convert Network from Sparse Adjacency Matrix into igraph Object</p></a></li>
<li><a href='#sparseAdjMat.to.NetInd'><p>Convert Network from Sparse Adjacency Matrix into Network IDs Matrix</p></a></li>
<li><a href='#vecfun.add'><p>Add Custom Vectorized Functions</p></a></li>
<li><a href='#vecfun.all.print'><p>Print Names of All Vectorized Functions</p></a></li>
<li><a href='#vecfun.print'><p>Print Names of Custom Vectorized Functions</p></a></li>
<li><a href='#vecfun.remove'><p>Remove Custom Vectorized Functions</p></a></li>
<li><a href='#vecfun.reset'><p>Reset Custom Vectorized Function List</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.6</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Longitudinal Data with Causal Inference Applications</td>
</tr>
<tr>
<td>Description:</td>
<td>A flexible tool for simulating complex longitudinal data using
    structural equations, with emphasis on problems in causal inference.
    Specify interventions and simulate from intervened data generating
    distributions. Define and evaluate treatment-specific means, the average
    treatment effects and coefficients from working marginal structural models.
    User interface designed to facilitate the conduct of transparent and
    reproducible simulation studies, and allows concise expression of complex
    functional dependencies for a large number of time-varying nodes. See the
    package vignette for more information, documentation and examples.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/osofr/simcausal">https://github.com/osofr/simcausal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/osofr/simcausal/issues">https://github.com/osofr/simcausal/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, igraph, stringr, R6, assertthat, Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>copula, RUnit, ltmle, knitr, ggplot2, Hmisc, mvtnorm, bindata</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-28 01:11:08 UTC; fred</td>
</tr>
<tr>
<td>Author:</td>
<td>Oleg Sofrygin [aut],
  Mark J. van der Laan [aut],
  Romain Neugebauer [aut],
  Fred Gruber [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fred Gruber &lt;fgruber@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-28 11:52:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='A'>Subsetting/Indexing Actions Defined for <code>DAG</code> Object</h2><span id='topic+A'></span>

<h3>Description</h3>

<p>Subsetting/Indexing Actions Defined for <code>DAG</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A(DAG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A_+3A_dag">DAG</code></td>
<td>
<p>A DAG object that was defined using functions <code><a href="#topic+node">node</a></code>, <code><a href="#topic+set.DAG">set.DAG</a></code> and <code><a href="#topic+action">action</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of actions, which are intervened versions of the original observed data DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- DAG.empty()
D &lt;- D + node(name="W1", distr="rbern", prob=plogis(-0.5))
D &lt;- D + node(name="W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- D + node(name="A", distr="rbern", prob=plogis(-0.5 + 0.5*W1+ 0.5*W2))
D &lt;- set.DAG(D)
# Define two actions, acting on node "A"
D &lt;- D + action("A0", nodes=node("A", distr="rbern", prob=0))
D &lt;- D + action("A1", nodes=node("A", distr="rbern", prob=1))
# Select both actions
A(D)
# Select action "A1" only
A(D)["A1"]
</code></pre>

<hr>
<h2 id='add.action'>Define and Add Actions (Interventions)</h2><span id='topic+add.action'></span><span id='topic+action'></span>

<h3>Description</h3>

<p>Define and add new action (intervention) to the existing DAG object. Use either syntax <code>DAG +</code> <code>action(name = ,nodes = )</code> or <code>add.action((DAG = ,name = ,nodes = )</code>. Both give identical results, see the examples in the vignette and below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.action(DAG, name, nodes, ..., attr = list())

action(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.action_+3A_dag">DAG</code></td>
<td>
<p>DAG object</p>
</td></tr>
<tr><td><code id="add.action_+3A_name">name</code></td>
<td>
<p>Unique name of the action</p>
</td></tr>
<tr><td><code id="add.action_+3A_nodes">nodes</code></td>
<td>
<p>A list of node objects that defines the action on the DAG (replaces the distributions of the corresponding nodes in DAG)</p>
</td></tr>
<tr><td><code id="add.action_+3A_...">...</code></td>
<td>
<p>Additional named attributes defining / indexing the action</p>
</td></tr>
<tr><td><code id="add.action_+3A_attr">attr</code></td>
<td>
<p>Additional named attributes defining / indexing the action</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the action name and list of action nodes, both of these functions accept arbitrary named attributes (as additional arguments which must be given a name).
This additional attributes can be used to simplify specification of dynamic regimes (actions that depend on the past observed covariates).
</p>
<p>The formula of the intervention node is allowed to contain undefined variables, as long as those are later defined as a named argument to <code>action</code>. 
</p>
<p>In Example 2 below, <code>node("A",..., mean = ifelse(W1 &gt;= theta, 1, 0))</code>, 
defines the mean of the node &quot;A&quot; as a function of some undefined variable <code>theta</code>, setting <code>A</code> to 1 if the baseline node <code>W1</code> is above or equal to <code>theta</code> and 0 vice versa.
One specifies actual values of <code>theta</code> while defining a new action, possible creating a series of actions, each indexed by a different value of <code>theta</code>.
A new action can be defined with <code>D&lt;-D+action("A1th0.1", nodes=actN, theta=0.1)</code>.
</p>
<p>Note that any name can be used in place of <code>theta</code>. This attribute variable can appear anywhere inside the node distribution formula.
Finally, the attribute variable can also be time varying and, just like with DAG nodes, can be indexed by square bracket notation, <code>theta[t]</code>. See Example 3 for defining time-varying attributes.
</p>


<h3>Value</h3>

<p>A modified <code>DAG</code> object with the added action
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------------------
# EXAMPLE 1: Showing two equivalent ways of defining an action for a simple DAG
#---------------------------------------------------------------------------------------

D &lt;- DAG.empty()
D &lt;- D + node(name="W1", distr="rbern", prob=plogis(-0.5))
D &lt;- D + node(name="W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- D + node(name="A", distr="rbern", prob=plogis(-0.5 + 0.5*W1+ 0.5*W2))
Dset &lt;- set.DAG(D)

# Syntax '+ action': define two actions, intervening on node "A", imputing order
Dset &lt;- Dset + action("A0", nodes=node("A", distr="rbern", prob=0))
Dset &lt;- Dset + action("A1", nodes=node("A", distr="rbern", prob=1))

# Equivalent syntax 'add.action': define two actions, intervening on node "A"
Dset &lt;- add.action(Dset, "A0", nodes=node("A", distr="rbern", prob=0))
Dset &lt;- add.action(Dset, "A1", nodes=node("A", distr="rbern", prob=1))

#---------------------------------------------------------------------------------------
# EXAMPLE 2: Adding named attributes that define (index) the action.
# Define intervention on A that is conditional on W1 crossing some threshold theta
#---------------------------------------------------------------------------------------

# Redefining node W1 as uniform [0,1]
D &lt;- DAG.empty()
D &lt;- D + node(name="W1", distr="runif", min=0, max=1)
D &lt;- D + node(name="W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- D + node(name="A", distr="rbern", prob=plogis(-0.5 + 0.5*W1+ 0.5*W2))
Dset &lt;- set.DAG(D)

# Define a node that is indexed by unknown variable theta
actN &lt;- node("A",distr="rbern",prob=ifelse(W1 &gt;= theta,1,0))
# Define 3 actions for theta=0.1, 0.5, 0.9
Dset &lt;- Dset + action("A1th0.1", nodes = actN, theta = 0.1)
Dset &lt;- Dset + action("A1th0.5", nodes = actN, theta = 0.5)
Dset &lt;- Dset + action("A1th0.9", nodes = actN, theta = 0.9)

# Simulate 50 observations per each action above
simfull(A(Dset), n=50)

#---------------------------------------------------------------------------------------
# EXAMPLE 3: Time-varying action attributes for longitudinal DAG
#---------------------------------------------------------------------------------------
# Define longitudinal data structure over 6 time-points t=(0:5) with survival outcome "Y"
t_end &lt;- 5
D &lt;- DAG.empty()
D &lt;- D + node("L2", t=0, distr="rbern", prob=0.05)
D &lt;- D + node("L1", t=0, distr="rbern", prob=ifelse(L2[0]==1,0.5,0.1))
D &lt;- D + node("A1", t=0, distr="rbern", prob=ifelse(L1[0]==1, 0.5, 0.1))
D &lt;- D + node("Y",  t=0, distr="rbern",
                prob=plogis(-6.5 + L1[0] + 4*L2[0] + 0.05*I(L2[0]==0)), EFU=TRUE)
D &lt;- D + node("L2", t=1:t_end, distr="rbern", prob=ifelse(A1[t-1]==1, 0.1, 0.9))
D &lt;- D + node("A1", t=1:t_end, distr="rbern",
              prob=ifelse(A1[t-1]==1, 1, ifelse(L1[0]==1 &amp; L2[0]==0, 0.3, 0.5)))
D &lt;- D + node("Y",  t=1:t_end, distr="rbern", prob=plogis(-6.5+L1[0]+4*L2[t]), EFU=TRUE)
D &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# Dynamic actions indexed by constant value of parameter theta={0,1})
#---------------------------------------------------------------------------------------
# Define time-varying node A1: sets A1 to 1 if L2 at t is &gt;= theta
actN_A1 &lt;- node("A1",t=0:t_end, distr="rbern", prob=ifelse(L2[t] &gt;= theta,1,0))

# Define two actions, indexed by fixed values of theta={0,1}
D_act &lt;- D + action("A1_th0", nodes=actN_A1, theta=0)
D_act &lt;- D_act + action("A1_th1", nodes=actN_A1, theta=1)

# Simulate 50 observations for per each action above
simfull(simcausal::A(D_act), n=50)

#---------------------------------------------------------------------------------------
# Dynamic actions indexed by time-varying parameter theta[t]
#---------------------------------------------------------------------------------------
# This defines an action node with threshold theta varying in time (note syntax theta[t])
actN_A1 &lt;- node("A1",t=0:t_end, distr="rbern", prob=ifelse(L2[t] &gt;= theta[t],1,0))

# Now define 3 actions that are indexed by various values of theta over time
D_act &lt;- D + action("A1_th_const0", nodes=actN_A1, theta=rep(0,(t_end+1)))
D_act &lt;- D_act + action("A1_th_var1", nodes=actN_A1, theta=c(0,0,0,1,1,1))
D_act &lt;- D_act + action("A1_th_var2", nodes=actN_A1, theta=c(0,1,1,1,1,1))

# Simulate 50 observations for per each action above
simfull(simcausal::A(D_act), n=50)
</code></pre>

<hr>
<h2 id='add.nodes'>Adding Node(s) to DAG</h2><span id='topic+add.nodes'></span><span id='topic++2B.DAG'></span>

<h3>Description</h3>

<p>Adding nodes to a growing DAG object, as in <code>DAG + node()</code>. Use either syntax <code>DAG + node()</code> or <code>add.nodes(DAG = , nodes = node())</code>. Both give identical results, see the examples in the vignette and below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.nodes(DAG, nodes)

## S3 method for class 'DAG'
obj1 + obj2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.nodes_+3A_dag">DAG</code></td>
<td>
<p>DAG object</p>
</td></tr>
<tr><td><code id="add.nodes_+3A_nodes">nodes</code></td>
<td>
<p>A node or several nodes returned from a call to <code>node</code> function. If the node(s) under same name(s) already exist, the old node(s) get overwritten.</p>
</td></tr>
<tr><td><code id="add.nodes_+3A_obj1">obj1</code></td>
<td>
<p>Object that belongs to either classes: <code>DAG</code>, <code>DAG.action</code> or <code>DAG.nodelist</code>.</p>
</td></tr>
<tr><td><code id="add.nodes_+3A_obj2">obj2</code></td>
<td>
<p>Object that belongs to either classes: <code>DAG</code>, <code>DAG.action</code> or <code>DAG.nodelist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated DAG object with new nodes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+node">node</a></code>
</p>

<hr>
<h2 id='DAG.empty'>Initialize an empty DAG object</h2><span id='topic+DAG.empty'></span>

<h3>Description</h3>

<p>Initialize an empty DAG object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAG.empty()
</code></pre>

<hr>
<h2 id='Define_sVar'>Class for defining and evaluating user-specified summary measures (exprs_list)</h2><span id='topic+Define_sVar'></span>

<h3>Description</h3>

<p>Evaluates and and stores arbitrary summary measure expressions. The expressions (exprs_list) are evaluated in the environment of the input data.frame.
</p>


<h3>Format</h3>

<p>An R6 class object.
</p>


<h3>Details</h3>

<p>Following fields are created during initialization
</p>

<ul>
<li><p>nodes ...
</p>
</li>
<li><p>subset_regs ...
</p>
</li>
<li><p>sA_nms ...
</p>
</li>
<li><p>sW_nms ...
</p>
</li>
<li><p>Kmax ...
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Define_sVar-new"><code>Define_sVar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-set.new.exprs"><code>Define_sVar$set.new.exprs()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-eval.nodeforms"><code>Define_sVar$eval.nodeforms()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-eval.EFU"><code>Define_sVar$eval.EFU()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-df.names"><code>Define_sVar$df.names()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-setnode.setenv"><code>Define_sVar$setnode.setenv()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-set.net"><code>Define_sVar$set.net()</code></a>
</p>
</li>
<li> <p><a href="#method-Define_sVar-clone"><code>Define_sVar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Define_sVar-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$new()</pre></div>


<hr>
<a id="method-Define_sVar-set.new.exprs"></a>



<h4>Method <code>set.new.exprs()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$set.new.exprs(exprs_list)</pre></div>


<hr>
<a id="method-Define_sVar-eval.nodeforms"></a>



<h4>Method <code>eval.nodeforms()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$eval.nodeforms(cur.node, data.df)</pre></div>


<hr>
<a id="method-Define_sVar-eval.EFU"></a>



<h4>Method <code>eval.EFU()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$eval.EFU(cur.node, data.df)</pre></div>


<hr>
<a id="method-Define_sVar-df.names"></a>



<h4>Method <code>df.names()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$df.names(data.df)</pre></div>


<hr>
<a id="method-Define_sVar-setnode.setenv"></a>



<h4>Method <code>setnode.setenv()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$setnode.setenv(cur.node)</pre></div>


<hr>
<a id="method-Define_sVar-set.net"></a>



<h4>Method <code>set.net()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Define_sVar$set.net(netind_cl)</pre></div>


<hr>
<a id="method-Define_sVar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Define_sVar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='DF.to.long'>Convert Data from Wide to Long Format Using <code>reshape</code></h2><span id='topic+DF.to.long'></span>

<h3>Description</h3>

<p>This utility function takes a simulated data.frame in wide format as an input and converts it into a long format (slower compared to <code><a href="#topic+DF.to.longDT">DF.to.longDT</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DF.to.long(df_wide)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DF.to.long_+3A_df_wide">df_wide</code></td>
<td>
<p>A <code>data.frame</code> in wide format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keeps all covariates that appear only once and at the first time-point constant (carry-forward).
</p>
<p>All covariates that appear fewer than range(t) times are imputed with NA for missing time-points.
</p>
<p>Observations with all NA's for all time-varying covariates are removed.
</p>
<p>When removing NA's the time-varying covariates that are attributes (attnames) are not considered.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object in long format
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DF.to.longDT">DF.to.longDT</a></code> - a faster version of <code>DF.to.long</code> that uses <code>data.table</code> package
</p>
<p>Other data manipulation functions: 
<code><a href="#topic+DF.to.longDT">DF.to.longDT</a>()</code>,
<code><a href="#topic+doLTCF">doLTCF</a>()</code>
</p>

<hr>
<h2 id='DF.to.longDT'>Faster Conversion of Data from Wide to Long Format Using <code>dcast.data.table</code></h2><span id='topic+DF.to.longDT'></span>

<h3>Description</h3>

<p>Faster utility function for converting wide-format <code>data.frame</code> into a long format.
Internally uses <span class="pkg">data.table</span> package functions <code>melt.data.table</code> and <code>dcast.data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DF.to.longDT(df_wide, return_DF = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DF.to.longDT_+3A_df_wide">df_wide</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> in wide format</p>
</td></tr>
<tr><td><code id="DF.to.longDT_+3A_return_df">return_DF</code></td>
<td>
<p><code>TRUE</code> (default) to return a <code>data.frame</code>, <code>FALSE</code> returns a <code>data.table</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keeps all covariates that appear only once and at the first time-point constant (carry-forward).
</p>
<p>All covariates that appear fewer than range(t) times are imputed with NA for missing time-points.
</p>
<p>Observations with all NA's for all time-varying covariates are removed.
</p>
<p>When removing NA's the time-varying covariates that are attributes (attnames) are not considered.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> in long format
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+DF.to.long">DF.to.long</a>()</code>,
<code><a href="#topic+doLTCF">doLTCF</a>()</code>
</p>

<hr>
<h2 id='distr.list'>List All Custom Distribution Functions in <code>simcausal</code>.</h2><span id='topic+distr.list'></span>

<h3>Description</h3>

<p>List All Custom Distribution Functions in <code>simcausal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr.list()
</code></pre>

<hr>
<h2 id='doLTCF'>Missing Variable Imputation with Last Time Point Value Carried Forward (LTCF)</h2><span id='topic+doLTCF'></span>

<h3>Description</h3>

<p>Forward imputation for missing variable values in simulated data after a particular end of the follow-up event. The end of follow-up event is defined by the node of type <code>EOF=TRUE</code> being equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doLTCF(data, LTCF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doLTCF_+3A_data">data</code></td>
<td>
<p>Simulated <code>data.frame</code> in wide format</p>
</td></tr>
<tr><td><code id="doLTCF_+3A_ltcf">LTCF</code></td>
<td>
<p>Character string specifying the outcome node that is the indicator of the end of follow-up (observations with value of the outcome variable being 1 indicate that the end of follow-up has been reached). The outcome variable must be a binary node that was declared with <code>EFU=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>data.frame</code>, all time-varying missing variables after the <code>EFU</code> outcome specified in <code>LTCF</code> are forward imputed with their last available non-missing value.
</p>


<h3>Details</h3>

<p>The default behavior of the <code>sim</code> function consists in setting all nodes that temporally follow an <code>EFU</code> node whose simulated value is 1 to missing (i.e., <code>NA</code>).
The argument <code>LTCF</code> of the <code>sim</code> function can however be used to change this default behavior and impute some of these missing values with <em>last time point value carried forward</em> (LTCF).
More specifically, only the missing values of time-varying nodes (i.e., those with non-missing <code>t</code> argument) that follow the end of follow-up event encoded by the <code>EFU</code> node specified by the <code>LTCF</code> argument will be imputed.
One can use the function <code>doLTCF</code> to apply the <em>last time point value carried forward</em> (LTCF) imputation to an existing simulated dataset obtained from the function <code>sim</code> that was called with its default imputation setting (i.e., with no <code>LTCF</code> argument).
Illustration of the use of the LTCF imputation functionality are provided in the package vignette.
</p>
<p>The first example below shows the default data format of the <code>sim</code> function after an end of the follow-up event and how this behavior can be modified to generate data with LTCF imputation by either using the <code>LTCF</code> argument of the
<code>sim</code> function or by calling the <code>doLTCF</code> function. The second example demonstrates how to use the <code>doLTCF</code> function to perform LTCF imputation on already existing data simulated with the <code>sim</code> function based on its default non-imputation behavior.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim">sim</a></code>, <code><a href="#topic+simobs">simobs</a></code> and <code><a href="#topic+simfull">simfull</a></code> for simulating data with and without carry forward imputation.
</p>
<p>Other data manipulation functions: 
<code><a href="#topic+DF.to.longDT">DF.to.longDT</a>()</code>,
<code><a href="#topic+DF.to.long">DF.to.long</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_end &lt;- 10
lDAG &lt;- DAG.empty()
lDAG &lt;- lDAG +
	node(name = "L2", t = 0, distr = "rconst", const = 0) +
	node(name = "A1", t = 0, distr = "rconst", const = 0) +
	node(name = "L2", t = 1:t_end, distr = "rbern",
 	prob = ifelse(A1[t - 1]  ==  1, 0.1,
 			ifelse(L2[t-1] == 1, 0.9,
        min(1,0.1 + t/t_end)))) +
	node(name = "A1", t = 1:t_end, distr = "rbern",
 	prob = ifelse(A1[t - 1]  ==  1, 1,
 			 ifelse(L2[0] == 0, 0.3,
			  ifelse(L2[0] == 0, 0.1,
			   ifelse(L2[0] == 1, 0.7, 0.5))))) +
	node(name = "Y", t = 1:t_end, distr = "rbern",
 	prob = plogis(-6.5 + 4 * L2[t] + 0.05 * sum(I(L2[0:t] == rep(0,(t + 1))))),
 	EFU = TRUE)
lDAG &lt;- set.DAG(lDAG)
#---------------------------------------------------------------------------------------
# EXAMPLE 1. No forward imputation.
#---------------------------------------------------------------------------------------
Odat.wide &lt;- sim(DAG = lDAG, n = 1000, rndseed = 123)
Odat.wide[c(21,47), 1:18]
Odat.wideLTCF &lt;- sim(DAG = lDAG, n = 1000, LTCF = "Y", rndseed = 123)
Odat.wideLTCF[c(21,47), 1:18]
#---------------------------------------------------------------------------------------
# EXAMPLE 2. With forward imputation.
#---------------------------------------------------------------------------------------
Odat.wideLTCF2 &lt;- doLTCF(data = Odat.wide, LTCF = "Y")
Odat.wideLTCF2[c(21,47), 1:18]
# all.equal(Odat.wideLTCF, Odat.wideLTCF2)
</code></pre>

<hr>
<h2 id='eval.target'>Evaluate the True Value of the Causal Target Parameter</h2><span id='topic+eval.target'></span>

<h3>Description</h3>

<p>This function estimates the true value of the previously set target parameter (<code>set.targetE</code> or <code>set.targetMSM</code>) using the DAG object and either 1) <code>data</code>: list of action-specific simulated <code>data.frames</code>; or 2) <code>actions</code>; or 3) when <code>data</code> and <code>actions</code> are missing, using all distinct actions previously defined on the <code>DAG</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.target(
  DAG,
  n,
  data,
  actions,
  rndseed = NULL,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.target_+3A_dag">DAG</code></td>
<td>
<p>DAG object with target parameter set via <code>set.targetE</code> or <code>set.targetMSM</code> functions</p>
</td></tr>
<tr><td><code id="eval.target_+3A_n">n</code></td>
<td>
<p>Number of observations to simulate (if simulating full data), this is overwritten by the number of observations in each data</p>
</td></tr>
<tr><td><code id="eval.target_+3A_data">data</code></td>
<td>
<p>List of action-specific <code>data.frames</code> generated with <code>sim</code> or <code>simfull</code></p>
</td></tr>
<tr><td><code id="eval.target_+3A_actions">actions</code></td>
<td>
<p>Character vector of action names which play the role of the data generating mechanism for simulated data when argument <code>data</code> is missing. Alternatively, <code>actions</code> can be a list of action DAGs  pre-selected with <code>A(DAG)</code> function. When this argument is missing, full data is automatically sampled from all available actions in the <code>DAG</code> argument.</p>
</td></tr>
<tr><td><code id="eval.target_+3A_rndseed">rndseed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="eval.target_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console.
Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples and additional details see documentation for <code><a href="#topic+set.targetE">set.targetE</a></code> or <code><a href="#topic+set.targetMSM">set.targetMSM</a></code>
</p>


<h3>Value</h3>

<p>For targetE returns a vector of counterfactual means, ATE or ATR; for targetMSM returns a named list with the MSM model fit (<code>"msm"</code>),
MSM model coefficients (<code>"coef"</code>), the mapping of the MSM summary terms <code>S()</code> to the actual variable names used in the data, (<code>"S.msm.map"</code>),
and the long format full data that was used for fitting this MSM <code>"df_long"</code>.
</p>

<hr>
<h2 id='igraph.to.sparseAdjMat'>Convert igraph Network Object into Sparse Adjacency Matrix</h2><span id='topic+igraph.to.sparseAdjMat'></span>

<h3>Description</h3>

<p>Convert igraph network object into its sparse adjacency matrix representation using <code>as_adjacency_matrix</code> function from the <code>igraph</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.to.sparseAdjMat(igraph_network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.to.sparseAdjMat_+3A_igraph_network">igraph_network</code></td>
<td>
<p>Network as an <code>igraph</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparase adjacency matrix returned by <code>igraph::as_adjacency_matrix</code> function.
NOTE: for directed graphs the friend IDs pointing into vertex <code>i</code> are assumed to be listed in the column <code>i</code>
(i.e, <code>which(adjmat[,i])</code> are friends of <code>i</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>; <code><a href="#topic+sparseAdjMat.to.NetInd">sparseAdjMat.to.NetInd</a></code>; <code><a href="#topic+NetInd.to.sparseAdjMat">NetInd.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.igraph">sparseAdjMat.to.igraph</a></code>;
</p>

<hr>
<h2 id='N'>Subsetting/Indexing <code>DAG</code> Nodes</h2><span id='topic+N'></span>

<h3>Description</h3>

<p>Subsetting/Indexing <code>DAG</code> Nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N(DAG)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N_+3A_dag">DAG</code></td>
<td>
<p>A DAG object that was defined using functions <code><a href="#topic+node">node</a></code> and <code><a href="#topic+set.DAG">set.DAG</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of nodes that can be indexed as a typical named list &quot;[[]]&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- DAG.empty()
D &lt;- D + node(name="W1", distr="rbern", prob=plogis(-0.5))
D &lt;- D + node(name="W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- set.DAG(D)
#Returns all nodes from DAG D
N(D)
#Returns node W1 from DAG D
N(D)["W1"]
</code></pre>

<hr>
<h2 id='net.list'>List All Custom Network Generator Functions in <code>simcausal</code>.</h2><span id='topic+net.list'></span>

<h3>Description</h3>

<p>List All Custom Network Generator Functions in <code>simcausal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.list()
</code></pre>

<hr>
<h2 id='NetInd.to.sparseAdjMat'>Convert Network IDs Matrix into Sparse Adjacency Matrix</h2><span id='topic+NetInd.to.sparseAdjMat'></span>

<h3>Description</h3>

<p>Convert <code>simcausal</code> network ID matrix (<code>NetInd_k</code>) into a network represented by a sparse adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetInd.to.sparseAdjMat(NetInd_k, nF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetInd.to.sparseAdjMat_+3A_netind_k">NetInd_k</code></td>
<td>
<p>Matrix of network IDs of dimension <code>(n=nrow(sparseAdjMat),Kmax)</code>,
where each row <code>i</code> consists of the network IDs (row number of friends) of observation <code>i</code>. Remainders are filled with <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="NetInd.to.sparseAdjMat_+3A_nf">nF</code></td>
<td>
<p>Integer vector of length <code>n</code> specifying the number of friends for each observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Network represented as a sparse adjacency matrix (S4 class object <code>dgCMatrix</code> from package <code>Matrix</code>).
NOTE: The friend IDs for observation <code>i</code> will be listed in column <code>i</code>
(i.e, <code>which(sparseAdjMat[,i])</code> are friends of <code>i</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>; <code><a href="#topic+sparseAdjMat.to.igraph">sparseAdjMat.to.igraph</a></code>; <code><a href="#topic+igraph.to.sparseAdjMat">igraph.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.NetInd">sparseAdjMat.to.NetInd</a></code>;
</p>

<hr>
<h2 id='NetIndClass'>R6 class for creating and storing a friend matrix (network IDs) for network data</h2><span id='topic+NetIndClass'></span>

<h3>Description</h3>

<p>This R6 class defines fields and methods for creating and storing <code>NetInd_k</code>,
a matrix of friend indices (network IDs) of <code>dim = (nobs x Kmax)</code>.
</p>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object
</p>


<h3>Details</h3>


<ul>
<li><p>NetInd - Matrix of friend indices (network IDs) of <code>dim = (nobs x Kmax)</code> (Active Binding).
</p>
</li>
<li><p>nF - Vector of integers, where <code>nF[i]</code> is the integer number of friends (0 to <code>Kmax</code>) for observation <code>i</code>.
</p>
</li>
<li><p>nobs - Number of observations
</p>
</li>
<li><p>Kmax - Maximum number of friends for any observation.
</p>
</li></ul>



<h3>Methods</h3>


<dl>
<dt><code>new(nobs, Kmax = 1)</code></dt><dd><p>Uses <code>nobs</code> and <code>Kmax</code> to instantiate an object of R6 class and pre-allocate memory
for the future network ID matrix.</p>
</dd>
<dt><code>makeNetInd.fromIDs(Net_str, IDs_str = NULL, sep = ' ')</code></dt><dd><p>Build the matrix of network IDs (<code>NetInd_k</code>) from IDs string vector,
all friends of one observation <code>i</code> are located in a string Net_str[i], with two distinct friend IDs of <code>i</code>
separated by character <code>sep</code>. If <code>IDs_str</code> is NULL it is assumed that the friends in Net_str are
actual row numbers in <code>1:nobs</code>, otherwise IDs from Net_str will be used for looking up the observation row numbers in <code>IDs_str</code>.</p>
</dd>
<dt><code>make.nF(NetInd_k = self$NetInd_k, nobs = self$nobs, Kmax = self$Kmax)</code></dt><dd><p>This method calculates the integer number of
friends for each row of the network ID matrix (<code>self$NetInd_k</code>). The result is assigned to a field <code>self$nF</code> and
is returned invisibly.</p>
</dd>
<dt><code>mat.nF(nFnode)</code></dt><dd><p><code>nFnode</code> - the character name for the number of friends variable that is assigned as a column
name to a single column matrix in <code>self$nF</code>.</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NetIndClass-new"><code>NetIndClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NetIndClass-makeNetInd.fromIDs"><code>NetIndClass$makeNetInd.fromIDs()</code></a>
</p>
</li>
<li> <p><a href="#method-NetIndClass-make.nF"><code>NetIndClass$make.nF()</code></a>
</p>
</li>
<li> <p><a href="#method-NetIndClass-mat.nF"><code>NetIndClass$mat.nF()</code></a>
</p>
</li>
<li> <p><a href="#method-NetIndClass-clone"><code>NetIndClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NetIndClass-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NetIndClass$new(nobs, Kmax = 1)</pre></div>


<hr>
<a id="method-NetIndClass-makeNetInd.fromIDs"></a>



<h4>Method <code>makeNetInd.fromIDs()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NetIndClass$makeNetInd.fromIDs(Net_str, IDs_str = NULL, sep = " ")</pre></div>


<hr>
<a id="method-NetIndClass-make.nF"></a>



<h4>Method <code>make.nF()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NetIndClass$make.nF(
  NetInd_k = self$NetInd_k,
  nobs = self$nobs,
  Kmax = self$Kmax
)</pre></div>


<hr>
<a id="method-NetIndClass-mat.nF"></a>



<h4>Method <code>mat.nF()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>NetIndClass$mat.nF(nFnode)</pre></div>


<hr>
<a id="method-NetIndClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NetIndClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='network'>Define a Network Generator</h2><span id='topic+network'></span>

<h3>Description</h3>

<p>Define a network generator by providing a function (using the argument <code>netfun</code>) which will simulate a network of connected friends for observations <code>i</code> in <code>1:n</code>.
This network then serves as a backbone for defining and simulating from the structural equation models for dependent data.
In particular, the network allows new nodes to be defined as functions of the previously simulated node values of <code>i</code>'s friends, across all observations <code>i</code>.
Let <code>F_i</code> denote the set of friends of one observation <code>i</code> (observations in <code>F_i</code> are assumed to be &quot;connected&quot; to <code>i</code>) and
refer to the union of these sets <code>F_i</code> as a &quot;network&quot; on <code>n</code> observations, denoted by <code>F</code>.
A user-supplied network generating function <code>netfun</code> should be able to simulate such network <code>F</code> by returning a matrix of <code>n</code> rows,
where each row <code>i</code> defines a friend set <code>F_i</code>, i.e., row <code>i</code> should be a vector of observations in <code>1:n</code> that are connected to <code>i</code> (friends of <code>i</code>),
with the remainder filled by <code>NA</code>s.
Each friend set <code>F_i</code> can contain up to <code>Kmax</code> unique indices <code>j</code> from <code>1:n</code>, except for <code>i</code> itself.
<code>F_i</code> is also allowed to be empty (row <code>i</code> has only <code>NA</code>s), implying that <code>i</code> has no friends.
The functionality is illustrated in the examples below. For additional information see Details.
To learn how to use the <code>node</code> function for defining a node as a function of the friend node values, see Syntax and Network Summary Measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network(name, netfun, ..., params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_+3A_name">name</code></td>
<td>
<p>Character string specifiying the name of the current network, may be used for adding new network that replaces the existing one (resample previous network)</p>
</td></tr>
<tr><td><code id="network_+3A_netfun">netfun</code></td>
<td>
<p>Character name of the user-defined network generating function, can be any R function that returns a matrix of friend IDs of dimension <code>c(n, Kmax)</code>.
The function must accept a named argument <code>n</code> that specifies the total sample size of the network.
The matrix of network IDs should have <code>n</code> rows and <code>Kmax</code> columns, where each row <code>i</code> contains a vector of unique IDs in <code>1:n</code> that are <code>i</code>'s friends
(observations that can influence <code>i</code>'s node distribution), except for <code>i</code> itself.
Arguments to <code>netfun</code> can be either passed as named arguments to <code>network</code> function itself or as a named list of parameters <code>params</code>.
These network arguments can themselves be functions of the previously defined node names,
allowing for network sampling itself to be dependent on the previously simulated node values, as shown in Example 2.</p>
</td></tr>
<tr><td><code id="network_+3A_...">...</code></td>
<td>
<p>Named arguments specifying distribution parameters that are accepted by the network sampling function in <code>netfun</code>.
These parameters can be R expressions that are themselves formulas of the past node names.</p>
</td></tr>
<tr><td><code id="network_+3A_params">params</code></td>
<td>
<p>A list of additional named parameters to be passed on to the <code>netfun</code> function.
The parameters have to be either constants or character strings of R expressions of the past node names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without the network of friends, the <code>DAG</code> objects constructed by calling the <code>node</code> function can only specify structural equation models for independent and identically distributed data.
That is, if no network is specified, for each observation <code>i</code> a node can be defined conditionally only on <code>i</code>'s own previously simulated node values.
As a result, any two observations simulated under such data-generating model are always independent and identically distributed.
Defining a network <code>F</code> allows one to define a new structural equation model where a node for each observation <code>i</code> can depend
on its own simulated past, but also on the previously simulated node values of <code>i</code>'s friends (<code>F_i</code>).
This is accomplished by allowing the data generating distribution for each observation <code>i</code>'s node to be defined conditionally
on the past node values of <code>i</code>'s friends (observations in <code>F_i</code>).
The network of friends can be used in subsequent calls to <code>node</code> function where new nodes (random variables) defined by the <code>node</code> function can depend on the node values of <code>i</code>'s friends
(observations in the set <code>F_i</code>). During simulation it is assumed observations on <code>F_i</code> can simultaneously influence <code>i</code>.
</p>
<p>Note that the current version of the package does not allow combining time-varying node indexing <code>Var[t]</code> and network node indexing <code>Var[[net_indx]]</code>
for the same data generating distribution.
</p>
<p>Each argument for the input network can be an evaluable R expression. All formulas are captured by delayed evaluation and are evaluated during the simulation.
Formulas can refer to standard or user-specified R functions that must only apply to the values of previously defined nodes
(i.e. node(s) that were called prior to <code>network()</code> function call).
</p>


<h3>Value</h3>

<p>A list containing the network object(s) of type <code>DAG.net</code>, this will be utilized when data is simulated with <code>sim</code> function.
</p>


<h3>Syntax</h3>

<p>The <code>network</code> function call that defines the network of friends can be added to a growing <code>DAG</code> object by using <code>'+'</code> syntax, much like a new <code>node</code> is added to a <code>DAG</code>.
Subsequently defined nodes (<code>node</code> function calls) can employ the double square bracket subsetting syntax to reference previously simulated node values
for specific friends in <code>F_i</code> simultaneously across all observations <code>i</code>.
For example, <code>VarName[[net_indx]]</code> can be used inside the <code>node</code> formula to reference the node <code>VarName</code> values of <code>i</code>'s friends in <code>F_i[net_indx]</code>,
simultaneously across all <code>i</code> in <code>1:n</code>.
</p>
<p>The friend subsetting index <code>net_indx</code> can be any non-negative integer vector that takes values from 0 to <code>Kmax</code>,
where 0 refers to the <code>VarName</code> node values of observation <code>i</code> itself (this is equivalent to just using <code>VarnName</code> in the <code>node</code> formula),
<code>net_indx</code> value of 1 refers to node <code>VarName</code> values for observations in <code>F_i[1]</code>, across all <code>i</code> in <code>1:n</code>
(that is, the value of <code>VarName</code> of <code>i</code>'s first friend <code>F_i[1]</code>, if the friend exists and <code>NA</code> otherwise),
and so on, up to <code>net_indx</code> value of <code>Kmax</code>, which would reference to the last friend node values of <code>VarName</code>, as defined by observations in <code>F_i[Kmax]</code> across all <code>i</code>.
Note that <code>net_indx</code> can be a vector (e.g, <code>net_indx=c(1:Kmax)</code>),
in which case the result of the query <code>VarName[[c(1:Kmax)]]</code> is a matrix of <code>Kmax</code> columns and <code>n</code> rows.
</p>
<p>By default, <code>VarName[[j]]</code> evaluates to missing (<code>NA</code>) when observation <code>i</code> does not have a friend under <code>F_i[j]</code> (i.e., in the <code>j</code>th spot of <code>i</code>'s friend set).
This default behavior however can be changed to return 0 instead of <code>NA</code>, by passing an additional argument <code>replaceNAw0 = TRUE</code> to the corresponding <code>node</code> function.
</p>


<h3>Network Summary Measures</h3>

<p>One can also define summary measures of the network covariates by specifying a node formula that applies an R function to the result of <code>VarName[[net_indx]]</code>.
The rules for defining and applying such summary measures are identical to the rules for defining summary measures for time-varying nodes VarName[t_indx].
For example, use <code>sum(VarName[[net_indx]])</code> to define a summary measure as a sum of <code>VarName</code> values of friends in <code>F_i[net_indx]</code>, across all observations <code>i</code> in <code>1:n</code>.
Similarly, use <code>mean(VarName[[net_indx]])</code> to define a summary measure as a mean of <code>VarName</code> values of friends in <code>F_i[net_indx]</code>, across all <code>i</code>.
For more details on defining such summary functions see the <code>simcausal</code> vignette.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+igraph.to.sparseAdjMat">igraph.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.NetInd">sparseAdjMat.to.NetInd</a></code>; <code><a href="#topic+NetInd.to.sparseAdjMat">NetInd.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.igraph">sparseAdjMat.to.igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--------------------------------------------------------------------------------------------------
# EXAMPLE 1. USING igraph R PACKAGE TO SIMULATE NETWORKS
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
# Example of a network sampler, will be provided as "netfun" argument to network(, netfun=);
# Generates a random graph according to the G(n,m) Erdos-Renyi model using the igraph package;
# Returns (n,Kmax) matrix of net IDs (friends) by row;
# Row i contains the IDs (row numbers) of i's friends;
# i's friends are assumed connected to i and can influence i in equations defined by node())
# When i has less than Kmax friends, the remaining i row entries are filled with NAs;
# Argument m_pn: &gt; 0
# a total number of edges in the network as a fraction (or multiplier) of n (sample size)
#--------------------------------------------------------------------------------------------------
gen.ER &lt;- function(n, m_pn, ...) {
  m &lt;- as.integer(m_pn*n)
  if (n&lt;=10) m &lt;- 20
  igraph.ER &lt;- igraph::sample_gnm(n = n, m = m, directed = TRUE)
  sparse_AdjMat &lt;- igraph.to.sparseAdjMat(igraph.ER)
  NetInd_out &lt;- sparseAdjMat.to.NetInd(sparse_AdjMat)
  return(NetInd_out$NetInd_k)
}

D &lt;- DAG.empty()
# Sample ER model network using igraph::sample_gnm with m_pn argument:
D &lt;- D + network("ER.net", netfun = "gen.ER", m_pn = 50)
# W1 - categorical (6 categories, 1-6):
D &lt;- D +
  node("W1", distr = "rcat.b1",
        probs = c(0.0494, 0.1823, 0.2806, 0.2680, 0.1651, 0.0546)) +
# W2 - binary infection status, positively correlated with W1:
  node("W2", distr = "rbern", prob = plogis(-0.2 + W1/3)) +
# W3 - binary confounder:
  node("W3", distr = "rbern", prob = 0.6)
# A[i] is a function W1[i] and the total of i's friends values W1, W2 and W3:
D &lt;- D + node("A", distr = "rbern",
              prob = plogis(2 + -0.5 * W1 +
                            -0.1 * sum(W1[[1:Kmax]]) +
                            -0.4 * sum(W2[[1:Kmax]]) +
                            -0.7 * sum(W3[[1:Kmax]])),
              replaceNAw0 = TRUE)
# Y[i] is a function of netW3 (friends of i W3 values) and the total N of i's friends
# who are infected AND untreated:
D &lt;- D + node("Y", distr = "rbern",
              prob = plogis(-1 + 2 * sum(W2[[1:Kmax]] * (1 - A[[1:Kmax]])) +
                            -2 * sum(W3[[1:Kmax]])
                            ),
              replaceNAw0 = TRUE)
# Can add N untreated friends to the above outcome Y equation: sum(1 - A[[1:Kmax]]):
D &lt;- D + node("Y", distr = "rbern",
              prob = plogis(-1 + 1.5 * sum(W2[[1:Kmax]] * (1 - A[[1:Kmax]])) +
                            -2 * sum(W3[[1:Kmax]]) +
                            0.25 * sum(1 - A[[1:Kmax]])
                            ),
              replaceNAw0 = TRUE)
# Can add N infected friends at baseline to the above outcome Y equation: sum(W2[[1:Kmax]]):
D &lt;- D + node("Y", distr = "rbern",
              prob = plogis(-1 + 1 * sum(W2[[1:Kmax]] * (1 - A[[1:Kmax]])) +
                            -2 * sum(W3[[1:Kmax]]) +
                            0.25 * sum(1 - A[[1:Kmax]]) +
                            0.25 * sum(W2[[1:Kmax]])
                            ),
              replaceNAw0 = TRUE)
Dset &lt;- set.DAG(D, n.test = 100)
# Simulating data from the above sem:
datnet &lt;- sim(Dset, n = 1000, rndseed = 543)
head(datnet)
# Obtaining the network object from simulated data:
net_object &lt;- attributes(datnet)$netind_cl
# Max number of friends:
net_object$Kmax
# Network matrix
head(attributes(datnet)$netind_cl$NetInd)

#--------------------------------------------------------------------------------------------------
# EXAMPLE 2. USING CUSTOM NETWORK GENERATING FUNCTION
#--------------------------------------------------------------------------------------------------

#--------------------------------------------------------------------------------------------------
# Example of a user-defined network sampler(s) function
# Arguments K, bslVar[i] (W1) &amp; nF are evaluated in the environment of the simulated data then
# passed to genNET() function
  # - K: maximum number of friends for any unit
  # - bslVar[i]: used for contructing weights for the probability of selecting i as
  # someone else's friend (weighted sampling), when missing the sampling goes to uniform
  # - nF[i]: total number of friends that need to be sampled for observation i
#--------------------------------------------------------------------------------------------------
genNET &lt;- function(n, K, bslVar, nF, ...) {
  prob_F &lt;- plogis(-4.5 + 2.5*c(1:K)/2) / sum(plogis(-4.5 + 2.5*c(1:K)/2))
  NetInd_k &lt;- matrix(NA_integer_, nrow = n, ncol = K)
  nFriendTot &lt;- rep(0L, n)
  for (index in (1:n)) {
    FriendSampSet &lt;- setdiff(c(1:n), index)
    nFriendSamp &lt;- max(nF[index] - nFriendTot[index], 0L)
    if (nFriendSamp &gt; 0) {
      if (length(FriendSampSet) == 1)  {
        friends_i &lt;- FriendSampSet
      } else {
        friends_i &lt;- sort(sample(FriendSampSet, size = nFriendSamp,
                          prob = prob_F[bslVar[FriendSampSet] + 1]))
      }
      NetInd_k[index, ] &lt;- c(as.integer(friends_i),
                            rep_len(NA_integer_, K - length(friends_i)))
      nFriendTot[index] &lt;- nFriendTot[index] + nFriendSamp
    }
  }
  return(NetInd_k)
}

D &lt;- DAG.empty()
D &lt;- D +
# W1 - categorical or continuous confounder (5 categories, 0-4):
  node("W1", distr = "rcat.b0",
        probs = c(0.0494, 0.1823, 0.2806, 0.2680, 0.1651, 0.0546)) +
# W2 - binary infection status at t=0, positively correlated with W1:
  node("W2", distr = "rbern", prob = plogis(-0.2 + W1/3)) +
# W3 - binary confounder:
  node("W3", distr = "rbern", prob = 0.6)

# def.nF: total number of friends for each i (0-K), each def.nF[i] is influenced by categorical W1
K &lt;- 10
set.seed(12345)
normprob &lt;- function(x) x / sum(x)
p_nF_W1_mat &lt;- apply(matrix(runif((K+1)*6), ncol = 6, nrow = (K+1)), 2, normprob)
colnames(p_nF_W1_mat) &lt;- paste0("p_nF_W1_", c(0:5))
create_probs_nF &lt;- function(W1) t(p_nF_W1_mat[,W1+1])
vecfun.add("create_probs_nF")
D &lt;- D + node("def.nF", distr = "rcat.b0", probs = create_probs_nF(W1))

# Adding the network generator that depends on nF and categorical W1:
D &lt;- D + network(name="net.custom", netfun = "genNET", K = K, bslVar = W1, nF = def.nF)
# Define A[i] is a function W1[i] as well as the total sum of i's friends values for W1, W2 and W3:
D &lt;- D + node("A", distr = "rbern",
              prob = plogis(2 + -0.5 * W1 +
                            -0.1 * sum(W1[[1:Kmax]]) +
                            -0.4 * sum(W2[[1:Kmax]]) +
                            -0.7 * sum(W3[[1:Kmax]])),
              replaceNAw0 = TRUE)
# Y[i] is a the total N of i's friends who are infected AND untreated
# + a function of friends W3 values
D &lt;- D + node("pYRisk", distr = "rconst",
              const = plogis(-1 + 2 * sum(W2[[1:Kmax]] * (1 - A[[1:Kmax]])) +
                              -1.5 * sum(W3[[1:Kmax]])),
              replaceNAw0 = TRUE)

D &lt;- D + node("Y", distr = "rbern", prob = pYRisk)
Dset &lt;- set.DAG(D, n.test = 100)

# Simulating data from the above sem:
datnet &lt;- sim(Dset, n = 1000, rndseed = 543)
head(datnet, 10)
# Obtaining the network object from simulated data:
net_object &lt;- attributes(datnet)$netind_cl
# Max number of friends:
net_object$Kmax
# Network matrix
head(attributes(datnet)$netind_cl$NetInd)
plotDAG(Dset)
</code></pre>

<hr>
<h2 id='node'>Create Node Object(s)</h2><span id='topic+node'></span>

<h3>Description</h3>

<p>Define a single DAG node and its distribution or define many repeated-measure/time-varying nodes by using argument <code>t</code>.
The node distribution is allowed to vary as a function of time (<code>t</code>). Conditionaing on past nodes is accomplished by using the syntactic sugar, such as, <code>NodeName[t]</code>.
After all the nodes have been added to the DAG, call <code><a href="#topic+set.DAG">set.DAG</a></code>, a DAG object constructor, and <code><a href="#topic+add.action">add.action</a></code>, an action (intervention) constructor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node(name, t, distr, EFU, order, ..., params = list(), asis.params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_+3A_name">name</code></td>
<td>
<p>Character node name or a vector of names when specifying a multivariate node. For time-dependent nodes the names will be automatically expanded to a scheme &quot;name_t&quot; for each t provided specified.</p>
</td></tr>
<tr><td><code id="node_+3A_t">t</code></td>
<td>
<p>Node time-point(s). Allows specification of several time-points when t is a vector of positive integers, in which case the output will consist of a
named list of length(t) nodes, corresponding to each value in t.</p>
</td></tr>
<tr><td><code id="node_+3A_distr">distr</code></td>
<td>
<p>Character name of the node distribution, can be a standard distribution R function, s.a. rnorm, rbinom, runif or user defined.
The function must accept a named argument &quot;n&quot; to specify the total sample size.
Distributional parameters (arguments) must be passed as either named arguments to node or as a named list of parameters &quot;params&quot;.</p>
</td></tr>
<tr><td><code id="node_+3A_efu">EFU</code></td>
<td>
<p>End-of-Follow Up flag for designating a survival/censoring type node, only applies to Bernoulli nodes. When <code>EFU=TRUE</code> this node becomes an indicator for the end of follow-up event
(censoring, end of study, death, etc).
When simulated variable with this node distribution evaluates to value 1 subsequent nodes with higher temporal <code>order</code> values will be set to NA by default
(or imputed with carry forward imputation, depending on the settings of the <code>sim</code> function).
This can only be set to <code>TRUE</code> and should be omitted otherwise.</p>
</td></tr>
<tr><td><code id="node_+3A_order">order</code></td>
<td>
<p>An optional integer parameter specifying the order in which these nodes will be sampled. The value of order has to start at 1 and be unique for each new node,
can be specified as a range / vector and has to be of the same length as the argument <code>t</code> above.
When order is left unspecified it will be automatically inferred based on the order in which the node(s) were added in relation to other nodes. See Examples and Details below.</p>
</td></tr>
<tr><td><code id="node_+3A_...">...</code></td>
<td>
<p>Named arguments specifying distribution parameters that are accepted by the <code>distr</code> function. The parameters can be R expressions that are themselves formulas of the past node names.</p>
</td></tr>
<tr><td><code id="node_+3A_params">params</code></td>
<td>
<p>A list of additional named parameters to be passed on to the <code>distr</code> function. The parameters have to be either constants or character strings of R expressions of the past node names.</p>
</td></tr>
<tr><td><code id="node_+3A_asis.params">asis.params</code></td>
<td>
<p>(ADVANCED USE) A list of additional named distributional parameters that will be evaluated &quot;as is&quot;,
inside the currently simulated data.frame + the calling environment, without any modifications to the R expression strings inside the <code>asis.params</code> list.
There is no error-checking for existing node names and no parent node name extraction (the arrows from parents will not appear in <code>plotDAG</code>).
Time varying nodes should be referenced by their names as they appear in the simulated data, as in <code>"TVar_t"</code>.
See details and examples 7 and 8 below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing node object(s) (expanded to several nodes if t is an integer vector of length &gt; 1)
</p>


<h3>Details</h3>

<p>The combination of <code>name</code> and <code>t</code> must uniquely identify each node in the DAG. Use argument <code>t</code> to identify measurements of the same attribute (e.g. 'A1c') at various time points.
The collection of all unique <code>t</code> values, across all nodes, should consist of non-negative integers (i.e., starting at 0).
</p>
<p>The optional <code>order</code> argument can be specified, used for determining the sampling order of each node.
When <code>order</code> not specified, it is automatically inferred based on the actual order in which the nodes were added to the DAG (earlier added nodes get lower <code>order</code> value and are sampled first)
</p>
<p>All node calls that share the same generic name <code>name</code> must also share the same <code>EFU</code> value (if any is specified in at least one of them).
A value of <code>TRUE</code> for the <code>EFU</code> indicates that if a simulated value for a measurement of the attribute represented by node is 1
then all the following nodes with that measurement (in terms of higher <code>t</code> values) in the DAG will be unobserved (i.e., their simulated value will be set to NA).
</p>


<h3>Node formulas (parameters of the distribution)</h3>

<p>Each user-supplied argument to the node function is an evaluable R expression, their evaluation is delayed until the actual simulation time.
These arguments can refer to standard or user-specified R functions that must only apply to the values of parent nodes,
i.e. a subset of the node(s) with an <code>order</code> value strictly lower than that of the node characterized by the formula.
Formulas must reference the parent nodes with unique <code>name</code> identifiers, employing the square bracket vector subsetting <code>name[t]</code> for referencing a
parent node at a particular time point <code>t</code> (if any time-points were specified).
The square bracket notation is used to index a generic name with the relevant time point as illustrated in the examples.
When an input node is used to define several nodes (i.e., several measurement of the same attribute, <code>t=0:5</code>), the formula(s) specified in that node can apply
to each node indexed by a given time point denoted by <code>t</code>. This generic expression <code>t</code> can then be referenced within a formula to simultaneously identify a
different set of parent nodes for each time point as illustrated below. Note that the parents of each node represented by a given <code>node</code> object are implicitly defined
by the nodes referenced in formulas of that <code>node</code> call.
</p>


<h3>Different types of evaluation for node function arguments</h3>

<p>There is quite a bit of flexibility in the way in which the <code>node</code> function arguments can be evaluated.
By default, the named arguments specified as expressions are first captured by delayed-evaluation and then
modified by <code>simcausal</code> to enable the special types of functional syntax.
For example, simcausal will over-ride the subsetting operators '<code>[...]</code>' (for time varying nodes) and '[[...]]' (for networks), implying
that these operators can no longer be used in their typical <code>R</code> way.
Furthermore, simcausal will over-ride the standard 'c' function, with its own definition. Similarly, it will over-ride any calls to <code>sum</code> and <code>mean</code> functions
with their row-matrix counterpart functions <code>rowSums</code> and <code>rowMeans</code>.
When programming with <code>simcausal</code> (such as passing node arguments inside a function, prior to defining the node), it may be helpful to instead pass
such node arguments as character strings, rather than as R expressions. In this case one should use the argument <code>params</code>
by adopting the following syntax <code>node(...,params = list(mean="A+B"))</code>, which in this case is equivalent to: <code>node(..., mean = A+B)</code>.
</p>
<p>There are also instances when it might be desirable to retain the original behavior of all <code>R</code> expressions and functions and evaluate a particular node argument &quot;as is&quot;.
For example, the user may wish to retain the
original <code>R</code> functionality of all its operators, including those of <code>[...]</code> and <code>[[...]]</code>.
In this case the node argument (or a specific part of the node argument) should be wrapped in <code>.()</code> or <code>eval()</code>.
Note that once the expression has been wrapped with <code>.(...)</code> (or <code>eval(...)</code>), the <code>simcausal</code> definitions of operators <code>[...]</code> and <code>[[...]]</code> no
longer apply to these expressions and no error checking for &quot;correctness&quot; of these node arguments will be performed.
</p>
<p>The forced-evaluation operator <code>.()</code> can be also used as part of an expression,
which will prevent the typical <code>simcausal</code> evaluation on only that specific part of the expression. Example 8 below demonstrates the following use case
for the expression <code>.(coefAi[t]) * A[t-1]</code>,
which will look for vector <code>coefAi</code> and then subset it by current value of <code>t</code> (and return a scalar),
while <code>A[t-1]</code> will evaluate to the entire column vector of variable <code>A</code> for time point <code>t-1</code>.
Such an expression will multiply the entire time-varying vector <code>A[t-1]</code> by scalar value determined
by current value of <code>t</code> and the previously defined vector <code>coefAi</code>.
</p>
<p>Furthermore, even when a vector or a matrix is wrapped in .(...) it still will be automatically re-parsed into K column matrix with n rows.
When this is not desired, for example, when defining a multivariate node distribution, the user may pass such vector or matrix node arguments as a character string
in a list argument <code>asis.params</code>. See Example 7 and 8 below for additional details.
</p>


<h3>Multivariate random variables (multivariate nodes)</h3>

<p>Starting from v.0.5, a single <code>node</code> call can be used for defining a multivariate (and possibly correlated) random vector.
To define a random vector that has more than 1 dimension, use the argument <code>name</code> to specify a vector with names for each dimension, e.g.,
</p>
<p><code>node(c("X1","X2"), distr = "mvtnorm::rmvnorm", asis.params = list(mean = "c(0,1)", sigma = "matrix(c(1,0.75,0.75,1), ncol=2)"))</code>
</p>
<p>will define a bi-variate (correlated) normally distributed node,
the simulated data set will contain this bi-variately distributed random variable in columns &quot;X1&quot; and &quot;X2&quot;.
Note that the multivariate sampling distribution function (such as function <code>rmvnorm</code> from the package <code>mvtnorm</code>) must return a matrix of
<code>n</code> rows (number of observations) and <code>length(name)</code> columns (dimensionality). See additional examples below.
</p>
<p>Note that one can also define time-varying multivariate nodes, e.g.,
</p>
<p><code>node(c("X1","X2"), t=0:5, distr = "mvtnorm::rmvnorm", asis.params = list(mean = "c(0,1)"))</code>.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------------------
# EXAMPLE 1A: Define some Bernoulli nodes, survival outcome Y and put it together in a
# DAG object
#---------------------------------------------------------------------------------------
W1node &lt;- node(name = "W1", distr = "rbern",
	prob = plogis(-0.5), order = 1)
W2node &lt;- node(name = "W2", distr = "rbern",
	prob = plogis(-0.5 + 0.5 * W1), order = 2)
Anode &lt;- node(name = "A", distr = "rbern",
	prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2), order = 3)
Ynode &lt;- node(name = "Y", distr = "rbern",
	prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2), order = 4)
D1Aset &lt;- set.DAG(c(W1node,W2node,Anode,Ynode))

#---------------------------------------------------------------------------------------
# EXAMPLE 1B: Same as 1A using +node interface and no order argument
#---------------------------------------------------------------------------------------
D1B &lt;- DAG.empty()
D1B &lt;- D1B +
  node(name = "W1", distr = "rbern", prob = plogis(-0.5)) +
  node(name = "W2", distr = "rbern", prob = plogis(-0.5 + 0.5 * W1)) +
  node(name = "A", distr = "rbern", prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2)) +
  node(name = "Y", distr = "rbern", prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2))
D1Bset &lt;- set.DAG(D1B)

#---------------------------------------------------------------------------------------
# EXAMPLE 1C: Same as 1A and 1B using add.nodes interface and no order argument
#---------------------------------------------------------------------------------------
D1C &lt;- DAG.empty()
D1C &lt;- add.nodes(D1C, node(name = "W1", distr = "rbern", prob = plogis(-0.5)))
D1C &lt;- add.nodes(D1C, node(name = "W2", distr = "rbern",
	prob = plogis(-0.5 + 0.5 * W1)))
D1C &lt;- add.nodes(D1C, node(name = "A", distr = "rbern",
	prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2)))
D1C &lt;- add.nodes(D1C, node(name = "Y", distr = "rbern",
	prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2)))
D1C &lt;- set.DAG(D1C)

#---------------------------------------------------------------------------------------
# EXAMPLE 1D: Add a uniformly distributed node and redefine outcome Y as categorical
#---------------------------------------------------------------------------------------
D_unif &lt;- DAG.empty()
D_unif &lt;- D_unif +
 node("W1", distr = "rbern", prob = plogis(-0.5)) +
 node("W2", distr = "rbern", prob = plogis(-0.5 + 0.5 * W1)) +
 node("W3", distr = "runif", min = plogis(-0.5 + 0.7 * W1 + 0.3 * W2), max = 10) +
 node("An", distr = "rbern", prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2 - 0.2 * sin(W3)))
# Categorical syntax 1 (probabilities as values):
D_cat_1 &lt;- D_unif + node("Y", distr = "rcat.b1", probs = {0.3; 0.4})
D_cat_1 &lt;- set.DAG(D_cat_1)
# Categorical syntax 2 (probabilities as formulas):
D_cat_2 &lt;- D_unif +
node("Y", distr = "rcat.b1",
	probs={plogis(-0.1 + 1.2 * An + 0.3 * W1 + 0.3 * W2 + 0.2 * cos(W3));
			   plogis(-0.5 + 0.7 * W1)})
D_cat_2 &lt;- set.DAG(D_cat_2)

#---------------------------------------------------------------------------------------
# EXAMPLE 2A: Define Bernoulli nodes using R rbinom() function, defining prob argument
# for L2 as a function of node L1
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbinom", prob = 0.05, size = 1) +
node("L2", t = 0, distr = "rbinom", prob = ifelse(L1[0] == 1, 0.5, 0.1), size = 1)
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 2B: Equivalent to 2A, passing argument size to rbinom inside a named list
# params
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbinom", prob = 0.05, params = list(size = 1)) +
node("L2", t = 0, distr = "rbinom",
	prob = ifelse(L1[0] == 1,0.5,0.1), params = list(size = 1))
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 2C: Equivalent to 2A and 2B, define Bernoulli nodes using a wrapper "rbern"
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbern", prob = 0.05) +
node("L2", t = 0, distr = "rbern", prob = ifelse(L1[0] == 1, 0.5, 0.1))
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 3: Define node with normal distribution using rnorm() R function
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("L2", t = 0, distr = "rnorm", mean = 10, sd = 5)
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 4: Define 34 Bernoulli nodes, or 2 Bernoulli nodes over 17 time points,
#---------------------------------------------------------------------------------------
t_end &lt;- 16
D &lt;- DAG.empty()
D &lt;- D +
node("L2", t = 0:t_end, distr = "rbinom",
	prob = ifelse(t == t_end, 0.5, 0.1), size = 1) +
node("L1", t = 0:t_end, distr = "rbinom",
	prob = ifelse(L2[0] == 1, 0.5, 0.1), size = 1)
Dset &lt;- set.DAG(D)
sim(Dset, n=10)

#---------------------------------------------------------------------------------------
# EXAMPLE 5: Defining new distribution function 'rbern', defining and passing a custom
# vectorized node function 'customfun'
#---------------------------------------------------------------------------------------
rbern &lt;- function(n, prob) { # defining a bernoulli wrapper based on R rbinom function
  rbinom(n = n, prob = prob, size = 1)
}
customfun &lt;- function(arg, lambda) {
  res &lt;- ifelse(arg == 1, lambda, 0.1)
  res
}
D &lt;- DAG.empty()
D &lt;- D +
node("W1", distr = "rbern", prob = 0.05) +
node("W2", distr = "rbern", prob = customfun(W1, 0.5)) +
node("W3", distr = "rbern", prob = ifelse(W1 == 1, 0.5, 0.1))
D1d &lt;- set.DAG(D, vecfun = c("customfun"))
sim(D1d, n = 10, rndseed = 1)

#---------------------------------------------------------------------------------------
# EXAMPLE 6: Defining latent variables I and U.Y (will be hidden from simulated data)
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
  node("I",
    distr = "rcat.b1",
    probs = c(0.1, 0.2, 0.2, 0.2, 0.1, 0.1, 0.1)) +
  node("W1",
    distr = "rnorm",
    mean = ifelse(I == 1, 0, ifelse(I == 2, 3, 10)) + 0.6 * I,
    sd = 1) +
  node("W2",
    distr = "runif",
    min = 0.025*I, max = 0.7*I) +
  node("W3",
    distr = "rbern",
    prob = plogis(-0.5 + 0.7*W1 + 0.3*W2 - 0.2*I)) +
  node("A",
    distr = "rbern",
    prob = plogis(+4.2 - 0.5*W1 + 0.2*W2/2 + 0.2*W3)) +
	node("U.Y", distr = "rnorm", mean = 0, sd = 1) +
  node("Y",
    distr = "rconst",
    const = -0.5 + 1.2*A + 0.1*W1 + 0.3*W2 + 0.2*W3 + 0.2*I + U.Y)
Dset1 &lt;- set.DAG(D, latent.v = c("I", "U.Y"))
sim(Dset1, n = 10, rndseed = 1)

#---------------------------------------------------------------------------------------
# EXAMPLE 7: Multivariate random variables
#---------------------------------------------------------------------------------------
if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  # 2 dimensional normal (uncorrelated), using rmvnorm function from rmvnorm package:
  D &lt;- D +
    node(c("X1","X2"), distr = "mvtnorm::rmvnorm",
      asis.params = list(mean = "c(0,1)")) +
  # Can define a degenerate (rconst) multivariate node:
    node(c("X1.copy", "X2.copy"), distr = "rconst", const = c(X1, X2))
  Dset1 &lt;- set.DAG(D, verbose = TRUE)
  sim(Dset1, n = 10)
}

# On the other hand this syntax wont work,
# since simcausal will parse c(0,1) into a two column matrix:
## Not run: 
D &lt;- DAG.empty()
D &lt;- D + node(c("X1","X2"), distr = "mvtnorm::rmvnorm", mean = c(0,1))
Dset1 &lt;- set.DAG(D, verbose = TRUE)

## End(Not run)

if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  # Bivariate normal (correlation coef 0.75):
  D &lt;- D +
    node(c("X1","X2"), distr = "mvtnorm::rmvnorm",
      asis.params = list(mean = "c(0,1)",
        sigma = "matrix(c(1,0.75,0.75,1), ncol=2)")) +
  # Can use any component of such multivariate nodes when defining new nodes:
    node("A", distr = "rconst", const = 1 - X1)
  Dset2 &lt;- set.DAG(D, verbose = TRUE)
  sim(Dset2, n = 10)
}

# Time-varying multivar node (3 time-points, 2 dimensional normal)
# plus changing the mean over time, as as function of t:
if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
    node(c("X1", "X2"), t = 0:2, distr = "mvtnorm::rmvnorm",
      asis.params = list(
        mean = "c(0,1) + t",
        sigma = "matrix(rep(0.75,4), ncol=2)"))
  Dset5b &lt;- set.DAG(D)
  sim(Dset5b, n = 10)
}

# Two ways to define the same bivariate uniform copula:
if (requireNamespace("copula", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
  # with a warning since normalCopula() returns an object unknown to simcausal:
    node(c("X1","X2"), distr = "copula::rCopula",
      copula = eval(copula::normalCopula(0.75, dim = 2))) +
  # same, as above:
    node(c("X3","X4"), distr = "copula::rCopula",
      asis.params = list(copula = "copula::normalCopula(0.75, dim = 2)"))
  vecfun.add("qbinom")
  # Bivariate binomial derived from previous copula, with same correlation:
  D &lt;- D +
    node(c("A.Bin1", "A.Bin2"), distr = "rconst",
      const = c(qbinom(X1, 10, 0.5), qbinom(X2, 15, 0.7)))
  Dset3 &lt;- set.DAG(D)
  sim(Dset3, n = 10)
}

# Same as "A.Bin1" and "A.Bin2", but directly using rmvbin function in bindata package:
if (requireNamespace("bindata", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
    node(c("B.Bin1","B.Bin2"), distr = "bindata::rmvbin",
      asis.params = list(
        margprob = "c(0.5, 0.5)",
        bincorr = "matrix(c(1,0.75,0.75,1), ncol=2)"))
  Dset4b &lt;- set.DAG(D)
  sim(Dset4b, n = 10)
}

#---------------------------------------------------------------------------------------
# EXAMPLE 8: Combining simcausal non-standard evaluation with eval() forced evaluation
#---------------------------------------------------------------------------------------
coefAi &lt;- 1:10
D &lt;- DAG.empty()
D &lt;- D +
  node("A", t = 1, distr = "rbern", prob = 0.7) +
  node("A", t = 2:10, distr = "rconst", const = eval(coefAi[t]) * A[t-1])
Dset8 &lt;- set.DAG(D)
sim(Dset8, n = 10)

#---------------------------------------------------------------------------------------
# TWO equivalent ways of creating a multivariate node (combining nodes W1 and W2):
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("W1", distr = "rbern", prob = 0.45)
D &lt;- D + node("W2", distr = "rconst", const = 1)

# option 1:
D &lt;- D + node(c("W1.copy1", "W2.copy1"), distr = "rconst", const = c(W1, W2))

# equivalent option 2:
create_mat &lt;- function(W1, W2) cbind(W1, W2)
vecfun.add("create_mat")
D &lt;- D + node(c("W1.copy2", "W2.copy2"), distr = "rconst", const = create_mat(W1, W2))

Dset &lt;- set.DAG(D)
sim(Dset, n=10, rndseed=1)
</code></pre>

<hr>
<h2 id='parents'>Show Node Parents Given DAG Object</h2><span id='topic+parents'></span>

<h3>Description</h3>

<p>Given a vector of node names, this function provides the name(s) of node parents that were obtained by parsing the node formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parents(DAG, nodesChr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parents_+3A_dag">DAG</code></td>
<td>
<p>A DAG object that was specified by calling <code><a href="#topic+set.DAG">set.DAG</a></code></p>
</td></tr>
<tr><td><code id="parents_+3A_nodeschr">nodesChr</code></td>
<td>
<p>A vector of node names that are already defined in DAG</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with parent names for each node name in nodesChr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- DAG.empty()
D &lt;- D + node(name="W1", distr="rbern", prob=plogis(-0.5))
D &lt;- D + node(name="W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- D + node(name="A", distr="rbern", prob=plogis(-0.5 - 0.3*W1 - 0.3*W2))
D &lt;- D + node(name="Y", distr="rbern", prob=plogis(-0.1 + 1.2*A + 0.3*W1 + 0.3*W2), EFU=TRUE)
D &lt;- set.DAG(D)
parents(D, c("W2", "A", "Y"))
</code></pre>

<hr>
<h2 id='plotDAG'>Plot DAG</h2><span id='topic+plotDAG'></span>

<h3>Description</h3>

<p>Plot DAG object using functions from <code>igraph</code> package.
The default setting is to keep the regular (observed) DAG nodes with <code>shape</code> set to &quot;none&quot;, which can be over-ridden by the user.
For latent (hidden) DAG nodes the default is to:
1) set the node color as grey;
2) enclose the node by a circle; and
3) all directed edges coming out of the latent node are plotted as dashed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDAG(
  DAG,
  tmax = NULL,
  xjitter,
  yjitter,
  node.action.color,
  vertex_attrs = list(),
  edge_attrs = list(),
  excludeattrs,
  customvlabs,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDAG_+3A_dag">DAG</code></td>
<td>
<p>A DAG object that was specified by calling <code><a href="#topic+set.DAG">set.DAG</a></code></p>
</td></tr>
<tr><td><code id="plotDAG_+3A_tmax">tmax</code></td>
<td>
<p>Maximum time-point to plot for time-varying DAG objects</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_xjitter">xjitter</code></td>
<td>
<p>Amount of random jitter for node x-axis plotting coordinates</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_yjitter">yjitter</code></td>
<td>
<p>Amount of random jitter for node y-axis plotting coordinates</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_node.action.color">node.action.color</code></td>
<td>
<p>Color of the action node labels (only for action DAG of class DAG.action). If missing, defaults to red.</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_vertex_attrs">vertex_attrs</code></td>
<td>
<p>A named list of <code>igraph</code> graphical parameters for plotting DAG vertices. These parameters are passed on to <code>add.vertices</code> <code>igraph</code> function.</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_edge_attrs">edge_attrs</code></td>
<td>
<p>A named list of <code>igraph</code> graphical parameters for plotting DAG edges. These parameters are passed on to <code>add.edges</code> <code>igraph</code> function.</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_excludeattrs">excludeattrs</code></td>
<td>
<p>A character vector for DAG nodes that should be excluded from the plot</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_customvlabs">customvlabs</code></td>
<td>
<p>A named vector of custom DAG node labels (replaces node names from the DAG object).</p>
</td></tr>
<tr><td><code id="plotDAG_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console.
Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>

<hr>
<h2 id='plotSurvEst'>(EXPERIMENTAL) Plot Discrete Survival Function(s)</h2><span id='topic+plotSurvEst'></span>

<h3>Description</h3>

<p>Plot discrete survival curves from a list of discrete survival probabilities by calling <code><a href="graphics.html#topic+plot">plot</a></code> with <code>type='b'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSurvEst(
  surv = list(),
  xindx = NULL,
  ylab = "",
  xlab = "t",
  ylim = c(0, 1),
  legend.xyloc = "topright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSurvEst_+3A_surv">surv</code></td>
<td>
<p>A list of vectors, each containing action-specific discrete survival probabilities over time.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_xindx">xindx</code></td>
<td>
<p>A vector of indices for subsetting the survival vectors in <code>surv</code>, if omitted all survival probabilities in each <code>surv[[i]]</code> are plotted.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_ylab">ylab</code></td>
<td>
<p>An optional title for y axis, passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_xlab">xlab</code></td>
<td>
<p>An optional title for x axis, passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_ylim">ylim</code></td>
<td>
<p>Optional y limits for the plot, passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_legend.xyloc">legend.xyloc</code></td>
<td>
<p>Optional x and y co-ordinates to be used to position the legend.
Can be specified by keyword or as a named list with (x,y), uses the same convention as in <code>graphics::xy.coords</code>.</p>
</td></tr>
<tr><td><code id="plotSurvEst_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='print.DAG'>Print DAG Object</h2><span id='topic+print.DAG'></span>

<h3>Description</h3>

<p>Print DAG Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DAG_+3A_x">x</code></td>
<td>
<p>A DAG object.</p>
</td></tr>
<tr><td><code id="print.DAG_+3A_...">...</code></td>
<td>
<p>Other arguments to generic print.</p>
</td></tr>
</table>

<hr>
<h2 id='print.DAG.action'>Print Action Object</h2><span id='topic+print.DAG.action'></span>

<h3>Description</h3>

<p>Print Action Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG.action'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DAG.action_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="print.DAG.action_+3A_...">...</code></td>
<td>
<p>Other arguments to generic print.</p>
</td></tr>
</table>

<hr>
<h2 id='print.DAG.node'>Print DAG.node Object</h2><span id='topic+print.DAG.node'></span>

<h3>Description</h3>

<p>Print DAG.node Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DAG.node'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DAG.node_+3A_x">x</code></td>
<td>
<p>A Node object.</p>
</td></tr>
<tr><td><code id="print.DAG.node_+3A_...">...</code></td>
<td>
<p>Other arguments to generic print.</p>
</td></tr>
</table>

<hr>
<h2 id='rbern'>Random Sample from Bernoulli Distribution</h2><span id='topic+rbern'></span>

<h3>Description</h3>

<p>Wrapper for Bernoulli node distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbern(n, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbern_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="rbern_+3A_prob">prob</code></td>
<td>
<p>A vector of success probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binary vector of length <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---------------------------------------------------------------------------------------
# Specifying and simulating from a DAG with 3 Bernoulli nodes
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("W1", distr="rbern", prob=0.05)
D &lt;- D + node("W2", distr="rbern", prob=ifelse(W1==1,0.5,0.1))
D &lt;- D + node("W3", distr="rbern", prob=ifelse(W1==1,0.5,0.1))
Dset &lt;- set.DAG(D)
simdat &lt;- sim(Dset, n=200, rndseed=1)
</code></pre>

<hr>
<h2 id='rcat.factor'>Random Sample for a Categorical Factor</h2><span id='topic+rcat.factor'></span><span id='topic+rcategor'></span>

<h3>Description</h3>

<p>Matrix version of the categorical distribution. The argument <code>probs</code> can be a matrix of n rows,
specifying individual (varying in sample) categorical probabilities.
The number of categories generated is equal to <code>ncol(probs)+1</code>, the levels labeled as: <code>1,...,ncol(probs)+1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcat.factor(n, probs)

rcategor(n, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcat.factor_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="rcat.factor_+3A_probs">probs</code></td>
<td>
<p>Either a vector or a matrix of success probabilities.
When <code>probs</code> is a vector, <code>n</code> identically distributed random categorical variables
are generated with categories: 1, 2, ..., length(probs)+1.
When <code>probs</code> is a matrix, the categorical probabilities of the <code>k</code>th sample are determined by the
<code>k</code>th row of <code>probs</code> matrix, i.e., <code>probs[k,]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of length <code>n</code> with levels: <code>1,2, ...,ncol(probs)+1</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rcategor</code>: (Deperecated) Random Sample of a Categorical Factor
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+rcat.b1">rcat.b1</a></code>, <code><a href="#topic+rcat.b0">rcat.b0</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---------------------------------------------------------------------------------------
# Specifying and simulating from a DAG with one categorical node with constant
# probabilities
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("race",t=0,distr="rcat.factor",probs=c(0.2,0.1,0.4,0.15,0.05,0.1))
Dset &lt;- set.DAG(D)
simdat &lt;- sim(Dset, n=200, rndseed=1)

#---------------------------------------------------------------------------------------
# Specifying and simulating from a DAG with a categorical node with varying
# probabilities (probabilities are determined by values sampled for nodes L0 and L1)
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("L0", distr="rnorm", mean=10, sd=5)
D &lt;- D + node("L1", distr="rnorm", mean=10, sd=5)
D &lt;- D + node("L2", distr="rcat.factor", probs=c(abs(1/L0), abs(1/L1)))
Dset &lt;- set.DAG(D)
simdat &lt;- sim(Dset, n=200, rndseed=1)
</code></pre>

<hr>
<h2 id='rcategor.int'>Random Sample from Base 1 (rcat.b1) or Base 0 (rcat.b0) Categorical (Integer) Distribution</h2><span id='topic+rcategor.int'></span><span id='topic+rcat.b1'></span><span id='topic+rcat.b0'></span>

<h3>Description</h3>

<p>Same as , but returning a vector of sampled integers with range 1, 2, ..., <code>ncol(probs)+1</code> for <code>rcat.b1</code>
or range 0, 1, ..., <code>ncol(probs)</code> for <code>rcat.b0</code>. For sampling categorical factors see <a href="#topic+rcat.factor">rcat.factor</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcategor.int(n, probs)

rcat.b1(n, probs)

rcat.b0(n, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcategor.int_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="rcategor.int_+3A_probs">probs</code></td>
<td>
<p>Either a vector or a matrix of success probabilities.
When probs is a vector, <code>n</code> identically distributed random categorical variables are
generated.
When <code>probs</code> is a matrix, the categorical probabilities of the <code>k</code>th
sample are determined by the <code>k</code>th row of probs matrix, i.e., <code>probs[k,]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length <code>n</code> with range either in <code>0,...,ncol(probs)</code> or in <code>1,...,ncol(probs)+1</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rcategor.int</code>: (Deperecated) Random Sample from Base 1 Categorical (Integer) Distribution
</p>
</li>
<li> <p><code>rcat.b1</code>: Random Sample from Base 1 Categorical (Integer) Distribution
</p>
</li>
<li> <p><code>rcat.b0</code>: Random Sample from Base 0 Categorical (Integer) Distribution
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+rcat.factor">rcat.factor</a></code>
</p>

<hr>
<h2 id='rconst'>Constant (Degenerate) Distribution (Returns its Own Argument <code>const</code>)</h2><span id='topic+rconst'></span>

<h3>Description</h3>

<p>Wrapper for constant value (degenerate) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rconst(n, const)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rconst_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="rconst_+3A_const">const</code></td>
<td>
<p>Either a vector with one constant value (replicated <code>n</code> times)
or a vector of length <code>n</code> or a matrix with <code>n</code> rows (for a multivariate node).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of constants of length <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---------------------------------------------------------------------------------------
# Specifying and simulating from a DAG with 1 Bernoulli and 2 constant nodes
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("W1", distr = "rbern", prob = 0.45)
D &lt;- D + node("W2", distr = "rconst", const = 1)
D &lt;- D + node("W3", distr = "rconst", const = ifelse(W1 == 1, 5, 10))

# TWO equivalent ways of creating a multivariate node (just repeating W1 and W2):
create_mat &lt;- function(W1, W2) cbind(W1, W2)
vecfun.add("create_mat")

D &lt;- D + node(c("W1.copy1", "W2.copy1"), distr = "rconst", const = c(W1, W2))
D &lt;- D + node(c("W1.copy2", "W2.copy2"), distr = "rconst", const = create_mat(W1, W2))
Dset &lt;- set.DAG(D)
sim(Dset, n=10, rndseed=1)
</code></pre>

<hr>
<h2 id='rdistr.template'>Template for Writing Custom Distribution Functions</h2><span id='topic+rdistr.template'></span>

<h3>Description</h3>

<p>Template function for writing <code>SimCausal</code> custom distribution wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdistr.template(n, arg1, arg2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdistr.template_+3A_n">n</code></td>
<td>
<p>Sample size that needs to be generated</p>
</td></tr>
<tr><td><code id="rdistr.template_+3A_arg1">arg1</code></td>
<td>
<p>Argument 2</p>
</td></tr>
<tr><td><code id="rdistr.template_+3A_arg2">arg2</code></td>
<td>
<p>Argument 1</p>
</td></tr>
<tr><td><code id="rdistr.template_+3A_...">...</code></td>
<td>
<p>Additional optional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the named arguments must be 'n', this argument is passed on to the function automatically by
the package and is assigned to the number of samples that needs to be generated from this distribution.
Other arguments (in this example arg1 and arg2) must be declared by the user as
arguments inside the node() function that uses this distribution,
e.g., <code>node("Node1"</code>, <code>distr="distr.template"</code>, <code>arg1 = ...</code>, <code>arg2 = ...)</code>.
Both, arg1 and arg2, can be either numeric constants or formulas involving past node names.
The constants get passed on to the distribution function unchanged.
The formulas are evaluated inside the environment of the simulated data and are passed on to the
distribution functions as vectors.
The output of the distribution function is expected to be a vector of length n of the sampled covariates.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code>
</p>

<hr>
<h2 id='rnet.gnm'>Call <code>igraph::sample_gnm</code> to Generate Random Graph Object According to the G(n,m) Erdos-Renyi Model</h2><span id='topic+rnet.gnm'></span>

<h3>Description</h3>

<p>Call <code>igraph::sample_gnm</code> and convert the output to <code>simcausal</code> network matrix.
The parameter <code>m</code> of <code>igraph::sample_gnm</code> is derived from <code>n</code> and <code>m_pn</code> as <code>as.integer(m_pn*n)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet.gnm(n, m_pn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet.gnm_+3A_n">n</code></td>
<td>
<p>Size of the network graph (number of nodes).</p>
</td></tr>
<tr><td><code id="rnet.gnm_+3A_m_pn">m_pn</code></td>
<td>
<p>The total number of edges as a fraction of the sample size <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n rows, each row lists the indices of friends connected to that particular observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnet.gnp">rnet.gnp</a></code>
</p>

<hr>
<h2 id='rnet.gnp'>Call <code>igraph::sample_gnp</code> to Generate Random Graph Object According to the G(n,p) Erdos-Renyi Model</h2><span id='topic+rnet.gnp'></span>

<h3>Description</h3>

<p>Call <code>igraph::sample_gnp</code> and convert the output to <code>simcausal</code> network matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet.gnp(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet.gnp_+3A_n">n</code></td>
<td>
<p>Size of the network graph (number of nodes).</p>
</td></tr>
<tr><td><code id="rnet.gnp_+3A_p">p</code></td>
<td>
<p>Same as <code>igraph::sample_gnp</code>: The probability for drawing an edge between two arbitrary vertices (G(n,p) graph).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n rows, each row lists the indices of friends connected to that particular observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnet.gnm">rnet.gnm</a></code>
</p>

<hr>
<h2 id='rnet.SmWorld'>Call <code>igraph::sample_smallworld</code> to Generate Random Graph Object from the Watts-Strogatz Small-World Model</h2><span id='topic+rnet.SmWorld'></span>

<h3>Description</h3>

<p>Call <code>igraph::sample_smallworld</code> and convert the output to <code>simcausal</code> network matrix.
The parameters are the same as those of <code>igraph::sample_smallworld</code>.
The loop edges aren't allowed (<code>loops = FALSE</code>) and the multiple edges aren't allowed either <code>multiple = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet.SmWorld(n, dim, nei, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet.SmWorld_+3A_n">n</code></td>
<td>
<p>Size of the network graph (the number of nodes).</p>
</td></tr>
<tr><td><code id="rnet.SmWorld_+3A_dim">dim</code></td>
<td>
<p>Same as in <code>igraph::sample_smallworld</code>: Integer constant, the dimension of the starting lattice.</p>
</td></tr>
<tr><td><code id="rnet.SmWorld_+3A_nei">nei</code></td>
<td>
<p>Same as in <code>igraph::sample_smallworld</code>: Integer constant, the neighborhood within which the vertices of the lattice will be connected.</p>
</td></tr>
<tr><td><code id="rnet.SmWorld_+3A_p">p</code></td>
<td>
<p>Same as in <code>igraph::sample_smallworld</code>: Real constant between zero and one, the rewiring probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with n rows, each row lists the indices of friends connected to that particular observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnet.gnp">rnet.gnp</a></code>, <code><a href="#topic+rnet.gnm">rnet.gnm</a></code>
</p>

<hr>
<h2 id='set.DAG'>Create and Lock DAG Object</h2><span id='topic+set.DAG'></span>

<h3>Description</h3>

<p>Check current DAG (created with <code>node</code>) for errors and consistency of its node distributions, set the observed data generating distribution.
Attempts to simulates several observations to catch any errors in DAG definition. New nodes cannot be added after function set.DAG has been applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.DAG(
  DAG,
  vecfun,
  latent.v,
  n.test = 10,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.DAG_+3A_dag">DAG</code></td>
<td>
<p>Named list of node objects that together will form a DAG.
Temporal ordering of nodes is either determined by the order in which the nodes were added to the DAG (using <code>+node(...)</code> interface)
or with an optional &quot;order&quot; argument to <code>node()</code>.</p>
</td></tr>
<tr><td><code id="set.DAG_+3A_vecfun">vecfun</code></td>
<td>
<p>A character vector with names of the vectorized user-defined node formula functions. See examples and the vignette for more information.</p>
</td></tr>
<tr><td><code id="set.DAG_+3A_latent.v">latent.v</code></td>
<td>
<p>The names of the unobserved (latent) DAG node names. These variables will be hidden from the observed simulated data and will be marked differently on the DAG plot.</p>
</td></tr>
<tr><td><code id="set.DAG_+3A_n.test">n.test</code></td>
<td>
<p>Non-negative simulation sample size used for testing the consistency of the <code>DAG</code> object.
A larger <code>n.test</code> may be useful when simulating a network of a fixed size (see <code>?network</code>) or when testing <code>DAG</code> for rare-event errors.
A smaller <code>n.test</code> can be better for performance (faster validation of the <code>DAG</code>).
Set <code>n.test=0</code> to completely skip the simulation test (use at your own risk, since calling <code>sim()</code> on such un-tested <code>DAG</code> may lead to uninterpretable errors).
Note that when using <code>n.test=0</code>, the <code>plotDAG</code> function <em>will not</em> draw <em>any</em> child-parent relationships, since the formula parsing is not performed.</p>
</td></tr>
<tr><td><code id="set.DAG_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console. Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DAG (S3) object, which is a list consisting of node object(s) sorted by their temporal order.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------------------
# EXAMPLE 1A: Define some Bernoulli nodes, survival outcome Y and put it together in a
# DAG object
#---------------------------------------------------------------------------------------
W1node &lt;- node(name = "W1", distr = "rbern",
	prob = plogis(-0.5), order = 1)
W2node &lt;- node(name = "W2", distr = "rbern",
	prob = plogis(-0.5 + 0.5 * W1), order = 2)
Anode &lt;- node(name = "A", distr = "rbern",
	prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2), order = 3)
Ynode &lt;- node(name = "Y", distr = "rbern",
	prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2), order = 4)
D1Aset &lt;- set.DAG(c(W1node,W2node,Anode,Ynode))

#---------------------------------------------------------------------------------------
# EXAMPLE 1B: Same as 1A using +node interface and no order argument
#---------------------------------------------------------------------------------------
D1B &lt;- DAG.empty()
D1B &lt;- D1B +
  node(name = "W1", distr = "rbern", prob = plogis(-0.5)) +
  node(name = "W2", distr = "rbern", prob = plogis(-0.5 + 0.5 * W1)) +
  node(name = "A", distr = "rbern", prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2)) +
  node(name = "Y", distr = "rbern", prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2))
D1Bset &lt;- set.DAG(D1B)

#---------------------------------------------------------------------------------------
# EXAMPLE 1C: Same as 1A and 1B using add.nodes interface and no order argument
#---------------------------------------------------------------------------------------
D1C &lt;- DAG.empty()
D1C &lt;- add.nodes(D1C, node(name = "W1", distr = "rbern", prob = plogis(-0.5)))
D1C &lt;- add.nodes(D1C, node(name = "W2", distr = "rbern",
	prob = plogis(-0.5 + 0.5 * W1)))
D1C &lt;- add.nodes(D1C, node(name = "A", distr = "rbern",
	prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2)))
D1C &lt;- add.nodes(D1C, node(name = "Y", distr = "rbern",
	prob = plogis(-0.1 + 1.2 * A + 0.3 * W1 + 0.3 * W2)))
D1C &lt;- set.DAG(D1C)

#---------------------------------------------------------------------------------------
# EXAMPLE 1D: Add a uniformly distributed node and redefine outcome Y as categorical
#---------------------------------------------------------------------------------------
D_unif &lt;- DAG.empty()
D_unif &lt;- D_unif +
 node("W1", distr = "rbern", prob = plogis(-0.5)) +
 node("W2", distr = "rbern", prob = plogis(-0.5 + 0.5 * W1)) +
 node("W3", distr = "runif", min = plogis(-0.5 + 0.7 * W1 + 0.3 * W2), max = 10) +
 node("An", distr = "rbern", prob = plogis(-0.5 - 0.3 * W1 - 0.3 * W2 - 0.2 * sin(W3)))
# Categorical syntax 1 (probabilities as values):
D_cat_1 &lt;- D_unif + node("Y", distr = "rcat.b1", probs = {0.3; 0.4})
D_cat_1 &lt;- set.DAG(D_cat_1)
# Categorical syntax 2 (probabilities as formulas):
D_cat_2 &lt;- D_unif +
node("Y", distr = "rcat.b1",
	probs={plogis(-0.1 + 1.2 * An + 0.3 * W1 + 0.3 * W2 + 0.2 * cos(W3));
			   plogis(-0.5 + 0.7 * W1)})
D_cat_2 &lt;- set.DAG(D_cat_2)

#---------------------------------------------------------------------------------------
# EXAMPLE 2A: Define Bernoulli nodes using R rbinom() function, defining prob argument
# for L2 as a function of node L1
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbinom", prob = 0.05, size = 1) +
node("L2", t = 0, distr = "rbinom", prob = ifelse(L1[0] == 1, 0.5, 0.1), size = 1)
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 2B: Equivalent to 2A, passing argument size to rbinom inside a named list
# params
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbinom", prob = 0.05, params = list(size = 1)) +
node("L2", t = 0, distr = "rbinom",
	prob = ifelse(L1[0] == 1,0.5,0.1), params = list(size = 1))
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 2C: Equivalent to 2A and 2B, define Bernoulli nodes using a wrapper "rbern"
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
node("L1", t = 0, distr = "rbern", prob = 0.05) +
node("L2", t = 0, distr = "rbern", prob = ifelse(L1[0] == 1, 0.5, 0.1))
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 3: Define node with normal distribution using rnorm() R function
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("L2", t = 0, distr = "rnorm", mean = 10, sd = 5)
Dset &lt;- set.DAG(D)

#---------------------------------------------------------------------------------------
# EXAMPLE 4: Define 34 Bernoulli nodes, or 2 Bernoulli nodes over 17 time points,
#---------------------------------------------------------------------------------------
t_end &lt;- 16
D &lt;- DAG.empty()
D &lt;- D +
node("L2", t = 0:t_end, distr = "rbinom",
	prob = ifelse(t == t_end, 0.5, 0.1), size = 1) +
node("L1", t = 0:t_end, distr = "rbinom",
	prob = ifelse(L2[0] == 1, 0.5, 0.1), size = 1)
Dset &lt;- set.DAG(D)
sim(Dset, n=10)

#---------------------------------------------------------------------------------------
# EXAMPLE 5: Defining new distribution function 'rbern', defining and passing a custom
# vectorized node function 'customfun'
#---------------------------------------------------------------------------------------
rbern &lt;- function(n, prob) { # defining a bernoulli wrapper based on R rbinom function
  rbinom(n = n, prob = prob, size = 1)
}
customfun &lt;- function(arg, lambda) {
  res &lt;- ifelse(arg == 1, lambda, 0.1)
  res
}
D &lt;- DAG.empty()
D &lt;- D +
node("W1", distr = "rbern", prob = 0.05) +
node("W2", distr = "rbern", prob = customfun(W1, 0.5)) +
node("W3", distr = "rbern", prob = ifelse(W1 == 1, 0.5, 0.1))
D1d &lt;- set.DAG(D, vecfun = c("customfun"))
sim(D1d, n = 10, rndseed = 1)

#---------------------------------------------------------------------------------------
# EXAMPLE 6: Defining latent variables I and U.Y (will be hidden from simulated data)
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D +
  node("I",
    distr = "rcat.b1",
    probs = c(0.1, 0.2, 0.2, 0.2, 0.1, 0.1, 0.1)) +
  node("W1",
    distr = "rnorm",
    mean = ifelse(I == 1, 0, ifelse(I == 2, 3, 10)) + 0.6 * I,
    sd = 1) +
  node("W2",
    distr = "runif",
    min = 0.025*I, max = 0.7*I) +
  node("W3",
    distr = "rbern",
    prob = plogis(-0.5 + 0.7*W1 + 0.3*W2 - 0.2*I)) +
  node("A",
    distr = "rbern",
    prob = plogis(+4.2 - 0.5*W1 + 0.2*W2/2 + 0.2*W3)) +
	node("U.Y", distr = "rnorm", mean = 0, sd = 1) +
  node("Y",
    distr = "rconst",
    const = -0.5 + 1.2*A + 0.1*W1 + 0.3*W2 + 0.2*W3 + 0.2*I + U.Y)
Dset1 &lt;- set.DAG(D, latent.v = c("I", "U.Y"))
sim(Dset1, n = 10, rndseed = 1)

#---------------------------------------------------------------------------------------
# EXAMPLE 7: Multivariate random variables
#---------------------------------------------------------------------------------------
if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  # 2 dimensional normal (uncorrelated), using rmvnorm function from rmvnorm package:
  D &lt;- D +
    node(c("X1","X2"), distr = "mvtnorm::rmvnorm",
      asis.params = list(mean = "c(0,1)")) +
  # Can define a degenerate (rconst) multivariate node:
    node(c("X1.copy", "X2.copy"), distr = "rconst", const = c(X1, X2))
  Dset1 &lt;- set.DAG(D, verbose = TRUE)
  sim(Dset1, n = 10)
}

# On the other hand this syntax wont work,
# since simcausal will parse c(0,1) into a two column matrix:
## Not run: 
D &lt;- DAG.empty()
D &lt;- D + node(c("X1","X2"), distr = "mvtnorm::rmvnorm", mean = c(0,1))
Dset1 &lt;- set.DAG(D, verbose = TRUE)

## End(Not run)

if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  # Bivariate normal (correlation coef 0.75):
  D &lt;- D +
    node(c("X1","X2"), distr = "mvtnorm::rmvnorm",
      asis.params = list(mean = "c(0,1)",
        sigma = "matrix(c(1,0.75,0.75,1), ncol=2)")) +
  # Can use any component of such multivariate nodes when defining new nodes:
    node("A", distr = "rconst", const = 1 - X1)
  Dset2 &lt;- set.DAG(D, verbose = TRUE)
  sim(Dset2, n = 10)
}

# Time-varying multivar node (3 time-points, 2 dimensional normal)
# plus changing the mean over time, as as function of t:
if (requireNamespace("mvtnorm", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
    node(c("X1", "X2"), t = 0:2, distr = "mvtnorm::rmvnorm",
      asis.params = list(
        mean = "c(0,1) + t",
        sigma = "matrix(rep(0.75,4), ncol=2)"))
  Dset5b &lt;- set.DAG(D)
  sim(Dset5b, n = 10)
}

# Two ways to define the same bivariate uniform copula:
if (requireNamespace("copula", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
  # with a warning since normalCopula() returns an object unknown to simcausal:
    node(c("X1","X2"), distr = "copula::rCopula",
      copula = eval(copula::normalCopula(0.75, dim = 2))) +
  # same, as above:
    node(c("X3","X4"), distr = "copula::rCopula",
      asis.params = list(copula = "copula::normalCopula(0.75, dim = 2)"))
  vecfun.add("qbinom")
  # Bivariate binomial derived from previous copula, with same correlation:
  D &lt;- D +
    node(c("A.Bin1", "A.Bin2"), distr = "rconst",
      const = c(qbinom(X1, 10, 0.5), qbinom(X2, 15, 0.7)))
  Dset3 &lt;- set.DAG(D)
  sim(Dset3, n = 10)
}

# Same as "A.Bin1" and "A.Bin2", but directly using rmvbin function in bindata package:
if (requireNamespace("bindata", quietly = TRUE)) {
  D &lt;- DAG.empty()
  D &lt;- D +
    node(c("B.Bin1","B.Bin2"), distr = "bindata::rmvbin",
      asis.params = list(
        margprob = "c(0.5, 0.5)",
        bincorr = "matrix(c(1,0.75,0.75,1), ncol=2)"))
  Dset4b &lt;- set.DAG(D)
  sim(Dset4b, n = 10)
}

#---------------------------------------------------------------------------------------
# EXAMPLE 8: Combining simcausal non-standard evaluation with eval() forced evaluation
#---------------------------------------------------------------------------------------
coefAi &lt;- 1:10
D &lt;- DAG.empty()
D &lt;- D +
  node("A", t = 1, distr = "rbern", prob = 0.7) +
  node("A", t = 2:10, distr = "rconst", const = eval(coefAi[t]) * A[t-1])
Dset8 &lt;- set.DAG(D)
sim(Dset8, n = 10)

#---------------------------------------------------------------------------------------
# TWO equivalent ways of creating a multivariate node (combining nodes W1 and W2):
#---------------------------------------------------------------------------------------
D &lt;- DAG.empty()
D &lt;- D + node("W1", distr = "rbern", prob = 0.45)
D &lt;- D + node("W2", distr = "rconst", const = 1)

# option 1:
D &lt;- D + node(c("W1.copy1", "W2.copy1"), distr = "rconst", const = c(W1, W2))

# equivalent option 2:
create_mat &lt;- function(W1, W2) cbind(W1, W2)
vecfun.add("create_mat")
D &lt;- D + node(c("W1.copy2", "W2.copy2"), distr = "rconst", const = create_mat(W1, W2))

Dset &lt;- set.DAG(D)
sim(Dset, n=10, rndseed=1)
</code></pre>

<hr>
<h2 id='set.targetE'>Define Non-Parametric Causal Parameters</h2><span id='topic+set.targetE'></span>

<h3>Description</h3>

<p>Set up the causal target parameter as a vector of expectations, ratio of expectations or contrast of expectations (average treatment effect) over the nodes of specified actions.
These settings are then used to evaluate the true value of the causal target parameter by calling <code><a href="#topic+eval.target">eval.target</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.targetE(DAG, outcome, t, param, ..., attr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.targetE_+3A_dag">DAG</code></td>
<td>
<p>Object specifying the directed acyclic graph (DAG) for the observed data</p>
</td></tr>
<tr><td><code id="set.targetE_+3A_outcome">outcome</code></td>
<td>
<p>Name of the outcome node</p>
</td></tr>
<tr><td><code id="set.targetE_+3A_t">t</code></td>
<td>
<p>Integer vector of time points to use for expectations, has to be omitted or NULL for non-time-varying DAGs.</p>
</td></tr>
<tr><td><code id="set.targetE_+3A_param">param</code></td>
<td>
<p>A character vector <code>"ActionName1"</code>, specifying the action name for the expectation target parameter;
<code>"ActionName1 / ActionName2"</code>, for the ratio of expectations of <code>outcome</code> nodes for actions <code>"ActionName1"</code>
and <code>"ActionName2"</code>; <code>"ActionName1 - ActionName2"</code> for the contrast of expectations of <code>outcome</code> for actions <code>"ActionName1"</code> and <code>"ActionName2"</code></p>
</td></tr>
<tr><td><code id="set.targetE_+3A_...">...</code></td>
<td>
<p>Additional attributes (to be used in future versions)</p>
</td></tr>
<tr><td><code id="set.targetE_+3A_attr">attr</code></td>
<td>
<p>Additional attributes (to be used in future versions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified DAG object with the target parameter saved as part of the DAG,
this DAG can now be passed as an argument to <code><a href="#topic+eval.target">eval.target</a></code> function for actual Monte-Carlo evaluation of the target parameter. See Examples.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------------------
# EXAMPLE 1: DAG with single point treatment
#---------------------------------------------------------------------------------------
# Define a DAG with single-point treatment ("Anode")
D &lt;- DAG.empty()
D &lt;- D + node("W1", distr="rbern", prob=plogis(-0.5))
D &lt;- D + node("W2", distr="rbern", prob=plogis(-0.5 + 0.5*W1))
D &lt;- D + node("Anode", distr="rbern", prob=plogis(-0.5 - 0.3*W1 - 0.3*W2))
D &lt;- D + node("Y", distr="rbern", prob=plogis(-0.1 + 1.2*Anode + 0.3*W1 + 0.3*W2),
EFU=TRUE)
D_WAY &lt;- set.DAG(D)

# Defining interventions (actions)
# define action "A1" that sets the treatment node to constant 1
D_WAY &lt;- D_WAY + action("A1", nodes=node("Anode",distr="rbern", prob=1))
# define another action "A0" that sets the treatment node to constant 0
D_WAY &lt;- D_WAY + action("A0", nodes=node("Anode",distr="rbern", prob=0))
#---------------------------------------------------------------------------------------
# Defining and calculating causal parameters:
#---------------------------------------------------------------------------------------
# Counterfactual mean of node "Y" under action "A1"
D_WAY &lt;- set.targetE(D_WAY, outcome="Y", param="A1")
eval.target(D_WAY, n=10000)

# Contrasts of means of "Y" under action "A1" minus action "A0"
D_WAY &lt;- set.targetE(D_WAY, outcome="Y", param="A1-A0")
eval.target(D_WAY, n=10000)

# Ratios of "Y" under action "A1" over action "A0"
D_WAY &lt;- set.targetE(D_WAY, outcome="Y", param="A1/A0")
eval.target(D_WAY, n=10000)

# Alternative parameter evaluation by passing already simulated full data to
# \code{eval.target}
X_dat1 &lt;- simfull(A(D_WAY), n=10000)
D_WAY &lt;- set.targetE(D_WAY, outcome="Y", param="A1/A0")
eval.target(D_WAY, data=X_dat1)

#---------------------------------------------------------------------------------------
# EXAMPLE 2: DAG with time-varying outcomes (survival outcome)
#---------------------------------------------------------------------------------------
# Define longitudinal data structure over 6 time-points t=(0:5)
t_end &lt;- 5
D &lt;- DAG.empty()
D &lt;- D + node("L2", t=0, distr="rbern", prob=0.05)
D &lt;- D + node("L1", t=0, distr="rbern", prob=ifelse(L2[0]==1,0.5,0.1))
D &lt;- D + node("A1", t=0, distr="rbern", prob=ifelse(L1[0]==1 &amp; L2[0]==0, 0.5,
ifelse(L1[0]==0 &amp; L2[0]==0, 0.1,
ifelse(L1[0]==1 &amp; L2[0]==1, 0.9, 0.5))))
D &lt;- D + node("A2", t=0, distr="rbern", prob=0, order=4, EFU=TRUE)
D &lt;- D + node("Y",  t=0, distr="rbern",
prob=plogis(-6.5 + L1[0] + 4*L2[0] + 0.05*I(L2[0]==0)),
EFU=TRUE)
D &lt;- D + node("L2", t=1:t_end, distr="rbern", prob=ifelse(A1[t-1]==1, 0.1,
ifelse(L2[t-1]==1, 0.9,
min(1,0.1 + t/16))))
D &lt;- D + node("A1", t=1:t_end, distr="rbern", prob=ifelse(A1[t-1]==1, 1,
ifelse(L1[0]==1 &amp; L2[0]==0, 0.3,
ifelse(L1[0]==0 &amp; L2[0]==0, 0.1,
ifelse(L1[0]==1 &amp; L2[0]==1, 0.7,
0.5)))))
D &lt;- D + node("A2", t=1:t_end, distr="rbern", prob=0, EFU=TRUE)
D &lt;- D + node("Y",  t=1:t_end, distr="rbern",
prob=plogis(-6.5 + L1[0] + 4*L2[t] + 0.05*sum(I(L2[0:t]==rep(0,(t+1))))),
EFU=TRUE)
D &lt;- set.DAG(D)

# Add two dynamic actions (indexed by values of the parameter theta={0,1})
# Define intervention nodes
act_t0_theta &lt;- node("A1",t=0, distr="rbern", prob=ifelse(L2[0] &gt;= theta,1,0))
act_tp_theta &lt;- node("A1",t=1:t_end, distr="rbern",
prob=ifelse(A1[t-1]==1,1,ifelse(L2[t] &gt;= theta,1,0)))
# Add two actions to current DAG object
D &lt;- D + action("A1_th0", nodes=c(act_t0_theta, act_tp_theta), theta=0)
D &lt;- D + action("A1_th1", nodes=c(act_t0_theta, act_tp_theta), theta=1)
#---------------------------------------------------------------------------------------
# Defining and calculating the target parameter
#---------------------------------------------------------------------------------------
# Counterfactual mean of node "Y" at time-point t=4 under action "A1_th0"
D &lt;- set.targetE(D, outcome="Y", t=4, param="A1_th0")
eval.target(D, n=5000)

# Vector of counterfactual means of"Y" over all time points under action "A1_th1"
D &lt;- set.targetE(D, outcome="Y", t=0:5, param="A1_th1")
eval.target(D, n=5000)

# Vector of counterfactual contrasts of "Y" over all time points
# for action "A1_th1" minus action "A1_th0"
D &lt;- set.targetE(D, outcome="Y", t=0:5, param="A1_th1 - A1_th0")
eval.target(D, n=5000)

# Vector of counterfactual ratios of "Y" over all time points
# for action "A1_th0" over action "A1_th1"
D &lt;- set.targetE(D, outcome="Y", t=0:5, param="A1_th0 / A1_th1")
eval.target(D, n=5000)
</code></pre>

<hr>
<h2 id='set.targetMSM'>Define Causal Parameters with a Working Marginal Structural Model (MSM)</h2><span id='topic+set.targetMSM'></span>

<h3>Description</h3>

<p>Set up the MSM causal target parameter for the current DAG object. These settings can be later used to evaluate the true value of the MSM parameter on the full (counterfactual) data by calling <code>eval.target</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.targetMSM(
  DAG,
  outcome,
  t,
  formula,
  family = "quasibinomial",
  hazard,
  ...,
  attr = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.targetMSM_+3A_dag">DAG</code></td>
<td>
<p>Object specifying the directed acyclic graph (DAG) for the observed data</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_outcome">outcome</code></td>
<td>
<p>Name of the outcome node</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_t">t</code></td>
<td>
<p>Vector of time points which are used for pooling the <code>outcome</code></p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_formula">formula</code></td>
<td>
<p>MSM formula for modeling pooled outcome on the full data with glm regression. Left hand side should be equal to the <code>outcome</code>, right hand side can include baseline covariates, action-specific attribute names and time-dependent treatment summary measures. See Details.</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_family">family</code></td>
<td>
<p>Model family to use in the <code>glm</code> regression</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_hazard">hazard</code></td>
<td>
<p>When TRUE MSM fits the discrete hazard function for survival <code>outcome</code> (if outcome node had <code>EOF=TRUE</code> attribute)</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_...">...</code></td>
<td>
<p>Additional attributes (to be used in future versions)</p>
</td></tr>
<tr><td><code id="set.targetMSM_+3A_attr">attr</code></td>
<td>
<p>Additional attributes (to be used in future versions)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enclosing an MSM formula term inside S(), e.g., S(mean(A[0:t])), forces this term to be evaluated as a summary measure of time-indexed nodes in the full data environment. All such MSM terms are parsed and then evaluated inside the previously simulated full data environment, each S() term is then replaced with a vector name 'XMSMterms.i' that is a result of this evaluation.
</p>


<h3>Value</h3>

<p>A modified DAG object with well-defined target parameter saved as part of the DAG, this DAG can now be passed as an argument to <code>eval.target</code> function for actual Monte-Carlo evaluation of the target parameter. See Examples.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---------------------------------------------------------------------------------------
# DAG with time-varying outcomes (survival outcome)
#---------------------------------------------------------------------------------------
# Define longitudinal data structure over 6 time-points t=(0:5)
t_end &lt;- 5
D &lt;- DAG.empty()
D &lt;- D + node("L2", t=0, distr="rbern", prob=0.05)
D &lt;- D + node("L1", t=0, distr="rbern", prob=ifelse(L2[0]==1,0.5,0.1))
D &lt;- D + node("A1", t=0, distr="rbern", prob=ifelse(L1[0]==1 &amp; L2[0]==0, 0.5,
ifelse(L1[0]==0 &amp; L2[0]==0, 0.1,
ifelse(L1[0]==1 &amp; L2[0]==1, 0.9, 0.5))))
D &lt;- D + node("A2", t=0, distr="rbern", prob=0, order=4, EFU=TRUE)
D &lt;- D + node("Y",  t=0, distr="rbern",
prob=plogis(-6.5 + L1[0] + 4*L2[0] + 0.05*I(L2[0]==0)),
EFU=TRUE)
D &lt;- D + node("L2", t=1:t_end, distr="rbern", prob=ifelse(A1[t-1]==1, 0.1,
ifelse(L2[t-1]==1, 0.9,
min(1,0.1 + t/16))))
D &lt;- D + node("A1", t=1:t_end, distr="rbern", prob=ifelse(A1[t-1]==1, 1,
ifelse(L1[0]==1 &amp; L2[0]==0, 0.3,
ifelse(L1[0]==0 &amp; L2[0]==0, 0.1,
ifelse(L1[0]==1 &amp; L2[0]==1, 0.7,
0.5)))))
D &lt;- D + node("A2", t=1:t_end, distr="rbern", prob=0, EFU=TRUE)
D &lt;- D + node( "Y",  t=1:t_end, distr="rbern",
prob=plogis(-6.5 + L1[0] + 4*L2[t] + 0.05*sum(I(L2[0:t]==rep(0,(t+1))))),
EFU=TRUE)
D &lt;- set.DAG(D)

# Add two dynamic actions (indexed by values of the parameter theta={0,1})
# Define intervention nodes
act_t0_theta &lt;- node("A1",t=0, distr="rbern", prob=ifelse(L2[0] &gt;= theta,1,0))
act_tp_theta &lt;- node("A1",t=1:t_end, distr="rbern",
prob=ifelse(A1[t-1]==1,1,ifelse(L2[t] &gt;= theta,1,0)))
# Add two actions to current DAG object
D &lt;- D + action("A1_th0", nodes=c(act_t0_theta, act_tp_theta), theta=0)
D &lt;- D + action("A1_th1", nodes=c(act_t0_theta, act_tp_theta), theta=1)

#---------------------------------------------------------------------------------------
# MSM EXAMPLE 1: Modeling survival over time
#---------------------------------------------------------------------------------------
# Modeling pooled survival Y_t over time as a projection on the following working
# logistic model:
msm.form &lt;- "Y ~ theta + t + I(theta*t)"
D &lt;- set.targetMSM(D, outcome="Y", t=0:5, formula=msm.form, family="binomial",
hazard=FALSE)
MSMres &lt;- eval.target(D, n=1000)
MSMres$coef

#---------------------------------------------------------------------------------------
# MSM EXAMPLE 2: Modeling survival over time with exposure-based summary measures
#---------------------------------------------------------------------------------------
# Now we want to model Y_t by adding a summary measure covariate defined as mean
# exposure A1 from time 0 to t;
# Enclosing any term inside S() forces its evaluation in the environment
# of the full (counterfactual) data.
msm.form_sum &lt;- "Y ~ theta + t + I(theta*t) + S(mean(A1[0:t]))"
D &lt;- set.targetMSM(D, outcome="Y", t=0:5, formula=msm.form_sum, family="binomial",
hazard=FALSE)
MSMres &lt;- eval.target(D, n=1000)
MSMres$coef
</code></pre>

<hr>
<h2 id='sim'>Simulate Observed or Full Data from <code>DAG</code> Object</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>This function simulates full data based on a list of intervention DAGs, returning a list of <code>data.frame</code>s. See the vignette for examples and detailed description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(
  DAG,
  actions,
  n,
  wide = TRUE,
  LTCF = NULL,
  rndseed = NULL,
  rndseed.reset.node = NULL,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_dag">DAG</code></td>
<td>
<p>A DAG objects that has been locked with set.DAG(DAG). Observed data from this DAG will be simulated if actions argument is omitted.</p>
</td></tr>
<tr><td><code id="sim_+3A_actions">actions</code></td>
<td>
<p>Character vector of action names which will be extracted from the DAG object. Alternatively, this can be a list of action DAGs selected with <code>A(DAG)</code> function, in which case the argument <code>DAG</code> is unused. When <code>actions</code> is omitted, the function returns simulated observed data (see <code>simobs</code>).</p>
</td></tr>
<tr><td><code id="sim_+3A_n">n</code></td>
<td>
<p>Number of observations to sample.</p>
</td></tr>
<tr><td><code id="sim_+3A_wide">wide</code></td>
<td>
<p>A logical, if TRUE the output data is generated in wide format, if FALSE, the output longitudinal data in generated in long format</p>
</td></tr>
<tr><td><code id="sim_+3A_ltcf">LTCF</code></td>
<td>
<p>If forward imputation is desired for the missing variable values, this argument should be set to the name of the node that indicates the end of follow-up event.</p>
</td></tr>
<tr><td><code id="sim_+3A_rndseed">rndseed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="sim_+3A_rndseed.reset.node">rndseed.reset.node</code></td>
<td>
<p>When <code>rndseed</code> is specified, use this argument to specify the name of the <code>DAG</code> node at which the random number generator seed is reset back to <code>NULL</code> (simulation function will call <code>set.seed(NULL)</code>).
Can be useful if one wishes to simulate data using the set seed <code>rndseed</code> only for the first K nodes of the DAG and use an entirely random sample when simulating the rest of the nodes starting at K+1 and on.
The name of such (K+1)th order <code>DAG</code> node should be then specified with this argument.</p>
</td></tr>
<tr><td><code id="sim_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console.
Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If actions argument is missing a simulated data.frame is returned, otherwise the function returns a named list of action-specific simulated data.frames with action names giving names to corresponding list items.
</p>


<h3>Forward Imputation</h3>

<p>By default, when LTCF is left unspecified, all variables that follow after any end of follow-up (EFU) event are set to missing (NA).
The end of follow-up event occurs when a binary node of type <code>EFU=TRUE</code> is equal to 1, indicating a failing or right-censoring event.
To forward impute the values of the time-varying nodes after the occurrence of the <code>EFU</code> event, set the LTCF argument to a name of the EFU node representing this event.
For additional details and examples see the vignette and <code><a href="#topic+doLTCF">doLTCF</a></code> function.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simobs">simobs</a></code> - a wrapper function for simulating observed data only; <code><a href="#topic+simfull">simfull</a></code> - a wrapper function for simulating full data only; <code><a href="#topic+doLTCF">doLTCF</a></code> - forward imputation of the missing values in already simulating data; <code><a href="#topic+DF.to.long">DF.to.long</a></code>, <code><a href="#topic+DF.to.longDT">DF.to.longDT</a></code> - converting longitudinal data from wide to long formats.
</p>
<p>Other simulation functions: 
<code><a href="#topic+simfull">simfull</a>()</code>,
<code><a href="#topic+simobs">simobs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_end &lt;- 10
lDAG &lt;- DAG.empty()
lDAG &lt;- lDAG +
	node(name = "L2", t = 0, distr = "rconst", const = 0) +
	node(name = "A1", t = 0, distr = "rconst", const = 0) +
	node(name = "L2", t = 1:t_end, distr = "rbern",
 	prob = ifelse(A1[t - 1]  ==  1, 0.1,
 			ifelse(L2[t-1] == 1, 0.9,
        min(1,0.1 + t/t_end)))) +
	node(name = "A1", t = 1:t_end, distr = "rbern",
 	prob = ifelse(A1[t - 1]  ==  1, 1,
 			 ifelse(L2[0] == 0, 0.3,
			  ifelse(L2[0] == 0, 0.1,
			   ifelse(L2[0] == 1, 0.7, 0.5))))) +
	node(name = "Y", t = 1:t_end, distr = "rbern",
 	prob = plogis(-6.5 + 4 * L2[t] + 0.05 * sum(I(L2[0:t] == rep(0,(t + 1))))),
 	EFU = TRUE)
lDAG &lt;- set.DAG(lDAG)
#---------------------------------------------------------------------------------------
# EXAMPLE 1. No forward imputation.
#---------------------------------------------------------------------------------------
Odat.wide &lt;- sim(DAG = lDAG, n = 1000, rndseed = 123)
Odat.wide[c(21,47), 1:18]
Odat.wideLTCF &lt;- sim(DAG = lDAG, n = 1000, LTCF = "Y", rndseed = 123)
Odat.wideLTCF[c(21,47), 1:18]
#---------------------------------------------------------------------------------------
# EXAMPLE 2. With forward imputation.
#---------------------------------------------------------------------------------------
Odat.wideLTCF2 &lt;- doLTCF(data = Odat.wide, LTCF = "Y")
Odat.wideLTCF2[c(21,47), 1:18]
# all.equal(Odat.wideLTCF, Odat.wideLTCF2)
</code></pre>

<hr>
<h2 id='simcausal'>Simulating Longitudinal Data with Causal Inference Applications</h2><span id='topic+simcausal'></span>

<h3>Description</h3>

<p>The <span class="pkg">simcausal</span> R package is a tool for specification and simulation of complex longitudinal data structures that are
based on structural equation models. The package provides a flexible tool for conducting transparent and reproducible
simulation studies, with a particular emphasis on the types of data and interventions frequently encountered in typical
causal inference problems, such as, observational data with time-dependent confounding, selection bias, and random monitoring processes.
The package interface allows for concise expression of complex functional dependencies between a large number of nodes,
where each node may represent a time-varying random variable.
The package allows for specification and simulation of counterfactual data under various user-specified interventions
(e.g., static, dynamic, deterministic, or stochastic).
In particular, the interventions may represent exposures to treatment regimens, the occurrence or non-occurrence of right-censoring
events, or of clinical monitoring events. <span class="pkg">simcausal</span> enables the computation of a selected set of user-specified
features of the distribution of the counterfactual data that represent common causal quantities of interest,
such as, treatment-specific means, the average treatment effects and coefficients from working marginal structural models.
For additional details and examples please see the package vignette and the function-specific documentation.
</p>


<h3>Documentation</h3>


<ul>
<li><p> To see the package vignette use: <code>vignette("simcausal_vignette", package="simcausal")</code>
</p>
</li>
<li><p> To see all available package documentation use: <code>help(package = 'simcausal')</code>
</p>
</li></ul>



<h3>Routines</h3>

<p>The following routines will be generally invoked by a user, in the same order as presented below.
</p>

<dl>
<dt><code><a href="#topic+DAG.empty">DAG.empty</a></code></dt><dd><p>Initiates an empty <code>DAG</code> object that contains no nodes.</p>
</dd>
<dt><code><a href="#topic+node">node</a></code></dt><dd><p>Defines node(s) in the structural equation model and its conditional distribution(s) using a language of vector-like R expressions. A call to <code>node</code> can specify either a single node or multiple nodes at once.</p>
</dd>
<dt><code><a href="#topic+add.nodes">add.nodes</a></code> or <code>+<a href="#topic+node">node</a></code></dt><dd><p>Provide two equivalent ways of growing the structural equation model by adding new nodes and their conditional distributions.
Sequentially define nodes in the <code>DAG</code> object, with each node representing the outcomes of one or more structural equation(s), altogether making-up the causal model of interest.</p>
</dd>
<dt><code><a href="#topic+set.DAG">set.DAG</a></code></dt><dd><p>Performs consistency checks and locks the <code>DAG</code> object so that no additional nodes can be subsequently added to the structural equation model.</p>
</dd>
<dt><code><a href="#topic+sim">sim</a></code> or <code><a href="#topic+simobs">simobs</a></code></dt><dd><p>Simulates iid observations of the complete node sequence defined by the <code>DAG</code> object. The output dataset is stored as a <code>data.frame</code> and is referred to as the <em>observed data</em>.</p>
</dd>
<dt><code><a href="#topic+add.action">add.action</a></code> or <code>+<a href="#topic+action">action</a></code></dt><dd><p>Provide two equivalent ways to define one or more actions.
Each action modifies the conditional distribution for a subset of nodes in the original <code>DAG</code> object. The resulting data generating distribution is referred to as the post-intervention distribution.
It is saved in the <code>DAG</code> object alongside the original structural equation model (<code>DAG</code> object).</p>
</dd>
<dt><code><a href="#topic+sim">sim</a></code> or <code><a href="#topic+simfull">simfull</a></code></dt><dd><p>Simulates independent observations from one or more post-intervention distribution(s).
Produces a named list of <code>data.frame</code>s, collectively referred to as the <em>full data</em>.
The number of output <code>data.frame</code>s is equal to the number of post-intervention distributions specified in the <code>actions</code> argument, where each <code>data.frame</code> object is an iid sample from a particular post-intervention distribution.</p>
</dd>
<dt><code><a href="#topic+set.targetE">set.targetE</a></code> and <code><a href="#topic+set.targetMSM">set.targetMSM</a></code></dt><dd><p>Define two distinct types of target causal parameters.
The function <code>set.targetE</code> defines causal parameters as the expected value(s) of <code>DAG</code> node(s) under one post-intervention distribution or the contrast of such expected value(s) from two post-intervention distributions.
The function <code>set.targetMSM</code> defines causal parameters based on a user-specified <b>working</b> marginal structural model.</p>
</dd>
<dt><code><a href="#topic+eval.target">eval.target</a></code></dt><dd><p>Evaluates the previously defined causal parameter using simulated full data</p>
</dd>
</dl>



<h3>Data structures</h3>

<p>The following most common types of output are produced by the package:
</p>

<ul>
<li> <p><em>parameterized causal <code>DAG</code> model</em> - object that specifies the structural equation model, along with interventions and the causal target parameter of interest.
</p>
</li>
<li> <p><em>observed data</em> - data simulated from the (pre-intervention) distribution specified by the structural equation model.
</p>
</li>
<li> <p><em>full data</em> - data simulated from one or more post-intervention distributions defined by actions on the structural equation model.
</p>
</li>
<li> <p><em>causal target parameter</em> - the true value of the causal target parameter evaluated with full data.
</p>
</li></ul>



<h3>Updates</h3>

<p>Check for updates and report bugs at <a href="https://github.com/osofr/simcausal">https://github.com/osofr/simcausal</a>.
</p>


<h3>References</h3>

<p>Sofrygin O, van der Laan MJ, Neugebauer R (2017).
&quot;simcausal R Package: Conducting Transparent and Reproducible Simulation Studies of Causal Effect Estimation with Complex Longitudinal Data.&quot;
Journal of Statistical Software, 81(2), 1-47. doi: 10.18637/jss.v081.i02.
</p>

<hr>
<h2 id='simfull'>Simulate Full Data (From Action DAG(s))</h2><span id='topic+simfull'></span>

<h3>Description</h3>

<p>This function simulates full data based on a list of intervention DAGs, returning a list of <code>data.frame</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simfull(
  actions,
  n,
  wide = TRUE,
  LTCF = NULL,
  rndseed = NULL,
  rndseed.reset.node = NULL,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simfull_+3A_actions">actions</code></td>
<td>
<p>Actions specifying the counterfactual DAG. This argument must be either an object of class DAG.action or a list of DAG.action objects.</p>
</td></tr>
<tr><td><code id="simfull_+3A_n">n</code></td>
<td>
<p>Number of observations to sample.</p>
</td></tr>
<tr><td><code id="simfull_+3A_wide">wide</code></td>
<td>
<p>A logical, if TRUE the output data is generated in wide format, if FALSE, the output longitudinal data in generated in long format</p>
</td></tr>
<tr><td><code id="simfull_+3A_ltcf">LTCF</code></td>
<td>
<p>If forward imputation is desired for the missing variable values, this argument should be set to the name of the node that indicates the end of follow-up event. See the vignette, <code><a href="#topic+sim">sim</a></code> and <code><a href="#topic+doLTCF">doLTCF</a></code> for additional details.</p>
</td></tr>
<tr><td><code id="simfull_+3A_rndseed">rndseed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="simfull_+3A_rndseed.reset.node">rndseed.reset.node</code></td>
<td>
<p>When <code>rndseed</code> is specified, use this argument to specify the name of the <code>DAG</code> node at which the random number generator seed is reset back to <code>NULL</code> (simulation function will call <code>set.seed(NULL)</code>).
Can be useful if one wishes to simulate data using the set seed <code>rndseed</code> only for the first K nodes of the DAG and use an entirely random sample when simulating the rest of the nodes starting at K+1 and on.
The name of such (K+1)th order <code>DAG</code> node should be then specified with this argument.</p>
</td></tr>
<tr><td><code id="simfull_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console.
Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, each item is a <code>data.frame</code> corresponding to an action specified by the actions argument, action names are used for naming these list items.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simobs">simobs</a></code> - a wrapper function for simulating observed data only; <code><a href="#topic+sim">sim</a></code> - a wrapper function for simulating both types of data; <code><a href="#topic+doLTCF">doLTCF</a></code> for forward imputation of the missing values in already simulating data; <code><a href="#topic+DF.to.long">DF.to.long</a></code>, <code><a href="#topic+DF.to.longDT">DF.to.longDT</a></code> - converting longitudinal data from wide to long formats.
</p>
<p>Other simulation functions: 
<code><a href="#topic+simobs">simobs</a>()</code>,
<code><a href="#topic+sim">sim</a>()</code>
</p>

<hr>
<h2 id='simobs'>Simulate Observed Data</h2><span id='topic+simobs'></span>

<h3>Description</h3>

<p>This function simulates observed data from a DAG object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simobs(
  DAG,
  n,
  wide = TRUE,
  LTCF = NULL,
  rndseed = NULL,
  rndseed.reset.node = NULL,
  verbose = getOption("simcausal.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simobs_+3A_dag">DAG</code></td>
<td>
<p>A DAG objects that has been locked with set.DAG(DAG). Observed data from this DAG will be simulated.</p>
</td></tr>
<tr><td><code id="simobs_+3A_n">n</code></td>
<td>
<p>Number of observations to sample.</p>
</td></tr>
<tr><td><code id="simobs_+3A_wide">wide</code></td>
<td>
<p>A logical, if TRUE the output data is generated in wide format, if FALSE, the output longitudinal data in generated in long format</p>
</td></tr>
<tr><td><code id="simobs_+3A_ltcf">LTCF</code></td>
<td>
<p>If forward imputation is desired for the missing variable values, this argument should be set to the name of the node that indicates the end of follow-up event. See the vignette, <code><a href="#topic+sim">sim</a></code> and <code><a href="#topic+doLTCF">doLTCF</a></code> for additional details.</p>
</td></tr>
<tr><td><code id="simobs_+3A_rndseed">rndseed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="simobs_+3A_rndseed.reset.node">rndseed.reset.node</code></td>
<td>
<p>When <code>rndseed</code> is specified, use this argument to specify the name of the <code>DAG</code> node at which the random number generator seed is reset back to <code>NULL</code> (simulation function will call <code>set.seed(NULL)</code>).
Can be useful if one wishes to simulate data using the set seed <code>rndseed</code> only for the first K nodes of the DAG and use an entirely random sample when simulating the rest of the nodes starting at K+1 and on.
The name of such (K+1)th order <code>DAG</code> node should be then specified with this argument.</p>
</td></tr>
<tr><td><code id="simobs_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print messages on status and information to the console.
Turn this off by default using options(simcausal.verbose=FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> where each column is sampled from the conditional distribution specified by the corresponding <code>DAG</code> object node.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simfull">simfull</a></code> - a wrapper function for simulating full data only; <code><a href="#topic+sim">sim</a></code> - a wrapper function for simulating both types of data; <code><a href="#topic+doLTCF">doLTCF</a></code> for forward imputation of the missing values in already simulating data; <code><a href="#topic+DF.to.long">DF.to.long</a></code>, <code><a href="#topic+DF.to.longDT">DF.to.longDT</a></code> - converting longitudinal data from wide to long formats.
</p>
<p>Other simulation functions: 
<code><a href="#topic+simfull">simfull</a>()</code>,
<code><a href="#topic+sim">sim</a>()</code>
</p>

<hr>
<h2 id='sparseAdjMat.to.igraph'>Convert Network from Sparse Adjacency Matrix into igraph Object</h2><span id='topic+sparseAdjMat.to.igraph'></span>

<h3>Description</h3>

<p>Uses <code>graph_from_adjacency_matrix</code> function from the <code>igraph</code> package to convert the network in sparse adjacency matrix format into <code>igraph</code> network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseAdjMat.to.igraph(sparseAdjMat, mode = "directed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseAdjMat.to.igraph_+3A_sparseadjmat">sparseAdjMat</code></td>
<td>
<p>Network represented as a sparse adjacency matrix (S4 class object <code>dgCMatrix</code> from package <code>Matrix</code>).
NOTE: for directed graphs the friend IDs pointing into vertex <code>i</code> are assumed to be listed in the column <code>i</code>
(i.e, <code>which(sparseAdjMat[,i])</code> are friends of <code>i</code>).</p>
</td></tr>
<tr><td><code id="sparseAdjMat.to.igraph_+3A_mode">mode</code></td>
<td>
<p>Character scalar, passed on to <code>igraph::graph_from_adjacency_matrix</code>, specifies how igraph should interpret the supplied matrix.
See <code>?igraph::graph_from_adjacency_matrix</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the network object(s) of type <code>DAG.net</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>; <code><a href="#topic+igraph.to.sparseAdjMat">igraph.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.NetInd">sparseAdjMat.to.NetInd</a></code>; <code><a href="#topic+NetInd.to.sparseAdjMat">NetInd.to.sparseAdjMat</a></code>;
</p>

<hr>
<h2 id='sparseAdjMat.to.NetInd'>Convert Network from Sparse Adjacency Matrix into Network IDs Matrix</h2><span id='topic+sparseAdjMat.to.NetInd'></span>

<h3>Description</h3>

<p>Convert network represented by a sparse adjacency matrix into <code>simcausal</code> network IDs matrix (<code>NetInd_k</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseAdjMat.to.NetInd(sparseAdjMat, trimKmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseAdjMat.to.NetInd_+3A_sparseadjmat">sparseAdjMat</code></td>
<td>
<p>Network represented as a sparse adjacency matrix (S4 class object <code>dgCMatrix</code> from package <code>Matrix</code>).
NOTE: The friends (row numbers) of observation <code>i</code> are assumed to be listed in column <code>i</code>
(i.e, <code>which(sparseAdjMat[,i])</code> are friends of <code>i</code>).</p>
</td></tr>
<tr><td><code id="sparseAdjMat.to.NetInd_+3A_trimkmax">trimKmax</code></td>
<td>
<p>Trim the maximum number of friends to this integer value. If this argument is not missing,
the conversion network matrix obtained from <code>sparseAdjMat</code> will be trimmed, so that each observation has at most <code>trimKmax</code> friends.
The trimming initiates from the last column of the network ID matrix, removing columns until only <code>trimKmax</code> columns are left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with 3 items: 1) <code>NetInd_k</code>; 2) <code>nF</code>; and 3) <code>Kmax</code>.
1) <code>NetInd_k</code> - matrix of network IDs of dimension <code>(n=nrow(sparseAdjMat),Kmax)</code>, where each row <code>i</code> consists of the network IDs (friends) for observation <code>i</code>.
Remainders are filled with NAs.
2) <code>nF</code> - integer vector of length <code>n</code> specifying the number of friends for each observation.
3) <code>Kmax</code> - integer constant specifying the maximum observed number of friends in input <code>sparseAdjMat</code> (this is the column dimension for the output matrix <code>NetInd_k</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network">network</a></code>; <code><a href="#topic+NetInd.to.sparseAdjMat">NetInd.to.sparseAdjMat</a></code>; <code><a href="#topic+sparseAdjMat.to.igraph">sparseAdjMat.to.igraph</a></code>; <code><a href="#topic+igraph.to.sparseAdjMat">igraph.to.sparseAdjMat</a></code>;
</p>

<hr>
<h2 id='vecfun.add'>Add Custom Vectorized Functions</h2><span id='topic+vecfun.add'></span>

<h3>Description</h3>

<p>Add user-defined function names to a global list of custom vectorized functions.
The functions in <code>vecfun_names</code> are intended for use inside the node formulas.
Adding functions to this list will generally greatly expedite the simulation run time.
Any node formula calling a function on this list will be evaluated &quot;as is&quot;, the function should
be written to accept arguments as either vectors of length <code>n</code> or as matrices with <code>n</code> rows.
Adding function to this list will effects simulation from all DAG objects that call this function. See vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecfun.add(vecfun_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecfun.add_+3A_vecfun_names">vecfun_names</code></td>
<td>
<p>A character vector of function names that will be treated as &quot;vectorized&quot; by the node formula R parser</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An old vector of user-defined vectorized function names
</p>

<hr>
<h2 id='vecfun.all.print'>Print Names of All Vectorized Functions</h2><span id='topic+vecfun.all.print'></span>

<h3>Description</h3>

<p>Print all vectorized function names (build-in and user-defined).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecfun.all.print()
</code></pre>


<h3>Value</h3>

<p>A vector of build-in and user-defined vectorized function names
</p>

<hr>
<h2 id='vecfun.print'>Print Names of Custom Vectorized Functions</h2><span id='topic+vecfun.print'></span>

<h3>Description</h3>

<p>Print current user-defined vectorized function names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecfun.print()
</code></pre>


<h3>Value</h3>

<p>A vector of vectorized function names
</p>

<hr>
<h2 id='vecfun.remove'>Remove Custom Vectorized Functions</h2><span id='topic+vecfun.remove'></span>

<h3>Description</h3>

<p>Remove user-defined function names from a global list of custom vectorized functions. See vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecfun.remove(vecfun_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecfun.remove_+3A_vecfun_names">vecfun_names</code></td>
<td>
<p>A character vector of function names that will be removed from the custom list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An old vector of user-defined vectorized function names
</p>

<hr>
<h2 id='vecfun.reset'>Reset Custom Vectorized Function List</h2><span id='topic+vecfun.reset'></span>

<h3>Description</h3>

<p>Reset a listing of user-defined vectorized functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecfun.reset()
</code></pre>


<h3>Value</h3>

<p>An old vector of user-defined vectorized function names
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
