<!DOCTYPE html><html><head><title>Help for package cycloids</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cycloids}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cycloids-package'>
<p>Calculating coordinate representations of hypocycloids, epicyloids,</p>
hypotrochoids, and epitrochoids</a></li>
<li><a href='#ggT'>
<p>Calculates the greatest common divisor of two natural numbers a</p>
and b based on the Euclidean Algorithm</a></li>
<li><a href='#kgV'>
<p>Calculates the least common multiple of two natural numbers a and b</p></a></li>
<li><a href='#npeaks'>
<p>Calculates the number of a cycloid's peaks based on the radii A</p>
(fixed circle) and a (moving circle)</a></li>
<li><a href='#zykloid'>
<p>Core function for calculating coordinate representations of</p>
hypocycloids, epicyloids, hypotrochoids, and epitrochoids
(altogether called 'cycloids' here)</a></li>
<li><a href='#zykloid.scaleA'>
<p>Wrapper for <code>zykloid</code> which allows to scale and position</p>
a cycloid by the radius A of the fixed circle and its midpoint</a></li>
<li><a href='#zykloid.scaleAa'>
<p>Wrapper for <code>zykloid</code> which scales a cycloid by its</p>
outer radius and allows free positioning</a></li>
<li><a href='#zykloid.scaleP'>
<p>Wrapper for <code>zykloid</code> which scales a cycloid by the</p>
circle its peaks are located on and allows free positioning</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Calculating Hypocycloids, Epicycloids, Hypotrochoids,
and Epitrochoids</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Biber</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Biber &lt;castor.fiber@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for calculating coordinate representations of
    hypocycloids, epicyloids, hypotrochoids, and epitrochoids
    (altogether called 'cycloids' here) with different scaling
    and positioning options. The cycloids can be visualised with
    any appropriate graphics function in R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'ZFunktionen.r'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 10:05:30 UTC; casto</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cycloids-package'>
Calculating coordinate representations of hypocycloids, epicyloids,
hypotrochoids, and epitrochoids
</h2><span id='topic+cycloids-package'></span><span id='topic+cycloids'></span>

<h3>Description</h3>

<p>Functions for calculating coordinate representations of hypocycloids,
epicyloids, hypotrochoids, and epitrochoids (altogether called
'cycloids' here) with different scaling and positioning options.
The cycloids can be visualised with any appropriate graphics
function in R.
</p>


<h3>Details</h3>

<p>This package has been written for calculating cartesian coordinate
representations of hypocycloids, epicyloids, hypotrochoids, and
epitrochoids (altogether called 'cycloids' here). These can be
easily visualized with any R graphic routine that
handles two-dimensional data. All examples shown here use
standard R graphics. While there are technical applications, the
main purpose of this package is to create mathematical artwork.
<br />
Geometrically, cycloids in the sense of this package are generated as
follows (Figure 1, 2): Imagine a circle <code class="reqn">cfix</code>, with radius
<code class="reqn">A</code>, which is fixed on a plane. Another circle, <code class="reqn">cmov</code>,
with radius <code class="reqn">a</code>, is rolling along <code class="reqn">cfix</code>'s circumference
at the outside of <code class="reqn">cfix</code>. The figure created by the trace of
a point on <code class="reqn">cmov</code>'s circumference is called an epicycloid (Figure 1A).
If <code class="reqn">cmov</code> is rolling not at the outside but at the inside of
<code class="reqn">cfix</code>, the trace of a point on <code class="reqn">cmov</code>'s circumference
is called a hypocycloid (Figure 2A).
<br />
If in both cases the tracepoint is not located on
<code class="reqn">cmov</code>'s circumference but at a fixed distance from its midpoint
either in- or outside cmov, the resulting figure is an epitrochoid (Figure 1B, C)
or a hypotrochoid (Figure 2B, C), respectively. Hypotrochoids and epitrochoids
became quite popular through toys like the spirograph.
<br />
The most important functions of the package are
<code><a href="#topic+zykloid">zykloid</a></code>, <code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>,
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>, and <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>.
<br />
<img src="../help/figures/Figure1.png" width="500" height="500" alt="Figure1.png" />

<img src="../help/figures/Figure2.png" width="500" height="500" alt="Figure2.png" />

</p>


<h3>Note</h3>

<p>Type <code>demo(cycloids)</code> for seeing some examples.
</p>


<h3>Author(s)</h3>

<p>Peter Biber<br />
Maintainer: Peter Biber &lt;castor.fiber@gmx.de&gt;
</p>


<h3>References</h3>

<p>Bronstein IN, Semendjaev KA, Musiol G, Muehlig H (2001): Taschenbuch der
Mathematik, 5th Edition, Verlag Harri Deutsch, 1186 p. (103 &ndash; 105)<br />
<br />
http://en.wikipedia.org/wiki/Epicycloid<br />
<br />
http://en.wikipedia.org/wiki/Hypocycloid<br />
<br />
http://en.wikipedia.org/wiki/Epitrochoid<br />
<br />
http://en.wikipedia.org/wiki/Hypotrochoid<br />
<br />
http://en.wikipedia.org/wiki/Spirograph<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zykloid">zykloid</a></code>, <code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>,
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>, <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(cycloids)

# Create and plot a hypocycloid, a hypotrochoid, an epicycloid,
# and an epitrochoid, all of them with radii A = 5 and a = 3
npeaks(5, 3)  # The cycloids will have five peaks
# The hypocycloid
cyc &lt;- zykloid(A = 5, a = 3, lambda = 1, hypo = TRUE)
plot(y ~ x, data = cyc, type = "l", asp = 1, xlim = c(-12, 12),
     ylim = c(-12, 12), main = "A = 5, a = 3")
# The hypotrochoid
cyc &lt;- zykloid(A = 5, a = 3, lambda = 1/2, hypo = TRUE)
lines(y ~ x, data = cyc, type = "l", asp = 1, col = "green")
# The epicycloid
cyc &lt;- zykloid(A = 5, a = 3, lambda = 1, hypo = FALSE)
lines(y ~ x, data = cyc, type = "l", col = "red")
# The epitrochoid
cyc &lt;- zykloid(A = 5, a = 3, lambda = 1/2, hypo = FALSE)
lines(y ~ x, data = cyc, type = "l", col = "blue")
legend("topleft", c("hypocycloid", "hypotrochoid", "epicycloid",
       "epitrochoid"), lty = rep("solid", 4),
       col = c("black", "green", "red", "blue"), bty = "n")



# Same Framework, different shape: A = 17, a = 5
npeaks(17, 5)  # The cycloids will have seventeen peaks
# The hypocycloid
cyc &lt;- zykloid(A = 17, a = 5, lambda = 1, hypo = TRUE)
plot(y ~ x, data = cyc, type = "l", asp = 1, xlim = c(-27, 27),
     ylim = c(-27, 27), main = "A = 17, a = 5")
# The hypotrochoid
cyc &lt;- zykloid(A = 17, a = 5, lambda = 1/2, hypo = TRUE)
lines(y ~ x, data = cyc, type = "l", asp = 1, col = "green")
# The epicycloid
cyc &lt;- zykloid(A = 17, a = 5, lambda = 1, hypo = FALSE)
lines(y ~ x, data = cyc, type = "l", col = "red")
# The epitrochoid
cyc &lt;- zykloid(A = 17, a = 5, lambda = 1/2, hypo = FALSE)
lines(y ~ x, data = cyc, type = "l", col = "blue")
legend("topleft", c("hypocycloid", "hypotrochoid", "epicycloid",
       "epitrochoid"), lty = rep("solid", 4),
       col = c("black", "green", "red", "blue"), bty = "n")



# Pretty - a classic Spirograph pattern with the same settings 
# for A (5) and a (3) as in the first example.
# Varying parameters (here: lambda) within a loop often gives
# nice results.
op &lt;- par(mar = c(0,0,0,0)) # no plot margins
lambdax &lt;- seq(0.85, by = -0.05, length.out = 14)
ccol &lt;- rep(c("blue", "blue", "red", "red"), 4)
plot.new()
plot.window(asp = 1, xlim = c(-4.5, 4.5), ylim = c(-4.5, 4.5))
# draw fourteen hypotrochoids with decreasing lambda
for (i in c(1:14)) {
     z &lt;- zykloid(5, 3, lambdax[i])     
     lines(y ~ x, data = z, type = "l", col = ccol[i])
} # for i
par(op) # set graphics parameters back to original values



# A bit more of the same kind to get the big picture...
op &lt;- par(mar = c(0,0,0,0)) # no plot margins
lambdax &lt;- seq(1, by = -0.05, length.out = 16)
ccol &lt;- rep(c("blue", "blue", "red", "red"), 4)
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
# first loop: sixteen epitrochoids with decreasing lambda
for (i in 1:16) {
     z &lt;- zykloid(5, 3, lambdax[i], hypo = FALSE) 
     lines(y ~ x, data = z, type = "l", col = ccol[i])
} # for i - first loop
# first loop: sixteen epitrochoids with decreasing lambda
for (i in 1:16) {
     z &lt;- zykloid(5, 3, lambdax[i], hypo = TRUE)     
     lines(y ~ x, data = z, type = "l", col = ccol[i])
} # for i - second loop
par(op) # set graphics parameters back to original values



# Show off with an example for zykloid.scaleP
#    No plot margins, and ... paint it black
op &lt;- par(mar = c(0,0,0,0), bg = "black")
lambdax &lt;- seq(2, 0.0, -0.05) # Note: some lambdas are greater than 1
ccol &lt;- rep(c("lightblue", "lightblue", "yellow", "yellow", "yellow"), 9)
plot.new()
plot.window(asp = 1, xlim = c(-1, 1), ylim = c(-1, 1))
for (ll in c(1:length(lambdax))) {
     z &lt;- zykloid.scaleP(A = 7, a = 5, hypo = TRUE, lambda = lambdax[ll]) 
     lines(y ~ x, data = z, col = ccol[ll])
} # for ll
par(op) # set graphics parameters back to original values



# Spiky Flower with zykloid.scaleA and zykloid
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-150, 150), ylim = c(-150, 150))
z &lt;- zykloid.scaleA(A = 90, a = 32, lambda = 1, Radius = 150, hypo = TRUE)
lines(y ~ x, data = z, col = "lightblue")
for (ll in seq(2, 0.8, -0.4)) {
     if (ll == 2) ccol &lt;- "royalblue"
     else         ccol &lt;- "plum"
     z &lt;- zykloid(A = 90, a = 32, lambda = ll, hypo = TRUE, steps = 360, start = pi/2)
     lines(y ~ x, data = z, col = ccol)
} # for ll
par(op)



</code></pre>

<hr>
<h2 id='ggT'>
Calculates the greatest common divisor of two natural numbers a
and b based on the Euclidean Algorithm
</h2><span id='topic+ggT'></span>

<h3>Description</h3>

<p>The function ggT calculates the greatest common divisor of two
natural numbers. In this package it is called by the function
<code><a href="#topic+kgV">kgV</a></code> which calculates the least common multiple of
two natural numbers. The latter is needed by the function
<code><a href="#topic+zykloid">zykloid</a></code> and by the function <code><a href="#topic+npeaks">npeaks</a></code>
which calculates the number of peaks (or loops) a cycloid has.
As the greatest common divisor might be useful for other
purposes, the function ggT is accessible to external use in this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggT(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggT_+3A_a">a</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
<tr><td><code id="ggT_+3A_b">b</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A natural number if <code class="reqn">a</code> and <code class="reqn">b</code> are natural numbers. In any other
case, the function returns NA.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>References</h3>

<p>Bronstein IN, Semendjaev KA, Musiol G, Muehlig H (2001): Taschenbuch der
Mathematik, 5th Edition, Verlag Harri Deutsch, 1186 p. (p. 333)<br />
<br />
http://en.wikipedia.org/wiki/Euclidean_algorithm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kgV">kgV</a></code>, <code><a href="#topic+npeaks">npeaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ggT(18, 6)        # 6
ggT(38, 105)      # 1
ggT(36, 9)        # 9
ggT(12, 9)        # 3
ggT(9, 12)        # 3
ggT(-5, 12)       # NA - only integer numbers &gt; 0 allowed
ggT(3, 0)         # NA - only integer numbers &gt; 0 allowed
ggT(3.2, 12)      # NA - only integer numbers &gt; 0 allowed

</code></pre>

<hr>
<h2 id='kgV'>
Calculates the least common multiple of two natural numbers a and b
</h2><span id='topic+kgV'></span>

<h3>Description</h3>

<p>The function kgV calculates the least common multiple of two natural
numbers. In this package it is used by the function <code><a href="#topic+zykloid">zykloid</a></code>
and by the function <code><a href="#topic+npeaks">npeaks</a></code> which calculates the
number of peaks (or loops) a cycloid has. As it might be useful
for other purposes, it is externally available in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kgV(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kgV_+3A_a">a</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
<tr><td><code id="kgV_+3A_b">b</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A natural number if <code class="reqn">a</code> and <code class="reqn">b</code> are natural numbers. In any other
case, the function returns NA.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>References</h3>

<p>Bronstein IN, Semendjaev KA, Musiol G, Muehlig H (2001): Taschenbuch der
Mathematik, 5th Edition, Verlag Harri Deutsch, 1186 p. (p. 334)<br />
<br />
http://en.wikipedia.org/wiki/Least_common_multiple
</p>


<h3>See Also</h3>

<p><code><a href="#topic+npeaks">npeaks</a></code>, <code><a href="#topic+ggT">ggT</a></code>, <code><a href="#topic+zykloid">zykloid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kgV(18, 6)          #   18
kgV(38, 105)        # 3990
kgV(36, 9)          #   36
kgV(12, 9)          #   36
kgV(9, 12)          #   36
kgV(-5, 12)         # NA - only integer numbers &gt; 0 allowed
kgV(3, 0)           # NA - only integer numbers &gt; 0 allowed
kgV(3.2, 12)        # NA - only integer numbers &gt; 0 allowed

</code></pre>

<hr>
<h2 id='npeaks'>
Calculates the number of a cycloid's peaks based on the radii A
(fixed circle) and a (moving circle)
</h2><span id='topic+npeaks'></span>

<h3>Description</h3>

<p>This function may be useful for calculating the number <code class="reqn">n</code> of peaks
a cycloid (<code><a href="#topic+zykloid">zykloid</a></code>) based on the radii <code class="reqn">A</code> (fixed
circle) and <code class="reqn">a</code> (moving circle) will have. The equation for <code class="reqn">n</code> is<br />
<br />
<code class="reqn">n = kgV(A, a)/a</code><br />
<br />
where <code class="reqn">kgV(A, a)</code> is the least common multiple of <code class="reqn">A</code> and <code class="reqn">a</code> as
implemented in the function <code><a href="#topic+kgV">kgV</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npeaks(A, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npeaks_+3A_a">A</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
<tr><td><code id="npeaks_+3A_a">a</code></td>
<td>

<p>A natural number (integer value &gt; 0)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A natural number if <code class="reqn">A</code> and <code class="reqn">a</code> are natural numbers. In any other
case, the function returns NA.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kgV">kgV</a></code>, <code><a href="#topic+ggT">ggT</a></code>, <code><a href="#topic+zykloid">zykloid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
npeaks(18, 6)      #  3
npeaks(38, 105)    # 38
npeaks(36, 9)      #  4
npeaks(12, 9)      #  4
npeaks(9, 12)      #  3
npeaks(-5, 12)     # NA - only integer numbers &gt; 0 allowed
npeaks(3, 0)       # NA - only integer numbers &gt; 0 allowed
npeaks(3.2, 12)    # NA - only integer numbers &gt; 0 allowed

</code></pre>

<hr>
<h2 id='zykloid'>
Core function for calculating coordinate representations of
hypocycloids, epicyloids, hypotrochoids, and epitrochoids
(altogether called 'cycloids' here)
</h2><span id='topic+zykloid'></span>

<h3>Description</h3>

<p>This is the package's core function for calculating cycloids.
These are represented by a set of two-dimensional point
coordinates. Although this function provides the essential
mathematics, you may want to use the wrappers <code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>,
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>, and <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>
due to their convenient scaling and positioning options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zykloid(A, a, lambda, hypo = TRUE, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zykloid_+3A_a">A</code></td>
<td>

<p>The Radius of the fixed circle <code class="reqn">cfix</code>. Must be an integer Number &gt; 0.
</p>
</td></tr>
<tr><td><code id="zykloid_+3A_a">a</code></td>
<td>

<p>The radius of the moving circle <code class="reqn">cmov</code>. Must be an integer Number &gt; 0.
Together with <code class="reqn">A</code>, <code class="reqn">a</code> determines the resulting cycloid's shape and
number of peaks which can be calculated with <code><a href="#topic+npeaks">npeaks</a></code>.
</p>
</td></tr>
<tr><td><code id="zykloid_+3A_lambda">lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (<code class="reqn">cmov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code> means that
the tracepoint is located on <code class="reqn">cmov</code>'s circumference. For <code class="reqn">lambda &lt; 1</code>,
the tracepoint is on <code class="reqn">cmov</code>'s area, e.g. if <code class="reqn">lambda = 0.5</code>, it is
halfway between <code class="reqn">cmov</code>'s centre and its circumference. If <code class="reqn">lambda &gt; 1</code>
the tracepoint is outside <code class="reqn">cmov</code>'s area, you might imagine it
being attached to a rod which is attached to <code class="reqn">cmov</code> and crosses
its centre. E.g. <code class="reqn">lambda = 2</code> would mean that the tracepoint's
distance from cmov's centre equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a
circle because the tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td></tr>
<tr><td><code id="zykloid_+3A_hypo">hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid <code class="reqn">lambda != 1</code>
is generated, as <code class="reqn">cmov</code> is rolling at the outside of <code class="reqn">cfix</code>'s
circumference.
</p>
</td></tr>
<tr><td><code id="zykloid_+3A_steps">steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (<code class="reqn">cmov</code>) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
<code class="reqn">cmov</code>. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td></tr>
<tr><td><code id="zykloid_+3A_start">start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometrically, cycloids in the sense of this package are generated as
follows (Figure 1, 2): Imagine a circle <code class="reqn">cfix</code>, with radius <code class="reqn">A</code>,
which is fixed on a plane. Another circle, <code class="reqn">cmov</code>, with radius
<code class="reqn">a</code>, is rolling along <code class="reqn">cfix</code>'s circumference at the outside
of <code class="reqn">cfix</code>. The figure created by the trace of a point on
<code class="reqn">cmov</code>'s circumference is called an epicycloid (Figure 1A).
If <code class="reqn">cmov</code> is rolling not at the outside but at the inside of
<code class="reqn">cfix</code>, the trace of a point on <code class="reqn">cmov</code>'s circumference
is called an hypocycloid (Figure 2A).
<br />
If in both cases the tracepoint is not located on <code class="reqn">cmov</code>'s
circumference but at a fixed distance from its midpoint
either in- or outside <code class="reqn">cmov</code>, the resulting figure is an
epitrochoid (Figure 1B, C) or a hypotrochoid (Figure 2B, C),
respectively.
<br />
With the arguments of zykloid as defined above, the centre of <code class="reqn">cfix</code>
in the origin, and <code class="reqn">phi</code> being the counterclockwise angle of
<code class="reqn">cmov</code>'s midpoint against the start position with <code class="reqn">cfix</code>'
centre as the pivot, the cartesian coordinates of a point on the
cycloid are calculated as follows:
<br />
<br />
<code class="reqn">x = (A + a) * cos(phi + start) - lambda * a * cos((A + a)/a * phi + start)</code>
<br />
<code class="reqn">y = (A + a) * sin(phi + start) - lambda * a * sin((A + a)/a * phi + start)</code>
<br />
<br />
<img src="../help/figures/Figure1.png" width = "500" height = "500" alt="Figure1.png" />
<img src="../help/figures/Figure2.png" width = "500" height = "500" alt="Figure2.png" />
</p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row
represents a tracepoint position. The positions are ordered along
the trace with the last and the first point being identical in
order to warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>References</h3>

<p>Bronstein IN, Semendjaev KA, Musiol G, Muehlig H (2001): Taschenbuch
der Mathematik, 5th Edition, Verlag Harri Deutsch, 1186 p.
(103 - 105)<br />
<br />
http://en.wikipedia.org/wiki/Epicycloid<br />
<br />
http://en.wikipedia.org/wiki/Hypocycloid<br />
<br />
http://en.wikipedia.org/wiki/Epitrochoid<br />
<br />
http://en.wikipedia.org/wiki/Hypotrochoid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>,
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>, <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Very simple example
cycl &lt;- zykloid(A = 17, a = 9, lambda = 0.9, hypo = TRUE)
plot(y ~ x, data = cycl, asp = 1, type = "l")


# More complex: Looks like a passion flower
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-23, 23), ylim = c(-23, 23))
ll   &lt;- seq(2, 0, -0.2)
ccol &lt;- rep(c("lightblue", "lightgreen", "yellow", "yellow",
              "yellow"), 2)
for (i in c(1:length(ll))) {
     z &lt;- zykloid(A = 15, a = 7, lambda = ll[i], hypo = TRUE)
     lines(y ~ x, data = z, col = ccol[i])
} # for i
par(op)


# Dense hypotrochoids
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5))
m &lt;- zykloid(A = 90, a = 89, lambda = 0.01)
lines(y ~ x, data = m, col = "grey")
m &lt;- zykloid(A = 90, a = 89, lambda = 0.02)
lines(y ~ x, data = m, col = "red")
m &lt;- zykloid(A = 90, a = 89, lambda = 0.015)
lines(y ~ x, data = m, col = "blue")
par(op)


# Fragile star
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-14, 14), ylim = c(-14, 14))
l.max &lt;- 1.6
l.min &lt;- 0.1
ll &lt;- seq(l.max, l.min, by = -1 * (l.max - l.min)/30)
n  &lt;- length(ll)
ccol &lt;- rainbow(n, start = 2/3, end = 1)
for (i in c(1:n)) {
    m &lt;- zykloid(A = 9, a = 8, lambda = ll[i])
    lines(y ~ x, data = m, type = "l", col = ccol[i])
}  # for i
par(op)


</code></pre>

<hr>
<h2 id='zykloid.scaleA'>
Wrapper for <code><a href="#topic+zykloid">zykloid</a></code> which allows to scale and position
a cycloid by the radius A of the fixed circle and its midpoint
</h2><span id='topic+zykloid.scaleA'></span>

<h3>Description</h3>

<p>While <code><a href="#topic+zykloid">zykloid</a></code> provides the basic functionality for
calculating cycloids, this functions allows to re-size a cycloid
by freely setting the radius on the fixed circle. In addition,
the cycloid can be re-positioned by locating the fix circle's
midpoint. See Figures 1 and 2 and <code><a href="#topic+zykloid">zykloid</a></code> for the
geometrical principles of cycloids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zykloid.scaleA(A, a, lambda, hypo = TRUE, Cx = 0, Cy = 0,
               RadiusA = 1, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zykloid.scaleA_+3A_a">A</code></td>
<td>

<p>The Radius of the fixed circle before re-sizing. Must be an integer
Number &gt; 0. Together with <code class="reqn">a</code> (see below), <code class="reqn">A</code> is only
determining the cycloid's shape and number of peaks (see
<code><a href="#topic+npeaks">npeaks</a></code>), while its actual size is defined by the
argument <code class="reqn">RadiusA</code> (see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_a">a</code></td>
<td>

<p>The radius of the moving circle before re-sizing. Must be an
integer Number &gt; 0. Together with <code class="reqn">A</code>, <code class="reqn">a</code> only determines the
cycloid's shape and number of peaks (see <code><a href="#topic+npeaks">npeaks</a></code>),
while its actual size is defined via the argument <code class="reqn">RadiusA</code>
(see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_lambda">lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (c<code class="reqn">mov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code>
means that the tracepoint is located on <code class="reqn">cmov</code>'s circumference.
For <code class="reqn">lambda &lt; 1</code>, the tracepoint is on <code class="reqn">cmov</code>'s area, e.g.
if <code class="reqn">lambda = 0.5</code>, it is halfway between <code class="reqn">cmov</code>'s centre
and its circumference. If <code class="reqn">lambda &gt; 1</code> the tracepoint is outside
<code class="reqn">cmov</code>'s area, you might imagine it being attached to a rod
which is attached to <code class="reqn">cmov</code> and originates from its centre.
E.g. <code class="reqn">lambda = 2</code> would mean that the tracepoint's distance
from cmov's centre equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a
circle because the tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_hypo">hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid <code class="reqn">lambda != 1</code>
is generated, as <code class="reqn">cmov</code> is rolling at the outside of <code class="reqn">cfix</code>'s
circumference.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_cx">Cx</code></td>
<td>

<p>x-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_cy">Cy</code></td>
<td>

<p>y-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_radiusa">RadiusA</code></td>
<td>

<p>The actual radius of the fixed circle. Default is 1.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_steps">steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (<code class="reqn">cmov</code>) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
cmov. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleA_+3A_start">start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><img src="../help/figures/Figure1.png" width = "500" height = "500" alt="Figure1.png" />
<img src="../help/figures/Figure2.png" width = "500" height = "500" alt="Figure2.png" />
</p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row represents a
tracepoint position. The positions are ordered along the trace
with the last and the first point being identical in order to
warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zykloid">zykloid</a></code>,
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>, <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Same hypotrochoid scaled to different radii of the fix circle
cycl1 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 1.3)
cycl2 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 1.0)
cycl3 &lt;- zykloid.scaleA(A = 7, a = 3, lambda = 2/3, RadiusA = 0.7)
plot (y ~ x, data = cycl1, asp = 1, col = "red", type = "l",
      main = "A = 7, a = 3, lambda = 2/3")
lines(y ~ x, data = cycl2, asp = 1, col = "green")
lines(y ~ x, data = cycl3, asp = 1, col = "blue")
legend("topleft", c("RadiusA = 1.3", "RadiusA = 1.0", "RadiusA = 0.7"),
       lty = rep("solid", 3), col = c("red", "green", "blue"), bty = "n")
       


# In this example, RadiusA depends on the cosine of the x-coordinate
# of the fixed circle's centre
op &lt;- par(mar = c(0,0,0,0), bg = "black")
ctrx &lt;- seq(-2*pi, 2*pi, pi/10)
ccol &lt;- rainbow(length(ctrx))
plot.new()
plot.window(asp = 1, xlim = c(-8, 8), ylim = c(-0.5, 0.5))
for(i in c(1:length(ctrx))) {
    zzz &lt;- zykloid.scaleA(A = 9, a = 7, hypo = TRUE, Cx = ctrx[i],
                          Cy = -ctrx[i], lambda = 0.9,
                          RadiusA = 1.5 + cos(ctrx[i]), start = -pi/4)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# Geometric degression of RadiusA makes a nice star
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-10, 10), ylim = c(-10, 10))
rad &lt;- 10
n &lt;- 60
ccol &lt;- heat.colors(n)
for(i in c(1:n)) {
    if (i/2 != floor(i/2)) { sstart = pi/2 }
    else                   { sstart = pi/4 }
    zzz &lt;- zykloid.scaleA(A = 4, a = 3, RadiusA = rad, lambda = 1,
                          start = sstart)
    lines(y ~ x, data = zzz, col = ccol[i])
    rad &lt;- rad * 0.9
} # for i
par(op)



# A windmill
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-1.4, 1.4), ylim = c(-1.4, 1.4))
rrad &lt;- sqrt(seq(0.1, 2, 0.1))
n    &lt;- length(rrad)
ccol &lt;- rainbow(n, start = 0, end = 0.3)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleA(A = 7, a = 3, RadiusA = rrad[i],
           hypo = TRUE, lambda = 1.1,
           start = pi/2 - (1*pi/7 - (i - 1) * 2*pi/(7 * n)))
    lines(y ~ x, data = zzz, col = ccol[n + 1 - i])
} # for i
par(op)



# Advanced Example: A series of cycloids with their centres
# located on a logarithmic spiral
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-50, 50), ylim = c(-50, 50))
a     &lt;- 1/32     # spiral's scaling constant
alpha &lt;- pi/20    # spiral's slope angle
sphi  &lt;- seq(0, 18 * pi, pi/25)   # series of angles for cycloid centres
rad  &lt;- a * exp(tan(alpha)*sphi)  # corresponding spiral radii
spx  &lt;- rad * cos(sphi)           # corresponding x-coordinates
spy  &lt;- rad *sin(sphi)            # corresponding y-coordinates
n    &lt;- length(sphi)
ccol &lt;- rainbow(n, start = 2/3, end = 1/2)
for (i in c(1:n)) {
     czc &lt;- zykloid.scaleA(A = 3, a = 1, lambda = 1.5,
            Cx = spx[i], Cy = spy[i],
            RadiusA = rad[i]/2.5, # cycloid radii depends on spiral radii
            start = pi + sphi[i]) # angle cycloid towards spiral centre
     lines(y ~ x, data = czc, col = ccol[i])
} # for i
par(op)


</code></pre>

<hr>
<h2 id='zykloid.scaleAa'>
Wrapper for <code><a href="#topic+zykloid">zykloid</a></code> which scales a cycloid by its
outer radius and allows free positioning
</h2><span id='topic+zykloid.scaleAa'></span>

<h3>Description</h3>

<p>While <code><a href="#topic+zykloid">zykloid</a></code> provides the basic functionality for
calculating cycloids, this functions allows to re-size a cycloid
by freely setting the radius of its circumcircle. In addition,
the cycloid can be re-positioned by locating the fixed circle's
midpoint. This function behaves similarly as <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>.
See details. Figures 1 and 2 and <code><a href="#topic+zykloid">zykloid</a></code> describe the
geometrical principles of cycloids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zykloid.scaleAa(A, a, lambda, hypo = TRUE, Cx = 0, Cy = 0,
                RadiusAa = 1, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zykloid.scaleAa_+3A_a">A</code></td>
<td>

<p>The Radius of the fixed circle before re-sizing. Must be an integer
Number &gt; 0. Together with <code class="reqn">a</code> (see below), <code class="reqn">A</code> is only
determining the cycloid's shape and number of peaks (see
<code><a href="#topic+npeaks">npeaks</a></code>), while its actual size is defined by the
argument <code class="reqn">RadiusAa</code> (see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_a">a</code></td>
<td>

<p>The radius of the moving circle before re-sizing. Must be an
integer Number &gt; 0. Together with <code class="reqn">A</code>, <code class="reqn">a</code> only determines
the cycloid's shape and number of peaks (see <code><a href="#topic+npeaks">npeaks</a></code>),
while its actual size is defined via the argument <code class="reqn">RadiusAa</code>
(see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_lambda">lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (<code class="reqn">cmov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code>
means that the tracepoint is located on <code class="reqn">cmov</code>'s circumference.
For <code class="reqn">lambda &lt; 1</code>, the tracepoint is on <code class="reqn">cmov</code>'s area, e.g.
if <code class="reqn">lambda = 0.5</code>, it is halfway between <code class="reqn">cmov</code>'s centre
and its circumference. If <code class="reqn">lambda &gt; 1</code> the tracepoint is
outside <code class="reqn">cmov</code>'s area, you might imagine it being attached to
a rod which is attached to <code class="reqn">cmov</code> and crosses its centre.
E.g. <code class="reqn">lambda = 2</code> would mean that the tracepoint's distance
from cmov's centre equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a
circle because the tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_hypo">hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid <code class="reqn">\lambda != 1</code>
is generated, as <code class="reqn">cmov</code> is rolling at the outside of <code class="reqn">cfix</code>'s
circumference.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_cx">Cx</code></td>
<td>

<p>x-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_cy">Cy</code></td>
<td>

<p>y-coordinate of the fixed circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_radiusaa">RadiusAa</code></td>
<td>

<p>The actual radius of the cycloids outer circle. Default is 1.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_steps">steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (cmov) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
cmov. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleAa_+3A_start">start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales in either case the radius of the whole
cycloid's circumcircle. Thus, for hypocycloids and hypotrochoids
it will behave the same way as <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>.
For epicycloids and epitrochoids their output will be different.
zykloid.scaleAa scales the outer edge of the figure, while
<code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code> always scales the circle where the
peaks of the figure are located on. In the case of epicycloids
and epitrochoids this is at the inside of the figure (see
examples).<br />
Figure 1 and 2 show the principle behind cycloid construction:
<br />
<img src="../help/figures/Figure1.png" width = "500" height = "500" alt="Figure1.png" />
<img src="../help/figures/Figure2.png" width = "500" height = "500" alt="Figure2.png" />
</p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row represents
a tracepoint position. The positions are ordered along the trace
with the last and the first point being identical in order to
warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zykloid">zykloid</a></code>,
<code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>, <code><a href="#topic+zykloid.scaleP">zykloid.scaleP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Same epicycloid scaled to different maximum radii of the figure
cycl1 &lt;- zykloid.scaleAa(A = 21, a = 11, lambda = 1, hypo = FALSE,
                         RadiusAa = 100)
cycl2 &lt;- zykloid.scaleAa(A = 21, a = 11, lambda = 1, hypo = FALSE,
                         RadiusAa =  70)
cycl3 &lt;- zykloid.scaleAa(A = 21, a = 11, lambda = 1, hypo = FALSE,
                         RadiusAa =  40)
plot (y ~ x, data = cycl1, col = "red", asp = 1, type = "l",
      main = "A = 21, a = 11, lambda = 1")
lines(y ~ x, data = cycl2, col = "green")
lines(y ~ x, data = cycl3, col = "blue")
legend("topleft", c("RadiusAa = 100", "RadiusAa =  70", "RadiusAa =  40"),
       lty = rep("solid", 3), col = c("red", "green", "blue"), bty = "n")
       

# Pentagram by constructing a hypocycloid and an epicycloid
# with the same outer radius and scaling this radius exponentially
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-40, 40), ylim = c(-40, 40))
n &lt;- 20
ccol &lt;- heat.colors(n)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleAa(A = 5, a = 2,
           RadiusAa = 38*exp(-0.05*(i-1)), hypo = FALSE, lambda = 1)
    lines(y ~ x, data = zzz, col = ccol[i])
    zzz &lt;- zykloid.scaleAa(A = 5, a = 2,
           RadiusAa = 38*exp(-0.05*(i-1)), hypo = TRUE,  lambda = 1)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# Psychedelic star by modifying lambda while keeping the outer
# radius constant
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-5, 5), ylim = c(-5, 5))
llam &lt;- seq(0, 8, 0.2)
ccol &lt;- terrain.colors(length(llam))
for(i in c(1:length(llam))) {
    zzz &lt;- zykloid.scaleAa(A = 5, a = 1, RadiusAa = 4.5,
           hypo = FALSE, lambda = llam[i])
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)

</code></pre>

<hr>
<h2 id='zykloid.scaleP'>
Wrapper for <code><a href="#topic+zykloid">zykloid</a></code> which scales a cycloid by the
circle its peaks are located on and allows free positioning
</h2><span id='topic+zykloid.scaleP'></span>

<h3>Description</h3>

<p>While <code><a href="#topic+zykloid">zykloid</a></code> provides the basic functionality for
calculating cycloids, this functions allows to re-size a cycloid
by freely setting the radius of the circle its peaks are located
on. In addition, the cycloid can be re-positioned by locating
the fixed circle's midpoint. This function behaves similarly as
<code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>. See details. See Figures 1, 2, and
<code><a href="#topic+zykloid">zykloid</a></code> for the geometrical principles of cycloids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zykloid.scaleP(A, a, lambda, hypo = TRUE, Cx = 0, Cy = 0,
               RadiusP = 1, steps = 360, start = pi/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zykloid.scaleP_+3A_a">A</code></td>
<td>

<p>The Radius of the fix circle before re-sizing. Must be an integer
Number &gt; 0. Together with <code class="reqn">a</code> (see below), <code class="reqn">A</code> is only
determining the cycloid's shape and number of peaks (see
<code><a href="#topic+npeaks">npeaks</a></code>), while its actual size is defined by the
argument <code class="reqn">RadiusP</code> (see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_a">a</code></td>
<td>

<p>The radius of the moving circle before re-sizing. Must be an
integer Number &gt; 0. Together with <code class="reqn">A</code>, <code class="reqn">a</code> only determines
the cycloid's shape and number of peaks (see <code><a href="#topic+npeaks">npeaks</a></code>),
while its actual size is defined via the argument <code class="reqn">RadiusP</code>
(see below).
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_lambda">lambda</code></td>
<td>

<p>The distance of the tracepoint from the moving circle's (<code class="reqn">cmov</code>)
centre in relative units of its radius <code class="reqn">a</code>. <code class="reqn">lambda = 1</code>
means that the tracepoint is located on <code class="reqn">cmov</code>'s circumference.
For <code class="reqn">lambda &lt; 1</code>, the tracepoint is on <code class="reqn">cmov</code>'s area, e.g.
if <code class="reqn">lambda = 0.5</code>, it is halfway between <code class="reqn">cmov</code>'s centre
and its circumference. If <code class="reqn">lambda &gt; 1</code> the tracepoint is outside
<code class="reqn">cmov</code>'s area, you might imagine it being attached to a rod
which is attached to cmov and crosses its centre. E.g. <code class="reqn">lambda = 2</code>
would mean that the tracepoint's distance from <code class="reqn">cmov</code>'s centre
equals <code class="reqn">2*a</code>. <code class="reqn">lambda = 0</code> produces a circle because the
tracepoint is identical with <code class="reqn">cmov</code>'s centre.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_hypo">hypo</code></td>
<td>

<p>logical. If TRUE, the resulting figure is a hypocycloid (<code class="reqn">lambda = 1</code>)
or a hypotrochoid (<code class="reqn">lambda != 1</code>), because <code class="reqn">cmov</code> is rolling
along the inner side of the fixed circle (<code class="reqn">cfix</code>). If FALSE,
an epicycloid (<code class="reqn">lambda = 1</code>) or an epitrochoid (<code class="reqn">lambda != 1</code>)
is generated, as <code class="reqn">cmov</code> is rolling at the outside of
<code class="reqn">cfix</code>'s circumference.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_cx">Cx</code></td>
<td>

<p>x-coordinate of the fix circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_cy">Cy</code></td>
<td>

<p>y-coordinate of the fix circle's midpoint. Default is 0.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_radiusp">RadiusP</code></td>
<td>

<p>The actual radius of the circle the cycloid's peaks are located
on. Default is 1.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_steps">steps</code></td>
<td>

<p>positive integer. The number of steps per circuit of the moving
circle (<code class="reqn">cmov</code>) for which tracepoint positions are calculated.
The default, 360, means steps of 1 degree for the movement of
<code class="reqn">cmov</code>. Analogously, steps = 720 would mean steps of 0.5 degrees.
</p>
</td></tr>
<tr><td><code id="zykloid.scaleP_+3A_start">start</code></td>
<td>

<p>Start angle (radians) of the moving circle's (<code class="reqn">cmov</code>) centre
counterclockwise to the horizontal with the fixed circle's (<code class="reqn">cfix</code>)
centre as the pivot. The tracepoint will start at a peak.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function scales the radius of the circle the cycloids peaks
are located on. For hypocycloids and hypotrochoids it will thus
behave the same way as <code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>. For
epicycloids and epitrochoids the output will be different.
While <code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code> scales the outer edge of the
figure, zykloid.scaleP always scales the circle where the
peaks of the figure are located on. In the case of epicycloids
and epitrochoids this is at the inside of the figure (see
examples below).<br />
Figure 1 and 2 show the principle behind cycloid construction:
<br />
<img src="../help/figures/Figure1.png" width = "500" height = "500" alt="Figure1.png" />
<img src="../help/figures/Figure2.png" width = "500" height = "500" alt="Figure2.png" />
</p>


<h3>Value</h3>

<p>A dataframe with the columns <code class="reqn">x</code> and <code class="reqn">y</code>. Each row represents
a tracepoint position. The positions are ordered along the trace
with the last and the first point being identical in order to
warrant a closed figure when plotting the data.
</p>


<h3>Author(s)</h3>

<p>Peter Biber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zykloid">zykloid</a></code>,
<code><a href="#topic+zykloid.scaleA">zykloid.scaleA</a></code>, <code><a href="#topic+zykloid.scaleAa">zykloid.scaleAa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Epitrochoids with different lambda scaled to the same radius of
# the peak circle
cycl1 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 1.2, hypo = FALSE,
                         RadiusP = 10)
cycl2 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 1.0, hypo = FALSE,
                         RadiusP = 10)
cycl3 &lt;- zykloid.scaleP(A = 21, a = 11, lambda = 0.8, hypo = FALSE,
                         RadiusP = 10)
plot (y ~ x, data = cycl1, col = "red", asp = 1, type = "l",
      main = "A = 21, a = 11, RadiusP = 10")
lines(y ~ x, data = cycl2, col = "green")
lines(y ~ x, data = cycl3, col = "blue")
legend("topleft", c("lambda = 1.2", "lambda =  1.0", "lambda =  0.8"),
       lty = rep("solid", 3), col = c("red", "green", "blue"),
       bty = "n")



# Cool Disk by scaling the start angle with an
# exponential function ...
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = FALSE)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# ... the free space in the centre could be filled with
# the corresponding hypocycloid ...
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
for(i in c(1:n)) {
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = FALSE)
    lines(y ~ x, data = zzz, col = ccol[i])
    zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = 6, lambda = 1,
           start = 2*pi/3 * exp(-0.1 * (i - 1)), hypo = TRUE)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)



# ... or the same ring again and again.
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-11, 11), ylim = c(-11, 11))
n &lt;- 30
ccol &lt;- topo.colors(n)
rad &lt;- 6
for(g in c(1:7)) {
    for(i in c(1:n)) {
        zzz &lt;- zykloid.scaleP(A = 3, a = 1, RadiusP = rad,
               lambda = 1, start = 2*pi/3 * exp(-0.1 * (i - 1)),
               hypo = FALSE)
        lines(y ~ x, data = zzz, col = ccol[i])
    } # for i
    rad &lt;- rad * 3/5
} # for g
par(op)



# Cauliflower pattern. Here, an exponential function is used
# for scaling the radius of the circle the cycloid's loops
# are on.
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-22, 22), ylim = c(-22, 22))
n &lt;- 15
dcol &lt;- heat.colors(n)
for(i in c(1:n)) {
    lambdax &lt;- seq(2.0, 2.2, 0.1)
    for(j in c(1:length(lambdax))) {
        zzz &lt;- zykloid.scaleP(A = 11, a = 1,
               RadiusP = 15 * exp(-0.3 * (i - 1)),
               lambda = lambdax[j], hypo = FALSE,
               start = pi/2 + (i - 1)*pi/11)
        if(j/2 == floor(j/2)) { colx &lt;- "blue" }
        else                  { colx &lt;- dcol[n + 1 - i] }
        lines(y ~ x, data = zzz, col = colx)
    } # for j
} # for i
par(op)



# Sparkling star
op &lt;- par(mar = c(0,0,0,0), bg = "black")
plot.new()
plot.window(asp = 1, xlim = c(-15, 15), ylim = c(-15, 15))
llam &lt;- seq(0, 8, 0.2)
ccol &lt;- rainbow(length(llam), start = 2/3, end = 1/3)
for(i in c(1:length(llam))) {
    zzz &lt;- zykloid.scaleP(A = 5, a = 1, RadiusP = 2.1,
           hypo = FALSE, lambda = llam[i], start = pi/5)
    lines(y ~ x, data = zzz, col = ccol[i])
} # for i
par(op)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
