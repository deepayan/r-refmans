<!DOCTYPE html><html><head><title>Help for package insurancerating</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {insurancerating}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_prediction'><p>Add predictions to a data frame</p></a></li>
<li><a href='#autoplot.bootstrap_rmse'><p>Automatically create a ggplot for objects obtained from bootstrap_rmse()</p></a></li>
<li><a href='#autoplot.check_residuals'><p>Automatically create a ggplot for objects obtained from check_residuals()</p></a></li>
<li><a href='#autoplot.constructtariffclasses'><p>Automatically create a ggplot for objects obtained from</p>
construct_tariff_classes()</a></li>
<li><a href='#autoplot.fitgam'><p>Automatically create a ggplot for objects obtained from fit_gam()</p></a></li>
<li><a href='#autoplot.restricted'><p>Automatically create a ggplot for objects obtained from restrict_coef()</p></a></li>
<li><a href='#autoplot.riskfactor'><p>Automatically create a ggplot for objects obtained from rating_factors()</p></a></li>
<li><a href='#autoplot.smooth'><p>Automatically create a ggplot for objects obtained from smooth_coef()</p></a></li>
<li><a href='#autoplot.truncated_dist'><p>Automatically create a ggplot for objects obtained from fit_truncated_dist()</p></a></li>
<li><a href='#autoplot.univariate'><p>Automatically create a ggplot for objects obtained from univariate()</p></a></li>
<li><a href='#biggest_reference'><p>Set reference group to the group with largest exposure</p></a></li>
<li><a href='#bootstrap_rmse'><p>Bootstrapped RMSE</p></a></li>
<li><a href='#check_overdispersion'><p>Check overdispersion of Poisson GLM</p></a></li>
<li><a href='#check_residuals'><p>Check model residuals</p></a></li>
<li><a href='#construct_model_points'><p>Construct model points from Generalized Linear Model</p></a></li>
<li><a href='#construct_tariff_classes'><p>Construct insurance tariff classes</p></a></li>
<li><a href='#fisher'><p>Fisher's natural breaks classification</p></a></li>
<li><a href='#fit_gam'><p>Generalized additive model</p></a></li>
<li><a href='#fit_truncated_dist'><p>Fit a distribution to truncated severity (loss) data</p></a></li>
<li><a href='#histbin'><p>Create a histogram with outlier bins</p></a></li>
<li><a href='#model_data'><p>Get model data</p></a></li>
<li><a href='#model_performance'><p>Performance of fitted GLMs</p></a></li>
<li><a href='#MTPL'><p>Characteristics of 30,000 policyholders in a Motor Third Party Liability</p>
(MTPL) portfolio.</a></li>
<li><a href='#MTPL2'><p>Characteristics of 3,000 policyholders in a Motor Third Party Liability</p>
(MTPL) portfolio.</a></li>
<li><a href='#period_to_months'><p>Split period to months</p></a></li>
<li><a href='#rating_factors'><p>Include reference group in regression output</p></a></li>
<li><a href='#reduce'><p>Reduce portfolio by merging redundant date ranges</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#refit_glm'><p>Refitting Generalized Linear Models</p></a></li>
<li><a href='#restrict_coef'><p>Restrict coefficients in the model</p></a></li>
<li><a href='#rgammat'><p>Generate data from truncated gamma distribution</p></a></li>
<li><a href='#rlnormt'><p>Generate data from truncated lognormal distribution</p></a></li>
<li><a href='#rmse'><p>Root Mean Squared Error</p></a></li>
<li><a href='#rows_per_date'><p>Find active rows per date</p></a></li>
<li><a href='#smooth_coef'><p>Smooth coefficients in the model</p></a></li>
<li><a href='#summary.reduce'><p>Automatically create a summary for objects obtained from reduce()</p></a></li>
<li><a href='#univariate'><p>Univariate analysis for discrete risk factors</p></a></li>
<li><a href='#update_formula_add'><p>Create new offset-term and new formula</p></a></li>
<li><a href='#update_glm'><p>Refitting Generalized Linear Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analytic Insurance Rating Techniques</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Haringa &lt;mtharinga@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mharinga/insurancerating/issues">https://github.com/mharinga/insurancerating/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for insurance rating. It helps actuaries to implement GLMs within all relevant steps needed to construct
 a risk premium from raw data. It provides a data driven strategy for the construction of insurance tariff classes.
 This strategy is based on the work by Antonio and Valdez (2012) &lt;<a href="https://doi.org/10.1007%2Fs10182-011-0152-7">doi:10.1007/s10182-011-0152-7</a>&gt;. It also provides recipes
 on how to easily perform one-way, or univariate, analyses on an insurance portfolio. In addition it adds functionality
 to include reference categories in the levels of the coefficients in the output of a generalized linear regression analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mharinga/insurancerating">https://github.com/mharinga/insurancerating</a>,
<a href="https://mharinga.github.io/insurancerating/">https://mharinga.github.io/insurancerating/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ciTools, classInt, colorspace, data.table, DHARMa, dplyr,
evtree, fitdistrplus, ggplot2, insight, lubridate, mgcv,
patchwork, scales, stringr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-20 11:18:20 UTC; martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Haringa [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-20 11:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_prediction'>Add predictions to a data frame</h2><span id='topic+add_prediction'></span>

<h3>Description</h3>

<p>Add model predictions and confidence bounds to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_prediction(data, ..., var = NULL, conf_int = FALSE, alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_prediction_+3A_data">data</code></td>
<td>
<p>a data frame of new data.</p>
</td></tr>
<tr><td><code id="add_prediction_+3A_...">...</code></td>
<td>
<p>one or more objects of class <code>glm</code>.</p>
</td></tr>
<tr><td><code id="add_prediction_+3A_var">var</code></td>
<td>
<p>the name of the output column(s), defaults to NULL</p>
</td></tr>
<tr><td><code id="add_prediction_+3A_conf_int">conf_int</code></td>
<td>
<p>determines whether confidence intervals will be shown.
Defaults to <code>conf_int = FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_prediction_+3A_alpha">alpha</code></td>
<td>
<p>a real number between 0 and 1. Controls the confidence level of
the interval estimates (defaults to 0.10, representing 90 percent confidence
interval).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- glm(nclaims ~ age_policyholder, data = MTPL,
    offset = log(exposure), family = poisson())
add_prediction(MTPL, mod1)

# Include confidence bounds
add_prediction(MTPL, mod1, conf_int = TRUE)

</code></pre>

<hr>
<h2 id='autoplot.bootstrap_rmse'>Automatically create a ggplot for objects obtained from bootstrap_rmse()</h2><span id='topic+autoplot.bootstrap_rmse'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>bootstrap_rmse()</code>, and plots the
simulated RMSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap_rmse'
autoplot(object, fill = NULL, color = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.bootstrap_rmse_+3A_object">object</code></td>
<td>
<p>bootstrap_rmse object produced by <code>bootstrap_rmse()</code></p>
</td></tr>
<tr><td><code id="autoplot.bootstrap_rmse_+3A_fill">fill</code></td>
<td>
<p>color to fill histogram (default is &quot;steelblue&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.bootstrap_rmse_+3A_color">color</code></td>
<td>
<p>color to plot line colors of histogram</p>
</td></tr>
<tr><td><code id="autoplot.bootstrap_rmse_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='autoplot.check_residuals'>Automatically create a ggplot for objects obtained from check_residuals()</h2><span id='topic+autoplot.check_residuals'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>check_residuals()</code>, and produces a
uniform quantile-quantile plot.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'check_residuals'
autoplot(object, show_message = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.check_residuals_+3A_object">object</code></td>
<td>
<p>check_residuals object produced by <code>check_residuals()</code></p>
</td></tr>
<tr><td><code id="autoplot.check_residuals_+3A_show_message">show_message</code></td>
<td>
<p>show output from test (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="autoplot.check_residuals_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='autoplot.constructtariffclasses'>Automatically create a ggplot for objects obtained from
construct_tariff_classes()</h2><span id='topic+autoplot.constructtariffclasses'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>construct_tariff_classes()</code>,
and plots the fitted GAM. In addition the constructed tariff classes are
shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constructtariffclasses'
autoplot(
  object,
  conf_int = FALSE,
  color_gam = "steelblue",
  show_observations = FALSE,
  color_splits = "grey50",
  size_points = 1,
  color_points = "black",
  rotate_labels = FALSE,
  remove_outliers = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.constructtariffclasses_+3A_object">object</code></td>
<td>
<p>constructtariffclasses object produced by
<code>construct_tariff_classes</code></p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_conf_int">conf_int</code></td>
<td>
<p>determines whether 95\
The default is <code>conf_int = FALSE</code></p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_color_gam">color_gam</code></td>
<td>
<p>a color can be specified either by name (e.g.: &quot;red&quot;) or by
hexadecimal code (e.g. : &quot;#FF1234&quot;) (default is &quot;steelblue&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_show_observations">show_observations</code></td>
<td>
<p>add observed frequency/severity points for each
level of the variable for which tariff classes are constructed</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_color_splits">color_splits</code></td>
<td>
<p>change the color of the splits in the graph (&quot;grey50&quot; is
default)</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_size_points">size_points</code></td>
<td>
<p>size for points (1 is default)</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_color_points">color_points</code></td>
<td>
<p>change the color of the points in the graph (&quot;black&quot; is
default)</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_rotate_labels">rotate_labels</code></td>
<td>
<p>rotate x-labels 45 degrees (this might be helpful for
overlapping x-labels)</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_remove_outliers">remove_outliers</code></td>
<td>
<p>do not show observations above this number in the
plot. This might be helpful for outliers.</p>
</td></tr>
<tr><td><code id="autoplot.constructtariffclasses_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
library(dplyr)
x &lt;- fit_gam(MTPL,
nclaims = nclaims, x = age_policyholder, exposure = exposure) |&gt;
   construct_tariff_classes()
autoplot(x, show_observations = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='autoplot.fitgam'>Automatically create a ggplot for objects obtained from fit_gam()</h2><span id='topic+autoplot.fitgam'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>fit_gam()</code>, and plots the fitted
GAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitgam'
autoplot(
  object,
  conf_int = FALSE,
  color_gam = "steelblue",
  show_observations = FALSE,
  x_stepsize = NULL,
  size_points = 1,
  color_points = "black",
  rotate_labels = FALSE,
  remove_outliers = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.fitgam_+3A_object">object</code></td>
<td>
<p>fitgam object produced by <code>fit_gam()</code></p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_conf_int">conf_int</code></td>
<td>
<p>determines whether 95 percent confidence intervals will be
plotted. The default is <code>conf_int = FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_color_gam">color_gam</code></td>
<td>
<p>a color can be specified either by name (e.g.: &quot;red&quot;) or by
hexadecimal code (e.g. : &quot;#FF1234&quot;) (default is &quot;steelblue&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_show_observations">show_observations</code></td>
<td>
<p>add observed frequency/severity points for each
level of the variable for which tariff classes are constructed</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_x_stepsize">x_stepsize</code></td>
<td>
<p>set step size for labels horizontal axis</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_size_points">size_points</code></td>
<td>
<p>size for points (1 is default)</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_color_points">color_points</code></td>
<td>
<p>change the color of the points in the graph (&quot;black&quot; is
default)</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_rotate_labels">rotate_labels</code></td>
<td>
<p>rotate x-labels 45 degrees (this might be helpful for
overlapping x-labels)</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_remove_outliers">remove_outliers</code></td>
<td>
<p>do not show observations above this number in the
plot. This might be helpful for outliers.</p>
</td></tr>
<tr><td><code id="autoplot.fitgam_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
library(dplyr)
fit_gam(MTPL, nclaims = nclaims, x = age_policyholder,
        exposure = exposure) |&gt;
   autoplot(show_observations = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='autoplot.restricted'>Automatically create a ggplot for objects obtained from restrict_coef()</h2><span id='topic+autoplot.restricted'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Takes an object produced by <code>restrict_coef()</code>, and produces
a line plot with a comparison between the restricted coefficients and
estimated coefficients obtained from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'restricted'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.restricted_+3A_object">object</code></td>
<td>
<p>object produced by <code>restrict_coef()</code></p>
</td></tr>
<tr><td><code id="autoplot.restricted_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class ggplot2
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq &lt;- glm(nclaims ~ bm + zip, weights = power, family = poisson(),
 data = MTPL)
zip_df &lt;- data.frame(zip = c(0,1,2,3), zip_rst = c(0.8, 0.9, 1, 1.2))
freq |&gt;
  restrict_coef(restrictions = zip_df) |&gt;
  autoplot()

</code></pre>

<hr>
<h2 id='autoplot.riskfactor'>Automatically create a ggplot for objects obtained from rating_factors()</h2><span id='topic+autoplot.riskfactor'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>univariate()</code>, and plots the
available input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riskfactor'
autoplot(
  object,
  risk_factors = NULL,
  ncol = 1,
  labels = TRUE,
  dec.mark = ",",
  ylab = "rate",
  fill = NULL,
  color = NULL,
  linetype = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.riskfactor_+3A_object">object</code></td>
<td>
<p>riskfactor object produced by <code>rating_factors()</code></p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_risk_factors">risk_factors</code></td>
<td>
<p>character vector to define which factors are included.
Defaults to all risk factors.</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in output (default is 1)</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_labels">labels</code></td>
<td>
<p>show labels with the exposure (default is TRUE)</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_dec.mark">dec.mark</code></td>
<td>
<p>control the format of the decimal point, as well as the mark
between intervals before the decimal point, choose either &quot;,&quot; (default) or
&quot;.&quot;</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_ylab">ylab</code></td>
<td>
<p>modify label for the y-axis</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_fill">fill</code></td>
<td>
<p>color to fill histogram</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_color">color</code></td>
<td>
<p>color to plot line colors of histogram (default is &quot;skyblue&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_linetype">linetype</code></td>
<td>
<p>use different linetypes (default is FALSE)</p>
</td></tr>
<tr><td><code id="autoplot.riskfactor_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- MTPL2 %&gt;%
  mutate(across(c(area), as.factor)) %&gt;%
  mutate(across(c(area), ~biggest_reference(., exposure)))

mod1 &lt;- glm(nclaims ~ area + premium, offset = log(exposure),
 family = poisson(), data = df)
mod2 &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
 data = df)

x &lt;- rating_factors(mod1, mod2, model_data = df, exposure = exposure)
autoplot(x)

</code></pre>

<hr>
<h2 id='autoplot.smooth'>Automatically create a ggplot for objects obtained from smooth_coef()</h2><span id='topic+autoplot.smooth'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Takes an object produced by <code>smooth_coef()</code>, and produces
a plot with a comparison between the smoothed coefficients and
estimated coefficients obtained from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.smooth_+3A_object">object</code></td>
<td>
<p>object produced by <code>smooth_coef()</code></p>
</td></tr>
<tr><td><code id="autoplot.smooth_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class ggplot2
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='autoplot.truncated_dist'>Automatically create a ggplot for objects obtained from fit_truncated_dist()</h2><span id='topic+autoplot.truncated_dist'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>fit_truncated_dist()</code>, and plots
the available input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'truncated_dist'
autoplot(
  object,
  geom_ecdf = c("point", "step"),
  xlab = NULL,
  ylab = NULL,
  ylim = c(0, 1),
  xlim = NULL,
  print_title = TRUE,
  print_dig = 2,
  print_trunc = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.truncated_dist_+3A_object">object</code></td>
<td>
<p>object univariate object produced by <code>fit_truncated_dist()</code></p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_geom_ecdf">geom_ecdf</code></td>
<td>
<p>the geometric object to use display the data (point or step)</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_xlab">xlab</code></td>
<td>
<p>the title of the x axis</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_ylab">ylab</code></td>
<td>
<p>the title of the y axis</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_ylim">ylim</code></td>
<td>
<p>two numeric values, specifying the lower limit and the upper
limit of the scale</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_xlim">xlim</code></td>
<td>
<p>two numeric values, specifying the left limit and the right
limit of the scale</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_print_title">print_title</code></td>
<td>
<p>show title (default to TRUE)</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_print_dig">print_dig</code></td>
<td>
<p>number of digits for parameters in title (default 2)</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_print_trunc">print_trunc</code></td>
<td>
<p>number of digits for truncation values to print</p>
</td></tr>
<tr><td><code id="autoplot.truncated_dist_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='autoplot.univariate'>Automatically create a ggplot for objects obtained from univariate()</h2><span id='topic+autoplot.univariate'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>univariate()</code>, and plots the
available input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'univariate'
autoplot(
  object,
  show_plots = 1:9,
  ncol = 1,
  background = TRUE,
  labels = TRUE,
  sort = FALSE,
  sort_manual = NULL,
  dec.mark = ",",
  color = "dodgerblue",
  color_bg = "lightskyblue",
  label_width = 10,
  coord_flip = FALSE,
  show_total = FALSE,
  total_color = NULL,
  total_name = NULL,
  rotate_angle = NULL,
  custom_theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.univariate_+3A_object">object</code></td>
<td>
<p>univariate object produced by <code>univariate()</code></p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_show_plots">show_plots</code></td>
<td>
<p>numeric vector of plots to be shown (default is
c(1,2,3,4,5,6,7,8,9)), there are nine available plots:
</p>

<ul>
<li><p>1. frequency (i.e. number of claims / exposure)
</p>
</li>
<li><p>2. average severity (i.e. severity / number of claims)
</p>
</li>
<li><p>3. risk premium (i.e. severity / exposure)
</p>
</li>
<li><p>4. loss ratio (i.e. severity / premium)
</p>
</li>
<li><p>5. average premium (i.e. premium / exposure)
</p>
</li>
<li><p>6. exposure
</p>
</li>
<li><p>7. severity
</p>
</li>
<li><p>8. nclaims
</p>
</li>
<li><p>9. premium
</p>
</li></ul>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in output (default is 1)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_background">background</code></td>
<td>
<p>show exposure as a background histogram (default is TRUE)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_labels">labels</code></td>
<td>
<p>show labels with the exposure (default is TRUE)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_sort">sort</code></td>
<td>
<p>sort (or order) risk factor into descending order by exposure
(default is FALSE)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_sort_manual">sort_manual</code></td>
<td>
<p>sort (or order) risk factor into own ordering; should be
a character vector (default is NULL)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_dec.mark">dec.mark</code></td>
<td>
<p>decimal mark; defaults to &quot;,&quot;</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_color">color</code></td>
<td>
<p>change the color of the points and line (&quot;dodgerblue&quot; is
default)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_color_bg">color_bg</code></td>
<td>
<p>change the color of the histogram (&quot;#f8e6b1&quot; is default)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_label_width">label_width</code></td>
<td>
<p>width of labels on the x-axis (10 is default)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_coord_flip">coord_flip</code></td>
<td>
<p>flip cartesian coordinates so that horizontal becomes
vertical, and vertical, horizontal (default is FALSE)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_show_total">show_total</code></td>
<td>
<p>show line for total if by is used in univariate (default
is FALSE)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_total_color">total_color</code></td>
<td>
<p>change the color for the total line (&quot;black&quot; is default)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_total_name">total_name</code></td>
<td>
<p>add legend name for the total line (e.g. &quot;total&quot;)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_rotate_angle">rotate_angle</code></td>
<td>
<p>numeric value for angle of labels on the x-axis (degrees)</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_custom_theme">custom_theme</code></td>
<td>
<p>list with customized theme options</p>
</td></tr>
<tr><td><code id="autoplot.univariate_+3A_...">...</code></td>
<td>
<p>other plotting parameters to affect the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Marc Haine, Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
x &lt;- univariate(MTPL2, x = area, severity = amount, nclaims = nclaims,
exposure = exposure)
autoplot(x)
autoplot(x, show_plots = c(6,1), background = FALSE, sort = TRUE)

# Group by `zip`
xzip &lt;- univariate(MTPL, x = bm, severity = amount, nclaims = nclaims,
exposure = exposure, by = zip)
autoplot(xzip, show_plots = 1:2)

</code></pre>

<hr>
<h2 id='biggest_reference'>Set reference group to the group with largest exposure</h2><span id='topic+biggest_reference'></span>

<h3>Description</h3>

<p>This function specifies the first level of a factor to the level
with the largest exposure. Levels of factors are sorted using an alphabetic
ordering. If the factor is used in a regression context, then the first level
will be the reference. For insurance applications it is common to specify
the reference level to the level with the largest exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biggest_reference(x, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biggest_reference_+3A_x">x</code></td>
<td>
<p>an unordered factor</p>
</td></tr>
<tr><td><code id="biggest_reference_+3A_weight">weight</code></td>
<td>
<p>a vector containing weights (e.g. exposure). Should be numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor of the same length as x
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Kaas, Rob &amp; Goovaerts, Marc &amp; Dhaene, Jan &amp; Denuit, Michel.
(2008). Modern Actuarial Risk Theory: Using R. doi:10.1007/978-3-540-70998-5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)
df &lt;- chickwts |&gt;
mutate(across(where(is.character), as.factor)) |&gt;
mutate(across(where(is.factor), ~biggest_reference(., weight)))

## End(Not run)

</code></pre>

<hr>
<h2 id='bootstrap_rmse'>Bootstrapped RMSE</h2><span id='topic+bootstrap_rmse'></span>

<h3>Description</h3>

<p>Generate <code>n</code> bootstrap replicates to compute <code>n</code> root mean
squared errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_rmse(
  model,
  data,
  n = 50,
  frac = 1,
  show_progress = TRUE,
  rmse_model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_rmse_+3A_model">model</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="bootstrap_rmse_+3A_data">data</code></td>
<td>
<p>data used to fit model object</p>
</td></tr>
<tr><td><code id="bootstrap_rmse_+3A_n">n</code></td>
<td>
<p>number of bootstrap replicates (defaults to 50)</p>
</td></tr>
<tr><td><code id="bootstrap_rmse_+3A_frac">frac</code></td>
<td>
<p>fraction used in training set if cross-validation is applied
(defaults to 1)</p>
</td></tr>
<tr><td><code id="bootstrap_rmse_+3A_show_progress">show_progress</code></td>
<td>
<p>show progress bar (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="bootstrap_rmse_+3A_rmse_model">rmse_model</code></td>
<td>
<p>numeric RMSE to show as vertical dashed line in autoplot()
(defaults to NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test the predictive ability of the fitted model it might be
helpful to determine the variation in the computed RMSE. The variation is
calculated by computing the root mean squared errors from <code>n</code> generated
bootstrap replicates. More precisely, for each iteration a sample with
replacement is taken from the data set and the model is refitted using
this sample. Then, the root mean squared error is calculated.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>rmse_bs</code></td>
<td>
<p>numerical vector with <code>n</code> root mean squared errors</p>
</td></tr>
<tr><td><code>rmse_mod</code></td>
<td>
<p>root mean squared error for fitted (i.e. original) model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mod1 &lt;- glm(nclaims ~ age_policyholder, data = MTPL,
    offset = log(exposure), family = poisson())

# Use all records in MTPL
x &lt;- bootstrap_rmse(mod1, MTPL, n = 80, show_progress = FALSE)
print(x)
autoplot(x)

# Use 80% of records to test whether predictive ability depends on which 80%
# is used. This might for example be useful in case portfolio contains large
# claim sizes
x_frac &lt;- bootstrap_rmse(mod1, MTPL, n = 50, frac = .8,
 show_progress = FALSE)
autoplot(x_frac) # Variation is quite small for Poisson GLM

## End(Not run)

</code></pre>

<hr>
<h2 id='check_overdispersion'>Check overdispersion of Poisson GLM</h2><span id='topic+check_overdispersion'></span>

<h3>Description</h3>

<p>Check Poisson GLM for overdispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_overdispersion(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_overdispersion_+3A_object">object</code></td>
<td>
<p>fitted model of class <code>glm</code> and family Poisson</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A dispersion ratio larger than one indicates overdispersion, this
occurs when the observed variance is higher than the variance of the
theoretical model. If the dispersion ratio is close to one, a Poisson model
fits well to the data. A p-value &lt; .05 indicates overdispersion.
Overdispersion &gt; 2 probably means there is a larger problem with the data:
check (again) for outliers, obvious lack of fit. Adopted from
<code>performance::check_overdispersion()</code>.
</p>


<h3>Value</h3>

<p>A list with dispersion ratio, chi-squared statistic, and p-value.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>


<ul>
<li><p> Bolker B et al. (2017): <a href="http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html">GLMM FAQ.</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
  data = MTPL2)
check_overdispersion(x)

</code></pre>

<hr>
<h2 id='check_residuals'>Check model residuals</h2><span id='topic+check_residuals'></span>

<h3>Description</h3>

<p>Detect overall deviations from the expected distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_residuals(object, n_simulations = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_residuals_+3A_object">object</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="check_residuals_+3A_n_simulations">n_simulations</code></td>
<td>
<p>number of simulations (defaults to 30)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Misspecifications in GLMs cannot reliably be diagnosed with standard
residual plots, and GLMs are thus often not as thoroughly checked as LMs.
One reason why GLMs residuals are harder to interpret is that the expected
distribution of the data changes with the fitted values. As a result,
standard residual plots, when interpreted in the same way as for linear
models, seem to show all kind of problems, such as non-normality,
heteroscedasticity, even if the model is correctly specified.
<code>check_residuals()</code> aims at solving these problems by creating readily
interpretable residuals for GLMs that are standardized to values between
0 and 1, and that can be interpreted as intuitively as residuals for the
linear model. This is achieved by a simulation-based approach, similar to the
Bayesian p-value or the parametric bootstrap, that transforms the residuals
to a standardized scale. This explanation is adopted from
<code><a href="DHARMa.html#topic+simulateResiduals">DHARMa::simulateResiduals()</a></code>.
</p>


<h3>Value</h3>

<p>Invisibly returns the p-value of the test statistics. A
p-value &lt; 0.05 indicates a significant deviation from expected distribution.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Dunn, K. P., and Smyth, G. K. (1996). Randomized quantile
residuals. Journal of Computational and Graphical Statistics 5, 1-10.
</p>
<p>Gelman, A. &amp; Hill, J. Data analysis using regression and
multilevel/hierarchical models Cambridge University Press, 2006
</p>
<p>Hartig, F. (2020). DHARMa: Residual Diagnostics for Hierarchical
(Multi-Level / Mixed) Regression Models. R package version 0.3.0.
<a href="https://CRAN.R-project.org/package=DHARMa">https://CRAN.R-project.org/package=DHARMa</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m1 &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
data = MTPL2)
check_residuals(m1, n_simulations = 50) |&gt; autoplot()

## End(Not run)

</code></pre>

<hr>
<h2 id='construct_model_points'>Construct model points from Generalized Linear Model</h2><span id='topic+construct_model_points'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> <code>construct_model_points()</code>
is used to construct model points from generalized linear models, and must
be preceded by <code>model_data()</code>. <code>construct_model_points()</code> can also be used
in combination with a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_model_points(
  x,
  exposure = NULL,
  exposure_by = NULL,
  agg_cols = NULL,
  drop_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_model_points_+3A_x">x</code></td>
<td>
<p>Object of class model_data or of class data.frame</p>
</td></tr>
<tr><td><code id="construct_model_points_+3A_exposure">exposure</code></td>
<td>
<p>column with exposure</p>
</td></tr>
<tr><td><code id="construct_model_points_+3A_exposure_by">exposure_by</code></td>
<td>
<p>split column exposure by (e.g. year)</p>
</td></tr>
<tr><td><code id="construct_model_points_+3A_agg_cols">agg_cols</code></td>
<td>
<p>list of columns to aggregate (sum) by, e.g. number of claims</p>
</td></tr>
<tr><td><code id="construct_model_points_+3A_drop_na">drop_na</code></td>
<td>
<p>drop na values (default to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# With data.frame
library(dplyr)
mtcars |&gt;
 select(cyl, vs) |&gt;
 construct_model_points()

mtcars |&gt;
  select(cyl, vs, disp) |&gt;
  construct_model_points(exposure = disp)

mtcars |&gt;
 select(cyl, vs, disp, gear) |&gt;
 construct_model_points(exposure = disp, exposure_by = gear)

mtcars |&gt;
 select(cyl, vs, disp, gear, mpg) |&gt;
 construct_model_points(exposure = disp, exposure_by = gear,
   agg_cols = list(mpg))

# With glm
library(datasets)
data1 &lt;- warpbreaks |&gt;
 mutate(jaar = c(rep(2000, 10), rep(2010, 44))) |&gt;
 mutate(exposure = 1) |&gt;
 mutate(nclaims = 2)

pmodel &lt;- glm(breaks ~ wool + tension, data1, offset = log(exposure),
 family = poisson(link = "log"))

model_data(pmodel) |&gt;
 construct_model_points()

model_data(pmodel) |&gt;
 construct_model_points(agg_cols = list(nclaims))

model_data(pmodel) |&gt;
 construct_model_points(exposure = exposure, exposure_by = jaar) |&gt;
 add_prediction(pmodel)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='construct_tariff_classes'>Construct insurance tariff classes</h2><span id='topic+construct_tariff_classes'></span>

<h3>Description</h3>

<p>Constructs insurance tariff classes to <code>fitgam</code> objects
produced by <code>fit_gam</code>. The goal is to bin the continuous risk factors
such that categorical risk factors result which capture the effect of the
covariate on the response in an accurate way, while being easy to use in a
generalized linear model (GLM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_tariff_classes(
  object,
  alpha = 0,
  niterations = 10000,
  ntrees = 200,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_tariff_classes_+3A_object">object</code></td>
<td>
<p>fitgam object produced by <code>fit_gam</code></p>
</td></tr>
<tr><td><code id="construct_tariff_classes_+3A_alpha">alpha</code></td>
<td>
<p>complexity parameter. The complexity parameter (alpha) is used
to control the number of tariff classes. Higher values for <code>alpha</code>
render less tariff classes. (<code>alpha</code> = 0 is default).</p>
</td></tr>
<tr><td><code id="construct_tariff_classes_+3A_niterations">niterations</code></td>
<td>
<p>in case the run does not converge, it terminates after a
specified number of iterations defined by niterations.</p>
</td></tr>
<tr><td><code id="construct_tariff_classes_+3A_ntrees">ntrees</code></td>
<td>
<p>the number of trees in the population.</p>
</td></tr>
<tr><td><code id="construct_tariff_classes_+3A_seed">seed</code></td>
<td>
<p>an numeric seed to initialize the random number generator (for
reproducibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evolutionary trees are used as a technique to bin the <code>fitgam</code>
object produced by <code>fit_gam</code> into risk homogeneous categories.
This method is based on the work by Henckaerts et al. (2018). See Grubinger
et al. (2014) for more details on the various parameters that
control aspects of the evtree fit.
</p>


<h3>Value</h3>

<p>A list of class <code>constructtariffclasses</code> with components
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>data frame with predicted values</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>name of continuous risk factor for which tariff classes are
constructed</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>either 'frequency', 'severity' or 'burning'</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data frame with predicted values and observed values</p>
</td></tr>
<tr><td><code>x_obs</code></td>
<td>
<p>observations for continuous risk factor</p>
</td></tr>
<tr><td><code>splits</code></td>
<td>
<p>vector with boundaries of the constructed tariff classes</p>
</td></tr>
<tr><td><code>tariff_classes</code></td>
<td>
<p>values in vector <code>x</code> coded according to which
constructed tariff class they fall</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Antonio, K. and Valdez, E. A. (2012). Statistical concepts of a
priori and a posteriori risk classification in insurance. Advances in
Statistical Analysis, 96(2):187–224. doi:10.1007/s10182-011-0152-7.
</p>
<p>Grubinger, T., Zeileis, A., and Pfeiffer, K.-P. (2014). evtree:
Evolutionary learning of globally optimal classification and regression trees
in R. Journal of Statistical Software, 61(1):1–29. doi:10.18637/jss.v061.i01.
</p>
<p>Henckaerts, R., Antonio, K., Clijsters, M. and Verbelen, R.
(2018). A data driven binning strategy for the construction of insurance
tariff classes. Scandinavian Actuarial Journal, 2018:8, 681-705.
doi:10.1080/03461238.2018.1429300.
</p>
<p>Wood, S.N. (2011). Fast stable restricted maximum likelihood and
marginal likelihood estimation of semiparametric
generalized linear models. Journal of the Royal Statistical Society (B)
73(1):3-36. doi:10.1111/j.1467-9868.2010.00749.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)
fit_gam(MTPL, nclaims = nclaims,
x = age_policyholder, exposure = exposure) |&gt;
   construct_tariff_classes()

## End(Not run)

</code></pre>

<hr>
<h2 id='fisher'>Fisher's natural breaks classification</h2><span id='topic+fisher'></span>

<h3>Description</h3>

<p>The function provides an interface to finding class intervals
for continuous numerical variables, for example for choosing colours for
plotting maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher(vec, n = 7, diglab = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher_+3A_vec">vec</code></td>
<td>
<p>a continuous numerical variable</p>
</td></tr>
<tr><td><code id="fisher_+3A_n">n</code></td>
<td>
<p>number of classes required (n = 7 is default)</p>
</td></tr>
<tr><td><code id="fisher_+3A_diglab">diglab</code></td>
<td>
<p>number of digits (n = 2 is default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;fisher&quot; style uses the algorithm proposed by W. D. Fisher
(1958) and discussed by Slocum et al. (2005) as the Fisher-Jenks algorithm.
This function is adopted from the classInt package.
</p>


<h3>Value</h3>

<p>Vector with clustering
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Bivand, R. (2018). classInt: Choose Univariate Class Intervals.
R package version 0.2-3. <a href="https://CRAN.R-project.org/package=classInt">https://CRAN.R-project.org/package=classInt</a>
</p>
<p>Fisher, W. D. 1958 &quot;On grouping for maximum homogeneity&quot;, Journal
of the American Statistical Association, 53, pp. 789–798.
doi: 10.1080/01621459.1958.10501479.
</p>

<hr>
<h2 id='fit_gam'>Generalized additive model</h2><span id='topic+fit_gam'></span>

<h3>Description</h3>

<p>Fits a generalized additive model (GAM) to continuous risk
factors in one of the following three types of models: the number of reported
claims (claim frequency), the severity of reported claims (claim severity)
or the burning cost (i.e. risk premium or pure premium).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_gam(
  data,
  nclaims,
  x,
  exposure,
  amount = NULL,
  pure_premium = NULL,
  model = "frequency",
  round_x = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_gam_+3A_data">data</code></td>
<td>
<p>data.frame of an insurance portfolio</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_nclaims">nclaims</code></td>
<td>
<p>column in <code>data</code> with number of claims</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_x">x</code></td>
<td>
<p>column in <code>data</code> with continuous risk factor</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_exposure">exposure</code></td>
<td>
<p>column in <code>data</code> with exposure</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_amount">amount</code></td>
<td>
<p>column in <code>data</code> with claim amount</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_pure_premium">pure_premium</code></td>
<td>
<p>column in <code>data</code> with pure premium</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_model">model</code></td>
<td>
<p>choose either 'frequency', 'severity' or 'burning'
(model = 'frequency' is default). See details section.</p>
</td></tr>
<tr><td><code id="fit_gam_+3A_round_x">round_x</code></td>
<td>
<p>round elements in column <code>x</code> to multiple of <code>round_x</code>. This
gives a speed enhancement for data containing many levels for <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'frequency' specification uses a Poisson GAM for fitting the
number of claims. The logarithm of the exposure is included as an offset,
such that the expected number of claims is proportional to the exposure.
</p>
<p>The 'severity' specification uses a lognormal GAM for fitting the average
cost of a claim. The average cost of a claim is defined as the ratio of the
claim amount and the number of claims. The number of claims is included as a
weight.
</p>
<p>The 'burning' specification uses a lognormal GAM for fitting the pure
premium of a claim. The pure premium is obtained by multiplying the estimated
frequency and the estimated severity of claims. The word burning cost is
used here as equivalent of risk premium and pure premium. Note that the
functionality for fitting a GAM for pure premium is still experimental (in
the early stages of development).
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>prediction</code></td>
<td>
<p>data frame with predicted values</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>name of continuous risk factor</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>either 'frequency', 'severity' or 'burning'</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data frame with predicted values and observed values</p>
</td></tr>
<tr><td><code>x_obs</code></td>
<td>
<p>observations for continuous risk factor</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>References</h3>

<p>Antonio, K. and Valdez, E. A. (2012). Statistical concepts of a
priori and a posteriori risk classification in insurance. Advances in
Statistical Analysis, 96(2):187–224. doi:10.1007/s10182-011-0152-7.
</p>
<p>Grubinger, T., Zeileis, A., and Pfeiffer, K.-P. (2014). evtree:
Evolutionary learning of globally optimal classification and regression trees
in R. Journal of Statistical Software, 61(1):1–29. doi:10.18637/jss.v061.i01.
</p>
<p>Henckaerts, R., Antonio, K., Clijsters, M. and Verbelen, R.
(2018). A data driven binning strategy for the construction of insurance
tariff classes. Scandinavian Actuarial Journal, 2018:8, 681-705.
doi:10.1080/03461238.2018.1429300.
</p>
<p>Wood, S.N. (2011). Fast stable restricted maximum likelihood and
marginal likelihood estimation of semiparametric generalized linear models.
Journal of the Royal Statistical Society (B) 73(1):3-36.
doi:10.1111/j.1467-9868.2010.00749.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_gam(MTPL, nclaims = nclaims, x = age_policyholder,
exposure = exposure)

</code></pre>

<hr>
<h2 id='fit_truncated_dist'>Fit a distribution to truncated severity (loss) data</h2><span id='topic+fit_truncated_dist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Estimate the original
distribution from truncated data. Truncated data arise frequently in
insurance studies. It is common that only claims above a certain threshold
are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_truncated_dist(
  y,
  dist = c("gamma", "lognormal"),
  left = NULL,
  right = NULL,
  start = NULL,
  print_initial = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_truncated_dist_+3A_y">y</code></td>
<td>
<p>vector with observations of losses</p>
</td></tr>
<tr><td><code id="fit_truncated_dist_+3A_dist">dist</code></td>
<td>
<p>distribution for severity (&quot;gamma&quot; or &quot;lognormal&quot;). Defaults to
&quot;gamma&quot;.</p>
</td></tr>
<tr><td><code id="fit_truncated_dist_+3A_left">left</code></td>
<td>
<p>numeric. Observations below this threshold are not present in the
sample.</p>
</td></tr>
<tr><td><code id="fit_truncated_dist_+3A_right">right</code></td>
<td>
<p>numeric. Observations above this threshold are not present in
the sample. Defaults to Inf.</p>
</td></tr>
<tr><td><code id="fit_truncated_dist_+3A_start">start</code></td>
<td>
<p>list of starting parameters for the algorithm.</p>
</td></tr>
<tr><td><code id="fit_truncated_dist_+3A_print_initial">print_initial</code></td>
<td>
<p>print attempts for initial parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitdist returns an object of class &quot;fitdist&quot;
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Original observations for severity
set.seed(1)
e &lt;- rgamma(1000, scale = 148099.5, shape = 0.4887023)

# Truncated data (only claims above 30.000 euros)
threshold &lt;- 30000
f &lt;- e[e &gt; threshold]

library(dplyr)
library(ggplot2)
data.frame(value = c(e, f),
variable = rep(c("Original data", "Only claims above 30.000 euros"),
               c(length(e), length(f)))) %&gt;%
               filter(value &lt; 5e5) %&gt;%
               mutate(value = value / 1000) %&gt;%
               ggplot(aes(x = value)) +
               geom_histogram(colour = "white") +
               facet_wrap(~variable, ncol = 1) +
               labs(y = "Number of observations",
                    x = "Severity (x 1000 EUR)")

# scale = 156259.7 and shape = 0.4588. Close to parameters of original
# distribution!
x &lt;- fit_truncated_dist(f, left = threshold, dist = "gamma")

# Print cdf
autoplot(x)

# CDF with modifications
autoplot(x, print_dig = 5, xlab = "loss", ylab = "cdf", ylim = c(.9, 1))

est_scale &lt;- x$estimate[1]
est_shape &lt;- x$estimate[2]

# Generate data from truncated distribution (between 30k en 20 mln)
rg &lt;- rgammat(10, scale = est_scale, shape = est_shape, lower = 3e4,
 upper = 20e6)

# Calculate quantiles
quantile(rg, probs = c(.5, .9, .99, .995))

## End(Not run)

</code></pre>

<hr>
<h2 id='histbin'>Create a histogram with outlier bins</h2><span id='topic+histbin'></span>

<h3>Description</h3>

<p>Visualize the distribution of a single continuous variable by dividing the x
axis into bins and counting the number of observations in each bin.
Data points that are considered outliers can be binned together. This might
be helpful to display numerical data over a very wide range of values in a
compact way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histbin(
  data,
  x,
  left = NULL,
  right = NULL,
  line = FALSE,
  bins = 30,
  fill = NULL,
  color = NULL,
  fill_outliers = "#a7d1a7"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histbin_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="histbin_+3A_x">x</code></td>
<td>
<p>variable name in data.frame <code>data</code> that should be mapped</p>
</td></tr>
<tr><td><code id="histbin_+3A_left">left</code></td>
<td>
<p>numeric indicating the floor of the range</p>
</td></tr>
<tr><td><code id="histbin_+3A_right">right</code></td>
<td>
<p>numeric indicating the ceiling of the range</p>
</td></tr>
<tr><td><code id="histbin_+3A_line">line</code></td>
<td>
<p>show density line (default is FALSE)</p>
</td></tr>
<tr><td><code id="histbin_+3A_bins">bins</code></td>
<td>
<p>numeric to indicate number of bins</p>
</td></tr>
<tr><td><code id="histbin_+3A_fill">fill</code></td>
<td>
<p>color used to fill bars</p>
</td></tr>
<tr><td><code id="histbin_+3A_color">color</code></td>
<td>
<p>color for bar lines</p>
</td></tr>
<tr><td><code id="histbin_+3A_fill_outliers">fill_outliers</code></td>
<td>
<p>color used to fill outlier bars</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper function around <code>ggplot2::geom_histogram()</code>. The method is
based on suggestions from <a href="https://edwinth.github.io/blog/outlier-bin/">https://edwinth.github.io/blog/outlier-bin/</a>.
</p>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>histbin(MTPL2, premium)
histbin(MTPL2, premium, left = 30, right = 120, bins = 30)

</code></pre>

<hr>
<h2 id='model_data'>Get model data</h2><span id='topic+model_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> <code>model_data()</code>
is used to get data from glm, and must be preceded by <code>update_glm()</code> or
<code>glm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_data_+3A_x">x</code></td>
<td>
<p>Object of class refitsmooth, refitrestricted or glm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='model_performance'>Performance of fitted GLMs</h2><span id='topic+model_performance'></span>

<h3>Description</h3>

<p>Compute indices of model performance for (one or more) GLMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_performance(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_performance_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>glm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following indices are computed:
</p>

<dl>
<dt>AIC</dt><dd><p>Akaike's Information Criterion</p>
</dd>
<dt>BIC</dt><dd><p>Bayesian Information Criterion</p>
</dd>
<dt>RMSE</dt><dd><p>Root mean squared error</p>
</dd>
</dl>

<p>Adopted from <code>performance::model_performance()</code>.
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
          data = MTPL2)
m2 &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
          data = MTPL2)
model_performance(m1, m2)

</code></pre>

<hr>
<h2 id='MTPL'>Characteristics of 30,000 policyholders in a Motor Third Party Liability
(MTPL) portfolio.</h2><span id='topic+MTPL'></span>

<h3>Description</h3>

<p>A dataset containing the age, number of claims, exposure,
claim amount, power, bm, and region of 30,000 policyholders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTPL
</code></pre>


<h3>Format</h3>

<p>A data frame with 30,000 rows and 7 variables:
</p>

<dl>
<dt>age_policyholder</dt><dd><p>age of policyholder, in years.</p>
</dd>
<dt>nclaims</dt><dd><p>number of claims.</p>
</dd>
<dt>exposure</dt><dd><p>exposure, for example, if a vehicle is insured as of
July 1 for a certain year, then during that year, this would represent an
exposure of 0.5 to the insurance company.</p>
</dd>
<dt>amount</dt><dd><p>claim amount in Euros.</p>
</dd>
<dt>power</dt><dd><p>engine power of vehicle (in kilowatts).</p>
</dd>
<dt>bm</dt><dd><p>level occupied in the 23-level (0-22) bonus-malus scale (the
higher the level occupied, the worse the claim history).</p>
</dd>
<dt>zip</dt><dd><p>region indicator (0-3).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Source</h3>

<p>The data is derived from the portfolio of a large Dutch motor
insurance company.
</p>

<hr>
<h2 id='MTPL2'>Characteristics of 3,000 policyholders in a Motor Third Party Liability
(MTPL) portfolio.</h2><span id='topic+MTPL2'></span>

<h3>Description</h3>

<p>A dataset containing the area, number of claims, exposure,
claim amount, exposure, and premium of 3,000 policyholders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTPL2
</code></pre>


<h3>Format</h3>

<p>A data frame with 3,000 rows and 6 variables:
</p>

<dl>
<dt>customer_id</dt><dd><p>customer id</p>
</dd>
<dt>area</dt><dd><p>region where customer lives (0-3)</p>
</dd>
<dt>nclaims</dt><dd><p>number of claims</p>
</dd>
<dt>amount</dt><dd><p>claim amount (severity)</p>
</dd>
<dt>exposure</dt><dd><p>exposure</p>
</dd>
<dt>premium</dt><dd><p>earned premium</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Source</h3>

<p>The data is derived from the portfolio of a large Dutch motor
insurance company.
</p>

<hr>
<h2 id='period_to_months'>Split period to months</h2><span id='topic+period_to_months'></span>

<h3>Description</h3>

<p>The function splits rows with a time period longer than one
month to multiple rows with a time period of exactly one month each. Values
in numeric columns (e.g. exposure or premium) are divided over the months
proportionately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period_to_months(df, begin, end, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period_to_months_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="period_to_months_+3A_begin">begin</code></td>
<td>
<p>column in <code>df</code> with begin dates</p>
</td></tr>
<tr><td><code id="period_to_months_+3A_end">end</code></td>
<td>
<p>column in <code>df</code> with end dates</p>
</td></tr>
<tr><td><code id="period_to_months_+3A_...">...</code></td>
<td>
<p>numeric columns in <code>df</code> to split</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In insurance portfolios it is common that rows relate to periods
longer than one month. This is for example problematic in case exposures per
month are desired.
</p>
<p>Since insurance premiums are constant over the months, and do not depend on
the number of days per month, the function assumes that each month has the
same number of days (i.e. 30).
</p>


<h3>Value</h3>

<p>data.frame with same columns as in <code>df</code>, and one extra column
called <code>id</code>
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
portfolio &lt;- data.frame(
begin1 = ymd(c("2014-01-01", "2014-01-01")),
end = ymd(c("2014-03-14", "2014-05-10")),
termination = ymd(c("2014-03-14", "2014-05-10")),
exposure = c(0.2025, 0.3583),
premium =  c(125, 150))
period_to_months(portfolio, begin1, end, premium, exposure)

</code></pre>

<hr>
<h2 id='rating_factors'>Include reference group in regression output</h2><span id='topic+rating_factors'></span>

<h3>Description</h3>

<p>Extract coefficients in terms of the original levels of the
coefficients rather than the coded variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rating_factors(
  ...,
  model_data = NULL,
  exposure = NULL,
  exponentiate = TRUE,
  signif_stars = FALSE,
  round_exposure = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rating_factors_+3A_...">...</code></td>
<td>
<p>glm object(s) produced by <code>glm()</code></p>
</td></tr>
<tr><td><code id="rating_factors_+3A_model_data">model_data</code></td>
<td>
<p>data.frame used to create glm object(s), this should only
be specified in case the exposure is desired in the output, default value
is NULL</p>
</td></tr>
<tr><td><code id="rating_factors_+3A_exposure">exposure</code></td>
<td>
<p>column in <code>model_data</code> with exposure, default value is NULL</p>
</td></tr>
<tr><td><code id="rating_factors_+3A_exponentiate">exponentiate</code></td>
<td>
<p>logical indicating whether or not to exponentiate the
coefficient estimates. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="rating_factors_+3A_signif_stars">signif_stars</code></td>
<td>
<p>show significance stars for p-values (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="rating_factors_+3A_round_exposure">round_exposure</code></td>
<td>
<p>number of digits for exposure (defaults to 0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fitted linear model has coefficients for the contrasts of the
factor terms, usually one less in number than the number of levels. This
function re-expresses the coefficients in the original coding. This
function is adopted from dummy.coef(). Our adoption prints a data.frame as
output.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- MTPL2 |&gt;
dplyr::mutate(dplyr::across(c(area), as.factor)) |&gt;
dplyr::mutate(dplyr::across(c(area), ~biggest_reference(., exposure)))

mod1 &lt;- glm(nclaims ~ area + premium, offset = log(exposure),
family = poisson(), data = df)
mod2 &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
data = df)

rating_factors(mod1, mod2, model_data = df, exposure = exposure)

</code></pre>

<hr>
<h2 id='reduce'>Reduce portfolio by merging redundant date ranges</h2><span id='topic+reduce'></span>

<h3>Description</h3>

<p>Transform all the date ranges together as a set to produce a
new set of date ranges. Ranges separated by a gap of at least <code>min.gapwidth</code>
days are not merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(df, begin, end, ..., agg_cols = NULL, agg = "sum", min.gapwidth = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="reduce_+3A_begin">begin</code></td>
<td>
<p>name of column <code>df</code> with begin dates</p>
</td></tr>
<tr><td><code id="reduce_+3A_end">end</code></td>
<td>
<p>name of column in <code>df</code> with end dates</p>
</td></tr>
<tr><td><code id="reduce_+3A_...">...</code></td>
<td>
<p>names of columns in <code>df</code> used to group date ranges by</p>
</td></tr>
<tr><td><code id="reduce_+3A_agg_cols">agg_cols</code></td>
<td>
<p>list with columns in <code>df</code> to aggregate by (defaults to NULL)</p>
</td></tr>
<tr><td><code id="reduce_+3A_agg">agg</code></td>
<td>
<p>aggregation type (defaults to &quot;sum&quot;)</p>
</td></tr>
<tr><td><code id="reduce_+3A_min.gapwidth">min.gapwidth</code></td>
<td>
<p>ranges separated by a gap of at least <code>min.gapwidth</code>
days are not merged. Defaults to 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is adopted from <code>IRanges::reduce()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"reduce"</code>.
The function <code>summary</code> is used to obtain and print a summary of the results.
An object of class <code>"reduce"</code> is a list usually containing at least the
following elements:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>data frame with reduced time periods</p>
</td></tr>
<tr><td><code>begin</code></td>
<td>
<p>name of column in <code>df</code> with begin dates</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>name of column in <code>df</code> with end dates</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>names of columns in <code>df</code> used to group date ranges by</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>portfolio &lt;- structure(list(policy_nr = c("12345", "12345", "12345", "12345",
"12345", "12345", "12345", "12345", "12345", "12345", "12345"),
productgroup = c("fire", "fire", "fire", "fire", "fire", "fire",
"fire", "fire", "fire", "fire", "fire"), product = c("contents",
"contents", "contents", "contents", "contents", "contents", "contents",
"contents", "contents", "contents", "contents"),
begin_dat = structure(c(16709,16740, 16801, 17410, 17440, 17805, 17897,
17956, 17987, 18017, 18262), class = "Date"),
end_dat = structure(c(16739, 16800, 16831, 17439, 17531, 17896, 17955,
17986, 18016, 18261, 18292), class = "Date"),
premium = c(89L, 58L, 83L, 73L, 69L, 94L, 91L, 97L, 57L, 65L, 55L)),
row.names = c(NA, -11L), class = "data.frame")

# Merge periods
pt1 &lt;- reduce(portfolio, begin = begin_dat, end = end_dat, policy_nr,
    productgroup, product, min.gapwidth = 5)

# Aggregate per period
summary(pt1, period = "days", policy_nr, productgroup, product)

# Merge periods and sum premium per period
pt2 &lt;- reduce(portfolio, begin = begin_dat, end = end_dat, policy_nr,
    productgroup, product, agg_cols = list(premium), min.gapwidth = 5)

# Create summary with aggregation per week
summary(pt2, period = "weeks", policy_nr, productgroup, product)


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='refit_glm'>Refitting Generalized Linear Models</h2><span id='topic+refit_glm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>refit_glm()</code> is used to refit generalized linear models, and must be
preceded by <code>restrict_coef()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit_glm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refit_glm_+3A_x">x</code></td>
<td>
<p>Object of class restricted or of class smooth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class GLM
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='restrict_coef'>Restrict coefficients in the model</h2><span id='topic+restrict_coef'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Add restrictions, like a bonus-malus structure, on the risk
factors used in the model. <code>restrict_coef()</code> must always be followed
by <code>update_glm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_coef(model, restrictions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_coef_+3A_model">model</code></td>
<td>
<p>object of class glm/restricted</p>
</td></tr>
<tr><td><code id="restrict_coef_+3A_restrictions">restrictions</code></td>
<td>
<p>data.frame with two columns containing restricted data.
The first column, with the name of the risk factor as column name, must
contain the levels of the risk factor. The second column must contain the
restricted coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although restrictions could be applied either to the frequency or
the severity model, it is more appropriate to impose the restrictions
on the premium model. This can be achieved by calculating the pure
premium for each record (i.e. expected number of claims times the expected
claim amount), then fitting an &quot;unrestricted&quot; Gamma GLM to the pure
premium,and then imposing the restrictions in a final &quot;restricted&quot; Gamma
GLM.
</p>


<h3>Value</h3>

<p>Object of class restricted.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_glm">update_glm()</a></code> for refitting the restricted model,
and <code><a href="#topic+autoplot.restricted">autoplot.restricted()</a></code>.
</p>
<p>Other update_glm: 
<code><a href="#topic+smooth_coef">smooth_coef</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Add restrictions to risk factors for region (zip) -------------------------

# Fit frequency and severity model
library(dplyr)
freq &lt;- glm(nclaims ~ bm + zip, offset = log(exposure), family = poisson(),
             data = MTPL)
sev &lt;- glm(amount ~ bm + zip, weights = nclaims,
            family = Gamma(link = "log"),
            data = MTPL |&gt; filter(amount &gt; 0))

# Add predictions for freq and sev to data, and calculate premium
premium_df &lt;- MTPL |&gt;
   add_prediction(freq, sev) |&gt;
   mutate(premium = pred_nclaims_freq * pred_amount_sev)

# Restrictions on risk factors for region (zip)
zip_df &lt;- data.frame(zip = c(0,1,2,3), zip_rst = c(0.8, 0.9, 1, 1.2))

# Fit unrestricted model
burn &lt;- glm(premium ~ bm + zip, weights = exposure,
            family = Gamma(link = "log"), data = premium_df)

# Fit restricted model
burn_rst &lt;- burn |&gt;
  restrict_coef(restrictions = zip_df) |&gt;
  update_glm()

# Show rating factors
rating_factors(burn_rst)

## End(Not run)

</code></pre>

<hr>
<h2 id='rgammat'>Generate data from truncated gamma distribution</h2><span id='topic+rgammat'></span>

<h3>Description</h3>

<p>Random generation for the truncated Gamma distribution with
parameters shape and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgammat(n, scale = scale, shape = shape, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgammat_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rgammat_+3A_scale">scale</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="rgammat_+3A_shape">shape</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="rgammat_+3A_lower">lower</code></td>
<td>
<p>numeric. Observations below this threshold are not present in
the sample.</p>
</td></tr>
<tr><td><code id="rgammat_+3A_upper">upper</code></td>
<td>
<p>numeric. Observations above this threshold are not present in
the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the result is determined by <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='rlnormt'>Generate data from truncated lognormal distribution</h2><span id='topic+rlnormt'></span>

<h3>Description</h3>

<p>Random generation for the truncated log normal distribution
whose logarithm has mean equal to meanlog and standard deviation equal to
sdlog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlnormt(n, meanlog, sdlog, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlnormt_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rlnormt_+3A_meanlog">meanlog</code></td>
<td>
<p>mean of the distribution on the log scale</p>
</td></tr>
<tr><td><code id="rlnormt_+3A_sdlog">sdlog</code></td>
<td>
<p>standard deviation of the distribution on the log scale</p>
</td></tr>
<tr><td><code id="rlnormt_+3A_lower">lower</code></td>
<td>
<p>numeric. Observations below this threshold are not present in
the sample.</p>
</td></tr>
<tr><td><code id="rlnormt_+3A_upper">upper</code></td>
<td>
<p>numeric. Observations above this threshold are not present in
the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The length of the result is determined by <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

<hr>
<h2 id='rmse'>Root Mean Squared Error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Compute root mean squared error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_object">object</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="rmse_+3A_data">data</code></td>
<td>
<p>data.frame (defaults to NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RMSE is the square root of the average of squared differences
between prediction and actual observation and indicates
the absolute fit of the model to the data. It can be interpreted as the
standard deviation of the unexplained variance, and is in the same units
as the response variable. Lower values indicate better model fit.
</p>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- glm(nclaims ~ area, offset = log(exposure), family = poisson(),
 data = MTPL2)
rmse(x, MTPL2)

</code></pre>

<hr>
<h2 id='rows_per_date'>Find active rows per date</h2><span id='topic+rows_per_date'></span>

<h3>Description</h3>

<p>Fast overlap joins. Usually, <code>df</code> is a very large data.table
(e.g. insurance portfolio) with small interval ranges, and <code>dates</code> is much
smaller with (e.g.) claim dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows_per_date(
  df,
  dates,
  df_begin,
  df_end,
  dates_date,
  ...,
  nomatch = NULL,
  mult = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rows_per_date_+3A_df">df</code></td>
<td>
<p>data.frame with portfolio (df should include time period)</p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_dates">dates</code></td>
<td>
<p>data.frame with dates to join</p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_df_begin">df_begin</code></td>
<td>
<p>column name with begin dates of time period in <code>df</code></p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_df_end">df_end</code></td>
<td>
<p>column name with end dates of time period in <code>df</code></p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_dates_date">dates_date</code></td>
<td>
<p>column name with dates in <code>dates</code></p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_...">...</code></td>
<td>
<p>additional column names in <code>dates</code> to join by</p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_nomatch">nomatch</code></td>
<td>
<p>When a row (with interval say, <code style="white-space: pre;">&#8288;[a,b]&#8288;</code>) in x has no match in
y, nomatch=NA means NA is returned for y's non-by.y columns for that row of
x. nomatch=NULL (default) means no rows will be returned for that row of x.</p>
</td></tr>
<tr><td><code id="rows_per_date_+3A_mult">mult</code></td>
<td>
<p>When multiple rows in y match to the row in x, <code>mult</code> controls
which values are returned - &quot;all&quot; (default), &quot;first&quot; or &quot;last&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returned class is equal to class of <code>df</code>
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
portfolio &lt;- data.frame(
begin1 = ymd(c("2014-01-01", "2014-01-01")),
end = ymd(c("2014-03-14", "2014-05-10")),
termination = ymd(c("2014-03-14", "2014-05-10")),
exposure = c(0.2025, 0.3583),
premium =  c(125, 150),
car_type = c("BMW", "TESLA"))

## Find active rows on different dates
dates0 &lt;- data.frame(active_date = seq(ymd("2014-01-01"), ymd("2014-05-01"),
by = "months"))
rows_per_date(portfolio, dates0, df_begin = begin1, df_end = end,
dates_date = active_date)

## With extra identifiers (merge claim date with time interval in portfolio)
claim_dates &lt;- data.frame(claim_date = ymd("2014-01-01"),
car_type = c("BMW", "VOLVO"))

### Only rows are returned that can be matched
rows_per_date(portfolio, claim_dates, df_begin = begin1,
   df_end = end, dates_date = claim_date, car_type)

### When row cannot be matched, NA is returned for that row
rows_per_date(portfolio, claim_dates, df_begin = begin1,
   df_end = end, dates_date = claim_date, car_type, nomatch = NA)

</code></pre>

<hr>
<h2 id='smooth_coef'>Smooth coefficients in the model</h2><span id='topic+smooth_coef'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Apply smoothing on the risk factors used in the model. <code>smooth_coef()</code>
must always be followed by <code>update_glm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_coef(model, x_cut, x_org, degree = NULL, breaks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_coef_+3A_model">model</code></td>
<td>
<p>object of class glm/smooth</p>
</td></tr>
<tr><td><code id="smooth_coef_+3A_x_cut">x_cut</code></td>
<td>
<p>column name with breaks/cut</p>
</td></tr>
<tr><td><code id="smooth_coef_+3A_x_org">x_org</code></td>
<td>
<p>column name where x_cut is based on</p>
</td></tr>
<tr><td><code id="smooth_coef_+3A_degree">degree</code></td>
<td>
<p>order of polynomial</p>
</td></tr>
<tr><td><code id="smooth_coef_+3A_breaks">breaks</code></td>
<td>
<p>numerical vector with new clusters for x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although smoothing could be applied either to the frequency or
the severity model, it is more appropriate to impose the smoothing
on the premium model. This can be achieved by calculating the pure
premium for each record (i.e. expected number of claims times the expected
claim amount), then fitting an &quot;unrestricted&quot; Gamma GLM to the pure
premium, and then imposing the restrictions in a final &quot;restricted&quot;
Gamma GLM.
</p>


<h3>Value</h3>

<p>Object of class smooth
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_glm">update_glm()</a></code> for refitting the smoothed model,
and <code><a href="#topic+autoplot.smooth">autoplot.smooth()</a></code>.
</p>
<p>Other update_glm: 
<code><a href="#topic+restrict_coef">restrict_coef</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(insurancerating)
library(dplyr)

# Fit GAM for claim frequency
age_policyholder_frequency &lt;- fit_gam(data = MTPL,
                                      nclaims = nclaims,
                                      x = age_policyholder,
                                      exposure = exposure)

# Determine clusters
clusters_freq &lt;- construct_tariff_classes(age_policyholder_frequency)

# Add clusters to MTPL portfolio
dat &lt;- MTPL |&gt;
  mutate(age_policyholder_freq_cat = clusters_freq$tariff_classes) |&gt;
  mutate(across(where(is.character), as.factor)) |&gt;
  mutate(across(where(is.factor), ~biggest_reference(., exposure)))

# Fit frequency and severity model
freq &lt;- glm(nclaims ~ bm + age_policyholder_freq_cat, offset = log(exposure),
 family = poisson(), data = dat)
sev &lt;- glm(amount ~ bm + zip, weights = nclaims,
 family = Gamma(link = "log"), data = dat |&gt; filter(amount &gt; 0))

# Add predictions for freq and sev to data, and calculate premium
premium_df &lt;- dat |&gt;
  add_prediction(freq, sev) |&gt;
  mutate(premium = pred_nclaims_freq * pred_amount_sev)

# Fit unrestricted model
burn_unrestricted &lt;- glm(premium ~ zip + bm + age_policyholder_freq_cat,
                         weights = exposure,
                         family = Gamma(link = "log"),
                         data = premium_df)

# Impose smoothing and create figure
burn_unrestricted |&gt;
  smooth_coef(x_cut = "age_policyholder_freq_cat",
              x_org = "age_policyholder",
              breaks = seq(18, 95, 5)) |&gt;
  autoplot()

# Impose smoothing and refit model
burn_restricted &lt;- burn_unrestricted |&gt;
  smooth_coef(x_cut = "age_policyholder_freq_cat",
              x_org = "age_policyholder",
              breaks = seq(18, 95, 5)) |&gt;
  update_glm()

# Show new rating factors
rating_factors(burn_restricted)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.reduce'>Automatically create a summary for objects obtained from reduce()</h2><span id='topic+summary.reduce'></span>

<h3>Description</h3>

<p>Takes an object produced by <code>reduce()</code>, and counts new and lost
customers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reduce'
summary(object, ..., period = "days", name = "count")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.reduce_+3A_object">object</code></td>
<td>
<p>reduce object produced by <code>reduce()</code></p>
</td></tr>
<tr><td><code id="summary.reduce_+3A_...">...</code></td>
<td>
<p>names of columns to aggregate counts by</p>
</td></tr>
<tr><td><code id="summary.reduce_+3A_period">period</code></td>
<td>
<p>a character string indicating the period to aggregate on.
Four options are available: &quot;quarters&quot;, &quot;months&quot;, &quot;weeks&quot;, and &quot;days&quot;
(the default option)</p>
</td></tr>
<tr><td><code id="summary.reduce_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output. If omitted, it will
default to count.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='univariate'>Univariate analysis for discrete risk factors</h2><span id='topic+univariate'></span>

<h3>Description</h3>

<p>Univariate analysis for discrete risk factors in an insurance
portfolio. The following summary statistics are calculated:
</p>

<ul>
<li><p>frequency (i.e. number of claims / exposure)
</p>
</li>
<li><p>average severity (i.e. severity / number of claims)
</p>
</li>
<li><p>risk premium (i.e. severity / exposure)
</p>
</li>
<li><p>loss ratio (i.e. severity / premium)
</p>
</li>
<li><p>average premium (i.e. premium / exposure)
</p>
</li></ul>

<p>If input arguments are not specified, the summary statistics related to
these arguments are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate(
  df,
  x,
  severity = NULL,
  nclaims = NULL,
  exposure = NULL,
  premium = NULL,
  by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_+3A_df">df</code></td>
<td>
<p>data.frame with insurance portfolio</p>
</td></tr>
<tr><td><code id="univariate_+3A_x">x</code></td>
<td>
<p>column in <code>df</code> with risk factor, or use <code>vec_ext()</code> for use with
an external vector (see examples)</p>
</td></tr>
<tr><td><code id="univariate_+3A_severity">severity</code></td>
<td>
<p>column in <code>df</code> with severity (default is NULL)</p>
</td></tr>
<tr><td><code id="univariate_+3A_nclaims">nclaims</code></td>
<td>
<p>column in <code>df</code> with number of claims (default is NULL)</p>
</td></tr>
<tr><td><code id="univariate_+3A_exposure">exposure</code></td>
<td>
<p>column in <code>df</code> with exposure (default is NULL)</p>
</td></tr>
<tr><td><code id="univariate_+3A_premium">premium</code></td>
<td>
<p>column in <code>df</code> with premium (default is NULL)</p>
</td></tr>
<tr><td><code id="univariate_+3A_by">by</code></td>
<td>
<p>list of column(s) in <code>df</code> to group by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Summarize by `area`
univariate(MTPL2, x = area, severity = amount, nclaims = nclaims,
           exposure = exposure, premium = premium)

# Summarize by `area`, with column name in external vector
xt &lt;- "area"
univariate(MTPL2, x = vec_ext(xt), severity = amount, nclaims = nclaims,
           exposure = exposure, premium = premium)

# Summarize by `zip` and `bm`
univariate(MTPL, x = zip, severity = amount, nclaims = nclaims,
           exposure = exposure, by = bm)

# Summarize by `zip`, `bm` and `power`
univariate(MTPL, x = zip, severity = amount, nclaims = nclaims,
           exposure = exposure, by = list(bm, power))

</code></pre>

<hr>
<h2 id='update_formula_add'>Create new offset-term and new formula</h2><span id='topic+update_formula_add'></span>

<h3>Description</h3>

<p>Create new offset-term and new formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_formula_add(offset_term, fm_no_offset, add_term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_formula_add_+3A_offset_term">offset_term</code></td>
<td>
<p>String obtained from get_offset()</p>
</td></tr>
<tr><td><code id="update_formula_add_+3A_fm_no_offset">fm_no_offset</code></td>
<td>
<p>Obtained from remove_offset_formula()</p>
</td></tr>
<tr><td><code id="update_formula_add_+3A_add_term">add_term</code></td>
<td>
<p>Name of restricted risk factor to add</p>
</td></tr>
</table>

<hr>
<h2 id='update_glm'>Refitting Generalized Linear Models</h2><span id='topic+update_glm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>update_glm()</code> is used to refit generalized linear models, and must be
preceded by <code>restrict_coef()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_glm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_glm_+3A_x">x</code></td>
<td>
<p>Object of class restricted or of class smooth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class GLM
</p>


<h3>Author(s)</h3>

<p>Martin Haringa
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
