<!DOCTYPE html><html><head><title>Help for package RGCxGC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RGCxGC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aligned_GCxGC-class'><p>Subclass aligned_GCxGC</p></a></li>
<li><a href='#baseline_corr'><p>Two-dimensional baseline correction</p></a></li>
<li><a href='#batch_2DCOW'><p>Two-dimensional COW in batch.</p></a></li>
<li><a href='#batch_2DCOW-class'><p>Subclass batch_2DCOW</p></a></li>
<li><a href='#dephase_chrom'><p>Method dephase_chrom</p></a></li>
<li><a href='#GCxGC-class'><p>Class GCxGC</p></a></li>
<li><a href='#get_metadata'><p>Method get_metadata</p></a></li>
<li><a href='#join_chromatograms'><p>Join multiple two-dimensional chromatograms into a single R object</p></a></li>
<li><a href='#joined_chrom-class'><p>Class joined_chrom</p></a></li>
<li><a href='#m_prcomp'><p>Multiway Principal Component Analysis</p></a></li>
<li><a href='#make_loadings'><p>Import foreign model loadings</p></a></li>
<li><a href='#MPCA-class'><p>Subclass MPCA</p>
subclass for Multiway Principal Component Analysis object</a></li>
<li><a href='#MTBLS579'><p>Chromatograms from Dioagnostic Metabolite Biomarkers</p>
of Chronic Typhoid Carraige study</a></li>
<li><a href='#Myrothecium'><p>Microbial metabolism kinetics of <em>Myrothecium sp.</em></p></a></li>
<li><a href='#plot'><p>Method plot</p></a></li>
<li><a href='#plot_loading'><p>Plot two-dimensional MPCA loadings</p></a></li>
<li><a href='#PLSDA-class'><p>Subclass PLSDA</p></a></li>
<li><a href='#preproc_GCxGC-class'><p>Subclass preproc_GCxGC</p></a></li>
<li><a href='#print_mpca'><p>Print MPCA summary</p></a></li>
<li><a href='#projected-class'><p>Class projected</p></a></li>
<li><a href='#raw_GCxGC-class'><p>Subclass raw_GCxGC</p></a></li>
<li><a href='#read_chrom'><p>Read two-dimensional chromatogram</p></a></li>
<li><a href='#reference_chrom'><p>Make reference chromatogram</p></a></li>
<li><a href='#scores'><p>Method plot_scores</p></a></li>
<li><a href='#set_metadata'><p>Set the metadata for a joined_chrom</p></a></li>
<li><a href='#twod_cow'><p>Two-dimensional correlation optimized warping alignment</p></a></li>
<li><a href='#unfold_chrom'><p>Unfold two-dimensional chromatograms</p></a></li>
<li><a href='#wsmooth'><p>Two-dimensional smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Preprocessing and Multivariate Analysis of Bidimensional Gas
Chromatography Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cristian Quiroz-Moreno &lt;cristianquirozd1997@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolbox for chemometrics analysis of bidimensional gas 
    chromatography data. This package import data for common scientific data
    format (NetCDF) and fold it to 2D chromatogram. Then, it can perform
    preprocessing and multivariate analysis. In the preprocessing algorithms,
    baseline correction, smoothing, and peak alignment are available.
    While in multivariate analysis, multiway principal component analysis is
    incorporated.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DanielQuiroz97/RGCxGC">https://github.com/DanielQuiroz97/RGCxGC</a>,
<a href="https://danielquiroz97.github.io/RGCxGC/">https://danielquiroz97.github.io/RGCxGC/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DanielQuiroz97/RGCxGC/issues">https://github.com/DanielQuiroz97/RGCxGC/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>colorRamps, Rdpack, stats, methods, graphics</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), RNetCDF, ptw</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, lattice, prettydoc,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-13 20:44:01 UTC; quirozmoreno.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Cristian Quiroz-Moreno
    <a href="https://orcid.org/0000-0002-9069-9147"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Guilherme L. Alexandrino
    <a href="https://orcid.org/0000-0002-2007-378X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Noroska G.S. Mogoll√≥n
    <a href="https://orcid.org/0000-0002-0756-6184"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-14 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aligned_GCxGC-class'>Subclass aligned_GCxGC</h2><span id='topic+aligned_GCxGC-class'></span>

<h3>Description</h3>

<p>Subclass <em>aligned_GCxGC</em> are contained in <em>raw_GCxGC</em> super class.
It is not contained in the <em>prepec_GCxGC</em> due to raw chromatograms can
be aligned without a previous preproccesing technique. Although, it can
improve the performance of the aligment, but it is not mandatory.
</p>


<h3>Details</h3>

<p>You can perform the aligment after some preprocessing technique as:
baseline correction, or signal smoothing to imporve the performance of the
alignment function.
</p>

<hr>
<h2 id='baseline_corr'>Two-dimensional baseline correction</h2><span id='topic+baseline_corr'></span>

<h3>Description</h3>

<p>'baseline_corr' provides a two-dimensional baseline correction
by using the asymmetric least squares algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseline_corr(chromatogram, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseline_corr_+3A_chromatogram">chromatogram</code></td>
<td>
<p>a <em>raw_GCxGC</em> object.</p>
</td></tr>
<tr><td><code id="baseline_corr_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="ptw.html#topic+baseline.corr">baseline.corr</a></code>
function in the pwt package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a raw two-dimensional chromatogram and performs
the baseline correction  with the implemented function in
<code><a href="ptw.html#topic+baseline.corr">baseline.corr</a></code>  (Eilers 2004).
</p>


<h3>References</h3>

<p>Eilers PH (2004).
&ldquo;Parametric Time Warping.&rdquo;
<em>Analytical Chemistry</em>, <b>76</b>(2), 404&ndash;411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(colorRamps)
chrom_name &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
chrom_2D &lt;- read_chrom(chrom_name, 5L)
chrom_bsline &lt;- baseline_corr(chrom_2D)
plot(chrom_bsline, nlevels = 150,
           color.palette = matlab.like)

</code></pre>

<hr>
<h2 id='batch_2DCOW'>Two-dimensional COW in batch.</h2><span id='topic+batch_2DCOW'></span>

<h3>Description</h3>

<p>'batch_2DCOW' perform two-dimensional correlation optimized warping
alignment in batch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_2DCOW(reference, sample_chroms, segments, max_warp, add_ref = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_2DCOW_+3A_reference">reference</code></td>
<td>
<p>a GCxGC chromatogram which will be taken as the reference 
chromatogram.</p>
</td></tr>
<tr><td><code id="batch_2DCOW_+3A_sample_chroms">sample_chroms</code></td>
<td>
<p>a named list with the sample chromatograms which will
be aligned against to the reference chromatogram.</p>
</td></tr>
<tr><td><code id="batch_2DCOW_+3A_segments">segments</code></td>
<td>
<p>a two integer vector with the number of segments
which the first and second dimension will be divided, respectively.</p>
</td></tr>
<tr><td><code id="batch_2DCOW_+3A_max_warp">max_warp</code></td>
<td>
<p>a two integer vector with the maximum warping parameter for
the first and second dimension</p>
</td></tr>
<tr><td><code id="batch_2DCOW_+3A_add_ref">add_ref</code></td>
<td>
<p>a logical indicating if the reference chromatogram will
be joined together with the sample chromatograms. By the fault add_ref = F.
If add_ref is set to T, the provide reference chromatogram will 
be included as another sample chromatogram in the downstream analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument is the reference chromatogram which other chromatograms
will aligned against to. Then, a named list is needed for the sample_chroms
argument. Each chromatogram in this list will be aligned using the reference
chromatogram. By default, the reference chromatogram will be not included in
the subsequent analysis, such as MPCA. If you would like to add the reference
chromatogram, then add_ref = T.
</p>
<p>This is an adaptation of two-dimensional COW alignment, firstly implemented
in MATLAB. This function takes a set of samples chromatogram to be aligned 
against to the reference. The argument [segment] will be used 
to split the whole chromatogram in <em>n</em> and <em>m</em> parts in the first
and the second dimension, respectively. The [max_warp] argument provides
the maximum tolerance of the signal transformation for the first and the
second dimension, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Read Sample chromatogram
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
MTBLS08 &lt;- read_chrom(GB08_fl, mod_time = 5)

# Read reference chromatogram
GB09_fl &lt;- system.file("extdata", "09GB.cdf", package = "RGCxGC")
MTBLS09 &lt;- read_chrom(GB09_fl, mod_time = 5)

# Create a named list
# MTBLS08 will be repeated for exemplification
# Considerer that chromatograms are renamed considering the list names
batch_samples &lt;- list(Chrom1 = MTBLS08, Chrom2 = MTBLS08)


# Perform batch 2DCOW alignment
# Add the reference chromatogram as another sample
batch_alignment &lt;- batch_2DCOW(MTBLS09, batch_samples,
                               c(10, 40), c(1, 10), add_ref = TRUE)
# Exclude the reference chromatogram in the sample chromatogram set
batch_alignment &lt;- batch_2DCOW(MTBLS09, batch_samples, c(10, 40), c(1, 10))


</code></pre>

<hr>
<h2 id='batch_2DCOW-class'>Subclass batch_2DCOW</h2><span id='topic+batch_2DCOW-class'></span>

<h3>Description</h3>

<p>Subclass <em>batch_2DCOW</em> are contained in <em>raw_GCxGC</em> super
class. <em>batch_2DCOW</em> contains multiple aligned chromatograms, which the
first one is the reference chromatogram.
</p>


<h3>Details</h3>

<p>You can perform the alignment after some preprocessing technic as:
baseline correction, or signal smothing to improve the performance of the
aligment function, or with the raw chromatogram.
</p>

<hr>
<h2 id='dephase_chrom'>Method dephase_chrom</h2><span id='topic+dephase_chrom'></span><span id='topic+dephase_chrom+2CGCxGC-method'></span>

<h3>Description</h3>

<p>'dephase_chrom' shifts the retention time in the second
dimension of the two-dimensional chromatogram. This procedure is usually
applied in cases when part of peaks is splited in at the final and beginning
of the second dimension. Also, the solvent effect and column bleeding can
be removing by dephasing the chromatogram. The dephasing procedure is
performing by splitting the chromagram with the relative value provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dephase_chrom(Object, rel_dephase)

## S4 method for signature 'GCxGC'
dephase_chrom(Object, rel_dephase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dephase_chrom_+3A_object">Object</code></td>
<td>
<p>a GCxGC class object</p>
</td></tr>
<tr><td><code id="dephase_chrom_+3A_rel_dephase">rel_dephase</code></td>
<td>
<p>a numeric value from 0 to 100 with the relative dephasing
position.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> 
 library(colorRamps)
 GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
 GB08 &lt;- read_chrom(GB08_fl, 5L)
 plot(GB08, nlevels = 150, color.palette = matlab.like,
      main = "No dephased chromatogram")
 GB08_d25 &lt;- dephase_chrom(GB08, 25)
 plot(GB08_d25, nlevels = 150, color.palette = matlab.like,
      main = "25% dephased chromatogram")
 
</code></pre>

<hr>
<h2 id='GCxGC-class'>Class GCxGC</h2><span id='topic+GCxGC-class'></span>

<h3>Description</h3>

<p>Class <em>GCxGC</em> defines the superclass of two-dimensional comprehensive
gas chromatographic data.
</p>


<h3>Details</h3>

<p>The validity function evaluates if the provided file can be readed as a 
NetCDF file. The validation function employs the function 
<code><a href="RNetCDF.html#topic+open.nc">open.nc</a></code> to check if the provided file inherits to
the NetCDF class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>the name of a NetCDF file where the data will be retrieved from.</p>
</dd>
<dt><code>mod_time</code></dt><dd><p>a integer with the modulation time for the second dimension.</p>
</dd>
</dl>

<hr>
<h2 id='get_metadata'>Method get_metadata</h2><span id='topic+get_metadata'></span><span id='topic+get_metadata+2Cjoined_chrom-method'></span><span id='topic+get_metadata+2CGCxGC-method'></span>

<h3>Description</h3>

<p>'get_metadata' retrieves the metadata contained in a
joined_chrom object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata(chroms)

## S4 method for signature 'joined_chrom'
get_metadata(chroms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metadata_+3A_chroms">chroms</code></td>
<td>
<p>a joined_chrom object created by
joined_chrom function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accesses to the <em>groups</em> slot created by the
joined_chrom function. The <em>Names</em> are the names of the
chromatograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Myrothecium)
myr_data &lt;- get_metadata(Myrothecium)
myr_data
</code></pre>

<hr>
<h2 id='join_chromatograms'>Join multiple two-dimensional chromatograms into a single R object</h2><span id='topic+join_chromatograms'></span>

<h3>Description</h3>

<p>'join_chromatograms' saves chromatograms in a
named list slot. Also, it saves information like metadata and 
retention times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_chromatograms(x, y, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_chromatograms_+3A_x">x</code>, <code id="join_chromatograms_+3A_y">y</code></td>
<td>
<p>a GCxGC object, either single or batch chromatograms.</p>
</td></tr>
<tr><td><code id="join_chromatograms_+3A_groups">groups</code></td>
<td>
<p>a data.frame containing the metadata. It must have a column
named as <em>Names</em> to merge with the imported chromatograms.</p>
</td></tr>
<tr><td><code id="join_chromatograms_+3A_...">...</code></td>
<td>
<p>other GCxGC objects to be merged</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
GB09_fl &lt;- system.file("extdata", "09GB.cdf", package = "RGCxGC")
GB08 &lt;- read_chrom(GB08_fl, 5L)
GB09 &lt;- read_chrom(GB09_fl, 5L)
join_gc &lt;- join_chromatograms(GB08, GB09)
metadata &lt;- data.frame(Names = c("GB08", "GB09"),
                       Type = c("Control", "Treatment"))
join_metadata &lt;- join_chromatograms(GB08, GB09, groups = metadata)
</code></pre>

<hr>
<h2 id='joined_chrom-class'>Class joined_chrom</h2><span id='topic+joined_chrom-class'></span>

<h3>Description</h3>

<p>Class <em>joined_chrom</em> defines the superclass to gather single
chromatogram, as well as batch chromatograms into a single list, prior to
multiway principal compoment analysis or unfolding them.
</p>


<h3>Slots</h3>


<dl>
<dt><code>chromatograms</code></dt><dd><p>a named list with all chromatograms.</p>
</dd>
<dt><code>time</code></dt><dd><p>the time range of the chromatographic run</p>
</dd>
<dt><code>groups</code></dt><dd><p>a data.frame containing the experiment metadata with
a column named as <em>Names</em>.</p>
</dd>
<dt><code>mod_time</code></dt><dd><p>modulation time of the second dimension</p>
</dd>
</dl>

<hr>
<h2 id='m_prcomp'>Multiway Principal Component Analysis</h2><span id='topic+m_prcomp'></span>

<h3>Description</h3>

<p>'m_prcomp' Performs a multiway principal components analysis on a given
two-dimensional chromatograms and returns the results as object of class
MPCA.
Before to perform the calculation, each given chromatogramas are unfolded
to a single dimension. All chromatograms are merged and principal component 
analysis is performed with the built-in <code><a href="stats.html#topic+prcomp">prcomp</a></code> function.
The print method for these objects prints the summary of the analysis.
This algorithm was first presented by (Wold et al. 1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_prcomp(chrom, center = FALSE, scale = FALSE, npcs = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_prcomp_+3A_chrom">chrom</code></td>
<td>
<p>Multiple chromatograms read or batch aligned</p>
</td></tr>
<tr><td><code id="m_prcomp_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether the variables should be
shifted to be zero centered. FALSE is set by default.</p>
</td></tr>
<tr><td><code id="m_prcomp_+3A_scale">scale</code></td>
<td>
<p>a logical value indicating whether the variables should
be scaled to have unit variance before the analysis takes place. The
default is FALSE.</p>
</td></tr>
<tr><td><code id="m_prcomp_+3A_npcs">npcs</code></td>
<td>
<p>an integer indicating how many principals components are
desired to maintain. The default is 3 principal components.</p>
</td></tr>
<tr><td><code id="m_prcomp_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stats.html#topic+prcomp">prcomp</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MPCA returns a list whit class &quot;MPCA&quot; containing the summary of the
analysis, the scores matrix, unfolded loadings, and the metadata if it
was provided when chromatograms were joined.
</p>


<h3>References</h3>

<p>Wold S, Geladi P, Esbensen K, √ñhman J (1987).
&ldquo;Multi-way principal components- and PLS-analysis.&rdquo;
<em>Journal of Chemometrics</em>, <b>1</b>(January 1986), 41&ndash;56.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(MTBLS579)

# Perform multiway principal component analysis
MTBLS579_mpca &lt;- m_prcomp(MTBLS579, center = TRUE)
# Print MPCA summary
print(MTBLS579_mpca)
# Retrieve MPCA scores
scores(MTBLS579_mpca)
# Plot bidimensional scores
plot_loading(MTBLS579_mpca)


</code></pre>

<hr>
<h2 id='make_loadings'>Import foreign model loadings</h2><span id='topic+make_loadings'></span>

<h3>Description</h3>

<p>'make_loading' method takes the loading matrix obtained
by a mixOmixs package and fold them into two-dimensional matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_loadings(floadings, time, mod_time, acq_rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_loadings_+3A_floadings">floadings</code></td>
<td>
<p>a numeric matrix with foreign loadings. With variables in
columns and eigenvalues as rows.</p>
</td></tr>
<tr><td><code id="make_loadings_+3A_time">time</code></td>
<td>
<p>a vector of length two with the time range of the
chromatographic run</p>
</td></tr>
<tr><td><code id="make_loadings_+3A_mod_time">mod_time</code></td>
<td>
<p>the modulation time of the second dimension.</p>
</td></tr>
<tr><td><code id="make_loadings_+3A_acq_rate">acq_rate</code></td>
<td>
<p>the acquisition rate of the mass analyzer. 
The acquisition rate  is printed when read_chrom function is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We strongly recommend to use the plsda function in the mixOmics
package to perform partial least squares-discriminant analysis. The result
of this model is a list containing a loading matrix.
The method retrieves a matrix A with <em>m</em> and <em>n</em> dimensions.
Where <em>m</em> is the eigenvalues and <em>n</em>
is the number of loadings which the model returns.
</p>

<hr>
<h2 id='MPCA-class'>Subclass MPCA
subclass for Multiway Principal Component Analysis object</h2><span id='topic+MPCA-class'></span>

<h3>Description</h3>

<p>Subclass MPCA
subclass for Multiway Principal Component Analysis object
</p>


<h3>Slots</h3>


<dl>
<dt><code>scores</code></dt><dd><p>A matrix with the eigenvalues of projected chromatograms
into principal components space.</p>
</dd>
</dl>

<hr>
<h2 id='MTBLS579'>Chromatograms from Dioagnostic Metabolite Biomarkers 
of Chronic Typhoid Carraige study</h2><span id='topic+MTBLS579'></span>

<h3>Description</h3>

<p>The dataset was retrieved from MetaboLights with the 
identifier number MTBLS79 <a href="https://www.ebi.ac.uk/metabolights/MTBLS579">https://www.ebi.ac.uk/metabolights/MTBLS579</a>.
Two groups from the entire study was downloaded: control and <em>S. typhi</em>
carriage. The name files of control group are: 08GB, 09GB, and 14GB,
which has the following native name 08_GB.cdf, 14_GB.cdf, and 09_GB.cdf in the
MetaboLights database. For the <em>S. typhi</em> group the names are:
34GB, 24GB, 29GB, which has the native name of 34_GB.cdf, 24_GB.cdf and
29_GB.cdf in MetaboLights database.
</p>
<p>Due to the large size of chromatograms, these data is a subset of the whole
chromatograms from 7 min to 18 min of chromatografic run. If you would
like to acces the whole formated chromatograms, please go to 
<a href="https://github.com/DanielQuiroz97/MTBLS579">https://github.com/DanielQuiroz97/MTBLS579</a>.
</p>
<p>The original study was developed by
N√§sstr√∂m et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MTBLS579)
</code></pre>


<h3>Format</h3>

<p>A joined_chrom object containing four slots:
</p>

<dl>
<dt>chromatograms</dt><dd><p>A named list with the two-dimensional chromatograms</p>
</dd>
<dt>groups</dt><dd><p>The metadata containing two varaibles and six observations</p>
</dd>
<dt>time</dt><dd><p>The retantion time range of the chromatographic run</p>
</dd>
<dt>mod_time</dt><dd><p>The modulation time</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ebi.ac.uk/metabolights/MTBLS579">https://www.ebi.ac.uk/metabolights/MTBLS579</a>
</p>


<h3>References</h3>

<p>N√§sstr√∂m E, Jonsson P, Johansson A, Dongol S, Karkey A, Basnyat B, Tran Vu Thieu N, Trinh Van T, Thwaites GE, Antti H, Baker S (2018).
&ldquo;Diagnostic metabolite biomarkers of chronic typhoid carriage.&rdquo;
<em>PLoS Neglected Tropical Diseases</em>, <b>12</b>(1), 1&ndash;15.
</p>

<hr>
<h2 id='Myrothecium'>Microbial metabolism kinetics of <em>Myrothecium sp.</em></h2><span id='topic+Myrothecium'></span>

<h3>Description</h3>

<p>This object contains six chromatograms of the microbial
metabolic kinetics. <em>Myrothecium sp.</em> were cultured in CMA.
Inoculation was made from Petri dishes with the fully-grown fungal cells and
sterile distilled water (to wash the surface of the plate). The plate was 
scraped with a sterile glass handle to obtain the spore suspension.
The suspension was liquated and the concentration of 2.4 x 105 spores/mL was
determined using a Neubauer chamber and an optical microscope. Then, 50 uL
of the suspension was inoculated in a flow chamber into the tubes containing
the culture medium. Tubes were kept at 25 celsius degree in a growth
chamber with 12h of photoperiod. 
</p>
<p>A solid-phase microextraction (SPME) assay containing a
DVB / CAR / PDMS (Divinylbenzene / Carboxene / Polymethylsiloxane 50/30 mm)
fiber was placed into the tube headspace.
</p>
<p>A set of columns consisting of HP-5MS 30m x 0.25mm x 0.25 um
connected to a Supelcowax 1m x 0.10mm √ó 0.10um 
with a 1m x 0.25mm deactivated silica capillary being allocated between
them. In these tests, a modulation period of 5s was used.
</p>
<p>For GCxGC-QMS data acquisition, GCMSsolution version 5.3 software was used.
The temperature program were 60-165 celcius at 3 celcius/min;
165 celcius - 260celcius at 20 celcius/min; 260 celcius (5 min);
flow rate was 0.6 mL/min (Helium 5.0 carrier gas); splitless injection mode,
ion source temperature 200 celcius, interface temperature
260 celcius; voltage 0,9 kV; mass range 50-380 m/z; acquisition rate 25Hz and
electron ionization (70eV).
</p>
<p>The original study was developed by
Quiroz-Moreno et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Myrothecium)
</code></pre>


<h3>Format</h3>

<p>A joined_chrom object containing four slots:
</p>

<dl>
<dt>chromatograms</dt><dd><p>A named list with the two-dimensional chromatograms</p>
</dd>
<dt>groups</dt><dd><p>The metadata containing two varaibles and six observations</p>
</dd>
<dt>time</dt><dd><p>The retantion time range of the chromatographic run</p>
</dd>
<dt>mod_time</dt><dd><p>The modulation time</p>
</dd>
</dl>



<h3>References</h3>

<p>Quiroz-Moreno C, Furlan MF, Belinato JR, Augusto F, Alexandrino GL, Mogoll√≥n NGS (2020).
&ldquo;RGCxGC toolbox: An R-package for data processing in comprehensive two-dimensional gas chromatography-mass spectrometry.&rdquo;
<em>Microchemical Journal</em>, <b>156</b>, 104830.
</p>

<hr>
<h2 id='plot'>Method plot</h2><span id='topic+plot'></span><span id='topic+plot+2CGCxGC-method'></span>

<h3>Description</h3>

<p>'plot' plot the two-dimensional chromatogram as a contour plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(Object, type = "f", ...)

## S4 method for signature 'GCxGC'
plot(Object, type = "f", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_object">Object</code></td>
<td>
<p>a GCxGC chromatogram, it can be a raw, or preprocessed
chromatogram.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>a character indicating the type of chromatogram representation.
By default, type = &quot;f&quot; for <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> function,
if type = &quot;c&quot; only contours or isolines will be displayed by using the
<code><a href="graphics.html#topic+contour">contour</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>
or <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> function, it depends on the value
of the <em>type</em> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plot function employs the built-in contour function. As
mentioned in Reichenbach et al. (2004), interpolation
is used to display non-native GCxGC data.
</p>


<h3>References</h3>

<p>Reichenbach SE, Ni M, Kottapalli V, Visvanathan A (2004).
&ldquo;Information technologies for comprehensive two-dimensional gas chromatography.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>71</b>(2), 107&ndash;120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(colorRamps)
chrom_name &lt;-  system.file("extdata", "08GB.cdf", package = "RGCxGC")
chrom_2D &lt;- read_chrom(chrom_name, 5L)
plot(chrom_2D, nlevels = 150, color.palette = matlab.like)
plot(chrom_2D, type = "c", nlevels = 50, col = matlab.like(30))
</code></pre>

<hr>
<h2 id='plot_loading'>Plot two-dimensional MPCA loadings</h2><span id='topic+plot_loading'></span><span id='topic+plot_loading+2Cprojected-method'></span><span id='topic+plot_loading+2CMPCA-method'></span>

<h3>Description</h3>

<p>'plot_loading' plot the loading of the a MPCA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_loading(Object, type = "n", pc = 1, thresh, ...)

## S4 method for signature 'projected'
plot_loading(Object, type = "b", pc = 1, thresh, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_loading_+3A_object">Object</code></td>
<td>
<p>a MPCA object</p>
</td></tr>
<tr><td><code id="plot_loading_+3A_type">type</code></td>
<td>
<p>the value type of loadings, <em>p</em> for positive, 
<em>n</em> for negative, and <em>b</em> for negative and positive 
loading values.</p>
</td></tr>
<tr><td><code id="plot_loading_+3A_pc">pc</code></td>
<td>
<p>the principal component to plot.</p>
</td></tr>
<tr><td><code id="plot_loading_+3A_thresh">thresh</code></td>
<td>
<p>numerical value. A threshold to remove low loading values.</p>
</td></tr>
<tr><td><code id="plot_loading_+3A_...">...</code></td>
<td>
<p>Other parameters passes to <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the loadings of MPCA and eval if a certain
variable was removed previous compute de MPCA and it fills the removed
variables with zero. Then, the loadings are plotted considering one
principle component at a time as a two-dimensional chromatogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(colorRamps)
data(MTBLS579)
# MPCA with mean-centered and scaled data
MTBLS579_mpca &lt;- m_prcomp(MTBLS579)
# Negative loadings of the first principal component

plot_loading(MTBLS579_mpca, type = "n", pc = 1,
             color.palette = matlab.like)
# Positive loadings of the first principal component
plot_loading(MTBLS579_mpca, type = "p", pc = 1,
             color.palette = matlab.like)

</code></pre>

<hr>
<h2 id='PLSDA-class'>Subclass PLSDA</h2><span id='topic+PLSDA-class'></span>

<h3>Description</h3>

<p>Class <em>PLSDA</em> defines the class to import foreign results of 
partial least squares-discriminant analysis performed with
mixOmics package.
</p>

<hr>
<h2 id='preproc_GCxGC-class'>Subclass preproc_GCxGC</h2><span id='topic+preproc_GCxGC-class'></span>

<h3>Description</h3>

<p>Subclass <em>preproc_GCxGC</em> are contained in <em>raw_GCxGC</em> super class.
It contains a dedicated slot to storage the preprocessed two-dimensional
chromatogram.
</p>


<h3>Details</h3>

<p>After reading a two-dimensional chromatogram, you can perform serveral
preprocessing techniques such as smoothing or baseline correction.
This action will create an object of a preproc_GCxGC subclass.
</p>

<hr>
<h2 id='print_mpca'>Print MPCA summary</h2><span id='topic+print_mpca'></span><span id='topic+print_mpca+2CMPCA-method'></span>

<h3>Description</h3>

<p>'print_mpca' call the MPCA object to print the summary of this
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_mpca(Object)

## S4 method for signature 'MPCA'
print_mpca(Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_mpca_+3A_object">Object</code></td>
<td>
<p>a MPCA object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot function employs the built-in print function and a
precomputed MPCA summary to display the explained and cumulative variance
for each principal component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(MTBLS579)
MTBLS_mpca &lt;- m_prcomp(MTBLS579, center = TRUE)
print_mpca(MTBLS_mpca)
</code></pre>

<hr>
<h2 id='projected-class'>Class projected</h2><span id='topic+projected-class'></span>

<h3>Description</h3>

<p>The <em>projected</em> class defines the superclass for projection methods,
specially for multiway principal component analysis and discriminant
analysis based on partial least squares. The class represents the 
convergence of in-package results (m_prcomp) and the foreing 
building model (PLS-DA) procedure.
</p>


<h3>Slots</h3>


<dl>
<dt><code>loadings</code></dt><dd><p>The eigenvectors of each principal component.</p>
</dd>
<dt><code>time</code></dt><dd><p>The time range of chromatographic run</p>
</dd>
<dt><code>mod_time</code></dt><dd><p>modulation time of the second dimension</p>
</dd>
</dl>

<hr>
<h2 id='raw_GCxGC-class'>Subclass raw_GCxGC</h2><span id='topic+raw_GCxGC-class'></span>

<h3>Description</h3>

<p>Subclass <em>raw_GCxGC</em> are contained in <em>GCxGC</em> super class. It
contains a dedicated slot to storage the folded two-dimensional chromatogram.
</p>


<h3>Details</h3>

<p>In the first creation of a <em>raw_GCxGC</em> object, the slot for the
chromatogram is not created yet. To read and fold the chromatogram 
use the <code><a href="#topic+read_chrom">read_chrom</a></code>  function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>chromatogram</code></dt><dd><p>a numeric matrix.</p>
</dd>
<dt><code>time</code></dt><dd><p>a vector of two elements with the range of the first dimenstion
run time</p>
</dd>
</dl>

<hr>
<h2 id='read_chrom'>Read two-dimensional chromatogram</h2><span id='topic+read_chrom'></span>

<h3>Description</h3>

<p>'read_GCxGC' returns a <em>raw_GCxGC</em> with the sample name, the modulation
time, the chromatographic time range and the two-dimensional chromatogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_chrom(
  name,
  mod_time,
  sam_rate,
  per_eval = 0.1,
  x_cut = NULL,
  y_cut = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_chrom_+3A_name">name</code></td>
<td>
<p>a name of the NetCDF file where the data is allocated.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_mod_time">mod_time</code></td>
<td>
<p>a integer, the modulation time of the chromatographic run.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_sam_rate">sam_rate</code></td>
<td>
<p>a integer, the sampling rate of the equipment.
If sam_rate is missing, the sampling rate is calculated by the dividing 1 by
the difference of two adjacent scan time.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_per_eval">per_eval</code></td>
<td>
<p>a double between 0 and 1, with the percentage of the run time
records to be evaluated if the sampling rate is homogeneous.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_x_cut">x_cut</code></td>
<td>
<p>a vector with two elements representing the retention time range
to be mantained in the first dimension.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_y_cut">y_cut</code></td>
<td>
<p>a vector with two elements representing the retention time range
to be mantained in the second dimension.</p>
</td></tr>
<tr><td><code id="read_chrom_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating if the information of chromatogram is
printted in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads the NetCDF file and retrieves values in the
<em>total_intensity</em> array. Then, with the provided sampling rate and
modulation time, the chromatogram is folded into a numerical matrix,
representing the two-dimensional chromatogram. This function is an
adaptation of the presented routine by Skov and Bro (2008).
</p>


<h3>References</h3>

<p>Skov T, Bro R (2008).
&ldquo;Solving fundamental problems in chromatographic analysis.&rdquo;
<em>Analytical and Bioanalytical Chemistry</em>, <b>390</b>(1), 281&ndash;285.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
GB08 &lt;- read_chrom(GB08_fl, 5L)

</code></pre>

<hr>
<h2 id='reference_chrom'>Make reference chromatogram</h2><span id='topic+reference_chrom'></span>

<h3>Description</h3>

<p>'reference_chrom' makes a reference chromatogram by calculating a statistic
of multiple chromatograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reference_chrom(chromatograms, stat = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reference_chrom_+3A_chromatograms">chromatograms</code></td>
<td>
<p>a joined_chrom object.</p>
</td></tr>
<tr><td><code id="reference_chrom_+3A_stat">stat</code></td>
<td>
<p>a character with the name of the mathematical function that
pixels will be subjected to. By default, (stat = &quot;mean&quot;) the new reference
chromatogram will be the result of the provided mathematical function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to create a consensus chromatogram to be used
as a reference in the peak alignment process. In other words, multiple
chromatograms will be subjected to a mathematical function, such as min, max,
or mean in order to create a representative chromatogram.
Then, the new chromatogram will be used as a template and the other
chromatograms will be aligned against it. This function overlap pixels with
the same chromatogram index and computes a desired mathematical function for
each pixel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read chromatogram 1
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
MTBLS08 &lt;- read_chrom(GB08_fl, mod_time = 5)

# Read chromatogram 2
GB09_fl &lt;- system.file("extdata", "09GB.cdf", package = "RGCxGC")
MTBLS09 &lt;- read_chrom(GB09_fl, mod_time = 5)

# Join chromatograms
joined &lt;-  join_chromatograms(MTBLS08, MTBLS09)
reference &lt;- reference_chrom(joined, stat = "mean")
plot(reference, main = "Reference chromaogram")
</code></pre>

<hr>
<h2 id='scores'>Method plot_scores</h2><span id='topic+scores'></span><span id='topic+scores+2CMPCA-method'></span>

<h3>Description</h3>

<p>'scores' exports the scores matrix of a MPCA
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(Object)

## S4 method for signature 'MPCA'
scores(Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_object">Object</code></td>
<td>
<p>a MPCA object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the whole MPCA object and retrieves the score
matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(MTBLS579)
# MPCA with mean-centered and scaled data
MTBLS579_mpca &lt;- m_prcomp(MTBLS579, center = TRUE)
# Export scores matrix
scores(MTBLS579_mpca)
</code></pre>

<hr>
<h2 id='set_metadata'>Set the metadata for a joined_chrom</h2><span id='topic+set_metadata'></span><span id='topic+set_metadata+2Cjoined_chrom+2Cdata.frame-method'></span><span id='topic+set_metadata+2CGCxGC-method'></span>

<h3>Description</h3>

<p>'set_metadata' fill metadata slot of a joined_chrom object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_metadata(Object, metadata)

## S4 method for signature 'joined_chrom,data.frame'
set_metadata(Object, metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_metadata_+3A_object">Object</code></td>
<td>
<p>a joined_chrom object</p>
</td></tr>
<tr><td><code id="set_metadata_+3A_metadata">metadata</code></td>
<td>
<p>a data.frame containing the metadata. It must have a column
named as <em>Names</em> to merge with the chromatograms.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
GB09_fl &lt;- system.file("extdata", "09GB.cdf", package = "RGCxGC")
GB08 &lt;- read_chrom(GB08_fl, 5L)
GB09 &lt;- read_chrom(GB09_fl, 5L)
extra_info &lt;- data.frame(Names = c("GB08", "GB09"),
                       Type = c("Control", "Treatment"))
join_chrom &lt;- join_chromatograms(GB08, GB09)
join_metadata &lt;- set_metadata(join_chrom, metadata = extra_info)
</code></pre>

<hr>
<h2 id='twod_cow'>Two-dimensional correlation optimized warping alignment</h2><span id='topic+twod_cow'></span>

<h3>Description</h3>

<p>This is an adaptation of two-dimesional COW alignment, first implemented 
in MATLAB (Tomasi et al. 2004). 
This functions takes a sample chromatogram to be aligned 
against a reference. The argument [segment] will be used to split the whole
chromatogram in <em>n</em> and <em>m</em> parts the first and the second
dimension, respectively. The [max_warp] argument provides de maximum
tolerance of the signal transformation for the first and the second dimension
(Dabao Zhang et al. 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twod_cow(sample_chrom, ref_chrom, segments, max_warp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twod_cow_+3A_sample_chrom">sample_chrom</code></td>
<td>
<p>A GCxGC class chromatogram imported by read_chrom 
function or a preprocessed chromatogram.</p>
</td></tr>
<tr><td><code id="twod_cow_+3A_ref_chrom">ref_chrom</code></td>
<td>
<p>A representative GCxGC chromatogram chosen to be the 
template which sample_chrom will be aligned.</p>
</td></tr>
<tr><td><code id="twod_cow_+3A_segments">segments</code></td>
<td>
<p>A two integer vector with number of segments
which the first and second dimension will be divided, respectively.</p>
</td></tr>
<tr><td><code id="twod_cow_+3A_max_warp">max_warp</code></td>
<td>
<p>A two integer vector with the maximum warping parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dabao Zhang, Xiaodong Huang, Fred E. Regnier, Min Zhang (2008).
&ldquo;Two-dimensional correlation optimized warping algorithm for aligning GCxGC-MS data.&rdquo;
<em>Analytical Chemistry</em>, <b>80</b>(8), 2664&ndash;2671.<br /><br /> Tomasi G, Van Den Berg F, Andersson C (2004).
&ldquo;Correlation optimized warping and dynamic time warping as preprocessing methods for chromatographic data.&rdquo;
<em>Journal of Chemometrics</em>, <b>18</b>(5), 231&ndash;241.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
GB08_fl &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
GB09_fl &lt;- system.file("extdata", "09GB.cdf", package = "RGCxGC")
GB08 &lt;- read_chrom(GB08_fl, 5L)
GB09 &lt;- read_chrom(GB09_fl, 5L)

GB09_al &lt;- twod_cow(sample_chrom = GB09, ref_chrom = GB08,
                    segments = c(20, 40), max_warp = c(2, 8))


</code></pre>

<hr>
<h2 id='unfold_chrom'>Unfold two-dimensional chromatograms</h2><span id='topic+unfold_chrom'></span>

<h3>Description</h3>

<p>'unfold' converts the two-dimensional chromatograms into a one dimensional
vector. Then, all chromatograms are joined into a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold_chrom(Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_chrom_+3A_object">Object</code></td>
<td>
<p>a batch_2DCOW or joined_chrom objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a single argument, batch_2DCOW or joined_chrom objects
and extracts each chromatogram and then it is unfolded into a one-dimensional
vector. Then, each one dimensional vector is joined in a single matrix, where
each row represent an observation or a chromatogram and each column
represent a variable, in our case, each retention time.
Also, in order to keep information about chromatographic runs, the retention
times for both dimensions are also exported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(Myrothecium)
# Unfold 2D chromatogram
chrom_1D &lt;- unfold_chrom(Myrothecium)
# Retrieve retention time for the first dimension
time_1D &lt;- chrom_1D$time
# Retrieve the modulation time
modulation &lt;- chrom_1D$mod_time
</code></pre>

<hr>
<h2 id='wsmooth'>Two-dimensional smoothing</h2><span id='topic+wsmooth'></span>

<h3>Description</h3>

<p>'wsmooth' weighted whittaker  smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsmooth(chromatogram, penalty = 1, lambda = 1, min_int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsmooth_+3A_chromatogram">chromatogram</code></td>
<td>
<p><em>raw_GCxGC</em> or <em>preproc_GCxGC</em> object with
<em>name</em> and <em>mod_time</em> slots.</p>
</td></tr>
<tr><td><code id="wsmooth_+3A_penalty">penalty</code></td>
<td>
<p>an integer of the order of the penalty. Only penalty of
first (penalty = 1) and second  (penalty = 2) order are allowed. By
default, the smooth function is performed with first penalty order.</p>
</td></tr>
<tr><td><code id="wsmooth_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter: larger values lead to more smoothing.</p>
</td></tr>
<tr><td><code id="wsmooth_+3A_min_int">min_int</code></td>
<td>
<p>minimum intensity value. The smoothing routine usually
creates low intensity artifacts which can obscure other compounds signals.
The min intensity value replace signals bellow the given value with 0.
For quadrupole mass detector this artifacts may range from 0-100, while
for TOF mass analyzers it can be 0-1e3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a raw two-dimensional chromatogram and performs
the weighted wittaker smoothing. It smooths the signal with linear or
quadratic penalty, depending on the provided penalty,
along side the first dimension, based on Whittaker smoother
(Eilers 2003).
</p>


<h3>References</h3>

<p>Eilers PH (2003).
&ldquo;A perfect smoother.&rdquo;
<em>Analytical Chemistry</em>, <b>75</b>(14), 3631&ndash;3636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chrom_name &lt;- system.file("extdata", "08GB.cdf", package = "RGCxGC")
chrom_2D &lt;- read_chrom(chrom_name, 5L)
chrom_smooth &lt;- wsmooth(chrom_2D, penalty = 1, lambda = 1e1)
plot(chrom_smooth, nlevels = 150,
           color.palette = colorRamps::matlab.like,
           main = expression(paste(lambda, "= 10, penalty = 1")) )
# Remove intensities bellow 1.75e5 (too high)    
chrom_smooth2 &lt;- wsmooth(chrom_2D, penalty = 1,
                         lambda = 1e1, min_int = 1.75e5)
plot(chrom_smooth2, nlevels = 150,
           color.palette = colorRamps::matlab.like,
           main = expression(paste(lambda,
            "= 10, penalty = 1, min_int = 1.75e5")) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
