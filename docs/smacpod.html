<!DOCTYPE html><html><head><title>Help for package smacpod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smacpod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smacpod'><p>smacpod</p></a></li>
<li><a href='#arg_check_alternative'><p>Argument check alternative</p></a></li>
<li><a href='#circles.intersect'><p>Determine whether circles intersect</p></a></li>
<li><a href='#circles.plot'><p>Plot circles</p></a></li>
<li><a href='#clusters.spscan'><p>Extract clusters</p></a></li>
<li><a href='#gradient.color.scale'><p>Create gradient color scale with midpoint</p></a></li>
<li><a href='#grave'><p>Medieval Grave Site Data</p></a></li>
<li><a href='#kd'><p>Difference of estimated K functions</p></a></li>
<li><a href='#kdest'><p>Difference of estimated K functions</p></a></li>
<li><a href='#kdplus.test'><p>Global test of clustering using difference in K functions</p></a></li>
<li><a href='#logrr'><p>Log ratio of spatial densities</p></a></li>
<li><a href='#logrr.test'><p>Global test of clustering using log ratio of spatial</p>
densities</a></li>
<li><a href='#nn'><p>Determine nearest neighbors</p></a></li>
<li><a href='#noc'><p>Determine non-overlapping clusters</p></a></li>
<li><a href='#plot.kdenv'><p>Plot a <code>kdenv</code> object.</p></a></li>
<li><a href='#plot.logrrenv'><p>Plots objects  produced by the <code>logrr</code></p>
function.</a></li>
<li><a href='#plot.spscan'><p>Plots object from <code>spscan.test</code>.</p></a></li>
<li><a href='#print.kdenv'><p>Print a <code>kdenv</code> object</p></a></li>
<li><a href='#print.kdenv_summary'><p>Print a <code>kdenv_summary</code> object</p></a></li>
<li><a href='#print.kdplus_test'><p>Print a <code>kdplus_test</code> object</p></a></li>
<li><a href='#print.logrr_test'><p>Print a <code>logrr_test</code> object</p></a></li>
<li><a href='#print.logrrenv'><p>Print a <code>logrrenv</code> object</p></a></li>
<li><a href='#print.spscan'><p>Plots object from <code>spscan.test</code>.</p></a></li>
<li><a href='#qnn.test'><p>q Nearest Neighbors Test</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#spdensity'><p>Kernel smoothed spatial density of point pattern</p></a></li>
<li><a href='#spscan.test'><p>Spatial Scan Test</p></a></li>
<li><a href='#summary.kdenv'><p>Summarize a <code>kdenv</code> object</p></a></li>
<li><a href='#summary.spscan'><p>Summarize object from <code>spscan.test</code>.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods for the Analysis of Case-Control Point Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua French &lt;joshua.french@ucdenver.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical methods for analyzing case-control point data.  Methods include the ratio of kernel densities, the difference in K Functions, the spatial scan statistic, and q nearest neighbors of cases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom, spatstat.random, spatstat.explore, smerc,
plotrix, abind, pbapply</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-21 19:29:41 UTC; frencjos</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua French <a href="https://orcid.org/0000-0002-9708-3353"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-22 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smacpod'>smacpod</h2><span id='topic+smacpod'></span><span id='topic+smacpod-package'></span>

<h3>Description</h3>

<p>*S*tatistical *M*thods for the *A*nalysis of *C*ase-control *Po*int *D*ata
</p>


<h3>Details</h3>

<p>Statistical methods for analyzing case-control point
data. Methods include the ratio of kernel densities, the
difference in K Functions, the spatial scan statistic,
and q nearest neighbors of cases.
</p>
<p>Run
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joshua French <a href="mailto:joshua.french@ucdenver.edu">joshua.french@ucdenver.edu</a> (<a href="https://orcid.org/0000-0002-9708-3353">ORCID</a>)
</p>

<hr>
<h2 id='arg_check_alternative'>Argument check alternative</h2><span id='topic+arg_check_alternative'></span>

<h3>Description</h3>

<p>Argument check alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arg_check_alternative(alternative)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arg_check_alternative_+3A_alternative">alternative</code></td>
<td>
<p>One of &quot;lower&quot;, &quot;greater&quot;, &quot;two.sided&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='circles.intersect'>Determine whether circles intersect</h2><span id='topic+circles.intersect'></span>

<h3>Description</h3>

<p><code>circles.intersect</code> determines whether circles
intersect with each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles.intersect(coords, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles.intersect_+3A_coords">coords</code></td>
<td>
<p>A matrix of coordinates with the
centroid of each circle.</p>
</td></tr>
<tr><td><code id="circles.intersect_+3A_r">r</code></td>
<td>
<p>A vector containing the radii of the circles. 
The length of <code>r</code> must equal the number of rows of 
<code>coords</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on the premise that two circles
intersect if, and only if, the distance between their
centroids is between the sum and the difference of their
radii.  I have squared the respective parts of the
inequality in the implemented algorithm.
</p>


<h3>Value</h3>

<p>Returns a matrix of logical values indicating
whether the circles intersect.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first two circles intersect each other, 
# the next two circles intersect each other 
# (but not the previous ones)
# the last circles doesn't intersect any other circle
co = cbind(c(1, 2, 5, 6, 9), c(1, 2, 5, 6, 9))
r = c(1.25, 1.25, 1.25, 1.25, 1.25)
# draw circles
circles.plot(co, r)
# confirm intersections
circles.intersect(co, r)

# nested circles (don't intersect)
co = matrix(rep(0, 4), nrow = 2)
r = c(1, 1.5)
circles.plot(co, r)
circles.intersect(co, r)
</code></pre>

<hr>
<h2 id='circles.plot'>Plot circles</h2><span id='topic+circles.plot'></span>

<h3>Description</h3>

<p><code>plot.circles</code> creates a plot with one or more 
circles (or adds them to an existing plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles.plot(
  coords,
  r,
  add = FALSE,
  ...,
  nv = 100,
  border = NULL,
  ccol = NA,
  clty = 1,
  density = NULL,
  angle = 45,
  clwd = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circles.plot_+3A_coords">coords</code></td>
<td>
<p>A matrix of coordinates with the centroid
of each circle.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_r">r</code></td>
<td>
<p>A vector containing the radii of the circles. 
The length of <code>r</code> must equal the number of rows of
<code>coords</code>.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_add">add</code></td>
<td>
<p>A logical value indicating whether the circles
should be added to an existing plot.  Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the 
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_nv">nv</code></td>
<td>
<p>Number of vertices to draw the circle.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_border">border</code></td>
<td>
<p>A vector with the desired border of each
circle.  The length should either be 1 (in which case
the border is repeated for all circles) or should match
the number of rows of <code>coords</code>.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_ccol">ccol</code></td>
<td>
<p>A vector with the desired color of each
circle.  The length should either be 1 (in which case
the color is repeated for all circles) or should match
the number of rows of <code>coords</code>.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_clty">clty</code></td>
<td>
<p>A vector with the desired line type of each
circle.  The length should either be 1 (in which case
the line type is repeated for all circles) or should match
the number of rows of <code>coords</code>.</p>
</td></tr>
<tr><td><code id="circles.plot_+3A_density">density</code></td>
<td>
<p>A vector with the density for a patterned fill.
The length should either be 1 (in which case
the density is repeated for all circles) or should match
the number of rows of <code>coords</code>. See <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
<tr><td><code id="circles.plot_+3A_angle">angle</code></td>
<td>
<p>A vector with the angle of a patterned fill.
The length should either be 1 (in which case
the angle is repeated for all circles) or should match
the number of rows of <code>coords</code>. See <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
<tr><td><code id="circles.plot_+3A_clwd">clwd</code></td>
<td>
<p>A vector with the desired line width of each
circle.  The length should either be 1 (in which case
the line width is repeated for all circles) or should match
the number of rows of <code>coords</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>See Also</h3>

<p><code><a href="plotrix.html#topic+draw.circle">draw.circle</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>co = cbind(c(1, 2, 5, 6, 9), c(1, 2, 5, 6, 9))
r = c(1.25, 1.25, 1.25, 1.25, 1.25)
# draw circles
circles.plot(co, r)
circles.plot(co, r, 
   ccol = c("blue", "blue", "orange", "orange", "brown"),
   density = c(10, 20, 30, 40, 50),
   angle = c(45, 135, 45, 136, 90))
</code></pre>

<hr>
<h2 id='clusters.spscan'>Extract clusters</h2><span id='topic+clusters.spscan'></span>

<h3>Description</h3>

<p>Extract clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spscan'
clusters(x, idx = seq_along(x$clusters), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters.spscan_+3A_x">x</code></td>
<td>
<p>An object of class <code>spscan</code> from the <code><a href="#topic+spscan.test">spscan.test</a></code></p>
</td></tr>
<tr><td><code id="clusters.spscan_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of
<code>x$clusters</code> to print information for. The default
is all clusters.</p>
</td></tr>
<tr><td><code id="clusters.spscan_+3A_...">...</code></td>
<td>
<p>Currently unimplemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. Each element of the list is a vector with the indices of event
locations in the associated cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# apply scan method
out = spscan.test(grave, nsim = 99)
# print scan object
clusters(out)
</code></pre>

<hr>
<h2 id='gradient.color.scale'>Create gradient color scale with midpoint</h2><span id='topic+gradient.color.scale'></span>

<h3>Description</h3>

<p>Create gradient color scale with midpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient.color.scale(
  minval,
  maxval,
  n = 11,
  low = "blue",
  mid = "white",
  high = "red",
  midpoint = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient.color.scale_+3A_minval">minval</code></td>
<td>
<p>The minimum value of the data to be colored</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_maxval">maxval</code></td>
<td>
<p>The maximum value of the data to be colored</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_n">n</code></td>
<td>
<p>The desired number of breaks (approximately)</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_low">low</code></td>
<td>
<p>The color for the low values</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_mid">mid</code></td>
<td>
<p>The color used for the midpoint of the gradient</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_high">high</code></td>
<td>
<p>The color used for the high values</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_midpoint">midpoint</code></td>
<td>
<p>The midpoint of the color scale</p>
</td></tr>
<tr><td><code id="gradient.color.scale_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a></code>
</p>

<dl>
<dt><code>colors</code></dt><dd><p>colors to interpolate; must be a valid argument to
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a>()</code>.</p>
</dd>
<dt><code>bias</code></dt><dd><p>a positive number.  Higher values give more widely spaced
colors at the high end.</p>
</dd>
<dt><code>space</code></dt><dd><p>a character string; interpolation in RGB or CIE Lab
color spaces.</p>
</dd>
<dt><code>interpolate</code></dt><dd><p>use spline or linear interpolation.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>logical: should alpha channel (opacity) values be
returned?   It is an error to give a true value if
<code>space</code> is specified.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>col</code> and <code>breaks</code> components specifying the colors and breaks of the color scale.
</p>


<h3>References</h3>

<p>Based on code from https://stackoverflow.com/a/10986203/5931362
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
lr = logrr(grave)
grad = gradient.color.scale(min(lr$v, na.rm = TRUE), max(lr$v, na.rm = TRUE))
plot(lr, col = grad$col, breaks = grad$breaks)
</code></pre>

<hr>
<h2 id='grave'>Medieval Grave Site Data</h2><span id='topic+grave'></span>

<h3>Description</h3>

<p>This data set contains 143 observations of
medieval grave site data stored as a <code>ppp</code> class
object from the <code>spatstat.geom</code> package.  The data are
marked as being &quot;affected&quot; by a tooth deformity or
&quot;unaffected&quot; by a tooth deformity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grave)
</code></pre>


<h3>Format</h3>

<p><code>ppp</code> (planar point process) class object
from the <code>spatstat.geom</code> package.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Source</h3>

<p>Waller, L.A. and Gotway, C.A. (2005).  Applied
Spatial Statistics for Public Health Data.  Hoboken,
NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>
</p>

<hr>
<h2 id='kd'>Difference of estimated K functions</h2><span id='topic+kd'></span>

<h3>Description</h3>

<p><code>kd</code> determines the difference in estimated K 
functions for a set of cases and controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kd(
  x,
  case = 2,
  r = NULL,
  rmax = NULL,
  breaks = NULL,
  correction = c("border", "isotropic", "Ripley", "translate"),
  nlarge = 3000,
  domain = NULL,
  var.approx = FALSE,
  ratio = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kd_+3A_x">x</code></td>
<td>
<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object with marks for the case
and control groups.</p>
</td></tr>
<tr><td><code id="kd_+3A_case">case</code></td>
<td>
<p>The name of the desired &quot;case&quot; group in
<code>levels(x$marks)</code>. Alternatively, the position of
the name of the &quot;case&quot; group in <code>levels(x$marks)</code>.
Since we don't know the group names, the default is 2,
the second position of <code>levels(x$marks)</code>.
<code>x$marks</code> is assumed to be a factor.  Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="kd_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">K(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default. If necessary, specify <code>rmax</code>.
</p>
</td></tr>
<tr><td><code id="kd_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="kd_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="kd_+3A_correction">correction</code></td>
<td>

<p>Optional. A character vector containing any selection of the
options <code>"none"</code>, <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"rigid"</code>,
<code>"none"</code>, <code>"periodic"</code>, <code>"good"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="kd_+3A_nlarge">nlarge</code></td>
<td>

<p>Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed (by default), using a fast algorithm.
</p>
</td></tr>
<tr><td><code id="kd_+3A_domain">domain</code></td>
<td>
<p>Optional. Calculations will be restricted 
to this subset of the window. See Details of 
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>.</p>
</td></tr>
<tr><td><code id="kd_+3A_var.approx">var.approx</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the approximate
variance of <code class="reqn">\hat K(r)</code> under CSR
will also be computed.
</p>
</td></tr>
<tr><td><code id="kd_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies internally on the 
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> and 
<code><a href="spatstat.explore.html#topic+eval.fv">eval.fv</a></code>.  The arguments are essentially
the same as the <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> function, 
and the user is referred there for more details about
the various arguments.
</p>


<h3>Value</h3>

<p>Returns an <code>fv</code> object.  See documentation 
for <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005). Applied
Spatial Statistics for Public Health Data. Hoboken, NJ:
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, 
<code><a href="spatstat.explore.html#topic+eval.fv">eval.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
kd = kd(grave)
plot(kd)
</code></pre>

<hr>
<h2 id='kdest'>Difference of estimated K functions</h2><span id='topic+kdest'></span>

<h3>Description</h3>

<p><code>kdest</code> computes the difference in estimated K functions for a set of
cases and controls, with <code>KD(r) = K_case(r) - K_control(r)</code> denoting the
estimated difference at distance <code>r</code>. If <code>nsim &gt; 0</code>, then pointwise
tolerance envelopes for <code>KD(r)</code> are constructed under the random
labeling hypothesis for each distance <code>r</code>. The <code>summary</code> function
can be used to determine the distances for which <code>KD(r)</code> is above or
below the tolerance envelopes. The <code>plot</code> function will plot
<code>KD(r)</code> versus r, along with the tolerance envelopes, the min/max
envelopes of <code>KD(r)</code> simulated under the random labeling hypothesis, and
the average KD(r) under the random labeling hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdest(
  x,
  case = 2,
  nsim = 0,
  level = 0.95,
  r = NULL,
  rmax = NULL,
  breaks = NULL,
  correction = c("border", "isotropic", "Ripley", "translate"),
  nlarge = 3000,
  domain = NULL,
  var.approx = FALSE,
  ratio = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdest_+3A_x">x</code></td>
<td>
<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object
package with marks for the case and control groups.
<code>x$marks</code> is assumed to be a factor. Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="kdest_+3A_case">case</code></td>
<td>
<p>The name of the desired &quot;case&quot; group in
<code>levels(x$marks)</code>. Alternatively, the position of
the name of the &quot;case&quot; group in <code>levels(x$marks)</code>.
Since we don't know the group names, the default is 2,
the second position of <code>levels(x$marks)</code>.
<code>x$marks</code> is assumed to be a factor.  Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="kdest_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated data sets from which
to construct tolerance envelopes under the random
labeling hypothesis.  The default is 0 (i.e., no
envelopes).</p>
</td></tr>
<tr><td><code id="kdest_+3A_level">level</code></td>
<td>
<p>The level of the tolerance envelopes.</p>
</td></tr>
<tr><td><code id="kdest_+3A_r">r</code></td>
<td>

<p>Optional. Vector of values for the argument <code class="reqn">r</code> at which <code class="reqn">K(r)</code> 
should be evaluated. Users are advised <em>not</em> to specify this
argument; there is a sensible default. If necessary, specify <code>rmax</code>.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum desired value of the argument <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_correction">correction</code></td>
<td>

<p>Optional. A character vector containing any selection of the
options <code>"none"</code>, <code>"border"</code>, <code>"bord.modif"</code>,
<code>"isotropic"</code>, <code>"Ripley"</code>, <code>"translate"</code>,
<code>"translation"</code>, <code>"rigid"</code>,
<code>"none"</code>, <code>"periodic"</code>, <code>"good"</code> or <code>"best"</code>.
It specifies the edge correction(s) to be applied.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_nlarge">nlarge</code></td>
<td>

<p>Optional. Efficiency threshold.
If the number of points exceeds <code>nlarge</code>, then only the
border correction will be computed (by default), using a fast algorithm.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_domain">domain</code></td>
<td>

<p>Optional. Calculations will be restricted to this subset
of the window. See Details.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_var.approx">var.approx</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the approximate
variance of <code class="reqn">\hat K(r)</code> under CSR
will also be computed.
</p>
</td></tr>
<tr><td><code id="kdest_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each edge-corrected estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies internally on the <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> and
<code><a href="spatstat.explore.html#topic+eval.fv">eval.fv</a></code> functions.  The arguments are essentially the same as the
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> function, and the user is referred there
for more details about the various arguments.
</p>


<h3>Value</h3>

<p>Returns a <code>kdenv</code> object.  See documentation
for <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005). 
Applied Spatial Statistics for Public Health Data. 
Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.explore.html#topic+eval.fv">eval.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# estimate and plot KD(r)
kd1 = kdest(grave, case = "affected")
plot(kd1, iso ~ r, ylab = "difference", legend = FALSE, main = "")
kd2 = kdest(grave, case = 2, nsim = 9, level = 0.8)
kd2 # print object
summary(kd2) # summarize distances KD(r) outside envelopes
plot(kd2)
# manually add legend
legend("bottomright", legend = c("obs", "avg", "max/min env", "95% env"),
       lty = c(1, 2, 1, 2), col = c("black", "red", "darkgrey", "lightgrey"),
       lwd = c(1, 1, 10, 10))
</code></pre>

<hr>
<h2 id='kdplus.test'>Global test of clustering using difference in K functions</h2><span id='topic+kdplus.test'></span>

<h3>Description</h3>

<p><code>kdplus.test</code> performs a global test of clustering
for comparing cases and controls using the method of
Diggle and Chetwynd (1991).  It relies on the difference
in estimated K functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdplus.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdplus.test_+3A_x">x</code></td>
<td>
<p>A <code>kdenv</code> object from the <code>kdest</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list providing the observed test statistic
(<code>kdplus</code>) and the estimate p-value
<code>pvalue</code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005).
Applied Spatial Statistics for Public Health Data.
Hoboken, NJ: Wiley.  
</p>
<p>Diggle, Peter J., and Amanda G.
Chetwynd. &quot;Second-order analysis of spatial clustering
for inhomogeneous populations.&quot; Biometrics (1991):
1155-1163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdest">kdest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# construct envelopes for differences in estimated K functions
kdenv = kdest(grave, nsim = 9)
kdplus.test(kdenv)
</code></pre>

<hr>
<h2 id='logrr'>Log ratio of spatial densities</h2><span id='topic+logrr'></span>

<h3>Description</h3>

<p><code>logrr</code> computes the estimated log relative risk of
cases relative to controls. The log relative risk at
location s is defined as <code>r(s) = ln(f(s)/g(s))</code>. The
numerator, <code>f(s)</code>, is the spatial density of the
case group. The denominator, <code>g(s)</code>, is the spatial
density of the control group. If <code>nsim &gt; 0</code>, then
pointwise (at each pixel) tolerance envelopes are
estimated under the random labeling hypothesis. The
tolerance envelopes can be used to assess pixels where
the log relative risk differs significantly from zero.
See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrr(
  x,
  sigma = NULL,
  sigmacon = NULL,
  case = 2,
  nsim = 0,
  level = 0.9,
  alternative = "two.sided",
  envelope = "pixelwise",
  ...,
  bwargs = list(),
  weights = NULL,
  edge = TRUE,
  varcov = NULL,
  at = "pixels",
  leaveoneout = TRUE,
  adjust = 1,
  diggle = FALSE,
  kernel = "gaussian",
  scalekernel = is.character(kernel),
  positive = FALSE,
  verbose = TRUE,
  return_sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrr_+3A_x">x</code></td>
<td>
<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object
package with marks for the case and control groups.
<code>x$marks</code> is assumed to be a factor. Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="logrr_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of isotropic smoothing
kernel for cases. Either a numerical value, or a
function that computes an appropriate value of
<code>sigma</code>. If not specified, then
<code><a href="spatstat.explore.html#topic+bw.relrisk">bw.relrisk</a></code> is used.</p>
</td></tr>
<tr><td><code id="logrr_+3A_sigmacon">sigmacon</code></td>
<td>
<p>Standard deviation of isotropic smoothing
kernel for controls.  Default is the same as
<code>sigma</code>.</p>
</td></tr>
<tr><td><code id="logrr_+3A_case">case</code></td>
<td>
<p>The name of the desired &quot;case&quot; group in
<code>levels(x$marks)</code>. Alternatively, the position of
the name of the &quot;case&quot; group in <code>levels(x$marks)</code>.
Since we don't know the group names, the default is 2,
the second position of <code>levels(x$marks)</code>.
<code>x$marks</code> is assumed to be a factor.  Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="logrr_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulated data sets from which
to construct tolerance envelopes under the random
labeling hypothesis.  The default is 0 (i.e., no
envelopes).</p>
</td></tr>
<tr><td><code id="logrr_+3A_level">level</code></td>
<td>
<p>The level of the tolerance envelopes.</p>
</td></tr>
<tr><td><code id="logrr_+3A_alternative">alternative</code></td>
<td>
<p>The type of envelopes to construct.
The default is <code>"two.sided"</code> (upper and lower
envelopes).  The values <code>"less"</code> (lower envelope)
and <code>"greater"</code> (upper envelope) are also valid.</p>
</td></tr>
<tr><td><code id="logrr_+3A_envelope">envelope</code></td>
<td>
<p>The type of envelope to construct. The
default is <code>"pixelwise"</code>. The other option is
<code>"simulataneous"</code>, which controls the tolerance
level across the entire study area.</p>
</td></tr>
<tr><td><code id="logrr_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.geom.html#topic+pixellate.ppp">pixellate.ppp</a></code>
and <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine
the pixel resolution, or passed to <code>sigma</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_bwargs">bwargs</code></td>
<td>
<p>A list of arguments for the bandwidth
function supplied to <code>sigma</code> and <code>sigmacon</code>,
if applicable.</p>
</td></tr>
<tr><td><code id="logrr_+3A_weights">weights</code></td>
<td>

<p>Optional weights to be attached to the points.
A numeric vector, numeric matrix, an <code>expression</code>,
or a pixel image.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic smoothing kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the intensity values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="logrr_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the smoothing parameter.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_diggle">diggle</code></td>
<td>

<p>Logical. If <code>TRUE</code>, use the Jones-Diggle improved edge correction,
which is more accurate but slower to compute than the default
correction.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_kernel">kernel</code></td>
<td>

<p>The smoothing kernel.
A character string specifying the smoothing kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>),
or a pixel image (object of class <code>"im"</code>)
containing values of the kernel, or a <code>function(x,y)</code> which
yields values of the kernel.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_scalekernel">scalekernel</code></td>
<td>

<p>Logical value.
If <code>scalekernel=TRUE</code>, then the kernel will be rescaled
to the bandwidth determined by <code>sigma</code> and <code>varcov</code>:
this is the default behaviour when <code>kernel</code> is a character string.
If <code>scalekernel=FALSE</code>, then <code>sigma</code> and <code>varcov</code>
will be ignored: this is the default behaviour when <code>kernel</code> is a
function or a pixel image.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_positive">positive</code></td>
<td>

<p>Logical value indicating whether to force all density values to
be positive numbers. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to issue warnings
about numerical problems and conditions.
</p>
</td></tr>
<tr><td><code id="logrr_+3A_return_sims">return_sims</code></td>
<td>
<p>A logical value indicating whether
parts of the simulated data shoudl be returned. The
default is <code>FALSE</code>. This is mostly used for
debugging purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nsim=0</code>, the <code>plot</code> function creates a heat
map of the log relative risk. If <code>nsim &gt; 0</code>, the
<code>plot</code> function colors the pixels where the
estimated log relative risk is outside the tolerance
envelopes created under the random labeling hypothesis
(i.e., pixels with potential clustering of cases or
controls). Colored regions with values above 0 indicate a
cluster of cases relative to controls (without
controlling for multiple comparisons), i.e., a region
where the the density of the cases is greater than the
the density of the controls. Colored regions with values
below 0 indicate a cluster of controls relative to cases
(without controlling for multiple comparisons), i.e., a
region where the density of the controls is greater than
the density of the cases.
</p>
<p>The <code>two.sided</code> alternative test constructs
two-sided tolerance envelopes to assess whether the
estimated <code>r(s)</code> deviates more than what is expected
under the random labeling hypothesis.  The <code>greater</code>
alternative constructs an upper tolerance envelope to
assess whether the estimated <code>r(s)</code> is greater than
what is expected under the random labeling hypothesis,
i.e., where there is clustering of cases relative to
controls. The <code>lower</code> alternative constructs a lower
tolerance envelope to assess whether the estimated
<code>r(s)</code> is lower than what is expected under the
random labeling hypothesis, i.e., where there is
clustering of controls relative to cases.
</p>
<p>If the estimated density of the case or control group
becomes too small, this function may produce warnings due
to numerical underflow. Increasing the bandwidth
(<code>sigma</code>) may help.
</p>


<h3>Value</h3>

<p>The function produces an object of type
<code>logrrenv</code>.  Its components are similar to those
returned by the
<code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>, with the
intensity values replaced by the log ratio of spatial
densities of f and g.  Includes an array <code>simr</code> of
dimension c(nx, ny, nsim + 1), where nx and ny are the
number of x and y grid points used to estimate the
spatial density. <code>simr[,,1]</code> is the log ratio of
spatial densities for the observed data, and the
remaining <code>nsim</code> elements in the third dimension
of the array are the log ratios of spatial densities
from a new ppp simulated under the random labeling
hypothesis.
</p>


<h3>Author(s)</h3>

<p>Joshua French (and a small chunk by the authors
of the <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>)
function for consistency with the default behavior of
that function).
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005). Applied
Spatial Statistics for Public Health Data. Hoboken, NJ:
Wiley.
</p>
<p>Kelsall, Julia E., and Peter J. Diggle. &quot;Kernel
estimation of relative risk.&quot; Bernoulli (1995): 3-16.
</p>
<p>Kelsall, Julia E., and Peter J. Diggle. &quot;Non-parametric
estimation of spatial variation in relative risk.&quot;
Statistics in Medicine 14.21-22 (1995): 2335-2342.
</p>
<p>Hegg, Alex and French, Joshua P. (2022) &quot;Simultaneous
tolerance bands of log relative risk for 
case-control point data. Technical report.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# estimate and plot log relative risk
r = logrr(grave, case = "affected")
plot(r)
# use scott's bandwidth
r2 = logrr(grave, case = 2, sigma = spatstat.explore::bw.scott)
plot(r2)
# construct pointwise tolerance envelopes for log relative risk
## Not run: 
renv = logrr(grave, nsim = 9)
print(renv) # print information about envelopes
plot(renv) # plot results
# plot using a better gradient
grad = gradient.color.scale(min(renv$v, na.rm = TRUE), max(renv$v, na.rm = TRUE))
plot(renv, col = grad$col, breaks = grad$breaks, conlist = list(col = "lightgrey"))
## End(Not run)
</code></pre>

<hr>
<h2 id='logrr.test'>Global test of clustering using log ratio of spatial
densities</h2><span id='topic+logrr.test'></span>

<h3>Description</h3>

<p><code>logrr.test</code> performs a global test of clustering
for comparing cases and controls using the log ratio of
spatial densities based on the method of Kelsall and
Diggle (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logrr.test(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logrr.test_+3A_x">x</code></td>
<td>
<p>An <code>logrrenv</code> object from the
<code><a href="#topic+logrr">logrr</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list providing the observed test statistic
(<code>islogrr</code>) and the estimated p-value
(<code>pvalue</code>).
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005). Applied
Spatial Statistics for Public Health Data. Hoboken, NJ:
Wiley.
</p>
<p>Kelsall, Julia E., and Peter J. Diggle. &quot;Non-parametric
estimation of spatial variation in relative risk.&quot;
Statistics in Medicine 14.21-22 (1995): 2335-2342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
## Not run: 
logrrenv = logrr(grave, nsim = 9)
logrr.test(logrrenv)
## End(Not run)
</code></pre>

<hr>
<h2 id='nn'>Determine nearest neighbors</h2><span id='topic+nn'></span>

<h3>Description</h3>

<p><code>nn</code> determines the nearest neighbors for a set of 
observations based on a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn(d, k, method = "c", self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_+3A_d">d</code></td>
<td>
<p>A square distance matrix for the 
coordinates of interest.</p>
</td></tr>
<tr><td><code id="nn_+3A_k">k</code></td>
<td>
<p>The number of neighbors to return (if 
<code>method = "c"</code>) or the distance for which 
observations are considered neighbors (if <code>method 
= "d"</code>).</p>
</td></tr>
<tr><td><code id="nn_+3A_method">method</code></td>
<td>
<p>The method of determining the neighbors. 
The default is <code>"c"</code>, specifying that the <code>k</code>
nearest neighbors (the number of neighbors) for each 
observation should be returned.  The alternative is 
<code>"d"</code>, meaning that neighbors are determined by 
their distance from an observation.  In that case, two 
observations are neighbors if their separation distance
is less or equal to <code>k</code>.</p>
</td></tr>
<tr><td><code id="nn_+3A_self">self</code></td>
<td>
<p>A logical indicating whether an observation 
is a neighbor with itself.  The default is 
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determine nearest neighbors in two ways: 1.
number of neighbors or 2. distance.
</p>
<p>If <code>method = "c"</code>, then <code>k</code> specifies the total
number of neighbors to return for each observation.  
</p>
<p>If <code>method = "d"</code>, then <code>k</code> specifies the maximum
distance for which an observation is considered a 
neighbor.  
</p>
<p>The function returns the neighbors for each 
observation.
</p>


<h3>Value</h3>

<p>Returns a list with the nearest neighbors of each
observation. For each element of the list, the indices
order neighbors from nearest to farthest.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# make distance matrix
d = as.matrix(dist(cbind(grave$x, grave$y)))
# 3 nearest neighbors
nnc = nn(d, k = 3, method = "c")
# nearest neighbors within k units of each observation
nnd = nn(d, k = 200, method = "d")
</code></pre>

<hr>
<h2 id='noc'>Determine non-overlapping clusters</h2><span id='topic+noc'></span>

<h3>Description</h3>

<p>Determine non-overlapping clusters from a list of potential clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noc_+3A_x">x</code></td>
<td>
<p>A list containing the potential clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a list of potential clusters. Each element of the list
contains a potential cluster. The potential clusters are defined by the
location indices of the regions comprising the clusters.  Starting with the
first potential cluster, the function excludes every potential cluster that
intersects the first (any potential cluster that shares indices).  Moving
onto the next non-overlapping cluster, the process is repeated. The function
returns the indices (in the list of clusters) of the clusters that do not
overlap.
</p>


<h3>Value</h3>

<p>A vector with the list indices of the non-overlapping clusters.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = list(1:2, 1:3, 4:5, 4:6, 7:8)
noc(x)
</code></pre>

<hr>
<h2 id='plot.kdenv'>Plot a <code>kdenv</code> object.</h2><span id='topic+plot.kdenv'></span>

<h3>Description</h3>

<p>Plots an object from <code><a href="#topic+kdest">kdest</a></code> of
class <code>kdenv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdenv'
plot(
  x,
  ...,
  shadecol1 = "darkgrey",
  shadecol2 = "lightgrey",
  main = "",
  legend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kdenv_+3A_x">x</code></td>
<td>
<p>An object of class <code>kdenv</code> produced by
<code><a href="#topic+kdest">kdest</a></code>.</p>
</td></tr>
<tr><td><code id="plot.kdenv_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the
<code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code> function, which is used
internally for plotting.</p>
</td></tr>
<tr><td><code id="plot.kdenv_+3A_shadecol1">shadecol1</code></td>
<td>
<p>Color for min/max tolerance envelopes generated under the random labeling hypothesis.
The default is a dark grey.</p>
</td></tr>
<tr><td><code id="plot.kdenv_+3A_shadecol2">shadecol2</code></td>
<td>
<p>Shade color for non-rejection envelopes.
The default is <code>"lightgrey"</code>.</p>
</td></tr>
<tr><td><code id="plot.kdenv_+3A_main">main</code></td>
<td>
<p>A main title for the plot.  The default is blank.</p>
</td></tr>
<tr><td><code id="plot.kdenv_+3A_legend">legend</code></td>
<td>
<p>Logical for whether a legend should
automatically be displayed.  Default is <code>FALSE</code>.
See Details for an explanation of the components of the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The solid line indicates the observed difference in the K
functions for the cases and controls.  The dashed line
indicates the average difference in the K functions
produced from the data sets simulated under the random
labeling hypothesis when executing the <code>kdest</code>
function. The shaded areas indicate the tolerance envelopes
constructed in <code>x</code> for tolerance level <code>level</code> and
the min/max envelopes constructed under the random labeling
hypothesis.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
kdenv = kdest(grave, nsim = 19, level = 0.9)
plot(kdenv)
plot(kdenv, legend = TRUE)
</code></pre>

<hr>
<h2 id='plot.logrrenv'>Plots objects  produced by the <code><a href="#topic+logrr">logrr</a></code> 
function.</h2><span id='topic+plot.logrrenv'></span>

<h3>Description</h3>

<p>Plots objects  of class <code>logrrenv</code> produced by the 
<code><a href="#topic+logrr">logrr</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logrrenv'
plot(x, ..., conlist = list(), main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.logrrenv_+3A_x">x</code></td>
<td>
<p>An object of class <code>logrrenv</code>.</p>
</td></tr>
<tr><td><code id="plot.logrrenv_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the 
<code><a href="spatstat.geom.html#topic+image.im">image.im</a></code> function.  See
Details.</p>
</td></tr>
<tr><td><code id="plot.logrrenv_+3A_conlist">conlist</code></td>
<td>
<p>Additional argument passed to the 
<code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.logrrenv_+3A_main">main</code></td>
<td>
<p>A main title for the plot.  Default is blank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An important aspect of this plot is the
color argument (<code>col</code>) used for displaying
the regions outside the non-rejection envelopes.  If NULL
(the implicit default), then the default color palette
used by <code><a href="spatstat.geom.html#topic+image.im">image.im</a></code> will be used. 
Simpler schemes, e.g., c(&quot;blue&quot;, &quot;white&quot;, &quot;orange&quot;) can
suffice. See the examples.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>,
<code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
## Not run: 
logrrsim = logrr(grave, nsim = 9)
plot(logrrsim)
# no border or ribben (legend).  Simple color scheme.
plot(logrrsim, col = c("blue", "white", "orange"), ribbon = FALSE, box = FALSE) 
# alternate color scheme
plot(logrrsim, col = topo.colors(12), conlist = list(col = "lightgrey"))
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.spscan'>Plots object from <code><a href="#topic+spscan.test">spscan.test</a></code>.</h2><span id='topic+plot.spscan'></span>

<h3>Description</h3>

<p>Plots object of class <code>scan</code> from
<code><a href="#topic+spscan.test">spscan.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spscan'
plot(x, ..., nv = 100, border = NULL, ccol = NULL, clty = NULL, clwd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spscan_+3A_x">x</code></td>
<td>
<p>An object of class <code>spscan</code>.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the
<code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_nv">nv</code></td>
<td>
<p>The number of vertices when drawing the cluster 
circles. Default is 100.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_border">border</code></td>
<td>
<p>The border color of the circle.  Default is
NULL, meaning black.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_ccol">ccol</code></td>
<td>
<p>Fill color of the circles.  Default is NULL,
indicating empty.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_clty">clty</code></td>
<td>
<p>Line type of circles.  Default is NULL,
indicting <code>lty = 1</code>.</p>
</td></tr>
<tr><td><code id="plot.spscan_+3A_clwd">clwd</code></td>
<td>
<p>Line width of circles.  Default is NULL,
indicating <code>lwd = 2</code> for the most likely cluster and 
<code>lwd = 1</code> for the rest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>border</code>, <code>ccol</code>, <code>clty</code>, or 
<code>clwd</code> are specified, then the length of these
vectors must match <code>nrow(x$coords)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>, <code><a href="plotrix.html#topic+draw.circle">draw.circle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
out = spscan.test(grave, case = 2, alpha = 0.1, nsim = 49)
plot(out, chars = c(1, 20), main = "most likely cluster",
     border = "orange", ccol = NA)
# change color, lty, lwd of circles
set.seed(2)
out2 = spscan.test(grave, case = 2, alpha = 0.8, nsim = 49)
plot(out2, chars = c(1, 20),  border = "blue")
plot(out2, chars = c(1, 20),  border = c("blue", "orange"),
     clwd = c(3, 2), clty = c(2, 3))
</code></pre>

<hr>
<h2 id='print.kdenv'>Print a <code>kdenv</code> object</h2><span id='topic+print.kdenv'></span>

<h3>Description</h3>

<p>Print an <code>kdenv</code> object produced by
<code><a href="#topic+kdest">kdest</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdenv'
print(x, ..., extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.kdenv_+3A_x">x</code></td>
<td>
<p>An object produced by the
<code><a href="#topic+kdest">kdest</a></code> function.</p>
</td></tr>
<tr><td><code id="print.kdenv_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
<tr><td><code id="print.kdenv_+3A_extra">extra</code></td>
<td>
<p>A logical value indicating whether extra
information related to the internal
<code><a href="spatstat.explore.html#topic+fv">fv</a></code> object should be printed.
The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the <code>kdest</code>
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='print.kdenv_summary'>Print a <code>kdenv_summary</code> object</h2><span id='topic+print.kdenv_summary'></span>

<h3>Description</h3>

<p>Print a <code>kdenv_summary</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdenv_summary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.kdenv_summary_+3A_x">x</code></td>
<td>
<p>An object produced by <code><a href="#topic+summary.kdenv">summary.kdenv</a></code>.</p>
</td></tr>
<tr><td><code id="print.kdenv_summary_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print summary
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='print.kdplus_test'>Print a <code>kdplus_test</code> object</h2><span id='topic+print.kdplus_test'></span>

<h3>Description</h3>

<p>Print a <code>kdplus_test</code> object produced by 
<code><a href="#topic+kdplus.test">kdplus.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdplus_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.kdplus_test_+3A_x">x</code></td>
<td>
<p>An object produced by the <code><a href="#topic+kdplus.test">kdplus.test</a></code> function.</p>
</td></tr>
<tr><td><code id="print.kdplus_test_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the test
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='print.logrr_test'>Print a <code>logrr_test</code> object</h2><span id='topic+print.logrr_test'></span>

<h3>Description</h3>

<p>Print an <code>logrr_test</code> object produced by
<code><a href="#topic+logrr.test">logrr.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logrr_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.logrr_test_+3A_x">x</code></td>
<td>
<p>An object produced by the <code><a href="#topic+logrr.test">logrr.test</a></code> function.</p>
</td></tr>
<tr><td><code id="print.logrr_test_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the test
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='print.logrrenv'>Print a <code>logrrenv</code> object</h2><span id='topic+print.logrrenv'></span>

<h3>Description</h3>

<p>Print a <code>logrrenv</code> object produced by
<code><a href="#topic+logrr">logrr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logrrenv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.logrrenv_+3A_x">x</code></td>
<td>
<p>An object produced by the
<code><a href="#topic+logrr">logrr</a></code> function.</p>
</td></tr>
<tr><td><code id="print.logrrenv_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about the <code>logrrenv</code>
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='print.spscan'>Plots object from <code><a href="#topic+spscan.test">spscan.test</a></code>.</h2><span id='topic+print.spscan'></span>

<h3>Description</h3>

<p>Plots object of class <code>spscan</code> from
<code><a href="#topic+spscan.test">spscan.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spscan'
print(x, ..., extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spscan_+3A_x">x</code></td>
<td>
<p>An object of class <code>spscan</code>.</p>
</td></tr>
<tr><td><code id="print.spscan_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+print">base::print</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="print.spscan_+3A_extra">extra</code></td>
<td>
<p>A logical value. Default is <code>FALSE</code>.
<code>TRUE</code> indicates that extra information should be
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>border</code>, <code>ccol</code>, <code>clty</code>, or 
<code>clwd</code> are specified, then the length of these
vectors must match <code>nrow(x$coords)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
out = spscan.test(grave, case = 2, alpha = 0.1)
out
</code></pre>

<hr>
<h2 id='qnn.test'>q Nearest Neighbors Test</h2><span id='topic+qnn.test'></span>

<h3>Description</h3>

<p><code>qnn.test</code> calculates statistics related to the q
nearest neighbors method of comparing case and control
point patterns under the random labeling hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnn.test(x, q = 5, case = 2, nsim = 499, longlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qnn.test_+3A_x">x</code></td>
<td>
<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object with marks for the case
and control groups.</p>
</td></tr>
<tr><td><code id="qnn.test_+3A_q">q</code></td>
<td>
<p>A vector of positive integers indicating the
values of <code>q</code> for which to do the q nearest
neighbors test.</p>
</td></tr>
<tr><td><code id="qnn.test_+3A_case">case</code></td>
<td>
<p>The name of the desired &quot;case&quot; group in
<code>levels(x$marks)</code>. Alternatively, the position of
the name of the &quot;case&quot; group in <code>levels(x$marks)</code>.
Since we don't know the group names, the default is 2,
the second position of <code>levels(x$marks)</code>.
<code>x$marks</code> is assumed to be a factor.  Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="qnn.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to
compute p-value.</p>
</td></tr>
<tr><td><code id="qnn.test_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether
Euclidean distance (<code>FALSE</code>) or Great Circle
(WGS84 ellipsoid, <code>FALSE</code>) should be used. Default
is <code>FALSE</code>, i.e., Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>qsum</code></td>
<td>
<p>A dataframe with the number of neighbors
(q), test statistic (Tq), and p-value for each test.</p>
</td></tr>
<tr><td><code>consum</code></td>
<td>
<p>A dataframe with the contrasts
(contrast), test statistic (Tcon), and p-value
(pvalue) for the test of contrasts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A., and Gotway, C.A. (2005).
Applied Spatial Statistics for Public Health Data.
Hoboken, NJ: Wiley.
</p>
<p>Cuzick, J., and Edwards, R. (1990). Spatial clustering
for inhomogeneous populations. Journal of the Royal
Statistical Society. Series B (Methodological), 73-104.
</p>
<p>Alt, K.W., and Vach, W. (1991). The reconstruction of
&quot;genetic kinship&quot; in prehistoric burial
complexes-problems and statistics. Classification, Data
Analysis, and Knowledge Organization, 299-310.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
qnn.test(grave, case = "affected", q = c(3, 5, 7, 9, 11, 13, 15))
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+clusters'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>smerc</dt><dd><p><code><a href="smerc.html#topic+clusters">clusters</a></code></p>
</dd>
</dl>

<hr>
<h2 id='spdensity'>Kernel smoothed spatial density of point pattern</h2><span id='topic+spdensity'></span>

<h3>Description</h3>

<p><code>spdensity</code> computes a kernel smoothed spatial
density function from a point pattern.  This function is
basically a wrapper for <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.
The <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> function computes
the spatial intensity of a point pattern; the <code>spdensity</code>
function scales the intensity to produce a true spatial density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdensity(
  x,
  sigma = NULL,
  ...,
  weights = NULL,
  edge = TRUE,
  varcov = NULL,
  at = "pixels",
  leaveoneout = TRUE,
  adjust = 1,
  diggle = FALSE,
  kernel = "gaussian",
  scalekernel = is.character(kernel),
  positive = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spdensity_+3A_x">x</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_sigma">sigma</code></td>
<td>

<p>The smoothing bandwidth (the amount of smoothing).
The standard deviation of the isotropic smoothing kernel.
Either a numerical value, 
or a function that computes an appropriate value of <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.geom.html#topic+pixellate.ppp">pixellate.ppp</a></code>
and <code><a href="grid.html#topic+as.mask">as.mask</a></code> to determine
the pixel resolution, or passed to <code>sigma</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_weights">weights</code></td>
<td>

<p>Optional weights to be attached to the points.
A numeric vector, numeric matrix, an <code>expression</code>,
or a pixel image.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_edge">edge</code></td>
<td>

<p>Logical value indicating whether to apply edge correction.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_varcov">varcov</code></td>
<td>

<p>Variance-covariance matrix of anisotropic smoothing kernel.
Incompatible with <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the intensity values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the smoothing parameter.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_diggle">diggle</code></td>
<td>

<p>Logical. If <code>TRUE</code>, use the Jones-Diggle improved edge correction,
which is more accurate but slower to compute than the default
correction.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_kernel">kernel</code></td>
<td>

<p>The smoothing kernel.
A character string specifying the smoothing kernel
(current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>),
or a pixel image (object of class <code>"im"</code>)
containing values of the kernel, or a <code>function(x,y)</code> which
yields values of the kernel.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_scalekernel">scalekernel</code></td>
<td>

<p>Logical value.
If <code>scalekernel=TRUE</code>, then the kernel will be rescaled
to the bandwidth determined by <code>sigma</code> and <code>varcov</code>:
this is the default behaviour when <code>kernel</code> is a character string.
If <code>scalekernel=FALSE</code>, then <code>sigma</code> and <code>varcov</code>
will be ignored: this is the default behaviour when <code>kernel</code> is a
function or a pixel image.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_positive">positive</code></td>
<td>

<p>Logical value indicating whether to force all density values to
be positive numbers. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="spdensity_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to issue warnings
about numerical problems and conditions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function produces the spatial density of <code>x</code>
as an object of class <code><a href="spatstat.geom.html#topic+im">im</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Waller, L.A. and Gotway, C.A. (2005).  Applied Spatial Statistics for Public Health Data.  Hoboken, NJ: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
contour(spdensity(grave))
</code></pre>

<hr>
<h2 id='spscan.test'>Spatial Scan Test</h2><span id='topic+spscan.test'></span>

<h3>Description</h3>

<p><code>spscan.test</code> performs the spatial scan test of Kulldorf (1997) for
case/control point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spscan.test(
  x,
  case = 2,
  nsim = 499,
  alpha = 0.1,
  maxd = NULL,
  cl = NULL,
  longlat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spscan.test_+3A_x">x</code></td>
<td>
<p>A <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object with marks for the case
and control groups.</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_case">case</code></td>
<td>
<p>The name of the desired &quot;case&quot; group in
<code>levels(x$marks)</code>. Alternatively, the position of
the name of the &quot;case&quot; group in <code>levels(x$marks)</code>.
Since we don't know the group names, the default is 2,
the second position of <code>levels(x$marks)</code>.
<code>x$marks</code> is assumed to be a factor.  Automatic
conversion is attempted if it is not.</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations from which to compute the p-value.  A
non-negative integer.  Default is 499.</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level to determine whether a cluster is
signficant.  Default is 0.1.</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_maxd">maxd</code></td>
<td>
<p>The radius of the largest possible cluster to consider.  Default
is <code>NULL</code>, i.e., half the maximum intercentroid distance.</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
It can also be <code>"future"</code> to use a future backend (see Details),
<code>NULL</code> (default) refers to sequential evaluation.
</p>
</td></tr>
<tr><td><code id="spscan.test_+3A_longlat">longlat</code></td>
<td>
<p>A logical value indicating whether
Euclidean distance (<code>FALSE</code>) or Great Circle
(WGS84 ellipsoid, <code>FALSE</code>) should be used. Default
is <code>FALSE</code>, i.e., Euclidean distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is performed using the random labeling hypothesis.  The windows are
circular and extend from the observed data locations.  The clusters returned
are non-overlapping, ordered from most significant to least significant.  The
first cluster is the most likely to be a cluster.  If no significant clusters
are found, then the most likely cluster is returned (along with a warning).
</p>
<p>Setting <code>cl</code> to a positive integer MAY speed up computations on
non-Windows computers.  However, parallelization does have overhead cost, and
there are cases where parallelization results in slower computations.
</p>


<h3>Value</h3>

<p>Returns a list of length two of class 
<code>scan</code>. The first element (clusters) is a list 
containing the significant, non-overlapping clusters, 
and has the the following components: 
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>The
centroid of the significant clusters.</p>
</td></tr> 
<tr><td><code>r</code></td>
<td>
<p>The 
radius of the window of the clusters.</p>
</td></tr> 
<tr><td><code>pop</code></td>
<td>
<p>The 
total population in the cluser window.</p>
</td></tr> 
<tr><td><code>cases</code></td>
<td>
<p>The observed number of cases in the 
cluster window.</p>
</td></tr> 
<tr><td><code>expected</code></td>
<td>
<p>The expected number of
cases in the cluster window.</p>
</td></tr> 
<tr><td><code>smr</code></td>
<td>
<p>Standarized 
mortaility ratio (observed/expected) in the cluster 
window.</p>
</td></tr> 
<tr><td><code>rr</code></td>
<td>
<p>Relative risk in the cluster 
window.</p>
</td></tr> <tr><td><code>propcases</code></td>
<td>
<p>Proportion of cases in the 
cluster window.</p>
</td></tr> 
<tr><td><code>loglikrat</code></td>
<td>
<p>The loglikelihood 
ratio for the cluster window (i.e., the log of the test
statistic).</p>
</td></tr> 
<tr><td><code>pvalue</code></td>
<td>
<p>The pvalue of the test 
statistic associated with the cluster window.</p>
</td></tr> 
</table>
<p>Various additional pieces of information are included for plotting,
printing
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>


<h3>References</h3>

<p>Kulldorff M., Nagarwalla N. (1995) Spatial
disease clusters: Detection and Inference. Statistics
in Medicine 14, 799-810.
</p>
<p>Kulldorff, M. (1997) A spatial scan statistic.
Communications in Statistics &ndash; Theory and Methods 26,
1481-1496.
</p>
<p>Waller, L.A. and Gotway, C.A. (2005). Applied Spatial
Statistics for Public Health Data. Hoboken, NJ: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
# apply scan method
out = spscan.test(grave, case = "affected", nsim = 99)
# print scan object
out
print(out, extra = TRUE)
# summarize results
summary(out)
# plot results
plot(out, chars = c(1, 20), main = "most likely cluster")
# extract clusters from out 
# each element of the list gives the location index of the events in each cluster
clusters(out)
# get warning if no significant cluster
out2 = spscan.test(grave, case = 2, alpha = 0.001, nsim = 99)
</code></pre>

<hr>
<h2 id='summary.kdenv'>Summarize a <code>kdenv</code> object</h2><span id='topic+summary.kdenv'></span>

<h3>Description</h3>

<p>Summarize the sequences of distances for which the difference in estimated K
functions, <code>KD(r) = K_case(r) - K_control(r)</code>, falls outside the
non-rejection envelopes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kdenv'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.kdenv_+3A_object">object</code></td>
<td>
<p>An object produced by the <code><a href="#topic+kdest">kdest</a></code>
function.</p>
</td></tr>
<tr><td><code id="summary.kdenv_+3A_...">...</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains the sequences of indices for which the estimated
difference in KD functions is above the envelopes, below the envelopes, and
the vector of distances.
</p>


<h3>Author(s)</h3>

<p>Joshua French
</p>

<hr>
<h2 id='summary.spscan'>Summarize object from <code><a href="#topic+spscan.test">spscan.test</a></code>.</h2><span id='topic+summary.spscan'></span>

<h3>Description</h3>

<p>Summarize object of class <code>scan</code> from <code><a href="#topic+spscan.test">spscan.test</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spscan'
summary(object, ..., idx = seq_along(object$clusters), digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spscan_+3A_object">object</code></td>
<td>
<p>An <code>spscan</code> object.</p>
</td></tr>
<tr><td><code id="summary.spscan_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="base.html#topic+summary">base::summary</a></code>, <code><a href="base.html#topic+summary">base::summary</a></code>
</p>

<dl>
<dt></dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="summary.spscan_+3A_idx">idx</code></td>
<td>
<p>An index vector indicating the elements of <code>object$clusters</code>
to print information for. The default is all clusters.</p>
</td></tr>
<tr><td><code id="summary.spscan_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns/prints a data frame. Each row of the data frame summarizes
the centroid of each cluster, the cluster radius, the number of events in
the cluster, the number of cases in the cluster, the expected number of
cases in the cluster, the relative risk of the cluster (cases/events in
cluster)(cases/events outside cluster), the natural logarithm of the test
statistic, and the associated p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grave)
out = spscan.test(grave, nsim = 99, alpha = 0.8)
summary(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
