<!DOCTYPE html><html><head><title>Help for package PTAk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PTAk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#APSOLU3'><p>Associated 3-modes Principal Tensors of a 3-modes</p>
Principal Tensor</a></li>
<li><a href='#APSOLUk'><p>Associated k-modes Principal Tensors of a k-modes Principal Tensor</p></a></li>
<li><a href='#CANDPARA'><p>CANonical DECOMPosition analysis and PARAllel FACtor analysis</p></a></li>
<li><a href='#CauRuimet'><p>Robust estimation of within group varinace-covariance</p></a></li>
<li><a href='#CONTRACTION'><p>Contraction of two tensors</p></a></li>
<li><a href='#COS2-CTR'><p>Interpretation summaries</p></a></li>
<li><a href='#datasets'><p>data used for demo in SVDgen, PTA3</p></a></li>
<li><a href='#FCA2'><p>Correspondence Analysis for 2-way tables</p></a></li>
<li><a href='#FCAk'><p>Generalisation of Correspondence Analysis for k-way tables</p></a></li>
<li><a href='#FCAmet'><p>Tool used in Generalisation of Correspondence Analysis for k-way tables</p></a></li>
<li><a href='#howtoPTAk'><p>howto for Principal Tensors Analysis of a k-modes Tensor</p></a></li>
<li><a href='#INITIA'><p>Initialisation used in SINGVA</p></a></li>
<li><a href='#PCAn'><p>Principal Component Analysis on n modes</p></a></li>
<li><a href='#plot.PTAk'><p>Plot a PTAk object</p></a></li>
<li><a href='#preprocessings'><p>Few useful functions for preprocessing arrays</p></a></li>
<li><a href='#PROJOT'><p>Orthogonal Tensor projection</p></a></li>
<li><a href='#PTA3'><p>Principal Tensor Analysis on 3 modes</p></a></li>
<li><a href='#PTAk'><p>Principal Tensor Analysis on k modes</p></a></li>
<li><a href='#PTAk-internal'><p>Internal PTAk functions</p></a></li>
<li><a href='#REBUILD'><p>Build an approximation of the tensor of any order</p></a></li>
<li><a href='#SINGVA'><p>Optimisation algorithm RPVSCC</p></a></li>
<li><a href='#summary.PTAk'><p>Summary of a PTA-k modes analysis</p></a></li>
<li><a href='#SVDgen'><p>SVD with metrics and smoothing approximation</p></a></li>
<li><a href='#TENSELE'><p>Elementary Tensor product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Principal Tensor Analysis on k Modes</td>
</tr>
<tr>
<td>Author:</td>
<td>Didier G. Leibovici (2010) &lt;doi:10.18637/jss.v034.i10&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Didier G. Leibovici &lt;GeotRYcs@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), tensor</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>A multiway method to decompose a tensor (array) of any order, as a generalisation of SVD also supporting non-identity metrics and penalisations. 2-way SVD with these extensions is also available. The package includes also some other multiway methods: PCAn (Tucker-n) and PARAFAC/CANDECOMP with these extensions. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.GeotRYcs.com">https://www.GeotRYcs.com</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 18:32:58 UTC; lgzdl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-25 00:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='APSOLU3'>Associated 3-modes Principal Tensors of a 3-modes
Principal Tensor</h2><span id='topic+APSOLU3'></span>

<h3>Description</h3>

<p> Computes all the 2-modes solutions associated to the given
Principal Tensor of the given tensor.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>APSOLU3(X,solu,pt3=NULL,nbPT2=1,
                 smoothing=FALSE,smoo=list(NA),
                        verbose=getOption("verbose"),file=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APSOLU3_+3A_x">X</code></td>
<td>
<p>a tensor (as an array) of order <em>3</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics </p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_solu">solu</code></td>
<td>
<p>a <code><a href="#topic+PTAk">PTAk</a></code> object</p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_pt3">pt3</code></td>
<td>
<p>a number identifying in <code>solu</code> the Principal Tensor to use or the
last (if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_nbpt2">nbPT2</code></td>
<td>
<p>integer, if 1 all solutions will be computed otherwise at maximum
nbPT2  solutions</p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code></p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="APSOLU3_+3A_...">...</code></td>
<td>
<p>any other arguments passed to SVDGen or other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p> For each component of the identified Principal Tensor
given in <code>solu</code>, an SVD of the contracted product of <code>X</code> and the component is done.
This gives all the associated Principal Tensors which updates <code>solu</code> supposed to contain
Principal Tensors of <code>X</code>. </p>


<h3>Value</h3>

<p>an updated <code><a href="#topic+PTAk">PTAk</a></code> object</p>


<h3>Note</h3>

<p> Usually (i.e. as in <code>PTA3</code> and <code>PTAk</code>) the principal
tensor used is the first Principal Tensor of X (and is the last updated in <code>solu</code>). If
it is another Principal Tensor, the obtained associated solutions do not <em>stricto sensu</em>
refer to the SVD-<em>k</em>modes decomposition (because the orthogonality is defined in the whole
tensor space not necessarily on each component space) but are still meaningful. </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p> Leibovici D and Sabatier R (1998) <em>A Singular Value Decomposition of a k-ways
array for a Principal Component Analysis of multi-way data, the PTA-k</em>. Linear Algebra and its
Applications, 269:307-329 </p>


<h3>See Also</h3>

<p><code><a href="#topic+PTA3">PTA3</a></code>, <code><a href="#topic+APSOLUk">APSOLUk</a></code> </p>

<hr>
<h2 id='APSOLUk'>Associated k-modes Principal Tensors of a k-modes Principal Tensor</h2><span id='topic+APSOLUk'></span>

<h3>Description</h3>

<p>Computes all the (k-1)-modes associated solutions to the given
Principal Tensor of the given tensor. Calls recursively PTAk. </p>


<h3>Usage</h3>

<pre><code class='language-R'> APSOLUk(X,solu,nbPT,nbPT2=1,
                       smoothing=FALSE,smoo=list(NA),
                        minpct=0.1,ptk=NULL,
                         verbose=getOption("verbose"),file=NULL,
                          modesnam=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APSOLUk_+3A_x">X</code></td>
<td>

<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_solu">solu</code></td>
<td>
<p>a <code>PTAk</code>  object </p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_nbpt">nbPT</code></td>
<td>
<p>a number or a vector of dimension <em>(k-2)</em></p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_nbpt2">nbPT2</code></td>
<td>
<p>integer, if 0 no 2-modes solutions will be computed, 1 means all, &gt;1 otherwise</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code></p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_minpct">minpct</code></td>
<td>
<p>numerical 0-100 to control of computation of future solutions at this level and below</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_ptk">ptk</code></td>
<td>
<p>a number identifying in solutions the Principal Tensor to use or the last (if <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> &quot;<code>mo 1</code>&quot; ...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="APSOLUk_+3A_...">...</code></td>
<td>
<p>any other arguments passed to PTAk or other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each component of the identified  Principal Tensor given in
<code>solutions</code>, a PTA-<em>(k-1)</em>modes of the contracted product
of X and the component is done. This gives all the associated
Principal Tensors which updates  <code>solutions</code> supposed to contain
a Principal Tensors of X at the first place. For full description of
arguments see <code><a href="#topic+PTAk">PTAk</a></code>.</p>


<h3>Value</h3>

<p>an updated <code>PTAk</code> object </p>


<h3>Note</h3>

<p>Usually (<em>i.e.</em> as in <code>PTA3</code> and <code>PTAk</code>) the
principal tensor used is the first Principal Tensor of
<code>X</code> (and is the last updated in <code>solutions</code>). If
it is another Principal Tensor, the obtained associated
solutions do not <em>stricto sensu</em> refer to the
SVD-<em>k</em>modes decomposition (because the orthogonality
is defined in the whole tensor space not necessarily on
each component space) but are still meaningful. This
function is usually called by <code>PTAk</code> but can be used
on its own to carry on a <code>PTAk</code> analysis if <code>X</code>
is the projected (of the original data) on the orthogonal
of all the <em>k</em>modes Principal Tensor. In other words
the <code>ptk</code> rank-one tensor in <code>solutions</code> should
be the first best rank-one tensor approximating <code>X</code>
for this decomposition analysis to be called
PTA-<em>k</em>modes.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329. </p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code> </p>

<hr>
<h2 id='CANDPARA'>CANonical DECOMPosition analysis and PARAllel FACtor analysis</h2><span id='topic+CANDPARA'></span>

<h3>Description</h3>

<p>Performs the identical models known as PARAFAC or CANDECOMP model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CANDPARA(X,dim=3,test=1E-8,Maxiter=1000,
                     smoothing=FALSE,smoo=list(NA),
                      verbose=getOption("verbose"),file=NULL,
                       modesnam=NULL,addedcomment="")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CANDPARA_+3A_x">X</code></td>
<td>
<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code> as the array and
<code>met</code> a list of metrics.</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_dim">dim</code></td>
<td>
<p>a number specifying the number of rank-one tensors </p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_test">test</code></td>
<td>
<p>control of convergence</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_maxiter">Maxiter</code></td>
<td>
<p>maximum number of iterations allowed for convergence</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code></p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code>
&quot;<code>mo 1</code>&quot; ...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="CANDPARA_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed after the title of the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking for the best rank-one tensor approximation (LS) the three
methods described in the package are equivalent. If the number of
tensors looked for is greater then one the methods differs:
PTA-<em>k</em>modes will look for best approximation according to the
<em>orthogonal rank</em> (<em>i.e.</em> the rank-one tensors are
orthogonal), PCA-<em>k</em>modes will look for best approximation
according to the <em>space ranks</em> (<em>i.e.</em> the ranks of all
(simple) bilinear forms , that is the number of components in each
space), PARAFAC/CANDECOMP will look for best approximation according
to the <em>rank</em> (<em>i.e.</em> the rank-one tensors are not
necessarily orthogonal). For sake of comparisons the
PARAFAC/CANDECOMP method and the PCA-<em>n</em>modes are also in the
package but complete functionnality of the use these methods and more
complete packages may be checked at the www site quoted below.
</p>


<h3>Value</h3>

<p>a <code>CANDPARA</code> (inherits from <code><a href="#topic+PTAk">PTAk</a></code>) object</p>


<h3>Note</h3>

<p>The use of metrics (diagonal or not) and smoothing extends
flexibility of analysis. This program runs slow! A PARAFAC orthogonal
can be done with PTAk looking only for k-modes Principal Tensors
<em>i.e.</em> with the options <code>nbPT=c(rep(0,k-2),dim), nbPT2=0</code>.
It is identical to look in any <code>PTAk</code> decomposition only for the
<em>k</em>modes solution but obviously with unecessary computations.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Caroll J.D and Chang J.J (1970) <em>Analysis of individual
differences in multidimensional scaling via n-way generalization of
'Eckart-Young' decomposition</em>. Psychometrika 35,283-319.
</p>
<p>Harshman R.A (1970) <em>Foundations of the PARAFAC procedure:
models and conditions for 'an explanatory' multi-mode factor
analysis</em>. UCLA Working Papers in Phonetics, 16,1-84.
</p>
<p>Kroonenberg P (1983) <em>Three-mode Principal Component Analysis:
Theory and Applications</em>. DSWO press. Leiden.)
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
</p>

<hr>
<h2 id='CauRuimet'>Robust estimation of within group varinace-covariance</h2><span id='topic+CauRuimet'></span>

<h3>Description</h3>

<p> Gives a robust estimate of an unknown within group covariance, aiming either to look
for dense groups or to sparse groups (outliers) according to <em>local variance and weighting
function</em> choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CauRuimet(Z,ker=1,m0=1,withingroup=TRUE,
              loc=substitute(apply(Z,2,mean,trim=.1)),matrixmethod=TRUE, Nrandom=3000)

        </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CauRuimet_+3A_z">Z</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_ker">ker</code></td>
<td>
<p>either numerical or a function:
if numerical the weighting function is <code class="reqn">e^{(-ker \;t)}</code>, otherwise
<br /> ker=function(t){return(expression)} is a positive decreasing function. </p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_m0">m0</code></td>
<td>

<p>is a graph of neighbourhood or another proximity matrix, the hadamard product of the proximities
will be operated</p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_withingroup">withingroup</code></td>
<td>

<p>logical,if <code>TRUE</code> the aim is to give a robust estimate for dense groups, if <code>FALSE</code> the
aim is to give a robust estimate for outliers</p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_loc">loc</code></td>
<td>

<p>a vector of locations or a function using mean, median, to give an estimate of it</p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_matrixmethod">matrixmethod</code></td>
<td>
<p>if <code>TRUE</code> (only with <code>withingroup</code>) uses some matrix computation rather
than double looping as suggests the formula below </p>
</td></tr>
<tr><td><code id="CauRuimet_+3A_nrandom">Nrandom</code></td>
<td>
<p>if <code>Nrandom &lt; dim(Z)[1]</code>) uses  only  a <code>Nrandom</code> sample from rows of <code>Z</code> and  
<code>m0</code> if applicable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When withingroup is <code>TRUE</code>, local(defined by the weighting) variance formula is returned, aiming
at finding dense groups: </p>
<p style="text-align: center;"><code class="reqn">W_l=\frac{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))(Z_i-Z_j)'(Z_i-Z_j)}{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))}</code>
</p>
<p> where <code class="reqn">d^2_{S^-}( . , .)</code> is the squared euclidian distance with
<code class="reqn">S^-</code> the inverse of a robust sample covariance (i.e. using <code>loc</code> instead of the mean) ;
if <code>FALSE</code> robust Total weighted variance or if <code>m0</code> not 1  Global weighted variance, is returned:
</p>
<p style="text-align: center;"><code class="reqn">W_o=\frac{\sum_{i=1}^nker(d^2_{S^-}(Z_i,\tilde{Z}))(Z_i-\tilde{Z})'(Z_i-\tilde{Z})}
 {\sum_{i=1}^n  ker(d^2_{S^-}(Z_i,\tilde{Z}))}</code>
</p>

<p style="text-align: center;"><code class="reqn">W_g=\frac{\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}.ker(d^2_{S^-}(Z_i,Z_j))(Z_i-\tilde{Z})'(Z_j-\tilde{Z})}
 {\sum_{i=1}^{n-1}\sum_{j=i+1}^n
m0_{ij}ker(d^2_{S^-}(Z_i,Z_j))}</code>
</p>

<p>where <code class="reqn">\tilde{Z}</code> is the vector <code>loc</code>.
<br />
If <code>m0</code> is a graph of neighbourhood and ker is the function returning 1 (no proximity due to
distance is used) the function will return (when <code>withingroup=TRUE</code>) the <em>local
variance-covariance</em> matrix as define in Lebart(1969). </p>


<h3>Value</h3>

<p>a matrix</p>


<h3>Note</h3>

<p>As mentioned by Caussinus and Ruiz a good strategy to reveal dense groups with generalised PCA
would be to reveal outliers first using the metric <code class="reqn">W_o^{-1}</code> and remove them before using the
metric <code class="reqn">W_l^{-1}</code>. Based on theoretical considerations they recommand for  the choice of
<code>ker</code>, with the decreasing function <code class="reqn">e^{(-ker \;t)}</code>: a lower bound of 1 if
<code>withingroup</code> and something fairly small say in the interval [0.05;0.3] otherwise.
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Caussinus, H and Ruiz, A (1990) <em>Interesting Projections of Multidimensional Data by Means of
Generalized Principal Components Analysis</em>. COMPSTAT90, Physica-Verlag, Heidelberg,121-126.
</p>
<p>Faraj, A (1994) <em>Interpretation tools for Generalized Discriminant Analysis</em>.In: New
Approches in Classification and Data Analysis, Springer-Verlag, 286-291, Heidelberg.
</p>
<p>Lebart, L (1969) <em>Analyse statistique de la contiguit&lt;e9&gt;e</em>.Publication de l'Institut de
Statistiques Universitaire de Paris, XVIII,81-112.
</p>
<p>Leibovici D (2008) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes: the R package <span class="pkg">PTAk</span></em>
. to be submitted soon at Journal of Statisticcal Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVDgen">SVDgen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(iris)
  iris2 &lt;- as.matrix(iris[,1:4])
  dimnames(iris2)[[1]] &lt;- as.character(iris[,5])

 D2 &lt;- CauRuimet(iris2,ker=1,withingroup=TRUE)
 D2 &lt;- Powmat(D2,(-1))
 iris2 &lt;- sweep(iris2,2,apply(iris2,2,mean))
 res &lt;- SVDgen(iris2,D2=D2,D1=1)
 plot(res,nb1=1,nb2=2,cex=1,mod=1,Zcol=list(c(rep(1,50),rep(2,50),rep(3,50))))
 summary(res,testvar=0)

 # the same in a demo function
 # source(paste(R.home(),"/library/PTAk/demo/CauRuimet.R",sep=""))
 # demo.CauRuimet(ker=4,withingroup=TRUE,openX11s=FALSE)
 # demo.Cauruimet(ker=0.15,withingroup=FALSE,openX11s=FALSE)
</code></pre>

<hr>
<h2 id='CONTRACTION'>Contraction of two tensors </h2><span id='topic+CONTRACTION'></span><span id='topic+CONTRACTION.list'></span>

<h3>Description</h3>

<p>Computes the contraction product of two tensors as a generalisation of matrix product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> CONTRACTION(X,z, Xwiz=NULL,zwiX=NULL,rezwiX=FALSE,usetensor=TRUE)
 CONTRACTION.list(X,zlist,moins=1,zwiX=NULL,usetensor=TRUE,withapply=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CONTRACTION_+3A_x">X</code></td>
<td>
<p>a tensor(as an array) of any order</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_z">z</code></td>
<td>
<p>another tensor  (with at least one space in common)</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_zlist">zlist</code></td>
<td>

<p>a list of lists like a <code>solution.PTAk</code> at least with
<code>v</code> for every list(here <code>v</code> can be any array) </p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_xwiz">Xwiz</code></td>
<td>

<p><code>Xwiz</code> is to specify the entries of <code>X</code> to
contract with entries of <code>z</code> specified by <code>zwiX</code>,
if <code>Xwiz</code> <code>NULL</code> <code>dim(z)[zwiX]</code> matching
<code>dim(X)</code> will do without ambiguity (taking all
<code>z</code> dimensions if <code>zwiX</code> is <code>NULL</code>). In
<code>CONTRACTION.list</code> it is not set as one supposes the
contractions in the list to operate follow the dimensions
of X</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_zwix">zwiX</code></td>
<td>

<p>idem as <code>Xwiz</code>. If both <code>Xwiz</code> and <code>zwiX</code>
are <code>NULL</code> <code>zwiX</code>is replaced by full
possibilities (<code>1:length(dimz)</code>) then <code>Xwiz</code> is
looked for. In <code>CONTRACTION.list</code> it is the vector for
dimensions in the <code>v</code> to contract with X. Only 1-way
dimension for each <code>v</code>.</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_moins">moins</code></td>
<td>

<p>the elements in <code>zlist</code> to skip (see also
<code><a href="#topic+TENSELE">TENSELE</a></code>)</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_rezwix">rezwiX</code></td>
<td>

<p>logical if <code>TRUE</code> (and zwiX is <code>NULL</code>) rematches
the dimensions in for <code>zwiX</code>: useful only if the
dimensions of z were not following the Xwiz order and are
not equals.</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_usetensor">usetensor</code></td>
<td>
<p>if <code>TRUE</code> uses <code>tensor</code> (add-on package)</p>
</td></tr>
<tr><td><code id="CONTRACTION_+3A_withapply">withapply</code></td>
<td>
<p>if <code>TRUE</code> (only for vectors in <code>zlist</code> uses <code>apply</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like two matrices <em>contract</em> according to the
appropriate dimensions (columns matching rows) when one
performs a matrix product, this operation does pretty much
the same thing for tensors(array) and specified contraction
dimensions given by <code>Xwiz</code> and <code>zwiX</code> which
should match. The function is actually written like:
transforms both tensors as matrices with the &ldquo;matching
tensor product&quot; of their contraction dimensions in columns
(for higher order tensor) and rows (the other one),
performs the matrix product and rebuild the result as a
tensor(array). Without using <code>tensor</code>, if <code>Xwiz</code>
and/or <code>zwiX</code> are not specified the functions tries to
match all <code>z</code> dimensions onto the dimensions of X
where X is the higher order tensor (if it is not the case
in the arguments the function swaps them). </p>


<h3>Value</h3>

<p>A tensor of dimension <code>c(dim(X)[-Xwiz],dim(z)[-zwiX])</code>
if <code>X</code> has got a bigger order than <code>z</code>.</p>


<h3>Note</h3>

<p>This operation generalises the <em>matrix</em> product to the
<em>contracted</em> product of any two tensors(arrays), and
should theoretically perform the tensor product if no
matching (no contraction) but has not been implemented. I
recently put the option of using <code>tensor</code> which does
exactly the same thing faster as well as it is from
<code>C</code>. When using <code>tensor</code> if <code>Xwiz</code> or
<code>zwiX</code> are <code>NULL</code> they are replaced by the full
possibilities.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component
Analysis of multi-way data, the PTA-k</em>. Linear Algebra and
its Applications, 269:307-329.
</p>
<p>Schwartz L (1975) <em>Les Tenseurs</em>. Herman, Paris. </p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code>,  <code><a href="#topic+APSOLUk">APSOLUk</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> library(tensor)
   z &lt;-  array(1:12,c(2,3,2))
   X &lt;- array(1:48,c(3,4,2,2))
   Xcz &lt;- CONTRACTION(X,z,Xwiz=c(1,3,4),zwiX=c(2,3,1))
   dim(Xcz)   # 4
   Xcz1 &lt;- CONTRACTION(X,z,Xwiz=c(3,4),zwiX=c(1,3))
   dim(Xcz1) # 3,4,3
   Xcz2 &lt;- CONTRACTION(X,z,Xwiz=c(3,4),zwiX=c(3,1))
   Xcz1[,,1]
   Xcz2[,,1]
   #######
   sval0 &lt;- list(list(v=c(1,2,3,4)),list(v=rep(1,3)),list(v=c(1,3)))
   tew &lt;- array(1:24,c(4,3,2))
    CONTRACTION.list(tew,sval0,moins=1)
       #this is equivalent to the following which may be too expensive for big datasets
    CONTRACTION(tew,TENSELE(sval0,moins=1),Xwiz=c(2,3))
   ##
     CONTRACTION.list(tew,sval0,moins=c(1,2)) #must be equal to
     CONTRACTION(tew,sval0[[3]]$v,Xwiz=3)
   </code></pre>

<hr>
<h2 id='COS2-CTR'>Interpretation summaries</h2><span id='topic+COS2'></span><span id='topic+CTR'></span>

<h3>Description</h3>

<p>After a <code><a href="#topic+FCA2">FCA2</a></code>, a <code><a href="#topic+SVDgen">SVDgen</a></code>, a <code><a href="#topic+FCAk">FCAk</a></code> or a <code><a href="#topic+PTAk">PTAk</a></code> computes the traditional guides for interpretations used in PCA and correspondence analysis: COS2 or the percentage of variability rebuilt by the component and CTR or the amount of contribution towards that component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COS2(solu, mod=1, solnbs=2:4)
CTR(solu, mod=1, solnbs=1:4, signed = TRUE, mil = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COS2-CTR_+3A_solu">solu</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code>, representing a generalised  singular value decomposition</p>
</td></tr>
<tr><td><code id="COS2-CTR_+3A_mod">mod</code></td>
<td>
<p>an integer representing the mode number entry, 1 is row, 2 columns, ...</p>
</td></tr>
<tr><td><code id="COS2-CTR_+3A_solnbs">solnbs</code></td>
<td>
<p>a vector of integers representing the tensor numbers in the listing summary</p>
</td></tr>
<tr><td><code id="COS2-CTR_+3A_signed">signed</code></td>
<td>
<p>logical to use signed-CTR from affect the sign of corresponding value in <code>solu[[mod]]$v[,c ]</code>, c defined by solnbs.</p>
</td></tr>
<tr><td><code id="COS2-CTR_+3A_mil">mil</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classical measures helping to interpret the plots in PCA, FCA and in PTAk as well.
The sum of the COS2 across all the components needed to rebuild fully the tensor analysed) would make 1000 and the sum pf the CTR across the entry mode would be 1000.
</p>


<h3>Value</h3>

<p>a matrix whose columns are the COS2 or CTR  as per thousands (‰) for the mode considered </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Escoufier Y (1985) <em>L'Analyse des correspondances : ses
propriétés et ses extensions</em>. ISI 45th session Amsterdam.
</p>
<p>Leibovici D(1993) <em>Facteurs à Mesures Répétées et Analyses Factorielles :
applications à un suivi Epidémiologique</em>. Université de Montpellier
II. PhD Thesis in Mathématiques et Applications (Biostatistiques).
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+FCA2">FCA2</a></code>, <code><a href="#topic+FCAk">FCAk</a></code>, <code><a href="#topic+summary.FCAk">summary.FCAk</a></code>, <code><a href="#topic+plot.PTAk">plot.PTAk</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> data(crimerate)
  cri.FCA2 &lt;- FCA2(crimerate)
   summary(cri.FCA2)
    plot(cri.FCA2, mod = c(1,2), nb1 = 2, nb2 = 3) # unscaled
    plot(cri.FCA2, mod = c(1,2), nb1 = 2, nb2 = 3, coefi = 
    	list(c(0.130787,0.130787),c(0.104359,0.104359)) ) # symmetric-map biplot
   CTR(cri.FCA2, mod = 1, solnbs = 2:4)
   CTR(cri.FCA2, mod = 2, solnbs = 2:4)
 COS2(cri.FCA2, mod = 2, solnbs = 2:4)
 ##### useful fonctions
 ##selecting and sorting out dimensions positive and negative sides
 "ctrcos2" &lt;-function(Ta, mod=1, dim=2, NegPos=TRUE, select=c("avg",12,"none"),nbdig=2, 
 			cos2min=333){
	dim=c(dim, dim+1)
	ctr=CTR(Ta,mod=mod,solnbs=dim);cos2=COS2(Ta,mod=mod,solnbs=dim)
	val=round(Ta[[mod]]$v[dim,][1,],digits=nbdig)
	oo=order(ctr[,1],decreasing=TRUE)
	if(NegPos)oo=order(val,decreasing=TRUE)
	out=cbind(ctr[oo,1],cos2[oo,1],val[oo])
	colnames(out)=c("ctr","cos2",paste0("dim",dim[1]))
	if(select[1]=="none") sout=0
	if(select[1]=="avg") sout= 1000/length(val)
	if(is.numeric(select[1])) sout=select[1]
return(out[ out[,1]&gt;=sout | out[,2]&gt;=cos2min, ])	 
}#ctrcos2

## plot ctr cos2
"plotctrcos2"&lt;-function(sol,mod12=c(1,2),dim=2, ratio2avg=TRUE, col=c(1,2),pch=c("-","°"), 
				posi=c(2,3),reposi=TRUE, cos2min=333,select="avg",...){
	### ctrcos2 ini Ta,mod=1,dim=2, NegPos=TRUE, select=c("avg",12,"none"), nbdig=2, cos2min=333
	pre&lt;-function(mod=1,soldim=2, ...){
	diim=length(sol[[mod]]$v[1,])
	ctrov= ctrcos2(sol,dim= soldim,mod=mod,...)	
	x=ctrov[,1]*sign(ctrov[,3])
	if(ratio2avg)x=round(x/(1000/diim),2)
	y=ctrov[,2]
	lab=rownames(ctrov)
	len=dim(ctrov)[1]
	return(list("x"=x,"y"=y,"len"=len,"lab"=lab))
	}
	if(length(col)&lt;length(mod12))col=rep(col,length(mod12))
	if(length(pch)&lt;length(mod12))pch=rep(pch,length(mod12))
	x=NULL;y=NULL;coul=NULL;pchl=NULL;lab=NULL;poslab=NULL
	for(m in mod12){
		prep=pre(mod=m,soldim=dim,...)
		x=c(x,prep$x);y=c(y,prep$y);
        coul=c(coul,rep(col[m],prep$len));pchl=c(pchl,rep(pch[m],prep$len))
		repos=rep(posi[m],prep$len); if(reposi)repos=sample(1:4,prep$len, replace=TRUE)
		lab=c(lab,prep$lab);poslab=c(poslab,repos)
	}
	summsol=summary(sol)
	
	if(match("FCA2" ,class(sol),nomatch=0)&gt;0) xlabe=paste0( "Global pct ",
	round(summsol[dim,4],2), " FCA pct",round(summsol[dim,5],2)) else 
	xlabe=paste0( " local pxt",round(summsol[dim,4],2), " Global pct", round(summsol[dim,5],2))
	dimi=paste0("dim",dim)
	if(ratio2avg)ctrlab="CTR (signed ctr /(uniform ctr))" else ctrlab="CTR (signed)"
	if(!is.null(cos2min))cos2lab=paste("COS2 (&gt; ",cos2min,")")else cos2lab= "COS2"
	plot(x,y,xlab=ctrlab, main=paste(dimi, xlabe ),ylab= cos2lab,col=coul,
	             pch=pchl,ylim=c(min(y),1050),xlim=c(min(x-0.5),max(x+0.5)))
	abline(v=0,col=4,lty=2)
	abline(v=1,col=3,lty=2)
	abline(v=-1,col=3,lty=2)
	text(x,y,lab,pos=poslab, col=coul)
return(cbind(x,y,lab,coul,pchl,poslab))
}#plotctrcos2

ctrcos2(cri.FCA2,mod=1)
ctrcos2(cri.FCA2,mod=2)
plotctrcos2(cri.FCA2)
 
</code></pre>

<hr>
<h2 id='datasets'>data used for demo in SVDgen, PTA3</h2><span id='topic+timage12'></span><span id='topic+crimerate'></span><span id='topic+Zone_climTUN'></span>

<h3>Description</h3>

<p>The <code>crimerate</code> dataset provides crime rates per 100,000 people in
seven categories for each of the fifty states (USA) in 1977.  The <code>timage12</code> dataset
is an image from fMRI analysis (one brain slice), it is a <em>t</em>-statistic image over 12 subjects of the activation (verbal) parameter.
The <code>Zone_climTUN</code> is an object of class Map  representing montly (<code>12</code>) measurements in  Tunisia  
of <code>10</code> climatic indicators. The grid of <code>2599</code> cells was stored previously as a shapefile and read using <code>read.shape</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(crimerate)
data(timage12)
data(Zone_climTUN)
</code></pre>


<h3>Format</h3>

<p><code>crimerate</code> is a matrix of <code>50 x 7</code> for the <code>crimerate</code> data.
</p>
<p><code>timage12</code> is a matrix <code>91 x 109</code> for <code>timage12</code> data.</p>


<h3>Source</h3>

<p><code>crimerate</code> comes from SAS. The <code>timage12</code> comes from FMRIB center, University of Oxford. 
The <code>Zone_climTUN</code> comes from WorldCLIM database 2000 see references along with description of the indicators in Leibovici et al.(2007).
</p>


<h3>References</h3>

<p>Leibovici D, Quillevere G, Desconnets JC (2007). A Method to Classify Ecoclimatic Arid
and Semi-Arid Zones in Circum-Saharan Africa Using Monthly Dynamics of Multiple
Indicators. IEEE Transactions on Geoscience and Remote Sensing, 45(12), 4000-4007.</p>

<hr>
<h2 id='FCA2'>Correspondence Analysis for 2-way tables</h2><span id='topic+FCA2'></span>

<h3>Description</h3>

<p>Performs a particular <code>SVDgen</code>  data as a ratio Observed/Expected
under complete independence with metrics as margins of the
contingency table (in frequencies).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FCA2(X, nbdim =NULL, minpct = 0.01, smoothing = FALSE,
         smoo = rep(list(function(u) ksmooth(1:length(u), u, kernel = "normal",
        bandwidth = 3, x.points = (1:length(u)))$y), length(dim(X))),
      verbose = getOption("verbose"), file = NULL, modesnam = NULL,
    addedcomment = "", chi2 = FALSE, E = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCA2_+3A_x">X</code></td>
<td>
<p>a matrix table of positive values</p>
</td></tr>
<tr><td><code id="FCA2_+3A_nbdim">nbdim</code></td>
<td>
<p>a number of dimension to retain, if <code>NULL</code> the default value of maximum possible number of dimensions is kept</p>
</td></tr>
<tr><td><code id="FCA2_+3A_minpct">minpct</code></td>
<td>
<p>numerical 0-100 to control of computation of future solutions at this level and below</p>
</td></tr>
<tr><td><code id="FCA2_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="FCA2_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="FCA2_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="FCA2_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="FCA2_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> &quot;<code>mo 1</code>&quot;
...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="FCA2_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed if <code>printt</code> after the title of the analysis</p>
</td></tr>
<tr><td><code id="FCA2_+3A_chi2">chi2</code></td>
<td>
<p>print the chi2 information when computing margins in <code><a href="#topic+FCAmet">FCAmet</a></code></p>
</td></tr>
<tr><td><code id="FCA2_+3A_e">E</code></td>
<td>
<p> if not <code>NULL</code> is a matrix with the same dimensions as X with the same margins</p>
</td></tr>
<tr><td><code id="FCA2_+3A_...">...</code></td>
<td>
<p>any other arguments passed to SVDGen or other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gives the SVD-<em>2</em>modes decomposition of the <code class="reqn">1+\chi^2/N</code> of
the contingency table of full count <code class="reqn">N=\sum X_{ij}</code>,
i.e. complete independence + lack of independence (including marginal
independences) as shown for example in Lancaster(1951)(see reference
in Leibovici(1993 or 2000)). Noting <code class="reqn">P=X/N</code>,  a <code>SVD</code> of the
<code class="reqn">(3)</code>-uple is done, that is :
</p>
<p style="text-align: center;"><code class="reqn"> ((D_I^{-1} \otimes D_J^{-1})..P, \quad D_I, \quad D_J)</code>
</p>

<p>where the metrics are diagonals of the corresponding margins. For
full description of arguments see <code><a href="#topic+PTAk">PTAk</a></code>. If <code>E</code>
is not <code>NULL</code> an FCAk-modes relatively to a model is
done (see Escoufier(1985) and therin reference
Escofier(1984) for a 2-way derivation), e.g. for a three way contingency table
<code class="reqn">k=3</code> the <em>4</em>-tuple data and metrics is:
</p>
<p style="text-align: center;"><code class="reqn"> ((D_I^{-1} \otimes D_J^{-1} \otimes D_K^{-1})(P-E), \quad D_I, \quad D_J, \quad D_K)</code>
</p>

<p>If <code>E</code> was the complete independence (product of the margins)
then this would give an <code>AFCk</code> but without looking at the
marginal  dependencies (i.e. for a three way table no two-ways lack of
independence are looked for).
</p>


<h3>Value</h3>

<p>a <code>FCA2</code> (inherits <code><a href="#topic+FCAk">FCAk</a></code> and <code><a href="#topic+PTAk">PTAk</a></code>) object </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Escoufier Y (1985) <em>L'Analyse des correspondances : ses
propriétés et ses extensions</em>. ISI 45th session Amsterdam.
</p>
<p>Leibovici D(1993) <em>Facteurs à Mesures Répétées et Analyses Factorielles :
applications à un suivi Epidémiologique</em>. Université de Montpellier
II. PhD Thesis in Mathématiques et Applications (Biostatistiques).
</p>
<p>Leibovici D (2000) <em>Multiway Multidimensional Analysis for
Pharmaco-EEG Studies</em>.<a href="http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf">http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf</a>
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>
<p>Leibovici DG and Birkin MH (2013) Simple, multiple and multiway correspondence analysis applied to spatial census-based population microsimulation studies using R. NCRM Working Paper. NCRM-n^o 07/13, Id-3178 <a href="https://eprints.ncrm.ac.uk/id/eprint/3178">https://eprints.ncrm.ac.uk/id/eprint/3178</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+FCAmet">FCAmet</a></code>, <code><a href="#topic+summary.FCAk">summary.FCAk</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'> data(crimerate)
 cri.FCA2 &lt;- FCA2(crimerate)
 summary(cri.FCA2)
  plot(cri.FCA2, mod = c(1,2), nb1 = 2, nb2 = 3) # unscaled
  plot(cri.FCA2, mod = c(1,2), nb1 = 2, nb2 = 3, coefi = 
  	list(c(0.130787,0.130787),c(0.104359,0.104359)) )# symmetric-map biplot
 CTR(cri.FCA2, mod = 1, solnbs = 2:4)
 CTR(cri.FCA2, mod = 2, solnbs = 2:4)
 COS2(cri.FCA2, mod = 2, solnbs = 2:4)
 
 
</code></pre>

<hr>
<h2 id='FCAk'>Generalisation of Correspondence Analysis for k-way tables</h2><span id='topic+FCAk'></span>

<h3>Description</h3>

<p>Performs a particular <code>PTAk</code>  data as a ratio Observed/Expected
under complete independence with metrics as margins of the multiple
contingency table (in frequencies).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FCAk(X,nbPT=3,nbPT2=1,minpct=0.01,
               smoothing=FALSE,smoo=rep(list(
                       function(u)ksmooth(1:length(u),u,kernel="normal",
                       bandwidth=3,x.points=(1:length(u)))$y),length(dim(X))),
                     verbose=getOption("verbose"),file=NULL,
                       modesnam=NULL,addedcomment="",chi2=TRUE,E=NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCAk_+3A_x">X</code></td>
<td>
<p>a multiple contingency table (array) of order <em>k</em></p>
</td></tr>
<tr><td><code id="FCAk_+3A_nbpt">nbPT</code></td>
<td>
<p>a number or a vector of dimension <em>(k-2)</em></p>
</td></tr>
<tr><td><code id="FCAk_+3A_nbpt2">nbPT2</code></td>
<td>
<p>if 0 no 2-modes solutions will be computed, 1 =all, &gt;1
otherwise</p>
</td></tr>
<tr><td><code id="FCAk_+3A_minpct">minpct</code></td>
<td>
<p>numerical 0-100 to control of computation of future solutions at this level and below</p>
</td></tr>
<tr><td><code id="FCAk_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="FCAk_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="FCAk_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="FCAk_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="FCAk_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> &quot;<code>mo 1</code>&quot;
...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="FCAk_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed if <code>printt</code> after the title of the analysis</p>
</td></tr>
<tr><td><code id="FCAk_+3A_chi2">chi2</code></td>
<td>
<p>print the chi2 information when computing margins in <code><a href="#topic+FCAmet">FCAmet</a></code></p>
</td></tr>
<tr><td><code id="FCAk_+3A_e">E</code></td>
<td>
<p> if not <code>NULL</code> is an array with the same dimensions as X</p>
</td></tr>
<tr><td><code id="FCAk_+3A_...">...</code></td>
<td>
<p>any other arguments passed to SVDGen or other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gives the SVD-<em>k</em>modes decomposition of the <code class="reqn">1+\chi^2/N</code> of
the multiple contingency table of full count <code class="reqn">N=\sum X_{ijk...}</code>,
i.e. complete independence + lack of independence (including marginal
independences) as shown for example in Lancaster(1951)(see reference
in Leibovici(2000)). Noting <code class="reqn">P=X/N</code>,  a <code>PTAk</code> of the
<code class="reqn">(k+1)</code>-uple is done, e.g. for a three way contingency table
<code class="reqn">k=3</code> the <em>4</em>-uple data and metrics is:
</p>
<p style="text-align: center;"><code class="reqn"> ((D_I^{-1} \otimes D_J^{-1} \otimes D_K^{-1})P, \quad D_I, \quad D_J, \quad D_K)</code>
</p>

<p>where the metrics are diagonals of the corresponding margins. For
full description of arguments see <code><a href="#topic+PTAk">PTAk</a></code>. If <code>E</code>
is not <code>NULL</code> an FCAk-modes relatively to a model is
done (see Escoufier(1985) and therin reference
Escofier(1984) for a 2-way derivation), e.g. for a three way contingency table
<code class="reqn">k=3</code> the <em>4</em>-tuple data and metrics is:
</p>
<p style="text-align: center;"><code class="reqn"> ((D_I^{-1} \otimes D_J^{-1} \otimes D_K^{-1})(P-E), \quad D_I, \quad D_J, \quad D_K)</code>
</p>

<p>If <code>E</code> was the complete independence (product of the margins)
then this would give an <code>AFCk</code> but without looking at the
marginal  dependencies (i.e. for a three way table no two-ways lack of
independence are looked for).
</p>


<h3>Value</h3>

<p>a <code>FCAk</code> (inherits <code><a href="#topic+PTAk">PTAk</a></code>) object </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Escoufier Y (1985) <em>L'Analyse des correspondances : ses
propri&lt;e9&gt;t&lt;e9&gt;s et ses extensions</em>. ISI 45th session Amsterdam.
</p>
<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D (2000) <em>Multiway Multidimensional Analysis for
Pharmaco-EEG Studies</em>.<a href="http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf">http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf</a>
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>
<p>Leibovici DG and Birkin MH (2013) Simple, multiple and multiway correspondence analysis applied to spatial census-based population microsimulation studies using R. NCRM Working Paper. NCRM-n^o 07/13, Id-3178 <a href="https://eprints.ncrm.ac.uk/id/eprint/3178">https://eprints.ncrm.ac.uk/id/eprint/3178</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+FCAmet">FCAmet</a></code>, <code><a href="#topic+summary.FCAk">summary.FCAk</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>   # try the demo
   # demo.FCAk()
</code></pre>

<hr>
<h2 id='FCAmet'>Tool used in Generalisation of Correspondence Analysis for k-way tables</h2><span id='topic+FCAmet'></span>

<h3>Description</h3>

<p>Computes the  ratio Observed/Expected under complete independence
with margins of the multiple contingency table (in frequencies) and
gives <code>chi2</code> statistic of lack of complete independence. </p>


<h3>Usage</h3>

<pre><code class='language-R'> FCAmet(X,chi2=FALSE,E=NULL,No0margins=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCAmet_+3A_x">X</code></td>
<td>
<p>a multiple contingency table (array) of order <em>k</em></p>
</td></tr>
<tr><td><code id="FCAmet_+3A_chi2">chi2</code></td>
<td>
<p>if <code>TRUE</code> prints the chi2 statistic information </p>
</td></tr>
<tr><td><code id="FCAmet_+3A_e">E</code></td>
<td>
<p>if not <code>NULL</code> represent a model which
would be used for an <code><a href="#topic+FCAk">FCAk</a></code> relatively to a model</p>
</td></tr>
<tr><td><code id="FCAmet_+3A_no0margins">No0margins</code></td>
<td>
<p>if TRUE, prevents zero margins in replacing cells involved by the min of the non-zero margins /nb of zero cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr><td><code>data</code></td>
<td>

<p>an array <code>(X/count (-E))/Indepen</code> where <code>Indepen</code> is the array obtained
from he products of the margins</p>
</td></tr>
<tr><td><code>met</code></td>
<td>

<p>a list wherein each entry is the vector of the corresponding margins i.e.
<code>apply(X,i,sum)/count</code></p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>is the total sum <code>sum(X).</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The statistics and metrics do not depend on <code>E</code>. The statistic given measure only the lack of independence.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>See Also</h3>

 <p><code><a href="#topic+FCAk">FCAk</a></code> </p>

<hr>
<h2 id='howtoPTAk'>howto for Principal Tensors Analysis of a k-modes Tensor</h2><span id='topic+howtoPTAk'></span>

<h3>Description</h3>

<p>A mini guide to handle PTAk model decomposition</p>


<h3>Usage</h3>

<pre><code class='language-R'>howtoPTAk()</code></pre>


<h3>Details</h3>

<p>The PTAk decomposition aims at building an approximation of a given multiway data, represented as a tensor, based on a variance criterion. This approximation is given by a set of rank one tensors, orthogonal to each other, in a nested algorithm process and so controlling the level of approximation by the amount of variability extracted and represented by the sum of squares of the singular values (associated to the rank one tensors). In that respect it offers a way of generalising PCA to tensors of order greater than 2.
</p>
<p>The reference in JSS provides details about preparing a dataset and running a general PTAk and particularities for spatio-temporal data. Some aspects on FCAk can also be found in the NCRM publication.
</p>
<p>The license is GPL-3, support can be provided via http://c3s2i.free.fr, donations via Paypal to c3s2i@free.fr are welcome.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p> Leibovici D and Sabatier R (1998) <em>A Singular Value Decomposition of a k-ways
array for a Principal Component Analysis of multi-way data, the PTA-k</em>. Linear Algebra and its
Applications, 269:307-329 
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>
<p>Leibovici DG and Birkin MH (2013) Simple, multiple and multiway correspondence analysis applied to spatial census-based population microsimulation studies using R. NCRM Working Paper. NCRM-n^o 07/13, Id-3178 <a href="https://eprints.ncrm.ac.uk/id/eprint/3178">https://eprints.ncrm.ac.uk/id/eprint/3178</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTA3">PTA3</a></code>, <code><a href="#topic+PTAk">PTAk</a></code> ,<code><a href="#topic+FCAk">FCAk</a></code></p>

<hr>
<h2 id='INITIA'>Initialisation used in SINGVA</h2><span id='topic+INITIA'></span>

<h3>Description</h3>

<p>Gives the first Tucker1 components of a given tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   INITIA(X,modesnam=NULL,method="svds",dim=1,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INITIA_+3A_x">X</code></td>
<td>
<p>a tensor (as an array) of order <em>k</em></p>
</td></tr>
<tr><td><code id="INITIA_+3A_modesnam">modesnam</code></td>
<td>
<p>a character vector of the names of the modes</p>
</td></tr>
<tr><td><code id="INITIA_+3A_method">method</code></td>
<td>

<p>uses either the inbuilt SVD <code>method="svd"</code> or a power
algorithm giving only the first <code>method="Presvd"</code> or
any other function given applying to the column space of a
matrix and returning a list with <code>v</code> (in columns
vectors as in <code>svd</code>) and <code>d</code>. The method <code>method="svds"</code> performs alike  <code>method="svd"</code> but on a sum of tables instead of the Tucker1 approach.</p>
</td></tr>
<tr><td><code id="INITIA_+3A_dim">dim</code></td>
<td>

<p>default 1 in each space otherwise specify the number of dimensions
e.g. <code>c(2,3..,2)</code> (with <code>"Presvd"</code> dim is obviously 1)</p>
</td></tr>
<tr><td><code id="INITIA_+3A_...">...</code></td>
<td>
<p>extra arguments of the method <code>method</code>: the first argument is fixed (see details). </p>
</td></tr></table>


<h3>Details</h3>

<p>Computes the first (or <code>dim</code>) right singular vector  (or other
summaries) for every representation of the tensor as a matrix with
<code>dim(X)[i]</code> columns, <code>i=1...k</code>.</p>


<h3>Value</h3>

<p>a list (of length <em>k</em>) of  lists  with arguments:
</p>
<table>
<tr><td><code>v</code></td>
<td>
<p>the singular vectors in rows</p>
</td></tr>
<tr><td><code>modesnam</code></td>
<td>
<p>a character object naming the mode, <code>"m i"</code> otherwise</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>labels of mode <code>i</code> entries as given in <code>dimnames</code> of the data, can be <code>NULL</code></p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>the corresponding first singular values</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The collection these eigenvectors, is known as the Tucker1 solution
or initialisation related to PCA-3modes or PCA-<em>n</em>modes models.
If a function is given  it may include <code>dim</code> as argument.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Kroonenberg P.M (1983) <em>Three-mode Principal Component Analysis:
Theory and Applications</em>.  DSWO Press, Leiden.
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+SINGVA">SINGVA</a></code>, <code><a href="#topic+PTAk">PTAk</a></code> </p>

<hr>
<h2 id='PCAn'>Principal Component Analysis on n modes </h2><span id='topic+PCAn'></span>

<h3>Description</h3>

<p>Performs the Tucker<em>n</em> model using a space version of RPVSCC (<code>SINGVA</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'> PCAn(X,dim=c(2,2,2,3),test=1E-12,Maxiter=400,
              smoothing=FALSE,smoo=list(NA),
                verbose=getOption("verbose"),file=NULL,
                  modesnam=NULL,addedcomment="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCAn_+3A_x">X</code></td>
<td>

<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td></tr>
<tr><td><code id="PCAn_+3A_dim">dim</code></td>
<td>
<p>a vector of  numbers specifying the dimensions in each space </p>
</td></tr>
<tr><td><code id="PCAn_+3A_test">test</code></td>
<td>
<p>control of convergence</p>
</td></tr>
<tr><td><code id="PCAn_+3A_maxiter">Maxiter</code></td>
<td>
<p>maximum number of iterations allowed for convergence</p>
</td></tr>
<tr><td><code id="PCAn_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="PCAn_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code></p>
</td></tr>
<tr><td><code id="PCAn_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="PCAn_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="PCAn_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code>
&quot;<code>mo 1</code>&quot; ...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="PCAn_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed after the title of the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Looking for the best rank-one tensor approximation (LS) the three
methods described in the package are equivalent. If the number of
tensors looked for is greater then one the  methods differs:
PTA-<em>k</em>modes will &quot;look&quot; for &quot;best&quot; approximation according to the
<em>orthogonal rank</em> (<em>i.e.</em> the rank-one tensors are
orthogonal), PCA-<em>k</em>modes will look for best approximation
according to the <em>space ranks</em> (<em>i.e.</em> the rank of every
bilinear form, that is the number of components in each space),
PARAFAC/CANDECOMP will look for best approximation according to the
<em>rank</em> (<em>i.e.</em> the rank-one tensors are not necessarily
orthogonal). For the sake of comparisons the PARAFAC/CANDECOMP method
and the PCA-<em>n</em>modes are also in the  package but complete
functionnality  of the use these methods  and more complete packages
may be fetched at the www site quoted below. <br />
Recent work from Tamara G Kolda showed on an example that <em>orthogonal rank</em>
decompositions are not necesseraly nested. This makes PTA-<em>k</em>modes a model with
nested decompositions not giving the exact <em>orthogonal rank</em>.
So PTA-<em>k</em>modes will look for best approximation according to orthogonal tensors in a nested approximmation process. </p>


<h3>Value</h3>

<p>a <code>PCAn</code> (inherits <code><a href="#topic+PTAk">PTAk</a></code>) object</p>


<h3>Note</h3>

<p>The use of metrics (diagonal or not) and smoothing extend flexibility of analysis. </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Caroll J.D  and Chang J.J (1970) <em>Analysis of individual
differences in multidimensional   scaling via n-way generalization of
&quot;Eckart-Young&quot; decomposition</em>. Psychometrika 35,283-319.
</p>
<p>Harshman R.A (1970) <em>Foundations of the PARAFAC procedure:
models and conditions for &quot;an explanatory&quot; multi-mode factor
analysis</em>. UCLA Working Papers in Phonetics, 16,1-84.
</p>
<p>Kroonenberg P (1983) <em>Three-mode Principal Component Analysis:
Theory and Applications</em>. DSWO press. Leiden. (There was a maintained (by Pieter) library of contributions to multiway analysis ...))
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
</p>
<p>Kolda T.G (2003)<em> A Counterexample to the Possibility of an Extension of the Eckart-Young Low-Rank Approximation Theorem for the Orthogonal Rank Tensor Decomposition</em>. SIAM J. Matrix Analysis, 24(2):763-767, Jan. 2003.
</p>

<hr>
<h2 id='plot.PTAk'>Plot a PTAk object</h2><span id='topic+plot.PTAk'></span><span id='topic+RiskJackplot'></span>

<h3>Description</h3>

<p>Screeplot of singular values or superposed plot of modes for one or two components (1 dimensional scatterplot with spread labels or scatterplot on two dimensions).</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PTAk'
plot(x, labels = TRUE, mod = 1, nb1 = 1, nb2 = NULL,
    coefi = list(NULL, NULL), xylab = TRUE, ppch = (1:length(solution)),
    lengthlabels = 2, scree = FALSE, ordered = TRUE,
    nbvs = 40, RiskJack = NULL, method = "",ZoomInOut=NULL, Zlabels=NULL, Zcol=NULL,
    poslab=c(2,1,3,3), signedCTR = FALSE, relCTR = TRUE,...)
RiskJackplot(x, nbvs = 1:20, mod = NULL, max = NULL, rescaled=TRUE, ...)
                              </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PTAk_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code>, representing a generalised  singular value decomposition</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_labels">labels</code></td>
<td>
<p>logical if <code>TRUE</code> plots the labels given in <code>solution[[mod]]["n"]</code></p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_mod">mod</code></td>
<td>
<p>vectors of the modes numbers to be plotted</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_nb1">nb1</code></td>
<td>
<p>number identifying the Principal Tensor to display on the vertical
axe, can be checked using <code><a href="#topic+summary.PTAk">summary.PTAk</a></code> </p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_nb2">nb2</code></td>
<td>
<p>as nb1 to be displayed on the horizontal axe, if <code>NULL</code> the horizontal
axe will be used  as <code>Index</code> (see <code><a href="graphics.html#topic+plot.default">plot.default</a></code>) </p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_coefi">coefi</code></td>
<td>
<p>coefficients to multiply components for all modes (not just the one in <code>mod</code>) for rescaling or changing signs
purposes; each element of the list correspond to <code>nb1</code> and <code>nb2</code>
and are vectors of dimentions the tensor order</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_xylab">xylab</code></td>
<td>
<p>logical to display axes labels</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_ppch">ppch</code></td>
<td>
<p>a vector of length at least <code>length(mod)</code> used for <code>pch=</code></p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_lengthlabels">lengthlabels</code></td>
<td>

<p>a number or a vector of numbers of characters in labels to be used for display</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_scree">scree</code></td>
<td>

<p>logical to display a screeplot of squared singular values as percent of total variation</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_ordered">ordered</code></td>
<td>
<p>logical used when displaying the screeplot  with sorted
values (TRUE) or the order is given by output listing from
<code>summary.PTAk</code></p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_nbvs">nbvs</code></td>
<td>
<p>a maximum number of singular values to display on the screeplot or a vector of ranks</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_max">max</code></td>
<td>
<p>is the number of singular values to be considered as giving the perfect fit, NULL is the max possible in x</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_rescaled">rescaled</code></td>
<td>
<p>boolean to rescale the y axis to 0-100</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_riskjack">RiskJack</code></td>
<td>

<p>if not <code>NULL</code> is an integer,  scree is <code>TRUE</code> and ordered is <code>TRUE</code>, plots
on top of the scree plot a Risk plot with <code>nbvs = 1:RiskJack</code>. It is
possible to use directly the function <code>RiskJackplot</code>: the default
maximum dimension (argument <code>max</code>) is  <code>length(solution[[k]][["d"]])</code>. </p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_method">method</code></td>
<td>
<p>default is <code>""</code>, a value <code>"FCA"</code> is to be used only
if <code>solution</code> is after an FCA with <code>SVDgen</code></p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_zoominout">ZoomInOut</code></td>
<td>
<p> list used as [[1]] for xlim and [[2]] for ylim in xy-plots instead of max and min range</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_zlabels">Zlabels</code></td>
<td>
<p> used as labels instead of <code>x[[mod]]$n</code>, it is a list with the same length as all modes. For example on 3 modes changing the labels of the second mode only will have to set <code>Zlabels=list(NULL,rep("a",length(x[[2]]$n) ), NULL )</code> </p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_zcol">Zcol</code></td>
<td>
<p> list of vectors of colours for Zlabels</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_poslab">poslab</code></td>
<td>
<p>integer or vector for 'pos' parameter, position of labels</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_signedctr">signedCTR</code></td>
<td>
<p>logical to plot signed-CTR instead of coordinates, see <code><a href="#topic+CTR">CTR</a></code></p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_relctr">relCTR</code></td>
<td>
<p>logical if <code>signedCTR = TRUE</code> use relative CTRs, expected contribution <code>1</code> if uniform or equal contributions.</p>
</td></tr>
<tr><td><code id="plot.PTAk_+3A_...">...</code></td>
<td>
<p>plot arguments can be passed (except <code>xlim, ylim, ylab,pch,xaxt</code> for component plot,
and <code>xlab, ylab</code> for screeplot). For example to have normed plot one can use <code>asp=1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot components of one or two Principal Tensors, modes are superposed if more
than one is asked, or gives a screeplot. As it is using <code>plot.default</code> at
some point some added features can be used in the ... part, especially
<code>xlab= </code> may be useful when <code>nb2=NULL</code>. Plots are superposed as they
correspond to the same Principal Tensor and so this gives insight to
interpretation of it, but careful is recommended as only overall
interpretation, once the Principal Tensor has been rebuilt mentally
(<em>i.e.</em> product of signs ...) to work out oppositions or associations. The
risk plot on top of a screeplot is an approximation of the Jacknife estimate of
the MSE in the choice of number of dimensions (see Besse et al.(1997)). </p>


<h3>Note</h3>

<p>This function is used all for <code>FCAk</code>, and
<code>CANDPARA</code>, <code>PCAn</code> objjects notheless for this
last object other interesting plots known as jointplots have not been implemented.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Besse, P Cardot, H and Ferraty, F (1997) <em>Simultaneous
non-parametric regressions of unbalanced longitudinal
data</em>. Computational Statistics and Data Analysis, 24:255-270.
</p>
<p>Leibovici D (2000) <em>Multiway Multidimensional Analysis for Pharmaco-EEG
Studies</em>. <a href="https://www.researchgate.net/publication/216807619_Multiway_Multidimensional_Analysis_for_Pharmaco-EEG_Studies">https://www.researchgate.net/publication/216807619_Multiway_Multidimensional_Analysis_for_Pharmaco-EEG_Studies</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+PTA3">PTA3</a></code>, <code><a href="#topic+CTR">CTR</a></code>,
<code><a href="#topic+FCAk">FCAk</a></code>,<code><a href="#topic+SVDgen">SVDgen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#  see the demo function   source(paste(R.home(),"/ library/PTAk/demo/PTA3.R",sep=""));
# or    source(paste(R.home(),"/ library/PTAk/demo/PTAk.R",sep=""));
 
 # demo.PTA3()
 </code></pre>

<hr>
<h2 id='preprocessings'>Few useful functions for preprocessing arrays </h2><span id='topic+preprocessings'></span><span id='topic+Multcent'></span><span id='topic+IterMV'></span><span id='topic+Detren'></span><span id='topic+Susan1D'></span>

<h3>Description</h3>

<p>Choices of centering or detrending  and scaling are important preprocessings for multiway analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multcent(dat,bi=c(1,2),by=3,
          centre=mean,
           centrebyBA=c(TRUE,FALSE),scalebyBA=c(TRUE,FALSE))
IterMV(n=10,dat,Mm=c(1,3),Vm=c(2,3),
               fFUN=mean,usetren=FALSE,
                  tren=function(x)smooth.spline(as.vector(x),df=5)$y,
                   rsd=TRUE)
Detren(dat,Mm=c(1,3),rsd=TRUE,
         tren=function(x)smooth.spline(as.vector(x),df=5)$y )
Susan1D(y,x=NULL,sigmak=NULL,sigmat=NULL,
          ker=list(function(u)return(exp(-0.5*u**2))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocessings_+3A_dat">dat</code></td>
<td>
<p>array</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_bi">bi</code></td>
<td>
<p>vector defining the &quot;centering, bicentering or multi-centering&quot; one wants
to operate crossed with <code>by</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_by">by</code></td>
<td>
<p>number or vector defining the entries used &quot;with&quot; in
the other operations</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_centre">centre</code></td>
<td>
<p>function used as <code>FUN</code> in applying
&quot;multi-centering&quot;</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_centrebyba">centrebyBA</code></td>
<td>
<p>a bolean vector for &quot;centering&quot; with <code>centre</code> Before and After
according to <code>by</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_scalebyba">scalebyBA</code></td>
<td>
<p>idem as centrebyBA, for scaling operation</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_n">n</code></td>
<td>
<p>number of iterations between &quot;centering&quot; and scaling</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_mm">Mm</code></td>
<td>
<p>margins to performs <code>Detren</code> or <code>fFUN</code> on</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_vm">Vm</code></td>
<td>
<p>margins to scale</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_ffun">fFUN</code></td>
<td>
<p>function to use as <code>FUN</code> if <code>usetren</code> is
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_usetren">usetren</code></td>
<td>
<p>logical, to use <code>Detren</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_tren">tren</code></td>
<td>
<p>function to use in <code>Detren</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_rsd">rsd</code></td>
<td>
<p>logical passed into <code>Detren</code> (only) to detrend or not</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_y">y</code></td>
<td>
<p>vector (length <code>n</code>)</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_x">x</code></td>
<td>
<p>vector of same length, if <code>NULL</code> it is <code>1:n</code> </p>
</td></tr>
<tr><td><code id="preprocessings_+3A_sigmak">sigmak</code></td>
<td>
<p>parameter related to kernel bandwidth with <code>y</code>
values (default is <code>1/2*range</code></p>
</td></tr>
<tr><td><code id="preprocessings_+3A_sigmat">sigmat</code></td>
<td>
<p>parameter related to kernel bandwidth with  <code>x</code>
values (default value is <code>8*n^{-1/5}</code>, with a minimum number of
neigbours set as one apart)</p>
</td></tr>
<tr><td><code id="preprocessings_+3A_ker">ker</code></td>
<td>
<p>a list of two kernels <code>list("t"=function "k"=function
      ) </code> for each weightings (if only one given it is used for
both)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Multcent</code> performs in order &quot;centering&quot; by <code>by</code>;
&quot;multicentering&quot; for every <code>bi</code> with <code>by</code>; then scale
(standard deviation) to one by <code>by</code>.
</p>
<p><code>IterMV</code> performs an iterative &quot;detrending&quot; and scaling
according to te margins defined (see Leibovici(2000) and references
in it).
</p>
<p><code>Detren</code> detrends (or smooths if <code>rsd</code> is <code>FALSE</code>)
the data accoding to th margins given.
</p>
<p><code>Susan1D</code> performs a non-linear kernel smoothing  of <code>y</code>
against <code>x</code> (both reordered in the function according to orders
of <code>x</code>) with an usual kernel (<code>t</code>) as for kernel
regression and a kernel (<code>t</code>) for the values of <code>y</code> (the
product of the kernels constitutes the non-linear weightings. This
function is adapted from SUSAN algorithm (see references).
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Smith S.M. and J.M. Brady (1997) <em>SUSAN - a new approach to low level image processing</em>.
International Journal of Computer Vision, 23(1):45-78, May 1997.
</p>

<hr>
<h2 id='PROJOT'>Orthogonal Tensor projection </h2><span id='topic+PROJOT'></span>

<h3>Description</h3>

<p>Orthogonal-tensoriel projection of a tensor according to a rank-1
tensor, or a to bigger structure defined by kronecker product of
matrices. </p>


<h3>Usage</h3>

<pre><code class='language-R'> PROJOT(X,solu,numo=1,bortho=TRUE,Ortho=TRUE,metrics=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PROJOT_+3A_x">X</code></td>
<td>
<p>a tensor(as an array) of any order </p>
</td></tr>
<tr><td><code id="PROJOT_+3A_solu">solu</code></td>
<td>
<p>an object like a <code>solutions.PTAk</code> object with at least <code>v</code></p>
</td></tr>
<tr><td><code id="PROJOT_+3A_numo">numo</code></td>
<td>

<p>a vector of numbers  or a list of vectors  (length the order of the
tensor) identifying for each space the structure to project onto, if
NULL for a specific space then no projection is done for this space</p>
</td></tr>
<tr><td><code id="PROJOT_+3A_bortho">bortho</code></td>
<td>
<p>list of logicals saying if the structures are othogonal
or not.</p>
</td></tr>
<tr><td><code id="PROJOT_+3A_ortho">Ortho</code></td>
<td>

<p>list of logicals telling the projectors on each space to be  on the
structure  or on its orthogonal.</p>
</td></tr>
<tr><td><code id="PROJOT_+3A_metrics">metrics</code></td>
<td>
<p>NULL or list of metrics (either diagonal or not) for each entry of <code>X</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the <em>tensorial orthogonal projection</em> of
<code>X</code> onto the <em>tensorial structure</em> defined by <code>solu</code>
and <code>numo</code>. For each space (involved in the tensorial product
where from  <code>X</code> belongs), one defined the projector onto
<code>solu[[i]]$v[numo,]</code> (or on its orthogonal if
<code>Ortho[[i]]==TRUE</code>), then the result is the image of <code>X</code> by
the tensorial product of the projectors, i.e.
</p>
<p style="text-align: center;"><code class="reqn">(P_{S1} \otimes P_{S2} \otimes \ldots \otimes P_{Sk})(X)</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>A tensor with dimensions as <code>X</code></p>


<h3>Note</h3>

<p>For PTA-<em>k</em>modes the projection used is only on rank-one tensors
(Principal Tensors), <em>i.e.</em> <code>numo</code> is a number. The code
here can be used for any structure (on each spaces) and constitutes
the projector onto a tensorial structure, and can define the
PTAIV-<em>k</em>modes (PTAk on Instrumental Variables Leibovici(1993).
(see other references  for tensorial product of linear operators in
Leibovici(2000) <em>e.g.</em> Dauxois et al.(1994))</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici <a href="mailto:GeotRycs@gmail.com">GeotRycs@gmail.com</a></p>


<h3>References</h3>

<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D (2000) <em>Multiway Multidimensional Analysis for
Pharmaco-EEG Studies</em>. <a href="http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf">http://www.fmrib.ox.ac.uk/analysis/techrep/tr00dl2/tr00dl2.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
don &lt;- array(1:360,c(5,4,6,3))
 don &lt;- don + rnorm(360,10,2)

 ones &lt;- list(list(v=rep(1,5)),list(v=rep(1,4)),list(v=rep(1,6)),list(v=rep(1,3)))
 donfc &lt;- PROJOT(don,ones)

 apply(donfc,c(2,3,4),mean)
 apply(donfc,c(1),mean)

  # implementation de PTAIVk with obvious settings
 PTAIVk &lt;- function(X,STruct,...)
         {X &lt;- PROJOT(X$data,STruct,numo=Struct[[1]]$numo,Ortho=Struct[[1]]$Ortho,metrics=X$met)
         PTAk(X,...)
         }

   </code></pre>

<hr>
<h2 id='PTA3'>Principal Tensor Analysis on 3 modes</h2><span id='topic+PTA3'></span>

<h3>Description</h3>

<p>Performs a truncated SVD-<em>3</em>modes analysis with or
without specific metrics, penalised or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PTA3(X,nbPT=2,nbPT2=1,
                smoothing=FALSE,
                smoo=list(function(u)ksmooth(1:length(u),u,kernel="normal",
                          bandwidth=4,x.points=(1:length(u)))$y,
                          function(u)smooth.spline(u,df=3)$y,
                          NA),
                minpct=0.1,verbose=getOption("verbose"),file=NULL,
                modesnam=NULL,addedcomment="", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTA3_+3A_x">X</code></td>
<td>

<p>a tensor (as an array) of order <em>3</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td></tr>
<tr><td><code id="PTA3_+3A_nbpt">nbPT</code></td>
<td>
<p>a number specifying the number of <em>3</em>modes Principal Tensors requested</p>
</td></tr>
<tr><td><code id="PTA3_+3A_nbpt2">nbPT2</code></td>
<td>
<p>if 0 no <em>2</em>-modes solutions will be computed, 1 =all, &gt;1 otherwise</p>
</td></tr>
<tr><td><code id="PTA3_+3A_smoothing">smoothing</code></td>
<td>
<p>logical to consider smoothing or not</p>
</td></tr>
<tr><td><code id="PTA3_+3A_smoo">smoo</code></td>
<td>
<p>a list of length 3 with lists of functions operating on
vectors component for the appropriate dimension (see details) </p>
</td></tr>
<tr><td><code id="PTA3_+3A_minpct">minpct</code></td>
<td>

<p>numerical 0-100 to control of computation of future solutions at this
level and below</p>
</td></tr>
<tr><td><code id="PTA3_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="PTA3_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="PTA3_+3A_modesnam">modesnam</code></td>
<td>

<p>character vector of the names of the modes, if <code>NULL</code> &quot;<code>mo 1</code>&quot;
...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="PTA3_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed after the title of the analysis</p>
</td></tr>
<tr><td><code id="PTA3_+3A_...">...</code></td>
<td>
<p>any other arguments passed to SVDGen or other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the decomposition described in Leibovici(1993) and
Leibovici and Sabatier(1998) the function gives a generalisation of
the SVD (2 modes) to <em>3</em> modes. It is the same algorithm used
for <code>PTAk</code> but simpler as the recursivity implied by the
<em>k</em> modes analysis is reduced only to one level <em>i.e</em> for
every <em>3</em>-modes  Principal Tensors, 3 SVD are performed for
every contracted product with one the three components of the
<em>3</em>-modes  Principal Tensors (see <code><a href="#topic+APSOLU3">APSOLU3</a></code>,
<code><a href="#topic+PTAk">PTAk</a></code>). <br />
</p>
<p>Recent work from Tamara G Kolda showed on an example that <em>orthogonal rank</em>
decompositions are not necesseraly nested. This makes PTA-<em>3</em>modes a model with
nested decompositions not giving the exact <em>orthogonal rank</em>.
So PTA-<em>3</em>modes will look for best approximation according to orthogonal tensors in a nested approximmation process. PTA3 decompositions is &quot;a&quot; generalisation of SVD but not the ...
<br />
With the <code>smoothing</code> option <code>smoo</code> contain a list of (lists) of functions to
apply on vectors of component (within the algorithm, see
<code><a href="#topic+SVDgen">SVDgen</a></code>). For a given dimension (1,2,or 3) a list of
functions is given. If this list consists only of one function (no list
needed) this
function will be used at any level all the time : if one want to smooth
only for the first Principal Tensor, put <code>list(function,NA)</code>. Now
you start to understand this list will have a maximum length of
<code>nbPT</code> and the corresponding function will be used for the
corresponding <em>3</em>mode Principal Tensor. To smooth differently the
associated solutions one have to put another level of nested lists
otherwise the function given at the <em>3</em>mode level will be used for
all. These rules are te same for <code><a href="#topic+PTAk">PTAk</a></code>.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+PTAk">PTAk</a></code> object</p>


<h3>Note</h3>

<p>The use of metrics (diagonal or not) allows flexibility of analysis like in <em>2</em> modes
<em>e.g.</em> correspondence analysis, discriminant analysis, robust analysis.  Smoothing option
extends the analysis towards functional data analysis, and or outliers &quot;protection&quot; is
theoretically valid for tensors belonging to a tensor product of separable Hilbert spaces
(<em>e.g.</em> Sobolev spaces) (see references in <code>PTAk</code>, <code>SVDgen</code>).</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
</p>
<p>Kolda T.G (2003)<em> A Counterexample to the Possibility of an Extension of the Eckart-Young Low-Rank Approximation Theorem for the Orthogonal Rank Tensor Decomposition</em>. SIAM J. Matrix Analysis, 24(2):763-767, Jan. 2003.
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVDgen">SVDgen</a></code>, <code><a href="#topic+FCAk">FCAk</a></code>, <code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+summary.PTAk">summary.PTAk</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> # example using Zone_climTUN dataset
 #  
# library(maptools)
# library(RColorBrewer)
# Yl=brewer.pal(11,"PuOr")
# data(Zone_climTUN)
## in fact a modified version of plot.Map was used
# plot(Zone_climTUN,ol=NA,auxvar=Zone_climTUN$att.data$PREC_OCTO)
##indicators 84 +3 to repeat
# Zone_clim&lt;-Zone_climTUN$att.data[,c(2:13,15:26,28:39,42:53,57:80,83:95,55:56)]
# Zot &lt;-Zone_clim[,85:87] ;temp &lt;-colnames(Zot) 
# Zot &lt;- as.matrix(Zot)%x%t(as.matrix(rep(1,12)))
# colnames(Zot) &lt;-c(paste(rep(temp [1],12),1:12),paste(rep(temp [2],12),1:12),
#	 paste(rep(temp [3],12),1:12))
# Zone_clim &lt;-cbind(Zone_clim[,1:84],Zot)
 
# Zone3w &lt;- array(as.vector(as.matrix(Zone_clim)),c(2599,12,10))
## preprocessing
#Zone3w&lt;-Multcent(dat=Zone3w,bi=NULL,by=3,centre=mean, 
#	centrebyBA=c(TRUE,FALSE),scalebyBA=c(TRUE,FALSE))
# Zone3w.PTA3&lt;-PTA3(Zone3w,nbPT=3,nbPT2=3)
## summary and plot
# summary(Zone3w.PTA3)
#plot(Zone3w.PTA3,mod=c(2,3),nb1=1,nb2=11,lengthlabels=5,coefi=list(c(1,1,1),c(1,-1,-1)))
#plot(Zone_climTUN,ol=NA,auxvar=Zone3w.PTA3[[1]]$v[1,],nclass=30)
#plot(Zone_climTUN,ol=NA,auxvar=Zone3w.PTA3[[1]]$v[11,],nclass=30)
 
 ##############
 cat(" A little fun using iris3 and matching randomly 15 for each iris sample!","\n")
 cat("   then performing a PTA-3modes.  If many draws are done, plots")
 cat("   show the stability of the first and third Principal Tensors.","\n")
 cat("iris3 is centered and reduced beforehand for each original variables.","\n")
#  demo function 
# source(paste(R.home(),"/library/PTAk/demo/PTA3.R",sep=""))
# demo.PTA3(bootn=10,show=5,openX11s=FALSE)
 
</code></pre>

<hr>
<h2 id='PTAk'>Principal Tensor Analysis on k modes</h2><span id='topic+PTAk'></span>

<h3>Description</h3>

<p>Performs a truncated SVD-<em>k</em>modes analysis with or without
specific metrics, penalised or not. </p>


<h3>Usage</h3>

<pre><code class='language-R'> PTAk(X,nbPT=2,nbPT2=1,minpct=0.1,
                smoothing=FALSE,
                   smoo=list(NA),
                    verbose=getOption("verbose"),file=NULL,
                     modesnam=NULL,addedcomment="", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PTAk_+3A_x">X</code></td>
<td>

<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td></tr>
<tr><td><code id="PTAk_+3A_nbpt">nbPT</code></td>
<td>

<p>integer vector of length <em>(k-2)</em>  specifying the  maximum number
of Principal Tensors requested for the <em>(3,...,k-1, k)</em> modes
levels (see details), if it is not a vector every levels would have
the same given nbPT value </p>
</td></tr>
<tr><td><code id="PTAk_+3A_nbpt2">nbPT2</code></td>
<td>
<p>if 0 no 2-modes solutions
will be computed, 1 =all, &gt;1 otherwise</p>
</td></tr>
<tr><td><code id="PTAk_+3A_minpct">minpct</code></td>
<td>

<p>numerical 0-100 to control of computation of future solutions at this
level and below</p>
</td></tr>
<tr><td><code id="PTAk_+3A_smoothing">smoothing</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code>, <code><a href="#topic+SVDgen">SVDgen</a></code></p>
</td></tr>
<tr><td><code id="PTAk_+3A_smoo">smoo</code></td>
<td>
<p>see <code><a href="#topic+PTA3">PTA3</a></code></p>
</td></tr>
<tr><td><code id="PTAk_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="PTAk_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="PTAk_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> <code>mo 1</code> ...<code>mo k</code></p>
</td></tr>
<tr><td><code id="PTAk_+3A_addedcomment">addedcomment</code></td>
<td>
<p>character string printed if <code>printt</code> after the title of the analysis</p>
</td></tr>
<tr><td><code id="PTAk_+3A_...">...</code></td>
<td>
<p>any other arguments passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the decomposition described in Leibovici(1993) and
Leibovici and Sabatier(1998) the function gives a generalisation of
the SVD (2 modes) to <em>k</em> modes. The algorithm is recursive,
calling <code>APSOLUk</code> which calls <code>PTAk</code> for <em>(k-1)</em>.
<code>nbPT</code>, <code>nbPT2</code> and <code>minpct</code> control the number of
Principal Tensors desired. For example <code>nbPT=c(2,4,3)</code> means a
tensor of order <em>5</em> is analysed, the maximum number of 5-modes
PT is set to <em>3</em>, for <em>each of them</em> one sets a maximum of
<em>4</em> associated <em>4-modes</em> (for each of the five components),
for <em>each of these later</em> a maximum of <em>2</em> associated
<em>3-modes</em> PT is asked (for each of the four components). Then
<code>nbPT2</code> complete for <em>2-modes</em> associated or not. Overall
<code>minpct</code> controls to carry on the algorithm at any level and
lower, <em>i.e.</em> stops if <code class="reqn">100(vs^2/ssx)&lt;minpct</code> (where
<code class="reqn">vs</code> is the singular value, and <em>ssx</em> is the total sum of
squares of the tensor <code class="reqn">X</code> or the &quot;metric transformed&quot; <code class="reqn">X</code>).
Putting a <code class="reqn">0</code> at a given level in <code>nbPT</code> obviously
automatically puts <code class="reqn">0</code>  in <code>nbPT</code> at lower levels. Putting
high values in <code>nbPT</code> allows control only on <code>minpct</code>
helping to reach the full decomposition. All these controls allow to
truncate the full decomposition in a level-controlled fashion. Notice
the full decomposition always contains any possible choice of
truncation, <em>i.e.</em> the solutions are not dependant on the
truncation scheme (Generalised Eckart-Young Theorem).
<br />
Recent work from Tamara G Kolda showed on an example that <em>orthogonal rank</em>
decompositions are not necesseraly nested. This makes PTA-<em>k</em>modes a model with
nested decompositions not giving the exact <em>orthogonal rank</em>.
So PTA-<em>k</em>modes will look for best approximation according to orthogonal tensors in a nested approximmation process.</p>


<h3>Value</h3>

<p>a <code><a href="#topic+PTAk">PTAk</a></code> object which consist of a list of lists. Each mode has a list in which is listed:
</p>
<table>
<tr><td><code>$v</code></td>
<td>
<p>matrix of components for the given mode</p>
</td></tr>
<tr><td><code>$iter</code></td>
<td>
<p>vector of iterations numbers where maximum was reach</p>
</td></tr>
<tr><td><code>$test</code></td>
<td>
<p>vector of test values at maximum</p>
</td></tr>
<tr><td><code>$modesnam</code></td>
<td>
<p>name of the mode</p>
</td></tr>
<tr><td><code>$v</code></td>
<td>
<p>matrix of components for the given mode</p>
</td></tr>
</table>
<p>The last mode list has also some additional information on the analysis done:
</p>
<table>
<tr><td><code>$d</code></td>
<td>
<p>vector of singular values</p>
</td></tr>
<tr><td><code>$pct</code></td>
<td>
<p>percentage of sum of squares for each quared singular value</p>
</td></tr>
<tr><td><code>$ssX</code></td>
<td>
<p>vector of local sum of squares <em>i.e.</em> of the current tensor with the rescursive algorithm</p>
</td></tr>
<tr><td><code>$vsnam</code></td>
<td>
<p>vector of names given to the singular value according to a recursive data dependent scheme</p>
</td></tr>
<tr><td><code>$datanam</code></td>
<td>
<p>data reference</p>
</td></tr>
<tr><td><code>$method</code></td>
<td>
<p>call applied: could be PTAk or CANDPARA or PCAn or even SVDgen, with parameters choices</p>
</td></tr>
<tr><td><code>$addedcomment</code></td>
<td>
<p> the addedcomment (repeated) given in the call</p>
</td></tr>
</table>
<p>You will notice that methods other than PTAk may not have all list elements but the essential ones such as: $v, $d, $ssX, and may also have additional ones like $coremat for PCAn (the core array).
</p>


<h3>Note</h3>

<p>The use of metrics (diagonal or not) allows flexibility of analysis like in <em>2</em> modes
<em>e.g.</em> correspondence analysis, discriminant analysis, robust analysis.  Smoothing option
extending the analysis towards functional data analysis is theoretically
valid for Principal Tensors  belonging to a tensor product of separable
Hilbert spaces (<em>e.g.</em> Sobolev spaces) see Leibovici and El Maach (1997).</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D and El Maache H (1997) <em>Une d&lt;e9&gt;composition en Valeurs Singuli&lt;e8&gt;res d'un &lt;e9&gt;l&lt;e9&gt;ment
d'un produit Tensoriel de k espaces de Hilbert S&lt;e9&gt;parables</em>. Compte Rendus de l'Acad&lt;e9&gt;mie des
Sciences tome 325, s&lt;e9&gt;rie I, Statistiques (Statistics) &amp; Probabilit&lt;e9&gt;s (Probability Theory):
779-782.
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value Decomposition of a k-ways array for a
Principal Component Analysis of multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
Kolda T.G (2003)<em> A Counterexample to the Possibility of an Extension of the Eckart-Young Low-Rank Approximation Theorem for the Orthogonal Rank Tensor Decomposition</em>. SIAM J. Matrix Analysis, 24(2):763-767, Jan. 2003.
</p>
<p>Leibovici  D (2008) <em>A Simple Penalised algorithm for SVD and Multiway
functional  methods</em>. (to be submitted in the futur)
</p>
<p>Leibovici DG (2010) <em>Spatio-temporal Multiway Decomposition using Principal Tensor Analysis on k-modes:the R package <span class="pkg">PTAk</span></em>. Journal of Statistical Software, 34(10), 1-34. <a href="https://doi.org/10.18637/jss.v034.i10">doi:10.18637/jss.v034.i10</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+REBUILD">REBUILD</a></code>, <code><a href="#topic+FCAk">FCAk</a></code>, <code><a href="#topic+PTA3">PTA3</a></code> <code><a href="#topic+summary.PTAk">summary.PTAk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # don &lt;- array((1:3)%x%rnorm(6*4)%x%(1:10),c(10,4,6,3))

don &lt;- array(1:360,c(5,4,6,3))
 don &lt;- don + rnorm(360,1,2)

 dimnames(don) &lt;- list(paste("s",1:5,sep=""),paste("T",1:4,sep=""),
          paste("t",1:6,sep=""),c("young","normal","old"))
   # hypothetic data on learning curve at different age and period of year

 ones &lt;-list(list(v=rep(1,5)),list(v=rep(1,4)),list(v=rep(1,6)),list(v=rep(1,3)))

 don &lt;- PROJOT(don,ones)
 don.sol &lt;- PTAk(don,nbPT=1,nbPT2=2,minpct=0.01,
               verbose=TRUE,
                modesnam=c("Subjects","Trimester","Time","Age"),
                 addedcomment="centered on each mode")

don.sol[[1]] # mode Subjects results and components
don.sol[[2]] # mode Trimester results and components
don.sol[[3]] # mode Time results and components
don.sol[[4]] # mode Age results and  components with additional information on the call

 summary(don.sol,testvar=2)
  plot(don.sol,mod=c(1,2,3,4),nb1=1,nb2=NULL,
     xlab="Subjects/Trimester/Time/Age",main="Best rank-one approx" )
  plot(don.sol,mod=c(1,2,3,4),nb1=4,nb2=NULL,
      xlab="Subjects/Trimester/Time/Age",main="Associated to Subject vs1111")

#  demo function
 # demo.PTAk()

  </code></pre>

<hr>
<h2 id='PTAk-internal'>Internal PTAk functions</h2><span id='topic+Ginv'></span><span id='topic+PPMA'></span><span id='topic+Powmat'></span><span id='topic+RaoProd'></span><span id='topic+REBUILDPCAn'></span><span id='topic+RESUM'></span><span id='topic+svdsmooth'></span><span id='topic+toplist'></span><span id='topic+svd.p'></span>

<h3>Description</h3>

<p>Internal PTAk functions </p>


<h3>Usage</h3>

<pre><code class='language-R'>Ginv(A)
PPMA(X,test=1E-10,pena=list(function(u)ksmooth(1:length(u),u,kernel="normal",
                     bandwidth=3,x.points=(1:length(u)))$y
                     ,NA) ,ini=mean,vsmin=1E-20,Maxiter=2000, ...)
Powmat(A,pw,eltw=FALSE)
RaoProd(A,B)
REBUILDPCAn(solu)
RESUM(solb,sola=NULL,numass=NULL,verbose=getOption("verbose"),file=NULL
                        ,summary=FALSE,testvar=0.1,with=TRUE)
svdsmooth(X,nomb=min(dim(X)),
                   smooth=list(function(u)ksmooth(1:length(u),u,kernel="normal",
                               bandwidth=3,x.points=(1:length(u)))$y),vsmin=1E-16, ...)
toplist(li)
svd.p(X,...)
</code></pre>


<h3>Arguments</h3>

<p>These functions are not supposed to be called directly.
</p>
<table>
<tr><td><code id="PTAk-internal_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_test">test</code></td>
<td>
<p>a zero limit number</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_pena">pena</code></td>
<td>
<p> list of functions to be used as smoother</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_ini">ini</code></td>
<td>
<p>initialisation method over the dual dimension</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_vsmin">vsmin</code></td>
<td>
<p>zero limit for singular value</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_maxiter">Maxiter</code></td>
<td>
<p>limit number of iteration</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_a">A</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_pw">pw</code></td>
<td>
<p> power value number</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_eltw">eltw</code></td>
<td>
<p> boolean to perform power elementwise or matrix power </p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_b">B</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_solb">solb</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code> </p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_sola">sola</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code> </p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_solu">solu</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code> </p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_numass">numass</code></td>
<td>
<p>position number of the associated solution, NULL is equivalent to the last in <code>sola</code></p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_verbose">verbose</code></td>
<td>
<p>boolean playing a verbose role</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_file">file</code></td>
<td>
<p>string pointing a destination of  file output</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_summary">summary</code></td>
<td>
<p>boolean to show the summary or not </p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_testvar">testvar</code></td>
<td>
<p>threshold control for minimum percent of variability explained</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_with">with</code></td>
<td>
<p>boolean expression to give a supplementary selection criterion</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_nomb">nomb</code></td>
<td>
<p>integer giving the number of components to fit</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_smooth">smooth</code></td>
<td>
<p>idem as pena</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_li">li</code></td>
<td>
<p>any list</p>
</td></tr>
<tr><td><code id="PTAk-internal_+3A_...">...</code></td>
<td>
<p>any other arguments passed to functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code></p>

<hr>
<h2 id='REBUILD'>Build an approximation of the tensor of any order</h2><span id='topic+REBUILD'></span>

<h3>Description</h3>

<p>Gives the approximation of a previously analysed tensor using its
given decomposition. </p>


<h3>Usage</h3>

<pre><code class='language-R'> REBUILD(solutions,nTens=1:2,testvar=1 ,redundancy=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REBUILD_+3A_solutions">solutions</code></td>
<td>
<p>a <code>PTAk</code> object</p>
</td></tr>
<tr><td><code id="REBUILD_+3A_ntens">nTens</code></td>
<td>
<p>a vector of identifying positions (numbers given in <code>summary</code>) for  the choice of Principal Tensors to use</p>
</td></tr>
<tr><td><code id="REBUILD_+3A_testvar">testvar</code></td>
<td>
<p>control within <code>nTens</code> used Principal Tensor with  minimum percent of variability explained</p>
</td></tr>
<tr><td><code id="REBUILD_+3A_redundancy">redundancy</code></td>
<td>

<p>logical to take into account (within <code>nTens</code>) PT <em>tested</em>
redundant during analysis (seealso <code>RESUM</code>) if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function rebuilds the Principal Tensors, <em>i.e.</em> rank-one
tensors of order the order of the tensor analysed, and add them up to
build an approximation of the tensor analysed (according to the
method used see <code>method</code>). This constitutes a best Least Squares
(ordinary or &quot;weighted&quot;  if metrics are used) approximation of
<code>datanam</code> for a given <em>orthogonal-rank r</em> (number of
principal tensors used), if and only if the singular values used are
the <em>r</em> highest.
</p>


<h3>Value</h3>

<p>A tensor with dimensions as <code>solutions[[k]][["datanam"]]</code>. </p>


<h3>Note</h3>

<p>This function can be called for <code>PARAFAC/CANDECOMP</code> and
<code>PCAn</code>. A specific rebuilt is implemented for this last one. </p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code></p>

<hr>
<h2 id='SINGVA'>Optimisation algorithm RPVSCC</h2><span id='topic+SINGVA'></span>

<h3>Description</h3>

<p>Computes the best rank-one approximation using the RPVSCC algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SINGVA(X,test=1E-12,PTnam="vs111",Maxiter=2000,
                  verbose=getOption("verbose"),file=NULL,
                    smoothing=FALSE,smoo=list(NA),
                     modesnam=NULL,
                      Ini="svds",sym=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SINGVA_+3A_x">X</code></td>
<td>

<p>a tensor (as an array) of order <em>k</em>, if non-identity metrics are
used <code>X</code> is a list with <code>data</code>  as the array and
<code>met</code> a list of metrics</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_test">test</code></td>
<td>
<p>numerical value to stop optimisation</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_ptnam">PTnam</code></td>
<td>
<p>character giving the name of the <em>k</em>-modes Principal Tensor</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_maxiter">Maxiter</code></td>
<td>
<p>if <code>iter &gt; Maxiter</code> prompts to carry on or not, then do it
every other 200 iterations</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_verbose">verbose</code></td>
<td>
<p>control printing</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_file">file</code></td>
<td>
<p>output printed at the prompt if <code>NULL</code>, or printed in the given  &lsquo;<span class="file">file</span>&rsquo;</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_smoothing">smoothing</code></td>
<td>
<p>logical to use smooth functiosns or not (see
<code><a href="#topic+SVDgen">SVDgen</a></code>) </p>
</td></tr>
<tr><td><code id="SINGVA_+3A_smoo">smoo</code></td>
<td>
<p>list of functions returning smoothed vectors (see
<code><a href="#topic+PTA3">PTA3</a></code>) </p>
</td></tr>
<tr><td><code id="SINGVA_+3A_modesnam">modesnam</code></td>
<td>
<p>character vector of the names of the modes, if <code>NULL</code> &quot;<code>mo 1</code>&quot; ...&quot;<code>mo k</code>&quot;</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_ini">Ini</code></td>
<td>
<p>method used for initialisation of the algorithm (see <code>INITIA</code>)</p>
</td></tr>
<tr><td><code id="SINGVA_+3A_sym">sym</code></td>
<td>
<p>description of the symmetry of the tensor <em>e.g.</em> c(1,1,3,4,1) means the
second mode and the fifth are identical to the first </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm termed <em>RPVSCC</em>  in Leibovici(1993) is implemented
to compute the first Principal Tensor (rank-one tensor with its
singular value) of the given tensor <code>X</code>. According to the
decomposition described in Leibovici(1993) and Leibovici and
Sabatier(1998), the function gives a generalisation  to <em>k</em>
modes of the <em>best rank-one approximation</em> issued from SVD whith
2 modes. It is identical to  the PCA-<em>k</em>modes if only 1
dimension is asked in each space, and to PARAFAC/CANDECOMP if the
rank of the approximation is fixed to 1. Then the methods differs,
PTA-<em>k</em>modes will look for best approximation according to the
<em>orthogonal rank</em> (<em>i.e.</em> the rank-one tensors (of the
decomposition) are orthogonal), PCA-<em>k</em>modes will look for best
approximation according to the <em>space ranks</em> (<em>i.e.</em>  ranks
of every bilinear form deducted from the original tensor, that is the
number of components in each space), PARAFAC/CANDECOMP will look for
best approximation according to the <em>rank</em> (<em>i.e.</em> the
rank-one tensors are not necessarily orthogonal).
<br />
Recent work from Tamara G Kolda showed on an example that <em>orthogonal rank</em>
decompositions are not necesseraly nested. This makes PTA-<em>k</em>modes a model with
nested decompositions not giving the exact <em>orthogonal rank</em>.
So PTA-<em>k</em>modes will look for best approximation according to orthogonal tensors in a nested approximmation process.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+PTAk">PTAk</a></code> object (without <code>datanam method</code>)</p>


<h3>Note</h3>

<p>The algorithm was derived in generalising the <em>transition
formulae</em> of SVD (Leibovici 1993), can also be understood as a
generalisation of the <em>power method</em> (De Lathauwer et al.
2000). In this paper they also use a similar algorithm  to build
bases in each space, reminiscent of three-modes and <em>n</em>-modes
PCA (Kroonenberg(1980)), <em>i.e.</em> defining what they called a
rank-(R1,R2,...,Rn) approximation (called here <em>space ranks</em>,
see <code>PCAn</code>). <em>RPVSCC</em> stands for  <em>R</em>echerche de la <em>P</em>remi&lt;e8&gt;re
<em>V</em>aleur <em>S</em>inguli&lt;e8&gt;re par <em>C</em>ontraction
<em>C</em>ompl&lt;ea&gt;te.
</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>References</h3>

<p>Kroonenberg P (1983) <em>Three-mode Principal Component Analysis:
Theory and Applications</em>. DSWO press. Leiden.
</p>
<p>Leibovici D(1993) <em>Facteurs &lt;e0&gt; Mesures R&lt;e9&gt;p&lt;e9&gt;t&lt;e9&gt;es et Analyses Factorielles :
applications &lt;e0&gt; un suivi &lt;e9&gt;pid&lt;e9&gt;miologique</em>. Universit&lt;e9&gt; de Montpellier
II. PhD Thesis in Math&lt;e9&gt;matiques et Applications (Biostatistiques).
</p>
<p>Leibovici D and Sabatier R (1998) <em>A Singular Value
Decomposition of a k-ways array for a Principal Component Analysis of
multi-way data, the PTA-k</em>. Linear Algebra and its Applications,
269:307-329.
</p>
<p>De Lathauwer L, De Moor B and Vandewalle J (2000) <em>On the best
rank-1 and rank-(R1,R2,...,Rn) approximation of higher-order
tensors</em>. SIAM J. Matrix Anal. Appl. 21,4:1324-1342.
</p>
<p>Kolda T.G (2003)<em> A Counterexample to the Possibility of an Extension of the Eckart-Young Low-Rank Approximation Theorem for the Orthogonal Rank Tensor Decomposition</em>. SIAM J. Matrix Analysis, 24(2):763-767, Jan. 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+INITIA">INITIA</a></code>, <code><a href="#topic+PTAk">PTAk</a></code>, <code><a href="#topic+PCAn">PCAn</a></code>,
<code><a href="#topic+CANDPARA">CANDPARA</a></code> </p>

<hr>
<h2 id='summary.PTAk'>Summary of a PTA-k modes analysis</h2><span id='topic+summary.PTAk'></span><span id='topic+summary.FCAk'></span>

<h3>Description</h3>

<p>Print a summary listing of the decomposition obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PTAk'
summary(object,testvar=1,dontshow="*", ...)
## S3 method for class 'FCAk'
summary(object,testvar=0.5,dontshow="*", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PTAk_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>PTAk</code>, representing a generalised  singular value decomposition</p>
</td></tr>
<tr><td><code id="summary.PTAk_+3A_testvar">testvar</code></td>
<td>
<p>control within <code>nTens</code> used Principal Tensor with  minimum percent of variability explained</p>
</td></tr>
<tr><td><code id="summary.PTAk_+3A_dontshow">dontshow</code></td>
<td>

<p>boolean criterion to remove Principal Tensors from the summary, or
default is a character &quot;*&quot; equivalent to the criterion:
<br />
<code>!substr(solution[[length(solution)]][["vsnam"]],1,1)=="*"</code> </p>
</td></tr>
<tr><td><code id="summary.PTAk_+3A_...">...</code></td>
<td>
<p>summary generic additional arguments not used here </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints a listing of the decomposition with historical
order (instead of traditional singular value order). It is useful
before any plots or reconstruction, a screeplot (using
<code>plot.PTAk</code>) will be also useful. It is useful before any plots
r reconstruction, a screeplot (using <code>plot.PTAk</code>) will be also
useful. <code>summary.FCAk</code> is alike
<code>summary.PTAk</code> but <code>testvar</code> operates on the variability of
the lack of complete independence. </p>


<h3>Value</h3>

<p>prints on the prompt with an invisible return of the summary table</p>


<h3>Note</h3>

<p>At the moment can be used for <code>PCAn</code>,
<code>CANDPRA</code>, better summaries will be in the next release.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici <a href="mailto:GeotRYcs@gmail.com">GeotRYcs@gmail.com</a></p>


<h3>References</h3>

<p>Leibovici D (2000) <em>Multiway Multidimensional Analysis for
Pharmaco-EEG Studies</em>.(submitted)
<a href="https://www.researchgate.net/publication/216807619_Multiway_Multidimensional_Analysis_for_Pharmaco-EEG_Studies">https://www.researchgate.net/publication/216807619_Multiway_Multidimensional_Analysis_for_Pharmaco-EEG_Studies</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.PTAk">plot.PTAk</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> data(crimerate)
 crimerate.mat &lt;- sweep(crimerate,2,apply(crimerate,2,mean))
 crimerate.mat &lt;- sweep(crimerate.mat,2,sqrt(apply(crimerate,2,var)),FUN="/")
 cri.svd &lt;- SVDgen(crimerate.mat)
 summary(cri.svd,testvar=0)
  plot(cri.svd,scree=TRUE)
  par(new=TRUE)
  RiskJackplot(cri.svd,nbvs=1:7,mod=NULL,max=NULL,rescaled=TRUE,
        axes=FALSE,ann=FALSE)
  par(new=FALSE)

  # or equivalently

  plot(cri.svd,scree=TRUE,type="b",lty=3,RiskJack=1) #set mod=NULL or c(1,2)
  ###
   data(crimerate)
   criafc &lt;- FCAmet(crimerate,chi2=TRUE)
   cri.afc &lt;- SVDgen(criafc$data,criafc$met[[2]],criafc$met[[1]])
    summary(cri.afc)
   plot(cri.afc,scree=TRUE)
   plot(cri.afc,scree=TRUE,type="b",lty=3,RiskJack=1,method="FCA")


   </code></pre>

<hr>
<h2 id='SVDgen'>SVD with metrics and smoothing approximation</h2><span id='topic+SVDgen'></span>

<h3>Description</h3>

<p>Computes the generalised Singular Value Decomposition, <em>i.e.</em> with
non-identity metrics. A smooth approximation can be asked to constraint the
components (<code>u</code> and <code>v</code>) to be smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SVDgen(Y, D2 = 1, D1 = 1, smoothing = FALSE, nomb = NULL,
                  smoo = list(function(u)ksmooth( 1:length(u), u, kernel = "normal",
                           bandwidth = 3, x.points = (1:length(u)))$y)) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVDgen_+3A_y">Y</code></td>
<td>
<p>a matrix <code class="reqn">n \times p</code></p>
</td></tr>
<tr><td><code id="SVDgen_+3A_d2">D2</code></td>
<td>
<p>metric in <code class="reqn">R^p</code> either a vector (<code class="reqn">p \times 1</code>) or a matrix (<code class="reqn">p \times p</code>)</p>
</td></tr>
<tr><td><code id="SVDgen_+3A_d1">D1</code></td>
<td>
<p>metric in <code class="reqn">R^n</code> either a vector (<code class="reqn">n \times 1</code>) or a matrix (<code class="reqn">n \times n</code>)</p>
</td></tr>
<tr><td><code id="SVDgen_+3A_smoothing">smoothing</code></td>
<td>
<p>logical if <code>TRUE</code>  the smoothing methods in
<code>smoo</code> are used</p>
</td></tr>
<tr><td><code id="SVDgen_+3A_nomb">nomb</code></td>
<td>
<p>numeric number of components to extract (typically when
smoothing is used less components are used as the screeplot becomes
flatter faster)</p>
</td></tr>
<tr><td><code id="SVDgen_+3A_smoo">smoo</code></td>
<td>

<p>list of lists of smoothing functions on a vector of the approriate dimension; if on one dimension it is
<code>NA</code> no smoothing will be done for this one; if the length of a list is one the function is used
for all components. If only one list in the list it will be used for both dimensions. </p>
</td></tr> </table>


<h3>Details</h3>

<p>The function computes the decomposition <code class="reqn">X=UL^{1/2}V'</code> where <code class="reqn">U'D_1U=Id_p</code> and
<code class="reqn">V'D_2V=Id_p</code> and the diagonal matrix <code class="reqn">L</code> containing no zeros squared singular values. If
<code>smoothing</code> a <em>constraint</em>  on Least Squares solution  is used, then the
above decomposition becomes an approximation (unless <code>X</code> belongs to the space defined by the constraints). A <em>Power Method</em> algorithm to compute each
principal tensor is used wherein Alternated Least Squares are always followed by a <em>smoothed
version</em> of the updated vectors. If a Spline smoothing was used the algorithm would be equivalent
to use the traditional <em>penalised least squares</em> at each iteration and could be called
<em>Penalised Power Method</em> or Splined Alternated Least Squares Algorithm (SALSA is already  an
acronym used by Besse and Ferraty (1995) in where  a similar idea is developped: but smoothing
operates only on variables, and is<em> model based</em> as the Alternating operates on the whole
approximation <em>i.e.</em> given the choice of the dimension
reduction). </p>


<h3>Value</h3>

<p>a <code>PTAk</code> object</p>


<h3>Note</h3>

<p><code>SVDgen</code> makes use of a non-identity version <code>svd</code> (inbuilt) or
<code>svdksmooth</code> which outputs like the inbuilt <code>svd</code>. The smoothing
option is also implemented in PTA-kmodes, FCA-kmodes, PCAn and
CANDECOMP/PARAFAC. The use of metrics (diagonal or not) allows flexibility of
analysis like <em>e.g.</em> correspondence analysis, discriminant analysis,
robust analysis. Smoothing option extends the analysis towards functional data
analysis, and or outliers protection. 
</p>
<p>This smoothing penalising approach is theoretically valid for Principal Tensors (here order 2) belonging
to a tensor product of separable Hilbert spaces (<em>e.g.</em> Sobolev
spaces) see Leibovici and El Maach (1997), and in fact only valid for
projection onto this space : this includes polynomial fitting, spline
basis fitting ... As you are penalysing the alternating optimisation
criterion you also need the to get a <em>robust fit</em> at each iteration to be
able to reach stationarity and declare optimisation done. If the smoother is not linear one looses orthogonality of
the corresponding components but they are usually not too much correlated
and preserving one mode to be unsmoothed insured orthogonality of the
whole decomposition. Alternatively <code>keepOrtho</code> insures (as a third
step optimisation for each iteration) orthogonality with the previous
component (but then the solution is approximatively in the space of constraints).
</p>
<p>The flexibility of this function <code>smoothing</code> constraint should be carefully used. The
function offers also the choice to change of smoothing (method or parameters)
as the number of components grows as in Ramsay and Silverman (1997).</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici <a href="mailto:GeotRYcs@gmail.com">GeotRYcs@gmail.com</a></p>


<h3>References</h3>

<p>Leibovici D and El Maache H (1997) <em>Une décomposition en Valeurs Singulières d'un élément
d'un produit Tensoriel de k espaces de Hilbert Séparables</em>. Compte Rendus de l'Académie des
Sciences tome 325, série I, Statistiques (Statistics) &amp; Probabilités (Probability Theory):
779-782.
</p>
<p>Besse P and Ferraty F (1995) <em>Curvilinear fixed effect model</em>. Computational Statistics, 10:339-351.
</p>
<p>Leibovici  D (2008) <em>A Simple Penalised algorithm for SVD and Multiway
functional  methods</em>. (to be submitted)
</p>
<p>Ramsay J.O. and Silverman B.W.  (1997) <em>Functional Data
Analysis</em>. Springer Series in Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PTAk">PTAk</a></code>,<code><a href="#topic+PCAn">PCAn</a></code>, <code><a href="#topic+CANDPARA">CANDPARA</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(stats)
 #library(tensor)

 # on smoothing

 data(longley)
 long &lt;- as.matrix(longley[,-6])

 long.svd &lt;- SVDgen(long,smoothing=FALSE)
  summary.PTAk(long.svd,testvar=0)
   # X11(width=4,height=4)
  plot.PTAk(long.svd,scree=TRUE,RiskJack=4,type="b",lty=3)

 long.svdo &lt;- SVDgen(long,smoothing=TRUE,
  smoo=list(function(u)ksmooth(1:length(u),
      u,kernel="normal",bandwidth=3,x.points=(1:length(u)))$y,NA))

  summary.PTAk(long.svdo,testvar=0)
  #  X11(width=4,height=4)
  plot.PTAk(long.svdo,scree=TRUE,type="b",lty=3)
 ###using polynomial fitting
   polyfit &lt;- function(u,deg=length(u)/5)
       {n &lt;- length(u);time &lt;- rep(1,n);
        for(e in 1:deg)time&lt;-cbind(time,(1:n)^e);return(lm.fit(time,u)$fitted.values)}
bsfit&lt;-function(u,deg=42)
       {n &lt;- length(u);time &lt;- rep(1,n);
        return(lm.fit(bs(time,df=deg),u)$fitted.values)}

###
 long.svdo2 &lt;- SVDgen(long,nomb=4,smoothing=TRUE,smoo=list(polyfit,NA))
  long.svdo2[[1]]$v[1:3,]
long.svdo[[1]]$v[1:3,]
# orthogonality may be lost with non-projective smoother

     ####
comtoplot &lt;- function(com=1,solua=long.svd,solub=long.svdo,openX11s=FALSE,...)
         {
  if(openX11s)X11(width=4,height=4)
 yla &lt;- c(round((100*(solua[[2]]$d[com])^2)/
     solua[[2]]$ssX[1],4),
     round((100*(solub[[2]]$d[com])^2)/solua[[2]]$ssX[1],4))

limi &lt;- range(c(solua[[1]]$v[com,],solub[[1]]$v[com,]))
  plot(solua,nb1=com, mod=1,type="b",lty=3,lengthlabels=4,cex=0.4,
   ylimit=limi,ylab="",...)
mtext(paste("vs",com,":",yla[1],"%"),2,col=2,line=2)
 par(new=TRUE)

  plot.PTAk(solub,nb1=com,mod=1,labels=FALSE,type="b",lty=1,
  lengthlabels=4,cex=0.6,ylimit=limi,ylab="",main=paste("smooth vs",com,":",yla[2],"%"),...)
  par(new=FALSE)
}   ####
 comtoplot(com=1)



#  on using non-diagonal metrics

 data(crimerate)
  crimerate.mat &lt;- sweep(crimerate,2,apply(crimerate,2,mean))
  crimerate.mat &lt;- sweep(crimerate.mat,2,sqrt(apply(crimerate.mat,2,var)),FUN="/")
   metW &lt;- Powmat(CauRuimet(crimerate.mat),(-1))
   # inverse of the within "group" (to play a bit more you could set m0 relating
   # the neighbourhood of states (see CauRuimet)

  cri.svd &lt;- SVDgen(crimerate.mat,D2=1,D1=1)
  summary(cri.svd,testvar=0)
   plot(cri.svd,scree=TRUE,RiskJack=4,type="b",lty=3)
  cri.svdo &lt;- SVDgen(crimerate.mat,D2=metW,D1=1)
   summary(cri.svdo,testvar=0)
   plot(cri.svdo,scree=TRUE,RiskJack=4,type="b",lty=3)
  # X11(width=8,height=4)
  par(mfrow=c(1,2))
   plot(cri.svd,nb1=1,nb2=2,mod=1,lengthlabels=3)
  plot(cri.svd,nb1=1,nb2=2,mod=2,lengthlabels=4,main="canonical")
  # X11(width=8,height=4)
  par(mfrow=c(1,2))
 plot(cri.svdo,nb1=1,nb2=2,mod=1,lengthlabels=3)
 plot(cri.svdo,nb1=1,nb2=2,mod=2,lengthlabels=4,
       main=expression(paste("metric ",Wg^{-1})))

###########
#  demo function
 # when ima is NULL it uses the dataset timage12 but you can put any array
 # demo.SVDgen(ima=NULL,snr=3,openX11s=TRUE)  

    </code></pre>

<hr>
<h2 id='TENSELE'>Elementary Tensor product</h2><span id='topic+TENSELE'></span>

<h3>Description</h3>

<p>Computes the Tensor Product of a list of vectors  (or matrices) according to
a given order.</p>


<h3>Usage</h3>

<pre><code class='language-R'> TENSELE(T,moins=NULL, asarray=TRUE,order=NULL,id=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TENSELE_+3A_t">T</code></td>
<td>
<p>a list like a <code>PTAk</code> object and minimally  just contains <code>v</code> </p>
</td></tr>
<tr><td><code id="TENSELE_+3A_moins">moins</code></td>
<td>
<p>if not <code>NULL</code>, vector of indexes  (in the list T) to skip  </p>
</td></tr>
<tr><td><code id="TENSELE_+3A_asarray">asarray</code></td>
<td>
<p>logical to specify the output form <code>TRUE</code> gives an array, <code>FALSE</code> gives a vector</p>
</td></tr>
<tr><td><code id="TENSELE_+3A_order">order</code></td>
<td>

<p>if not <code>NULL</code> vector of length <code>length(T)</code>, <code>NULL</code> is equivalent to
<code>length(T):1</code> as the function makes indexes in order run slowest to
fastest </p>
</td></tr>
<tr><td><code id="TENSELE_+3A_id">id</code></td>
<td>

<p>when <code>T</code> is a list of matrices, can be either a vector of
<code>length(T)</code> giving indexes of the vectors for each space (following
order) or a list of vectors of indexes.</p>
</td></tr> </table>


<h3>Details</h3>

<p>The tensor product of the vectors (or matrices) in the list <code>T</code> is
computed, skipping or not the indexes in <code>moins</code>, the output tensor is
either in tensor form or in vector form. The way the tensor product is done
follows <code>order</code>.</p>


<h3>Value</h3>

<p>According to <code>asarray</code> the value is either an array, or a vector
representing the tensor product of the vectors (not in moins), the dimension
in <code>order[1]</code> running the slowest.</p>


<h3>Author(s)</h3>

<p>Didier G. Leibovici</p>


<h3>See Also</h3>

<p><code><a href="#topic+REBUILD">REBUILD</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
