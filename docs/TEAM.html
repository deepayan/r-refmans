<!DOCTYPE html><html><head><title>Help for package TEAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TEAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chunk.sum'><p>Chunk.Sum function</p></a></li>
<li><a href='#est.c.hat'><p>Estimate threshold function</p></a></li>
<li><a href='#est.FDR.hat.l'><p>Calculate FDR</p></a></li>
<li><a href='#expand.mat'><p>Enumerate binomial support</p></a></li>
<li><a href='#splitNoOverlap'><p>splitNoOverlap function</p></a></li>
<li><a href='#TEAM'><p>Testing on an Aggregation Tree Method</p></a></li>
<li><a href='#valid.counts'><p>Valid counts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Hypothesis Testing on an Aggregation Tree Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>John Pura, Cliburn Chan, and Jichun Xie</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Pura &lt;john.pura@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the TEAM algorithm to identify local differences 
    between two (e.g. case and control) independent, univariate distributions, as 
    described in J Pura, C Chan, and J Xie (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1906.07757">doi:10.48550/arXiv.1906.07757</a>&gt;. The algorithm 
    is based on embedding a multiple-testing procedure on a hierarchical structure 
    to identify high-resolution differences between two distributions. The 
    hierarchical structure is designed to identify strong, short-range differences 
    at lower layers and weaker, but long-range differences at increasing layers. 
    TEAM yields consistent layer-specific and overall false discovery rate control.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr,ggplot2,ks</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-09 14:53:02 UTC; John_Pura</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-13 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chunk.sum'>Chunk.Sum function</h2><span id='topic+chunk.sum'></span>

<h3>Description</h3>

<p>Rolling Sum over distinct chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk.sum(v, n, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk.sum_+3A_v">v</code></td>
<td>
<p>Numeric Vector</p>
</td></tr>
<tr><td><code id="chunk.sum_+3A_n">n</code></td>
<td>
<p>Size of chunk</p>
</td></tr>
<tr><td><code id="chunk.sum_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs (default=TRUE)</p>
</td></tr>
</table>

<hr>
<h2 id='est.c.hat'>Estimate threshold function</h2><span id='topic+est.c.hat'></span>

<h3>Description</h3>

<p>Estimate threshold to control FDR in multiple testing procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.c.hat(l, n, theta0, x.l, c.hats, alpha, m.l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.c.hat_+3A_l">l</code></td>
<td>
<p>Layer</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_n">n</code></td>
<td>
<p>Number of pooled case and control observations in each layer 1 bin</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_theta0">theta0</code></td>
<td>
<p>Nominal boundary level for binomial parameter at layer 1</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_x.l">x.l</code></td>
<td>
<p>Vector of case counts in each bin</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_c.hats">c.hats</code></td>
<td>
<p>Previous c.hats calculated from layers 1 to l-1</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_alpha">alpha</code></td>
<td>
<p>Nominal FDR level</p>
</td></tr>
<tr><td><code id="est.c.hat_+3A_m.l">m.l</code></td>
<td>
<p>Number of leaf hypotheses at layer l</p>
</td></tr>
</table>

<hr>
<h2 id='est.FDR.hat.l'>Calculate FDR</h2><span id='topic+est.FDR.hat.l'></span>

<h3>Description</h3>

<p>Step-down multiple-testing procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.FDR.hat.l(min.x, max.x, c.prev, n.l, x.l, theta0, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est.FDR.hat.l_+3A_min.x">min.x</code></td>
<td>
<p>lower limit of searching range</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_max.x">max.x</code></td>
<td>
<p>upper limit of searching range</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_c.prev">c.prev</code></td>
<td>
<p>Previous c.hat from layer l-1</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_n.l">n.l</code></td>
<td>
<p>Vector of number of pooled observations in layer l bins</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_x.l">x.l</code></td>
<td>
<p>Vector of case counts in each bin at layer l</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_theta0">theta0</code></td>
<td>
<p>Nominal boundary level for binomial parameter at layer 1</p>
</td></tr>
<tr><td><code id="est.FDR.hat.l_+3A_l">l</code></td>
<td>
<p>Layer</p>
</td></tr>
</table>

<hr>
<h2 id='expand.mat'>Enumerate binomial support</h2><span id='topic+expand.mat'></span>

<h3>Description</h3>

<p>Enumerate possible counts for calculating binomial probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.mat(mat, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.mat_+3A_mat">mat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="expand.mat_+3A_vec">vec</code></td>
<td>
<p>Numeric Vector</p>
</td></tr>
</table>

<hr>
<h2 id='splitNoOverlap'>splitNoOverlap function</h2><span id='topic+splitNoOverlap'></span>

<h3>Description</h3>

<p>Split a vector into distinct chunks of specified size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitNoOverlap(vec, seg.length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitNoOverlap_+3A_vec">vec</code></td>
<td>
<p>Numeric Vector</p>
</td></tr>
<tr><td><code id="splitNoOverlap_+3A_seg.length">seg.length</code></td>
<td>
<p>Number of distinct chunks to split vec</p>
</td></tr>
</table>

<hr>
<h2 id='TEAM'>Testing on an Aggregation Tree Method</h2><span id='topic+TEAM'></span>

<h3>Description</h3>

<p>This function performs multiple testing embedded in a hierarchical structure in order to identify local differences between two independent distributions (e.g. case and control).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEAM(x1, x2, theta0 = length(x2)/length(c(x1, x2)), K = 14,
  alpha = 0.05, L = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TEAM_+3A_x1">x1</code></td>
<td>
<p>Numeric vector of N1 control observations</p>
</td></tr>
<tr><td><code id="TEAM_+3A_x2">x2</code></td>
<td>
<p>Numeric vector of N2 case observations</p>
</td></tr>
<tr><td><code id="TEAM_+3A_theta0">theta0</code></td>
<td>
<p>Nominal boundary level for binomial parameter - default is N2/(N1+N2)</p>
</td></tr>
<tr><td><code id="TEAM_+3A_k">K</code></td>
<td>
<p>log2 number of bins</p>
</td></tr>
<tr><td><code id="TEAM_+3A_alpha">alpha</code></td>
<td>
<p>Nominal false discovery rate (FDR) level</p>
</td></tr>
<tr><td><code id="TEAM_+3A_l">L</code></td>
<td>
<p>Number of layers in the aggregation tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the discoveries (S.list) in each layer and the estimated layer-specific thresholds (c.hats)
</p>


<h3>References</h3>

<p>Pura J. Chan C. Xie J. Multiple Testing Embedded in an Aggregation Tree to Identify where Two Distributions Differ. <a href="https://arxiv.org/abs/1906.07757">https://arxiv.org/abs/1906.07757</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Simulate local shift difference for each population from mixture of normals
N1 &lt;- N2 &lt;- 1e6
require(ks) #loads rnorm.mixt function
#Controls
x1 &lt;- rnorm.mixt(N1,mus=c(0.2,0.89),sigmas=c(0.04,0.01),props=c(0.97,0.03))
#Cases
x2 &lt;- rnorm.mixt(N2,mus=c(0.2,0.88),sigmas=c(0.04,0.01),props=c(0.97,0.03))
res &lt;- TEAM(x1,x2,K=14,alpha=0.05,L=3)
#Discoveries in each layer - Each element is an growing set of
#indices captured at each layer
res$S.list
#Map back final discoveries in layer 3 to corresponding regions
levels(res$dat$quant)[res$S.list[[3]]]

</code></pre>

<hr>
<h2 id='valid.counts'>Valid counts</h2><span id='topic+valid.counts'></span>

<h3>Description</h3>

<p>Enumerate matrix of valid counts for a vector of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid.counts(x, c.prev)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.counts_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="valid.counts_+3A_c.prev">c.prev</code></td>
<td>
<p>Calculated chat from layer l-1</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
