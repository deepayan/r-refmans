<!DOCTYPE html><html><head><title>Help for package qrcmNP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qrcmNP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qrcmNP-package'>
<p>Nonlinear and Penalized Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#gof.piqr'>
<p>Goodness of Fit of Penalized Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#niqr'>
<p>Nonlinear Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#piqr'>
<p>Penalized Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#plot.niqr'>
<p>Plot Nonlinear Quantile Regression Coefficients</p></a></li>
<li><a href='#plot.piqr'>
<p>Plot Penalized Quantile Regression Coefficients</p></a></li>
<li><a href='#predict.niqr'>
<p>Prediction After Nonlinear Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#predict.piqr'>
<p>Prediction After Penalized Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#summary.niqr'>
<p>Summary After Nonlinear Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#summary.piqr'>
<p>Summary After Penalized Quantile Regression Coefficients Modeling</p></a></li>
<li><a href='#testfit.niqr'>
<p>Goodness-of-Fit Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear and Penalized Quantile Regression Coefficients
Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianluca Sottile [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonlinear and Penalized parametric modeling of quantile regression coefficient functions. Sottile G, Frumento P, Chiodi M and Bottai M (2020) &lt;<a href="https://doi.org/10.1177%2F1471082X19825523">doi:10.1177/1471082X19825523</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival (&ge; 2.4.1), qrcm (&ge; 3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 09:25:12 UTC; gianlucasottile</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 09:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='qrcmNP-package'>
Nonlinear and Penalized Quantile Regression Coefficients Modeling
</h2><span id='topic+qrcmNP-package'></span>

<h3>Description</h3>

<p>This package implements a nonlinear Frumento and Bottai's (2016) method for quantile regression coefficient modeling (qrcm), in which quantile regression coefficients are described by (flexible) parametric functions of the order of the quantile. In the classical qrcm framework the linearity in <code class="reqn">\beta(p)</code> and/or in <code class="reqn">\theta</code> could be relaxed at a cost of more complicated expressions for the ojective and the gradient functions. Here, we propose an efficiently algorithm to use more flexible structures for the regression coefficients. With respect to the most famous function nlrq (quantreg package) our main function niqr implements the integrated quantile regression idea  of Frumento and Bottai's (2016) for nonlinear functions. As already known, this practice allows to estimate quantiles all at one time and not one at a time.
This package also implements a penalized Frumento and Bottai's (2015) method for quantile regression coefficient modeling (qrcm). This package fits lasso qrcm using pathwise coordinate descent algorithm. With respect to some other packages which implements the L1-quantile regression (e.g. quantreg, rqPen) estimating quantiles one at a time our proposal allows to estimate the conditional quantile function parametrically estimating quantiles all at one and to do variable selction in the meanwhile.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qrcmNP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The function <code><a href="#topic+niqr">niqr</a></code> permits specifying nonlinear basis for each variables. The function <code><a href="#topic+testfit.niqr">testfit.niqr</a></code> permits to do goodness of fit.
The auxiliary functions <code><a href="#topic+summary.niqr">summary.niqr</a></code>, <code><a href="#topic+predict.niqr">predict.niqr</a></code>, and <code><a href="#topic+plot.niqr">plot.niqr</a></code> can be used to extract information from the fitted model.
The function <code><a href="#topic+piqr">piqr</a></code> permits specifying the lasso regression model. The function <code><a href="#topic+gof.piqr">gof.piqr</a></code> permits to select the best tuning parameter through AIC, BIC, GIC and GCV criteria. The auxiliary functions <code><a href="#topic+summary.piqr">summary.piqr</a></code>, <code><a href="#topic+predict.piqr">predict.piqr</a></code>, and <code><a href="#topic+plot.piqr">plot.piqr</a></code> can be used to extract information from the fitted model.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile G, Frumento P, Chiodi M, Bottai M. (2020). <em>A penalized approach to covariate selection through quantile regression coefficient models</em>. Statistical Modelling, 20(4), pp 369-385. doi:10.1177/1471082X19825523.
</p>
<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72(1), pp 74-84, doi:10.1111/biom.12410.
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008). <em>Regularization Paths for Generalized Linear Models via Coordinate Descent</em>. Journal of Statistical Software, Vol. 33(1), pp 1-22 Feb 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use simulated data

n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(0, 4), X=cbind(1,x), y=y)

# use simulated data

set.seed(1234)
n &lt;- 300
x1 &lt;- rexp(n)
x2 &lt;- runif(n, 0, 5)
x &lt;- cbind(x1,x2)

b &lt;- function(p){matrix(cbind(1, qnorm(p), slp(p, 2)), nrow=4, byrow=TRUE)}
theta &lt;- matrix(0, nrow=3, ncol=4); theta[, 1] &lt;- 1; theta[1,2] &lt;- 1; theta[2:3,3] &lt;- 2
qy &lt;- function(p, theta, b, x){rowSums(x * t(theta %*% b(p)))}

y &lt;- qy(runif(n), theta, b, cbind(1, x))

s &lt;- matrix(1, nrow=3, ncol=4); s[1,3:4] &lt;- 0
obj &lt;- piqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + slp(p, 2), s=s, nlambda=50)

best &lt;- gof.piqr(obj, method="AIC", plot=FALSE)
best2 &lt;- gof.piqr(obj, method="BIC", plot=FALSE)

summary(obj, best$posMinLambda)
summary(obj, best2$posMinLambda)

</code></pre>

<hr>
<h2 id='gof.piqr'>
Goodness of Fit of Penalized Quantile Regression Coefficients Modeling
</h2><span id='topic+gof.piqr'></span>

<h3>Description</h3>

<p>Goodness of Fit of an object of class &ldquo;<code>piqr</code>&rdquo;, usefull to select the best tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof.piqr(object, method=c("BIC","AIC"), Cn="1", plot=TRUE, df.new=TRUE, logi=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.piqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>piqr</code>&rdquo;, the result of a call to <code><a href="#topic+piqr">piqr</a></code>.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_method">method</code></td>
<td>

<p>a method to evaluate the goodness of fit and select the best value of the tuning parameter.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_cn">Cn</code></td>
<td>

<p>It is some positive constant that diverges to infinity as n increase. It is used by the BIC criterion and if Cn = 1 the classical BIC is used.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_df.new">df.new</code></td>
<td>

<p>if TRUE degrees of freedom are evaluated as the number of </p>
<p style="text-align: center;"><code class="reqn">\beta_j(p | \theta) != 0,  j = 1,\ldots, q</code>
</p>
<p>.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_logi">logi</code></td>
<td>

<p>if TRUE the loss function is log-transformed.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_plot">plot</code></td>
<td>

<p>if TRUE the chosen method is plotted - default is TRUE.
</p>
</td></tr>
<tr><td><code id="gof.piqr_+3A_...">...</code></td>
<td>

<p>additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best value of lambda is chosen minimizing the criterion, i.e., AIC and BIC.
</p>


<h3>Value</h3>

<table>
<tr><td><code>minLambda</code></td>
<td>
<p>the best value of lambda.</p>
</td></tr>
<tr><td><code>dfMinLambda</code></td>
<td>
<p>the number of nonzero parameters associated to the best lambda.</p>
</td></tr>
<tr><td><code>betaMin</code></td>
<td>
<p>the parameters associated to the best lambda.</p>
</td></tr>
<tr><td><code>posMinLambda</code></td>
<td>
<p>the position of the best lambda along the sequence of lambda.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piqr">piqr</a></code>, for model fitting; <code><a href="#topic+summary.piqr">summary.piqr</a></code> and <code><a href="#topic+plot.piqr">plot.piqr</a></code>, for summarizing and plotting <code>piqr</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

set.seed(1234)
n &lt;- 300
x1 &lt;- rexp(n)
x2 &lt;- runif(n, 0, 5)
x &lt;- cbind(x1,x2)

b &lt;- function(p){matrix(cbind(1, qnorm(p), slp(p, 2)), nrow=4, byrow=TRUE)}
theta &lt;- matrix(0, nrow=3, ncol=4); theta[, 1] &lt;- 1; theta[1,2] &lt;- 1; theta[2:3,3] &lt;- 2
qy &lt;- function(p, theta, b, x){rowSums(x * t(theta %*% b(p)))}

y &lt;- qy(runif(n), theta, b, cbind(1, x))

s &lt;- matrix(1, nrow=3, ncol=4); s[1,3:4] &lt;- 0
obj &lt;- piqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + slp(p, 2), s=s, nlambda=50)

par(mfrow=c(1,2))
best &lt;- gof.piqr(obj, method="AIC", plot=TRUE)
best2 &lt;- gof.piqr(obj, method="BIC", plot=TRUE)
</code></pre>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+internals'></span><span id='topic+Q'></span><span id='topic+funQ1'></span><span id='topic+check.fun'></span><span id='topic+boot'></span><span id='topic+predBeta'></span><span id='topic+grad3'></span><span id='topic+grad2'></span><span id='topic+num.int'></span><span id='topic+integr'></span><span id='topic+bisec'></span><span id='topic+Bfun'></span><span id='topic+bfun'></span><span id='topic+funGrad'></span><span id='topic+Fun'></span><span id='topic+armijo'></span><span id='topic+start.theta.niqr'></span><span id='topic+piqr.internal'></span><span id='topic+check.in.2'></span><span id='topic+check.out.2'></span><span id='topic+piqr.newton'></span><span id='topic+piqr.ee'></span><span id='topic+pciqr.ee'></span><span id='topic+pctiqr.ee'></span><span id='topic+plotCoef'></span><span id='topic+nonzeroCoef'></span><span id='topic+cov.theta.2'></span><span id='topic+plotPiqr2'></span><span id='topic+divide.et.impera.2'></span><span id='topic+print.niqr'></span><span id='topic+print.summary.niqr'></span><span id='topic+print.piqr'></span><span id='topic+print.summary.piqr'></span><span id='topic+terms.piqr'></span><span id='topic+coef.piqr'></span><span id='topic+model.matrix.piqr'></span><span id='topic+nobs.piqr'></span>

<h3>Description</h3>

<p>Functions for internal use only, or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Q(beta, X)
funQ1(X)
check.fun(obj, b)
boot(fun, fun2, X, y, start_theta, true_theta, p, seed, boot=FALSE, R=100, ...)
predBeta(obj, p)
grad3(fun, fun2, x, p, X, npp, q, h = 1e-04, method = c("1", "2", "3"))
grad2(fun, x, p, n.var, q, s, ind, h = 1e-04, method = c("1", "2", "3"))
num.int(x, dx, fx)
integr(fun, a=.01, b=.99, n=100, p0, h, ...)
bisec(fun, fun2, x, X, y, nit=15, n=NULL)
Bfun(fun, fun2, x, p.star.y, xx, dx, npp, q, X, n.var, p0,
     s = NULL, ind = NULL, hh, a = 0.01, b = 0.99, n = 100,
     fun_prime_theta=NULL, fun_prime_beta=NULL, ...)
bfun(fun, fun2, x, p.star.y, xx, dx, npp, q, X, p0, hh, a = 0.01, b = 0.99, n = 100)
funGrad(fun, fun2, x, y, X, i = FALSE, p.star.y, xx = NULL, dx = NULL, npp = NULL,
        p0 = NULL, s = NULL, ind = NULL, h = NULL, n = NULL, q = NULL, n.var = NULL,
        h1 = 0.01, method = c("1", "2", "3"), fun_prime_theta=NULL, fun_prime_beta=NULL)
Fun(fun, fun2, x, y, X, q, n, p0, npp)
armijo(x0, d, dtg, t0, f0, fun, fun2, alpha, beta, X, y, xx, dx, p0, h, n, npp, q)
start.theta.niqr(fun, fun2, x0, X, y, control=list())

piqr.internal(mf, cl, formula.p, tol=1e-6, maxit=100, s,
              segno=1, lambda=0, check=FALSE, A, st.theta=FALSE, theta0)
check.in.2(mf, formula.p, s)
check.out.2(theta, S, covar)
piqr.newton(theta, y,z,d,X,Xw, bfun, s, type, tol=1e-6, maxit=100, safeit, eps0,
            segno=1, lambda=0)
piqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, J=TRUE, G,
        i=FALSE, segno=1, lambda=0)
pciqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, J = TRUE, G,
         i = FALSE, segno=1, lambda=0)
pctiqr.ee(theta, y, z, d, X, Xw, bfun, p.star.y, p.star.z, J = TRUE, G,
          i = FALSE, segno=1, lambda=0)
plotCoef(beta, norm, lambda, df, dev, grad, label=FALSE,
          xvar=c("norm", "lambda", "objective", "grad"),
          xlab=iname, ylab="Coefficients", ...)
nonzeroCoef(beta, bystep=FALSE)
cov.theta.2(theta, y,z,d,X,Xw, weights, bfun,
            p.star.y, p.star.z, type, s, segno=1, lambda=0)
plotPiqr2(x, lambda, conf.int=TRUE, polygon=TRUE, which=NULL, ask=TRUE, ...)
divide.et.impera.2(fit, V, bfun, s, type, tol, maxit, safeit, eps0, segno = 1, lambda = 0)

## S3 method for class 'niqr'
print(x, digits=max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.niqr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'piqr'
print(x, digits=max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.piqr'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'piqr'
terms(x, ...)
## S3 method for class 'piqr'
coef(object, pos.lambda, ...)
## S3 method for class 'piqr'
model.matrix(object, ...)
## S3 method for class 'piqr'
nobs(object, ...)
</code></pre>

<hr>
<h2 id='niqr'>
Nonlinear Quantile Regression Coefficients Modeling
</h2><span id='topic+niqr'></span>

<h3>Description</h3>

<p>This package implements a nonlinear Frumento and Bottai's (2015) method for quantile regression
coefficient modeling (qrcm), in which quantile regression coefficients are described
by (flexible) parametric functions of the order of the quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niqr(fun, fun2, x0, X, y, control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niqr_+3A_fun">fun</code></td>
<td>

<p>a function of theta and p describing the beta functions.
</p>
</td></tr>
<tr><td><code id="niqr_+3A_fun2">fun2</code></td>
<td>

<p>a function of beta and X describing the whole quantile process.
</p>
</td></tr>
<tr><td><code id="niqr_+3A_x0">x0</code></td>
<td>

<p>starting values to search minimum.
</p>
</td></tr>
<tr><td><code id="niqr_+3A_x">X</code></td>
<td>

<p>a design matrix containing the intercept.
</p>
</td></tr>
<tr><td><code id="niqr_+3A_y">y</code></td>
<td>

<p>the response variable.
</p>
</td></tr>
<tr><td><code id="niqr_+3A_control">control</code></td>
<td>

<p>a list of control parameters. See 'Details'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile regression permits modeling conditional quantiles of a response variabile,
given a set of covariates.
</p>
<p>Assume that each coefficient can be expressed as a parametric function of <code class="reqn">\theta, p</code> of the form:
</p>
<p style="text-align: center;"><code class="reqn">\beta(\theta, p) = b_0(\theta_0, p) + b_1(\theta_1, p) + b_2(\theta_2 , p) + \ldots.</code>
</p>

<p>Users are required to specify a function of <code class="reqn">\theta</code> and p and to provide starting points for the minimization,
the design matrix (with intercept) and the response variable. Some control paramters such as, tol=1e-6,
<code class="reqn">\alpha=.1</code>, <code class="reqn">\beta=.5</code>, maxit=200, maxitstart=20, cluster=NULL, display=FALSE, <code class="reqn">\epsilon=1e-12</code>,
a1=.001, h1=1e-4, meth=&quot;2&quot;, lowp=.01, upp=.99, np=100 could be modified from their default.
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are parameters for line search, tol, epsilon, maxit, and a1 are parameters for quasi Newthod
approach, maxit start is the maximum number of iteration for guessing the best start values, h1 and meth (method)
are parameters for the gradient (method=&quot;2&quot; is centered formula, it is possible to select &quot;1&quot; for right and &quot;3&quot;
for five points stencil), lowp, upp and np are parameters used in the integral formula, and cluster if not NULL is a
vector of ID to compute standard errors in longitudinal data. fun_prime_theta and fun_prime_beta are the gradient functions of the quantile function with respect to <code class="reqn">\theta</code> and <code class="reqn">\beta</code>
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>niqr</code>&rdquo;, a list containing the following items:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the optimal <code class="reqn">\theta</code> values.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard errors for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>the value of the minimized integrated loss function.</p>
</td></tr>
<tr><td><code>gx</code></td>
<td>
<p>the gradient calculated in the optimal points.</p>
</td></tr>
<tr><td><code>Hx</code></td>
<td>
<p>the hessian of quasi newthon method</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>gradient matrix used in the sandwich formaula to compute standard errors.</p>
</td></tr>
<tr><td><code>covar</code></td>
<td>
<p>variance covariance matrix <code class="reqn">H^(-1)\Omega H^(-1).</code></p>
</td></tr>
<tr><td><code>p.star.y</code></td>
<td>
<p>the CDF calculated in the optimal x values.</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>the convergence code, 0 for convergence, 1 for maxit reached, 2 no more step in the gradient.</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>a list containing some initial and control object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2015). <em>Parametric modeling of quantile regression coefficient functions</em>.
Biometrics, doi: 10.1111/biom.12410.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.niqr">summary.niqr</a></code>, <code><a href="#topic+plot.niqr">plot.niqr</a></code>, <code><a href="#topic+predict.niqr">predict.niqr</a></code>,
for summary, plotting, and prediction.
<code><a href="#topic+testfit.niqr">testfit.niqr</a></code> for goodness of fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(.5, 4), X=cbind(1,x), y=y)

## Not run: 
# NOT RUN---qgamma function
set.seed(1234)
n &lt;- 1000
x &lt;- runif(n)
fun2 &lt;- function(theta, p){
  beta0 &lt;- theta[1] + qgamma(p, exp(theta[2]), exp(theta[3]))
  beta1 &lt;- theta[4] + theta[5]*p
  cbind(beta0, beta1)
}
beta &lt;- fun2(c(1,2,2,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun2, x0=rep(.5, 5), X=cbind(1,x), y=y)

# NOT RUN---qbeta function
set.seed(1234)
n &lt;- 1000
x &lt;- runif(n)
fun3 &lt;- function(theta, p){
  beta0 &lt;- theta[1] + theta[2]*qbeta(p, exp(theta[3]), exp(theta[4]))
  beta1 &lt;- theta[5] + theta[6]*p
  cbind(beta0, beta1)
}
beta &lt;- fun3(c(1,1.5,.5,.2,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun3, x0=rep(.5, 6), X=cbind(1,x), y=y)

# NOT RUN---qt function
set.seed(1234)
n &lt;- 1000
x &lt;- runif(n)
fun4 &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2])*qt(p, 1+exp(theta[3]), exp(theta[4]))
  beta1 &lt;- theta[5] + theta[6]*p
  cbind(beta0, beta1)
}
beta &lt;- fun4(c(1,.5,.3,.2,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun4, x0=rep(.5, 6), X=cbind(1,x), y=y)

## End(Not run)

# see the documentation for 'summary.piqr', and 'plot.piqr'

</code></pre>

<hr>
<h2 id='piqr'>
Penalized Quantile Regression Coefficients Modeling
</h2><span id='topic+piqr'></span>

<h3>Description</h3>

<p>This package implements a penalized Frumento and Bottai's (2016) method for quantile regression coefficient modeling (qrcm), in which quantile regression coefficients are described by (flexible) parametric functions of the order of the quantile.
This package fits lasso qrcm using pathwise coordinate descent algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piqr(formula, formula.p = ~ slp(p, 3), weights, data, s, nlambda=100,
     lambda.min.ratio=ifelse(nobs&lt;nvars, 0.01, 0.0001), lambda,
     tol=1e-6, maxit=100, display=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piqr_+3A_formula">formula</code></td>
<td>

<p>a two-sided formula of the form <code>y ~ x1 + x2 + ...</code>:
a symbolic description of the quantile regression model.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_formula.p">formula.p</code></td>
<td>

<p>a one-sided formula of the form <code>~ b1(p, ...) + b2(p, ...) + ...</code>, describing how
quantile regression coefficients depend on <kbd>p</kbd>, the order of the quantile.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_weights">weights</code></td>
<td>

<p>an optional vector of weights to be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment containing the variables in <code>formula</code>.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_s">s</code></td>
<td>

<p>an optional 0/1 matrix that permits excluding some model coefficients
(see &lsquo;Examples&rsquo;).
</p>
</td></tr>
<tr><td><code id="piqr_+3A_nlambda">nlambda</code></td>
<td>

<p>the number of lambda values - default is 100.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Smallest value for lambda, as a fraction of lambda.max. The default depends on the sample size nobs relative to the number of variables nvars. If nobs &gt; nvars, the default is 0.0001, close to zero. If nobs &lt; nvars, the default is 0.01.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_lambda">lambda</code></td>
<td>

<p>A user supplied lambda sequence.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_display">display</code></td>
<td>

<p>if TRUE something is printed - default is TRUE.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_tol">tol</code></td>
<td>

<p>convergence criterion for numerical optimization - default is 1e-6.
</p>
</td></tr>
<tr><td><code id="piqr_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations - default is 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile regression permits modeling conditional quantiles of a response variabile,
given a set of covariates. A linear model is used to describe the conditional
quantile function:
</p>
<p style="text-align: center;"><code class="reqn">Q(p | x) = \beta_0(p) + \beta_1(p)x_1 + \beta_2(p)x_2 + \ldots.</code>
</p>

<p>The model coefficients <code class="reqn">\beta(p)</code> describe the effect of covariates on the <code class="reqn">p</code>-th
quantile of the response variable. Usually, one or more
quantiles  are estimated, corresponding to different values of <code class="reqn">p</code>.
</p>
<p>Assume that each coefficient can be expressed as a parametric function of <code class="reqn">p</code> of the form:
</p>
<p style="text-align: center;"><code class="reqn">\beta(p | \theta) = \theta_{0} + \theta_1 b_1(p) + \theta_2 b_2(p) + \ldots</code>
</p>

<p>where <code class="reqn">b_1(p), b_2(p, \ldots)</code> are known functions of <code class="reqn">p</code>.
If <code class="reqn">q</code> is the dimension of
<code class="reqn">x = (1, x_1, x_2, \ldots)</code>
and <code class="reqn">k</code> is that of
<code class="reqn">b(p) = (1, b_1(p), b_2(p), \ldots)</code>,
the entire conditional quantile function is described by a
<code class="reqn">q \times k</code> matrix <code class="reqn">\theta</code> of model parameters.
</p>
<p>Users are required to specify two formulas: <code>formula</code> describes the regression model,
while <code>formula.p</code> identifies the 'basis' <code class="reqn">b(p)</code>.
By default, <code>formula.p = ~ slp(p, k = 3)</code>, a 3rd-degree shifted
Legendre polynomial (see <code><a href="qrcm.html#topic+slp">slp</a></code>). Any user-defined function <code class="reqn">b(p, \ldots)</code>
can be used, see &lsquo;Examples&rsquo;.
</p>
<p>Estimation of penalized <code class="reqn">\theta</code> is carried out by minimizing a penalized integrated loss function,
corresponding to the integral, over <code class="reqn">p</code>, of the penalized loss function of standard quantile regression. This
motivates the acronym <code>piqr</code> (penalized integrated quantile regression).
</p>
<p>See details in <code><a href="qrcm.html#topic+iqr">iqr</a></code>
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>piqr</code>&rdquo;, a list containing the following items:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list of estimated model parameters describing the fitted quantile function along the path.</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>the value of the minimized integrated loss function for each value of lambda.</p>
</td></tr>
<tr><td><code>dl</code></td>
<td>
<p>a matrix of gradient values along the path.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td></tr>
<tr><td><code>seqS</code></td>
<td>
<p>a list containg each matrix s for each value of lambda.</p>
</td></tr>
<tr><td><code>internal</code></td>
<td>
<p>a list containing some initial object.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>By expressing quantile regression coefficients as functions of <code class="reqn">p</code>, a parametric model for the conditional
quantile function is specified. The induced <abbr><span class="acronym">PDF</span></abbr> and <abbr><span class="acronym">CDF</span></abbr> can be used as diagnostic tools.
Negative values of <code>PDF</code> indicate quantile crossing, i.e., the conditional quantile function is not
monotonically increasing. Null values of <code>PDF</code> indicate observations that lie outside the
estimated support of the data, defined by quantiles of order 0 and 1. If null or negative <code>PDF</code>
values occur for a relatively large proportion of data, the model is probably misspecified or ill-defined.
If the model is correct, the fitted <code>CDF</code> should approximately follow a Uniform(0,1) distribution.
This idea is used to implement a goodness-of-fit test, see <code><a href="qrcm.html#topic+summary.iqr">summary.iqr</a></code>
and <code><a href="qrcm.html#topic+test.fit">test.fit</a></code>.
</p>
<p>The intercept can be excluded from <code>formula</code>, e.g.,
<code>iqr(y ~ -1 + x)</code>. This, however, implies that when <code>x = 0</code>,
<code>y</code> is always <code>0</code>. See example 5 in &lsquo;Examples&rsquo;.
The intercept can also be removed from <code>formula.p</code>.
This is recommended if the data are bounded. For example, for strictly positive data,
use <code>iqr(y ~ 1, formula.p = -1 + slp(p,3))</code> to force the smallest quantile
to be zero. See example 6 in &lsquo;Examples&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Sottile G, Frumento P, Chiodi M, Bottai M. (2020). <em>A penalized approach to covariate selection through quantile regression coefficient models</em>. Statistical Modelling, 20(4), pp 369-385. doi:10.1177/1471082X19825523.
</p>
<p>Frumento, P., and Bottai, M. (2016). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, 72(1), pp 74-84, doi:10.1111/biom.12410.
</p>
<p>Friedman, J., Hastie, T. and Tibshirani, R. (2008). <em>Regularization Paths for Generalized Linear Models via Coordinate Descent</em>. Journal of Statistical Software, Vol. 33(1), pp 1-22 Feb 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.piqr">summary.piqr</a></code>, <code><a href="#topic+plot.piqr">plot.piqr</a></code>, <code><a href="#topic+predict.piqr">predict.piqr</a></code>,
for summary, plotting, and prediction.
<code><a href="#topic+gof.piqr">gof.piqr</a></code> to select the best value of the tuning parameter though AIC, BIC, GIC, GCV criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ##### Using simulated data in all examples

  ##### Example 1
  set.seed(1234)
  n &lt;- 300
  x1 &lt;- rexp(n)
  x2 &lt;- runif(n, 0, 5)
  x &lt;- cbind(x1,x2)

  b &lt;- function(p){matrix(cbind(1, qnorm(p), slp(p, 2)), nrow=4, byrow=TRUE)}
  theta &lt;- matrix(0, nrow=3, ncol=4); theta[, 1] &lt;- 1; theta[1,2] &lt;- 1; theta[2:3,3] &lt;- 2
  qy &lt;- function(p, theta, b, x){rowSums(x * t(theta %*% b(p)))}

  y &lt;- qy(runif(n), theta, b, cbind(1, x))

  s &lt;- matrix(1, nrow=3, ncol=4); s[1,3:4] &lt;- 0; s[2:3, 2] &lt;- 0
  obj &lt;- piqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + slp(p, 2), s=s, nlambda=50)

  best &lt;- gof.piqr(obj, method="AIC", plot=FALSE)
  best2 &lt;- gof.piqr(obj, method="BIC", plot=FALSE)

  summary(obj, best$posMinLambda)
  summary(obj, best2$posMinLambda)

  ## Not run: 
  ##### other examples
  set.seed(1234)
  n &lt;- 1000
  q &lt;- 5
  k &lt;- 3
  X &lt;- matrix(abs(rnorm(n*q)), n, q)
  rownames(X) &lt;- 1:n
  colnames(X) &lt;- paste0("X", 1:q)
  theta &lt;- matrix(c(3, 1.5, 1, 1,
                    2, 1, 1, 1,
                    0, 0, 0, 0,
                    0, 0, 0, 0,
                    1.5, 1, 1, 1,
                    0, 0, 0, 0),
                  ncol=(k+1), byrow=TRUE)
  rownames(theta) &lt;- c("(intercept)", paste0("X", 1:q))
  colnames(theta) &lt;- c("(intercept)", "slp(p,1)", "slp(p,2)", "slp(p,3)")
  B &lt;- function(p, k){matrix(cbind(1, slp(p, k)), nrow=(k+1), byrow=TRUE)}
  Q &lt;- function(p, theta, B, k, X){rowSums(X * t(theta %*% B(p, k)))}

  pp &lt;- runif(n)
  y &lt;- Q(p=pp, theta=theta, B=B, k=k, X=cbind(1, X))
  m1 &lt;- piqr(y ~ X, formula.p = ~ slp(p, k))
  best1 &lt;- gof.piqr(m1, method="AIC", plot=FALSE)
  best2 &lt;- gof.piqr(m1, method="BIC", plot=FALSE)
  summary(m1, best1$posMinLambda)
  summary(m1, best2$posMinLambda)
  par(mfrow = c(1,3)); plot(m1, xvar="lambda");
                       plot(m1, xvar="objective"); plot(m1, xvar="grad")

  set.seed(1234)
  n &lt;- 1000
  q &lt;- 6
  k &lt;- 4
  # x &lt;- runif(n)
  X &lt;- matrix(abs(rnorm(n*q)), n, q)
  rownames(X) &lt;- 1:n
  colnames(X) &lt;- paste0("X", 1:q)
  theta &lt;- matrix(c(1, 2, 0, 0, 0,
                    2, 0, 1, 0, 0,
                    0, 0, 0, 0, 0,
                    1, 0, 0, 1, -1.2,
                    0, 0, 0, 0, 0,
                    1.5, 0, .5, 0, 0,
                    0, 0, 0, 0, 0),
                  ncol=(k+1), byrow=TRUE)
  rownames(theta) &lt;- c("(intercept)", paste0("X", 1:q))
  colnames(theta) &lt;- c("(intercept)", "qnorm(p)", "p", "log(p)", "log(1-p)")
  B &lt;- function(p, k){matrix(cbind(1, qnorm(p), p, log(p), log(1-p)), nrow=(k+1), byrow=TRUE)}
  Q &lt;- function(p, theta, B, k, X){rowSums(X * t(theta %*% B(p, k)))}

  pp &lt;- runif(n)
  y &lt;- Q(p=pp, theta=theta, B=B, k=k, X=cbind(1, X))
  s &lt;- matrix(1, q+1, k+1); s[2:(q+1), 2] &lt;- 0; s[1, 3:(k+1)] &lt;- 0; s[2:3, 4:5] &lt;- 0
  s[4:5, 3] &lt;- 0; s[6:7, 4:5] &lt;- 0
  m2 &lt;- piqr(y ~ X, formula.p = ~ qnorm(p) + p + I(log(p)) + I(log(1-p)), s=s)
  best1 &lt;- gof.piqr(m2, method="AIC", plot=FALSE)
  best2 &lt;- gof.piqr(m2, method="BIC", plot=FALSE)
  summary(m2, best1$posMinLambda)
  summary(m2, best2$posMinLambda)
  par(mfrow = c(1,3)); plot(m2, xvar="lambda");
                       plot(m2, xvar="objective"); plot(m2, xvar="grad")
  
## End(Not run)
  # see the documentation for 'summary.piqr', and 'plot.piqr'
</code></pre>

<hr>
<h2 id='plot.niqr'>
Plot Nonlinear Quantile Regression Coefficients
</h2><span id='topic+plot.niqr'></span>

<h3>Description</h3>

<p>Plots quantile regression coefficients <code class="reqn">\beta(\theta, p)</code> as a function of p, based on a fitted model
of class &ldquo;<code>niqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'niqr'
plot(x, conf.int=TRUE, which=NULL, ask=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.niqr_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;<code>niqr</code>&rdquo;, typically the result of a call to <code><a href="#topic+niqr">niqr</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.niqr_+3A_conf.int">conf.int</code></td>
<td>

<p>logical. If TRUE, asymptotic 95% confidence intervals are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.niqr_+3A_which">which</code></td>
<td>

<p>an optional numerical vector indicating which coefficient(s) to plot. If which = NULL,
all coefficients are plotted.
</p>
</td></tr>
<tr><td><code id="plot.niqr_+3A_ask">ask</code></td>
<td>

<p>logical. If which = NULL and ask = TRUE (the default), you will be asked interactively
which coefficients to plot.
</p>
</td></tr>
<tr><td><code id="plot.niqr_+3A_...">...</code></td>
<td>

<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd</kbd>.
See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.ot">gianluca.sottile@unipa.ot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niqr">niqr</a></code> for model fitting; <code><a href="#topic+testfit.niqr">testfit.niqr</a></code> for goodness of fit test; <code><a href="#topic+summary.niqr">summary.niqr</a></code> and <code><a href="#topic+predict.niqr">predict.niqr</a></code> for model summary and prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data

n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(0, 4), X=cbind(1, x), y=y)

plot(model, ask=FALSE)

</code></pre>

<hr>
<h2 id='plot.piqr'>
Plot Penalized Quantile Regression Coefficients
</h2><span id='topic+plot.piqr'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the quantile
regression coefficient paths for a fitted model of
class &ldquo;<code>piqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piqr'
plot(x, xvar=c("lambda", "objective", "grad", "beta"), pos.lambda,
                    label=FALSE, which=NULL, ask=TRUE, polygon=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.piqr_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;<code>piqr</code>&rdquo;, typically the result of a call to <code><a href="#topic+piqr">piqr</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_xvar">xvar</code></td>
<td>

<p>What is on the X-axis. &quot;lambda&quot; against the log-lambda sequence, &quot;objective&quot; against the value
of the minimized integrated loss function and &quot;grad&quot; the log-lambda sequence
against the gradient.
xvar = &quot;beta&quot; needs a lambda value to plot quantile regression coefficients
<code class="reqn">\beta(p | \theta(\lambda))</code> as a function of p, based on the fitted model of class &ldquo;<code>piqr</code>&rdquo;
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_pos.lambda">pos.lambda</code></td>
<td>

<p>the position of a lambda in the sequence of the object of class &ldquo;<code>piqr</code>&rdquo;. Could be the best
after selecting the result of a call to <code><a href="#topic+gof.piqr">gof.piqr</a></code>
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_label">label</code></td>
<td>

<p>If TRUE, label the curves with variable sequence numbers.
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_which">which</code></td>
<td>

<p>an optional numerical vector indicating which coefficient(s) to plot. If which = NULL, all coefficients are     plotted.
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_ask">ask</code></td>
<td>

<p>logical. If which = NULL and ask = TRUE (the default), you will be asked interactively which coefficients to plot.
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_polygon">polygon</code></td>
<td>

<p>ogical. If TRUE, confidence intervals are represented by shaded areas via polygon. Otherwise, dashed lines are used.
</p>
</td></tr>
<tr><td><code id="plot.piqr_+3A_...">...</code></td>
<td>

<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd</kbd>.
See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.ot">gianluca.sottile@unipa.ot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piqr">piqr</a></code> for model fitting; <code><a href="#topic+gof.piqr">gof.piqr</a></code> for the model selection criteria; <code><a href="#topic+summary.piqr">summary.piqr</a></code> and <code><a href="#topic+predict.piqr">predict.piqr</a></code> for model summary and prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data

  n &lt;- 300
  x &lt;- runif(n)
  qy &lt;- function(p,x){p^2 + x*log(p)}
  # true quantile function: Q(p | x) = beta0(p) + beta1(p)*x, with
     # beta0(p) = p^2
     # beta1(p) = log(p)
  y &lt;- qy(runif(n), x) # to generate y, plug uniform p in qy(p,x)

  obj &lt;- piqr(y ~ x, formula.p = ~ slp(p,3), nlambda=50)
  best &lt;- gof.piqr(obj, method="BIC", plot=FALSE)
  par(mfrow = c(1,3))
  plot(obj, xvar="lambda")
  plot(obj, xvar="objective")
  plot(obj, xvar="grad")
  par(mfrow=c(1,2));plot(obj, xvar="beta", pos.lambda=best$posMinLambda, ask=FALSE)
  # flexible fit with shifted Legendre polynomials
</code></pre>

<hr>
<h2 id='predict.niqr'>
Prediction After Nonlinear Quantile Regression Coefficients Modeling
</h2><span id='topic+predict.niqr'></span>

<h3>Description</h3>

<p>Predictions from an object of class &ldquo;<code>niqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'niqr'
predict(object, type=c("beta", "CDF", "QF", "sim"), newdata, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.niqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>niqr</code>&rdquo;, the result of a call to <code><a href="#topic+niqr">niqr</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.niqr_+3A_type">type</code></td>
<td>

<p>a character string specifying the type of prediction. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="predict.niqr_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict.
If omitted, the data are used. For <kbd>type = "CDF"</kbd>, it must include the response variable.
Ignored if <kbd>type = "beta"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.niqr_+3A_p">p</code></td>
<td>

<p>a numeric vector indicating the order(s) of the quantile to predict. Only used if
<kbd>type = "beta"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.niqr_+3A_...">...</code></td>
<td>

<p>for future methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different type of prediction from the model.
</p>


<h3>Note</h3>

<p>Prediction may generate quantile crossing
if the support of the new covariates values supplied in <code>newdata</code>
is different from that of the observed data.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niqr">niqr</a></code>, for model fitting; <code><a href="#topic+testfit.niqr">testfit.niqr</a></code>, to do goodness of fit test; <code><a href="#topic+summary.niqr">summary.niqr</a></code> and <code><a href="#topic+plot.niqr">plot.niqr</a></code>, for summarizing and plotting <code>niqr</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(0, 4), X=cbind(1,x), y=y)

# predict beta(0.25), beta(0.5), beta(0.75)
predict(model, type = "beta", p = c(0.25,0.5, 0.75))

# predict the CDF and the PDF at new values of x and y
predict(model, type = "CDF",
        newdata = data.frame(X1=runif(3), y = c(1,2,3)))

# computes the quantile function at new x, for p = (0.25,0.5,0.75)
predict(model, type = "QF", p = c(0.25,0.5,0.75),
        newdata = data.frame(X1=runif(3), y = c(1,2,3)))

# simulate data from the fitted model
ysim &lt;- predict(model, type = "sim") # 'newdata' can be supplied

# if the model is correct, the distribution of y and that of ysim should be similar
qy &lt;- quantile(y, prob = seq(.1,.9,.1))
qsim &lt;- quantile(ysim, prob = seq(.1,.9,.1))
plot(qy, qsim); abline(0,1)
</code></pre>

<hr>
<h2 id='predict.piqr'>
Prediction After Penalized Quantile Regression Coefficients Modeling
</h2><span id='topic+predict.piqr'></span>

<h3>Description</h3>

<p>Predictions from an object of class &ldquo;<code>piqr</code>&rdquo;, after selecting the best tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piqr'
predict(object, pos.lambda, type=c("beta", "CDF", "QF", "sim"), newdata,
                       p, se=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.piqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>piqr</code>&rdquo;, the result of a call to <code><a href="#topic+piqr">piqr</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_pos.lambda">pos.lambda</code></td>
<td>

<p>the positiion of a lambda in the sequence of the object of class &ldquo;<code>piqr</code>&rdquo;. Could be the best
after selecting the result of a call to <code><a href="#topic+gof.piqr">gof.piqr</a></code>
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_type">type</code></td>
<td>

<p>a character string specifying the type of prediction. See &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_newdata">newdata</code></td>
<td>

<p>an optional data frame in which to look for variables with which to predict.
If omitted, the data are used. For <kbd>type = "CDF"</kbd>, it must include the response variable.
Ignored if <kbd>type = "beta"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_p">p</code></td>
<td>

<p>a numeric vector indicating the order(s) of the quantile to predict. Only used if
<kbd>type = "beta"</kbd> or <kbd>type = "QF"</kbd>.
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_se">se</code></td>
<td>

<p>logical. If TRUE (the default), standard errors of the prediction will be computed. Only used if type = &quot;beta&quot; or   type = &quot;QF&quot;.
</p>
</td></tr>
<tr><td><code id="predict.piqr_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the best lambda or one value of lambda is chosen, the function call <code><a href="qrcm.html#topic+predict.iqr">predict.iqr</a></code>.
</p>


<h3>Value</h3>

<p>See details in <code><a href="qrcm.html#topic+predict.iqr">predict.iqr</a></code>
</p>


<h3>Note</h3>

<p>Prediction may generate quantile crossing
if the support of the new covariates values supplied in <code>newdata</code>
is different from that of the observed data.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piqr">piqr</a></code>, for model fitting; <code><a href="#topic+gof.piqr">gof.piqr</a></code>, to find the best lambda value; <code><a href="#topic+summary.piqr">summary.piqr</a></code> and <code><a href="#topic+plot.piqr">plot.piqr</a></code>, for summarizing and plotting <code>piqr</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

set.seed(1234)
n &lt;- 300
x1 &lt;- rexp(n)
x2 &lt;- runif(n, 0, 5)
x &lt;- cbind(x1,x2)

b &lt;- function(p){matrix(cbind(1, qnorm(p), slp(p, 2)), nrow=4, byrow=TRUE)}
theta &lt;- matrix(0, nrow=3, ncol=4); theta[, 1] &lt;- 1; theta[1,2] &lt;- 1; theta[2:3,3] &lt;- 2
qy &lt;- function(p, theta, b, x){rowSums(x * t(theta %*% b(p)))}

y &lt;- qy(runif(n), theta, b, cbind(1, x))

s &lt;- matrix(1, nrow=3, ncol=4); s[1,3:4] &lt;- 0
obj &lt;- piqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + slp(p, 2), s=s, nlambda=50)

best &lt;- gof.piqr(obj, method="AIC", plot=FALSE)

# predict beta(0.25), beta(0.5), beta(0.75)
predict(obj, best$posMinLambda, type = "beta", p = c(0.25,0.5, 0.75))

# predict the CDF and the PDF at new values of x and y
predict(obj, best$posMinLambda, type = "CDF",
        newdata = data.frame(x1=rexp(3), x2=runif(3), y = c(1,2,3)))

# computes the quantile function at new x, for p = (0.25,0.5,0.75)
predict(obj, best$posMinLambda, type = "QF", p = c(0.25,0.5,0.75),
        newdata = data.frame(x1=rexp(3), x2=runif(3), y = c(1,2,3)))

# simulate data from the fitted model
ysim &lt;- predict(obj, best$posMinLambda, type = "sim") # 'newdata' can be supplied

# if the model is correct, the distribution of y and that of ysim should be similar
qy &lt;- quantile(y, prob = seq(.1,.9,.1))
qsim &lt;- quantile(ysim, prob = seq(.1,.9,.1))
plot(qy, qsim); abline(0,1)
</code></pre>

<hr>
<h2 id='summary.niqr'>
Summary After Nonlinear Quantile Regression Coefficients Modeling
</h2><span id='topic+summary.niqr'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>niqr</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'niqr'
summary(object, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.niqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>niqr</code>&rdquo;, the result of a call to <code><a href="#topic+niqr">niqr</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.niqr_+3A_p">p</code></td>
<td>

<p>an optional vector of quantiles.
</p>
</td></tr>
<tr><td><code id="summary.niqr_+3A_...">...</code></td>
<td>

<p>for future methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary of the model is printed.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niqr">niqr</a></code>, for model fitting; <code><a href="#topic+testfit.niqr">testfit.niqr</a></code>, for goodness of fit test; <code><a href="#topic+predict.niqr">predict.niqr</a></code> and <code><a href="#topic+plot.niqr">plot.niqr</a></code>, for predicting and plotting objects of class &ldquo;<code>niqr</code>&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(0, 4), X=cbind(1,x), y=y)

summary(model)
summary(model, p=c(.01,.05))
</code></pre>

<hr>
<h2 id='summary.piqr'>
Summary After Penalized Quantile Regression Coefficients Modeling
</h2><span id='topic+summary.piqr'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>piqr</code>&rdquo;, after selecting the best tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'piqr'
summary(object, pos.lambda, SE=FALSE, p, cov=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.piqr_+3A_object">object</code></td>
<td>

<p>an object of class &ldquo;<code>piqr</code>&rdquo;, the result of a call to <code><a href="#topic+piqr">piqr</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.piqr_+3A_pos.lambda">pos.lambda</code></td>
<td>

<p>the position of a lambda in the sequence of the object of class &ldquo;<code>piqr</code>&rdquo;. Could be the best
after selecting the result of a call to <code><a href="#topic+gof.piqr">gof.piqr</a></code>
</p>
</td></tr>
<tr><td><code id="summary.piqr_+3A_se">SE</code></td>
<td>

<p>if TRUE standard errors are printed. Standard errors are computed through sandwich formula only for the             regularized parameters.
</p>
</td></tr>
<tr><td><code id="summary.piqr_+3A_p">p</code></td>
<td>

<p>an optional vector of quantiles.
</p>
</td></tr>
<tr><td><code id="summary.piqr_+3A_cov">cov</code></td>
<td>

<p>ff TRUE, the covariance matrix of <code class="reqn">\beta(p)</code> is reported. Ignored if p is missing.
</p>
</td></tr>
<tr><td><code id="summary.piqr_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the best lambda or one value of lambda is chosen a summary of the selected model is printed.
</p>


<h3>Value</h3>

<p>See details in <code><a href="qrcm.html#topic+summary.iqr">summary.iqr</a></code>
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piqr">piqr</a></code>, for model fitting; <code><a href="#topic+gof.piqr">gof.piqr</a></code>, to find the best lambda value; <code><a href="#topic+predict.piqr">predict.piqr</a></code> and <code><a href="#topic+plot.piqr">plot.piqr</a></code>, for predicting and plotting objects of class &ldquo;<code>piqr</code>&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

set.seed(1234)
n &lt;- 300
x1 &lt;- rexp(n)
x2 &lt;- runif(n, 0, 5)
x &lt;- cbind(x1,x2)

b &lt;- function(p){matrix(cbind(1, qnorm(p), slp(p, 2)), nrow=4, byrow=TRUE)}
theta &lt;- matrix(0, nrow=3, ncol=4); theta[, 1] &lt;- 1; theta[1,2] &lt;- 1; theta[2:3,3] &lt;- 2
qy &lt;- function(p, theta, b, x){rowSums(x * t(theta %*% b(p)))}

y &lt;- qy(runif(n), theta, b, cbind(1, x))

s &lt;- matrix(1, nrow=3, ncol=4); s[1,3:4] &lt;- 0
obj &lt;- piqr(y ~ x1 + x2, formula.p = ~ I(qnorm(p)) + slp(p, 2), s=s, nlambda=50)

best &lt;- gof.piqr(obj, method="AIC", plot=FALSE)
best2 &lt;- gof.piqr(obj, method="BIC", plot=FALSE)

summary(obj, best$posMinLambda)
summary(obj, best2$posMinLambda)
</code></pre>

<hr>
<h2 id='testfit.niqr'>
Goodness-of-Fit Test
</h2><span id='topic+testfit.niqr'></span>

<h3>Description</h3>

<p>Goodness-of-fit test for a model
fitted with <code><a href="#topic+niqr">niqr</a></code>. The Kolmogorov-Smirnov statistic and the Cramer-Von Mises statistic
are computed. Their distribution under the null hypothesis is estimated
with Monte Carlo (see &lsquo;Details&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testfit.niqr(obj, R = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testfit.niqr_+3A_obj">obj</code></td>
<td>

<p>an object of class &ldquo;<code>niqr</code>&rdquo;.
</p>
</td></tr>
<tr><td><code id="testfit.niqr_+3A_r">R</code></td>
<td>

<p>number of Monte Carlo replications.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function permits assessing goodness of fit by testing the null hypothesis
that the <abbr><span class="acronym">CDF</span></abbr> values follow a <code class="reqn">U(0,1)</code> distribution, indicating that
the model is correctly specified.
Since the <abbr><span class="acronym">CDF</span></abbr> values depend on estimated parameters, the distribution of
the test statistic is not known. To evaluate it, the model is fitted on <kbd>R</kbd> simulated datasets
generated under the null hypothesis.
</p>


<h3>Value</h3>

<p>a matrix with columns <code>statistic</code> and <code>p.value</code>,
reporting the Kolmogorov-Smirnov and Cramer-Von Mises statistic and the associated
p-values evaluated with Monte Carlo.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Frumento, P., and Bottai, M. (2015). <em>Parametric modeling of quantile regression coefficient functions</em>.
Biometrics, doi: 10.1111/biom.12410.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 300
x &lt;- runif(n)
fun &lt;- function(theta, p){
  beta0 &lt;- theta[1] + exp(theta[2]*p)
  beta1 &lt;- theta[3] + theta[4]*p
  cbind(beta0, beta1)}
beta &lt;- fun(c(1,1,1,1), runif(n))
y &lt;- beta[, 1] + beta[, 2]*x
model &lt;- niqr(fun=fun, x0=rep(0, 4), X=cbind(1,x), y=y)
## Not run: testfit.niqr(model, R=100)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
