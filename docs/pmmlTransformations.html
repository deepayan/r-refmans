<!DOCTYPE html><html lang="en"><head><title>Help for package pmmlTransformations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pmmlTransformations}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pmmlTransformations-package'>
<p>Data Transformations for PMML output</p></a></li>
<li><a href='#DiscretizeXform'>
<p>Discretizes a continuous variable to a discrete one as indicated by interval mappings.</p>
This is in accordance to the PMML element:<br /> <b>Discretize</b></a></li>
<li><a href='#FunctionXform'><p>Add a function transformation to a WrapData object.</p></a></li>
<li><a href='#Initialize'>
<p>Initialize internal variables in a WrapData object</p></a></li>
<li><a href='#MapXform'>
<p>Implements a map between discrete values in accordance to the PMML element: <b>MapValues</b></p></a></li>
<li><a href='#MinMaxXform'>
<p>Normalizes continuous values in accordance to the PMML element: <b>NormContinuous</b></p></a></li>
<li><a href='#NormDiscreteXform'>
<p>Normalize discrete values in accordance to the PMML element:<br /> <b>NormDiscrete</b></p></a></li>
<li><a href='#RenameVar'>
<p>Renames a variable in the WrapData transform object</p></a></li>
<li><a href='#WrapData'>
<p>Wrap raw data in an R object</p></a></li>
<li><a href='#ZScoreXform'>
<p>Performs a z-score normalization on continuous values in accordance to the PMML element: <b>NormContinuous</b></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Transforms Input Data from a PMML Perspective</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Tridivesh Jena, Wen Ching Lin, Dmitriy Bolotov</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dmitriy Bolotov &lt;rpmmlsupport@softwareag.com&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown, pmml (&le; 1.5.7)</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for data to be transformed before using it to construct models. Builds structures to allow functions in the PMML package to
    output transformation details in addition to the model in the resulting PMML file. The Predictive Model Markup Language (PMML) is an XML-based language which provides a way for applications to define machine learning, statistical and data mining models and to share models between PMML compliant applications. More information about the PMML industry standard and the Data Mining Group can be found at <a href="http://www.dmg.org">http://www.dmg.org</a>. The generated PMML can be imported into any PMML consuming application, such as Zementis Predictive Analytics products, which integrate with web services, relational database systems and deploy natively on Hadoop in conjunction with Hive, Spark or Storm, as well as allow predictive analytics to be executed for IBM z Systems mainframe applications and real-time, streaming analytics platforms.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.softwareag.com/zementis">https://www.softwareag.com/zementis</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 2.1)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-11 19:39:14 UTC; dmitriy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-11 22:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='pmmlTransformations-package'>
Data Transformations for PMML output
</h2><span id='topic+pmmlTransformations-package'></span><span id='topic+pmmlTransformations'></span>

<h3>Description</h3>

<p><b>NOTE</b>: The functions in this package have been merged into the package <span class="pkg">pmml</span>, starting with <span class="pkg">pmml</span> 2.0.0. <span class="pkg">pmmlTransformations</span> still works with <span class="pkg">pmml</span> up to and including version 1.5.7, but will not receive any more updates. The examples throughout this package have (commented-out) calls to functions from <span class="pkg">pmml</span>; if using <span class="pkg">pmmlTransformations</span>, please use <span class="pkg">pmml</span> 1.5.7 or older.
</p>
<p>This package reads in raw data and allows the user to perform various transformations 
on the input data. The user can then use the derived data to construct models 
and output the model together with data transformations in the Predictive Model Markup
Language (PMML) format through the use of the <b>pmml</b> package. 
</p>
<p>PMML is an XML-based language which provides a way for applications to define machine learning, statistical and data mining models and to share models between PMML compliant applications. More information about the PMML industry standard and the Data Mining Group can be found at &lt;http://www.dmg.org&gt;. The generated PMML can be imported into any PMML consuming application, such as Zementis Predictive Analytics products, which integrate with web services, relational database systems and deploy natively on Hadoop in conjunction with Hive, Spark or Storm, as well as allow predictive analytics to be executed for IBM z Systems mainframe applications and real-time, streaming analytics platforms.
</p>


<h3>Details</h3>

<p>The general methodology to use this package is to first wrap the data with the <b>WrapData</b> function 
and then perform all desired transformations. The model, in PMML format, including the information 
on the transformations executed, can then be output by calling the <b>pmml</b> function of the pmml package. 
The <b>pmml</b> function in this case has to be given an additional parameter, <b>transform</b>, as shown in the 
example below.
</p>
<p>This package can also be used as a transformation generator; output just the transformations information
instead of the whole pmml model. To do so, one has to call the pmml function with the WrapData output but
pass in a null value as the model name. An example can be seen in the documentation for the <b>WrapData</b> function.
</p>
<p>This package does not support boolean dataTypes; only numeric and string data are supported.  
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.
</p>


<h3>References</h3>

<p><a href="http://www.dmg.org">PMML home page</a>
</p>
<p><a href="http://dmg.org/pmml/v4-3/Transformations.html">PMML page describing various possible data transformations</a>
</p>
<p>A. Guazzelli, W. Lin, T. Jena (2012), <em>PMML in Action: Unleashing the Power  
of Open Standards for Data Mining and Predictive Analytics</em>. CreativeSpace 
(Second Edition) - <a href="http://www.amazon.com/dp/1470003244">Available on Amazon.com</a>
</p>
<p>T. Jena, A. Guazzelli, W. Lin, M. Zeller (2013). The R pmmlTransformations Package. 
In <em>Proceedings of the 19th ACM SIGKDD Conference on Knowledge Discovery 
and Data Mining</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already available in the base R package
   data(iris)

# First create the wrapper object
   irisBox &lt;- WrapData(iris)

# Perform a simple z-transformation on the first variable of the dataset: 
# Sepal.Length. By default, the name of the transformed variable is 
# "derived_Sepal.Length". The information of the transformation is added 
# back to the wrapped data object.
   irisBox &lt;- ZScoreXform(irisBox,"1")

# Build a simple lm model 
   fit &lt;- lm(Sepal.Width ~ derived_Sepal.Length + Petal.Length, 
            data=irisBox$data)

# One may now output the model in PMML format using the command below.
# The PMML file will now include the data transformations as well as 
# the model. 
   # library(pmml)
   # fit_pmml &lt;- pmml(fit, transform=irisBox)
</code></pre>

<hr>
<h2 id='DiscretizeXform'>
Discretizes a continuous variable to a discrete one as indicated by interval mappings.
This is in accordance to the PMML element:<br /> <b>Discretize</b>
</h2><span id='topic+DiscretizeXform'></span>

<h3>Description</h3>

<p>Creates a discrete variable from a continuous one. The discrete variable value depends on which interval
the continuous variable value lies in. The mapping from intervals to discrete values can be given 
in an external table file referred to in the transform command or as a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscretizeXform(boxdata, xformInfo, table, defaultValue=NA, 
                mapMissingTo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DiscretizeXform_+3A_boxdata">boxdata</code></td>
<td>

<p>the wrapper object obtained by using the WrapData function on the raw data. 
</p>
</td></tr>
<tr><td><code id="DiscretizeXform_+3A_xforminfo">xformInfo</code></td>
<td>
<p>specification of details of the transformation. This may be a name of an external file 
or a list of data frames. Even if only 1 variable is to be transformed, the
information for that transform should be given as a list with 1 element.</p>
</td></tr>
<tr><td><code id="DiscretizeXform_+3A_table">table</code></td>
<td>
<p>name of external CSV file containing the map from input to output values.</p>
</td></tr>
<tr><td><code id="DiscretizeXform_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable 
does not lie in any of the defined intervals. If 'xformInfo' is a
list, this is a vector with each element corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="DiscretizeXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable is missing.
If 'xformInfo' is a list, this is a vector with each element corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="DiscretizeXform_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of intervals and the discrete value each interval is linked to, a discrete variable is defined 
with the value indicated by the interval where it lies in. If a continuous variable <b>InVar</b> of data type 
<b>InType</b> is to be converted to a variable <b>OutVar</b> of data type <b>OutType</b>, the transformation command 
is in the format:
</p>
<p>xformInfo = &quot;[InVar-&gt;OutVar][InType-&gt;OutType]&quot;, table=&quot;TableFileName&quot;, <br />
defaultValue=&quot;defVal&quot;, mapMissingTo=&quot;missingVal&quot;
</p>
<p>where <b>TableFileName</b> is the name of the CSV file containing the interval to discrete value map. 
The data types of the variables can be any of the ones defined in the PMML format including integer, 
double or string. <b>defVal</b> is the default value of the transformed variable and if any of the input
values are missing, <b>missingVal</b> is the value of the transformed variable.
</p>
<p>The arguments InType, OutType, defaultValue and mapMissingTo 
are optional. The CSV file containing the table should not have any row and column identifiers, and the 
values given must be in the same order as in the map command. If the data types of the variables are not 
given, the data types of the input variables are attempted to be determined from the <b>boxData</b> argument. 
If that is not possible, the data types are assumed to be string.
</p>
<p>Intervals are either given by the left or right limits, in which case the other limit is considered as 
infinite. It may also be given by both the left and right limits separated by the character &quot;:&quot;. An example 
of how intervals should be defined in the external file are:
</p>
<p>rightVal1),outVal1 <br /> 
rightVal2],outVal2 <br />
[leftVal1:rightVal3),outVal3 <br />
(leftVal2:rightVal4],outVal4 <br />
(leftVal,outVal5
</p>
<p>which, given an input value <b>inVal</b> and the output value to be calculated <b>out</b>, means that:
</p>
<p>if(inVal &lt;  rightVal1) out=outVal1 <br />
if(inVal &lt;= rightVal2) out=outVal2 <br />
if( (inVal &gt;= leftVal1) and (inVal &lt; rightVal3) ) out=outVal3 <br />
if( (inVal &gt;  leftVal2) and (inVal &lt;= rightVal4) ) out=outVal4 <br />
if(inVal &gt; leftVal) out=outVal5
</p>
<p>It is also possible to give the information about the transforms without an external file, using a list of data frames. 
Each data frame defines a discretization operation for 1 input variable. The first row of the data frame gives the 
original field name, the derived field name, the left interval, the left value, the right interval and the right value.
The second row gives the data type of the values as listed in the first row. The second row with
the data types of the fields is not required. If not given, all fields are assumed to be strings. In this input format,
the 'defaultValue' and 'mapMissingTo' parameters should be vectors. The first element of each vector will correspond
to the derived field defined in the 1st element of the 'xformInfo' list etc. Although somewhat more complicated, this
method is designed to not require any external features. Further, once the intial list is constructed, modifying it is 
a simple operation; making this a better method to use if the parameters of the transformation are to be modified frequently
and/or automatically. This is made more clear in the example below.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>,
<code><a href="pmml.html#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the pmmlTransformations package
    library(pmmlTransformations)
    library(pmml)
# First wrap the data
    irisBox &lt;- WrapData(iris)

## Not run: 
# We wish to convert the continuous variable "Sepal.Length" to a discrete
# variable "dsl". The intervals to be used for this transformation is 
# given in a file, "intervals.csv", whose content is, for example,:
#
#  5],val1
#  (5:6],22
#  (6,val2
#
# This will be used to create a discrete variable named "dsl" of dataType
# "string" such that:
#    if(Sepal.length &lt;= 5) then dsl = "val1"  
#    if((Sepal.Lenght &gt; 5) and (Sepal.Length &lt;= 6)) then dsl = "22"
#    if(Sepal.Length &gt; 6) then dsl = "val2" 
#
# Give "dsl" the value 0 if the input variable value is missing.
  irisBox &lt;- DiscretizeXform(irisBox,
              xformInfo="[Sepal.Length -&gt; dsl][double -&gt; string]", 
              table="intervals.csv",mapMissingTo="0")

## End(Not run)

# A different transformation using a list of data frames, of size 1:
  t &lt;- list()
  m &lt;- data.frame(rbind(
                  c("Petal.Length","dis_pl","leftInterval","leftValue",
                  "rightInterval","rightValue"),
                  c("double","integer","string","double","string",
                  "double"),
                  c("0)",0,"open",NA,"Open",0),
                  c(NA,1,"closed",0,"Open",1),
                  c(NA,2,"closed",1,"Open",2),
                  c(NA,3,"closed",2,"Open",3), 
                  c(NA,4,"closed",3,"Open",4),
                  c("[4",5,"closed",4,"Open",NA)))

# Give column names to make it look nice; not necessary!
  colnames(m) &lt;- c("Petal.Length","dis_pl","leftInterval","leftValue",
                  "rightInterval","rightValue")

# a textual representation of the data frame is:
#   Petal.Length  dis_pl leftInterval leftValue rightInterval rightValue
# 1 Petal.Length  dis_pl leftInterval leftValue rightInterval rightValue
# 2       double integer       string    double        string     double
# 3           0)       0         open      &lt;NA&gt;          Open          0
# 4         &lt;NA&gt;       1       closed         0          Open          1
# 5         &lt;NA&gt;       2       closed         1          Open          2
# 6         &lt;NA&gt;       3       closed         2          Open          3
# 7         &lt;NA&gt;       4       closed         3          Open          4
# 8           (4       5       closed         4          Open       &lt;NA&gt;
#
# This is a transformation that defines a derived field 'dis_pl' 
# which has the integer value '0' if the original field 
# 'Petal.Length' has a value less than 0. The derived field has a 
# value '1' if the input is greater than or equal to 0 and less 
# than 1. Note that the values of the 1st column after row 2 have 
# been deliberately given NA values in the middle. This is to 
# show that that column is meant for a textual representation of 
# the transformation as defined for the method involving external 
# files; however in this methodtheir values are not used.

# Add the data frame to a list. The default values and the missing
# values should be given as a vector, each element of the vector 
# corresponding to the element at the same index in the list. If 
# these values are not given as a vector, they will be used for the 
# first list element only.
  t[[1]] &lt;- m
  def &lt;- c(11)
  mis &lt;- c(22)
  irisBox&lt;-DiscretizeXform(irisBox,xformInfo=t,defaultValue=def,
                          mapMissingTo=mis)

# Make a simple model to see the effect.
  fit&lt;-lm(Petal.Width~.,irisBox$data[,-5])
  # pmml(fit,transforms=irisBox)
</code></pre>

<hr>
<h2 id='FunctionXform'>Add a function transformation to a WrapData object.</h2><span id='topic+FunctionXform'></span>

<h3>Description</h3>

<p>Add a function transformation to a WrapData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FunctionXform(boxdata, origFieldName, newFieldName = "newField",
  newFieldDataType = "numeric", formulaText, mapMissingTo = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FunctionXform_+3A_boxdata">boxdata</code></td>
<td>
<p>wrapper object obtained by using the WrapData function on raw data</p>
</td></tr>
<tr><td><code id="FunctionXform_+3A_origfieldname">origFieldName</code></td>
<td>
<p>string specifying name(s) of the original data field(s) being used in the transformation</p>
</td></tr>
<tr><td><code id="FunctionXform_+3A_newfieldname">newFieldName</code></td>
<td>
<p>name of the new field created by the transformation</p>
</td></tr>
<tr><td><code id="FunctionXform_+3A_newfielddatatype">newFieldDataType</code></td>
<td>
<p>data type of the new field created by the transformation</p>
</td></tr>
<tr><td><code id="FunctionXform_+3A_formulatext">formulaText</code></td>
<td>
<p>string expression specifying the transformation</p>
</td></tr>
<tr><td><code id="FunctionXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of any input variable is missing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the expression provided 
in formulaText for every row in the <code>boxdata$data</code> 
data frame. The <code>formulaText</code> argument must represent 
a valid R expression, and any functions used in 
<code>formulaText</code> must be defined in the current 
environment.
</p>
<p>The name of the new field is optional (a default name is provided), but an error 
will be thrown if attempting to create a field with a name that already exists in 
the WrapData object.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics. 
The <code>data</code> data frame will contain a new <code>newFieldName</code> column, and 
<code>fieldData</code> will contain a new <code>newFieldName</code> row.
</p>


<h3>Author(s)</h3>

<p>Dmitriy Bolotov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset
data(iris)

# Wrap the data
irisBox &lt;- WrapData(iris)

# Perform a transform on the Sepal.Length field: 
# the value is squared and then divided by 100
irisBox &lt;- FunctionXform(irisBox,origFieldName="Sepal.Length",
                         newFieldName="Sepal.Length.Transformed",
                         formulaText="(Sepal.Length^2)/100")

# Combine two fields to create another new feature:                      
irisBox &lt;- FunctionXform(irisBox,
                         origFieldName="Sepal.Width, Petal.Width",
                         newFieldName="Width.Sum",
                         formulaText="Sepal.Width + Sepal.Length")
                         
# Create linear model using the derived features
fit &lt;- lm(Petal.Length ~ 
         Sepal.Length.Transformed + Width.Sum, data=irisBox$data)

# Create pmml from the fit
# library(pmml)
# fit_pmml &lt;- pmml(fit, transform=irisBox)
</code></pre>

<hr>
<h2 id='Initialize'>
Initialize internal variables in a WrapData object
</h2><span id='topic+Initialize'></span>

<h3>Description</h3>

<p>Internal function used by other functions in the package. Used to initialize parameters 
in the wrapped data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Initialize(inbox)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Initialize_+3A_inbox">inbox</code></td>
<td>
<p> Object returned by the WrapData function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used ony by the other functions of this package. 
</p>


<h3>Value</h3>

<p>An R object containing information on the data to be transformed.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>
</p>

<hr>
<h2 id='MapXform'>
Implements a map between discrete values in accordance to the PMML element: <b>MapValues</b>
</h2><span id='topic+MapXform'></span>

<h3>Description</h3>

<p>Maps discrete values of an input variable to a discrete value of the transformed variable.
The map can be given in an external table file referred to in the transform command or as a
list of data frames; each data frame defining a map transform for one variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapXform(boxdata, xformInfo, table, 
        defaultValue=NA, mapMissingTo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MapXform_+3A_boxdata">boxdata</code></td>
<td>

<p>the wrapper object obtained by using the WrapData function on the raw data. 
</p>
</td></tr>
<tr><td><code id="MapXform_+3A_xforminfo">xformInfo</code></td>
<td>
<p>specification of details of the transformation. It can be a text giving the external
file name or a list of data frames. Even if only 1 variable is to be transformed, the 
information for that map should be given as a list with 1 element.</p>
</td></tr>
<tr><td><code id="MapXform_+3A_table">table</code></td>
<td>
<p>name of external CSV file containing the map from input to output values.</p>
</td></tr>
<tr><td><code id="MapXform_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>the default value to be given to the transformed variable. If 'xformInfo' is a
list, this is a vector with each element corresponding to the corresponding list element.</p>
</td></tr>
<tr><td><code id="MapXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable is missing.
If 'xformInfo' is a list, this is a vector with each element corresponding to the corresponding 
list element.</p>
</td></tr>
<tr><td><code id="MapXform_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a map from the combination of variables <b>InVar1</b>, <b>InVar2</b>, ... to the transformed variable 
<b>OutVar</b>, where the variables have the data types <b>InType1</b>, <b>InType2</b>, ... and <b>OutType</b>, the 
map command is in the format:
</p>
<p>xformInfo = &quot;[InVar1,InVar2,...-&gt;OutVar][InType1,InType2,...-&gt;OutType]&quot;,<br />
table=&quot;TableFileName&quot;, defaultValue=&quot;defVal&quot;, mapMissingTo=&quot;missingVal&quot;
</p>
<p>where <b>TableFileName</b> is the name of the CSV file containing the map. The map can be a N to 1 map where
N is greater or equal to 1. The data types of the variables can be any of the ones defined in the PMML 
format including integer, double or string. <b>defVal</b> is the default value of the transformed variable
and if any of the map input values are missing, <b>missingVal</b> is the value of the transformed variable. 
</p>
<p>The arguments InType, OutType, defaultValue and mapMissingTo 
are optional. The CSV file containing the table should not have any row and column identifiers, and the 
values given must be in the same order as in the map command. If the data types of the variables are not 
given, the data types of the input variables are attempted to be determined from the <b>boxData</b> argument. 
If that is not possible, the data type is assumed to be string.
</p>
<p>It is also possible to give the maps to be implemented without an external file using a list of data frames. Each
data frame defines a map for 1 input variable. Given a data frame with N+1 columns, it is assumed that the map is
a N to 1 map where the last column of the data frame corresponds to the derived field. The 1st row is assumed to be 
the names of the fields and the second row the data types of the fields. The rest of the rows define the map; each
combination of the input values in a row is mapped to the value in the last column of that row. The second row with
the data types of the fields is not required. If not given, all fields are assumed to be strings. In this input format,
the 'defaultValue' and 'mapMissingTo' parameters should be vectors. The first element of each vector will correspond 
to the derived field defined in the 1st element of the 'xformInfo' list etc. These are made clearer in the example below. 
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>,
<code><a href="pmml.html#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard audit dataset, part of the pmml package
   library(pmml)
   library(pmmlTransformations)
   data(audit)

# First wrap the data
   auditBox &lt;- WrapData(audit)

## Not run: 
# One of the variables, "Sex", has 2 possible values: "Male" 
# and "Female". If these string values have to be mapped to a 
# numeric value, a file has to becreated, say "MapGender.csv" 
# whose content is, for example:
#
#  Male,1
#  Female,2
#
# Transform the variable "Gender" to a variable "d_gender" 
# such that:
#    if Sex = "Male" then d_sex = "1"
#    if Sex = "Female" then d_sex = "0"
#
# Give "d_sex" the value 0 if the input variable value is 
# missing.
  auditBox &lt;- MapXform(auditBox,
                      xformInfo="[Sex -&gt; d_sex][string-&gt;integer]", 
	                    table="MapGender.csv",mapMissingTo="0")

## End(Not run)
# same as above, with an extra variable, but using data frames.
# The top 2 rows gives the variable names and their data types. 
# The rest represent the map. So for example, the third row 
# indicates that when the input variable "Sex" has the value 
# "Male" and the input variable "Employment" has
# the value "PSLocal", the output variable "d_sex" should have 
# the value 1. 
   t &lt;- list()
   m &lt;- data.frame(c("Sex","string","Male","Female"),
                  c("Employment","string","PSLocal","PSState"),
	c("d_sex","integer",1,0))
   t[[1]] &lt;- m

# give default value as a vector and missing value as a string,
# this is only possible as there is only one map defined. If 
# default values is not given, it will simply not be given in 
# the PMML file as well. In general, the default values and the 
# missing values should be given as a vector, each element of 
# the vector corresponding to the element at the same index in 
# the list. If these values are not given as a vector, they will 
# be used for the first list element only.
   auditBox&lt;-MapXform(auditBox,xformInfo=t,defaultValue=c(3),
                      mapMissingTo="2")

# check what the pmml looks like
  fit&lt;-lm(Adjusted~.,data=auditBox$data)
  # pmml(fit,transforms=auditBox)

</code></pre>

<hr>
<h2 id='MinMaxXform'>
Normalizes continuous values in accordance to the PMML element: <b>NormContinuous</b>
</h2><span id='topic+MinMaxXform'></span>

<h3>Description</h3>

<p>Given input data in a WrapData format, normalize the given data values to lie between provided limits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinMaxXform(boxdata, xformInfo=NA, mapMissingTo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinMaxXform_+3A_boxdata">boxdata</code></td>
<td>

<p>the wrapper object obtained by using the WrapData function on the raw data. 
</p>
</td></tr>
<tr><td><code id="MinMaxXform_+3A_xforminfo">xformInfo</code></td>
<td>

<p>specification of details of the transformation. 
</p>
</td></tr>
<tr><td><code id="MinMaxXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable is missing.</p>
</td></tr>
<tr><td><code id="MinMaxXform_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input variable named <b>InputVar</b>, the name of the transformed variable <b>OutputVar</b>, the 
desired minimum value the transformed variable may have <b>low_limit</b>, the desired maximum value 
the transformed variable may have <b>high_limit</b>, and the desired value of the transformed variable 
if the input variable value is missing <b>missingVal</b>, the <b>MinMaxXform</b> command including all the 
optional parameters is in the format:
</p>
<p>xformInfo=&quot;InputVar -&gt; OutputVar[low_limit,high_limit], mapMissingTo=&quot;missingVal&quot;
</p>
<p>There are two methods in which the variables can be referred to. The first method is to use its 
column number; given the <b>data</b> attribute of the <b>boxData</b> object, this would be the order at 
which the variable appears. This can be indicated in the format &quot;column#&quot;. The second method is to 
refer to the variable by its name.
</p>
<p>The name of the transformed variable is optional; if the name is not provided, the transformed 
variable is given the name: &quot;derived_&quot; + <em>original_variable_name</em> <br />
Similarly, the low and high limit values are optional; they have the default values of 0 and 1 
respectively. <b>missingValue</b> is an optional parameter as well. It is the value of the derived variable  
if the input value is missing.
</p>
<p>If no input variable names are provided, by default all numeric variables are transformed. Note 
that in this case a replacement value for missing input values cannot be specified; the same applies 
to the <b>low_limit</b> and <b>high_limit</b> parameters.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already available in R
   data(iris)
   library(pmmlTransformations)

# First wrap the data
   irisBox &lt;- WrapData(iris)

# Normalize all numeric variables of the loaded iris dataset to lie 
# between 0 and 1. These would normalize "Sepal.Length", "Sepal.Width", 
# "Petal.Length", "Petal.Width" to the 4 new derived variables named 
# derived_Sepal.Length, derived_Sepal.Width, derived_Petal.Length, 
# derived_Petal.Width.
   MinMaxXform(irisBox)

# Normalize the 1st column values of the dataset (Sepal.Length) to lie 
# between 0 and 1 and give the derived variable the name "dsl" 
   MinMaxXform(irisBox,xformInfo="column1 -&gt; dsl")

# Repeat the above operation; adding the new transformed variable to 
# the irisBox object
   irisBox &lt;- MinMaxXform(irisBox,xformInfo="column1 -&gt; dsl")

# Transform Sepal.Width(the 2nd column)
# The new transformed variable will be given the default name 
# "derived_Sepal.Width" 
   MinMaxXform(irisBox,xformInfo="column2")

# Repeat the same operation as above, this time using the variable name
   MinMaxXform(irisBox,xformInfo="Sepal.Width")

# Repeat the same operation as above, assign the transformed variable, 
# "derived_Sepal.Width". the value of 0.5 if the input value of the 
# "Sepal.Width" variable is missing 
   MinMaxXform(irisBox,xformInfo="Sepal.Width", "mapMissingTo=0.5")

# Transform Sepal.Width(the 2nd column) to lie between 2 and 3. 
# The new transformed variable will be given the default name 
# "derived_Sepal.Width"
   MinMaxXform(irisBox,xformInfo="column2-&gt;[2,3]")

# Repeat the above transformation, this time the transformed variable 
# lies between 0 and 10
   irisBox &lt;- MinMaxXform(irisBox,xformInfo="column2-&gt;[,10]")
</code></pre>

<hr>
<h2 id='NormDiscreteXform'>
Normalize discrete values in accordance to the PMML element:<br /> <b>NormDiscrete</b>
</h2><span id='topic+NormDiscreteXform'></span>

<h3>Description</h3>

<p>Define a new derived variable for each possible value of a categorical variable. Given a categorical 
variable <b>catVar</b> with possible discrete values <b>A</b> and <b>B</b>, this will create 2 
derived variables <b>catVar_A</b> and <b>catVar_B</b>. If, for example, the input value of <b>catVar</b>
is <b>A</b> then <b>catVar_A</b> equals 1 and 
<b>catVar_B</b> equals 0.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormDiscreteXform(boxdata, xformInfo=NA, 
                  inputVar=NA, mapMissingTo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormDiscreteXform_+3A_boxdata">boxdata</code></td>
<td>

<p>the wrapper object obtained by using the WrapData function on the raw data.
</p>
</td></tr>
<tr><td><code id="NormDiscreteXform_+3A_xforminfo">xformInfo</code></td>
<td>

<p>specification of details of the transformation: the name of the input variable to be transformed. 
</p>
</td></tr>
<tr><td><code id="NormDiscreteXform_+3A_inputvar">inputVar</code></td>
<td>

<p>the input variable name in the data on which the transformation is to be applied 
</p>
</td></tr>
<tr><td><code id="NormDiscreteXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable is missing.</p>
</td></tr>
<tr><td><code id="NormDiscreteXform_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input variable, <b>InputVar</b> and <b>missingVal</b>, the desired value of the transformed variable 
if the input variable value is missing, the NormDiscreteXform command including all 
optional parameters is in the format:
</p>
<p>xformInfo=&quot;inputVar=input_variable, mapMissingTo=missingVal&quot;
</p>
<p>There are two methods in which the input variable can be referred to. The first method is to use its
column number; given the <b>data</b> attribute of the <b>boxData</b> object, this would be the order at
which the variable appears. This can be indicated in the format &quot;column#&quot;. The second method is to refer 
to the variable by its name.
</p>
<p>The <b>xformInfo</b> and <b>inputVar</b> parameters provide the same information. While either one may be used
when using this function, at least one of them is required. If both parameters are given, the <b>inputVar</b>
parameter is used as the default. 
</p>
<p>The output of this transformation is a set of transformed variables, one for each possible value of 
the input variable. For example, given possible values of the input variable <b>val1</b>, <b>val2</b>, ... these 
transformed variables are by default named <b>InputVar_val1</b>, <b>InputVar_val2</b>, ...
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already available in R
   data(iris)

# First wrap the data
   irisBox &lt;- WrapData(iris)

# Discretize the "Species" variable. This will find all possible 
# values of the "Species" variable and define new variables. The 
# parameter name used here should be replaced by the new preferred 
# parameter name as shown in the next example below.
#
# 	"Species_setosa" such that it is 1 if 
#      "Species" equals "setosa", else 0;
# 	"Species_versicolor" such that it is 1 if 
#      "Species" equals "versicolor", else 0;
# 	"Species_virginica" such that it is 1 if 
#      "Species" equals "virginica", else 0

  irisBox &lt;- NormDiscreteXform(irisBox,inputVar="Species")
  
# Exact same operation performed with a different parameter name. 
# Use of this new parameter is the preferred method as the previous 
# parameter will be deprecated soon.

  irisBox &lt;- WrapData(iris)
  irisBox &lt;- NormDiscreteXform(irisBox,xformInfo="Species")
  
</code></pre>

<hr>
<h2 id='RenameVar'>
Renames a variable in the WrapData transform object 
</h2><span id='topic+RenameVar'></span>

<h3>Description</h3>

<p>Renames a variable inside a WrapData object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenameVar(boxdata, xformInfo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RenameVar_+3A_boxdata">boxdata</code></td>
<td>
<p>wrapper object obtained by using the WrapData function on the raw data.</p>
</td></tr>
<tr><td><code id="RenameVar_+3A_xforminfo">xformInfo</code></td>
<td>
<p>specification of details of the renaming.</p>
</td></tr>
<tr><td><code id="RenameVar_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once input data is wrapped by the <b>WrapData</b> function, it is somewhat involved to rename a variable
inside. This function makes it easier to do so.
Given an variable named <b>InputVar</b> and the name one wishes to rename it to, <b>OutputVar</b>, the 
rename command options are:
</p>
<p>xformInfo=&quot;InputVar -&gt; OutputVar&quot;
</p>
<p>There are two methods in which the variables can be referred to. The first method is to use its 
column number; given the <b>data</b> attribute of the <b>boxData</b> object, this would be the order at 
which the variable appears. This can be indicated in the format &quot;column#&quot;. The second method is to 
refer to the variable by its name. This method will work even if the renamed value already exists; in 
which case there will be two variables with the same name.
</p>
<p>If no input variable name is provided, the original object is returned with no renamings performed.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already built into R
   data(iris)

# First wrap the data
   irisBox &lt;- WrapData(iris)

# We wish to refer to the variables "Sepal.Length" and 
# "Sepal.Width" as "SL" and "SW"
  irisBox &lt;- RenameVar(irisBox,"column1-&gt;SL")
  irisBox &lt;- RenameVar(irisBox,"Sepal.Width-&gt;SW")

</code></pre>

<hr>
<h2 id='WrapData'>
Wrap raw data in an R object
</h2><span id='topic+WrapData'></span>

<h3>Description</h3>

<p>Wrap raw data read in a R object. This object is then read in by the transform
functions and the data in it is transformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapData(indata, useMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WrapData_+3A_indata">indata</code></td>
<td>
<p> the raw data set.</p>
</td></tr>
<tr><td><code id="WrapData_+3A_usematrix">useMatrix</code></td>
<td>
<p> boolean value indicating whether data should be stored in matrix format as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Object consists of the data itself and various properties for each data variable. Since the data is 
not always required to be in matrix format as well as a data frame, the 'useMatrix' value lets the 
user decide if the data should be stored in both formats, giving the user a choice in reducing the 
speed of the transformation operations and the memory required. If there is not
enough information about the data, they are given default values; the data is assumed to be the 
original data of data type string. The variable names are assumed to be <b>X1</b>, <b>X2</b>, ... 
This information is then used by the transformation functions to calculate the derived variable 
values. 
</p>


<h3>Value</h3>

<p>An R object containing information on the data to be transformed.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc. 
</p>


<h3>See Also</h3>

<p><code><a href="pmml.html#topic+pmml">pmml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already built into R
   data(iris)

# Make a wrapper object for the iris dataset to use with 
# transformation functions
   irisBox &lt;- WrapData(iris)

# Output only the transformations in PMML format. 
# This example will output just an empty "LocalTransformations" 
# element as no transformations were performed.
   # library(pmml)
   # pmml(NULL,transforms=irisBox)
# This will also work
   # pmml(,transforms=irisBox)
</code></pre>

<hr>
<h2 id='ZScoreXform'>
Performs a z-score normalization on continuous values in accordance to the PMML element: <b>NormContinuous</b>
</h2><span id='topic+ZScoreXform'></span>

<h3>Description</h3>

<p>Performs a z-score normalization on data given in WrapData format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZScoreXform(boxdata, xformInfo=NA, mapMissingTo=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZScoreXform_+3A_boxdata">boxdata</code></td>
<td>
<p>wrapper object obtained by using the WrapData function on the raw data.</p>
</td></tr>
<tr><td><code id="ZScoreXform_+3A_xforminfo">xformInfo</code></td>
<td>
<p>specification of details of the transformation.</p>
</td></tr>
<tr><td><code id="ZScoreXform_+3A_mapmissingto">mapMissingTo</code></td>
<td>
<p>value to be given to the transformed variable if the value of the input variable is missing.</p>
</td></tr> 
<tr><td><code id="ZScoreXform_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input variable named <b>InputVar</b>, the name of the transformed variable <b>OutputVar</b>, and the 
desired value of the transformed variable if the input variable value is missing <b>missingVal</b>,
the ZScoreXform command including all the optional parameters is:
</p>
<p>xformInfo=&quot;InputVar -&gt; OutputVar&quot;, mapMissingTo=&quot;missingVal&quot;
</p>
<p>There are two methods in which the variables can be referred to. The first method is to use its 
column number; given the <b>data</b> attribute of the <b>boxData</b> object, this would be the order at 
which the variable appears. This can be indicated in the format &quot;column#&quot;. The second method is to 
refer to the variable by its name. <br /> 
The name of the transformed variable is optional; if the name is not provided, the transformed 
variable is given the name: &quot;derived_&quot; + <em>original_variable_name</em>
</p>
<p><b>missingValue</b>, an optional parameter, is the value to be given to the output variable if the 
input variable value is missing. If no input variable names are provided, by default all numeric
variables are transformed. Note that in this case a replacement value for missing input values
cannot be specified.
</p>


<h3>Value</h3>

<p>R object containing the raw data, the transformed data and data statistics.
</p>


<h3>Author(s)</h3>

<p>Tridivesh Jena, Zementis, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapData">WrapData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the standard iris dataset, already built into R
   data(iris)

# First wrap the data
   irisBox &lt;- WrapData(iris)

# Perform a z-transform on all numeric variables of the loaded 
# iris dataset. These would be Sepal.Length, Sepal.Width, 
# Petal.Length, and Petal.Width. The 4 new derived variables 
# will be named derived_Sepal.Length, derived_Sepal.Width, 
# derived_Petal.Length, and derived_Petal.Width
   ZScoreXform(irisBox)

# Perform a z-transform on the 1st column of the dataset (Sepal.Length)
# and give the derived variable the name "dsl" 
   ZScoreXform(irisBox,xformInfo="column1 -&gt; dsl")

# Repeat the above operation; adding the new transformed variable 
# to the irisBox object
   irisBox &lt;- ZScoreXform(irisBox,xformInfo="column1 -&gt; dsl")

# Transform Sepal.Width(the 2nd column)
# The new transformed variable will be given the default name 
# "derived_Sepal.Width"
   ZScoreXform(irisBox,xformInfo="column2")

# Repeat the same operation as above, this time using the variable 
# name
   ZScoreXform(irisBox,xformInfo="Sepal.Width")

# Repeat the same operation as above, assign the transformed variable 
# "derived_Sepal.Width". The value of 1.0 if the input value of the 
# "Sepal.Width" variable is missing. Add the new information to the 
# irisBox object. 
   irisBox &lt;- ZScoreXform(irisBox,xformInfo="Sepal.Width",
                          "mapMissingTo=1.0")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
