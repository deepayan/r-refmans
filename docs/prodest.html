<!DOCTYPE html><html><head><title>Help for package prodest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prodest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#block.boot.resample'><p>Cluster Bootstrap Resampling</p></a></li>
<li><a href='#checkM'><p>Change input to matrix</p></a></li>
<li><a href='#checkMD'><p>Change dummy input to dummy matrix</p></a></li>
<li><a href='#chilean'><p>Data: Chilean firm-level production data 1986-1996</p></a></li>
<li><a href='#coef'><p>Print the estimated parameters</p></a></li>
<li><a href='#finalACF'><p>ACF estimation routine</p></a></li>
<li><a href='#finalOPLP'><p>OP and LP estimation routine</p></a></li>
<li><a href='#FSres'><p>Generate the vector of the first stage residuals</p></a></li>
<li><a href='#gACF'><p>ACF Second Stage - GMM estimation</p></a></li>
<li><a href='#gOPLP'><p>OP and LP Second Stage - GMM estimation</p></a></li>
<li><a href='#lagPanel'><p>Generate lagged input variables</p></a></li>
<li><a href='#omega'><p>Generate the omega estimates</p></a></li>
<li><a href='#panelSim'>
<p>Simulate Panel dataset</p></a></li>
<li><a href='#printProd'>
<p>Print output - prod objects</p></a></li>
<li><a href='#prod'><p>Class for Prodest Fitted object</p></a></li>
<li><a href='#prodestACF'>
<p>Estimate productivity - Ackerberg-Caves-Frazer correction</p></a></li>
<li><a href='#prodestLP'>
<p>Estimate productivity - Levinsohn-Petrin method</p></a></li>
<li><a href='#prodestOP'>
<p>Estimate productivity - Olley-Pakes method</p></a></li>
<li><a href='#prodestROB'>
<p>Estimate productivity - Robinson-Wooldridge method</p></a></li>
<li><a href='#prodestWRDG'>
<p>Estimate productivity - IV Wooldridge method</p></a></li>
<li><a href='#prodestWRDG_GMM'>
<p>Estimate productivity - Wooldridge method</p></a></li>
<li><a href='#show'><p>Print a table with parameter estimates</p></a></li>
<li><a href='#summary'><p>Print a table with a summary of results</p></a></li>
<li><a href='#weightM'><p>Generate optimal GMM weighting matrix</p></a></li>
<li><a href='#withinvar'><p>Generate the variance of the demeaned variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Production Function Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriele Rovigatti [aut,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriele Rovigatti &lt;gabriele.rovigatti@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the methods proposed by Olley, G.S. and Pakes, A. (1996) &lt;<a href="https://doi.org/10.2307%2F2171831">doi:10.2307/2171831</a>&gt;, Levinsohn, J. and Petrin, A. (2003) &lt;<a href="https://doi.org/10.1111%2F1467-937X.00246">doi:10.1111/1467-937X.00246</a>&gt;, Ackerberg, D.A. and Caves, K. and Frazer, G. (2015) &lt;<a href="https://doi.org/10.3982%2FECTA13408">doi:10.3982/ECTA13408</a>&gt; and Wooldridge, J.M. (2009) &lt;<a href="https://doi.org/10.1016%2Fj.econlet.2009.04.026">doi:10.1016/j.econlet.2009.04.026</a>&gt; for structural productivity estimation .</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GabrieleRovigatti/prodest/issues">https://github.com/GabrieleRovigatti/prodest/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GabrieleRovigatti/prodest/tree/master/prodest">https://github.com/GabrieleRovigatti/prodest/tree/master/prodest</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), dplyr, parallel, Matrix, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp, DEoptim, AER</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-19 13:10:04 UTC; gabriele</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-19 13:21:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='block.boot.resample'>Cluster Bootstrap Resampling</h2><span id='topic+block.boot.resample'></span>

<h3>Description</h3>

<p>Function to generate R vectors of resampled IDs. It works reshuffling the row number of the original data - which is stored in the input <code>idvar</code> along with the relative IDs. The output is a list (N_ix1xR), where N_i is a random number depending on the reshuffle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  block.boot.resample(idvar, R)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="block.boot.resample_+3A_idvar">idvar</code></td>
<td>

<p>Vector of IDs to be resampled.
</p>
</td></tr>

<tr><td><code id="block.boot.resample_+3A_r">R</code></td>
<td>

<p>Number of samples to be computed.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>block.boot.resample()</code> accepts two inputs: a vector of IDs - i.e., the vector of panel identifier - and the number of resamplings. For each resampling, it reshuffles the IDs and outputs a vector whose row number is newly-created 'bootstrap' ID, while the value of each cell is the relative row to be reshuffled. This way, each individual can be sampled multiple times, keeping all her number of observations, without generating duplicates.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='checkM'>Change input to matrix</h2><span id='topic+checkM'></span>

<h3>Description</h3>

<p>Function to transform all input to matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  checkM(input)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="checkM_+3A_input">input</code></td>
<td>

<p>An <code>R</code> object. Can be a matrix/dataframe/vector/scalar.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>checkM()</code> accepts one input and - if codeinput is a matrix - returns it without column names, otherwise transforms it into a matrix and returns it without column names.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='checkMD'>Change dummy input to dummy matrix</h2><span id='topic+checkMD'></span>

<h3>Description</h3>

<p>Function to transform all input to a matrix. In addition, it checks whether all elements of the input are either 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    checkMD(input)
  </code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="checkMD_+3A_input">input</code></td>
<td>

<p>An <code>R</code> object. Can be a matrix/dataframe/vector/scalar.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>checkMD()</code> accepts one input and - if codeinput is a matrix - returns it without column names, otherwise transforms it into a matrix and returns it without column names. In case any of the elements of input are different from 0 or 1, it stops the routine and throws an error.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='chilean'>Data: Chilean firm-level production data 1986-1996</h2><span id='topic+chilean'></span>

<h3>Description</h3>

<p>Sectoral subsample of Chilean firm-level production data 1986-1996.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("chilean")</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a> object containing 9 variables with production-related data.</p>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>

<p>vector of log(outcome) - Value added.</p>
</td></tr>

<tr><td><code>sX</code></td>
<td>

<p>vector of log(capital).</p>
</td></tr>

<tr><td><code>fX</code></td>
<td>

<p>matrix of log(skilled labor) and log(unskilled labor).</p>
</td></tr>

<tr><td><code>cX</code></td>
<td>

<p>vector of log(water).</p>
</td></tr>

<tr><td><code>pX</code></td>
<td>

<p>vector of log(electricity).</p>
</td></tr>

<tr><td><code>inv</code></td>
<td>

<p>vector of log(investment).</p>
</td></tr>

<tr><td><code>idvar</code></td>
<td>

<p>vector of panel identifier.</p>
</td></tr>

<tr><td><code>timevar</code></td>
<td>

<p>vector of time.</p>
</td></tr>

</table>


<h3>References</h3>

<p><a href="http://www.ine.cl/canales/chile_estadistico/estadisticas_economicas/industria/series_estadisticas/series_estadisticas_enia.php">http://www.ine.cl/canales/chile_estadistico/estadisticas_economicas/industria/series_estadisticas/series_estadisticas_enia.php</a>
</p>

<hr>
<h2 id='coef'>Print the estimated parameters</h2><span id='topic+coef+2Cprod-method'></span><span id='topic+coef'></span>

<h3>Description</h3>

<p>This method provides the way to extract and print the estimated parameters from a <a href="#topic+prod">prod</a> <code>S4</code> object - estimates from <a href="#topic+prodestOP">prodestOP</a>, <a href="#topic+prodestLP">prodestLP</a>, <a href="#topic+prodestACF">prodestACF</a>, <a href="#topic+prodestWRDG">prodestWRDG</a> and <a href="#topic+prodestWRDG_GMM">prodestWRDG_GMM</a> - defined in the <code>prodest</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coef(object,...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>

<p>object of class <a href="#topic+prod">prod</a>.
</p>
</td></tr>

<tr><td><code id="coef_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>coef</code> accepts an <code>S4</code> <a href="#topic+prod">prod</a> object and prints the vector of estimated parameters.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='finalACF'>ACF estimation routine</h2><span id='topic+finalACF'></span>

<h3>Description</h3>

<p><code>finalACF</code> is the function linking the data cleaning part of the routine with the final function to be bootstrapped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  finalACF(ind, data, fnum, snum, cnum, opt, theta0, boot = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="finalACF_+3A_ind">ind</code></td>
<td>

<p>Vector of indices to reshuffle the data.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_data">data</code></td>
<td>

<p><code>data.frame</code> with the data to perform the estimation on.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_fnum">fnum</code></td>
<td>

<p>Number of free variables.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_snum">snum</code></td>
<td>

<p>Number of state variables.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_cnum">cnum</code></td>
<td>

<p>Number of control variables.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_opt">opt</code></td>
<td>

<p>String with the optimizer.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_theta0">theta0</code></td>
<td>

<p>Vector of starting points.
</p>
</td></tr>

<tr><td><code id="finalACF_+3A_boot">boot</code></td>
<td>

<p>Binary indicator for the estimation routine being the baseline estimation (<code>boot = FALSE</code>, the default) or a bootstrap repetition.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>finalACF()</code> accepts at least 7 inputs: a vector of reshuffled indices, the <code>data.frame</code> with the data, the number of free, state and control variables, the starting points and the optimizer. It collects the results of <code>gACF()</code> function - baseline and bootstrapped - calculates the standard errors and stores all in a <code>prod</code> object.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='finalOPLP'>OP and LP estimation routine</h2><span id='topic+finalOPLP'></span>

<h3>Description</h3>

<p><code>finalOPLP</code> is the function linking the data cleaning part of the routine with the final function to be bootstrapped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  finalOPLP(ind, data, fnum, snum, cnum, opt, theta0, boot, tol, att)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="finalOPLP_+3A_ind">ind</code></td>
<td>

<p>Vector of indices to reshuffle the data.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_data">data</code></td>
<td>

<p><code>data.frame</code> with the data to perform the estimation on.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_fnum">fnum</code></td>
<td>

<p>Number of free variables.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_snum">snum</code></td>
<td>

<p>Number of state variables.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_cnum">cnum</code></td>
<td>

<p>Number of control variables.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_opt">opt</code></td>
<td>

<p>String with the optimizer.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_theta0">theta0</code></td>
<td>

<p>Vector of starting points.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_boot">boot</code></td>
<td>

<p>Binary indicator for the estimation routine being the baseline estimation or a bootstrap repetition.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_tol">tol</code></td>
<td>

<p>Optimization tolerance set.
</p>
</td></tr>

<tr><td><code id="finalOPLP_+3A_att">att</code></td>
<td>

<p>Indicator for attrition in the data - i.e., if  firms exit the market.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>finalOPLP()</code> accepts at 9 inputs: a vector of reshuffled indices, the <code>data.frame</code> with the data, the number of free, state and control variables, the starting points, the optimizer, an indicator for bootstrapped repetitions and the optimization tolerance. It collects the results of <code>gACF()</code> function - baseline and bootstrapped - calculates the standard errors and stores all in a <code>prod</code> object.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='FSres'>Generate the vector of the first stage residuals</h2><span id='topic+FSres+2Cprod-method'></span><span id='topic+FSres'></span>

<h3>Description</h3>

<p>This method provides the way to estimate the first stage residuals from a <a href="#topic+prod">prod</a> <code>S4</code> object - estimates from <a href="#topic+prodestOP">prodestOP</a>, <a href="#topic+prodestLP">prodestLP</a>, <a href="#topic+prodestACF">prodestACF</a>, <a href="#topic+prodestWRDG">prodestWRDG</a> and <a href="#topic+prodestWRDG_GMM">prodestWRDG_GMM</a> - defined in the <code>prodest</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  FSres(object)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="FSres_+3A_object">object</code></td>
<td>

<p>object of class <a href="#topic+prod">prod</a>.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>FSres</code> accepts an <code>S4</code> <a href="#topic+prod">prod</a> object and returns the vector of firs stage residuals.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='gACF'>ACF Second Stage - GMM estimation</h2><span id='topic+gACF'></span>

<h3>Description</h3>

<p><code>gACF</code> returns the second stage parameters estimates of ACF models. It is part of the <code>prodestACF()</code> routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    gACF(theta, mZ, mW, mX, mlX, vphi, vlag.phi)
  </code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="gACF_+3A_theta">theta</code></td>
<td>

<p>Vector of parameters to be estimated.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_mz">mZ</code></td>
<td>

<p>Matrix of instruments.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_mw">mW</code></td>
<td>

<p>Weighting matrix.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_mx">mX</code></td>
<td>

<p>Matrix of regressors.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_mlx">mlX</code></td>
<td>

<p>matrix of lagged regressors.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_vphi">vphi</code></td>
<td>

<p>Vector of fitted polynomial.
</p>
</td></tr>

<tr><td><code id="gACF_+3A_vlag.phi">vlag.phi</code></td>
<td>

<p>Lagged vector of fitted polynomial.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>gACF()</code> estimates the second stage of ACF routine. It accepts 7 inputs, generates and optimizes over the group of moment functions E(xi_itZ^k_it).
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='gOPLP'>OP and LP Second Stage - GMM estimation</h2><span id='topic+gOPLP'></span>

<h3>Description</h3>

<p><code>gOPLP</code> returns the second stage parameters estimates of both OP and LP models. It is part of both <code>prodestOP()</code> and <code>prodestsLP()</code> routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gOPLP(vtheta, mX, mlX, vphi, vlag.phi, vres, stol, Pr.hat, att)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="gOPLP_+3A_vtheta">vtheta</code></td>
<td>

<p>Vector of parameters to be estimated.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_mx">mX</code></td>
<td>

<p>Matrix of regressors.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_mlx">mlX</code></td>
<td>

<p>matrix of lagged regressors.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_vphi">vphi</code></td>
<td>

<p>Vector of fitted polynomial.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_vlag.phi">vlag.phi</code></td>
<td>

<p>Lagged vector of fitted polynomial.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_vres">vres</code></td>
<td>

<p>Vector of residuals of the free variables.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_stol">stol</code></td>
<td>

<p>Number setting the tolerance of the routine.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_pr.hat">Pr.hat</code></td>
<td>

<p>Vector of fitted exit probabilities.
</p>
</td></tr>

<tr><td><code id="gOPLP_+3A_att">att</code></td>
<td>

<p>Indicator for attrition in the data - i.e., if  firms exit the market.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>gOPLP()</code> estimates the second stage of OP and LP routines. It accepts 7 inputs, generates and optimizes over the group of moment functions E(e_itX^k_it).
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='lagPanel'>Generate lagged input variables</h2><span id='topic+lagPanel'></span>

<h3>Description</h3>

<p>Function to generate lagged variables in a panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    lagPanel(idvar, timevar, value)
  </code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="lagPanel_+3A_idvar">idvar</code></td>
<td>

<p>vector of panel identifiers.
</p>
</td></tr>

<tr><td><code id="lagPanel_+3A_timevar">timevar</code></td>
<td>

<p>vector of time identifiers.
</p>
</td></tr>

<tr><td><code id="lagPanel_+3A_value">value</code></td>
<td>

<p>variable vector to be lagged.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>lagPanel()</code> accepts three inputs (the ID, the time and the variable to be lagged) and returns the vector of lagged variable. Lagged inputs with no correspondence - i.e., X_-1 - are returned as NA.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='omega'>Generate the omega estimates</h2><span id='topic+omega+2Cprod-method'></span><span id='topic+omega'></span>

<h3>Description</h3>

<p>This method provides the way to estimate the omega residuals from a <a href="#topic+prod">prod</a> <code>S4</code> object - estimates from <a href="#topic+prodestOP">prodestOP</a>, <a href="#topic+prodestLP">prodestLP</a>, <a href="#topic+prodestACF">prodestACF</a>, <a href="#topic+prodestWRDG">prodestWRDG</a> and <a href="#topic+prodestWRDG_GMM">prodestWRDG_GMM</a> - defined in the <code>prodest</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  omega(object)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="omega_+3A_object">object</code></td>
<td>

<p>object of class <a href="#topic+prod">prod</a>.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>omega</code> accepts an <code>S4</code> <a href="#topic+prod">prod</a> object and returns a vector of omega estimates.
</p>


<h3>Value</h3>


<ul>
<li><p> A vector of productivity estimates - omega.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='panelSim'>
Simulate Panel dataset
</h2><span id='topic+panelSim'></span>

<h3>Description</h3>

<p><code>panelSim()</code> produces a N*T balanced panel dataset of firms' production. In particular, it returns a <code>data.frame</code> with free, state and proxy variables aimed at performing Monte Carlo simulations on productivity-related models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  panelSim(N = 1000, T = 100, alphaL = .6, alphaK = .4, DGP = 1,
           rho = .7, sigeps = .1, sigomg = .3, rholnw = .3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelSim_+3A_n">N</code></td>
<td>

<p>the number of firms. By default <code>N=1000</code></p>
</td></tr>

<tr><td><code id="panelSim_+3A_t">T</code></td>
<td>

<p>the total time span to be simulated. Only a fraction (the last 10% of observations) will be returned. By default <code>T=100</code></p>
</td></tr>

<tr><td><code id="panelSim_+3A_alphal">alphaL</code></td>
<td>

<p>the parameter of the free variable. By default <code>alphaL=.6</code></p>
</td></tr>

<tr><td><code id="panelSim_+3A_alphak">alphaK</code></td>
<td>

<p>the parameter of the state variable. By default <code>alphaK=.4</code></p>
</td></tr>

<tr><td><code id="panelSim_+3A_dgp">DGP</code></td>
<td>

<p>Type of DGP; accepts 1, 2 or 3. They differ in terms of shock to wages (0 or 0.1), <code class="reqn">\Delta</code> (0 or 0.5) and shock to labor (0 or 0.37). See <code class="reqn">details</code>. By default <code>DGP=1</code>.</p>
</td></tr>

<tr><td><code id="panelSim_+3A_rho">rho</code></td>
<td>

<p>the AR(1) coefficient for omega. By default <code>rho=0.7</code></p>
</td></tr>

<tr><td><code id="panelSim_+3A_sigeps">sigeps</code></td>
<td>

<p>the standard deviation of epsilon. See <code class="reqn">details</code>. By default <code>sigeps = .1</code>.</p>
</td></tr>

<tr><td><code id="panelSim_+3A_sigomg">sigomg</code></td>
<td>

<p>the standard deviation of the innovation to productivity <code class="reqn">\omega</code>. By default <code>sigomg = .3</code>.</p>
</td></tr>

<tr><td><code id="panelSim_+3A_rholnw">rholnw</code></td>
<td>

<p>AR(1) coefficient for log(wage). By default <code>rholnw=.3</code>.</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>panelSim()</code> is the R implementation of the DGP written by Ackerberg, Caves and Frazer (2015).
</p>


<h3>Value</h3>

<p><code class="reqn">panelSim()</code> returns a <code>data.frame</code> with 7 variables:
</p>

<ul>
<li><p><code class="reqn">idvar</code>
ID codes from 1 to N (by default <code class="reqn">N = 1000</code>).

</p>
</li>
<li><p><code class="reqn">timevar</code>
time variable ranging 1 to <code class="reqn">round(T*0.1)</code> (by default <code class="reqn">T = 100</code> and <code class="reqn">max(timevar) = 10</code>).

</p>
</li>
<li><p><code class="reqn">Y</code>
log output value added variable

</p>
</li>
<li><p><code class="reqn">sX</code>
log state variable

</p>
</li>
<li><p><code class="reqn">fX</code>
log free variable

</p>
</li>
<li><p><code class="reqn">pX1</code>
log proxy variable - no measurement error

</p>
</li>
<li><p><code class="reqn">pX2</code>
log proxy variable - <code class="reqn">\sigma_{measurementerror}= .1</code>

</p>
</li>
<li><p><code class="reqn">pX3</code>
log proxy variable - <code class="reqn">\sigma_{measurementerror}= .2</code>

</p>
</li>
<li><p><code class="reqn">pX4</code>
log proxy variable - <code class="reqn">\sigma_{measurementerror}= .5</code>

</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>


<h3>References</h3>

<p>Ackerberg, D., Caves, K. and Frazer, G. (2015).
&quot;Identification properties of recent production function estimators.&quot;
Econometrica, 83(6), 2411-2451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  require(prodest)

  ## Simulate a dataset with 100 firms (T = 50).
  ## \code{Panelsim()} delivers the last 10% of usable time per panel.

  panel.data &lt;- panelSim(N = 100, T = 50)
  attach(panel.data)

  ## Estimate various models
  ACF.fit &lt;- prodestACF(Y, fX, sX, pX2, idvar, timevar, theta0 = c(.5,.5))
  
    LP.fit &lt;- prodestLP(Y, fX, sX, pX2, idvar, timevar)
    WRDG.fit &lt;- prodestWRDG(Y, fX, sX, pX3, idvar, timevar)

    ## print results in lateX tabular format
    printProd(list(LP.fit, ACF.fit, WRDG.fit))
  
</code></pre>

<hr>
<h2 id='printProd'>
Print output - prod objects
</h2><span id='topic+printProd'></span>

<h3>Description</h3>

<p>The <code>printProd()</code> function accepts a <code>list</code> of <code>prod</code> class objects and returns a screen printed tabular in lateX format of the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  printProd(mods, modnames = NULL, parnames = NULL, outfile = NULL,
            ptime = FALSE, nboot = FALSE, screen = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printProd_+3A_mods">mods</code></td>
<td>

<p>a <code>list</code> of <code>prod</code> objects.</p>
</td></tr>

<tr><td><code id="printProd_+3A_modnames">modnames</code></td>
<td>

<p>an optional vector of model names. By default, model names are the <code>@ModelMethod</code> values in <code>prod</code> objects.</p>
</td></tr>

<tr><td><code id="printProd_+3A_parnames">parnames</code></td>
<td>

<p>an optional vector of parameter names. By default, parameter names are the <code>names()</code> vector of <code>@Estimatespars</code> in <code>prod</code> objects.</p>
</td></tr>

<tr><td><code id="printProd_+3A_outfile">outfile</code></td>
<td>

<p>optional string with the path and directory to store a text file (.txt, .tex, etc. depending on the specified extension) with the tabular. By default <code>outfile = NULL</code>.</p>
</td></tr>

<tr><td><code id="printProd_+3A_ptime">ptime</code></td>
<td>

<p>add a row showing the computational time. By default <code>ptime = FALSE</code>.</p>
</td></tr>

<tr><td><code id="printProd_+3A_nboot">nboot</code></td>
<td>

<p>add a row showing the number of bootstrap repetitions. By default <code>nboot = FALSE</code>.</p>
</td></tr>

<tr><td><code id="printProd_+3A_screen">screen</code></td>
<td>

<p>print the table on-screen without teX format. By default <code>screen = FALSE</code>.</p>
</td></tr>

</table>


<h3>Value</h3>

<p>The output of the function <code>printProd</code> is either a screen printed tabular in lateX format of <code>prod</code> object results or a text file tabular in lateX format of <code>prod</code> object results.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data("chilean")

    # run various models
    WRDGfit &lt;- prodestWRDG_GMM(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                          chilean$sX, chilean$pX, chilean$idvar, chilean$timevar)
    OPfit &lt;- prodestOP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                        chilean$pX, chilean$idvar, chilean$timevar)

    # show the output in latex - tabular format
    printProd(list(OPfit, WRDGfit), modnames = c('Olley-Pakes', 'Wooldridge'),
              parnames = c('bunsk', 'bsk', 'bk'))
    # show the output on-screen - no teX format
    printProd(list(OPfit, WRDGfit), modnames = c('Olley-Pakes', 'Wooldridge'),
              parnames = c('bunsk', 'bsk', 'bk'), screen = TRUE)
  </code></pre>

<hr>
<h2 id='prod'>Class for Prodest Fitted object</h2><span id='topic+prod'></span><span id='topic+prod-class'></span>

<h3>Description</h3>

<p>Class for prodest fitted objects.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Slots</h3>



<dl>
<dt><code>Model</code>:</dt><dd><p>Object of class <code>list</code>. Contains information about the model and the optimization procedure:
</p>

<ul>
<li> <p><code>method</code>: <code>string</code> The method used in estimation.
</p>
</li>
<li> <p><code>FSbetas</code>: <code>numeric</code> First-stage estimated parameters.
</p>
</li>
<li> <p><code>boot.repetitions</code>: <code>numeric</code> Number of bootstrap repetitions.
</p>
</li>
<li> <p><code>elapsed.time</code>: <code>numeric</code> Time - in seconds - required for estimation.
</p>
</li>
<li> <p><code>theta0</code>: <code>numeric</code> Vector of Second-stage optimization starting points.
</p>
</li>
<li> <p><code>opt</code>: <code>string</code> Optimizer used for the Second-stage.
</p>
</li>
<li> <p><code>seed</code>: <code>numeric</code> seed set.
</p>
</li>
<li> <p><code>opt.outcome</code>: <code>list</code> Optimization outcome (depends on optimizer choice).
</p>
</li></ul>

</dd>

<dt><code>Data</code>:</dt><dd><p>Object of class <code>list</code>. Contains:
</p>

<ul>
<li> <p><code>Y</code>: <code>numeric</code> Dependent variable - Value added.
</p>
</li>
<li> <p><code>free</code>: <code>matrix</code> Free variable(s).
</p>
</li>
<li> <p><code>state</code>: <code>matrix</code> State variable(s).
</p>
</li>
<li> <p><code>proxy</code>: <code>matrix</code> Proxy variable(s).
</p>
</li>
<li> <p><code>control</code>: <code>matrix</code> Control variable(s).
</p>
</li>
<li> <p><code>idvar</code>: <code>numeric</code> Panel identifiers.
</p>
</li>
<li> <p><code>timevar</code>: <code>numeric</code> Time identifiers.
</p>
</li>
<li> <p><code>FSresiduals</code>: <code>numeric</code> First-Stage residuals.
</p>
</li></ul>

</dd>

<dt><code>Estimates</code>:</dt><dd><p>Object of class <code>list</code>. Contains:
</p>

<ul>
<li> <p><code>pars</code>: <code>numeric</code> Estimated parameters for the variables of interest.
</p>
</li>
<li> <p><code>std.errors</code>: <code>numeric</code> Estimated standard errors for the variables of interest.
</p>
</li></ul>

</dd>
</dl>



<h3>Methods</h3>


<ul>
<li> <p><code>show</code> <code>signature(object = 'prod')</code>: Show table with the method, the estimated parameters and their standard errors.
</p>
</li>
<li> <p><code>summary</code> <code>signature(object = 'prod')</code>: Show table with method, parameters, std.errors and auxiliary information on model and optimization.
</p>
</li>
<li> <p><code>FSres</code> <code>signature(object = 'prod')</code>: Extract First-Stage residual vector.
</p>
</li>
<li> <p><code>omega</code> <code>signature(object = 'prod')</code>: Extract estimated productivity vector.
</p>
</li>
<li> <p><code>coef</code> <code>signature(object = 'prod')</code>: Extract estimated coefficients.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='prodestACF'>
Estimate productivity - Ackerberg-Caves-Frazer correction
</h2><span id='topic+prodestACF'></span>

<h3>Description</h3>

<p>The <code>prodestACF()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S3</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestACF(Y, fX, sX, pX, idvar, timevar, R = 20, cX = NULL,
            opt = 'optim', theta0 = NULL, cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestACF_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_r">R</code></td>
<td>

<p>the number of block bootstrap repetitions to be performed in the standard error estimation. By default <code>R = 20</code>.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_opt">opt</code></td>
<td>

<p>a string with the optimization algorithm to be used during the estimation. By default <code>opt = 'optim'</code>.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_theta0">theta0</code></td>
<td>

<p>a vector with the second stage optimization starting points. By default <code>theta0 = NULL</code> and the optimization is run starting from the first stage estimated parameters + <code class="reqn">N(0,0.01)</code> noise.</p>
</td></tr>

<tr><td><code id="prodestACF_+3A_cluster">cluster</code></td>
<td>

<p>an object of class <code>"SOCKcluster"</code> or <code>"cluster"</code>. By default <code>cluster = NULL</code>.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
ACF propose an estimation algorithm alternative to OP and LP procedures claiming that the labour demand and the control function are partially collinear.
It is based on the following set of assumptions:
</p>

<ul>
<li><p> a) <code class="reqn">p_{it} = p(k_{it} , l_{it} , \omega_{it})</code> is the proxy variable policy function;
</p>
</li>
<li><p> b) <code class="reqn">p_{it}</code> is strictly monotone in <code class="reqn">\omega_{it}</code>;
</p>
</li>
<li><p> c) <code class="reqn">\omega_{it}</code> is scalar unobservable in <code class="reqn">p_{it} = m(.)</code> ;
</p>
</li>
<li><p> d) The state variable are decided at time t-1. The less variable labor input, <code class="reqn">l_{it}</code>, is chosen at t-b, where <code class="reqn">0 &lt; b &lt; 1</code>. The free variables, <code class="reqn">w_{it}</code>, are chosen in t when the firm productivity shock is realized.
</p>
</li></ul>

<p>Under this set of assumptions, the first stage is meant to remove the shock <code class="reqn">\epsilon_{it}</code> from the the output, <code class="reqn">y_{it}</code>. As in the OP/LP case, the inverted policy function replaces the productivity term <code class="reqn">\omega_{it}</code> in the production function:
</p>

<ul>
<li> <p><code class="reqn">y_{it} = k_{it}\gamma + w_{it}\beta + l_{it}\mu + h(p_{it} , k_{it} ,w_{it} , l_{it}) +  \epsilon_{it}</code>
</p>
</li></ul>

<p>which is estimated by a non-parametric approach - First Stage.
Exploiting the Markovian nature of the productivity process one can use assumption d) in order to set up the relevant moment conditions and estimate the production function parameters - Second stage.
</p>


<h3>Value</h3>

<p>The output of the function <code>prodestACF</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list with elements:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('ACF').
</p>
</li>
<li> <p><code>boot.repetitions:</code> the number of bootstrap repetitions used for standard errors' computation.
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>theta0:</code> numeric object with the optimization starting points - second stage.
</p>
</li>
<li> <p><code>opt:</code> string with the optimization routine used - 'optim', 'solnp' or 'DEoptim'.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li>
<li> <p><code>FSbetas:</code> first stage estimated parameters.
</p>
</li></ul>

<p><code>Data</code>, a list with elements:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li>
<li> <p><code>FSresiduals:</code> numeric object with the residuals of the first stage.
</p>
</li></ul>

<p><code>Estimates</code>, a list with elements:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>References</h3>

<p>Ackerberg, D., Caves, K. and Frazer, G. (2015).
&quot;Identification properties of recent production function estimators.&quot;
Econometrica, 83(6), 2411-2451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    require(prodest)

    ## Chilean data on production.The full version is Publicly available at
    ## http://www.ine.cl/canales/chile_estadistico/estadisticas_economicas/industria/
    ## series_estadisticas/series_estadisticas_enia.php

    data(chilean)

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    ACF.fit &lt;- prodestACF(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                          chilean$pX, chilean$idvar, chilean$timevar,
                          theta0 = c(.5,.5,.5), R = 5)
    
      set.seed(154673)
      ACF.fit.solnp &lt;- prodestACF(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                            chilean$pX, chilean$idvar, chilean$timevar,
                            theta0 = c(.5,.5,.5), opt = 'solnp')

      # run the same regression in parallel
      # nCores &lt;- as.numeric(Sys.getenv("NUMBER_OF_PROCESSORS")) # Windows systems
      nCores &lt;- 3
      cl &lt;- makeCluster(getOption("cl.cores", nCores - 1))
      set.seed(154673)
      ACF.fit.par &lt;- prodestACF(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                                chilean$pX, chilean$idvar, chilean$timevar,
                                theta0 = c(.5,.5,.5), cluster = cl)
      stopCluster(cl)

      # show results
      coef(ACF.fit)
      coef(ACF.fit.solnp)

       # show results in .tex tabular format
       printProd(list(ACF.fit, ACF.fit.solnp))
    
  </code></pre>

<hr>
<h2 id='prodestLP'>
Estimate productivity - Levinsohn-Petrin method
</h2><span id='topic+prodestLP'></span>

<h3>Description</h3>

<p>The <code>prodestLP()</code> The <code>prodestWRDG()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S3</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestLP(Y, fX, sX, pX, idvar, timevar, R = 20, cX = NULL,
            opt = 'optim', theta0 = NULL, cluster = NULL, tol = 1e-100, exit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestLP_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_r">R</code></td>
<td>

<p>the number of block bootstrap repetitions to be performed in the standard error estimation. By default <code>R = 20</code>.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_opt">opt</code></td>
<td>

<p>a string with the optimization algorithm to be used during the estimation. By default <code>opt = 'optim'</code>.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_theta0">theta0</code></td>
<td>

<p>a vector with the second stage optimization starting points. By default <code>theta0 = NULL</code> and the optimization is run starting from the first stage estimated parameters + <code class="reqn">N(\mu=0,\sigma=0.01)</code> noise.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_cluster">cluster</code></td>
<td>

<p>an object of class <code>"SOCKcluster"</code> or <code>"cluster"</code>. By default <code>cluster = NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_tol">tol</code></td>
<td>

<p>optimizer tolerance. By default <code>tol = 1e-100</code>.</p>
</td></tr>

<tr><td><code id="prodestLP_+3A_exit">exit</code></td>
<td>

<p>Indicator for attrition in the data - i.e., if firms exit the market. By default <code>exit = FALSE</code>; if <code>exit = TRUE</code>, an indicator function for firms whose last appearance is before the last observation's date is generated and used in the second stage. The user can even specify an indicator variable/matrix/dataframe with the exit years.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
The LP method relies on the following set of assumptions:
</p>

<ul>
<li><p> a) firms immediately adjust the level of inputs according to demand function <code class="reqn">m(\omega_{it}, k_{it})</code> after the technical efficiency shock realizes;
</p>
</li>
<li><p> b) <code class="reqn">m_{it}</code> is strictly monotone in <code class="reqn">\omega_{it}</code>;
</p>
</li>
<li><p> c) <code class="reqn">\omega_{it}</code> is scalar unobservable in <code class="reqn">m_{it} = m(.)</code> ;
</p>
</li>
<li><p> d) the levels of <code class="reqn">k_{it}</code> are decided at time <code class="reqn">t-1</code>; the level of the free variable, <code class="reqn">w_{it}</code>, is decided after the shock <code class="reqn">u_{it}</code> realizes.
</p>
</li></ul>

<p>Assumptions a)-d) ensure the invertibility of <code class="reqn">m_{it}</code> in <code class="reqn">\omega_{it}</code> and lead to the partially identified model:
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + h(m_{it}, k_{it}) + \epsilon_{it} = \alpha + w_{it}\beta  + \phi(m_{it}, k_{it}) + \epsilon_{it} </code>
</p>
</li></ul>

<p>which is estimated by a non-parametric approach - First Stage.
Exploiting the Markovian nature of the productivity process one can use assumption d) in order to set up the relevant moment conditions and estimate the production function parameters - Second stage.
Exploiting the residual <code class="reqn">\nu_{it}</code> of:
</p>

<ul>
<li> <p><code class="reqn">y_{it} - w_{it}\hat{\beta} = \alpha + k_{it}\gamma + g(\omega_{it-1}, \chi_{it}) + \nu_{it} </code>
</p>
</li></ul>

<p>and <code class="reqn">g(.)</code> is typically left unspecified and approximated by a <code class="reqn">n^{th}</code> order polynomial and <code class="reqn">\chi_{it}</code> is an indicator function for the attrition in the market.
</p>


<h3>Value</h3>

<p>The output of the function <code>prodestLP</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list containing:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('LP').
</p>
</li>
<li> <p><code>boot.repetitions:</code> the number of bootstrap repetitions used for standard errors' computation.
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>theta0:</code> numeric object with the optimization starting points - second stage.
</p>
</li>
<li> <p><code>opt:</code> string with the optimization routine used - 'optim', 'solnp' or 'DEoptim'.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li>
<li> <p><code>FSbetas:</code> first stage estimated parameters.
</p>
</li></ul>

<p><code>Data</code>, a list containing:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li>
<li> <p><code>FSresiduals:</code> numeric object with the residuals of the first stage.
</p>
</li></ul>

<p><code>Estimates</code>, a list containing:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>References</h3>

<p>Levinsohn, J. and Petrin, A. (2003).
&quot;Estimating production functions using inputs to control for unobservables.&quot;
The Review of Economic Studies, 70(2), 317-341.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    require(prodest)

    ## Chilean data on production.
    ## Publicly available at http://www.ine.cl/canales/chile_estadistico/estadisticas_
    ## economicas/industria/series_estadisticas/series_estadisticas_enia.php

    data(chilean)

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    set.seed(154673)
    LP.fit &lt;- prodestLP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                        chilean$pX, chilean$idvar, chilean$timevar)
    LP.fit.solnp &lt;- prodestLP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                        chilean$pX, chilean$idvar, chilean$timevar, opt = 'solnp')

    ## Not run: 
      # run the same model in parallel
      require(parallel)
      nCores &lt;- as.numeric(Sys.getenv("NUMBER_OF_PROCESSORS"))
      cl &lt;- makeCluster(getOption("cl.cores", nCores - 1))
      set.seed(154673)
      LP.fit.par &lt;- prodestLP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                      chilean$sX, chilean$pX, chilean$idvar, chilean$timevar,
                    cluster = cl)
      stopCluster(cl)
    
## End(Not run)

    # show results
    summary(LP.fit)
    summary(LP.fit.solnp)

    # show results in .tex tabular format
     printProd(list(LP.fit, LP.fit.solnp))
  </code></pre>

<hr>
<h2 id='prodestOP'>
Estimate productivity - Olley-Pakes method
</h2><span id='topic+prodestOP'></span>

<h3>Description</h3>

<p>The <code>prodestOP()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S4</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestOP(Y, fX, sX, pX, idvar, timevar, R = 20, cX = NULL,
            opt = 'optim', theta0 = NULL, cluster = NULL, tol = 1e-100, exit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestOP_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_r">R</code></td>
<td>

<p>the number of block bootstrap repetitions to be performed in the standard error estimation. By default <code>R = 20</code>.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_opt">opt</code></td>
<td>

<p>a string with the optimization algorithm to be used during the estimation. By default <code>opt = 'optim'</code>.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_theta0">theta0</code></td>
<td>

<p>a vector with the second stage optimization starting points. By default <code>theta0 = NULL</code> and the optimization is run starting from the first stage estimated parameters + <code class="reqn">N(\mu=0,\sigma=0.01)</code> noise.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_cluster">cluster</code></td>
<td>

<p>an object of class <code>"SOCKcluster"</code> or <code>"cluster"</code>. By default <code>cluster = NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_tol">tol</code></td>
<td>

<p>optimizer tolerance. By default <code>tol = 1e-100</code>.</p>
</td></tr>

<tr><td><code id="prodestOP_+3A_exit">exit</code></td>
<td>

<p>Indicator for attrition in the data - i.e., if firms exit the market. By default <code>exit = FALSE</code>; if <code>exit = TRUE</code>, an indicator function for firms whose last appearance is before the last observation's date is generated and used in the second stage. The user can even specify an indicator variable/matrix/dataframe with the exit years.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
The OP method relies on the following set of assumptions:
</p>

<ul>
<li><p> a) <code class="reqn">i_{it} = i(k_{it},\omega_{it})</code> - investments are a function of both the state variable and the technical efficiency parameter;
</p>
</li>
<li><p> b) <code class="reqn">i_{it}</code> is strictly monotone in <code class="reqn">\omega_{it}</code>;
</p>
</li>
<li><p> c) <code class="reqn">\omega_{it}</code> is scalar unobservable in <code class="reqn">i_{it} = i(.)</code> ;
</p>
</li>
<li><p> d) the levels of <code class="reqn">i_{it}</code> and <code class="reqn">k_{it}</code> are decided at time <code class="reqn">t-1</code>; the level of the free variable, <code class="reqn">w_{it}</code>, is decided after the shock <code class="reqn">u_{it}</code> realizes.
</p>
</li></ul>

<p>Assumptions a)-d) ensure the invertibility of <code class="reqn">i_{it}</code> in <code class="reqn">\omega_{it}</code> and lead to the partially identified model:
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + h(i_{it}, k_{it}) + \epsilon_{it} = \alpha + w_{it}\beta  + \phi(i_{it}, k_{it}) + \epsilon_{it} </code>
</p>
</li></ul>

<p>which is estimated by a non-parametric approach - First Stage.
Exploiting the Markovian nature of the productivity process one can use assumption d) in order to set up the relevant moment conditions and estimate the production function parameters - Second stage.
Exploiting the residual <code class="reqn">e_{it}</code> of:
</p>

<ul>
<li> <p><code class="reqn">y_{it} - w_{it}\hat{\beta} = \alpha + k_{it}\gamma + g(\omega_{it-1}, \chi_{it}) + \epsilon_{it} </code>
</p>
</li></ul>

<p>and <code class="reqn">g(.)</code> is typically left unspecified and approximated by a <code class="reqn">n^{th}</code> order polynomial and <code class="reqn">\chi_{it}</code> is an indicator function for the attrition in the market.
</p>


<h3>Value</h3>

<p>The output of the function <code>prodestOP</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list containing:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('OP').
</p>
</li>
<li> <p><code>boot.repetitions:</code> the number of bootstrap repetitions used for standard errors' computation.
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>theta0:</code> numeric object with the optimization starting points - second stage.
</p>
</li>
<li> <p><code>opt:</code> string with the optimization routine used - 'optim', 'solnp' or 'DEoptim'.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li>
<li> <p><code>FSbetas:</code> first stage estimated parameters.
</p>
</li></ul>

<p><code>Data</code>, a list containing:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li>
<li> <p><code>FSresiduals:</code> numeric object with the residuals of the first stage.
</p>
</li></ul>

<p><code>Estimates</code>, a list containing:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>


<h3>References</h3>

<p>Olley, S G and Pakes, A (1996).
&quot;The dynamics of productivity in the telecommunications equipment industry.&quot;
Econometrica, 64(6), 1263-1297.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    require(prodest)

    ## Chilean data on production.The full version is Publicly available at
    ## http://www.ine.cl/canales/chile_estadistico/estadisticas_economicas/industria/
    ## series_estadisticas/series_estadisticas_enia.php

    data(chilean)

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    OP.fit &lt;- prodestOP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2), chilean$sX,
                        chilean$inv, chilean$idvar, chilean$timevar)
    OP.fit.solnp &lt;- prodestOP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                              chilean$sX, chilean$inv, chilean$idvar,
                              chilean$timevar, opt='solnp')
    OP.fit.control &lt;- prodestOP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                                chilean$sX, chilean$inv, chilean$idvar,
                                chilean$timevar, cX = chilean$cX)
    OP.fit.attrition &lt;- prodestOP(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                                chilean$sX, chilean$inv, chilean$idvar,
                                chilean$timevar, exit = TRUE)

    # show results
    summary(OP.fit)
    summary(OP.fit.solnp)
    summary(OP.fit.control)

    # show results in .tex tabular format
     printProd(list(OP.fit, OP.fit.solnp, OP.fit.control, OP.fit.attrition))
</code></pre>

<hr>
<h2 id='prodestROB'>
Estimate productivity - Robinson-Wooldridge method
</h2><span id='topic+prodestROB'></span>

<h3>Description</h3>

<p>The <code>prodestROB()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S3</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestROB(Y, fX, sX, pX, idvar, timevar, cX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestROB_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestROB_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
Wooldridge method allows to jointly estimate OP/LP two stages jointly in a system of two equations. It relies on the following set of assumptions:
</p>

<ul>
<li><p> a) <code class="reqn">\omega_{it} = g(x_{it} , p_{it})</code>: productivity is an unknown function <code class="reqn">g(.)</code> of state and a proxy variables;
</p>
</li>
<li><p> b) <code class="reqn">E(\omega_{it} | \omega_{it-1)}=f[\omega_{it-1}]</code>, productivity is an unknown function <code class="reqn">f[.]</code> of lagged productivity, <code class="reqn">\omega_{it-1}</code>.
</p>
</li></ul>

<p>Under the above set of assumptions, It is possible to construct a system gmm using the  vector of residuals from
</p>

<ul>
<li> <p><code class="reqn">r_{1it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - g(x_{it} , p_{it}) </code>
</p>
</li>
<li> <p><code class="reqn">r_{2it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - f[g(x_{it-1} , p_{it-1})]</code>
</p>
</li></ul>

<p>where the unknown function <code class="reqn">f(.)</code> is approximated by a n-th order polynomial and <code class="reqn">g(x_{it} , m_{it}) = \lambda_{0} + c(x_{it} , m_{it})\lambda</code>. In particular, <code class="reqn">g(x_{it} , m_{it})</code> is a linear combination of functions in <code class="reqn">(x_{it} , m_{it})</code>
and <code class="reqn">c_{it}</code> are the addends of this linear combination. The residuals <code class="reqn">r_{it}</code> are used to set the moment conditions
</p>

<ul>
<li> <p><code class="reqn">E(Z_{it}*r_{it}) =0</code>
</p>
</li></ul>

<p>with the following set of instruments:
</p>

<ul>
<li> <p><code class="reqn">Z1_{it} = (1, w_{it}, x_{it}, c_{it})</code>
</p>
</li>
<li> <p><code class="reqn">Z2_{it} = (w_{it-1}, c_{it}, c_{it})</code>
</p>
</li></ul>

<p>According to the input timing in ACF, the first equation proposed by Wooldridge would not be useful to identify any of the parameters, but it would be possible to achieve the identification from the second equation by exploiting the orthogonality condition:
</p>

<ul>
<li> <p><code class="reqn">\epsilon_{it} | x_{it}, w_{it-1}, x_{it-1}, m_{it-1},...,x_{i1},w_{i1},m_{i1}) = 0</code>
</p>
</li></ul>

<p>with an instrumental variable version of Robinson (1988)'s estimator.
</p>


<h3>Value</h3>

<p>The output of the function <code>prodestROB</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list containing:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('ROB-IV').
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li></ul>

<p><code>Data</code>, a list containing:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li></ul>

<p><code>Estimates</code>, a list containing:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>References</h3>

<p>Ackerberg, D., K. Caves, and G. Frazer (2015).
&quot;Identification Properties of Recent Production Function Estimators.&quot;
Econometrica 83(6): 2411-2451.
</p>
<p>Robinson, P. M. (1988).
&quot;Root-N-consistent semiparametric regression.&quot;
Econometrica: Journal of the Econometric Society, 931-954.
</p>
<p>Wooldridge, J M (2009).
&quot;On estimating firm-level production functions using proxy variables to control for unobservables.&quot;
Economics Letters, 104, 112-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data("chilean")

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    ROB.IV.fit &lt;- prodestROB(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                                   chilean$sX, chilean$pX, chilean$idvar, chilean$timevar)

    # show results
    ROB.IV.fit

    
      # estimate a panel dataset - DGP1, various measurement errors - and run the estimation
      sim &lt;- panelSim()

      ROB.IV.sim1 &lt;- prodestROB(sim$Y, sim$fX, sim$sX, sim$pX1, sim$idvar, sim$timevar)
      ROB.IV.sim2 &lt;- prodestROB(sim$Y, sim$fX, sim$sX, sim$pX2, sim$idvar, sim$timevar)
      ROB.IV.sim3 &lt;- prodestROB(sim$Y, sim$fX, sim$sX, sim$pX3, sim$idvar, sim$timevar)
      ROB.IV.sim4 &lt;- prodestROB(sim$Y, sim$fX, sim$sX, sim$pX4, sim$idvar, sim$timevar)

      # show results in .tex tabular format
      printProd(list(ROB.IV.sim1, ROB.IV.sim2, ROB.IV.sim3, ROB.IV.sim4),
                parnames = c('Free','State'))
    
  </code></pre>

<hr>
<h2 id='prodestWRDG'>
Estimate productivity - IV Wooldridge method
</h2><span id='topic+prodestWRDG'></span>

<h3>Description</h3>

<p>The <code>prodestWRDG()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S3</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestWRDG(Y, fX, sX, pX, idvar, timevar, cX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestWRDG_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestWRDG_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
Wooldridge method allows to jointly estimate OP/LP two stages jointly in a system of two equations. It relies on the following set of assumptions:
</p>

<ul>
<li><p> a) <code class="reqn">\omega_{it} = g(x_{it} , p_{it})</code>: productivity is an unknown function <code class="reqn">g(.)</code> of state and a proxy variables;
</p>
</li>
<li><p> b) <code class="reqn">E(\omega_{it} | \omega_{it-1)}=f[\omega_{it-1}]</code>, productivity is an unknown function <code class="reqn">f[.]</code> of lagged productivity, <code class="reqn">\omega_{it-1}</code>.
</p>
</li></ul>

<p>Under the above set of assumptions, It is possible to construct a system gmm using the  vector of residuals from
</p>

<ul>
<li> <p><code class="reqn">r_{1it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - g(x_{it} , p_{it}) </code>
</p>
</li>
<li> <p><code class="reqn">r_{2it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - f[g(x_{it-1} , p_{it-1})]</code>
</p>
</li></ul>

<p>where the unknown function <code class="reqn">f(.)</code> is approximated by a n-th order polynomial and <code class="reqn">g(x_{it} , m_{it}) = \lambda_0 + c(x_{it} , m_{it})\lambda</code>. In particular, <code class="reqn">g(x_{it} , m_{it})</code> is a linear combination of functions in <code class="reqn">(x_{it} , m_{it})</code>
and <code class="reqn">c_{it}</code> are the addends of this linear combination. The residuals <code class="reqn">r_{it}</code> are used to set the moment conditions
</p>

<ul>
<li> <p><code class="reqn">E(Z_{it}*r_{it}) =0</code>
</p>
</li></ul>

<p>with the following set of instruments:
</p>

<ul>
<li> <p><code class="reqn">Z1_{it} = (1, w_{it}, x_{it}, c_{it})</code>
</p>
</li>
<li> <p><code class="reqn">Z2_{it} = (w_{it-1}, c_{it}, c_{it})</code>
</p>
</li></ul>

<p>Following previous assumptions, being <code class="reqn">f(\omega) = \delta_0 + \delta_1(c_{it}\lambda) + \delta_2(c_{it}\lambda)^2 + ... + \delta_G(c_{it}\lambda)^G</code>, one can set <code class="reqn">\delta_1 = G = 1</code> and estimate the model in a linear fashion - i.e., using a linear 2SLS model.
</p>


<h3>Value</h3>

<p>The output of the function <code>prodestWRDG</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list containing:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('WRDG').
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li></ul>

<p><code>Data</code>, a list containing:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li></ul>

<p><code>Estimates</code>, a list containing:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>References</h3>

<p>Wooldridge, J M (2009).
&quot;On estimating firm-level production functions using proxy variables to control for unobservables.&quot;
Economics Letters, 104, 112-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data("chilean")

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    WRDG.IV.fit &lt;- prodestWRDG_GMM(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                                    chilean$sX, chilean$pX, chilean$idvar, chilean$timevar)

    # show results
    WRDG.IV.fit

    
      # estimate a panel dataset - DGP1, various measurement errors - and run the estimation
      sim &lt;- panelSim()

      WRDG.IV.sim1 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX1, sim$idvar, sim$timevar)
      WRDG.IV.sim2 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX2, sim$idvar, sim$timevar)
      WRDG.IV.sim3 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX3, sim$idvar, sim$timevar)
      WRDG.IV.sim4 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX4, sim$idvar, sim$timevar)

      # show results in .tex tabular format
      printProd(list(WRDG.IV.sim1, WRDG.IV.sim2, WRDG.IV.sim3, WRDG.IV.sim4),
                parnames = c('Free','State'))
    
  </code></pre>

<hr>
<h2 id='prodestWRDG_GMM'>
Estimate productivity - Wooldridge method
</h2><span id='topic+prodestWRDG_GMM'></span>

<h3>Description</h3>

<p>The <code>prodestWRDG_GMM()</code> function accepts at least 6 objects (id, time, output, free, state and proxy variables), and returns a <code>prod</code> object of class <code>S3</code> with three elements: (i) a list of model-related objects, (ii) a list with the data used in the estimation and estimated vectors of first-stage residuals, and (iii) a list with the estimated parameters and their bootstrapped standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prodestWRDG_GMM(Y, fX, sX, pX, idvar, timevar, cX = NULL, tol = 1e-100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodestWRDG_GMM_+3A_y">Y</code></td>
<td>

<p>the vector of value added log output.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_fx">fX</code></td>
<td>

<p>the vector/matrix/dataframe of log free variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_sx">sX</code></td>
<td>

<p>the vector/matrix/dataframe of log state variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_px">pX</code></td>
<td>

<p>the vector/matrix/dataframe of log proxy variables.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_cx">cX</code></td>
<td>

<p>the vector/matrix/dataframe of control variables. By default <code>cX= NULL</code>.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_idvar">idvar</code></td>
<td>

<p>the vector/matrix/dataframe identifying individual panels.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_timevar">timevar</code></td>
<td>

<p>the vector/matrix/dataframe identifying time.</p>
</td></tr>

<tr><td><code id="prodestWRDG_GMM_+3A_tol">tol</code></td>
<td>

<p>optimizer tolerance. By default <code>tol = 1e-100</code>.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Consider a Cobb-Douglas production technology for firm <code class="reqn">i</code> at time <code class="reqn">t</code>
</p>

<ul>
<li> <p><code class="reqn">y_{it} = \alpha + w_{it}\beta + k_{it}\gamma + \omega_{it} + \epsilon_{it}</code>
</p>
</li></ul>

<p>where <code class="reqn">y_{it}</code> is the (log) output, w_it a 1xJ vector of (log) free variables, k_it is a 1xK vector of state variables and <code class="reqn">\epsilon_{it}</code> is a normally distributed idiosyncratic error term.
The unobserved technical efficiency parameter <code class="reqn">\omega_{it}</code> evolves according to a first-order Markov process:
</p>

<ul>
<li> <p><code class="reqn">\omega_{it} = E(\omega_{it} | \omega_{it-1}) + u_{it} = g(\omega_{it-1}) + u_{it}</code>
</p>
</li></ul>

<p>and <code class="reqn">u_{it}</code> is a random shock component assumed to be uncorrelated with the technical efficiency, the state variables in <code class="reqn">k_{it}</code> and the lagged free variables <code class="reqn">w_{it-1}</code>.
Wooldridge method allows to jointly estimate OP/LP two stages jointly in a system of two equations. It relies on the following set of assumptions:
</p>

<ul>
<li><p> a) <code class="reqn">\omega_{it} = g(x_{it} , p_{it})</code>: productivity is an unknown function <code class="reqn">g(.)</code> of state and a proxy variables;
</p>
</li>
<li><p> b) <code class="reqn">E(\omega_{it} | \omega_{it-1)}=f[\omega_{it-1}]</code>, productivity is an unknown function <code class="reqn">f[.]</code> of lagged productivity, <code class="reqn">\omega_{it-1}</code>.
</p>
</li></ul>

<p>Under the above set of assumptions, It is possible to construct a system gmm using the  vector of residuals from
</p>

<ul>
<li> <p><code class="reqn">r_{1it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - g(x_{it} , p_{it}) </code>
</p>
</li>
<li> <p><code class="reqn">r_{2it} = y_{it} - \alpha - w_{it}\beta - x_{it}\gamma - f[g(x_{it-1} , p_{it-1})]</code>
</p>
</li></ul>

<p>where the unknown function <code class="reqn">f(.)</code> is approximated by a n-th order polynomial and <code class="reqn">g(x_{it} , m_{it}) = \lambda_0 + c(x_{it} , m_{it})\lambda</code>. In particular, <code class="reqn">g(x_{it} , m_{it})</code> is a linear combination of functions in <code class="reqn">(x_{it} , m_{it})</code>
and <code class="reqn">c_{it}</code> are the addends of this linear combination. The residuals <code class="reqn">r_{it}</code> are used to set the moment conditions
</p>

<ul>
<li> <p><code class="reqn">E(Z_{it}*r_{it}) =0</code>
</p>
</li></ul>

<p>with the following set of instruments:
</p>

<ul>
<li> <p><code class="reqn">Z1_{it} = (1, w_{it}, x_{it}, c_{it})</code>
</p>
</li>
<li> <p><code class="reqn">Z2_{it} = (w_{it-1}, c_{it}, c_{it})</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The output of the function <code>prodestWRDG</code> is a member of the <code>S3</code> class <span class="pkg">prod</span>. More precisely, is a list (of length 3) containing the following elements:
</p>
<p><code>Model</code>, a list containing:
</p>

<ul>
<li> <p><code>method:</code> a string describing the method ('WRDG').
</p>
</li>
<li> <p><code>elapsed.time:</code> time elapsed during the estimation.
</p>
</li>
<li> <p><code>opt.outcome:</code> optimization outcome.
</p>
</li></ul>

<p><code>Data</code>, a list containing:
</p>

<ul>
<li> <p><code>Y:</code> the vector of value added log output.
</p>
</li>
<li> <p><code>free:</code> the vector/matrix/dataframe of log free variables.
</p>
</li>
<li> <p><code>state:</code> the vector/matrix/dataframe of log state variables.
</p>
</li>
<li> <p><code>proxy:</code> the vector/matrix/dataframe of log proxy variables.
</p>
</li>
<li> <p><code>control:</code> the vector/matrix/dataframe of log control variables.
</p>
</li>
<li> <p><code>idvar:</code> the vector/matrix/dataframe identifying individual panels.
</p>
</li>
<li> <p><code>timevar:</code> the vector/matrix/dataframe identifying time.
</p>
</li></ul>

<p><code>Estimates</code>, a list containing:
</p>

<ul>
<li> <p><code>pars:</code> the vector of estimated coefficients.
</p>
</li>
<li> <p><code>std.errors:</code> the vector of bootstrapped standard errors.
</p>
</li></ul>

<p>Members of class <code>prod</code> have an <code>omega</code> method returning a numeric object with the estimated productivity - that is: <code class="reqn">\omega_{it} = y_{it} - (\alpha + w_{it}\beta + k_{it}\gamma)</code>.
<code>FSres</code> method returns a numeric object with the residuals of the first stage regression, while <code>summary</code>, <code>show</code> and <code>coef</code> methods are implemented and work as usual.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti
</p>


<h3>References</h3>

<p>Wooldridge, J M (2009).
&quot;On estimating firm-level production functions using proxy variables to control for unobservables.&quot;
Economics Letters, 104, 112-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data("chilean")

    # we fit a model with two free (skilled and unskilled), one state (capital)
    # and one proxy variable (electricity)

    WRDG.GMM.fit &lt;- prodestWRDG_GMM(chilean$Y, fX = cbind(chilean$fX1, chilean$fX2),
                              chilean$sX, chilean$pX, chilean$idvar, chilean$timevar)

    # show results
    WRDG.GMM.fit

    
      # estimate a panel dataset - DGP1, various measurement errors - and run the estimation
      sim &lt;- panelSim()

      WRDG.GMM.sim1 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX1, sim$idvar, sim$timevar)
      WRDG.GMM.sim2 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX2, sim$idvar, sim$timevar)
      WRDG.GMM.sim3 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX3, sim$idvar, sim$timevar)
      WRDG.GMM.sim4 &lt;- prodestWRDG_GMM(sim$Y, sim$fX, sim$sX, sim$pX4, sim$idvar, sim$timevar)

      # show results in .tex tabular format
      printProd(list(WRDG.GMM.sim1, WRDG.GMM.sim2, WRDG.GMM.sim3, WRDG.GMM.sim4),
                      parnames = c('Free','State'))
    
 </code></pre>

<hr>
<h2 id='show'>Print a table with parameter estimates</h2><span id='topic+show+2Cprod-method'></span><span id='topic+show'></span>

<h3>Description</h3>

<p>This method allows the user to print a table with the parameter estimates of an <code>S4</code> <a href="#topic+prod">prod</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  show(object)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>

<p>object of class <a href="#topic+prod">prod</a>.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>show</code> accepts an <code>S4</code> <a href="#topic+prod">prod</a> object and prints a table with estimated parameters.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='summary'>Print a table with a summary of results</h2><span id='topic+summary+2Cprod-method'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p>This method allows the user to print a table with a summary of the results within an <code>S4</code> <a href="#topic+prod">prod</a> object: the parameter estimates, the method, the number of observations, the time elapsed, the number of bootstrap repetitions, the first stage estimates and the starting points.
</p>


<h3>Arguments</h3>


<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>

<p>object of class <a href="#topic+prod">prod</a>.
</p>
</td></tr>

<tr><td><code id="summary_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary</code> accepts an <code>S4</code> <a href="#topic+prod">prod</a> object and prints a table with the results.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='weightM'>Generate optimal GMM weighting matrix</h2><span id='topic+weightM'></span>

<h3>Description</h3>

<p>In a Wooldridge estimation setting, i.e., in a system GMM framework, this function returns the optimal weighting matrix or the variance-covariance matrix given 1st or 2nd stage estimation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  weightM(Y, X1, X2, Z1, Z2, betas, numR, SE = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="weightM_+3A_y">Y</code></td>
<td>

<p>Vector of log(value added output).
</p>
</td></tr>

<tr><td><code id="weightM_+3A_x1">X1</code></td>
<td>

<p>Matrix of regressors for the first equation.
</p>
</td></tr>

<tr><td><code id="weightM_+3A_x2">X2</code></td>
<td>

<p>Matrix of regressors for the second equation.
</p>
</td></tr>

<tr><td><code id="weightM_+3A_z1">Z1</code></td>
<td>

<p>Matrix of instruments for the first equation.
</p>
</td></tr>

<tr><td><code id="weightM_+3A_z2">Z2</code></td>
<td>

<p>Matrix of instruments for the second equation.
</p>
</td></tr>

<tr><td><code id="weightM_+3A_betas">betas</code></td>
<td>

<p>Vector of first/second stage parameter estimates.
</p>
</td></tr>

<tr><td><code id="weightM_+3A_numr">numR</code></td>
<td>

<p>Number of state + number of free + number of control variables (i.e., number of constrained parameters).
</p>
</td></tr>

<tr><td><code id="weightM_+3A_se">SE</code></td>
<td>

<p>Binary indicator for first (<code>SE == FALSE</code>, the default) or second stage.
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>weightM()</code> accepts at least 7 inputs: Y, X1, X2, Z1, Z2, betas and numR. With these, computes the optimal weighting matrix in a system GMM framework, i.e. W* = sigma*Z'Z. If it is called during the first stage, it returns W*, otherwise will return an estimate of the parameters' standard errors, i.e., the square root of the diagonal of the variance-covariance matrix: 1/N( (X'Z) W* (Z'X) )^-1.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

<hr>
<h2 id='withinvar'>Generate the variance of the demeaned variable</h2><span id='topic+withinvar'></span>

<h3>Description</h3>

<p><code>withinvar()</code> subtracts the mean of a vector from the vector itself, and then returns its variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    withinvar(inmat)
  </code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="withinvar_+3A_inmat">inmat</code></td>
<td>

<p>Vector of log(value added output).
</p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>withinvar()</code> accepts a vector as input, then subtracts the mean from it and returns the variance.
</p>


<h3>Author(s)</h3>

<p>Gabriele Rovigatti</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
