<!DOCTYPE html><html><head><title>Help for package netdiffuseR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netdiffuseR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netdiffuseR'><p>netdiffuseR</p></a></li>
<li><a href='#+25+2A+25'><p>Matrix multiplication</p></a></li>
<li><a href='#approx_geodesic'><p>Approximate Geodesic Distances</p></a></li>
<li><a href='#as_dgCMatrix'><p>Coerce a matrix-like objects to <code>dgCMatrix</code> (sparse matrix)</p></a></li>
<li><a href='#as.array.diffnet'><p>Coerce a diffnet graph into an array</p></a></li>
<li><a href='#bass'><p>Bass Model</p></a></li>
<li><a href='#bootnet'><p>Network Bootstrapping</p></a></li>
<li><a href='#brfarmers'><p>Brazilian Farmers</p></a></li>
<li><a href='#brfarmersDiffNet'><p><code>diffnet</code> version of the Brazilian Farmers data</p></a></li>
<li><a href='#c.diffnet'><p>Combine diffnet objects</p></a></li>
<li><a href='#classify_adopters'><p>Classify adopters accordingly to Time of Adoption and Threshold levels.</p></a></li>
<li><a href='#classify_graph'><p>Analyze an R object to identify the class of graph (if any)</p></a></li>
<li><a href='#cumulative_adopt_count'><p>Cummulative count of adopters</p></a></li>
<li><a href='#dgr'><p>Indegree, outdegree and degree of the vertices</p></a></li>
<li><a href='#diag_expand'><p>Creates a square matrix suitable for spatial statistics models.</p></a></li>
<li><a href='#diffnet_check_attr_class'><p>Infer whether <code>value</code> is dynamic or static.</p></a></li>
<li><a href='#diffnet_index'><p>Indexing diffnet objects (on development)</p></a></li>
<li><a href='#diffnet-arithmetic'><p><code>diffnet</code> Arithmetic and Logical Operators</p></a></li>
<li><a href='#diffnet-class'><p>Creates a <code>diffnet</code> class object</p></a></li>
<li><a href='#diffreg'><p>Diffusion regression model</p></a></li>
<li><a href='#diffusion-data'><p>Diffusion Network Datasets</p></a></li>
<li><a href='#diffusionMap'><p>Creates a heatmap based on a graph layout and a vertex attribute</p></a></li>
<li><a href='#drawColorKey'><p>Draw a color key in the current device</p></a></li>
<li><a href='#edgelist_to_adjmat'><p>Conversion between adjacency matrix and edgelist</p></a></li>
<li><a href='#edges_coords'><p>Compute ego/alter edge coordinates considering alter's size and aspect ratio</p></a></li>
<li><a href='#ego_variance'><p>Computes variance of <code class="reqn">Y</code> at ego level</p></a></li>
<li><a href='#egonet_attrs'><p>Retrieve alter's attributes (network effects)</p></a></li>
<li><a href='#exposure'><p>Ego exposure</p></a></li>
<li><a href='#fakeDynEdgelist'><p>Fake dynamic edgelist</p></a></li>
<li><a href='#fakeEdgelist'><p>Fake static edgelist</p></a></li>
<li><a href='#fakesurvey'><p>Fake survey data</p></a></li>
<li><a href='#fakesurveyDyn'><p>Fake longitudinal survey data</p></a></li>
<li><a href='#grid_distribution'><p>Distribution over a grid</p></a></li>
<li><a href='#hazard_rate'><p>Network Hazard Rate</p></a></li>
<li><a href='#igraph'><p>Coercion between graph classes</p></a></li>
<li><a href='#infection'><p>Susceptibility and Infection</p></a></li>
<li><a href='#isolated'><p>Find and remove isolated vertices</p></a></li>
<li><a href='#kfamily'><p>Korean Family Planning</p></a></li>
<li><a href='#kfamilyDiffNet'><p><code>diffnet</code> version of the Korean Family Planning data</p></a></li>
<li><a href='#matrix_compare'><p>Non-zero element-wise comparison between two sparse matrices</p></a></li>
<li><a href='#medInnovations'><p>Medical Innovation</p></a></li>
<li><a href='#medInnovationsDiffNet'><p><code>diffnet</code> version of the Medical Innovation data</p></a></li>
<li><a href='#mentor_matching'><p>Optimal Leader/Mentor Matching</p></a></li>
<li><a href='#moran'><p>Computes Moran's I correlation index</p></a></li>
<li><a href='#netdiffuseR-graphs'><p>Network data formats</p></a></li>
<li><a href='#netdiffuseR-options'><p><span class="pkg">netdiffuseR</span> default options</p></a></li>
<li><a href='#netmatch'><p>Matching Estimators with Network Data</p></a></li>
<li><a href='#network'><p>Coercion between <code>diffnet</code>, <code>network</code> and <code>networkDynamic</code></p></a></li>
<li><a href='#nvertices'><p>Count the number of vertices/edges/slices in a graph</p></a></li>
<li><a href='#permute_graph'><p>Permute the values of a matrix</p></a></li>
<li><a href='#plot_adopters'><p>Visualize adopters and cumulative adopters</p></a></li>
<li><a href='#plot_diffnet'><p>Plot the diffusion process</p></a></li>
<li><a href='#plot_diffnet2'><p>Another way of visualizing diffusion</p></a></li>
<li><a href='#plot_infectsuscep'><p>Plot distribution of infect/suscep</p></a></li>
<li><a href='#plot_threshold'><p>Threshold levels through time</p></a></li>
<li><a href='#plot.diffnet'><p>S3 plotting method for diffnet objects.</p></a></li>
<li><a href='#pretty_within'><p>Pretty numbers within a range.</p></a></li>
<li><a href='#rdiffnet'><p>Random diffnet network</p></a></li>
<li><a href='#read_pajek'><p>Read foreign graph formats</p></a></li>
<li><a href='#read_ucinet_head'><p>Reads UCINET files</p></a></li>
<li><a href='#recode'><p>Recodes an edgelist such that ids go from 1 to n</p></a></li>
<li><a href='#rescale_vertex_igraph'><p>Rescale vertex size to be used in <code>plot.igraph</code>.</p></a></li>
<li><a href='#rewire_graph'><p>Graph rewiring algorithms</p></a></li>
<li><a href='#rgraph_ba'><p>Scale-free and Homophilic Random Networks</p></a></li>
<li><a href='#rgraph_er'><p>Erdos-Renyi model</p></a></li>
<li><a href='#rgraph_ws'><p>Watts-Strogatz model</p></a></li>
<li><a href='#ring_lattice'><p>Ring lattice graph</p></a></li>
<li><a href='#round_to_seq'><p>Takes a numeric vector and maps it into a finite length sequence</p></a></li>
<li><a href='#select_egoalter'><p>Calculate the number of adoption changes between ego and alter.</p></a></li>
<li><a href='#struct_equiv'><p>Structural Equivalence</p></a></li>
<li><a href='#struct_test'><p>Structure dependence test</p></a></li>
<li><a href='#summary.diffnet'><p>Summary of diffnet objects</p></a></li>
<li><a href='#survey_to_diffnet'><p>Convert survey-like data and edgelists to a <code>diffnet</code> object</p></a></li>
<li><a href='#threshold'><p>Retrive threshold levels from the exposure matrix</p></a></li>
<li><a href='#toa_diff'><p>Difference in Time of Adoption (TOA) between individuals</p></a></li>
<li><a href='#toa_mat'><p>Time of adoption matrix</p></a></li>
<li><a href='#transformGraphBy'><p>Apply a function to a graph considering non-diagonal structural zeros</p></a></li>
<li><a href='#vertex_covariate_compare'><p>Comparisons at dyadic level</p></a></li>
<li><a href='#vertex_covariate_dist'><p>Computes covariate distance between connected vertices</p></a></li>
<li><a href='#weighted_var'><p>Computes weighted variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Diffusion and Contagion Processes on Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.22.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Empirical statistical analysis, visualization and simulation of
    diffusion and contagion processes on networks. The package implements algorithms
    for calculating network diffusion statistics such as transmission rate, hazard
    rates, exposure models, network threshold levels, infectiousness (contagion),
    and susceptibility. The package is inspired by work published in Valente,
    et al., (2015) &lt;<a href="https://doi.org/10.1016%2Fj.socscimed.2015.10.001">doi:10.1016/j.socscimed.2015.10.001</a>&gt;; Valente (1995) &lt;ISBN:
    9781881303213&gt;, Myers (2000) &lt;<a href="https://doi.org/10.1086%2F303110">doi:10.1086/303110</a>&gt;, Iyengar and others (2011)
    &lt;<a href="https://doi.org/10.1287%2Fmksc.1100.0566">doi:10.1287/mksc.1100.0566</a>&gt;, Burt (1987) &lt;<a href="https://doi.org/10.1086%2F228667">doi:10.1086/228667</a>&gt;; among others.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1), sna, network, networkDynamic, Matrix, MASS,
MatchIt, SparseM, methods, grDevices, graphics, stats, utils,
boot, igraph, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown, ape, RSiena, survival</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USCCANA/netdiffuseR">https://github.com/USCCANA/netdiffuseR</a>,
<a href="https://USCCANA.github.io/netdiffuseR/">https://USCCANA.github.io/netdiffuseR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USCCANA/netdiffuseR/issues">https://github.com/USCCANA/netdiffuseR/issues</a></td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>90C35, 90B18, 91D30</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'imports.r' 'graph_data.r' 'adjmat.r' 'bass.r'
'bootnet.r' 'data.r' 'diffnet-c.R' 'diffnet-class.r'
'diffnet-indexing.r' 'diffnet-methods.r' 'egonets.R'
'formula.r' 'igraph.r' 'infect_suscept.r' 'mentor.r' 'misc.r'
'moran.r' 'netmatch.r' 'network.r' 'options.R' 'package-doc.r'
'plot_diffnet2.r' 'rewire.r' 'random_graph.R' 'rdiffnet.r'
'read_write_foreign.r' 'select_egoalter.R' 'spatial.R'
'stats.R' 'struct_equiv.R' 'struct_test.R'
'survey_to_diffnet.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-30 15:45:38 UTC; george</td>
</tr>
<tr>
<td>Author:</td>
<td>George Vega Yon <a href="https://orcid.org/0000-0002-3171-0844"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (Rewrite functions with Rcpp, plus new features),
  Thomas Valente <a href="https://orcid.org/0000-0002-8824-5816"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph] (R original code),
  Stephanie Dyal [ctb] (Package's first version),
  Timothy Hayes [ctb] (Package's first version)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Vega Yon &lt;g.vegayon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-30 17:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='netdiffuseR'>netdiffuseR</h2><span id='topic+netdiffuseR'></span><span id='topic+netdiffuseR-package'></span>

<h3>Description</h3>

<p>Statistical analysis, visualization and simulation of diffusion and contagion
processes on networks. The package implements algorithms for
calculating stats such as innovation threshold levels, infectiousness
(contagion) and susceptibility, and hazard rates as presented in Burt (1987),
Valente (1995), and Myers (2000) (among others).
</p>
<p>You can access to the project website at
<a href="https://github.com/USCCANA/netdiffuseR">https://github.com/USCCANA/netdiffuseR</a>
</p>


<h3>Details</h3>

<p>Analysis of Diffusion and Contagion Processes on Networks
</p>


<h3>Acknowledgements</h3>

<p>netdiffuseR was created with the support of grant R01 CA157577 from the National Cancer Institute/National Institutes of Health.
</p>


<h3>Workshops and Tutorials</h3>

<p>Online you can find several learning resources:
</p>

<ul>
<li><p> Sunbelt 2016 <a href="https://github.com/USCCANA/netdiffuser-sunbelt2016">https://github.com/USCCANA/netdiffuser-sunbelt2016</a>
</p>
</li>
<li><p> NASN 2017 <a href="https://github.com/USCCANA/netdiffuser-nasn2017">https://github.com/USCCANA/netdiffuser-nasn2017</a>
</p>
</li>
<li><p> Sunbelt 2018 <a href="https://github.com/USCCANA/netdiffuser-sunbelt2018">https://github.com/USCCANA/netdiffuser-sunbelt2018</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>

<hr>
<h2 id='+25+2A+25'>Matrix multiplication</h2><span id='topic++25+2A+25'></span><span id='topic++25+2A+25.default'></span><span id='topic++25+2A+25.diffnet'></span>

<h3>Description</h3>

<p>Matrix multiplication methods, including <code><a href="#topic+diffnet">diffnet</a></code>
objects. This function creates a generic method for <code><a href="base.html#topic+matmult">%*%</a></code>
allowing for multiplying diffnet objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %*% y

## Default S3 method:
x %*% y

## S3 method for class 'diffnet'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B2A+2B25_+3A_x">x</code></td>
<td>
<p>Numeric or complex matrices or vectors, or <code>diffnet</code> objects.</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25_+3A_y">y</code></td>
<td>
<p>Numeric or complex matrices or vectors, or <code>diffnet</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be usefult to generate alternative graphs, for
example, users could compute the n-steps graph by doing <code>net %*% net</code>
(see examples).
</p>


<h3>Value</h3>

<p>In the case of <code>diffnet</code> objects performs matrix multiplication
via <code><a href="base.html#topic+mapply">mapply</a></code> using <code>x$graph</code> and <code>y$graph</code> as arguments,
returnling a <code>diffnet</code>. Otherwise returns the default according to
<code><a href="base.html#topic+matmult">%*%</a></code>.
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Finding the Simmelian Ties network ----------------------------------------

# Random diffnet graph
set.seed(773)
net &lt;- rdiffnet(100, 4, seed.graph='small-world', rgraph.args=list(k=8))
netsim &lt;- net

# According to Dekker (2006), Simmelian ties can be computed as follows
netsim &lt;- net * t(net) # Keeping mutal
netsim &lt;- netsim * (netsim %*% netsim)

# Checking out differences (netsim should have less)
nlinks(net)
nlinks(netsim)

mapply(`-`, nlinks(net), nlinks(netsim))

</code></pre>

<hr>
<h2 id='approx_geodesic'>Approximate Geodesic Distances</h2><span id='topic+approx_geodesic'></span><span id='topic+Geodesic'></span><span id='topic+Shortest-Path'></span><span id='topic+approx_geodist'></span>

<h3>Description</h3>

<p>Computes approximate geodesic distance matrix using graph powers and keeping
the amount of memory used low.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_geodesic(graph, n = 6L, warn = FALSE)

approx_geodist(graph, n = 6L, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_geodesic_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="approx_geodesic_+3A_n">n</code></td>
<td>
<p>Integer scalar. Degree of approximation. Bigger values increase
precision (see details).</p>
</td></tr>
<tr><td><code id="approx_geodesic_+3A_warn">warn</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, it warns if the algorithm
performs less steps than required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While both <span class="pkg">igraph</span> and <span class="pkg">sna</span> offer very good and computationally
efficient routines for computing geodesic distances, both functions return
dense matrices, i.e. not sparse, which can be troublesome. Furthermore,
from the perspective of social network analysis, path lengths of more than 6 steps,
for example, may not be meaningful, or at least, relevant for the researcher.
In such cases, <code>approx_geodesic</code> serves as a solution to this problem,
computing geodesics up to the number of steps, <code>n</code>, desired, hence,
if <code>n = 6</code>, once the algorithm finds all paths of 6 or less steps it
will stop, returning a sparse matrix with zeros for those pairs of
vertices for which it was not able to find a path with less than <code>n</code>
steps.
</p>
<p>Depending on the graph size and density, <code>approx_geodesic</code>'s performance
can be compared to that of <code><a href="sna.html#topic+geodist">sna::geodist</a></code>. Although,
as <code>n</code> increases, <code>geodist</code> becomes a better alternative.
</p>
<p>The algorithm was implemented using power graphs. At each itereation i the
power graph of order <code>i</code> is computed, and its values are compared
to the current values of the geodesic matrix (which is initialized in zero).
</p>

<ol>
<li><p> Initialize the output <code>ans(n, n)</code>
</p>
</li>
<li><p> For <code>i=1</code> to <code>i &lt; n</code> do
</p>

<ol>
<li><p> Iterate through the edges of <code>G^i</code>, if <code>ans</code> has a zero
value in the corresponding row+column, replace it with <code>i</code>
</p>
</li>
<li><p> next
</p>
</li></ol>

</li>
<li><p> Replace all diagonal elements with a zero and return.
</p>
</li></ol>

<p>This implementation can be more memory efficient that the aforementioned ones,
but at the same time it can be significant slower.
</p>
<p><code>approx_geodist</code> is just an allias for <code>approx_geodesic</code>.
</p>


<h3>Value</h3>

<p>A sparse matrix of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> of size
<code>nnodes(graph)^2</code> with geodesic distances up to <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A very simple example -----------------------------------------------------
g &lt;- ring_lattice(10, 3)
approx_geodesic(g, 6)
sna::geodist(as.matrix(g))[[2]]
igraph::distances(
  igraph::graph_from_adjacency_matrix(g, mode = "directed"),
  mode = "out"
)

</code></pre>

<hr>
<h2 id='as_dgCMatrix'>Coerce a matrix-like objects to <code>dgCMatrix</code> (sparse matrix)</h2><span id='topic+as_dgCMatrix'></span><span id='topic+as.dgCMatrix'></span><span id='topic+as_spmat'></span><span id='topic+as_dgCMatrix.default'></span><span id='topic+as_dgCMatrix.diffnet'></span><span id='topic+as_dgCMatrix.array'></span><span id='topic+as_dgCMatrix.igraph'></span><span id='topic+as_dgCMatrix.network'></span><span id='topic+as_dgCMatrix.list'></span>

<h3>Description</h3>

<p>This helper function allows easy coercion to sparse matrix objects
from the <span class="pkg">Matrix</span> package, <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dgCMatrix(x, make.dimnames = TRUE, ...)

as.dgCMatrix(x, make.dimnames = TRUE, ...)

as_spmat(x, make.dimnames = TRUE, ...)

## Default S3 method:
as_dgCMatrix(x, make.dimnames = TRUE, ...)

## S3 method for class 'diffnet'
as_dgCMatrix(x, make.dimnames = TRUE, ...)

## S3 method for class 'array'
as_dgCMatrix(x, make.dimnames = TRUE, ...)

## S3 method for class 'igraph'
as_dgCMatrix(x, make.dimnames = TRUE, ...)

## S3 method for class 'network'
as_dgCMatrix(x, make.dimnames = TRUE, ...)

## S3 method for class 'list'
as_dgCMatrix(x, make.dimnames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dgCMatrix_+3A_x">x</code></td>
<td>
<p>An object to be coerced into a sparse matrix.</p>
</td></tr>
<tr><td><code id="as_dgCMatrix_+3A_make.dimnames">make.dimnames</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, it makes sure that the
returned object has dimnames.</p>
</td></tr>
<tr><td><code id="as_dgCMatrix_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of the <code>igraph</code> and <code>network</code> methods, <code>...</code> is passed to
<code><a href="igraph.html#topic+as_adj">as_adj</a></code> and <code><a href="network.html#topic+as.matrix.network">as.matrix.network</a></code>
respectively.
</p>


<h3>Value</h3>

<p>Either a list with <code>dgCMatrix</code> objects or a <code>dgCMatrix</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1231)
x &lt;- rgraph_er(10)

# From matrix object
as_dgCMatrix(as.matrix(x))

# From a network object
as_dgCMatrix(network::as.network(as.matrix(x)))

# From igraph object
as_dgCMatrix(igraph::graph_from_adjacency_matrix(x))

# From array
myarray &lt;- array(dim=c(10,10,2))
myarray[,,1] &lt;- as.matrix(x)
myarray[,,2] &lt;- as.matrix(x)

myarray
as_dgCMatrix(myarray)

# From a diffnet object
ans &lt;- as_dgCMatrix(medInnovationsDiffNet)
str(ans)


</code></pre>

<hr>
<h2 id='as.array.diffnet'>Coerce a diffnet graph into an array</h2><span id='topic+as.array.diffnet'></span>

<h3>Description</h3>

<p>Coerce a diffnet graph into an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array.diffnet_+3A_x">x</code></td>
<td>
<p>A diffnet object.</p>
</td></tr>
<tr><td><code id="as.array.diffnet_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the list of sparse matrices stored in <code>x</code> and creates
an array with them. Attributes and other elements from the diffnet object are
dropped.
</p>
<p><code>dimnames</code> are obtained from the metadata of the diffnet object.
</p>


<h3>Value</h3>

<p>A three-dimensional array of <code class="reqn">T</code> matrices of size <code class="reqn">n\times n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffnet">diffnet</a></code>.
</p>
<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a random diffnet object
set.seed(84117)
mydiffnet &lt;- rdiffnet(30, 5)

# Coercing it into an array
as.array(mydiffnet)
</code></pre>

<hr>
<h2 id='bass'>Bass Model</h2><span id='topic+bass'></span><span id='topic+fitbass'></span><span id='topic+fitbass.diffnet'></span><span id='topic+fitbass.default'></span><span id='topic+plot.diffnet_bass'></span><span id='topic+bass_F'></span><span id='topic+bass_dF'></span><span id='topic+bass_f'></span>

<h3>Description</h3>

<p>Fits the Bass Diffusion model. In particular, fits an observed curve of
proportions of adopters to <code class="reqn">F(t)</code>, the proportion of adopters at time
<code class="reqn">t</code>, finding the corresponding coefficients <code class="reqn">p</code>, Innovation rate,
and <code class="reqn">q</code>, imitation rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitbass(dat, ...)

## S3 method for class 'diffnet'
fitbass(dat, ...)

## Default S3 method:
fitbass(dat, ...)

## S3 method for class 'diffnet_bass'
plot(
  x,
  y = 1:length(x$m$lhs()),
  add = FALSE,
  pch = c(21, 24),
  main = "Bass Diffusion Model",
  ylab = "Proportion of adopters",
  xlab = "Time",
  type = c("b", "b"),
  lty = c(2, 1),
  col = c("black", "black"),
  bg = c("lightblue", "gray"),
  include.legend = TRUE,
  ...
)

bass_F(Time, p, q)

bass_dF(p, q, Time)

bass_f(Time, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bass_+3A_dat">dat</code></td>
<td>
<p>Either a diffnet object, or a numeric vector.
Observed cumulative proportion of adopters.</p>
</td></tr>
<tr><td><code id="bass_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="bass_+3A_x">x</code></td>
<td>
<p>An object of class <code>diffnet_bass</code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_y">y</code></td>
<td>
<p>Integer vector. Time (label).</p>
</td></tr>
<tr><td><code id="bass_+3A_add">add</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_pch">pch</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_main">main</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. Label of the <code>y</code> axis.</p>
</td></tr>
<tr><td><code id="bass_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. Label of the <code>x</code> axis.</p>
</td></tr>
<tr><td><code id="bass_+3A_type">type</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_lty">lty</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_col">col</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_bg">bg</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+plot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_include.legend">include.legend</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, draws a legend.</p>
</td></tr>
<tr><td><code id="bass_+3A_time">Time</code></td>
<td>
<p>Integer vector with values greater than 0. The <code class="reqn">t</code> parameter.</p>
</td></tr>
<tr><td><code id="bass_+3A_p">p</code></td>
<td>
<p>Numeric scalar. Coefficient of innovation.</p>
</td></tr>
<tr><td><code id="bass_+3A_q">q</code></td>
<td>
<p>Numeric scalar. Coefficient of imitation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits the bass model with parameters <code class="reqn">[p, q]</code> for
values <code class="reqn">t = 1, 2, \dots, T</code>, in particular, it fits the following function:
</p>
<p style="text-align: center;"><code class="reqn">
  F(t) = \frac{1 - \exp{-(p+q)t}}{1 + \frac{q}{p}\exp{-(p+q)t}}
</code>
</p>

<p>Which is implemented in the <code>bass_F</code> function. The proportion of adopters
at time <code class="reqn">t</code>, <code class="reqn">f(t)</code> is:
</p>
<p style="text-align: center;"><code class="reqn">
  f(t) = \left\{\begin{array}{ll}
  F(t), &amp; t = 1 \\
  F(t) - F(t-1), &amp; t &gt; 1
  \end{array}\right.
</code>
</p>

<p>and it's implemented in the <code>bass_f</code> function.
</p>
<p>For testing purposes only, the gradient of <code class="reqn">F</code> with respect to <code class="reqn">p</code>
and <code class="reqn">q</code> is implemented in <code>bass_dF</code>.
</p>
<p>The estimation is done using <code><a href="stats.html#topic+nls">nls</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>nls</code> and <code>diffnet_bass</code>. For more
details, see <code><a href="stats.html#topic+nls">nls</a></code> in the <span class="pkg">stats</span> package.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Bass's Basement Institute Institute. The Bass Model. (2010).
Available at: <a href="https://web.archive.org/web/20220331222618/http://www.bassbasement.org/BassModel/">https://web.archive.org/web/20220331222618/http://www.bassbasement.org/BassModel/</a>.
(accessed live for the last time on March 29th, 2017.)
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fitting the model for the Brazilian Farmers Data --------------------------
data(brfarmersDiffNet)
ans &lt;- fitbass(brfarmersDiffNet)

# All the methods that work for the -nls- object work here
ans
summary(ans)
coef(ans)
vcov(ans)

# And the plot method returns both, fitted and observed curve
plot(ans)

</code></pre>

<hr>
<h2 id='bootnet'>Network Bootstrapping</h2><span id='topic+bootnet'></span><span id='topic+resample_graph'></span><span id='topic+c.diffnet_bootnet'></span><span id='topic+print.diffnet_bootnet'></span><span id='topic+hist.diffnet_bootnet'></span><span id='topic+plot.diffnet_bootnet'></span>

<h3>Description</h3>

<p>Implements the bootstrapping method described in Snijders and Borgatti (1999).
This function is essentially a wrapper of <code><a href="boot.html#topic+boot">boot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_graph(graph, self = NULL, useR = FALSE, ...)

bootnet(graph, statistic, R, resample.args = list(self = FALSE), ...)

## S3 method for class 'diffnet_bootnet'
c(..., recursive = FALSE)

## S3 method for class 'diffnet_bootnet'
print(x, ...)

## S3 method for class 'diffnet_bootnet'
hist(
  x,
  main = "Empirical Distribution of Statistic",
  xlab = expression(Values ~ of ~ t),
  breaks = 20,
  annotated = TRUE,
  b0 = expression(atop(plain("") %up% plain("")), t[0]),
  b = expression(atop(plain("") %up% plain("")), t[]),
  ask = TRUE,
  ...
)

## S3 method for class 'diffnet_bootnet'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootnet_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="bootnet_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="bootnet_+3A_user">useR</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, autolinks are filled using an
<span class="rlang"><b>R</b></span> based rutine. Otherwise it uses the <span class="pkg">Rcpp</span> implementation (default).
This is intended for testing only.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method (see details).</p>
</td></tr>
<tr><td><code id="bootnet_+3A_statistic">statistic</code></td>
<td>
<p>A function that returns a vector with the statistic(s) of interest.
The first argument must be the graph, and the second argument a vector of indices
(see details)</p>
</td></tr>
<tr><td><code id="bootnet_+3A_r">R</code></td>
<td>
<p>Number of reps</p>
</td></tr>
<tr><td><code id="bootnet_+3A_resample.args">resample.args</code></td>
<td>
<p>List. Arguments to be passed to <code><a href="#topic+resample_graph">resample_graph</a></code></p>
</td></tr>
<tr><td><code id="bootnet_+3A_recursive">recursive</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="bootnet_+3A_x">x</code></td>
<td>
<p>A <code>diffnet_bootnet</code> class object.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the histogram.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. x-axis label.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_annotated">annotated</code></td>
<td>
<p>Logical scalar. When TRUE marks the observed data average and the simulated data average.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_b0">b0</code></td>
<td>
<p>Character scalar. When <code>annotated=TRUE</code>, label for the value of <code>b0</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_b">b</code></td>
<td>
<p>Character scalar. When <code>annotated=TRUE</code>, label for the value of <code>b</code>.</p>
</td></tr>
<tr><td><code id="bootnet_+3A_ask">ask</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, asks the user to type <code>&lt;Enter&gt;</code> to
see each plot (as many as statistics where computed).</p>
</td></tr>
<tr><td><code id="bootnet_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just like the <code>boot</code> function of the <span class="pkg">boot</span> package, the <code>statistic</code>
that is passed must have as arguments the original data (the graph in this case),
and a vector of indicides. In each repetition, the graph that is passed is a
resampled version generated as described in Snijders and Borgatti (1999).
</p>
<p>When <code>self = FALSE</code>, for pairs of individuals that haven been drawn more than
once the algorithm, in particular, <code>resample_graph</code>, takes care of filling
these pseudo autolinks that are not in the diagonal of the network. By default
it is assumed that these pseudo-autolinks depend on whether the original graph
had any, hence, if the diagonal has any non-zero value the algorithm assumes that
<code>self = TRUE</code>, skiping the 'filling algorithm'. It is important to notice
that, in order to preserve the density of the original network, when
assigning an edge value to a pair of the form <code class="reqn">(i,i)</code> (pseudo-autolinks),
such is done with probabilty proportional to the density of the network, in
other words, before choosing from the existing list of edge values, the
algorithm decides whether to set a zero value first.
</p>
<p>The vector of indices that is passed to <code>statistic</code>, an integer vector with range
1 to <code class="reqn">n</code>, corresponds to the drawn sample of nodes, so the user can, for
example, use it to get a subset of a <code>data.frame</code> that will be used with
the <code>graph</code>.
</p>
<p>The 'plot.diffnet_bootnet' method is a wrapper for the
'hist' method.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet_bootnet</code> containing the following:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The graph passed to <code>bootnet</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The resulting p-value of the test (see details).</p>
</td></tr>
<tr><td><code>t0</code></td>
<td>
<p>The observed value of the statistic.</p>
</td></tr>
<tr><td><code>mean_t</code></td>
<td>
<p>The average value of the statistic applied to the simulated networks.</p>
</td></tr>
<tr><td><code>var_t</code></td>
<td>
<p>A vector of length <code>length(t0)</code>. Bootstrap variances.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The function <code>statistic</code> passed to <code>bootnet</code>.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>A <code>boot</code> class object as return from the call to <code>boot</code>.</p>
</td></tr>
<tr><td><code>resample.args</code></td>
<td>
<p>The list <code>resample.args</code> passed to <code>bootnet</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Snijders, T. A. B., &amp; Borgatti, S. P. (1999). Non-Parametric
Standard Errors and Tests for Network Statistics. Connections, 22(2), 1–10.
Retrieved from <a href="https://www.stats.ox.ac.uk/~snijders/Snijders_Borgatti.pdf">https://www.stats.ox.ac.uk/~snijders/Snijders_Borgatti.pdf</a>
</p>


<h3>See Also</h3>

<p>Other Functions for inference: 
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_test">struct_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computing edgecount -------------------------------------------------------
set.seed(13)
g &lt;- rgraph_ba(t=99)

ans &lt;- bootnet(g, function(w, ...) length(w@x), R=100)
ans

# Generating
</code></pre>

<hr>
<h2 id='brfarmers'>Brazilian Farmers</h2><span id='topic+brfarmers'></span>

<h3>Description</h3>

<p>From Valente (1995) &ldquo;In the mid-1960s, Rogers and others conducted
an ambitious &lsquo;three country study&rsquo; to determine influences on adoption
of farm practices in Nigeria, India and Brazil. [...] Only in Brazil, and
only for hybrid corn, did adoption of the innovation reach more than a small
proportion of the farmers.&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brfarmers
</code></pre>


<h3>Format</h3>

<p>A data frame with 692 rows and 148 columns:
</p>

<dl>
<dt>village</dt><dd><p>village number</p>
</dd>
<dt>idold</dt><dd><p>respondent id</p>
</dd>
<dt>age</dt><dd><p>respondent's age</p>
</dd>
<dt>liveout</dt><dd><p>Lived outside of community</p>
</dd>
<dt>visits</dt><dd><p># of visits to large city</p>
</dd>
<dt>contact</dt><dd><p># of contacts with relatives</p>
</dd>
<dt>coop</dt><dd><p>membership in coop</p>
</dd>
<dt>orgs</dt><dd><p>membership in organizations</p>
</dd>
<dt>patry</dt><dd><p>Patriarchalism score</p>
</dd>
<dt>liter</dt><dd><p>Literate</p>
</dd>
<dt>news1</dt><dd><p># of newspapers or mags pr mon</p>
</dd>
<dt>subs</dt><dd><p>subscribe to news</p>
</dd>
<dt>radio1</dt><dd><p>Own radio</p>
</dd>
<dt>radio2</dt><dd><p>Frequency radio listening</p>
</dd>
<dt>radio3</dt><dd><p>program preference</p>
</dd>
<dt>tv</dt><dd><p>frequency Tv viewing</p>
</dd>
<dt>movie</dt><dd><p>freq movie attendance</p>
</dd>
<dt>letter</dt><dd><p>freq letter writing</p>
</dd>
<dt>source</dt><dd><p>total # of sources used for ag</p>
</dd>
<dt>practA</dt><dd><p>Ever used practice A</p>
</dd>
<dt>practB</dt><dd><p>Ever used practice B</p>
</dd>
<dt>practC</dt><dd><p>Ever used practice C</p>
</dd>
<dt>practD</dt><dd><p>Ever used practice D</p>
</dd>
<dt>practE</dt><dd><p>Ever used practice E</p>
</dd>
<dt>practF</dt><dd><p>Ever used practice F</p>
</dd>
<dt>practG</dt><dd><p>Ever used practice G</p>
</dd>
<dt>practH</dt><dd><p>Ever used practice H</p>
</dd>
<dt>practI</dt><dd><p>Ever used practice I</p>
</dd>
<dt>practJ</dt><dd><p>Ever used practice J</p>
</dd>
<dt>practK</dt><dd><p>Ever used practice K</p>
</dd>
<dt>practL</dt><dd><p>Ever used practice L</p>
</dd>
<dt>yrA</dt><dd><p>A year of adoption</p>
</dd>
<dt>yrB</dt><dd><p>B year of adoption</p>
</dd>
<dt>yrC</dt><dd><p>C year of adoption</p>
</dd>
<dt>yrD</dt><dd><p>D year of adoption</p>
</dd>
<dt>yrE</dt><dd><p>E year of adoption</p>
</dd>
<dt>yrF</dt><dd><p>F year of adoption</p>
</dd>
<dt>yrG</dt><dd><p>G year of adoption</p>
</dd>
<dt>yrH</dt><dd><p>H year of adoption</p>
</dd>
<dt>yrI</dt><dd><p>I year of adoption</p>
</dd>
<dt>yrJ</dt><dd><p>J year of adoption</p>
</dd>
<dt>yrK</dt><dd><p>K year of adoption</p>
</dd>
<dt>yrL</dt><dd><p>L year of adoption</p>
</dd>
<dt>curA</dt><dd><p>A Current use</p>
</dd>
<dt>curB</dt><dd><p>B Current use</p>
</dd>
<dt>curC</dt><dd><p>C Current use</p>
</dd>
<dt>curD</dt><dd><p>D Current use</p>
</dd>
<dt>curE</dt><dd><p>E Current use</p>
</dd>
<dt>curF</dt><dd><p>F Current use</p>
</dd>
<dt>curG</dt><dd><p>G Current use</p>
</dd>
<dt>curH</dt><dd><p>H Current use</p>
</dd>
<dt>curI</dt><dd><p>I Current use</p>
</dd>
<dt>curJ</dt><dd><p>J Current use</p>
</dd>
<dt>curK</dt><dd><p>K Current use</p>
</dd>
<dt>curL</dt><dd><p>L Current use</p>
</dd>
<dt>srce1</dt><dd><p>Source of aware in A</p>
</dd>
<dt>timeA</dt><dd><p>Years ago 1st aware</p>
</dd>
<dt>src2</dt><dd><p>Source of more info on A</p>
</dd>
<dt>src3</dt><dd><p>Most influential source</p>
</dd>
<dt>use</dt><dd><p>use during trial stage</p>
</dd>
<dt>total</dt><dd><p>total # of practices adopted</p>
</dd>
<dt>futatt</dt><dd><p>Future attitude</p>
</dd>
<dt>achiev</dt><dd><p>Achievement Score</p>
</dd>
<dt>attcred</dt><dd><p>Attitude toward credit</p>
</dd>
<dt>littest</dt><dd><p>Score on functional literacy t</p>
</dd>
<dt>acarcomm</dt><dd><p>Communication with ACAR repres</p>
</dd>
<dt>econk</dt><dd><p>Economic knowledge</p>
</dd>
<dt>caact</dt><dd><p>recognize any change agent act</p>
</dd>
<dt>hfequip</dt><dd><p># of home &amp; farm equips owned</p>
</dd>
<dt>politk</dt><dd><p>political knowledge score</p>
</dd>
<dt>income</dt><dd><p>income</p>
</dd>
<dt>land1</dt><dd><p>total land area in pasture</p>
</dd>
<dt>land2</dt><dd><p>total land area planted</p>
</dd>
<dt>cows</dt><dd><p># of cows giving milk</p>
</dd>
<dt>land3</dt><dd><p>total land owned</p>
</dd>
<dt>respf</dt><dd><p>respondent named as friend</p>
</dd>
<dt>respa</dt><dd><p>respondent named as ag adv</p>
</dd>
<dt>resppa</dt><dd><p>respondent named for practic A</p>
</dd>
<dt>resppb</dt><dd><p>respondent named for practic B</p>
</dd>
<dt>resppc</dt><dd><p>respondent named for practic C</p>
</dd>
<dt>poly</dt><dd><p>polymorphic OL for 3 practices</p>
</dd>
<dt>respl</dt><dd><p>respondent named for loan</p>
</dd>
<dt>resppi</dt><dd><p>resp named for price info</p>
</dd>
<dt>repsccp</dt><dd><p>resp named for coop comm proj</p>
</dd>
<dt>counter</dt><dd><p>counterfactuality score</p>
</dd>
<dt>opinion</dt><dd><p>opinionness score</p>
</dd>
<dt>school</dt><dd><p>years of schooling by resp</p>
</dd>
<dt>pk1</dt><dd><p>political know 1</p>
</dd>
<dt>pk2</dt><dd><p>political know 2</p>
</dd>
<dt>pk3</dt><dd><p>political know 3</p>
</dd>
<dt>pk4</dt><dd><p>political know 4</p>
</dd>
<dt>pk5</dt><dd><p>political know 5</p>
</dd>
<dt>innovtim</dt><dd><p>innovativeness time</p>
</dd>
<dt>adoptpct</dt><dd><p>adoption percent</p>
</dd>
<dt>discon</dt><dd><p># of practices discontinued</p>
</dd>
<dt>mmcred</dt><dd><p>Mass media credibility</p>
</dd>
<dt>trust</dt><dd><p>Trust</p>
</dd>
<dt>stusincn</dt><dd><p>Status inconsistency</p>
</dd>
<dt>nach</dt><dd><p>N achievement motivation</p>
</dd>
<dt>attcred2</dt><dd><p>Attitude toward credit</p>
</dd>
<dt>risk</dt><dd><p>Risk taking</p>
</dd>
<dt>socpart</dt><dd><p>Social participate</p>
</dd>
<dt>patriarc</dt><dd><p>patriarchy</p>
</dd>
<dt>crdit2</dt><dd><p>attit to credit for product</p>
</dd>
<dt>visicit</dt><dd><p>visitin cities</p>
</dd>
<dt>nondep</dt><dd><p>non-dependence on farming</p>
</dd>
<dt>oltotal</dt><dd><p>OL total 7 items t-score</p>
</dd>
<dt>innov</dt><dd><p>overall innovativeness score</p>
</dd>
<dt>icosmo</dt><dd><p>cosmo index</p>
</dd>
<dt>immexp</dt><dd><p>mass media exposure index</p>
</dd>
<dt>iempath</dt><dd><p>empathy index</p>
</dd>
<dt>iach5</dt><dd><p>achievement motivation index 5</p>
</dd>
<dt>iach7</dt><dd><p>achievement motivation index 7</p>
</dd>
<dt>ipk</dt><dd><p>political knowledge index</p>
</dd>
<dt>immc</dt><dd><p>mass media credibililty index</p>
</dd>
<dt>iol</dt><dd><p>OL index</p>
</dd>
<dt>yr</dt><dd><p>Actual Year of Adoption</p>
</dd>
<dt>fs</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>ado</dt><dd><p>Time of Adoption</p>
</dd>
<dt>tri</dt><dd><p>Triangular values used as appro</p>
</dd>
<dt>hlperc</dt><dd><p>high low percent of diffusion</p>
</dd>
<dt>hlperc1</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>new</dt><dd><p>new or old villages</p>
</dd>
<dt>card1</dt><dd><p>card number</p>
</dd>
<dt>sour1</dt><dd><p>Source: radio</p>
</dd>
<dt>sour2</dt><dd><p>Source: TV</p>
</dd>
<dt>sour3</dt><dd><p>Source: Newpaper</p>
</dd>
<dt>sour4</dt><dd><p>Source: Magazine</p>
</dd>
<dt>sour5</dt><dd><p>Source: ACAR Bulletin</p>
</dd>
<dt>sour6</dt><dd><p>Source: Agronomist</p>
</dd>
<dt>sour7</dt><dd><p>Source: Neighbor</p>
</dd>
<dt>sourc6</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>adopt</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>net31</dt><dd><p>nomination friend 1</p>
</dd>
<dt>net32</dt><dd><p>nomination friend 2</p>
</dd>
<dt>net33</dt><dd><p>nomination friend 3</p>
</dd>
<dt>net21</dt><dd><p>nomination influential 1</p>
</dd>
<dt>net22</dt><dd><p>nomination influential 2</p>
</dd>
<dt>net23</dt><dd><p>nomination influential 3</p>
</dd>
<dt>net11</dt><dd><p>nomination practice A</p>
</dd>
<dt>net12</dt><dd><p>nomination practice B</p>
</dd>
<dt>net13</dt><dd><p>nomination practice C</p>
</dd>
<dt>net41</dt><dd><p>nomination coop comm proj</p>
</dd>
<dt>id</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>commun</dt><dd><p>Number of community</p>
</dd>
<dt>toa</dt><dd><p>Time of Adoption</p>
</dd>
<dt>test</dt><dd><p> &mdash; MISSING INFO &mdash; </p>
</dd>
<dt>study</dt><dd><p>Number of study in Valente (1995)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset has 692 respondents (farmers) from 11 communities. Collected
during 1966, it spans 20 years of farming pracitices.
</p>


<h3>Source</h3>

<p>The Brazilian Farmers data were collected as part of a USAID-funded study of farming
practicing in the three countries, India, Nigeria, and Brazil.
There was only one wave of data that contained survey questions regarding
social networks, and only in Brazil did diffusion of the studied farming
innovations reach an appreciable saturation level- that was for hybrid seed
corn. The data were stored along with hundreds of other datasets by the
University of Wisconsin library and I, Tom Valente, paid a fee to have the
disks mailed to me in the early 1990s.
</p>


<h3>References</h3>

<p>Rogers, E. M., Ascroft, J. R., &amp; Röling, N. (1970). Diffusion of Innovation
in Brazil, Nigeria, and India. Unpublished Report. Michigan State University,
East Lansing.
</p>
<p>Valente, T. W. (1995). Network models of the diffusion of innovations (2nd ed.).
Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='brfarmersDiffNet'><code>diffnet</code> version of the Brazilian Farmers data</h2><span id='topic+brfarmersDiffNet'></span>

<h3>Description</h3>

<p>A directed dynamic graph with 692 vertices and 21 time periods. The attributes
in the graph are static and described in <code><a href="#topic+brfarmers">brfarmers</a></code>.
</p>


<h3>Format</h3>

<p>A <code><a href="#topic+diffnet">diffnet</a></code> class object.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='c.diffnet'>Combine diffnet objects</h2><span id='topic+c.diffnet'></span>

<h3>Description</h3>

<p>Combining <code><a href="#topic+diffnet">diffnet</a></code> objects that share time periods and attributes names, but
vertices ids (only valid for diffnet objects that have an empty intersection
between vertices ids).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.diffnet_+3A_...">...</code></td>
<td>
<p>diffnet objects to be concatenated.</p>
</td></tr>
<tr><td><code id="c.diffnet_+3A_recursive">recursive</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diffnet objects in <code>...</code> must fulfill the following conditions:
</p>

<ol>
<li><p> Have the same time range,
</p>
</li>
<li><p> have the same vertex attributes, and
</p>
</li>
<li><p> have an empty intersection of vertices ids,
</p>
</li></ol>

<p>The meta data regarding <code>undirected</code>, <code>value</code>, and <code>multiple</code>
are set to <code>TRUE</code> if any of the concatenating diffnet objects has that
meta equal to <code>TRUE</code>.
</p>
<p>The resulting diffnet object's columns in the vertex attributes ordering (both
dynamic and static) will coincide with the first diffnet's ordering.
</p>


<h3>Value</h3>

<p>A new <code>diffnet</code> object with as many vertices as the sum of each
concatenated diffnet objects' number of vertices.
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate structural equivalence exposure by city -------------------------
data(medInnovationsDiffNet)

# Subsetting diffnets
city1 &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == 1]
city2 &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == 2]
city3 &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == 3]
city4 &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == 4]

# Computing exposure in each one
city1[["expo_se"]] &lt;- exposure(city1, alt.graph="se", valued=TRUE)
city2[["expo_se"]] &lt;- exposure(city2, alt.graph="se", valued=TRUE)
city3[["expo_se"]] &lt;- exposure(city3, alt.graph="se", valued=TRUE)
city4[["expo_se"]] &lt;- exposure(city4, alt.graph="se", valued=TRUE)

# Concatenating all
diffnet &lt;- c(city1, city2, city3, city4)
diffnet


</code></pre>

<hr>
<h2 id='classify_adopters'>Classify adopters accordingly to Time of Adoption and Threshold levels.</h2><span id='topic+classify_adopters'></span><span id='topic+classify'></span><span id='topic+classify_adopters.diffnet'></span><span id='topic+classify_adopters.default'></span><span id='topic+ftable.diffnet_adopters'></span><span id='topic+as.data.frame.diffnet_adopters'></span><span id='topic+plot.diffnet_adopters'></span>

<h3>Description</h3>

<p>Adopters are classified as in Valente (1995). In general, this is done
depending on the distance in terms of standard deviations from the mean of
Time of Adoption and Threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_adopters(...)

classify(...)

## S3 method for class 'diffnet'
classify_adopters(graph, include_censored = FALSE, ...)

## Default S3 method:
classify_adopters(
  graph,
  toa,
  t0 = NULL,
  t1 = NULL,
  expo = NULL,
  include_censored = FALSE,
  ...
)

## S3 method for class 'diffnet_adopters'
ftable(x, as.pcent = TRUE, digits = 2, ...)

## S3 method for class 'diffnet_adopters'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'diffnet_adopters'
plot(x, y = NULL, ftable.args = list(), table.args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_adopters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_include_censored">include_censored</code></td>
<td>
<p>Logical scalar, passed to <code><a href="#topic+threshold">threshold</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_toa">toa</code></td>
<td>
<p>Integer vector of length <code class="reqn">n</code> with times of adoption.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_t0">t0</code></td>
<td>
<p>Integer scalar passed to <code><a href="#topic+threshold">threshold</a></code> and <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_t1">t1</code></td>
<td>
<p>Integer scalar passed to <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_expo">expo</code></td>
<td>
<p>Numeric matrix of size <code class="reqn">n\times T</code> with network exposures.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_x">x</code></td>
<td>
<p>A <code>diffnet_adopters</code> class object.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_as.pcent">as.pcent</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> returns a table with percentages
instead.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_digits">digits</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="base.html#topic+round">round</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_row.names">row.names</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_optional">optional</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_ftable.args">ftable.args</code></td>
<td>
<p>List of arguments passed to <code><a href="stats.html#topic+ftable">ftable</a></code>.</p>
</td></tr>
<tr><td><code id="classify_adopters_+3A_table.args">table.args</code></td>
<td>
<p>List of arguments passed to <code><a href="base.html#topic+table">table</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classifies (only) adopters according to time of adoption and threshold as
described in Valente (1995). In particular, the categories are defined as follow:
</p>
<p>For Time of Adoption, with <code>toa</code> as the vector of times of adoption:
</p>

<ul>
<li> <p><em>Early Adopters</em>: <code>toa[i] &lt;= mean(toa) - sd(toa)</code>,
</p>
</li>
<li> <p><em>Early Majority</em>: <code>mean(toa) - sd(toa) &lt; toa[i] &lt;= mean(toa) </code>,
</p>
</li>
<li> <p><em>Late Majority</em>: <code>mean(toa) &lt; toa[i] &lt;= mean(toa) + sd(toa) </code>, and
</p>
</li>
<li> <p><em>Laggards</em>: <code>mean(toa) + sd(toa) &lt; toa[i] </code>.
</p>
</li></ul>

<p>For Threshold levels, with <code>thr</code> as the vector of threshold levels:
</p>

<ul>
<li> <p><em>Very Low Thresh.</em>: <code>thr[i] &lt;= mean(thr) - sd(thr)</code>,
</p>
</li>
<li> <p><em>Low Thresh.</em>: <code>mean(thr) - sd(thr) &lt; thr[i] &lt;= mean(thr) </code>,
</p>
</li>
<li> <p><em>High Thresh.</em>: <code>mean(thr) &lt; thr[i] &lt;= mean(thr) + sd(thr) </code>, and
</p>
</li>
<li> <p><em>Very High. Thresh.</em>: <code>mean(thr) + sd(thr) &lt; thr[i] </code>.
</p>
</li></ul>

<p>By default threshold levels are not computed for left censored data. These
will have a <code>NA</code> value in the <code>thr</code> vector.
</p>
<p>The plot method, <code>plot.diffnet_adopters</code>, is a wrapper for the
<code><a href="graphics.html#topic+plot.table">plot.table</a></code> method. This generates a
<code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code> plot.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet_adopters</code> with the following elements:
</p>
<table>
<tr><td><code>toa</code></td>
<td>
<p>A factor vector of length <code class="reqn">n</code> with 4 levels:
&quot;Early Adopters&quot;, &quot;Early Majority&quot;, &quot;Late Majority&quot;, and &quot;Laggards&quot;</p>
</td></tr>
<tr><td><code>thr</code></td>
<td>
<p>A factor vector of length <code class="reqn">n</code> with 4 levels:
&quot;Very Low Thresh.&quot;, &quot;Low Thresh.&quot;, &quot;High Thresh.&quot;, and &quot;Very High Thresh.&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Valente, T. W. (1995). &quot;Network models of the diffusion of innovations&quot;
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Classifying brfarmers -----------------------------------------------------

x &lt;- brfarmersDiffNet
diffnet.toa(x)[x$toa==max(x$toa, na.rm = TRUE)] &lt;- NA
out &lt;- classify_adopters(x)

# This is one way
round(
with(out, ftable(toa, thr, dnn=c("Time of Adoption", "Threshold")))/
  nnodes(x[!is.na(x$toa)])*100, digits=2)

# This is other
ftable(out)

# Can be coerced into a data.frame, e.g. ------------------------------------
 str(classify(brfarmersDiffNet))
 ans &lt;- cbind(
 as.data.frame(classify(brfarmersDiffNet)), brfarmersDiffNet$toa
 )
 head(ans)

# Creating a mosaic plot with the medical innovations -----------------------
x &lt;- classify(medInnovationsDiffNet)
plot(x)

</code></pre>

<hr>
<h2 id='classify_graph'>Analyze an R object to identify the class of graph (if any)</h2><span id='topic+classify_graph'></span>

<h3>Description</h3>

<p>Analyze an R object to identify the class of graph (if any)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_graph_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function analyzes an R object and tries to classify it among the
accepted classes in <span class="pkg">netdiffuseR</span>. If the object fails to fall in one of
the types of graphs the function returns with an error indicating what (and
when possible, where) the problem lies.
</p>
<p>The function was designed to be used with <code><a href="#topic+as_diffnet">as_diffnet</a></code>.
</p>


<h3>Value</h3>

<p>Whe the object fits any of the accepted graph formats, a list of attributes including
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Character scalar. Whether is a static or a dynamic graph</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>Character scalar. The class of the original object</p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p>Character vector. Labels of the vertices</p>
</td></tr>
<tr><td><code>pers</code></td>
<td>
<p>Integer vector. Labels of the time periods</p>
</td></tr>
<tr><td><code>nper</code></td>
<td>
<p>Integer scalar. Number of time periods</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Integer scalar. Number of vertices in the graph</p>
</td></tr>
</table>
<p>Otherwise returns with error.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_diffnet">as_diffnet</a></code>, <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>
</p>

<hr>
<h2 id='cumulative_adopt_count'>Cummulative count of adopters</h2><span id='topic+cumulative_adopt_count'></span>

<h3>Description</h3>

<p>For each time period, calculates the number of adopters, the proportion of adopters,
and the adoption rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulative_adopt_count(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulative_adopt_count_+3A_obj">obj</code></td>
<td>
<p>A <code class="reqn">n\times T</code> matrix (Cumulative adoption matrix obtained from
<code><a href="#topic+toa_mat">toa_mat</a></code>) or a <code><a href="#topic+diffnet">diffnet</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rate of adoption&ndash;returned in the 3rd row out the resulting
matrix&ndash;is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\frac{q_t - q_{t-1}}{q_{t-1}}</code>
</p>

<p>where <code class="reqn">q_i</code> is the number of adopters in time <code class="reqn">t</code>. Note that
it is only calculated fot <code class="reqn">t&gt;1</code>.
</p>


<h3>Value</h3>

<p>A <code class="reqn">3\times T</code> matrix, where its rows contain the number of adoptes, the proportion of
adopters and the rate of adoption respectively, for earch period of time.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>

<hr>
<h2 id='dgr'>Indegree, outdegree and degree of the vertices</h2><span id='topic+dgr'></span><span id='topic+degree'></span><span id='topic+indegree'></span><span id='topic+outdegree'></span><span id='topic+plot.diffnet_degSeq'></span>

<h3>Description</h3>

<p>Computes the requested degree measure for each node in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgr(
  graph,
  cmode = "degree",
  undirected = getOption("diffnet.undirected", FALSE),
  self = getOption("diffnet.self", FALSE),
  valued = getOption("diffnet.valued", FALSE)
)

## S3 method for class 'diffnet_degSeq'
plot(
  x,
  breaks = min(100L, nrow(x)/5),
  freq = FALSE,
  y = NULL,
  log = "xy",
  hist.args = list(),
  slice = ncol(x),
  xlab = "Degree",
  ylab = "Freq",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgr_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="dgr_+3A_cmode">cmode</code></td>
<td>
<p>Character scalar. Either &quot;indegree&quot;, &quot;outdegree&quot; or &quot;degree&quot;.</p>
</td></tr>
<tr><td><code id="dgr_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="dgr_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="dgr_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered. Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="dgr_+3A_x">x</code></td>
<td>
<p>An <code>diffnet_degSeq object</code></p>
</td></tr>
<tr><td><code id="dgr_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="dgr_+3A_freq">freq</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the y-axis will reflex counts,
otherwise densities.</p>
</td></tr>
<tr><td><code id="dgr_+3A_y">y</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="dgr_+3A_log">log</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+plot">plot</a></code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="dgr_+3A_hist.args">hist.args</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="dgr_+3A_slice">slice</code></td>
<td>
<p>Integer scalar. In the case of dynamic graphs, number of time
point to plot.</p>
</td></tr>
<tr><td><code id="dgr_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. Passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="dgr_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. Passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="dgr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of size <code class="reqn">n\times T</code>. In the case of <code>plot</code>,
returns an object of class <code><a href="graphics.html#topic+hist">histogram</a></code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>
<p>Other visualizations: 
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Comparing degree measurements ---------------------------------------------
# Creating an undirected graph
graph &lt;- rgraph_ba()
graph

data.frame(
   In=dgr(graph, "indegree", undirected = FALSE),
   Out=dgr(graph, "outdegree", undirected = FALSE),
   Degree=dgr(graph, "degree", undirected = FALSE)
 )

# Testing on Korean Family Planning (weighted graph) ------------------------
data(kfamilyDiffNet)
d_unvalued &lt;- dgr(kfamilyDiffNet, valued=FALSE)
d_valued   &lt;- dgr(kfamilyDiffNet, valued=TRUE)

any(d_valued!=d_unvalued)

# Classic Scale-free plot ---------------------------------------------------
set.seed(1122)
g &lt;- rgraph_ba(t=1e3-1)
hist(dgr(g))

# Since by default uses logscale, here we suppress the warnings
# on points been discarded for &lt;=0.
suppressWarnings(plot(dgr(g)))

</code></pre>

<hr>
<h2 id='diag_expand'>Creates a square matrix suitable for spatial statistics models.</h2><span id='topic+diag_expand'></span><span id='topic+diag_expand.list'></span><span id='topic+diag_expand.diffnet'></span><span id='topic+diag_expand.matrix'></span><span id='topic+diag_expand.array'></span><span id='topic+diag_expand.dgCMatrix'></span>

<h3>Description</h3>

<p>Creates a square matrix suitable for spatial statistics models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_expand(...)

## S3 method for class 'list'
diag_expand(graph, self = is_self(graph), valued = is_valued(graph), ...)

## S3 method for class 'diffnet'
diag_expand(graph, self = is_self(graph), valued = is_valued(graph), ...)

## S3 method for class 'matrix'
diag_expand(graph, nper, self = is_self(graph), valued = is_valued(graph), ...)

## S3 method for class 'array'
diag_expand(graph, self = is_self(graph), valued = is_valued(graph), ...)

## S3 method for class 'dgCMatrix'
diag_expand(graph, nper, self = is_self(graph), valued = is_valued(graph), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_expand_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the method.</p>
</td></tr>
<tr><td><code id="diag_expand_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="diag_expand_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="diag_expand_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered. Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="diag_expand_+3A_nper">nper</code></td>
<td>
<p>Integer scalar. Number of time periods of the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> of
size <code>(nnode(g)*nper)^2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example ------------------------------------------------------------
set.seed(23)
g &lt;- rgraph_er(n=10, p=.5, t=2,undirected=TRUE)

# What we've done: A list with 2 bernoulli graphs
g

# Expanding to a 20*20 matrix with structural zeros on the diagonal
# and on cell 'off' adjacency matrix
diag_expand(g)
</code></pre>

<hr>
<h2 id='diffnet_check_attr_class'>Infer whether <code>value</code> is dynamic or static.</h2><span id='topic+diffnet_check_attr_class'></span>

<h3>Description</h3>

<p>Intended for internal use only, this function is used in <code><a href="#topic+diffnet_index">diffnet_index</a></code>
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffnet_check_attr_class(value, meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffnet_check_attr_class_+3A_value">value</code></td>
<td>
<p>Either a matrix, data frame or a list. Attribute values.</p>
</td></tr>
<tr><td><code id="diffnet_check_attr_class_+3A_meta">meta</code></td>
<td>
<p>A list. A diffnet object's meta data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value object either as a data frame (if static) or as a list
of data frames (if dynamic). If <code>value</code> does not follows the permitted
types of <code><a href="#topic+diffnet_index">diffnet_index</a></code>, then returns with error.
</p>

<hr>
<h2 id='diffnet_index'>Indexing diffnet objects (on development)</h2><span id='topic+diffnet_index'></span><span id='topic++5B+5B.diffnet'></span><span id='topic++5B+5B+3C-.diffnet'></span><span id='topic++5B.diffnet'></span><span id='topic++5B+3C-.diffnet'></span>

<h3>Description</h3>

<p>Access and assign (replace) elements from the adjacency matrices or the vertex
attributes data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
x[[name, as.df = FALSE]]

## S3 replacement method for class 'diffnet'
x[[i, j]] &lt;- value

## S3 method for class 'diffnet'
x[i, j, k, drop = FALSE]

## S3 replacement method for class 'diffnet'
x[i, j, k] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffnet_index_+3A_x">x</code></td>
<td>
<p>A diffnet class object.</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_name">name</code></td>
<td>
<p>String vector. Names of the vertices attributes.</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_as.df">as.df</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> returns a data frame, otherwise
a list of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_i">i</code></td>
<td>
<p>Index of the i-th row of the adjacency matrix (see details).</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_j">j</code></td>
<td>
<p>Index of the j-th column of the adjacency matrix (see details)</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_value">value</code></td>
<td>
<p>Value to assign (see details)</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_k">k</code></td>
<td>
<p>Index of the k-th slice of the adjacency matrix (see details).</p>
</td></tr>
<tr><td><code id="diffnet_index_+3A_drop">drop</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> returns an adjacency matrix, otherwise
a filtered diffnet object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>[[.diffnet</code> methods provides access to the diffnet attributes
data frames, static and dynamic. By providing the <code>name</code> of the corresponding
attribute, depending on whether it is static or dynamic the function will return
either a data frame&ndash;static attributes&ndash;or a list of these&ndash;dynamic attributes.
For the assigning method, <code style="white-space: pre;">&#8288;[[&lt;-.diffnet&#8288;</code>, the function will infer what
kind of attribute is by analyzing the dimensions of <code>value</code>, in particular
we have the following possible cases:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Class</strong>    </td><td style="text-align: left;"> <strong>Dimension</strong>   </td><td style="text-align: right;"> <strong>Inferred</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>matrix</code>     </td><td style="text-align: left;"> <code class="reqn">n\times T</code> </td><td style="text-align: right;"> Dynamic           </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>matrix</code>     </td><td style="text-align: left;"> <code class="reqn">n\times 1</code> </td><td style="text-align: right;"> Static            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>matrix</code>     </td><td style="text-align: left;"> <code class="reqn">(n\times T)\times 1</code> </td><td style="text-align: right;"> Dynamic            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data.frame</code> </td><td style="text-align: left;"> <code class="reqn">n\times T</code> </td><td style="text-align: right;"> Dynamic           </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data.frame</code> </td><td style="text-align: left;"> <code class="reqn">n\times 1</code> </td><td style="text-align: right;"> Static            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data.frame</code> </td><td style="text-align: left;"> <code class="reqn">(n\times T)\times 1</code> </td><td style="text-align: right;"> Dynamic            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vector</code>     </td><td style="text-align: left;"> <code class="reqn">n</code>              </td><td style="text-align: right;"> Static            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vector</code>     </td><td style="text-align: left;"> <code class="reqn">n\times T</code> </td><td style="text-align: right;"> Dynamic           </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>list</code>*      </td><td style="text-align: left;"> <code class="reqn">T</code> data.frames/matrices/vectors</td><td style="text-align: right;"> Dynamic    </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>*: With <code class="reqn">n\times 1</code> <code>data.frame</code>/<code>matrix</code> or <code class="reqn">n</code> length vector.
</p>
<p>Other cases will return with error.
</p>
<p>In the case of the slices index <code>k</code>, either an
integer vector with the positions, a character vector with the labels of the
time periods or a logical vector of length <code>T</code> can be used to specify
which slices to retrieve. Likewise, indexing vertices works in the same way
with the only difference that, instead of time period labels and a logical vector
of length <code>T</code>, vertices ids labels and a logical vector of length <code>n</code>
should be provided.
</p>
<p>When subsetting slices, the function modifies the <code>toa</code> vector as well as the
<code>adopt</code> and <code>cumadopt</code> matrices collapsing network tinmming. For example,
if a network goes from time 1 to 20 and we set <code>k=3:10</code>, all individuals
who adopted prior to time 3 will be set as adopters at time 3, and all individuals
who adopted after time 10 will be set as adopters at time 10, changing the
adoption and cumulative adoption matrices. Importantly, <code>k</code> have no
gaps, and it should be within the graph time period range.
</p>


<h3>Value</h3>

<p>In the case of the assigning methods, a diffnet object. Otherwise,
for <code>[[.diffnet</code> a vector extracted from one of the attributes data frames,
and for <code>[.diffnet</code> a list of length <code>length(k)</code> with the corresponding
<code>[i,j]</code> elements from the adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating a random diffusion network ---------------------------------------
set.seed(111)
graph &lt;- rdiffnet(50,4)

# Accessing to a static attribute
graph[["real_threshold"]]

# Accessing to subsets of the adjacency matrix
graph[1,,1:3, drop=TRUE]
graph[,,1:3, drop=TRUE][[1]]

# ... Now, as diffnet objects (the default)
graph[1,,1:3, drop=FALSE]
graph[,,1:3, drop=FALSE]

# Changing values in the adjacency matrix
graph[1, , , drop=TRUE]
graph[1,,] &lt;- -5
graph[1, , , drop=TRUE]

# Adding attributes (dynamic) -----------------------------------------------
# Preparing the data
set.seed(1122)
x &lt;- rdiffnet(30, 4, seed.p.adopt=.15)

# Calculating exposure, and storing it diffe
expoM &lt;- exposure(x)
expoL &lt;- lapply(seq_len(x$meta$nper), function(x) expoM[,x,drop=FALSE])
expoD &lt;- do.call(rbind, expoL)

# Adding data (all these are equivalent)
x[["expoM"]] &lt;- expoM
x[["expoL"]] &lt;- expoL
x[["expoD"]] &lt;- expoD

# Lets compare
identical(x[["expoM"]], x[["expoL"]]) # TRUE
identical(x[["expoM"]], x[["expoD"]]) # TRUE
</code></pre>

<hr>
<h2 id='diffnet-arithmetic'><code>diffnet</code> Arithmetic and Logical Operators</h2><span id='topic+diffnet-arithmetic'></span><span id='topic++5E.diffnet'></span><span id='topic+graph_power'></span><span id='topic++2F.diffnet'></span><span id='topic+-.diffnet'></span><span id='topic++2A.diffnet'></span><span id='topic++26.diffnet'></span><span id='topic++7C.diffnet'></span>

<h3>Description</h3>

<p>Addition, subtraction, network power of diffnet and logical operators such as
<code>&amp;</code> and <code>|</code> as objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
x ^ y

graph_power(x, y, valued = getOption("diffnet.valued", FALSE))

## S3 method for class 'diffnet'
y / x

## S3 method for class 'diffnet'
x - y

## S3 method for class 'diffnet'
x * y

## S3 method for class 'diffnet'
x &amp; y

## S3 method for class 'diffnet'
x | y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffnet-arithmetic_+3A_x">x</code></td>
<td>
<p>A <code>diffnet</code> class object.</p>
</td></tr>
<tr><td><code id="diffnet-arithmetic_+3A_y">y</code></td>
<td>
<p>Integer scalar. Power of the network</p>
</td></tr>
<tr><td><code id="diffnet-arithmetic_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When FALSE all non-zero entries of the adjacency
matrices are set to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using binary operators, ease data management process with diffnet.
</p>
<p>By default the binary operator <code>^</code> assumes that the graph is valued,
hence the power is computed using a weighted edges. Otherwise, if more control
is needed, the user can use <code>graph_power</code> instead.
</p>


<h3>Value</h3>

<p>A diffnet class object
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computing two-steps away threshold with the Brazilian farmers data --------
data(brfarmersDiffNet)

expo1 &lt;- threshold(brfarmersDiffNet)
expo2 &lt;- threshold(brfarmersDiffNet^2)

# Computing correlation
cor(expo1,expo2)

# Drawing a qqplot
qqplot(expo1, expo2)

# Working with inverse ------------------------------------------------------
brf2_step &lt;- brfarmersDiffNet^2
brf2_step &lt;- 1/brf2_step

# Removing the first 3 vertex of medInnovationsDiffnet ----------------------
data(medInnovationsDiffNet)

# Using a diffnet object
first3Diffnet &lt;- medInnovationsDiffNet[1:3,,]
medInnovationsDiffNet - first3Diffnet

# Using indexes
medInnovationsDiffNet - 1:3

# Using ids
medInnovationsDiffNet - as.character(1001:1003)
</code></pre>

<hr>
<h2 id='diffnet-class'>Creates a <code>diffnet</code> class object</h2><span id='topic+diffnet-class'></span><span id='topic+diffnet'></span><span id='topic+as_diffnet'></span><span id='topic+as_diffnet.default'></span><span id='topic+as_diffnet.networkDynamic'></span><span id='topic+new_diffnet'></span><span id='topic+as.data.frame.diffnet'></span><span id='topic+diffnet.attrs'></span><span id='topic+diffnet.attrs+3C-'></span><span id='topic+diffnet.toa'></span><span id='topic+diffnet.toa+3C-'></span><span id='topic+print.diffnet'></span><span id='topic+nodes'></span><span id='topic+diffnetLapply'></span><span id='topic+str.diffnet'></span><span id='topic+dimnames.diffnet'></span><span id='topic+t.diffnet'></span><span id='topic+dim.diffnet'></span><span id='topic+is_undirected'></span><span id='topic+is_undirected.diffnet'></span><span id='topic+is_undirected.default'></span><span id='topic+is_self'></span><span id='topic+is_self.diffnet'></span><span id='topic+is_self.default'></span><span id='topic+is_multiple'></span><span id='topic+is_multiple.diffnet'></span><span id='topic+is_multiple.default'></span><span id='topic+is_valued'></span><span id='topic+is_valued.diffnet'></span><span id='topic+is_valued.default'></span>

<h3>Description</h3>

<p><code>diffnet</code> objects contain difussion networks. With adjacency
matrices and time of adoption (toa) vector as its main components, most of the
package's functions have methods for this class of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_diffnet(graph, ...)

## Default S3 method:
as_diffnet(graph, ...)

## S3 method for class 'networkDynamic'
as_diffnet(graph, toavar, ...)

new_diffnet(
  graph,
  toa,
  t0 = min(toa, na.rm = TRUE),
  t1 = max(toa, na.rm = TRUE),
  vertex.dyn.attrs = NULL,
  vertex.static.attrs = NULL,
  id.and.per.vars = NULL,
  graph.attrs = NULL,
  undirected = getOption("diffnet.undirected"),
  self = getOption("diffnet.self"),
  multiple = getOption("diffnet.multiple"),
  name = "Diffusion Network",
  behavior = "Unspecified"
)

## S3 method for class 'diffnet'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  attr.class = c("dyn", "static"),
  ...
)

diffnet.attrs(
  graph,
  element = c("vertex", "graph"),
  attr.class = c("dyn", "static"),
  as.df = FALSE
)

diffnet.attrs(graph, element = "vertex", attr.class = "static") &lt;- value

diffnet.toa(graph)

diffnet.toa(graph, i) &lt;- value

## S3 method for class 'diffnet'
print(x, ...)

nodes(graph)

diffnetLapply(graph, FUN, ...)

## S3 method for class 'diffnet'
str(object, ...)

## S3 method for class 'diffnet'
dimnames(x)

## S3 method for class 'diffnet'
t(x)

## S3 method for class 'diffnet'
dim(x)

is_undirected(x)

## S3 method for class 'diffnet'
is_undirected(x)

## Default S3 method:
is_undirected(x)

is_self(x)

## S3 method for class 'diffnet'
is_self(x)

## Default S3 method:
is_self(x)

is_multiple(x)

## S3 method for class 'diffnet'
is_multiple(x)

## Default S3 method:
is_multiple(x)

is_valued(x)

## S3 method for class 'diffnet'
is_valued(x)

## Default S3 method:
is_valued(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffnet-class_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the jmethod.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_toavar">toavar</code></td>
<td>
<p>Character scalar. Name of the variable that holds the time of adoption.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_toa">toa</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. Times of adoption.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_t1">t1</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_vertex.dyn.attrs">vertex.dyn.attrs</code></td>
<td>
<p>Vertices dynamic attributes (see details).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_vertex.static.attrs">vertex.static.attrs</code></td>
<td>
<p>Vertices static attributes (see details).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_id.and.per.vars">id.and.per.vars</code></td>
<td>
<p>A character vector of length 2. Optionally specified to check the
order of the rows in the attribute data.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_graph.attrs">graph.attrs</code></td>
<td>
<p>Graph dynamic attributes (not supported yet).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_name">name</code></td>
<td>
<p>Character scalar. Name of the diffusion network (descriptive).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_behavior">behavior</code></td>
<td>
<p>Character scalar. Name of the behavior been analyzed (innovation).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_x">x</code></td>
<td>
<p>A <code>diffnet</code> object.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_row.names">row.names</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_optional">optional</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_attr.class">attr.class</code></td>
<td>
<p>Character vector/scalar. Indicates the class of the attribute, either dynamic (<code>"dyn"</code>),
or static (<code>"static"</code>).</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_element">element</code></td>
<td>
<p>Character vector/scalar. Indicates what to retrieve/alter.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_as.df">as.df</code></td>
<td>
<p>Logical scalar. When TRUE returns a data.frame.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_value">value</code></td>
<td>
<p>In the case of <code>diffnet.toa</code>, replacement, otherwise see below.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_i">i</code></td>
<td>
<p>Indices specifying elements to replace. See <code><a href="base.html#topic+Extract">Extract</a></code>.</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_fun">FUN</code></td>
<td>
<p>a function to be passed to lapply</p>
</td></tr>
<tr><td><code id="diffnet-class_+3A_object">object</code></td>
<td>
<p>A <code>diffnet</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diffnet</code> objects hold both, static and dynamic vertex attributes. When
creating <code>diffnet</code> objects, these can be specified using the arguments
<code>vertex.static.attrs</code> and <code>vertex.dyn.attrs</code>; depending on whether
the attributes to specify are static or dynamic, <span class="pkg">netdiffuseR</span> currently
supports the following objects:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Class</strong>    </td><td style="text-align: left;"> <strong>Dimension</strong>               </td><td style="text-align: right;"> <strong>Check sorting</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Static attributes</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>matrix</code>     </td><td style="text-align: left;"> with <code class="reqn">n</code> rows                </td><td style="text-align: right;"> <code>id</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data.frame</code> </td><td style="text-align: left;"> with <code class="reqn">n</code> rows                </td><td style="text-align: right;"> <code>id</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vector</code>     </td><td style="text-align: left;"> of length <code class="reqn">n</code>                </td><td style="text-align: right;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Dynamic attributes</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>matrix</code>     </td><td style="text-align: left;"> with <code class="reqn">n\times T</code> rows </td><td style="text-align: right;"> <code>id</code>, <code>per</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data.frame</code> </td><td style="text-align: left;"> with <code class="reqn">n\times T</code> rows </td><td style="text-align: right;"> <code>id</code>, <code>per</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>vector</code>     </td><td style="text-align: left;"> of length <code class="reqn">n\times T</code>   </td><td style="text-align: right;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>list</code>       </td><td style="text-align: left;"> of length <code class="reqn">T</code> with matrices or data.frames of <code class="reqn">n</code> rows</td><td style="text-align: right;"> <code>id</code>, <code>per</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The last column, <strong>Check sorting</strong>, lists the variables that
the user should specify if he wants the function to check the order of the rows
of the attributes (notice that this is not possible for the case of vectors).
By providing the name of the vertex id variable, <code>id</code>, and the time period
id variable, <code>per</code>, the function makes sure that the attribute data is
presented in the right order. See the example below. If the user does not
provide the names of the vertex id and time period variables then the function
does not check the way the rows are sorted, further it assumes that the data
is in the correct order.
</p>
<p>The function 'is_undirected' returns TRUE if the network is marked
as undirected. In the case of 'diffnet' objects, this information is stored
in the 'meta' element as 'undirected'. The default method is to try to find
an attribute called 'undirected', i.e., 'attr(x, &quot;undirected&quot;)', if no
attribute is found, then the function returns 'FALSE'.
</p>
<p>The functions 'is_self', 'is_valued', and 'is_multiple' work exactly the same
as 'is_undirected'. 'diffnet' networks are not valued.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet</code> with the following elements:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>A list of length <code class="reqn">T</code>. Containing sparse square matrices of size <code class="reqn">n</code>
and class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code>toa</code></td>
<td>
<p>An integer vector of size <code class="reqn">T</code> with times of adoption.</p>
</td></tr>
<tr><td><code>adopt</code>, <code>cumadopt</code></td>
<td>
<p>Numeric matrices of size <code class="reqn">n\times T</code> as those returned
by <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code>vertex.static.attrs</code></td>
<td>
<p>If not NULL, a data frame with <code class="reqn">n</code> rows with vertex static
attributes.</p>
</td></tr>
<tr><td><code>vertex.dyn.attrs</code></td>
<td>
<p>A list of length <code class="reqn">T</code> with data frames containing vertex attributes
throught time (dynamic).</p>
</td></tr>
<tr><td><code>graph.attrs</code></td>
<td>
<p>A data frame with <code class="reqn">T</code> rows.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list of length 9 with the following elements:
</p>

<ul>
<li> <p><code>type</code>: Character scalar equal to <code>"dynamic"</code>.
</p>
</li>
<li> <p><code>class</code>: Character scalar equal to <code>"list"</code>.
</p>
</li>
<li> <p><code>ids</code>: Character vector of size <code class="reqn">n</code> with vertices' labels.
</p>
</li>
<li> <p><code>pers</code>: Integer vector of size <code class="reqn">T</code>.
</p>
</li>
<li> <p><code>nper</code>: Integer scalar equal to <code class="reqn">T</code>.
</p>
</li>
<li> <p><code>n</code>: Integer scalar equal to <code class="reqn">n</code>.
</p>
</li>
<li> <p><code>self</code>: Logical scalar.
</p>
</li>
<li> <p><code>undirected</code>: Logical scalar.
</p>
</li>
<li> <p><code>multiple</code>: Logical scalar.
</p>
</li>
<li> <p><code>name</code>: Character scalar.
</p>
</li>
<li> <p><code>behavior</code>: Character scalar.
</p>
</li></ul>

</td></tr>
</table>


<h3>Auxiliary functions</h3>

<p><code>diffnet.attrs</code> Allows retriving network attributes. In particular, by default
returns a list of length <code class="reqn">T</code> with data frames with the following columns:
</p>

<ol>
<li> <p><code>per</code> Indicating the time period to which the observation corresponds.
</p>
</li>
<li> <p><code>toa</code> Indicating the time of adoption of the vertex.
</p>
</li>
<li><p> Further columns depending on the vertex and graph attributes.
</p>
</li></ol>

<p>Each vertex static attributes' are repeated <code class="reqn">T</code> times in total so that these
can be binded (<code>rbind</code>) to dynamic attributes.
</p>
<p>When <code>as.df=TRUE</code>, this convenience function is useful as it can be used
to create event history (panel data) datasets used for model fitting.
</p>
<p>Conversely, the replacement method allows including new vertex or graph
attributes either dynamic or static (see examples below).
</p>
<p><code>diffnet.toa(graph)</code> works as an alias of <code>graph$toa</code>.
The replacement method, <code>diffnet.toa&lt;-</code> used as <code>diffnet.toa(graph)&lt;-...</code>,
is the right way of modifying times of adoption as when doing so it
performs several checks on the time ranges, and
recalculates adoption and cumulative adoption matrices using <code>toa_mat</code>.
</p>
<p><code>nodes(graph)</code> is an alias for <code>graph$meta$ids</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Default options are listed at <code><a href="#topic+netdiffuseR-options">netdiffuseR-options</a></code>
</p>
<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>
<p>Other data management functions: 
<code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a>()</code>,
<code><a href="#topic+egonet_attrs">egonet_attrs</a>()</code>,
<code><a href="#topic+isolated">isolated</a>()</code>,
<code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating a random graph
set.seed(123)
graph &lt;- rgraph_ba(t=9)
graph &lt;- lapply(1:5, function(x) graph)

# Pretty TOA
names(graph) &lt;- 2001L:2005L
toa &lt;- sample(c(2001L:2005L,NA), 10, TRUE)

# Creating diffnet object
diffnet &lt;- new_diffnet(graph, toa)
diffnet
summary(diffnet)

# Plotting slice 4
plot(diffnet, t=4)

# ATTRIBUTES ----------------------------------------------------------------

# Retrieving attributes
diffnet.attrs(diffnet, "vertex", "static")

# Now as a data.frame (only static)
diffnet.attrs(diffnet, "vertex", "static", as.df = TRUE)

# Now as a data.frame (all of them)
diffnet.attrs(diffnet, as.df = TRUE)
as.data.frame(diffnet) # This is a wrapper

# Unsorted data -------------------------------------------------------------
# Loading example data
data(fakesurveyDyn)

# Creating a diffnet object
fs_diffnet &lt;- survey_to_diffnet(
   fakesurveyDyn, "id", c("net1", "net2", "net3"), "toa", "group",
   timevar = "time", keep.isolates=TRUE, warn.coercion=FALSE)

# Now, we extract the graph data and create a diffnet object from scratch
graph &lt;- fs_diffnet$graph
ids &lt;- fs_diffnet$meta$ids
graph &lt;- Map(function(g) {
  dimnames(g) &lt;- list(ids,ids)
  g
  }, g=graph)
attrs &lt;- diffnet.attrs(fs_diffnet, as.df=TRUE)
toa   &lt;- diffnet.toa(fs_diffnet)

# Lets apply a different sorting to the data to see if it works
n &lt;- nrow(attrs)
attrs &lt;- attrs[order(runif(n)),]

# Now, recreating the old diffnet object (notice -id.and.per.vars- arg)
fs_diffnet_new &lt;- new_diffnet(graph, toa=toa, vertex.dyn.attrs=attrs,
   id.and.per.vars = c("id", "per"))

# Now, retrieving attributes. The 'new one' will have more (repeated)
attrs_new &lt;- diffnet.attrs(fs_diffnet_new, as.df=TRUE)
attrs_old &lt;- diffnet.attrs(fs_diffnet, as.df=TRUE)

# Comparing elements!
tocompare &lt;- intersect(colnames(attrs_new), colnames(attrs_old))
all(attrs_new[,tocompare] == attrs_old[,tocompare], na.rm = TRUE) # TRUE!

# diffnetLapply -------------------------------------------------------------

data(medInnovationsDiffNet)
diffnetLapply(medInnovationsDiffNet, function(x, cumadopt, ...) {sum(cumadopt)})

</code></pre>

<hr>
<h2 id='diffreg'>Diffusion regression model</h2><span id='topic+diffreg'></span>

<h3>Description</h3>

<p>A wrapper of <code>glm</code>, this function estimates a lagged regression model of
adoption as a function of exposure and other controls as especified by the
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffreg(model, type = c("logit", "probit"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffreg_+3A_model">model</code></td>
<td>
<p>An object of class formula where the right-hand-side is an object of
class <code><a href="#topic+diffnet">diffnet</a></code></p>
</td></tr>
<tr><td><code id="diffreg_+3A_type">type</code></td>
<td>
<p>Character scalar. Either <code>"probit"</code> or <code>"logit"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model must be in the following form:
</p>
<pre>
&lt;diffnet object&gt; ~ exposure + covariate1 + covariate2 + ...
</pre>
<p>Where <code>exposure</code> can be especified either as a simple term, or as a
call to the exposure function, e.g. to compute exposure with a lag of
length 2, the formula could be:
</p>
<pre>
&lt;diffnet object&gt; ~ exposure(lags = 2) + covariate1 + covariate2 + ...
</pre>
<p>When no argument is passed to <code>exposure</code>, the function sets a lag
of length 1 by default (see the <em>Lagged regression</em> section).
</p>
<p>This is a wrapper of <code><a href="stats.html#topic+glm">glm</a></code>. The function does the
following steps:
</p>

<ol>
<li><p> Compute exposure by calling <code>exposure</code> on the LHS (dependent variable).
</p>
</li>
<li><p> Modify the formula so that the model is on adoption as a function of
exposure and whatever covariates the user specifies.
</p>
</li>
<li><p> Selects either <code>"probit"</code> or <code>"logit"</code> and prepares the call
to <code>glm</code>. This includes passing the following line:
</p>
<pre>
 subset = ifelse(is.na(toa), TRUE, toa &gt;= per)
 </pre>
<p>This results in including observations that either did not adopted or up to
the time of adoption.
</p>
</li>
<li><p> Estimates the model.
</p>
</li></ol>

<p>The data passed to <code>glm</code> is obtained by using <code><a href="#topic+as.data.frame.diffnet">as.data.frame.diffnet</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Lagged regression</h3>

<p>The model estimated is a lagged regression model that has two main assumptions:
</p>

<ol>
<li><p> The network is exogenous to the behavior (no selection effect)
</p>
</li>
<li><p> The influence effect (diffusion) happens in a lagged fasion, hence,
exposure is computed lagged.
</p>
</li></ol>

<p>If either of these two assumptions is not met, then the model becomes endogenous,
ans so inference becomes invalid.
</p>
<p>In the case of the first assumption, the user can overcome the non-exogeneity
problem by providing an alternative network. This can be done by especifying
<code>alt.graph</code> in the <code>exposure</code> function so that the network becomes
exogenous to the adoption.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("medInnovationsDiffNet")

# Default model
ans &lt;- diffreg(
  medInnovationsDiffNet ~ exposure + factor(city) + proage + per)
summary(ans)
</code></pre>

<hr>
<h2 id='diffusion-data'>Diffusion Network Datasets</h2><span id='topic+diffusion-data'></span>

<h3>Description</h3>

<p>Diffusion Network Datasets
</p>


<h3>Details</h3>

<p>The three classic network diffusion datasets included in netdiffuseR are the
medical innovation data originally collected by Coleman, Katz &amp; Menzel (1966);
the Brazilian Farmers collected as part of the three country study implemented
by Everett Rogers (Rogers, Ascroft, &amp; Röling, 1970), and Korean Family Planning
data collected by researchers at the Seoul National University's School of
Public (Rogers &amp; Kincaid, 1981). The table below summarizes the three datasets:
</p>

<table>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: center;">	<b>Medical Innovation</b>	</td><td style="text-align: center;">	<b>Brazilian Farmers</b>	</td><td style="text-align: center;">	<b>Korean Family Planning</b>	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Country</em>	</td><td style="text-align: center;">	USA	</td><td style="text-align: center;">	Brazil	</td><td style="text-align: center;">	Korean	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em># Respondents</em>	</td><td style="text-align: center;">	125 Doctors	</td><td style="text-align: center;">	692 Farmers	</td><td style="text-align: center;">	1,047 Women	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em># Communities</em>	</td><td style="text-align: center;">	4	</td><td style="text-align: center;">	11	</td><td style="text-align: center;">	25	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Innovation</em>	</td><td style="text-align: center;">	Tetracycline	</td><td style="text-align: center;">	Hybrid Corn Seed	</td><td style="text-align: center;">	Family Planning	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Time for Diffusion</em>	</td><td style="text-align: center;">	18 Months	</td><td style="text-align: center;">	20 Years	</td><td style="text-align: center;">	11 Years	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Year Data Collected</em>	</td><td style="text-align: center;">	1955-1956	</td><td style="text-align: center;">	1966	</td><td style="text-align: center;">	1973	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Ave. Time to 50%</em>	</td><td style="text-align: center;">	6	</td><td style="text-align: center;">	16	</td><td style="text-align: center;">	7	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Highest Saturation</em>	</td><td style="text-align: center;">	0.89	</td><td style="text-align: center;">	0.98	</td><td style="text-align: center;">	0.83	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Lowest Saturation</em>	</td><td style="text-align: center;">	0.81	</td><td style="text-align: center;">	0.29	</td><td style="text-align: center;">	0.44	</td>
</tr>
<tr>
 <td style="text-align: left;">
<em>Citation</em>	</td><td style="text-align: center;">	Coleman et al (1966)	</td><td style="text-align: center;">	Rogers et al (1970)	</td><td style="text-align: center;">	Rogers &amp; Kincaid (1981)	</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>All datasets include a column called <em>study</em> which is coded as
(1) Medical Innovation (2) Brazilian Farmers, (3) Korean Family Planning.
</p>


<h3>Value</h3>

<p>No return value (this manual entry only provides information).
</p>


<h3>Right censored data</h3>

<p>By convention, non-adopting actors are coded as one plus the last observed time
of adoption.  Prior empirical event history approaches have used this approach
(Valente, 2005; Marsden and Podolny, 1990) and studies have shown that
omitting such observations leads to biased results (van den Bulte &amp; Iyengar,
2011).
</p>


<h3>Author(s)</h3>

<p>Thomas W. Valente
</p>


<h3>References</h3>

<p>Burt, R. S. (1987). &quot;Social Contagion and Innovation: Cohesion versus
Structural Equivalence&quot;. American Journal of Sociology, 92(6), 1287–1335.
<a href="https://doi.org/10.1086/228667">doi:10.1086/228667</a>
</p>
<p>Coleman, J., Katz, E., &amp; Menzel, H. (1966). Medical innovation: A diffusion
study (2nd ed.). New York: Bobbs-Merrill
</p>
<p>Granovetter, M., &amp; Soong, R. (1983). Threshold models of diffusion and
collective behavior. The Journal of Mathematical Sociology, 9(October 2013),
165–179. <a href="https://doi.org/10.1080/0022250X.1983.9989941">doi:10.1080/0022250X.1983.9989941</a>
</p>
<p>Rogers, E. M., Ascroft, J. R., &amp; Röling, N. (1970). Diffusion of Innovation
in Brazil, Nigeria, and India. Unpublished Report. Michigan State University,
East Lansing.
</p>
<p>Everett M. Rogers, &amp; Kincaid, D. L. (1981). Communication Networks: Toward a
New Paradigm for Research. (C. Macmillan, Ed.). New York; London: Free Press.
</p>
<p>Mardsen, P., &amp; Podolny, J. (1990). Dynamic Analysis of Network Diffusion Processes,
J. Weesie, H. Flap, eds. Social Networks Through Time, 197–214.
</p>
<p>Marsden, P. V., &amp; Friedkin, N. E. (1993). Network Studies of Social Influence.
Sociological Methods &amp; Research, 22(1), 127–151.
<a href="https://doi.org/10.1177/0049124193022001006">doi:10.1177/0049124193022001006</a>
</p>
<p>Van den Bulte, C., &amp; Iyengar, R. (2011). Tricked by Truncation: Spurious
Duration Dependence and Social Contagion in Hazard Models. Marketing Science,
30(2), 233–248. <a href="https://doi.org/10.1287/mksc.1100.0615">doi:10.1287/mksc.1100.0615</a>
</p>
<p>Valente, T. W. (1991). Thresholds and the critical mass: Mathematical models
of the diffusion of innovations. University of Southern California.
</p>
<p>Valente, T. W. (1995). &quot;Network models of the diffusion of innovations&quot; (2nd ed.).
Cresskill N.J.: Hampton Press.
</p>
<p>Valente, T. W. (2005). Network Models and Methods for Studying the Diffusion of Innovations.
In Models and Methods in Social Network Analysis, Volume 28 of Structural
Analysis in the Social Sciences (pp. 98–116). New York: Cambridge University Press.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='diffusionMap'>Creates a heatmap based on a graph layout and a vertex attribute</h2><span id='topic+diffusionMap'></span><span id='topic+diffmap'></span><span id='topic+diffusionMap.default'></span><span id='topic+diffusionMap.diffnet'></span><span id='topic+image.diffnet_diffmap'></span><span id='topic+print.diffnet_diffmap'></span><span id='topic+plot.diffnet_diffmap'></span>

<h3>Description</h3>

<p>Using bi-dimensional kernel smoothers, creates a heatmap based on a graph layout
and colored accordingly to <code>x</code>. This visualization technique is intended
to be used with large graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusionMap(graph, ...)

diffmap(graph, ...)

## Default S3 method:
diffusionMap(
  graph,
  x,
  x.adj = round_to_seq,
  layout = NULL,
  jitter.args = list(),
  kde2d.args = list(n = 100),
  sharp.criter = function(x, w) {
     wvar(x, w) &gt; (max(x, na.rm = TRUE) - min(x, na.rm
    = TRUE))^2/12
 },
  ...
)

## S3 method for class 'diffnet'
diffusionMap(graph, slice = nslices(graph), ...)

## S3 method for class 'diffnet_diffmap'
image(x, ...)

## S3 method for class 'diffnet_diffmap'
print(x, ...)

## S3 method for class 'diffnet_diffmap'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffusionMap_+3A_graph">graph</code></td>
<td>
<p>A square matrix of size <code class="reqn">n\times n</code>.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_...">...</code></td>
<td>
<p>Arguments passed to method.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_x">x</code></td>
<td>
<p>An vector of length <code class="reqn">n</code>. Usually a <code>toa</code> vector.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_x.adj">x.adj</code></td>
<td>
<p>Function to adjust <code>x</code>. If not <code>NULL</code> then it is applied
to <code>x</code> at the beginning (see details).</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_layout">layout</code></td>
<td>
<p>Either a <code class="reqn">n\times 2</code> matrix of coordinates or a layout
function applied to <code>graph</code> (must return coordinates).</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_jitter.args">jitter.args</code></td>
<td>
<p>A list including arguments to be passed to <code><a href="base.html#topic+jitter">jitter</a></code>.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_kde2d.args">kde2d.args</code></td>
<td>
<p>A list including arguments to be passed to <code><a href="MASS.html#topic+kde2d">kde2d</a></code>.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_sharp.criter">sharp.criter</code></td>
<td>
<p>A function choose whether to apply a weighted mean for each cell,
or randomize over the values present in that cell (see details).</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_slice">slice</code></td>
<td>
<p>Integer scalar. Slice of the network to be used as baseline for drawing the graph.</p>
</td></tr>
<tr><td><code id="diffusionMap_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The image is created using the function <code>kde2d</code> from
the <span class="pkg">MASS</span> package. The complete algorithm follows:
</p>

<ol>
<li> <p><code>x</code> is coerced into integer and the range is adjusted to start from 1.
<code>NA</code> are replaced by zero.
</p>
</li>
<li><p> If no <code>layout</code> is passed, layout is computed using
<code><a href="igraph.html#topic+layout_nicely">layout_nicely</a></code> from <span class="pkg">igraph</span>
</p>
</li>
<li><p> Then, a <code>kde2d</code> map is computed for each level of <code>x</code>. The
resulting matrices are added up as a weighted sum. This only holds if
at the cell level the function <code>sharp.criter</code> returns <code>FALSE</code>.
</p>
</li>
<li><p> The jitter function is applied to the repeated coordinates.
</p>
</li>
<li><p> 2D kernel is computed using <code>kde2d</code> over the coordinates.
</p>
</li></ol>

<p>The function <code>sharp.criter</code> must take two values, a vector of levels and a
vector of weights. It must return a logical scalar with value equal to <code>TRUE</code>
when a randomization at the cell level must be done, in which case the final
value of the cell is chosen using <code>sample(x, 1, prob=w)</code>.
</p>
<p>The resulting matrix can be passed to <code><a href="graphics.html#topic+image">image</a></code> or similar.
</p>
<p>The argument <code>x.adj</code> uses by default the function <code><a href="#topic+round_to_seq">round_to_seq</a></code>
which basically maps <code>x</code> to a fix length sequence of numbers such that
<code>x.adj(x)</code> resembles an integer sequence.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet_diffmap</code>
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>A matrix of size <code class="reqn">n\times 2</code> of vertices coordinates.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>Output from <code>kde2d</code>. This is a list with 3 elements, vectors
<code>x</code>, <code>y</code> and matrix <code>z</code> of size <code class="reqn">n\times n</code> (passed
via <code>kde2d.args</code>).</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Bandwidth passed to <code>kde2d</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Vega Yon, George G., and Valente, Thomas W., Visualizing Large Annotated
Networks as Heatmaps using Weighted Averages based on Kernel Smoothers (Working paper).
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with a random graph --------------------------------------------------

set.seed(1231)

# Random scale-free diffusion network
x &lt;- rdiffnet(500, 4, seed.graph="scale-free", seed.p.adopt = .025,
                           rewire = FALSE, seed.nodes = "central",
                           rgraph.arg=list(self=FALSE, m=4),
                           threshold.dist = function(id) runif(1,.2,.4))

# Diffusion map (no random toa)
dm0 &lt;- diffusionMap(x, kde2d.args=list(n=150, h=.5), layout=igraph::layout_with_fr)

# Random
diffnet.toa(x) &lt;- sample(x$toa, size = nnodes(x))

# Diffusion map (random toa)
dm1 &lt;- diffusionMap(x, layout = dm0$coords, kde2d.args=list(n=150, h=.5))

oldpar &lt;- par(no.readonly = TRUE)
col &lt;- colorRampPalette(blues9)(100)
par(mfrow=c(1,2), oma=c(1,0,0,0))
image(dm0, col=col, main="Non-random Times of Adoption\nAdoption from the core.")
image(dm1, col=col, main="Random Times of Adoption")
par(mfrow=c(1,1))
mtext("Both networks have the same distribution on times of adoption", 1,
      outer = TRUE)
par(oldpar)

# Example with Brazilian Farmers --------------------------------------------
dn &lt;- brfarmersDiffNet

# Setting last TOA as NA
diffnet.toa(dn)[dn$toa == max(dn$toa)] &lt;-
  NA

# Coordinates
coords &lt;- sna::gplot.layout.fruchtermanreingold(
  as.matrix(dn$graph[[1]]), layout.par=NULL
)

# Plotting diffusion
plot_diffnet2(dn, layout=coords, vertex.size = 300)

# Adding diffusion map
out &lt;- diffusionMap(dn, layout=coords, kde2d.args=list(n=100, h=50))
col &lt;- adjustcolor(colorRampPalette(c("white","lightblue", "yellow", "red"))(100),.5)
with(out$map, .filled.contour(x,y,z,pretty(range(z), 100),col))

</code></pre>

<hr>
<h2 id='drawColorKey'>Draw a color key in the current device</h2><span id='topic+drawColorKey'></span>

<h3>Description</h3>

<p>Draw a color key in the current device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawColorKey(
  x,
  tick.marks = pretty_within(x),
  labels = tick.marks,
  main = NULL,
  key.pos = c(0.925, 0.975, 0.05, 0.95),
  pos = 2,
  nlevels = length(tick.marks),
  color.palette = viridisLite::viridis(nlevels),
  tick.width = c(0.01, 0.0075),
  add.box = TRUE,
  na.col = NULL,
  na.height = 0.1,
  na.lab = "n/a",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawColorKey_+3A_x">x</code></td>
<td>
<p>A numeric vector with the data (it is used to extract the range).</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_tick.marks">tick.marks</code></td>
<td>
<p>A numeric vector indicating the levels to be included in the axis.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_labels">labels</code></td>
<td>
<p>Character vector. When provided, specifies using different
labels for the tick marks than those provided by <code>tick.marjks</code>.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the key.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_key.pos">key.pos</code></td>
<td>
<p>A numeric vector of length 4 with relative coordinates of the
key (as % of the plotting area, see  <code><a href="graphics.html#topic+par">par(&quot;usr&quot;)</a></code>)</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_pos">pos</code></td>
<td>
<p>Integer scalar. Position of the axis as in <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer scalar. Number of levels (colors) to include in the color key.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_color.palette">color.palette</code></td>
<td>
<p>Color palette of <code>length(nlevels)</code>.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_tick.width">tick.width</code></td>
<td>
<p>Numeric vector of length 2 indicating the length of the inner
and outer tick marks as percentage of the axis.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_add.box">add.box</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> adds a box around the key.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_na.col">na.col</code></td>
<td>
<p>Character scalar. If specified, adds an aditional box indicating the NA color.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_na.height">na.height</code></td>
<td>
<p>Numeric scalar. Relative height of the NA box. Only use if
<code>na.col</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_na.lab">na.lab</code></td>
<td>
<p>Character scalar. Label of the <code>NA</code> block. Only use if
<code>na.col</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="drawColorKey_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+rect">rect</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(166)
x &lt;- rnorm(100)
col &lt;- colorRamp(c("lightblue", "yellow", "red"))((x - min(x))/(max(x) - min(x)))
col &lt;- rgb(col, maxColorValue = 255)
plot(x, col=col, pch=19)
drawColorKey(x, nlevels = 100, border="transparent",
 main="Key\nLike A\nBoss")
</code></pre>

<hr>
<h2 id='edgelist_to_adjmat'>Conversion between adjacency matrix and edgelist</h2><span id='topic+edgelist_to_adjmat'></span><span id='topic+adjmat_to_edgelist'></span>

<h3>Description</h3>

<p>Generates adjacency matrix from an edgelist and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_to_adjmat(
  edgelist,
  w = NULL,
  t0 = NULL,
  t1 = NULL,
  t = NULL,
  simplify = TRUE,
  undirected = getOption("diffnet.undirected"),
  self = getOption("diffnet.self"),
  multiple = getOption("diffnet.multiple"),
  keep.isolates = TRUE,
  recode.ids = TRUE
)

adjmat_to_edgelist(
  graph,
  undirected = getOption("diffnet.undirected", FALSE),
  keep.isolates = getOption("diffnet.keep.isolates", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist_to_adjmat_+3A_edgelist">edgelist</code></td>
<td>
<p>Two column matrix/data.frame in the form of ego -source- and
alter -target- (see details).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_w">w</code></td>
<td>
<p>Numeric vector. Strength of ties (optional).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_t0">t0</code></td>
<td>
<p>Integer vector. Starting time of the ties (optional).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_t1">t1</code></td>
<td>
<p>Integer vector. Finishing time of the ties (optional).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_t">t</code></td>
<td>
<p>Integer scalar. Repeat the network <code>t</code> times (if no <code>t0,t1</code> are provided).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_simplify">simplify</code></td>
<td>
<p>Logical scalar. When TRUE and <code>times=NULL</code> it will return an adjacency
matrix, otherwise an array of adjacency matrices.
(see details).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_keep.isolates">keep.isolates</code></td>
<td>
<p>Logical scalar. When FALSE, rows with <code>NA/NULL</code> values
(isolated vertices unless have autolink) will be droped (see details).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_recode.ids">recode.ids</code></td>
<td>
<p>Logical scalar. When TRUE ids are recoded using <code><a href="base.html#topic+as.factor">as.factor</a></code>
(see details).</p>
</td></tr>
<tr><td><code id="edgelist_to_adjmat_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When converting from edglist to adjmat the function will <code><a href="#topic+recode">recode</a></code> the
edgelist before starting. The user can keep track after the recording by checking
the resulting adjacency matrices' <code><a href="base.html#topic+row.names">row.names</a></code>. In the case that the
user decides skipping the recoding (because wants to keep vertices index numbers,
implying that the resulting graph will have isolated vertices), he can override
this by setting <code>recode.ids=FALSE</code> (see example).
</p>
<p>When multiple edges are included, <code>multiple=TRUE</code>,each vertex between <code class="reqn">\{i,j\}</code> will be counted
as many times it appears in the edgelist. So if a vertex <code class="reqn">\{i,j\}</code> appears 2
times, the adjacency matrix element <code>(i,j)</code> will be 2.
</p>
<p>Edges with incomplete information (missing data on <code>w</code> or <code>times</code>) are
not included on the graph. Incomplete cases are tagged using <code><a href="stats.html#topic+complete.cases">complete.cases</a></code>
and can be retrieved by the user by accessing the attribute <code>incomplete</code>.
</p>
<p>Were the case that either ego or alter are missing (i.e. <code>NA</code> values), the
function will either way include the non-missing vertex. See below for an example
of this.
</p>
<p>The function performs several checks before starting to create the adjacency
matrix. These are:
</p>

<ul>
<li><p>Dimensions of the inputs, such as number of columns and length of vectors
</p>
</li>
<li><p>Having complete cases. If anly edge has a non-numeric value such as NAs or
NULL in either <code>times</code> or <code>w</code>, it will be
removed. A full list of such edges can be retrieved from the attribute
<code>incomplete</code>
</p>
</li>
<li><p>Nodes and times ids coding
</p>
</li></ul>

<p><code>recode.ids=FALSE</code> is useful when the vertices ids have already been
coded. For example, after having use <code>adjmat_to_edgelist</code>, ids are
correctly encoded, so when going back (using <code>edgelist_to_adjmat</code>)
<code>recode.ids</code> should be FALSE.
</p>


<h3>Value</h3>

<p>In the case of <code>edgelist_to_adjmat</code> either an adjacency matrix
(if times is NULL) or an array of these (if times is not null). For
<code>adjmat_to_edgelist</code> the output is an edgelist with the following columns:
</p>
<table>
<tr><td><code>ego</code></td>
<td>
<p>Origin of the tie.</p>
</td></tr>
<tr><td><code>alter</code></td>
<td>
<p>Target of the tie.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Value in the adjacency matrix.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Either a 1 (if the network is static) or the time stamp of the tie.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>See Also</h3>

<p>Other data management functions: 
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+egonet_attrs">egonet_attrs</a>()</code>,
<code><a href="#topic+isolated">isolated</a>()</code>,
<code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Base data
set.seed(123)
n &lt;- 5
edgelist &lt;- rgraph_er(n, as.edgelist=TRUE, p=.2)[,c("ego","alter")]
times &lt;- sample.int(3, nrow(edgelist), replace=TRUE)
w &lt;- abs(rnorm(nrow(edgelist)))

# Simple example
edgelist_to_adjmat(edgelist)
edgelist_to_adjmat(edgelist, undirected = TRUE)

# Using w
edgelist_to_adjmat(edgelist, w)
edgelist_to_adjmat(edgelist, w, undirected = TRUE)

# Using times
edgelist_to_adjmat(edgelist, t0 = times)
edgelist_to_adjmat(edgelist, t0 = times, undirected = TRUE)

# Using times and w
edgelist_to_adjmat(edgelist, t0 = times, w = w)
edgelist_to_adjmat(edgelist, t0 = times, undirected = TRUE, w = w)

# Not recoding ----------------------------------------------------
# Notice that vertices 3, 4 and 5 are not present in this graph.
graph &lt;- matrix(c(
 1,2,6,
 6,6,7
), ncol=2)

# Generates an adjmat of size 4 x 4
edgelist_to_adjmat(graph)

# Generates an adjmat of size 7 x 7
edgelist_to_adjmat(graph, recode.ids=FALSE)

# Dynamic with spells -------------------------------------------------------
edgelist &lt;- rbind(
   c(1,2,NA,1990),
   c(2,3,NA,1991),
   c(3,4,1991,1992),
   c(4,1,1992,1993),
   c(1,2,1993,1993)
)

graph &lt;- edgelist_to_adjmat(edgelist[,1:2], t0=edgelist[,3], t1=edgelist[,4])

# Creating a diffnet object with it so we can apply the plot_diffnet function
diffnet &lt;- as_diffnet(graph, toa=1:4)
plot_diffnet(diffnet, label=rownames(diffnet))

# Missing alter in the edgelist ---------------------------------------------
data(fakeEdgelist)

# Notice that edge 202 is isolated
fakeEdgelist

# The function still includes vertex 202
edgelist_to_adjmat(fakeEdgelist[,1:2])

edgelist

</code></pre>

<hr>
<h2 id='edges_coords'>Compute ego/alter edge coordinates considering alter's size and aspect ratio</h2><span id='topic+edges_coords'></span>

<h3>Description</h3>

<p>Given a graph, vertices' positions and sizes, calculates the absolute positions
of the endpoints of the edges considering the plot's aspect ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_coords(
  graph,
  toa,
  x,
  y,
  vertex_cex,
  undirected = TRUE,
  no_contemporary = TRUE,
  dev = as.numeric(c()),
  ran = as.numeric(c()),
  curved = as.logical(c())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_coords_+3A_graph">graph</code></td>
<td>
<p>A square matrix of size <code class="reqn">n</code>. Adjacency matrix.</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_toa">toa</code></td>
<td>
<p>Integer vector of size <code class="reqn">n</code>. Times of adoption.</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_x">x</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. x-coordinta of vertices.</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_y">y</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. y-coordinta of vertices.</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_vertex_cex">vertex_cex</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. Vertices' sizes in terms
of the x-axis (see <code><a href="graphics.html#topic+symbols">symbols</a></code>).</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. Whether the graph is undirected or not.</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_no_contemporary">no_contemporary</code></td>
<td>
<p>Logical scalar. Whether to return (compute) edges'
coordiantes for vertices with the same time of adoption (see details).</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_dev">dev</code></td>
<td>
<p>Numeric vector of size 2. Height and width of the device (see details).</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_ran">ran</code></td>
<td>
<p>Numeric vector of size 2. Range of the x and y axis (see details).</p>
</td></tr>
<tr><td><code id="edges_coords_+3A_curved">curved</code></td>
<td>
<p>Logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to make the plot's visualization more appealing, this function provides
a straight forward way of computing the tips of the edges considering the
aspect ratio of the axes range. In particular, the following corrections are
made at the moment of calculating the egdes coords:
</p>

<ul>
<li><p>Instead of using the actual distance between ego and alter, a relative
one is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">d'=\left[(x_0-x_1)^2 + (y_0' - y_1')^2\right]^\frac{1}{2}</code>
</p>

<p>where <code class="reqn">%
y_i'=y_i\times\frac{\max x - \min x}{\max y - \min y} </code>

</p>
</li>
<li><p>Then, for the relative elevation angle, <code>alpha</code>, the relative distance <code class="reqn">d'</code>
is used, <code class="reqn">\alpha'=\arccos\left( (x_0 - x_1)/d' \right)</code>
</p>
</li>
<li><p>Finally, the edge's endpoint's (alter) coordinates are computed as follows: 
</p>
<p style="text-align: center;"><code class="reqn">%
  x_1' = x_1 + \cos(\alpha')\times v_1</code>
</p>

<p style="text-align: center;"><code class="reqn">%
  y_1' = y_1 -+ \sin(\alpha')\times v_1 \times\frac{\max y - \min y}{\max x - \min x} </code>
</p>

<p>Where <code class="reqn">v_1</code> is alter's size in terms of the x-axis, and the sign of
the second term in <code class="reqn">y_1'</code> is negative iff <code class="reqn">y_0 &lt; y_1</code>.

</p>
</li></ul>

<p>The same process (with sign inverted) is applied to the edge starting piont.
The resulting values, <code class="reqn">x_1',y_1'</code> can be used with the function
<code><a href="graphics.html#topic+arrows">arrows</a></code>. This is the workhorse function used in <code><a href="#topic+plot_threshold">plot_threshold</a></code>.
</p>
<p>The <code>dev</code> argument provides a reference to rescale the plot accordingly
to the device, and former, considering the size of the margins as well (this
can be easily fetched via <code>par("pin")</code>, plot area in inches).
</p>
<p>On the other hand, <code>ran</code> provides a reference for the adjustment
according to the range of the data, this is <code>range(x)[2] - range(x)[1]</code>
and <code>range(y)[2] - range(y)[1]</code> respectively.
</p>


<h3>Value</h3>

<p>A numeric matrix of size <code class="reqn">m\times 5</code> with the following
columns:
</p>
<table>
<tr><td><code>x0</code>, <code>y0</code></td>
<td>
<p>Edge origin</p>
</td></tr>
<tr><td><code>x1</code>, <code>y1</code></td>
<td>
<p>Edge target</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Relative angle between <code>(x0,y0)</code> and <code>(x1,y1)</code> in terms
of radians</p>
</td></tr>
</table>
<p>With <code class="reqn">m</code> as the number of resulting edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># --------------------------------------------------------------------------
data(medInnovationsDiffNet)
library(sna)

# Computing coordinates
set.seed(79)
coords &lt;- sna::gplot(as.matrix(medInnovationsDiffNet$graph[[1]]))

# Getting edge coordinates
vcex &lt;- rep(1.5, nnodes(medInnovationsDiffNet))
ecoords &lt;- edges_coords(
  medInnovationsDiffNet$graph[[1]],
  diffnet.toa(medInnovationsDiffNet),
  x = coords[,1], y = coords[,2],
  vertex_cex = vcex,
  dev = par("pin")
  )

ecoords &lt;- as.data.frame(ecoords)

# Plotting
symbols(coords[,1], coords[,2], circles=vcex,
  inches=FALSE, xaxs="i", yaxs="i")

with(ecoords, arrows(x0,y0,x1,y1, length=.1))
</code></pre>

<hr>
<h2 id='ego_variance'>Computes variance of <code class="reqn">Y</code> at ego level</h2><span id='topic+ego_variance'></span>

<h3>Description</h3>

<p>Computes variance of <code class="reqn">Y</code> at ego level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ego_variance(graph, Y, funname, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ego_variance_+3A_graph">graph</code></td>
<td>
<p>A matrix of size <code class="reqn">n\times n</code> of class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="ego_variance_+3A_y">Y</code></td>
<td>
<p>A numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="ego_variance_+3A_funname">funname</code></td>
<td>
<p>Character scalar. Comparison to make (see <code><a href="#topic+vertex_covariate_compare">vertex_covariate_compare</a></code>).</p>
</td></tr>
<tr><td><code id="ego_variance_+3A_all">all</code></td>
<td>
<p>Logical scalar. When <code>FALSE</code> (default) <code class="reqn">f_i</code> is mean at
ego level. Otherwise is fix for all i (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each vertex <code class="reqn">i</code> the variance is computed as follows
</p>
<p style="text-align: center;"><code class="reqn">%
(\sum_j a_{ij})^{-1}\sum_j a_{ij} \left[f(y_i,y_j) - f_i\right]^2
</code>
</p>

<p>Where <code class="reqn">a_{ij}</code> is the ij-th element of <code>graph</code>, <code class="reqn">f</code> is
the function specified in <code>funname</code>, and, if <code>all=FALSE</code>
<code class="reqn">f_i = \sum_j a_{ij}f(y_i,y_j)^2/\sum_ja_{ij}</code>,
otherwise <code class="reqn">f_i = f_j = \frac{1}{n^2}\sum_{i,j}f(y_i,y_j)</code>
</p>
<p>This is an auxiliary function for <code><a href="#topic+struct_test">struct_test</a></code>. The idea is
to compute an adjusted measure of disimilarity between vertices, so the
closest in terms of <code class="reqn">f</code> is <code class="reqn">i</code> to its neighbors, the smaller the
relative variance.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code class="reqn">n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+struct_test">struct_test</a></code>
</p>
<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>

<hr>
<h2 id='egonet_attrs'>Retrieve alter's attributes (network effects)</h2><span id='topic+egonet_attrs'></span>

<h3>Description</h3>

<p>For a given set of vertices V, retrieves each vertex's alter's
attributes. This function enables users to calculate exposure on variables
other than the attribute that is diffusing.  Further, it enables the
specification of alternative functions to use to characterize ego's
personal network including calculating the mean, maximum, minimum, median, or
sum of the alters' attributes. These measures may be static or dynamic over
the interval of diffusion and they may be binary or valued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egonet_attrs(
  graph,
  attrs,
  V = NULL,
  direction = "outgoing",
  fun = function(x) x,
  as.df = FALSE,
  self = getOption("diffnet.self"),
  valued = getOption("diffnet.valued"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egonet_attrs_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_attrs">attrs</code></td>
<td>
<p>If <code>graph</code> is static, Numeric matrix with <code class="reqn">n</code> rows, otherwise a list of numeric matrices with <code class="reqn">n</code> rows.</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_v">V</code></td>
<td>
<p>Integer vector. Set of vertices from which the attributes will be retrieved.</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_direction">direction</code></td>
<td>
<p>Character scalar. Either <code>"outgoing"</code>, <code>"incoming"</code>.</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_fun">fun</code></td>
<td>
<p>Function. Applied to each</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_as.df">as.df</code></td>
<td>
<p>Logical scalar. When TRUE returns a data.frame instead of a list (see details).</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered. Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="egonet_attrs_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By indexing inner/outer edges, this function retrieves ego network attributes
for all <code class="reqn">v \in V</code>, which by default is the complete set
of vertices in the graph.
</p>
<p>When <code>as.df=TRUE</code> the function returns a data.frame of size
<code class="reqn">(|V|\times T)\times k</code> where <code class="reqn">T</code> is the number of time
periods and <code class="reqn">k</code> is the number of columns generated by the function.
</p>
<p>The function can be used to create network effects as those in the <span class="pkg">RSiena</span>
package. The difference here is that the definition of the statistic directly
relies on the user. For example, in the <span class="pkg">RSiena</span> package, the dyadic covariate
effect <em>37. covariate (centered) main effect (X)</em>
</p>
<p style="text-align: center;"><code class="reqn">%
s_{i37}(x) = \sum_j x_{ij}(w_{ij}-\bar w)
</code>
</p>

<p>Which, having a diffnet object with attributes named <code>x</code> and <code>w</code>,
can be calculated as
</p>
<pre>
    egonet_attrs(diffnet, as.df=TRUE, fun=function(dat) {
     sum(dat[, "x"]*(dat[, "w"] - mean(dat[, "w"])))
    })
    </pre>
<p>Furthermore, we could use the <em>median</em> centered instead, for example
</p>
<pre>
    egonet_attrs(diffnet, as.df=TRUE, fun=function(dat) {
     sum(dat[, "x"]*(dat[, "w"] - median(dat[, "w"])))
    })
    </pre>
<p>Where for each <code class="reqn">i</code>, <code>dat</code> will be a matrix with as many rows
as individuals in his egonetwork. Such matrix holds the column names of the
attributes in the network.
</p>
<p>When <code>self = TRUE</code>, it will include ego's attributes, regardless
the network has loops or not.
</p>


<h3>Value</h3>

<p>A list with ego alters's attributes. By default, if the graph is static, the
output is a list of length <code>length(V)</code> with matrices having the following
columns:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>Either the corresponding value of the tie.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Alter's id</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Further attributes contained in <code>attrs</code></p>
</td></tr>
</table>
<p>On the other hand, if <code>graph</code> is dynamic, the output is list of length
<code class="reqn">T</code> of lists of length <code>length(V)</code> with data frames having the following
columns:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>The corresponding value of the adjacency matrix.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Alter's id</p>
</td></tr>
<tr><td><code>per</code></td>
<td>
<p>Time id</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Further attributes contained in <code>attrs</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other data management functions: 
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a>()</code>,
<code><a href="#topic+isolated">isolated</a>()</code>,
<code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example with diffnet -----------------------------------------------
set.seed(1001)
diffnet &lt;- rdiffnet(150, 5, seed.graph="small-world")

# Adding attributes
indeg &lt;- dgr(diffnet, cmode="indegree")
head(indeg)
diffnet[["indegree"]] &lt;- indeg

# Retrieving egonet's attributes (vertices 1 and 20)
egonet_attrs(diffnet, V=c(1,20))

# Example with a static network ---------------------------------------------

set.seed(1231)
n &lt;- 20
net &lt;- rgraph_ws(n = n, k = 4, p = .5)
someattr &lt;- matrix(rnorm(n * 2), ncol= 2, dimnames = list(NULL, c("a", "b")))

# Maximum of -a- in ego network
ans &lt;- egonet_attrs(net, someattr, fun = function(x) max(x[,"a"]))
ans

# checking it worked, taking a look at node 1, 2, and 3
max(someattr[which(net[1,] == 1),"a"]) == ans[1] # TRUE
max(someattr[which(net[2,] == 1),"a"]) == ans[2] # TRUE
max(someattr[which(net[3,] == 1),"a"]) == ans[3] # TRUE


</code></pre>

<hr>
<h2 id='exposure'>Ego exposure</h2><span id='topic+exposure'></span>

<h3>Description</h3>

<p>Calculates exposure to adoption over time via multiple different types of weight
matrices.  The basic  model is exposure to adoption by immediate neighbors
(outdegree) at the time period prior to ego’s adoption. This exposure can also be
based on (1) incoming ties, (2) structural equivalence, (3) indirect ties, (4)
attribute weighted (5) network-metric weighted (e.g., central nodes have more
influence), and attribute-weighted (e.g., based on homophily or tie strength).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposure(
  graph,
  cumadopt,
  attrs = NULL,
  alt.graph = NULL,
  outgoing = getOption("diffnet.outgoing", TRUE),
  valued = getOption("diffnet.valued", FALSE),
  normalized = TRUE,
  groupvar = NULL,
  self = getOption("diffnet.self"),
  lags = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exposure_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="exposure_+3A_cumadopt">cumadopt</code></td>
<td>
<p><code class="reqn">n\times T</code> matrix. Cumulative adoption matrix obtained from
<code><a href="#topic+toa_mat">toa_mat</a></code></p>
</td></tr>
<tr><td><code id="exposure_+3A_attrs">attrs</code></td>
<td>
<p>Either a character scalar (if <code>graph</code> is diffnet),
or a numeric matrix of size <code class="reqn">n\times T</code>. Weighting for each time, period (see details).</p>
</td></tr>
<tr><td><code id="exposure_+3A_alt.graph">alt.graph</code></td>
<td>
<p>Either a graph that should be used instead of <code>graph</code>,
or <code>"se"</code> (see details).</p>
</td></tr>
<tr><td><code id="exposure_+3A_outgoing">outgoing</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, computed using outgoing ties.</p>
</td></tr>
<tr><td><code id="exposure_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered. Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="exposure_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, the exposure will be between zero
and one (see details).</p>
</td></tr>
<tr><td><code id="exposure_+3A_groupvar">groupvar</code></td>
<td>
<p>Passed to <code><a href="#topic+struct_equiv">struct_equiv</a></code>.</p>
</td></tr>
<tr><td><code id="exposure_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="exposure_+3A_lags">lags</code></td>
<td>
<p>Integer scalar. When different from 0, the resulting exposure
matrix will be the lagged exposure as specified (see examples).</p>
</td></tr>
<tr><td><code id="exposure_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+struct_equiv">struct_equiv</a></code> (only used when
<code>alt.graph="se"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exposure is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn"> %
E_t = \left(S_t \times \left[x_t \circ A_t\right]\right) / (S_t \times x_t) %
</code>
</p>

<p>Where <code class="reqn">S_t</code> is the graph in time <code class="reqn">t</code>, <code class="reqn">x_t</code> is an attribute
vector of size <code class="reqn">n</code> at time <code class="reqn">t</code>, <code class="reqn">A_t</code> is the t-th column of
the cumulative adopters matrix (a vector of length <code class="reqn">n</code> with <code class="reqn">a_{ti}=1</code>
if <code class="reqn">i</code> has adopted at or prior to <code class="reqn">t</code>), <code class="reqn">\circ</code> is the kronecker
product (element-wise), and <code class="reqn">\times</code> is the matrix product.
</p>
<p>By default the graph used for this calculation, <code class="reqn">S</code>, is the social network. Alternatively,
in the case of <code>diffnet</code> objects, the user can provide an alternative
graph using <code>alt.graph</code>. An example of this would be using <code class="reqn">1/SE</code>,
the element-wise inverse of the structural equivalence matrix (see example below).
Furthermore, if <code>alt.graph="se"</code>, the inverse of the structural equivalence
is computed via <code><a href="#topic+struct_equiv">struct_equiv</a></code> and used instead of the provided
graph. Notice that when using a valued graph the option <code>valued</code> should
be equal to <code>TRUE</code>, this check is run automatically when running the
model using structural equivalence.
</p>
<p>If the <code>alt.graph</code> is static, then the function will warn about it
and will recycle the graph to compute exposure at each time point.
</p>
<p><b>An important remark</b> is that when calculating <b>structural equivalence</b> the
function <b>assumes that this is to be done to the entire graph</b> regardless of
disconnected communities (as in the case of the medical innovations
data set). Hence, structural equivalence for individuals for two different
communites may not be zero. If the user wants to calculate structural
equivalence separately by community, he should create different diffnet
objects and do so (see example below). Alternatively, for the case of
diffnet objects, by using the option <code>groupvar</code> (see <code><a href="#topic+struct_equiv">struct_equiv</a></code>), the user can provide
the function with the name of a grouping variable&ndash;which should one in the
set of static vertex attributes&ndash;so that the algorithm is done by group
(or community) instead of in an aggregated way.
</p>
<p>If the user does not specifies a particular weighting attribute in <code>attrs</code>,
the function sets this as a matrix of ones. Otherwise the function will return
an attribute weighted exposure. When <code>graph</code> is of class <code>diffnet</code>,
<code>attrs</code> can be a character scalar specifying the name of any of the graph's
attributes, both dynamic and static. See the examples section for a demonstration using
degree.
</p>
<p>When <code>outgoing=FALSE</code>, <code class="reqn">S</code> is replaced by its transposed, so in the
case of a social network exposure will be computed based on the incoming ties.
</p>
<p>If <code>normalize=FALSE</code> then denominator, <code class="reqn">S_t \times x_t</code>,
is not included. This can be useful when, for example, exposure needs to be
computed as a count instead of a proportion. A good example of this can be
found at the examples section of the function <code><a href="#topic+rdiffnet">rdiffnet</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">n\times T</code> with exposure for each node.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>References</h3>

<p>Burt, R. S. (1987). &quot;Social Contagion and Innovation: Cohesion versus Structural
Equivalence&quot;. American Journal of Sociology, 92(6), 1287.
<a href="https://doi.org/10.1086/228667">doi:10.1086/228667</a>
</p>
<p>Valente, T. W. (1995). &quot;Network models of the diffusion of innovations&quot;
(2nd ed.). Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculating lagged exposure -----------------------------------------------

set.seed(8)
graph &lt;- rdiffnet(20, 4)

expo0 &lt;- exposure(graph)
expo1 &lt;- exposure(graph, lags = 1)

# These should be equivalent
stopifnot(all(expo0[, -4] == expo1[, -1])) # No stop!


# Calculating the exposure based on Structural Equivalence ------------------
set.seed(113132)
graph &lt;- rdiffnet(100, 4)

SE &lt;- lapply(struct_equiv(graph), "[[", "SE")
SE &lt;- lapply(SE, function(x) {
   x &lt;- 1/x
   x[!is.finite(x)] &lt;- 0
   x
})


# These three lines are equivalent to:
expo_se2 &lt;- exposure(graph, alt.graph="se", valued=TRUE)
# Notice that we are setting valued=TRUE, but this is not necesary since when
# alt.graph = "se" the function checks this to be setted equal to TRUE

# Weighted Exposure using degree --------------------------------------------
eDE &lt;- exposure(graph, attrs=dgr(graph))

# Which is equivalent to
graph[["deg"]] &lt;- dgr(graph)
eDE2 &lt;- exposure(graph, attrs="deg")

# Comparing using incoming edges -------------------------------------------
eIN &lt;- exposure(graph, outgoing=FALSE)

# Structral equivalence for different communities ---------------------------
data(medInnovationsDiffNet)

# Only using 4 time slides, this is for convenience
medInnovationsDiffNet &lt;- medInnovationsDiffNet[, , 1:4]

# METHOD 1: Using the c.diffnet method:

# Creating subsets by city
cities &lt;- unique(medInnovationsDiffNet[["city"]])

diffnet &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == cities[1]]
diffnet[["expo_se"]] &lt;- exposure(diffnet, alt.graph="se", valued=TRUE)

for (v in cities[-1]) {
   diffnet_v &lt;- medInnovationsDiffNet[medInnovationsDiffNet[["city"]] == v]
   diffnet_v[["expo_se"]] &lt;- exposure(diffnet_v, alt.graph="se", valued=TRUE)
   diffnet &lt;- c(diffnet, diffnet_v)
}

# We can set the original order (just in case) of the data
diffnet &lt;- diffnet[medInnovationsDiffNet$meta$ids]
diffnet

# Checking everything is equal
test &lt;- summary(medInnovationsDiffNet, no.print=TRUE) ==
   summary(diffnet, no.print=TRUE)

stopifnot(all(test[!is.na(test)]))

# METHOD 2: Using the 'groupvar' argument
# Further, we can compare this with using the groupvar
diffnet[["expo_se2"]] &lt;- exposure(diffnet, alt.graph="se",
   groupvar="city", valued=TRUE)

# These should be equivalent
test &lt;- diffnet[["expo_se", as.df=TRUE]] == diffnet[["expo_se2", as.df=TRUE]]
stopifnot(all(test[!is.na(test)]))

# METHOD 3: Computing exposure, rbind and then adding it to the diffnet object
expo_se3 &lt;- NULL
for (v in unique(cities))
   expo_se3 &lt;- rbind(
     expo_se3,
     exposure(
       diffnet[diffnet[["city"]] == v],
       alt.graph = "se", valued=TRUE
     ))

# Just to make sure, we sort the rows
expo_se3 &lt;- expo_se3[diffnet$meta$ids,]

diffnet[["expo_se3"]] &lt;- expo_se3

test &lt;- diffnet[["expo_se", as.df=TRUE]] == diffnet[["expo_se3", as.df=TRUE]]
stopifnot(all(test[!is.na(test)]))


# METHOD 4: Using the groupvar in struct_equiv
se &lt;- struct_equiv(diffnet, groupvar="city")
se &lt;- lapply(se, "[[", "SE")
se &lt;- lapply(se, function(x) {
   x &lt;- 1/x
   x[!is.finite(x)] &lt;- 0
   x
})

diffnet[["expo_se4"]] &lt;- exposure(diffnet, alt.graph=se, valued=TRUE)

test &lt;- diffnet[["expo_se", as.df=TRUE]] == diffnet[["expo_se4", as.df=TRUE]]
stopifnot(all(test[!is.na(test)]))



</code></pre>

<hr>
<h2 id='fakeDynEdgelist'>Fake dynamic edgelist</h2><span id='topic+fakeDynEdgelist'></span>

<h3>Description</h3>

<p>A data frame used for examples in reading edgelist format networks. This
edgelist can be merged with the dataset <code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 22 rows and 4 variables
</p>

<dl>
<dt>ego</dt><dd><p>Nominating individual</p>
</dd>
<dt>alter</dt><dd><p>Nominated individual</p>
</dd>
<dt>value</dt><dd><p>Strength of the tie</p>
</dd>
<dt>time</dt><dd><p>Integer with the time of the spell</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Source</h3>

<p>Generated for the package
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='fakeEdgelist'>Fake static edgelist</h2><span id='topic+fakeEdgelist'></span>

<h3>Description</h3>

<p>A data frame used for examples in reading edgelist format networks. This
edgelist can be merged with the dataset <code><a href="#topic+fakesurvey">fakesurvey</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 11 rows and 3 variables
</p>

<dl>
<dt>ego</dt><dd><p>Nominating individual</p>
</dd>
<dt>alter</dt><dd><p>Nominated individual</p>
</dd>
<dt>value</dt><dd><p>Strength of the tie</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Source</h3>

<p>Generated for the package
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='fakesurvey'>Fake survey data</h2><span id='topic+fakesurvey'></span>

<h3>Description</h3>

<p>This data frame is used to ilustrate some of the functions of the package,
in particular, the <code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a></code> function. This dataset
can be merged with the <code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 9 rows and 9 variables
</p>

<dl>
<dt>id</dt><dd><p>Unique id at group level</p>
</dd>
<dt>toa</dt><dd><p>Time of adoption</p>
</dd>
<dt>group</dt><dd><p>Group id</p>
</dd>
<dt>net1</dt><dd><p>Network nomination 1</p>
</dd>
<dt>net2</dt><dd><p>Network nomination 2</p>
</dd>
<dt>net3</dt><dd><p>Network nomination 3</p>
</dd>
<dt>age</dt><dd><p>Age of the respondent</p>
</dd>
<dt>gender</dt><dd><p>Gende of the respondent</p>
</dd>
<dt>note</dt><dd><p>Descroption of the respondent</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Source</h3>

<p>Generated for the package.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='fakesurveyDyn'>Fake longitudinal survey data</h2><span id='topic+fakesurveyDyn'></span>

<h3>Description</h3>

<p>This data frame is used to ilustrate some of the functions of the package,
in particular, the <code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a></code> function. This dataset
can be merged with the <code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 18 rows and 10 variables
</p>

<dl>
<dt>id</dt><dd><p>Unique id at group level</p>
</dd>
<dt>toa</dt><dd><p>Time of adoption</p>
</dd>
<dt>group</dt><dd><p>Group id</p>
</dd>
<dt>net1</dt><dd><p>Network nomination 1</p>
</dd>
<dt>net2</dt><dd><p>Network nomination 2</p>
</dd>
<dt>net3</dt><dd><p>Network nomination 3</p>
</dd>
<dt>age</dt><dd><p>Age of the respondent</p>
</dd>
<dt>gender</dt><dd><p>Gende of the respondent</p>
</dd>
<dt>note</dt><dd><p>Descroption of the respondent</p>
</dd>
<dt>time</dt><dd><p>Timing of the wave</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Source</h3>

<p>Generated for the package.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='grid_distribution'>Distribution over a grid</h2><span id='topic+grid_distribution'></span>

<h3>Description</h3>

<p>Distribution of pairs over a grid of fix size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_distribution(x, y, nlevels = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_distribution_+3A_x">x</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="grid_distribution_+3A_y">y</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="grid_distribution_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer scalar. Number of bins to return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function ment for internal use only.
</p>


<h3>Value</h3>

<p>Returns a list with three elements
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Numeric vector of size <code>nlevels</code> with the class marks for x</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Numeric vector of size <code>nlevels</code> with the class marks for y</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Numeric matrix of size <code>nlevels</code> by <code>nlevels</code> with the distribution 
of the elements in terms of frequency</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre>
# Generating random vectors of size 100
x &lt;- rnorm(100)
y &lt;- rnorm(100)

# Calculating distribution
grid_distribution(x,y,20)
</pre>


<h3>See Also</h3>

<p>Used by <code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a></code>
</p>
<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>

<hr>
<h2 id='hazard_rate'>Network Hazard Rate</h2><span id='topic+hazard_rate'></span><span id='topic+plot_hazarrate'></span><span id='topic+plot_hazard'></span><span id='topic+plot.diffnet_hr'></span>

<h3>Description</h3>

<p>The hazard rate is the instantaneous probability of adoption at each time
representing the likelihood members will adopt at that time (Allison 1984).
The shape of the hazard rate indicates the pattern of new adopters over time.
Rapid diffusion with convex cumulative adoption curves will have hazard functions
that peak early and decay over time whereas slow concave cumulative adoption
curves will have hazard functions that are low early and rise over time.
Smooth hazard curves indicate constant adoption whereas those that oscillate
indicate variability in adoption behavior over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazard_rate(obj, no.plot = FALSE, include.grid = TRUE, ...)

plot_hazard(x, ...)

## S3 method for class 'diffnet_hr'
plot(
  x,
  y = NULL,
  main = "Hazard Rate",
  xlab = "Time",
  ylab = "Hazard Rate",
  type = "b",
  include.grid = TRUE,
  bg = "lightblue",
  pch = 21,
  add = FALSE,
  ylim = c(0, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard_rate_+3A_obj">obj</code></td>
<td>
<p>A <code class="reqn">n\times T</code> matrix (Cumulative adoption matrix obtained from
<code><a href="#topic+toa_mat">toa_mat</a></code>) or a <code><a href="#topic+diffnet">diffnet</a></code> object.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_no.plot">no.plot</code></td>
<td>
<p>Logical scalar. When TRUE, suppress plotting (only returns hazard rates).</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_include.grid">include.grid</code></td>
<td>
<p>Logical scalar. When TRUE includes a grid on the plot.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the method.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_x">x</code></td>
<td>
<p>An object of class <code>diffnet_hr</code>.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the plot</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. x-axis label.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. y-axis label.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_type">type</code></td>
<td>
<p>Character scalar. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_bg">bg</code></td>
<td>
<p>Character scalar. Color of the points.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_pch">pch</code></td>
<td>
<p>Integer scalar. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_add">add</code></td>
<td>
<p>Logical scalar. When TRUE it adds the hazard rate to the current plot.</p>
</td></tr>
<tr><td><code id="hazard_rate_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector. See <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes hazard rate, plots it and returns the hazard rate vector
invisible (so is not printed on the console). For <code class="reqn">t&gt;1</code>, hazard rate is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\frac{q_t - q_{t-1}}{n - q_{t-1}}</code>
</p>

<p>where <code class="reqn">q_i</code> is the number of adopters in time <code class="reqn">t</code>, and <code class="reqn">n</code> is
the number of vertices in the graph.
</p>
<p>In survival analysis, hazard rate is defined formally as
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\lim_{h\to +0}\frac{F(t+h)-F(t)}{h}\frac{1}{1-F(t)} %
</code>
</p>

<p>Then, by approximating <code class="reqn">h=1</code>, we can rewrite the equation as
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{F(t+1)-F(t)}{1-F(t)} %
</code>
</p>

<p>Furthermore, we can estimate <code class="reqn">F(t)</code>, the probability of not having adopted
the innovation in time <code class="reqn">t</code>, as the proportion of adopters in that time, this
is <code class="reqn">F(t) \sim q_t/n</code>, so now we have
</p>
<p style="text-align: center;"><code class="reqn">%
\lambda(t)=\frac{q_{t+1}/n-q_t/n}{1-q_t/n} = \frac{q_{t+1} - q_t}{n - q_t} %
</code>
</p>

<p>As showed above.
</p>
<p>The <code>plot_hazard</code> function is an alias for the <code>plot.diffnet_hr</code> method.
</p>


<h3>Value</h3>

<p>A row vector of size <code class="reqn">T</code> with hazard rates for <code class="reqn">t&gt;1</code> of class <code>diffnet_hr</code>.
The class of the object is only used by the S3 plot method.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>References</h3>

<p>Allison, P. (1984). Event history analysis regression for longitudinal event
data. Beverly Hills: Sage Publications.
</p>
<p>Wooldridge, J. M. (2010). Econometric Analysis of Cross Section and Panel Data
(2nd ed.). Cambridge: MIT Press.
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>
<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a random vector of times of adoption
toa &lt;- sample(2000:2005, 20, TRUE)

# Computing cumulative adoption matrix
cumadopt &lt;- toa_mat(toa)$cumadopt

# Visualizing the hazard rate
hazard_rate(cumadopt)
</code></pre>

<hr>
<h2 id='igraph'>Coercion between graph classes</h2><span id='topic+igraph'></span><span id='topic+diffnet_to_igraph'></span><span id='topic+igraph_to_diffnet'></span>

<h3>Description</h3>

<p>Coercion between graph classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffnet_to_igraph(graph, slices = 1:nslices(graph))

igraph_to_diffnet(
  graph = NULL,
  graph.list = NULL,
  toavar,
  t0 = NULL,
  t1 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_+3A_graph">graph</code></td>
<td>
<p>Either a <code><a href="#topic+diffnet">diffnet</a></code> or <code><a href="igraph.html#topic+igraph">igraph</a></code> graph object.</p>
</td></tr>
<tr><td><code id="igraph_+3A_slices">slices</code></td>
<td>
<p>An integer vector indicating the slices to subset.</p>
</td></tr>
<tr><td><code id="igraph_+3A_graph.list">graph.list</code></td>
<td>
<p>A list of <code>igraph</code> objects.</p>
</td></tr>
<tr><td><code id="igraph_+3A_toavar">toavar</code></td>
<td>
<p>Character scalar. Name of the attribute that holds the times of adoption.</p>
</td></tr>
<tr><td><code id="igraph_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+diffnet-class">new_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="igraph_+3A_t1">t1</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+diffnet-class">new_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="igraph_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+as_diffnet">as_diffnet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list of <code>length(slices)</code> <code>igraph</code>
(<code>diffnet_to_igraph</code>), or a <code>diffnet</code> object (<code>igraph_to_diffnet</code>)
objects.
</p>


<h3>See Also</h3>

<p>Other Foreign: 
<code><a href="#topic+network">network</a></code>,
<code><a href="#topic+read_pajek">read_pajek</a>()</code>,
<code><a href="#topic+read_ucinet_head">read_ucinet_head</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Reading the medical innovation data into igraph --------------------------
x &lt;- diffnet_to_igraph(medInnovationsDiffNet[,,1:4])

# Fetching the times of adoption
igraph::vertex_attr(x[[1]], "toa")
</code></pre>

<hr>
<h2 id='infection'>Susceptibility and Infection</h2><span id='topic+infection'></span><span id='topic+susceptibility'></span>

<h3>Description</h3>

<p>Calculates infectiousness and susceptibility for each node in the graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infection(
  graph,
  toa,
  t0 = NULL,
  normalize = TRUE,
  K = 1L,
  r = 0.5,
  expdiscount = FALSE,
  valued = getOption("diffnet.valued", FALSE),
  outgoing = getOption("diffnet.outgoing", TRUE)
)

susceptibility(
  graph,
  toa,
  t0 = NULL,
  normalize = TRUE,
  K = 1L,
  r = 0.5,
  expdiscount = FALSE,
  valued = getOption("diffnet.valued", FALSE),
  outgoing = getOption("diffnet.outgoing", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infection_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="infection_+3A_toa">toa</code></td>
<td>
<p>Integer vector of length <code class="reqn">n</code> with the times of adoption.</p>
</td></tr>
<tr><td><code id="infection_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. See <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="infection_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Whether or not to normalize the outcome</p>
</td></tr>
<tr><td><code id="infection_+3A_k">K</code></td>
<td>
<p>Integer scalar. Number of time periods to consider</p>
</td></tr>
<tr><td><code id="infection_+3A_r">r</code></td>
<td>
<p>Numeric scalar. Discount rate used when <code>expdiscount=TRUE</code></p>
</td></tr>
<tr><td><code id="infection_+3A_expdiscount">expdiscount</code></td>
<td>
<p>Logical scalar. When TRUE, exponential discount rate is used (see details).</p>
</td></tr>
<tr><td><code id="infection_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered. Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="infection_+3A_outgoing">outgoing</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, computed using outgoing ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalization, <code>normalize=TRUE</code>, is applied by dividing the
resulting number from the infectiousness/susceptibility stat
by the number of individuals who adopted the innovation at
time <code class="reqn">t</code>.
</p>
<p>Given that node <code class="reqn">i</code> adopted the innovation in time <code class="reqn">t</code>, its
Susceptibility is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">S_i = \frac{%
\sum_{k=1}^K\sum_{j=1}^n x_{ij(t-k+1)}z_{j(t-k)}\times \frac{1}{w_k}}{%
\sum_{k=1}^K\sum_{j=1}^n x_{ij(t-k+1)}z_{j(1\leq t \leq t-k)} \times \frac{1}{w_k} }\qquad \mbox{for }i,j=1,\dots,n\quad i\neq j</code>
</p>

<p>where <code class="reqn">x_{ij(t-k+1)}</code> is 1 whenever there's a link from <code class="reqn">i</code>
to <code class="reqn">j</code> at time <code class="reqn">t-k+1</code>, <code class="reqn">z_{j(t-k)}</code>
is 1 whenever individual <code class="reqn">j</code> adopted the innovation at time <code class="reqn">t-k</code>,
<code class="reqn">z_{j(1\leq t \leq t-k)}</code> is 1 whenever
<code class="reqn">j</code> had adopted the innovation up to <code class="reqn">t-k</code>, and <code class="reqn">w_k</code> is
the discount rate used (see below).
</p>
<p>Similarly, infectiousness is calculated as follows
</p>
<p style="text-align: center;"><code class="reqn">I_i = \frac{%
\sum_{k=1}^K \sum_{j=1}^n x_{ji(t+k-1)}z_{j(t+k)}\times \frac{1}{w_k}}{%
\sum_{k=1}^K \sum_{j=1}^n x_{ji(t+k-1)}z_{j(t+k\leq t \leq T)}\times \frac{1}{w_k} }\qquad \mbox{for }i,j=1,\dots,n\quad i\neq j</code>
</p>

<p>It is worth noticing that, as we can see in the formulas, while susceptibility
is from alter to ego, infection is from ego to alter.
</p>
<p>When <code>outgoing=FALSE</code> the algorithms are based on incoming edges, this is
the adjacency matrices are transposed swapping the indexes <code class="reqn">(i,j)</code> by
<code class="reqn">(j,i)</code>. This can be useful for some users.
</p>
<p>Finally, by default both are normalized by the number of individuals who
adopted the innovation in time <code class="reqn">t-k</code>. Thus, the resulting formulas,
when <code>normalize=TRUE</code>, can be rewritten as
</p>
<p style="text-align: center;"><code class="reqn">%
S_i' = \frac{S_i}{\sum_{k=1}^K\sum_{j=1}^nz_{j(t-k)}\times \frac{1}{w_k}} %
\qquad I_i' = \frac{I_i}{\sum_{k=1}^K\sum_{j=1}^nz_{j(t-k)} \times\frac{1}{w_k}}</code>
</p>

<p>For more details on these measurements, please refer to the vignette titled
<em>Time Discounted Infection and Susceptibility</em>.
</p>


<h3>Value</h3>

<p>A numeric column vector (matrix) of size <code class="reqn">n</code> with either infection/susceptibility rates.
</p>


<h3>Discount rate</h3>

<p>Discount rate, <code class="reqn">w_k</code> in the formulas above, can be either exponential
or linear. When <code>expdiscount=TRUE</code>, <code class="reqn">w_k = (1 + r)^{k-1}</code>, otherwise
it will be <code class="reqn">w_k = k</code>.
</p>
<p>Note that when <code class="reqn">K=1</code>, the above formulas are equal to the ones presented
in Valente et al. (2015).
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Thomas W. Valente, Stephanie R. Dyal, Kar-Hai Chu, Heather Wipfli, Kayo
Fujimoto Diffusion of innovations theory applied to global tobacco control
treaty ratification, Social Science &amp; Medicine, Volume 145, November 2015,
Pages 89-97, ISSN 0277-9536
<a href="https://doi.org/10.1016/j.socscimed.2015.10.001">doi:10.1016/j.socscimed.2015.10.001</a>
</p>
<p>Myers, D. J. (2000). The Diffusion of Collective Violence: Infectiousness,
Susceptibility, and Mass Media Networks. American Journal of Sociology, 106(1),
173–208. <a href="https://doi.org/10.1086/303110">doi:10.1086/303110</a>
</p>


<h3>See Also</h3>

<p>The user can visualize the distribution of both statistics
by using the function <code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a></code>
</p>
<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating a random dynamic graph
set.seed(943)
graph &lt;- rgraph_er(n=100, t=10)
toa &lt;- sample.int(10, 100, TRUE)

# Computing infection and susceptibility (K=1)
infection(graph, toa)
susceptibility(graph, toa)

# Now with K=4
infection(graph, toa, K=4)
susceptibility(graph, toa, K=4)

</code></pre>

<hr>
<h2 id='isolated'>Find and remove isolated vertices</h2><span id='topic+isolated'></span><span id='topic+drop_isolated'></span>

<h3>Description</h3>

<p>Find and remove unconnected vertices from the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolated(
  graph,
  undirected = getOption("diffnet.undirected", FALSE),
  self = getOption("diffnet.self", FALSE)
)

drop_isolated(
  graph,
  undirected = getOption("diffnet.undirected", FALSE),
  self = getOption("diffnet.self", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolated_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="isolated_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="isolated_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>graph</code> is an adjacency matrix:
</p>
<table>
<tr><td><code>isolated</code></td>
<td>
<p>an matrix of size <code class="reqn">n\times 1</code> with 1's where a node is isolated</p>
</td></tr>
<tr><td><code>drop_isolated</code></td>
<td>
<p>a modified graph excluding isolated vertices.</p>
</td></tr>
</table>
<p>Otherwise, when <code>graph</code> is a list
</p>
<table>
<tr><td><code>isolated</code></td>
<td>
<p>an matrix of size <code class="reqn">n\times T</code> with 1's where a node is isolated</p>
</td></tr>
<tr><td><code>drop_isolated</code></td>
<td>
<p>a modified graph excluding isolated vertices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other data management functions: 
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a>()</code>,
<code><a href="#topic+egonet_attrs">egonet_attrs</a>()</code>,
<code><a href="#topic+survey_to_diffnet">survey_to_diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating random graph
set.seed(123)
adjmat &lt;- rgraph_er()

# Making nodes 1 and 4 isolated
adjmat[c(1,4),] &lt;- 0
adjmat[,c(1,4)] &lt;- 0
adjmat

# Finding isolated nodes
iso &lt;- isolated(adjmat)
iso

# Removing isolated nodes
drop_isolated(adjmat)


# Now with a dynamic graph
graph &lt;- rgraph_er(n=10, t=3)

# Making 1 and 5 isolated
graph &lt;- lapply(graph, "[&lt;-", i=c(1,5), j=1:10, value=0)
graph &lt;- lapply(graph, "[&lt;-", i=1:10, j=c(1,5), value=0)
graph

isolated(graph)
drop_isolated(graph)
</code></pre>

<hr>
<h2 id='kfamily'>Korean Family Planning</h2><span id='topic+kfamily'></span>

<h3>Description</h3>

<p>From Valente (1995) &ldquo;Scholars at Seoul National University's School
of Public Health (Park, Chung, Han &amp; Lee, 1974) collected data on the
adoption of family planning methods among all married women of child-bearing
age 25 in Korea villages in 1973 (N = 1,047).&rdquo;
</p>


<h3>Format</h3>

<p>A data frame with 1,047 rows and 432 columns:
</p>

<dl>
<dt>village</dt><dd><p>Village of residence</p>
</dd>
<dt>id</dt><dd><p>Respondent ID number</p>
</dd>
<dt>recno1</dt><dd><p>Card number NA</p>
</dd>
<dt>studno1</dt><dd><p>Study number NA</p>
</dd>
<dt>area1</dt><dd><p>Village of residence</p>
</dd>
<dt>id1</dt><dd><p>Respondent ID number</p>
</dd>
<dt>nmage1</dt><dd><p>Number males age 0</p>
</dd>
<dt>nmage2</dt><dd><p>Number males age 0-4</p>
</dd>
<dt>nmage3</dt><dd><p>Number males age 5-9</p>
</dd>
<dt>nmage4</dt><dd><p>Number males age 10-14</p>
</dd>
<dt>nmage5</dt><dd><p>Number males age 15-19</p>
</dd>
<dt>nmage6</dt><dd><p>Number males age 20-24</p>
</dd>
<dt>nmage7</dt><dd><p>Number males age 25-29</p>
</dd>
<dt>nmage8</dt><dd><p>Number males age 30-34</p>
</dd>
<dt>nmage9</dt><dd><p>Number males age 35-39</p>
</dd>
<dt>nmage10</dt><dd><p>Number males age 40-44</p>
</dd>
<dt>nmage11</dt><dd><p>Number males age 45-49</p>
</dd>
<dt>nmage12</dt><dd><p>Number males age 50-54</p>
</dd>
<dt>nmage13</dt><dd><p>Number males age 55-59</p>
</dd>
<dt>nmage14</dt><dd><p>Number males age 60-64</p>
</dd>
<dt>nmage15</dt><dd><p>Number males age 65-69</p>
</dd>
<dt>nmage16</dt><dd><p>Number males age 70-74</p>
</dd>
<dt>nmage17</dt><dd><p>Number males age 75-79</p>
</dd>
<dt>nmage18</dt><dd><p>Number males age 80+</p>
</dd>
<dt>nfage1</dt><dd><p>Number females age 0</p>
</dd>
<dt>nfage2</dt><dd><p>Number females age 0-4</p>
</dd>
<dt>nfage3</dt><dd><p>Number females age 5-9</p>
</dd>
<dt>nfage4</dt><dd><p>Number females age 10-14</p>
</dd>
<dt>nfage5</dt><dd><p>Number females age 15-19</p>
</dd>
<dt>nfage6</dt><dd><p>Number females age 20-24</p>
</dd>
<dt>nfage7</dt><dd><p>Number females age 25-29</p>
</dd>
<dt>nfage8</dt><dd><p>Number females age 30-34</p>
</dd>
<dt>nfage9</dt><dd><p>Number females age 35-39</p>
</dd>
<dt>nfage10</dt><dd><p>Number females age 40-44</p>
</dd>
<dt>nfage11</dt><dd><p>Number females age 45-49</p>
</dd>
<dt>nfage12</dt><dd><p>Number females age 50-54</p>
</dd>
<dt>nfage13</dt><dd><p>Number females age 55-59</p>
</dd>
<dt>nfage14</dt><dd><p>Number females age 60-64</p>
</dd>
<dt>nfage15</dt><dd><p>Number females age 65-69</p>
</dd>
<dt>nfage16</dt><dd><p>Number females age 70-74</p>
</dd>
<dt>nfage17</dt><dd><p>Number females age 75-79</p>
</dd>
<dt>nfage18</dt><dd><p>Number females age 80+</p>
</dd>
<dt>pregs</dt><dd><p>total pregnancies</p>
</dd>
<dt>pregs1</dt><dd><p>number normal deliveries</p>
</dd>
<dt>pregs2</dt><dd><p>number of induced abortions</p>
</dd>
<dt>pregs3</dt><dd><p>number of spontaneous abortions</p>
</dd>
<dt>pregs4</dt><dd><p>number of still births</p>
</dd>
<dt>pregs5</dt><dd><p>number of deaths after live birth</p>
</dd>
<dt>pregs6</dt><dd><p>currently pregnant</p>
</dd>
<dt>sons</dt><dd><p>number of sons</p>
</dd>
<dt>daughts</dt><dd><p>number of daughters</p>
</dd>
<dt>planning</dt><dd><p>Ever heard of FP or birth control</p>
</dd>
<dt>loop1</dt><dd><p>Awareness of Loop</p>
</dd>
<dt>loop2</dt><dd><p>Detailed knowledge of Loop</p>
</dd>
<dt>loop3</dt><dd><p>Attitudes toward Loop</p>
</dd>
<dt>loop4</dt><dd><p>Knowledge of Loop used by neighbors</p>
</dd>
<dt>loop5</dt><dd><p>Knowledge of place of service for Loop</p>
</dd>
<dt>pill1</dt><dd><p>Awareness of Pill</p>
</dd>
<dt>pill2</dt><dd><p>Detailed knowledge of Pill</p>
</dd>
<dt>pill3</dt><dd><p>Attitudes toward Pill</p>
</dd>
<dt>pill4</dt><dd><p>Knowledge of Pill used by neighbors</p>
</dd>
<dt>pill5</dt><dd><p>Knowledge of place of service for Pill</p>
</dd>
<dt>vase1</dt><dd><p>Awareness of Vasectomy</p>
</dd>
<dt>vase2</dt><dd><p>Detailed knowledge of Vasectomy</p>
</dd>
<dt>vase3</dt><dd><p>Attitudes toward Vasectomy</p>
</dd>
<dt>vase4</dt><dd><p>Knowledge of Vasectomy used by neighbors</p>
</dd>
<dt>vase5</dt><dd><p>Knowledge of place of service for Vasectomy</p>
</dd>
<dt>cond1</dt><dd><p>Awareness of Condoms</p>
</dd>
<dt>cond2</dt><dd><p>Detailed knowledge Condoms</p>
</dd>
<dt>cond3</dt><dd><p>Attitudes toward Condoms</p>
</dd>
<dt>cond4</dt><dd><p>Knowledge of Condoms used by neighbors</p>
</dd>
<dt>cond5</dt><dd><p>Knowledge of place of service for Condoms</p>
</dd>
<dt>rhyt1</dt><dd><p>Awareness of Rhythm</p>
</dd>
<dt>rhyt2</dt><dd><p>Detailed knowledge Rhythm</p>
</dd>
<dt>rhyt3</dt><dd><p>Attitudes toward Rhythm</p>
</dd>
<dt>rhyt4</dt><dd><p>Knowledge of Rhythm used by neighbors</p>
</dd>
<dt>bbt1</dt><dd><p>Awareness of Basic Body Temperature</p>
</dd>
<dt>bbt2</dt><dd><p>Detailed knowledge Basic Body Temperature</p>
</dd>
<dt>bbt3</dt><dd><p>Attitudes toward BBT</p>
</dd>
<dt>recno2</dt><dd><p>Record Number NA</p>
</dd>
<dt>studno2</dt><dd><p>Study Number NA</p>
</dd>
<dt>area2</dt><dd><p>village number</p>
</dd>
<dt>id2</dt><dd><p>id number</p>
</dd>
<dt>bbt4</dt><dd><p>Knowledge of BBT used by neighbors</p>
</dd>
<dt>diap1</dt><dd><p>Awareness of Diaphragm</p>
</dd>
<dt>diap2</dt><dd><p>Detailed knowledge Diaphragm</p>
</dd>
<dt>diap3</dt><dd><p>Attitudes toward Diaphragm</p>
</dd>
<dt>diap4</dt><dd><p>Knowledge of Diaphragm used by neighbors</p>
</dd>
<dt>with1</dt><dd><p>Awareness of Withdrawal</p>
</dd>
<dt>with2</dt><dd><p>Detailed knowledge Withdrawal</p>
</dd>
<dt>with3</dt><dd><p>Attitudes toward Withdrawal</p>
</dd>
<dt>with4</dt><dd><p>Knowledge of Withdrawal used by neighbors</p>
</dd>
<dt>tuba1</dt><dd><p>Awareness of Tubal Ligation</p>
</dd>
<dt>tuba2</dt><dd><p>Detailed knowledge TL</p>
</dd>
<dt>tuba3</dt><dd><p>Attitudes toward TL</p>
</dd>
<dt>tuba4</dt><dd><p>Knowledge of TL used by neighbors</p>
</dd>
<dt>fp1</dt><dd><p>Experience with an FP practice</p>
</dd>
<dt>fp2</dt><dd><p>Reasons for not practicing</p>
</dd>
<dt>fp3</dt><dd><p>What would you do if problem was solved</p>
</dd>
<dt>fp4</dt><dd><p>Any other reason for not practicing</p>
</dd>
<dt>fp5</dt><dd><p>Reasons for practicing</p>
</dd>
<dt>fp6</dt><dd><p>time between decision and adoption</p>
</dd>
<dt>fp7</dt><dd><p>reasons for time lag</p>
</dd>
<dt>fp8</dt><dd><p>Ever discontinued practicing</p>
</dd>
<dt>fp9</dt><dd><p>Reasons for discontinuing</p>
</dd>
<dt>fp10</dt><dd><p>Attitude toward FP</p>
</dd>
<dt>child1</dt><dd><p>Ideal number of sons</p>
</dd>
<dt>child2</dt><dd><p>Ideal number of daughters</p>
</dd>
<dt>child3</dt><dd><p>Ideal number of children regardless of sex</p>
</dd>
<dt>child4</dt><dd><p>what do if kept having girls</p>
</dd>
<dt>comop1</dt><dd><p>Spousal communication on # of children</p>
</dd>
<dt>comop2</dt><dd><p>Spousal communication on FP</p>
</dd>
<dt>comop3</dt><dd><p>Consensus on opinion between couple</p>
</dd>
<dt>comop4</dt><dd><p>What was the difference</p>
</dd>
<dt>comop5</dt><dd><p>Opinion on who should practice</p>
</dd>
<dt>comop6</dt><dd><p>Different opinions on who should practice</p>
</dd>
<dt>comop7</dt><dd><p>Who should make final decision</p>
</dd>
<dt>comop8</dt><dd><p>Residence in old age</p>
</dd>
<dt>net11</dt><dd><p>Neighbors talk to about FP- 1</p>
</dd>
<dt>net12</dt><dd><p>Neighbors talk to about FP- 2</p>
</dd>
<dt>net13</dt><dd><p>Neighbors talk to about FP- 3</p>
</dd>
<dt>net14</dt><dd><p>Neighbors talk to about FP- 4</p>
</dd>
<dt>net15</dt><dd><p>Neighbors talk to about FP- 5</p>
</dd>
<dt>famawe1</dt><dd><p>Family members of FP Practice</p>
</dd>
<dt>famawe2</dt><dd><p>Parents awareness of FP Practice</p>
</dd>
<dt>famawe3</dt><dd><p>How did parents-in-law become aware</p>
</dd>
<dt>famawe4</dt><dd><p>How did parents become aware</p>
</dd>
<dt>famawe5</dt><dd><p>How did husband become aware</p>
</dd>
<dt>advic1</dt><dd><p>Advice given to neighbors where to go</p>
</dd>
<dt>advic2</dt><dd><p>Advice given on method</p>
</dd>
<dt>advic3</dt><dd><p>Ever met persons who give advice on FP</p>
</dd>
<dt>advic4</dt><dd><p>Credibility of person advising on FP</p>
</dd>
<dt>advic5</dt><dd><p>Counter advice given to others</p>
</dd>
<dt>rumor1</dt><dd><p>Rumors on Loop</p>
</dd>
<dt>rumor2</dt><dd><p>Rumors on Pill</p>
</dd>
<dt>rumor3</dt><dd><p>Rumors on Vasectomy</p>
</dd>
<dt>rumor4</dt><dd><p>Rumors on Condom</p>
</dd>
<dt>rumor5</dt><dd><p>Rumors on Tuballigation</p>
</dd>
<dt>media1</dt><dd><p>Possession of Radio</p>
</dd>
<dt>media2</dt><dd><p>Possession of TV</p>
</dd>
<dt>media3</dt><dd><p>Subscription to Newspaper</p>
</dd>
<dt>media4</dt><dd><p>Subscription to Happy Home</p>
</dd>
<dt>media5</dt><dd><p>Subscription to other magazine</p>
</dd>
<dt>media6</dt><dd><p>Radio exposure to FP</p>
</dd>
<dt>media7</dt><dd><p>TV exposure to FP</p>
</dd>
<dt>media8</dt><dd><p>Daily paper exposure to FP</p>
</dd>
<dt>media9</dt><dd><p>Happy Home exposure to FP</p>
</dd>
<dt>media10</dt><dd><p>Magazine exposure to FP</p>
</dd>
<dt>media11</dt><dd><p>Movie or slide exposure to FP</p>
</dd>
<dt>media12</dt><dd><p>Poster exposure to FP</p>
</dd>
<dt>media13</dt><dd><p>Pamphlet exposure to FP</p>
</dd>
<dt>media14</dt><dd><p>FP Meeting exposure to FP</p>
</dd>
<dt>recno3</dt><dd><p>Record number NA</p>
</dd>
<dt>studno3</dt><dd><p>Study number NA</p>
</dd>
<dt>area3</dt><dd><p>village</p>
</dd>
<dt>id3</dt><dd><p>id</p>
</dd>
<dt>media15</dt><dd><p>Public lecture exposure to FP</p>
</dd>
<dt>media16</dt><dd><p>Mobile van exposure to FP</p>
</dd>
<dt>media17</dt><dd><p>Neighbors exposure to FP</p>
</dd>
<dt>media18</dt><dd><p>Workers home visiting exposure to FP</p>
</dd>
<dt>media19</dt><dd><p>Husband exposure to FP</p>
</dd>
<dt>club1</dt><dd><p>Awareness of clubs in community</p>
</dd>
<dt>club2</dt><dd><p>Membership in club</p>
</dd>
<dt>club3</dt><dd><p>Reasons for not becoming a member</p>
</dd>
<dt>club4</dt><dd><p>Feeling of necessity of club</p>
</dd>
<dt>club5</dt><dd><p>Visit of mobile van to area</p>
</dd>
<dt>club6</dt><dd><p>Service received from van</p>
</dd>
<dt>club7</dt><dd><p>Decision-making on FP on # children</p>
</dd>
<dt>club8</dt><dd><p>Decision-making on important goods</p>
</dd>
<dt>club9</dt><dd><p>Decision-making on childrens discipline</p>
</dd>
<dt>club10</dt><dd><p>Decision making on purchase wife clothes</p>
</dd>
<dt>net21</dt><dd><p>Closest neighbor most frequently met</p>
</dd>
<dt>n1adv</dt><dd><p>Advice received from neighbor 1</p>
</dd>
<dt>n1prac</dt><dd><p>practice of FP by neighbor 1</p>
</dd>
<dt>net22</dt><dd><p>Closest neighbor person 2</p>
</dd>
<dt>n2adv</dt><dd><p>Advice received from neighbor 2</p>
</dd>
<dt>n2prac</dt><dd><p>Practice of FP by neighbor 2</p>
</dd>
<dt>net23</dt><dd><p>Closest neighbor person 3</p>
</dd>
<dt>n3adv</dt><dd><p>Advice received from neighbor 3</p>
</dd>
<dt>n3prac</dt><dd><p>Practice of FP by neighbor 3</p>
</dd>
<dt>net24</dt><dd><p>Closest neighbor 4</p>
</dd>
<dt>n4adv</dt><dd><p>Advice received from neighbor 4</p>
</dd>
<dt>n4prac</dt><dd><p>Practice of FP by neighbor 4</p>
</dd>
<dt>net25</dt><dd><p>Closest neighbor 5</p>
</dd>
<dt>n5adv</dt><dd><p>Advice received from neighbor 5</p>
</dd>
<dt>n5prac</dt><dd><p>Practice of FP by neighbor 5</p>
</dd>
<dt>stand</dt><dd><p>Standard living of above neighbors</p>
</dd>
<dt>educ</dt><dd><p>Education level of named neighbors</p>
</dd>
<dt>net31</dt><dd><p>Advice on FP sought from 1</p>
</dd>
<dt>net32</dt><dd><p>Advice on FP sought from 2</p>
</dd>
<dt>net33</dt><dd><p>Advice on FP sought from 3</p>
</dd>
<dt>net34</dt><dd><p>Advice on FP sought from 4</p>
</dd>
<dt>net35</dt><dd><p>Advice on FP sought from 5</p>
</dd>
<dt>net41</dt><dd><p>Information provided on FP by 1</p>
</dd>
<dt>net42</dt><dd><p>Information provided on FP by 1</p>
</dd>
<dt>net43</dt><dd><p>Information provided on FP by 1</p>
</dd>
<dt>net44</dt><dd><p>Information provided on FP by 1</p>
</dd>
<dt>net45</dt><dd><p>Information provided on FP by 1</p>
</dd>
<dt>net51</dt><dd><p>Seek advice on induced abortion 1</p>
</dd>
<dt>net52</dt><dd><p>Seek advice on induced abortion 2</p>
</dd>
<dt>net53</dt><dd><p>Seek advice on induced abortion 3</p>
</dd>
<dt>net54</dt><dd><p>Seek advice on induced abortion 4</p>
</dd>
<dt>net55</dt><dd><p>Seek advice on induced abortion 5</p>
</dd>
<dt>age</dt><dd><p>Age of respondent</p>
</dd>
<dt>agemar</dt><dd><p>Age at first marriage</p>
</dd>
<dt>recno4</dt><dd><p>Rec no NA</p>
</dd>
<dt>studno4</dt><dd><p>Study no NA</p>
</dd>
<dt>area4</dt><dd><p>village</p>
</dd>
<dt>id4</dt><dd><p>id</p>
</dd>
<dt>net61</dt><dd><p>Advice on health sought from 1</p>
</dd>
<dt>net62</dt><dd><p>Advice on health sought from 2</p>
</dd>
<dt>net63</dt><dd><p>Advice on health sought from 3</p>
</dd>
<dt>net64</dt><dd><p>Advice on health sought from 4</p>
</dd>
<dt>net65</dt><dd><p>Advice on health sought from 5</p>
</dd>
<dt>net71</dt><dd><p>Advice on purchase of goods 1</p>
</dd>
<dt>net72</dt><dd><p>Advice on purchase of goods 2</p>
</dd>
<dt>net73</dt><dd><p>Advice on purchase of goods 3</p>
</dd>
<dt>net74</dt><dd><p>Advice on purchase of goods 4</p>
</dd>
<dt>net75</dt><dd><p>Advice on purchase of goods 5</p>
</dd>
<dt>net81</dt><dd><p>Advice on childrens education 1</p>
</dd>
<dt>net82</dt><dd><p>Advice on childrens education 2</p>
</dd>
<dt>net83</dt><dd><p>Advice on childrens education 3</p>
</dd>
<dt>net84</dt><dd><p>Advice on childrens education 4</p>
</dd>
<dt>net85</dt><dd><p>Advice on childrens education 5</p>
</dd>
<dt>rfampl1</dt><dd><p>Advice on FP sought by 1</p>
</dd>
<dt>rfampl2</dt><dd><p>Advice on FP sought by 2</p>
</dd>
<dt>rfampl3</dt><dd><p>Advice on FP sought by 3</p>
</dd>
<dt>rfampl4</dt><dd><p>Advice on FP sought by 4</p>
</dd>
<dt>rfampl5</dt><dd><p>Advice on FP sought by 5</p>
</dd>
<dt>rfampll</dt><dd><p>Leadership score - indegree FP</p>
</dd>
<dt>rabort1</dt><dd><p>Advice on abortion sought by 1</p>
</dd>
<dt>rabort2</dt><dd><p>Advice on abortion sought by 2</p>
</dd>
<dt>rabort3</dt><dd><p>Advice on abortion sought by 3</p>
</dd>
<dt>rabort4</dt><dd><p>Advice on abortion sought by 4</p>
</dd>
<dt>rabort5</dt><dd><p>Advice on abortion sought by 5</p>
</dd>
<dt>rabortl</dt><dd><p>Leadership score - indegree abortion</p>
</dd>
<dt>rhealth1</dt><dd><p>Advice on health sought by 1</p>
</dd>
<dt>rhealth2</dt><dd><p>Advice on health sought by</p>
</dd>
<dt>rhealth3</dt><dd><p>Advice on health sought by</p>
</dd>
<dt>rhealth4</dt><dd><p>Advice on health sought by</p>
</dd>
<dt>rhealth5</dt><dd><p>Advice on health sought by</p>
</dd>
<dt>rhealthl</dt><dd><p>Leadership score - indegree health</p>
</dd>
<dt>recno5</dt><dd><p>rec no NA</p>
</dd>
<dt>studno5</dt><dd><p>study no NA</p>
</dd>
<dt>area5</dt><dd><p>village</p>
</dd>
<dt>id5</dt><dd><p>id</p>
</dd>
<dt>rgoods1</dt><dd><p>Advice on purchases sought by 1</p>
</dd>
<dt>rgoods2</dt><dd><p>Advice on purchases sought by 2</p>
</dd>
<dt>rgoods3</dt><dd><p>Advice on purchases sought by 3</p>
</dd>
<dt>rgoods4</dt><dd><p>Advice on purchases sought by 4</p>
</dd>
<dt>rgoods5</dt><dd><p>Advice on purchases sought by 5</p>
</dd>
<dt>rgoodsl</dt><dd><p>Leadership score - indegree purchases</p>
</dd>
<dt>reduc1</dt><dd><p>Advice on education sought by 1</p>
</dd>
<dt>reduc2</dt><dd><p>Advice on education sought by 2</p>
</dd>
<dt>reduc3</dt><dd><p>Advice on education sought by 3</p>
</dd>
<dt>reduc4</dt><dd><p>Advice on education sought by 4</p>
</dd>
<dt>reduc5</dt><dd><p>Advice on education sought by 5</p>
</dd>
<dt>reducl</dt><dd><p>Leadership score - indegree education</p>
</dd>
<dt>hub1</dt><dd><p>Husbands friend 1</p>
</dd>
<dt>hub2</dt><dd><p>Husbands friend 2</p>
</dd>
<dt>hub3</dt><dd><p>Husbands friend 3</p>
</dd>
<dt>hub4</dt><dd><p>Husbands friend 4</p>
</dd>
<dt>hub5</dt><dd><p>Husbands friend 5</p>
</dd>
<dt>hubed</dt><dd><p>Husbands education</p>
</dd>
<dt>wifeed</dt><dd><p>Wifes education</p>
</dd>
<dt>wiferel</dt><dd><p>Wifes religion</p>
</dd>
<dt>hubocc</dt><dd><p>Husbands occupation</p>
</dd>
<dt>wifeocc</dt><dd><p>Wifes occupation</p>
</dd>
<dt>know1</dt><dd><p>Can you insert a loop yourself</p>
</dd>
<dt>know2</dt><dd><p>Can you remove it alone</p>
</dd>
<dt>know3</dt><dd><p>Can a man use a loop</p>
</dd>
<dt>know4</dt><dd><p>How long can a loop be used</p>
</dd>
<dt>know5</dt><dd><p>Which doctor</p>
</dd>
<dt>know6</dt><dd><p>Doctor or nurse</p>
</dd>
<dt>know7</dt><dd><p>Oral pill method</p>
</dd>
<dt>know8</dt><dd><p>Can men take pills</p>
</dd>
<dt>know9</dt><dd><p>Long term use</p>
</dd>
<dt>know10</dt><dd><p>Time required for vasectomy</p>
</dd>
<dt>know11</dt><dd><p>Does vasectomy = castration</p>
</dd>
<dt>know12</dt><dd><p>Can any doctor do vasectomies</p>
</dd>
<dt>pref1</dt><dd><p>Who prefer use: Husband or wife</p>
</dd>
<dt>pref2</dt><dd><p>Reasons for preferring FP practice by wife</p>
</dd>
<dt>pref3</dt><dd><p>Reasons for preferring FP practice by husband</p>
</dd>
<dt>ageend</dt><dd><p>Ideal age to end childbearing</p>
</dd>
<dt>cfp</dt><dd><p>Current status of FP</p>
</dd>
<dt>cfatt1</dt><dd><p>Husbands attitude</p>
</dd>
<dt>cfatt2</dt><dd><p>In-laws attitude</p>
</dd>
<dt>cfatt3</dt><dd><p>Own parents attitude</p>
</dd>
<dt>cbyr</dt><dd><p>Start of period from year</p>
</dd>
<dt>cbmnth</dt><dd><p>Start of period from month</p>
</dd>
<dt>ceyr</dt><dd><p>End of period year</p>
</dd>
<dt>cemnth</dt><dd><p>End of period month</p>
</dd>
<dt>clngth</dt><dd><p>Length of period</p>
</dd>
<dt>cawe1</dt><dd><p>FP contact</p>
</dd>
<dt>cawe2</dt><dd><p>Awareness of contraceptive method at the time</p>
</dd>
<dt>cawe3</dt><dd><p>Awareness of service site</p>
</dd>
<dt>cawe4</dt><dd><p>Credibiilty</p>
</dd>
<dt>recno6</dt><dd><p>rec no NA</p>
</dd>
<dt>studno6</dt><dd><p>study no NA</p>
</dd>
<dt>area6</dt><dd><p>village</p>
</dd>
<dt>id6</dt><dd><p>id</p>
</dd>
<dt>fpt1</dt><dd><p>FP Status time 1</p>
</dd>
<dt>fatt1t1</dt><dd><p>Husbands attitude T1</p>
</dd>
<dt>fatt2t1</dt><dd><p>In-laws attitude T1</p>
</dd>
<dt>fatt3t1</dt><dd><p>Own parents attitude T1</p>
</dd>
<dt>byrt1</dt><dd><p>Start of Time 1 from year</p>
</dd>
<dt>lngtht1</dt><dd><p>Length of Time 1</p>
</dd>
<dt>awe1t1</dt><dd><p>FP Contact Time 1</p>
</dd>
<dt>awe2t1</dt><dd><p>Methods known at Time 1</p>
</dd>
<dt>awe3t1</dt><dd><p>Knowledge of service sites Time 1</p>
</dd>
<dt>awe4t1</dt><dd><p>Credibility of service site Time 1</p>
</dd>
<dt>fpt2</dt><dd><p>FP Status time 2</p>
</dd>
<dt>fatt1t2</dt><dd><p>Husbands attitude T2</p>
</dd>
<dt>fatt2t2</dt><dd><p>In-laws attitude T2</p>
</dd>
<dt>fatt3t2</dt><dd><p>Own parents attitude T2</p>
</dd>
<dt>byrt2</dt><dd><p>Start of Time 2 from year</p>
</dd>
<dt>lngtht2</dt><dd><p>Length of Time 2</p>
</dd>
<dt>awe1t2</dt><dd><p>FP Contact Time 2</p>
</dd>
<dt>awe2t2</dt><dd><p>Methods known at Time 2</p>
</dd>
<dt>awe3t2</dt><dd><p>Knowledge of service sites Time 2</p>
</dd>
<dt>awe4t2</dt><dd><p>Credibility of service site Time 2</p>
</dd>
<dt>fpt3</dt><dd><p>FP Status time 3</p>
</dd>
<dt>fatt1t3</dt><dd><p>Husbands attitude T3</p>
</dd>
<dt>fatt2t3</dt><dd><p>In-laws attitude T3</p>
</dd>
<dt>fatt3t3</dt><dd><p>Own parents attitude T3</p>
</dd>
<dt>byrt3</dt><dd><p>Start of Time 3 from year</p>
</dd>
<dt>lngtht3</dt><dd><p>Length of Time 3</p>
</dd>
<dt>awe1t3</dt><dd><p>FP Contact Time 3</p>
</dd>
<dt>awe2t3</dt><dd><p>Methods known at Time 3</p>
</dd>
<dt>awe3t3</dt><dd><p>Knowledge of service sites Time 3</p>
</dd>
<dt>awe4t3</dt><dd><p>Credibility of service site Time 3</p>
</dd>
<dt>fpt4</dt><dd><p>FP Status time 4</p>
</dd>
<dt>fatt1t4</dt><dd><p>Husbands attitude T4</p>
</dd>
<dt>fatt2t4</dt><dd><p>In-laws attitude T4</p>
</dd>
<dt>fatt3t4</dt><dd><p>Own parents attitude T4</p>
</dd>
<dt>byrt4</dt><dd><p>Start of Time 4 from year</p>
</dd>
<dt>lngtht4</dt><dd><p>Length of Time 4</p>
</dd>
<dt>awe1t4</dt><dd><p>FP Contact Time 4</p>
</dd>
<dt>awe2t4</dt><dd><p>Methods known at Time 4</p>
</dd>
<dt>awe3t4</dt><dd><p>Knowledge of service sites Time 4</p>
</dd>
<dt>awe4t4</dt><dd><p>Credibility of service site Time 4</p>
</dd>
<dt>fpt5</dt><dd><p>FP Status time 5</p>
</dd>
<dt>fatt1t5</dt><dd><p>Husbands attitude T5</p>
</dd>
<dt>fatt2t5</dt><dd><p>In-laws attitude T5</p>
</dd>
<dt>fatt3t5</dt><dd><p>Own parents attitude T5</p>
</dd>
<dt>byrt5</dt><dd><p>Start of Time 5 from year</p>
</dd>
<dt>lngtht5</dt><dd><p>Length of Time 5</p>
</dd>
<dt>awe1t5</dt><dd><p>FP Contact Time 5</p>
</dd>
<dt>awe2t5</dt><dd><p>Methods known at Time 5</p>
</dd>
<dt>awe3t5</dt><dd><p>Knowledge of service sites Time 5</p>
</dd>
<dt>awe4t5</dt><dd><p>Credibility of service site Time 5</p>
</dd>
<dt>fpt6</dt><dd><p>FP Status time 6</p>
</dd>
<dt>fatt1t6</dt><dd><p>Husbands attitude T6</p>
</dd>
<dt>fatt2t6</dt><dd><p>In-laws attitude T6</p>
</dd>
<dt>fatt3t6</dt><dd><p>Own parents attitude T6</p>
</dd>
<dt>byrt6</dt><dd><p>Start of Time 6 from year</p>
</dd>
<dt>lngtht6</dt><dd><p>Length of Time 6</p>
</dd>
<dt>awe1t6</dt><dd><p>FP Contact Time 6</p>
</dd>
<dt>awe2t6</dt><dd><p>Methods known at Time 6</p>
</dd>
<dt>awe3t6</dt><dd><p>Knowledge of service sites Time 6</p>
</dd>
<dt>awe4t6</dt><dd><p>Credibility of service site Time 6</p>
</dd>
<dt>recno7</dt><dd><p>rec no NA</p>
</dd>
<dt>studno7</dt><dd><p>study no NA</p>
</dd>
<dt>area7</dt><dd><p>village</p>
</dd>
<dt>id7</dt><dd><p>id</p>
</dd>
<dt>fpt7</dt><dd><p>FP Status time 7</p>
</dd>
<dt>fatt1t7</dt><dd><p>Husbands attitude T7</p>
</dd>
<dt>fatt2t7</dt><dd><p>In-laws attitude T7</p>
</dd>
<dt>fatt3t7</dt><dd><p>Own parents attitude T7</p>
</dd>
<dt>byrt7</dt><dd><p>Start of Time 7 from year</p>
</dd>
<dt>lngtht7</dt><dd><p>Length of Time 7</p>
</dd>
<dt>awe1t7</dt><dd><p>FP Contact Time 7</p>
</dd>
<dt>awe2t7</dt><dd><p>Methods known at Time 7</p>
</dd>
<dt>awe3t7</dt><dd><p>Knowledge of service sites Time 7</p>
</dd>
<dt>awe4t7</dt><dd><p>Credibility of service site Time 7</p>
</dd>
<dt>fpt8</dt><dd><p>FP Status time 8</p>
</dd>
<dt>fatt1t8</dt><dd><p>Husbands attitude T8</p>
</dd>
<dt>fatt2t8</dt><dd><p>In-laws attitude T8</p>
</dd>
<dt>fatt3t8</dt><dd><p>Own parents attitude T8</p>
</dd>
<dt>byrt8</dt><dd><p>Start of Time 8 from year</p>
</dd>
<dt>lngtht8</dt><dd><p>Length of Time 8</p>
</dd>
<dt>awe1t8</dt><dd><p>FP Contact Time 8</p>
</dd>
<dt>awe2t8</dt><dd><p>Methods known at Time 8</p>
</dd>
<dt>awe3t8</dt><dd><p>Knowledge of service sites Time 8</p>
</dd>
<dt>awe4t8</dt><dd><p>Credibility of service site Time 8</p>
</dd>
<dt>fpt9</dt><dd><p>FP Status time 9</p>
</dd>
<dt>fatt1t9</dt><dd><p>Husbands attitude T9</p>
</dd>
<dt>fatt2t9</dt><dd><p>In-laws attitude T9</p>
</dd>
<dt>fatt3t9</dt><dd><p>Own parents attitude T9</p>
</dd>
<dt>byrt9</dt><dd><p>Start of Time 9 from year</p>
</dd>
<dt>lngtht9</dt><dd><p>Length of Time 9</p>
</dd>
<dt>awe1t9</dt><dd><p>FP Contact Time 9</p>
</dd>
<dt>awe2t9</dt><dd><p>Methods known at Time 9</p>
</dd>
<dt>awe3t9</dt><dd><p>Knowledge of service sites Time 9</p>
</dd>
<dt>awe4t9</dt><dd><p>Credibility of service site Time 9</p>
</dd>
<dt>fpt10</dt><dd><p>FP Status time 10</p>
</dd>
<dt>fatt1t10</dt><dd><p>Husbands attitude T10</p>
</dd>
<dt>fatt2t10</dt><dd><p>In-laws attitude T10</p>
</dd>
<dt>fatt3t10</dt><dd><p>Own parents attitude T10</p>
</dd>
<dt>byrt10</dt><dd><p>Start of Time 10 from year</p>
</dd>
<dt>lngtht10</dt><dd><p>Length of Time 10</p>
</dd>
<dt>awe1t10</dt><dd><p>FP Contact Time 10</p>
</dd>
<dt>awe2t10</dt><dd><p>Methods known at Time 10</p>
</dd>
<dt>awe3t10</dt><dd><p>Knowledge of service sites Time 10</p>
</dd>
<dt>awe4t10</dt><dd><p>Credibility of service site Time 10</p>
</dd>
<dt>fpt11</dt><dd><p>FP Status time 11</p>
</dd>
<dt>fatt1t11</dt><dd><p>Husbands attitude T11</p>
</dd>
<dt>fatt2t11</dt><dd><p>In-laws attitude T11</p>
</dd>
<dt>fatt3t11</dt><dd><p>Own parents attitude T11</p>
</dd>
<dt>byrt11</dt><dd><p>Start of Time 11 from year</p>
</dd>
<dt>lngtht11</dt><dd><p>Length of Time 11</p>
</dd>
<dt>awe1t11</dt><dd><p>FP Contact Time 11</p>
</dd>
<dt>awe2t11</dt><dd><p>Methods known at Time 11</p>
</dd>
<dt>awe3t11</dt><dd><p>Knowledge of service sites Time 11</p>
</dd>
<dt>awe4t11</dt><dd><p>Credibility of service site Time 11</p>
</dd>
<dt>fpt12</dt><dd><p>FP Status time 12</p>
</dd>
<dt>fatt1t12</dt><dd><p>Husbands attitude T12</p>
</dd>
<dt>fatt2t12</dt><dd><p>In-laws attitude T12</p>
</dd>
<dt>fatt3t12</dt><dd><p>Own parents attitude T12</p>
</dd>
<dt>byrt12</dt><dd><p>Start of Time 12 from year</p>
</dd>
<dt>lngtht12</dt><dd><p>Length of Time 12</p>
</dd>
<dt>awe1t12</dt><dd><p>FP Contact Time 12</p>
</dd>
<dt>awe2t12</dt><dd><p>Methods known at Time 12</p>
</dd>
<dt>awe3t12</dt><dd><p>Knowledge of service sites Time 12</p>
</dd>
<dt>awe4t12</dt><dd><p>Credibility of service site Time 12</p>
</dd>
<dt>ado</dt><dd><p>adopt times years converted to 1=63</p>
</dd>
<dt>ado1</dt><dd></dd>
<dt>ado2</dt><dd></dd>
<dt>ado3</dt><dd></dd>
<dt>commun</dt><dd><p>Village number</p>
</dd>
<dt>toa</dt><dd><p>Time of Adoption</p>
</dd>
<dt>study</dt><dd><p>Study (for when multiple diff studies used)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset has 1,047 respondents (women) from 25 communities. Collected
during 1973 it spans 11 years of data.
</p>


<h3>Source</h3>

<p>The Korean Family Planning data were
stored on a Vax tape that Rogers had given to Marc Granovetter who then gave
it to his colleague Roland Soong (see Granovetter &amp; Soong, 1983).  Granovetter
instructed Song to send the tape to me and I had it loaded on the Vax machine
at USC in 1990 and was able to download the data to a PC. The first two datasets
were acquired for my dissertation (Valente, 1991) and the third added as I
completed my book on Network Models of the Diffusion of Innovations (Valente,
1995; also see Valente, 2005).
</p>


<h3>References</h3>

<p>Everett M. Rogers, &amp; Kincaid, D. L. (1981). Communication Networks: Toward a
New Paradigm for Research. (C. Macmillan, Ed.). New York; London: Free Press.
</p>
<p>Valente, T. W. (1995). Network models of the diffusion of innovations (2nd ed.).
Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='kfamilyDiffNet'><code>diffnet</code> version of the Korean Family Planning data</h2><span id='topic+kfamilyDiffNet'></span>

<h3>Description</h3>

<p>A directed dynamic graph with 1,047 vertices and 11 time periods. The attributes
in the graph are static and described in <code><a href="#topic+kfamily">kfamily</a></code>.
</p>


<h3>Format</h3>

<p>A <code><a href="#topic+diffnet">diffnet</a></code> class object.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='matrix_compare'>Non-zero element-wise comparison between two sparse matrices</h2><span id='topic+matrix_compare'></span><span id='topic+binary-functions'></span><span id='topic+compare_matrix'></span>

<h3>Description</h3>

<p>Taking advantage of matrix sparseness, the function only evaluates
<code>fun</code> between pairs of elements of <code>A</code> and <code>B</code> where
either <code>A</code> or <code>B</code> have non-zero values. This can be helpful
to implement other binary operators between sparse matrices that may
not be implemented in the <span class="pkg">Matrix</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_compare(A, B, fun)

compare_matrix(A, B, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_compare_+3A_a">A</code></td>
<td>
<p>A matrix of size <code>n*m</code> of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="matrix_compare_+3A_b">B</code></td>
<td>
<p>A matrix of size <code>n*m</code> of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="matrix_compare_+3A_fun">fun</code></td>
<td>
<p>A function that receives 2 arguments and returns a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of comparing element by element, the function
loops through each matrix non-zero elements to make the comparisons, which
in the case of sparse matrices can be more efficient (faster). Algorithmically
it can be described as follows:
</p>
<pre>
# Matrix initialization
init ans[n,m];

# Looping through non-zero elements of A
for e_A in E_A:
  ans[e_A] = fun(A[e_A], B[e_A])

# Looping through non-zero elements of B and applying the function
# in e_B only if it was not applied while looping in E_A.
for e_B in E_B:
  if (ans[e_B] == Empty)
    ans[e_B] = fun(A[e_B], B[e_B])

</pre>
<p><code>compare_matrix</code> is just an alias for <code>matrix_compare</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>dgCMatrix</code> of size <code>n*m</code>.
</p>


<h3>See Also</h3>

<p>Other dyadic-level comparison functions: 
<code><a href="#topic+vertex_covariate_compare">vertex_covariate_compare</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These two should yield the same results -----------------------------------

# Creating two random matrices
set.seed(89)
A &lt;- rgraph_ba(t = 9, m = 4)
B &lt;- rgraph_ba(t = 9, m = 4)
A;B

# Comparing
ans0 &lt;- matrix_compare(A,B, function(a,b) (a+b)/2)

ans1 &lt;- matrix(0, ncol=10, nrow=10)
for (i in 1:10)
  for (j in 1:10)
    ans1[i,j] &lt;- mean(c(A[i,j], B[i,j]))

# Are these equal?
all(ans0[] == ans1[]) # Should yield TRUE

</code></pre>

<hr>
<h2 id='medInnovations'>Medical Innovation</h2><span id='topic+medInnovations'></span>

<h3>Description</h3>

<p>From Valente (1995) &ldquo;Coleman, Katz and Menzel from Columbia University's Bureau of Applied Research
studied the adoption of tetracycline by physiciams in four Illinois communities
in 1954.[...] Tetracycline was a powerful and useful antibiotic just introduced in
the mid-1950s&rdquo;
</p>


<h3>Format</h3>

<p>A data frame with 125 rows and 59 columns:
</p>

<dl>
<dt>city</dt><dd><p>city id</p>
</dd>
<dt>id</dt><dd><p>sequential respondent id</p>
</dd>
<dt>detail</dt><dd><p>detail man</p>
</dd>
<dt>meet</dt><dd><p>meetings, lectures, hospitals</p>
</dd>
<dt>coll</dt><dd><p>colleagues</p>
</dd>
<dt>attend</dt><dd><p>attend professional meets</p>
</dd>
<dt>proage</dt><dd><p>professional age</p>
</dd>
<dt>length</dt><dd><p>lenght of reside in community</p>
</dd>
<dt>here</dt><dd><p>only practice here</p>
</dd>
<dt>science</dt><dd><p>science versus patients</p>
</dd>
<dt>position</dt><dd><p>position in home base</p>
</dd>
<dt>journ2</dt><dd><p>journal subscriptions</p>
</dd>
<dt>paadico</dt><dd><p>Percent alter adoption date imp</p>
</dd>
<dt>ado</dt><dd><p>adoption month 1 to 18</p>
</dd>
<dt>thresh</dt><dd><p>threshold</p>
</dd>
<dt>ctl</dt><dd><p>corrected tl tl-exp level</p>
</dd>
<dt>catbak</dt><dd><p>category 1-init 2-marg 3-low tl</p>
</dd>
<dt>sourinfo</dt><dd><p>source of information</p>
</dd>
<dt>origid</dt><dd><p>original respondent id</p>
</dd>
<dt>adopt</dt><dd><p>adoption date 1= 11/53</p>
</dd>
<dt>recon</dt><dd><p>reconstructed med innov</p>
</dd>
<dt>date</dt><dd><p>date became aware</p>
</dd>
<dt>info</dt><dd><p>information source</p>
</dd>
<dt>most</dt><dd><p>most important info source</p>
</dd>
<dt>journ</dt><dd><p>journals</p>
</dd>
<dt>drug</dt><dd><p>drug houses</p>
</dd>
<dt>net1_1</dt><dd><p>advisor nomination1</p>
</dd>
<dt>net1_2</dt><dd><p>advisor nomination2</p>
</dd>
<dt>net1_3</dt><dd><p>advisor nomination3</p>
</dd>
<dt>net2_1</dt><dd><p>discuss nomination1</p>
</dd>
<dt>net2_2</dt><dd><p>discuss nomination2</p>
</dd>
<dt>net2_3</dt><dd><p>discuss nomination3</p>
</dd>
<dt>net3_1</dt><dd><p>friends nomination1</p>
</dd>
<dt>net3_2</dt><dd><p>friends nomination2</p>
</dd>
<dt>net3_3</dt><dd><p>friends nomination3</p>
</dd>
<dt>nojourn</dt><dd><p>number of pro journals receive</p>
</dd>
<dt>free</dt><dd><p>free time companions</p>
</dd>
<dt>social</dt><dd><p>med discussions during social</p>
</dd>
<dt>club</dt><dd><p>club membership</p>
</dd>
<dt>friends</dt><dd><p>friends are doctors</p>
</dd>
<dt>young</dt><dd><p>young patients</p>
</dd>
<dt>nonpoor</dt><dd><p>nonpoverty patients</p>
</dd>
<dt>office</dt><dd><p>office visits</p>
</dd>
<dt>house</dt><dd><p>house calls</p>
</dd>
<dt>tend</dt><dd><p>tendency to prescribe drugs</p>
</dd>
<dt>reltend</dt><dd><p>relative tendency to prescribe</p>
</dd>
<dt>perc</dt><dd><p>perceived drug competition</p>
</dd>
<dt>proximty</dt><dd><p>physical proximity to other doc</p>
</dd>
<dt>home</dt><dd><p>home base hospital affiliation</p>
</dd>
<dt>special</dt><dd><p>specialty</p>
</dd>
<dt>belief</dt><dd><p>belief in science</p>
</dd>
<dt>proage2</dt><dd><p>profesional age 2</p>
</dd>
<dt>presc</dt><dd><p>prescription prone</p>
</dd>
<dt>detail2</dt><dd><p>contact with detail man</p>
</dd>
<dt>dichot</dt><dd><p>dichotomous personal preference</p>
</dd>
<dt>expect</dt><dd><p>adoption month expected</p>
</dd>
<dt>recall</dt><dd><p>recalls adopting</p>
</dd>
<dt>commun</dt><dd><p>Number of community</p>
</dd>
<dt>toa</dt><dd><p>Time of Adoption</p>
</dd>
<dt>study</dt><dd><p>Number of study in Valente (1995)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The collected dataset has 125 respondents (doctors), and spans 17 months of data
collected in 1955. Time of adoption of non-adopters has been set to month
18 (see the manual entry titled <code><a href="#topic+diffusion-data">Difussion Network Datasets</a></code>).
</p>


<h3>Source</h3>

<p>The Medical Innovation data were stored in file cabinets in a basement
building at Columbia University. Ron Burt (1987) acquired an NSF grant to
develop network diffusion models and retrieve the original surveys and enter
them into a database. He distributed copies of the data on diskette and sent
one to me, Tom Valente, and I imported onto a PC environment.
</p>


<h3>References</h3>

<p>Coleman, J., Katz, E., &amp; Menzel, H. (1966). Medical innovation: A diffusion
study (2nd ed.). New York: Bobbs-Merrill
</p>
<p>Valente, T. W. (1995). Network models of the diffusion of innovations (2nd ed.).
Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovationsDiffNet">medInnovationsDiffNet</a></code>
</p>

<hr>
<h2 id='medInnovationsDiffNet'><code>diffnet</code> version of the Medical Innovation data</h2><span id='topic+medInnovationsDiffNet'></span>

<h3>Description</h3>

<p>A directed dynamic graph with 125 vertices and 18 time periods. The attributes
in the graph are static and described in <code><a href="#topic+medInnovations">medInnovations</a></code>.
</p>


<h3>Format</h3>

<p>A <code><a href="#topic+diffnet">diffnet</a></code> class object.
</p>


<h3>See Also</h3>

<p>Other diffusion datasets: 
<code><a href="#topic+brfarmersDiffNet">brfarmersDiffNet</a></code>,
<code><a href="#topic+brfarmers">brfarmers</a></code>,
<code><a href="#topic+diffusion-data">diffusion-data</a></code>,
<code><a href="#topic+fakeDynEdgelist">fakeDynEdgelist</a></code>,
<code><a href="#topic+fakeEdgelist">fakeEdgelist</a></code>,
<code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>,
<code><a href="#topic+fakesurvey">fakesurvey</a></code>,
<code><a href="#topic+kfamilyDiffNet">kfamilyDiffNet</a></code>,
<code><a href="#topic+kfamily">kfamily</a></code>,
<code><a href="#topic+medInnovations">medInnovations</a></code>
</p>

<hr>
<h2 id='mentor_matching'>Optimal Leader/Mentor Matching</h2><span id='topic+mentor_matching'></span><span id='topic+leader_matching'></span><span id='topic+plot.diffnet_mentor'></span>

<h3>Description</h3>

<p>Implementes the algorithm described in Valente and Davis (1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mentor_matching(
  graph,
  n,
  cmode = "indegree",
  lead.ties.method = "average",
  geodist.args = list()
)

leader_matching(
  graph,
  n,
  cmode = "indegree",
  lead.ties.method = "average",
  geodist.args = list()
)

## S3 method for class 'diffnet_mentor'
plot(
  x,
  y = NULL,
  vertex.size = "degree",
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  lead.cols = grDevices::topo.colors(attr(x, "nleaders")),
  vshapes = c(Leader = "square", Follower = "circle"),
  add.legend = TRUE,
  main = "Mentoring Network",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mentor_matching_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_n">n</code></td>
<td>
<p>Number of leaders</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_cmode">cmode</code></td>
<td>
<p>Passed to <code><a href="#topic+dgr">dgr</a></code>.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_lead.ties.method">lead.ties.method</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+rank">rank</a></code></p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_geodist.args">geodist.args</code></td>
<td>
<p>Passed to <code><a href="#topic+approx_geodesic">approx_geodesic</a></code>.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_x">x</code></td>
<td>
<p>An object of class <code>diffnet_mentor</code>.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Either a numeric scalar or vector of size <code class="reqn">n</code>, or any
of the following values: &quot;indegree&quot;, &quot;degree&quot;, or &quot;outdegree&quot; (see details).</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_minmax.relative.size">minmax.relative.size</code></td>
<td>
<p>Passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_lead.cols">lead.cols</code></td>
<td>
<p>Character vector of length <code>attr(x,"nleaders")</code>. Colors
to be applied to each group. (see details)</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_vshapes">vshapes</code></td>
<td>
<p>Character scalar of length 2. Shapes to identify leaders (mentors)
and followers respectively.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_add.legend">add.legend</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> generates a legend to distinguish
between leaders and followers.</p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_main">main</code></td>
<td>
<p>Character scalar. Passed to <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="mentor_matching_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works as follows:
</p>

<ol>
<li><p> Find the top <code>n</code> individuals ranking them by <code>dgr(graph, cmode)</code>.
The rank is computed by the function <code><a href="base.html#topic+rank">rank</a></code>. Denote this set <code>M</code>.
</p>
</li>
<li><p> Compute the geodesic matrix.
</p>
</li>
<li><p> For each <code>v in V</code> do:
</p>

<ol>
<li><p> Find the mentor <code>m in M</code> such that is closest to <code>v</code>
</p>
</li>
<li><p> Were there a tie, choose the mentor that minimizes the average
path length from <code>v</code>'s direct neighbors to <code>m</code>.
</p>
</li>
<li><p> If there are no paths to any member of <code>M</code>, or all have the
same average path length to <code>v</code>'s neighbors, then assign one
randomly.
</p>
</li></ol>

</li></ol>

<p>Plotting is done via the function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>When <code>vertex.size</code> is either of <code>"degree"</code>, <code>"indegree"</code>, or
<code>"outdegree"</code>, <code>vertex.size</code> will be replace with <code>dgr(.,cmode = )</code>
so that the vertex size reflects the desired degree.
</p>
<p>The argument <code>minmax.relative.size</code> is passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>
which adjusts <code>vertex.size</code> so that the largest and smallest vertices
have a relative size of <code>minmax.relative.size[2]</code> and
<code>minmax.relative.size[1]</code> respectively with respect to the x-axis.
</p>


<h3>Value</h3>

<p>An object of class <code>diffnet_mentor</code> and <code>data.frame</code> with the following columns:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>Character. Labels of the vertices</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>Numeric. Degree of each vertex in the graph</p>
</td></tr>
<tr><td><code>iselader</code></td>
<td>
<p>Logical. <code>TRUE</code> when the vertex was picked as a leader.</p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p>Character. The corresponding matched leader.</p>
</td></tr>
</table>
<p>The object also contains the following attributes:
</p>
<table>
<tr><td><code>nleaders</code></td>
<td>
<p>Integer scalar. The resulting number of leaders (could be greater than <code>n</code>)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The original graph used to run the algorithm.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Valente, T. W., &amp; Davis, R. L. (1999). Accelerating the Diffusion of
Innovations Using Opinion Leaders. The ANNALS of the American Academy of
Political and Social Science, 566(1), 55–67.
<a href="https://doi.org/10.1177/000271629956600105">doi:10.1177/000271629956600105</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple example ----------------------------------------------------------
set.seed(1231)
graph &lt;- rgraph_ws(n=50, k = 4, p = .5)

# Looking for 3 mentors
ans &lt;- mentor_matching(graph, n = 3)

head(ans)
table(ans$match) # We actually got 9 b/c of ties

# Visualizing the mentor network
plot(ans)

</code></pre>

<hr>
<h2 id='moran'>Computes Moran's I correlation index</h2><span id='topic+moran'></span>

<h3>Description</h3>

<p>Natively built for computing Moran's I on <code>dgCMatrix</code> objects, this
routine allows computing the I on large sparse matrices (graphs). Part of
its implementation was based on <code><a href="ape.html#topic+Moran.I">ape::Moran.I</a></code>,
which computes the I for dense matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran(x, w, normalize.w = TRUE, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran_+3A_x">x</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="moran_+3A_w">w</code></td>
<td>
<p>Numeric matrix of size <code class="reqn">n\times n</code>. Weights. It can be
either a object of class <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>
from the <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> package.</p>
</td></tr>
<tr><td><code id="moran_+3A_normalize.w">normalize.w</code></td>
<td>
<p>Logical scalar. When TRUE normalizes rowsums to one (or zero).</p>
</td></tr>
<tr><td><code id="moran_+3A_alternative">alternative</code></td>
<td>
<p>Character String. Specifies the alternative hypothesis that
is tested against the null of no autocorrelation; must be of one <code>"two.sided"</code>,
<code>"less"</code>, or <code>"greater"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case that the vector <code>x</code> is close to constant (degenerate random
variable), the statistic becomes irrelevant, and furthermore, the standard error
tends to be undefined (<code>NaN</code>).
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet_moran</code> with the following elements:
</p>
<table>
<tr><td><code>observed</code></td>
<td>
<p>Numeric scalar. Observed correlation index.</p>
</td></tr>
<tr><td><code>expected</code></td>
<td>
<p>Numeric scalar. Expected correlation index equal to <code class="reqn">-1/(N-1)</code>.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Numeric scalar. Standard error under the null.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Numeric scalar. p-value of the specified <code>alternative</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Moran's I. (2015, September 3). In Wikipedia, The Free Encyclopedia.
Retrieved 06:23, December 22, 2015, from <a href="https://en.wikipedia.org/w/index.php?title=Moran%27s_I&amp;oldid=679297766">https://en.wikipedia.org/w/index.php?title=Moran%27s_I&amp;oldid=679297766</a>
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>
<p>Other Functions for inference: 
<code><a href="#topic+bootnet">bootnet</a>()</code>,
<code><a href="#topic+struct_test">struct_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ape")) {

  # Generating a small random graph
  set.seed(123)
  graph &lt;- rgraph_ba(t = 4)
  w &lt;- approx_geodesic(graph)
  x &lt;- rnorm(5)

  # Computing Moran's I
  moran(x, w)

  # Comparing with the ape's package version
  ape::Moran.I(x, as.matrix(w))

}

</code></pre>

<hr>
<h2 id='netdiffuseR-graphs'>Network data formats</h2><span id='topic+netdiffuseR-graphs'></span>

<h3>Description</h3>

<p>List of accepted graph formats
</p>


<h3>Details</h3>

<p>The <span class="pkg">netdiffuseR</span> package can handle different types of graph
objects. Two general classes are defined across the package's functions:
static graphs, and dynamic graphs.
</p>

<ul>
<li><p>In the case of <strong>static graphs</strong>, these are represented as adjacency
matrices of size <code class="reqn">n\times n</code> and can be either <code><a href="base.html#topic+matrix">matrix</a></code>
(dense matrices) or <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>
(sparse matrix from the <span class="pkg"><a href="Matrix.html#topic+Matrix">Matrix</a></span> package). While
most of the package functions are defined for both classes, the default output
graph is sparse, i.e. <code>dgCMatrix</code>.
</p>
</li>
<li><p>With respect to <strong>dynamic graphs</strong>, these are represented by either
a <code><a href="#topic+diffnet">diffnet</a></code> object, an <code><a href="base.html#topic+array">array</a></code> of size
<code class="reqn">n\times n \times T</code>, or a list of size <code class="reqn">T</code>
with sparse matrices (class <code>dgCMatrix</code>) of size <code class="reqn">n\times n</code>.
Just like the static graph case, while most of the functions accept both
graph types, the default output is <code>dgCMatrix</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value (this manual entry only provides information).
</p>


<h3>diffnet objects</h3>

<p>In the case of <code>diffnet</code>-class objects, the following arguments can be omitted
when calling fuictions suitable for graph objects:
</p>

<ul>
<li><p><code>toa</code>: Time of Adoption vector
</p>
</li>
<li><p><code>adopt</code>: Adoption Matrix
</p>
</li>
<li><p><code>cumadopt</code>: Cumulative Adoption Matrix
</p>
</li>
<li><p><code>undirected</code>: Whether the graph is directed or not
</p>
</li></ul>



<h3>Objects' names</h3>

<p>When possible, <span class="pkg">netdiffuseR</span> will try to reuse graphs dimensional names,
this is, <code><a href="base.html#topic+rownames">rownames</a></code>, <code><a href="base.html#topic+colnames">colnames</a></code>, <code><a href="base.html#topic+dimnames">dimnames</a></code>
and <code><a href="base.html#topic+names">names</a></code> (in the case of dynamic graphs as lists). Otherwise,
when no names are provided, these will be created from scratch.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>

<hr>
<h2 id='netdiffuseR-options'><span class="pkg">netdiffuseR</span> default options</h2><span id='topic+netdiffuseR-options'></span>

<h3>Description</h3>

<p><span class="pkg">netdiffuseR</span> default options
</p>


<h3>Details</h3>

<p>Set of default options used by the package. These can be retrieved
via <code><a href="base.html#topic+getOption">getOption</a></code> using the prefix <code>diffnet</code> (see examples)
</p>


<h3>Value</h3>

<p>The full list of options follows:
</p>
<table>
<tr><td><code>undirected</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>self</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>multiple</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>1e-8 (used for package testing)</p>
</td></tr>
<tr><td><code>valued</code></td>
<td>
<p>FALSE</p>
</td></tr>
<tr><td><code>outgoing</code></td>
<td>
<p>TRUE</p>
</td></tr>
<tr><td><code>keep.isolates</code></td>
<td>
<p>TRUE</p>
</td></tr>
<tr><td><code>minmax.relative.size</code></td>
<td>
<p><code>c(0.025, 0.05)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getOption("diffnet.undirected")
getOption("diffnet.multiple")
getOption("diffnet.self")
</code></pre>

<hr>
<h2 id='netmatch'>Matching Estimators with Network Data</h2><span id='topic+netmatch'></span><span id='topic+netmatch_prepare'></span>

<h3>Description</h3>

<p><strong>WARNING</strong>: This function is still in development and has not been tested throughly.
Following Aral et al. (2009), <code>netmatch</code> computes matching
estimators for network data. The function <code>netmatch_prepare</code>, which
prepares the data to be used with <code><a href="MatchIt.html#topic+matchit">matchit</a></code> from
the <span class="pkg"><a href="MatchIt.html#topic+MatchIt">MatchIt</a></span> package, is called by <code>netmatch</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netmatch_prepare(
  dat,
  graph,
  timevar,
  depvar,
  covariates,
  treat_thr = rep(1L, length(graph)),
  adopt_thr = rep(1L, length(graph)),
  expo_pcent = FALSE,
  expo_lag = 0L
)

netmatch(
  dat,
  graph,
  timevar,
  depvar,
  covariates,
  treat_thr = rep(1L, length(graph)),
  adopt_thr = rep(1L, length(graph)),
  expo_pcent = FALSE,
  expo_lag = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netmatch_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> with dynamic data. Must be of
<code>nrow(dat)==nslices(graph)*nnodes(graph)</code>.</p>
</td></tr>
<tr><td><code id="netmatch_+3A_graph">graph</code></td>
<td>
<p>List with sparse matrices.</p>
</td></tr>
<tr><td><code id="netmatch_+3A_timevar">timevar</code></td>
<td>
<p>Character scalar. Name of time variable</p>
</td></tr>
<tr><td><code id="netmatch_+3A_depvar">depvar</code></td>
<td>
<p>Character scalar. Name of the dependent variable</p>
</td></tr>
<tr><td><code id="netmatch_+3A_covariates">covariates</code></td>
<td>
<p>Character vector. Name(s) of the control variable(s).</p>
</td></tr>
<tr><td><code id="netmatch_+3A_treat_thr">treat_thr</code></td>
<td>
<p>Either a numeric scalar or vector of length <code>nslices(graph)</code>.
Sets the threshold of <code>exposure</code> at which it is considered that an
observation is treated.</p>
</td></tr>
<tr><td><code id="netmatch_+3A_adopt_thr">adopt_thr</code></td>
<td>
<p>Either a numeric scalar or vector of length <code>nslices(graph)</code>.
Sets the threshold of <code>depvar</code> at which it is considered that an observation
has adopted a behavior.</p>
</td></tr>
<tr><td><code id="netmatch_+3A_expo_pcent">expo_pcent</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, exposure is computed
non-normalized (so it is a count rather than a percentage).</p>
</td></tr>
<tr><td><code id="netmatch_+3A_expo_lag">expo_lag</code></td>
<td>
<p>Integer scalar. Number of lags to consider when computing
exposure. <code>expo_lag=1</code> defines exposure in T considering behavior and
network at T-1.</p>
</td></tr>
<tr><td><code id="netmatch_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="MatchIt.html#topic+matchit">matchit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Aral et al. (2009), the matching estimator is used as a response to the
fact that the observed network is homophilous. Essentially, using exposure
as a treatment indicator, which is known to be endogenous, we can apply the
same principle of matching estimators in which, after controlling for characteristics
(covariates), individuals from the treated group (exposed to some behavior)
can be compared to individuals from the control group (not exposed to that
behavior), as the only difference between the two is the exposure.
</p>
<p>As pointed out in King &amp; Nielsen (2015), it is suggested that, contrary to
what Aral et al. (2009), the matching is not performed over propensity score
since it is know that the later can increase imbalances in the data and thus
obtaining exactly the opposed outcome that matching based estimators pursue.
</p>
<p>A couple of good references for matching estimators are Imbens and Wooldridge
(2009), and Sekhon (2008).
</p>


<h3>Value</h3>

<p>In the case of <code>netmatch_prepare</code>
</p>
<table>
<tr><td><code>dat</code></td>
<td>
<p>A <code>data.frame</code> with the original data (covariates), plus the
following new variables: <code>treat</code>, <code>adopt</code>, <code>exposure</code>.
</p>
</td></tr>
<tr><td><code>match_model</code></td>
<td>
<p>A formula to be passed to <code>netmatch</code></p>
</td></tr>
</table>
<p><code>netmatch</code> returns the following:
</p>
<table>
<tr><td><code>fATT</code></td>
<td>
<p>A numeric vector of length <code class="reqn">N_1</code> (number of treated used
in the matching process). Treatment effects on the treated at the individual
level</p>
</td></tr>
<tr><td><code>match_obj</code></td>
<td>
<p>The output from <code>matchit</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Aral, S., Muchnik, L., &amp; Sundararajan, A. (2009). Distinguishing
influence-based contagion from homophily-driven diffusion in dynamic networks.
Proceedings of the National Academy of Sciences of the United States of America,
106(51), 21544–21549. <a href="https://doi.org/10.1073/pnas.0908800106">doi:10.1073/pnas.0908800106</a>
</p>
<p>Imbens, G. W., &amp; Wooldridge, J. M. (2009). Recent Developments in the
Econometrics of Program Evaluation. Journal of Economic Literature, 47(1),
5–86. <a href="https://doi.org/10.1257/jel.47.1.5">doi:10.1257/jel.47.1.5</a>
</p>
<p>King, G., &amp; Nielsen, R. (2015). Why Propensity Scores Should Not Be Used for.
</p>
<p>Sekhon, J. S. (2008). The Neyman-Rubin Model of Causal Inference and Estimation
Via Matching Methods. The Oxford Handbook of Political Methodology.
<a href="https://doi.org/10.1093/oxfordhb/9780199286546.003.0011">doi:10.1093/oxfordhb/9780199286546.003.0011</a>
</p>

<hr>
<h2 id='network'>Coercion between <code>diffnet</code>, <code>network</code> and <code>networkDynamic</code></h2><span id='topic+network'></span><span id='topic+networkDynamic'></span><span id='topic+diffnet_to_network'></span><span id='topic+diffnet_to_networkDynamic'></span><span id='topic+networkDynamic_to_diffnet'></span><span id='topic+network_to_diffnet'></span>

<h3>Description</h3>

<p>Coercion between <code>diffnet</code>, <code>network</code> and <code>networkDynamic</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffnet_to_network(graph, slices = 1:nslices(graph), ...)

diffnet_to_networkDynamic(
  graph,
  slices = 1:nslices(graph),
  diffnet2net.args = list(),
  netdyn.args = list()
)

networkDynamic_to_diffnet(graph, toavar)

network_to_diffnet(
  graph = NULL,
  graph.list = NULL,
  toavar,
  t0 = NULL,
  t1 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_+3A_graph">graph</code></td>
<td>
<p>An object of class <code><a href="#topic+diffnet">diffnet</a></code></p>
</td></tr>
<tr><td><code id="network_+3A_slices">slices</code></td>
<td>
<p>An integer vector indicating the slices to subset</p>
</td></tr>
<tr><td><code id="network_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code></p>
</td></tr>
<tr><td><code id="network_+3A_diffnet2net.args">diffnet2net.args</code></td>
<td>
<p>List of arguments passed to <code>diffnet_to_network</code>.</p>
</td></tr>
<tr><td><code id="network_+3A_netdyn.args">netdyn.args</code></td>
<td>
<p>List of arguments passed to <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code></p>
</td></tr>
<tr><td><code id="network_+3A_toavar">toavar</code></td>
<td>
<p>Character scalar. Name of the vertex attribute that holds the times of adoption.</p>
</td></tr>
<tr><td><code id="network_+3A_graph.list">graph.list</code></td>
<td>
<p>A list of <code>network</code> objects.</p>
</td></tr>
<tr><td><code id="network_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+diffnet-class">new_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="network_+3A_t1">t1</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+diffnet-class">new_diffnet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diffnet_to_networkDynamic</code> calls <code>diffnet_to_network</code> and
uses the output to call <code>networkDynamic</code>, passing the resulting list of
<code>network</code> objects as <code>network.list</code> (see <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>).
</p>
<p>By default, <code>diffnet_to_networkDynamic</code> passes <code>net.obs.period</code> as
</p>
<pre>
  net.obs.period = list(
    observations = list(range(graph$meta$pers)),
    mode="discrete",
    time.increment = 1,
    time.unit = "step"
  )
</pre>
<p>By default, <code>networkDynamic_to_diffnet</code> uses the first slice as reference for
vertex attributes and times of adoption.
</p>
<p>By default, <code>network_to_diffnet</code> uses the first element of <code>graph</code>
(a list) as reference for vertex attributes and times of adoption.
</p>


<h3>Value</h3>

<p><code>diffnet_to_network</code> returns a list of length <code>length(slices)</code> in which
each element is a <code><a href="network.html#topic+network">network</a></code> object corresponding a slice of the
<code>graph</code> (<code>diffnet</code> object). The attributes list will include <code>toa</code> (time of
adoption).
</p>
<p>An object of class <code>networkDynamic</code>.
</p>


<h3>Caveats</h3>

<p>Since <code>diffnet</code> does not support edges attributes, these will be lost when
converting from <code>network</code>-type objects. The same applies to <code>network</code>
attributes.
</p>


<h3>See Also</h3>

<p>Other Foreign: 
<code><a href="#topic+igraph">igraph</a></code>,
<code><a href="#topic+read_pajek">read_pajek</a>()</code>,
<code><a href="#topic+read_ucinet_head">read_ucinet_head</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cohersing a diffnet to a list of networks ---------------------------------
set.seed(1)
ans &lt;- diffnet_to_network(rdiffnet(20, 2))
ans

# and back
network_to_diffnet(graph.list = ans, toavar="toa")

# If it was static, we can use -graph- instead
network_to_diffnet(ans[[1]], toavar="toa")

# A random diffusion network ------------------------------------------------
set.seed(87)
dn  &lt;- rdiffnet(50, 4)
ans &lt;- diffnet_to_networkDynamic(dn)

# and back
networkDynamic_to_diffnet(ans, toavar = "toa")

</code></pre>

<hr>
<h2 id='nvertices'>Count the number of vertices/edges/slices in a graph</h2><span id='topic+nvertices'></span><span id='topic+nnodes'></span><span id='topic+nedges'></span><span id='topic+nlinks'></span><span id='topic+nslices'></span>

<h3>Description</h3>

<p>Count the number of vertices/edges/slices in a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvertices(graph)

nnodes(graph)

nedges(graph)

nlinks(graph)

nslices(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvertices_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nnodes</code> and <code>nlinks</code> are just aliases for <code>nvertices</code> and
<code>nedges</code> respectively.
</p>


<h3>Value</h3>

<p>For <code>nvertices</code> and <code>nslices</code>, an integer scalar equal to the number
of vertices and slices in the graph. Otherwise, from <code>nedges</code>, either a list
of size <code class="reqn">t</code> with the counts of edges (non-zero elements in the adjacency matrices) at
each time period, or, when <code>graph</code> is static, a single scalar with
such number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a dynamic graph (we will use this for all the classes) -----------
set.seed(13133)
diffnet &lt;- rdiffnet(100, 4)

# Lets use the first time period as a static graph
graph_mat &lt;- diffnet$graph[[1]]
graph_dgCMatrix &lt;- methods::as(graph_mat, "dgCMatrix")

# Now lets generate the other dynamic graphs
graph_list  &lt;- diffnet$graph
graph_array &lt;- as.array(diffnet) # using the as.array method for diffnet objects

# Now we can compare vertices counts
nvertices(diffnet)
nvertices(graph_list)
nvertices(graph_array)

nvertices(graph_mat)
nvertices(graph_dgCMatrix)

# ... and edges count
nedges(diffnet)
nedges(graph_list)
nedges(graph_array)

nedges(graph_mat)
nedges(graph_dgCMatrix)
</code></pre>

<hr>
<h2 id='permute_graph'>Permute the values of a matrix</h2><span id='topic+permute_graph'></span><span id='topic+CUG'></span><span id='topic+QAP'></span><span id='topic+rewire_permute'></span><span id='topic+rewire_qap'></span>

<h3>Description</h3>

<p><code>permute_graph</code> Shuffles the values of a matrix either considering
<em>loops</em> and <em>multiple</em> links (which are processed as cell values
different than 1/0). <code>rewire_qap</code> generates a new graph <code>graph</code><code class="reqn">'</code>
that is isomorphic to <code>graph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_graph(graph, self = FALSE, multiple = FALSE)

rewire_permute(graph, self = FALSE, multiple = FALSE)

rewire_qap(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_graph_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="permute_graph_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="permute_graph_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A permuted version of <code>graph</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Anderson, B. S., Butts, C., &amp; Carley, K. (1999). The interaction of size and
density with graph-level indices. Social Networks, 21(3), 239–267.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900011-8">doi:10.1016/S0378-8733(99)00011-8</a>
</p>
<p>Mantel, N. (1967). The detection of disease clustering and a generalized
regression approach. Cancer Research, 27(2), 209–20.
</p>


<h3>See Also</h3>

<p>This function can be used as null distribution in <code>struct_test</code>
</p>
<p>Other simulation functions: 
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example ------------------------------------------------------------
set.seed(1231)
g &lt;- rgraph_ba(t=9)
g

# These preserve the density
permute_graph(g)
permute_graph(g)

# These are isomorphic to g
rewire_qap(g)
rewire_qap(g)

</code></pre>

<hr>
<h2 id='plot_adopters'>Visualize adopters and cumulative adopters</h2><span id='topic+plot_adopters'></span>

<h3>Description</h3>

<p>Visualize adopters and cumulative adopters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_adopters(
  obj,
  freq = FALSE,
  what = c("adopt", "cumadopt"),
  add = FALSE,
  include.legend = TRUE,
  include.grid = TRUE,
  pch = c(21, 24),
  type = c("b", "b"),
  ylim = if (!freq) c(0, 1) else NULL,
  lty = c(1, 1),
  col = c("black", "black"),
  bg = c("tomato", "gray"),
  xlab = "Time",
  ylab = ifelse(freq, "Frequency", "Proportion"),
  main = "Adopters and Cumulative Adopters",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_adopters_+3A_obj">obj</code></td>
<td>
<p>Either a diffnet object or a cumulative a doption matrix.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_freq">freq</code></td>
<td>
<p>Logical scalar. When TRUE frequencies are plotted instead of proportions.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_what">what</code></td>
<td>
<p>Character vector of length 2. What to plot.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_add">add</code></td>
<td>
<p>Logical scalar. When TRUE lines and dots are added to the current graph.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_include.legend">include.legend</code></td>
<td>
<p>Logical scalar. When TRUE a legend of the graph is plotted.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_include.grid">include.grid</code></td>
<td>
<p>Logical scalar. When TRUE, the grid of the graph is drawn</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_pch">pch</code></td>
<td>
<p>Integer vector of length 2. See <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_type">type</code></td>
<td>
<p>Character vector of length 2. See <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2. Sets the plotting limit for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_lty">lty</code></td>
<td>
<p>Numeric vector of length 2. See <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_col">col</code></td>
<td>
<p>Character vector of length 2. See <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_bg">bg</code></td>
<td>
<p>Character vector of length 2. See <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. Name of the x-axis.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. Name of the y-axis.</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the plot</p>
</td></tr>
<tr><td><code id="plot_adopters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix as described in <code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a></code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a random diffnet -----------------------------------------------
set.seed(821)
diffnet &lt;- rdiffnet(100, 5, seed.graph="small-world", seed.nodes="central")

plot_adopters(diffnet)

# Alternatively, we can use a TOA Matrix
toa &lt;- sample(c(NA, 2010L,2015L), 20, TRUE)
mat &lt;- toa_mat(toa)
plot_adopters(mat$cumadopt)
</code></pre>

<hr>
<h2 id='plot_diffnet'>Plot the diffusion process</h2><span id='topic+plot_diffnet'></span><span id='topic+plot_diffnet.diffnet'></span><span id='topic+plot_diffnet.default'></span>

<h3>Description</h3>

<p>Creates a colored network plot showing the structure of the graph through time
(one network plot for each time period)  and the set of adopter and non-adopters
in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diffnet(...)

## S3 method for class 'diffnet'
plot_diffnet(graph, ...)

## Default S3 method:
plot_diffnet(
  graph,
  cumadopt,
  slices = NULL,
  vertex.color = c("white", "tomato", "steelblue"),
  vertex.shape = c("square", "circle", "circle"),
  vertex.size = "degree",
  mfrow.par = NULL,
  main = c("Network in period %s", "Diffusion Network"),
  legend.args = list(),
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  background = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_diffnet_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_cumadopt">cumadopt</code></td>
<td>
<p><code class="reqn">n\times T</code> matrix.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_slices">slices</code></td>
<td>
<p>Integer vector. Indicates what slices to plot. By default all are plotted.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_vertex.color">vertex.color</code></td>
<td>
<p>A character vector of size 3 with colors names.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_vertex.shape">vertex.shape</code></td>
<td>
<p>A character vector of size 3 with shape names.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Either a numeric scalar or vector of size <code class="reqn">n</code>, or any
of the following values: &quot;indegree&quot;, &quot;degree&quot;, or &quot;outdegree&quot; (see details).</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_mfrow.par">mfrow.par</code></td>
<td>
<p>Vector of size 2 with number of rows and columns to be passed to <code><a href="graphics.html#topic+par">par</a>.</code></p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_main">main</code></td>
<td>
<p>Character scalar. A title template to be passed to <code><a href="base.html#topic+sprintf">sprintf</a>.</code></p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_legend.args">legend.args</code></td>
<td>
<p>List of arguments to be passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_minmax.relative.size">minmax.relative.size</code></td>
<td>
<p>Passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet_+3A_background">background</code></td>
<td>
<p>Either a function to be called before plotting each slice, a color
to specify the backgroupd color, or <code>NULL</code> (in which case nothing is done).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting is done via the function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>When <code>vertex.size</code> is either of <code>"degree"</code>, <code>"indegree"</code>, or
<code>"outdegree"</code>, <code>vertex.size</code> will be replace with <code>dgr(.,cmode = )</code>
so that the vertex size reflects the desired degree.
</p>
<p>The argument <code>minmax.relative.size</code> is passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>
which adjusts <code>vertex.size</code> so that the largest and smallest vertices
have a relative size of <code>minmax.relative.size[2]</code> and
<code>minmax.relative.size[1]</code> respectively with respect to the x-axis.
</p>
<p>Plotting is done via the function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>In order to center the attention on the diffusion process itself, the
positions of each vertex are computed only once by aggregating the networks
through time, this is, instead of computing the layout for each time <code class="reqn">t</code>,
the function creates a new graph accumulating links through time.
</p>
<p>The <code>mfrow.par</code> sets how to arrange the plots on the device. If <code class="reqn">T=5</code>
and <code>mfrow.par=c(2,3)</code>, the first three networks will be in the top
of the device and the last two in the bottom.
</p>
<p>The argument <code>vertex.color</code> contains the colors of non-adopters, new-adopters,
and adopters respectively. The new adopters (default color <code>"tomato"</code>) have a different
color that the adopters when the graph is at their time of adoption, hence,
when the graph been plotted is in <code class="reqn">t=2</code> and <code class="reqn">toa=2</code> the vertex will
be plotted in red.
</p>
<p><code>legend.args</code> has the following default parameter:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>x</code> </td><td style="text-align: left;"> <code>"bottom"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>legend</code> </td><td style="text-align: left;"> <code>c("Non adopters", "New adopters","Adopters")</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pch</code> </td><td style="text-align: left;"> <code>sapply(vertex.shape, switch, circle = 21, square = 22, 21)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>bty</code> </td><td style="text-align: left;"> <code>"n"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>horiz</code> </td><td style="text-align: left;"> <code>TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Calculated coordinates for the grouped graph (invisible).
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a random graph
set.seed(1234)
n &lt;- 6
nper &lt;- 5
graph &lt;- rgraph_er(n,nper, p=.3, undirected = FALSE)
toa &lt;- sample(2000:(2000+nper-1), n, TRUE)
adopt &lt;- toa_mat(toa)

plot_diffnet(graph, adopt$cumadopt)
</code></pre>

<hr>
<h2 id='plot_diffnet2'>Another way of visualizing diffusion</h2><span id='topic+plot_diffnet2'></span><span id='topic+plot_diffnet2.diffnet'></span><span id='topic+plot_diffnet2.default'></span>

<h3>Description</h3>

<p>Another way of visualizing diffusion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_diffnet2(graph, ...)

## S3 method for class 'diffnet'
plot_diffnet2(graph, toa, slice = nslices(graph), ...)

## Default S3 method:
plot_diffnet2(
  graph,
  toa,
  pers = min(toa, na.rm = TRUE):max(toa, na.rm = TRUE),
  color.ramp = grDevices::colorRamp(viridisLite::magma(20)),
  layout = NULL,
  key.width = 0.1,
  key.args = list(),
  main = "Diffusion dynamics",
  add.map = NULL,
  diffmap.args = list(kde2d.args = list(n = 100)),
  diffmap.alpha = 0.5,
  include.white = "first",
  vertex.size = "degree",
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  no.graph = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_diffnet2_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_toa">toa</code></td>
<td>
<p>Integer vector of length <code class="reqn">n</code> with the times of adoption.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_slice">slice</code></td>
<td>
<p>Integer scalar. Number of slice to use as baseline for drawing the graph.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_pers">pers</code></td>
<td>
<p>Integer vector of length <code class="reqn">T</code> indicating the time periods of the data.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_color.ramp">color.ramp</code></td>
<td>
<p>A function as returned by <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_layout">layout</code></td>
<td>
<p>Passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_key.width">key.width</code></td>
<td>
<p>Numeric scalar. Sets the proportion of the plot (x-axis) that the key uses.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_key.args">key.args</code></td>
<td>
<p>List. Further arguments to be passed to <code><a href="#topic+drawColorKey">drawColorKey</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the graph.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_add.map">add.map</code></td>
<td>
<p>Character scalar. When <code>"first"</code> plots a <code><a href="#topic+diffusionMap">diffusionMap</a></code> before the
graph itself. If <code>"last"</code> then it adds it at the end. When <code>NULL</code> adds nothing.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_diffmap.args">diffmap.args</code></td>
<td>
<p>List. If <code>add.map=TRUE</code>, arguments passed to <code>diffusionMap</code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_diffmap.alpha">diffmap.alpha</code></td>
<td>
<p>Numeric scalar between [0,1]. Alpha level for the map.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_include.white">include.white</code></td>
<td>
<p>Character scalar. Includes white in the color palette used in the map.
When <code>include.white=NULL</code> then it won't include it.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Either a numeric scalar or vector of size <code class="reqn">n</code>, or any
of the following values: &quot;indegree&quot;, &quot;degree&quot;, or &quot;outdegree&quot; (see details).</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_minmax.relative.size">minmax.relative.size</code></td>
<td>
<p>Passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_diffnet2_+3A_no.graph">no.graph</code></td>
<td>
<p>Logical scala. When <code>TRUE</code> the graph is not drawn. This only makes
sense when the option <code>add.map</code> is active.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting is done via the function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>When <code>vertex.size</code> is either of <code>"degree"</code>, <code>"indegree"</code>, or
<code>"outdegree"</code>, <code>vertex.size</code> will be replace with <code>dgr(.,cmode = )</code>
so that the vertex size reflects the desired degree.
</p>
<p>The argument <code>minmax.relative.size</code> is passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>
which adjusts <code>vertex.size</code> so that the largest and smallest vertices
have a relative size of <code>minmax.relative.size[2]</code> and
<code>minmax.relative.size[1]</code> respectively with respect to the x-axis.
</p>
<p>If <code>key.width&lt;=0</code> then no key is created.
</p>
<p>By defult, the function passes the following values to <code>plot.igraph</code>:
</p>

<ul>
<li><p><code>vertex.label</code> equals to <code>""</code>
</p>
</li>
<li><p><code>vertex.frame.color</code> equals to <code>"white"</code>
</p>
</li>
<li><p><code>add</code> equals to <code>TRUE</code>
</p>
</li>
<li><p><code>rescale</code> equals to <code>FALSE</code>
</p>
</li>
<li><p><code>vertex.size</code> equals to <code>rescale.fun(vertex.size)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following elements
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p>A numeric matrix with vertex coordinates.</p>
</td></tr>
<tr><td><code>vertex.color</code></td>
<td>
<p>A character vector with computed colors for each vertex.</p>
</td></tr>
<tr><td><code>vertex.label</code></td>
<td>
<p>The value passed to <code>plot_diffnet2</code>.</p>
</td></tr>
<tr><td><code>vertex.shape</code></td>
<td>
<p>A character vector with assigned shapes.</p>
</td></tr>
<tr><td><code>vertex.size</code></td>
<td>
<p>A numeric vector with vertices sizes</p>
</td></tr>
<tr><td><code>diffmap</code></td>
<td>
<p>If <code>add.map=TRUE</code>, the returned values from <code><a href="#topic+diffmap">diffmap</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>

<hr>
<h2 id='plot_infectsuscep'>Plot distribution of infect/suscep</h2><span id='topic+plot_infectsuscep'></span>

<h3>Description</h3>

<p>After calculating infectiousness and susceptibility of each individual on the
network, it creates an <code>nlevels</code> by <code>nlevels</code> matrix indicating the
number of individuals that lie within each cell, and draws a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_infectsuscep(
  graph,
  toa,
  t0 = NULL,
  normalize = TRUE,
  K = 1L,
  r = 0.5,
  expdiscount = FALSE,
  bins = 20,
  nlevels = round(bins/2),
  h = NULL,
  logscale = TRUE,
  main = "Distribution of Infectiousness and\nSusceptibility",
  xlab = "Infectiousness of ego",
  ylab = "Susceptibility of ego",
  sub = ifelse(logscale, "(in log-scale)", NA),
  color.palette = function(n) viridisLite::viridis(n),
  include.grid = TRUE,
  exclude.zeros = FALSE,
  valued = getOption("diffnet.valued", FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_infectsuscep_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_toa">toa</code></td>
<td>
<p>Integer vector of length <code class="reqn">n</code> with the times of adoption.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. See <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_normalize">normalize</code></td>
<td>
<p>Logical scalar.  Passed to infection/susceptibility.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_k">K</code></td>
<td>
<p>Integer scalar.  Passed to infection/susceptibility.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_r">r</code></td>
<td>
<p>Numeric scalar.  Passed to infection/susceptibility.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_expdiscount">expdiscount</code></td>
<td>
<p>Logical scalar.  Passed to infection/susceptibility.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_bins">bins</code></td>
<td>
<p>Integer scalar. Size of the grid (<code class="reqn">n</code>).</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer scalar. Number of levels to plot (see <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>).</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_h">h</code></td>
<td>
<p>Numeric vector of length 2. Passed to <code><a href="MASS.html#topic+kde2d">kde2d</a></code> in the <span class="pkg">MASS</span> package.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_logscale">logscale</code></td>
<td>
<p>Logical scalar. When TRUE the axis of the plot will be presented in log-scale.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the graph.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. Title of the x-axis.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. Title of the y-axis.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_sub">sub</code></td>
<td>
<p>Character scalar. Subtitle of the graph.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_color.palette">color.palette</code></td>
<td>
<p>a color palette function to be used to assign colors in the plot (see <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>).</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_include.grid">include.grid</code></td>
<td>
<p>Logical scalar. When TRUE, the grid of the graph is drawn.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_exclude.zeros">exclude.zeros</code></td>
<td>
<p>Logical scalar. When TRUE, observations with zero values</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When FALSE non-zero values in the adjmat are set to one.
in infect or suscept are excluded from the graph. This is done explicitly when <code>logscale=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_infectsuscep_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code><a href="graphics.html#topic+filled.contour">filled.contour</a>.</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plotting function was inspired by Aral, S., &amp; Walker, D. (2012).
</p>
<p>By default the function will try to apply a kernel smooth function via
<code>kde2d</code>. If not possible (because not enought data points), then
the user should try changing the parameter <code>h</code> or set it equal to zero.
</p>
<p><code>toa</code> is passed to <code>infection/susceptibility</code>.
</p>


<h3>Value</h3>

<p>A list with three elements:
</p>
<table>
<tr><td><code>infect</code></td>
<td>
<p>A numeric vector of size <code class="reqn">n</code> with infectiousness levels</p>
</td></tr>
<tr><td><code>suscep</code></td>
<td>
<p>A numeric vector of size <code class="reqn">n</code> with susceptibility levels</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>A list containing the class marks and counts used to draw the
plot via <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> (see <code><a href="#topic+grid_distribution">grid_distribution</a></code>)</p>
</td></tr>
<tr><td><code>complete</code></td>
<td>
<p>A logical vector with <code>TRUE</code> when the case was included in
the plot. (this is relevant whenever <code>logscale=TRUE</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Aral, S., &amp; Walker, D. (2012). &quot;Identifying Influential and Susceptible Members
of Social Networks&quot;. Science, 337(6092), 337–341.
<a href="https://doi.org/10.1126/science.1215842">doi:10.1126/science.1215842</a>
</p>


<h3>See Also</h3>

<p>Infectiousness and susceptibility are computed via <code><a href="#topic+infection">infection</a></code> and
<code><a href="#topic+susceptibility">susceptibility</a></code>.
</p>
<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a random graph -------------------------------------------------
set.seed(1234)
n &lt;- 100
nper &lt;- 20
graph &lt;- rgraph_er(n,nper, p=.2, undirected = FALSE)
toa &lt;- sample(1:(1+nper-1), n, TRUE)

# Visualizing distribution of suscep/infect
out &lt;- plot_infectsuscep(graph, toa, K=3, logscale = FALSE)
</code></pre>

<hr>
<h2 id='plot_threshold'>Threshold levels through time</h2><span id='topic+plot_threshold'></span><span id='topic+plot_threshold.diffnet'></span><span id='topic+plot_threshold.array'></span><span id='topic+plot_threshold.default'></span>

<h3>Description</h3>

<p>Draws a graph where the coordinates are given by time of adoption, x-axis,
and threshold level, y-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_threshold(graph, expo, ...)

## S3 method for class 'diffnet'
plot_threshold(graph, expo, ...)

## S3 method for class 'array'
plot_threshold(graph, expo, ...)

## Default S3 method:
plot_threshold(
  graph,
  expo,
  toa,
  include_censored = FALSE,
  t0 = min(toa, na.rm = TRUE),
  attrs = NULL,
  undirected = getOption("diffnet.undirected"),
  no.contemporary = TRUE,
  main = "Time of Adoption by\nNetwork Threshold",
  xlab = "Time",
  ylab = "Threshold",
  vertex.size = "degree",
  vertex.color = NULL,
  vertex.label = "",
  vertex.label.pos = NULL,
  vertex.label.cex = 1,
  vertex.label.adj = c(0.5, 0.5),
  vertex.label.color = NULL,
  vertex.sides = 40L,
  vertex.rot = 0,
  edge.width = 2,
  edge.color = NULL,
  arrow.width = NULL,
  arrow.length = NULL,
  arrow.color = NULL,
  include.grid = FALSE,
  vertex.frame.color = NULL,
  bty = "n",
  jitter.factor = c(1, 1),
  jitter.amount = c(0.25, 0.025),
  xlim = NULL,
  ylim = NULL,
  edge.curved = NULL,
  background = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_threshold_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_expo">expo</code></td>
<td>
<p><code class="reqn">n\times T</code> matrix. Esposure to the innovation obtained from <code><a href="#topic+exposure">exposure</a></code></p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_toa">toa</code></td>
<td>
<p>Integer vector of length <code class="reqn">n</code> with the times of adoption.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_include_censored">include_censored</code></td>
<td>
<p>Logical scalar. Passed to <code><a href="#topic+threshold">threshold</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Passed to <code><a href="#topic+threshold">threshold</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_attrs">attrs</code></td>
<td>
<p>Passed to <code><a href="#topic+exposure">exposure</a></code> (via threshold).</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_no.contemporary">no.contemporary</code></td>
<td>
<p>Logical scalar. When TRUE, edges for vertices with the same
<code>toa</code> won't be plotted.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the plot.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. x-axis label.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_ylab">ylab</code></td>
<td>
<p>Character scalar. y-axis label.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Numeric vector of size <code class="reqn">n</code>. Relative size of the vertices.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Either a vector of size <code class="reqn">n</code> or a scalar indicating colors of the vertices.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.label">vertex.label</code></td>
<td>
<p>Character vector of size <code class="reqn">n</code>. Labels of the vertices.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.label.pos">vertex.label.pos</code></td>
<td>
<p>Integer value to be passed to <code><a href="graphics.html#topic+text">text</a></code> via <code>pos</code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>Either a numeric scalar or vector of size <code class="reqn">n</code>. Passed to <code>text</code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.label.adj">vertex.label.adj</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.sides">vertex.sides</code></td>
<td>
<p>Either a vector of size <code class="reqn">n</code> or a scalar indicating the
number of sides of each vertex (see details).</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.rot">vertex.rot</code></td>
<td>
<p>Either a vector of size <code class="reqn">n</code> or a scalar indicating the
rotation in radians of each vertex (see details).</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_edge.width">edge.width</code></td>
<td>
<p>Numeric. Width of the edges.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_edge.color">edge.color</code></td>
<td>
<p>Character. Color of the edges.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_arrow.width">arrow.width</code></td>
<td>
<p>Numeric value to be passed to <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_arrow.length">arrow.length</code></td>
<td>
<p>Numeric value to be passed to <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_arrow.color">arrow.color</code></td>
<td>
<p>Color.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_include.grid">include.grid</code></td>
<td>
<p>Logical. When TRUE, the grid of the graph is drawn.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>Either a vector of size <code class="reqn">n</code> or a scalar indicating colors of vertices' borders.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_bty">bty</code></td>
<td>
<p>See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_jitter.factor">jitter.factor</code></td>
<td>
<p>Numeric vector of size 2 (for x and y) passed to <code><a href="base.html#topic+jitter">jitter</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_jitter.amount">jitter.amount</code></td>
<td>
<p>Numeric vector of size 2 (for x and y) passed to <code><a href="base.html#topic+jitter">jitter</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_xlim">xlim</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_ylim">ylim</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_edge.curved">edge.curved</code></td>
<td>
<p>Logical scalar. When curved, generates curved edges.</p>
</td></tr>
<tr><td><code id="plot_threshold_+3A_background">background</code></td>
<td>
<p>TBD</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>vertex.label=NULL</code> the function uses vertices ids as labels.
By default <code>vertex.label=""</code> plots no labels.
</p>
<p>Vertices are drawn using an internal function for generating polygons.
Polygons are inscribed in a circle of radius <code>vertex.size</code>, and can be
rotated using <code>vertex.rot</code>. The number of sides of each polygon
is set via <code>vertex.sides</code>.
</p>


<h3>Value</h3>

<p>Invisible. A data frame with the calculated coordinates, including:
'toa', 'threshold', and 'jit' (a jittered version of 'toa').
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+threshold">threshold</a></code> to retrieve the corresponding threshold
obtained returned by <code><a href="#topic+exposure">exposure</a></code>.
</p>
<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating a random graph
set.seed(1234)
n &lt;- 6
nper &lt;- 5
graph &lt;- rgraph_er(n,nper, p=.3, undirected = FALSE)
toa &lt;- sample(2000:(2000+nper-1), n, TRUE)
adopt &lt;- toa_mat(toa)

# Computing exposure
expos &lt;- exposure(graph, adopt$cumadopt)

plot_threshold(graph, expos, toa)

# Calculating degree (for sizing the vertices)
plot_threshold(graph, expos, toa, vertex.size = "indegree")

</code></pre>

<hr>
<h2 id='plot.diffnet'>S3 plotting method for diffnet objects.</h2><span id='topic+plot.diffnet'></span>

<h3>Description</h3>

<p>S3 plotting method for diffnet objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
plot(
  x,
  y = NULL,
  t = 1,
  vertex.color = c(adopt = "steelblue", noadopt = "white"),
  vertex.size = "degree",
  main = "Diffusion network in time %d",
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.diffnet_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+diffnet-class">diffnet</a></code></p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_t">t</code></td>
<td>
<p>Integer scalar indicating the time slice to plot.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Character scalar/vector. Color of the vertices.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Either a numeric scalar or vector of size <code class="reqn">n</code>, or any
of the following values: &quot;indegree&quot;, &quot;degree&quot;, or &quot;outdegree&quot; (see details).</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_main">main</code></td>
<td>
<p>Character. A title template to be passed to sprintf.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_minmax.relative.size">minmax.relative.size</code></td>
<td>
<p>Passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting is done via the function <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>When <code>vertex.size</code> is either of <code>"degree"</code>, <code>"indegree"</code>, or
<code>"outdegree"</code>, <code>vertex.size</code> will be replace with <code>dgr(.,cmode = )</code>
so that the vertex size reflects the desired degree.
</p>
<p>The argument <code>minmax.relative.size</code> is passed to <code><a href="#topic+rescale_vertex_igraph">rescale_vertex_igraph</a></code>
which adjusts <code>vertex.size</code> so that the largest and smallest vertices
have a relative size of <code>minmax.relative.size[2]</code> and
<code>minmax.relative.size[1]</code> respectively with respect to the x-axis.
</p>


<h3>Value</h3>

<p>A matrix with the coordinates of the vertices.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+summary.diffnet">summary.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(medInnovationsDiffNet)
plot(medInnovationsDiffNet)


</code></pre>

<hr>
<h2 id='pretty_within'>Pretty numbers within a range.</h2><span id='topic+pretty_within'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="base.html#topic+pretty">pretty</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pretty_within(x, min.n = 5, xrange = range(x, na.rm = TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pretty_within_+3A_x">x</code></td>
<td>
<p>Numeric vector passed to <code><a href="base.html#topic+pretty">pretty</a></code>.</p>
</td></tr>
<tr><td><code id="pretty_within_+3A_min.n">min.n</code></td>
<td>
<p>Integer scalar passed to <code><a href="base.html#topic+pretty">pretty</a></code>.</p>
</td></tr>
<tr><td><code id="pretty_within_+3A_xrange">xrange</code></td>
<td>
<p>Numeric vector of length 2. Indicates the range in which the
output vector should lie on.</p>
</td></tr>
<tr><td><code id="pretty_within_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.
</p>
<p>The only difference with <code>pretty</code> is that this function subsets the
resulting vector as
</p>
<p><code>tick[(tick &gt;= xrange[1]) &amp; (tick &lt;= xrange[2])]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector sequence of 'n + 1' round values in the specified range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example ------------------------------------------------------------
set.seed(3331)
x &lt;- runif(10)
pretty(x)
pretty_within(x)
range(x)
</code></pre>

<hr>
<h2 id='rdiffnet'>Random diffnet network</h2><span id='topic+rdiffnet'></span><span id='topic+rdiffnet_multiple'></span>

<h3>Description</h3>

<p>Simulates a diffusion network by creating a random dynamic network and
adoption threshold levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdiffnet_multiple(R, statistic, ..., ncpus = 1L, cl = NULL)

rdiffnet(
  n,
  t,
  seed.nodes = "random",
  seed.p.adopt = 0.05,
  seed.graph = "scale-free",
  rgraph.args = list(),
  rewire = TRUE,
  rewire.args = list(),
  threshold.dist = runif(n),
  exposure.args = list(),
  name = "A diffusion network",
  behavior = "Random contagion",
  stop.no.diff = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdiffnet_+3A_r">R</code></td>
<td>
<p>Integer scalar. Number of simulations to be done.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_statistic">statistic</code></td>
<td>
<p>A Function to be applied to each simulated diffusion network.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>rdiffnet</code>.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_ncpus">ncpus</code></td>
<td>
<p>Integer scalar. Number of processors to be used (see details).</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_cl">cl</code></td>
<td>
<p>An object of class <code><a href="parallel.html#topic+makeCluster">c(&quot;SOCKcluster&quot;, &quot;cluster&quot;)</a></code>
(see details).</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_n">n</code></td>
<td>
<p>Integer scalar. Number of vertices.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_t">t</code></td>
<td>
<p>Integer scalar. Time length.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_seed.nodes">seed.nodes</code></td>
<td>
<p>Either a character scalar or a vector. Type of seed nodes (see details).</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_seed.p.adopt">seed.p.adopt</code></td>
<td>
<p>Numeric scalar. Proportion of early adopters.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_seed.graph">seed.graph</code></td>
<td>
<p>Baseline graph used for the simulation (see details).</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_rgraph.args">rgraph.args</code></td>
<td>
<p>List. Arguments to be passed to rgraph.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_rewire">rewire</code></td>
<td>
<p>Logical scalar. When TRUE, network slices are generated by rewiring
(see <code><a href="#topic+rewire_graph">rewire_graph</a></code>).</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_rewire.args">rewire.args</code></td>
<td>
<p>List. Arguments to be passed to <code><a href="#topic+rewire_graph">rewire_graph</a></code>.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_threshold.dist">threshold.dist</code></td>
<td>
<p>Either a function to be applied via <code><a href="base.html#topic+sapply">sapply</a></code>,
a numeric scalar, or a vector/matrix with <code class="reqn">n</code> elements. Sets the adoption
threshold for each node.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_exposure.args">exposure.args</code></td>
<td>
<p>List. Arguments to be passed to <code><a href="#topic+exposure">exposure</a></code>.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_name">name</code></td>
<td>
<p>Character scalar. Passed to <code><a href="#topic+as_diffnet">as_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_behavior">behavior</code></td>
<td>
<p>Character scalar. Passed to <code><a href="#topic+as_diffnet">as_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="rdiffnet_+3A_stop.no.diff">stop.no.diff</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, the function will return
with error if there was no diffusion. Otherwise it throws a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of randomizing whether an individual adopts the innovation or not, this
toy model randomizes threshold levels, seed adopters and network structure, so
an individual adopts the innovation in time <code class="reqn">T</code> iff his exposure is above or
equal to his threshold. The simulation is done in the following steps:
</p>

<ol>
<li><p> Using <code>seed.graph</code>, a baseline graph is created.
</p>
</li>
<li><p> Given the baseline graph, the set of initial adopters is defined
using <code>seed.nodes</code>.
</p>
</li>
<li><p> Afterwards, if <code>rewire=TRUE</code> <code class="reqn">t-1</code> slices of the network are created
by iteratively rewiring the baseline graph.
</p>
</li>
<li><p> The <code>threshold.dist</code> function is applied to each node in the graph.
</p>
</li>
<li><p> Simulation starts at <code class="reqn">t=2</code> assigning adopters in each time period
accordingly to each vertex's threshold and exposure.
</p>
</li></ol>

<p>When <code>seed.nodes</code> is a character scalar it can be <code>"marginal"</code>, <code>"central"</code> or <code>"random"</code>,
So each of these values sets the initial adopters using the vertices with lowest
degree, with highest degree or completely randomly. The number of early adoptes
is set as <code>seed.p.adopt * n</code>. Please note that when marginal nodes are
set as seed it may be the case that no diffusion process is attained as the
chosen set of first adopters can be isolated. Any other case will be considered
as an index (via <code><a href="base.html#topic++5B+3C-">[&lt;-</a></code> methods), hence the user can manually set the set of initial adopters, for example
if the user sets <code>seed.nodes=c(1, 4, 7)</code> then nodes 1, 4 and 7 will be
selected as initial adopters.
</p>
<p>The argument <code>seed.graph</code> can be either a function that generates a graph
(Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>)), a
graph itself or a character scalar in which the user sets the algorithm used to
generate the first network (network in t=1), this can be either &quot;scale-free&quot;
(Barabasi-Albert model using the <code><a href="#topic+rgraph_ba">rgraph_ba</a></code> function, the default),
<code>"bernoulli"</code> (Erdos-Renyi model using the <code><a href="#topic+rgraph_er">rgraph_er</a></code> function),
or <code>"small-world"</code> (Watts-Strogatz model using the <code><a href="#topic+rgraph_ws">rgraph_ws</a></code>
function). The list <code>rgraph.args</code> passes arguments to the chosen algorithm.
</p>
<p>When <code>rewire=TRUE</code>, the networks that follow t=1 will be generated using the
<code><a href="#topic+rewire_graph">rewire_graph</a></code> function as <code class="reqn">G(t) = R(G(t-1))</code>, where <code class="reqn">R</code>
is the rewiring algorithm.
</p>
<p>If a function, the argument <code>threshold.dist</code> sets the threshold for each vertex in the graph.
It is applied using <code>sapply</code> as follows
</p>
<pre>
sapply(1:n, threshold.dist)
</pre>
<p>By default sets the threshold to be random for each node in the graph.
</p>
<p>If <code>seed.graph</code> is provided, no random graph is generated and the simulation
is applied using that graph instead.
</p>
<p><code>rewire.args</code> has the following default options:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>p</code>          </td><td style="text-align: left;"> <code>.1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>undirected</code> </td><td style="text-align: left;"> <code>getOption("diffnet.undirected", FALSE)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>self</code>       </td><td style="text-align: left;"> <code>getOption("diffnet.self", FALSE)</code>
</td>
</tr>

</table>

<p><code>exposure.args</code> has the following default options:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>outgoing</code> </td><td style="text-align: left;"> <code>TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>valued</code> </td><td style="text-align: left;"> <code>getOption("diffnet.valued", FALSE)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>normalized</code> </td><td style="text-align: left;"> <code>TRUE</code>
</td>
</tr>

</table>

<p>The function <code>rdiffnet_multiple</code> is a wrapper of <code>rdiffnet</code> wich allows
simulating multiple diffusion networks with the same parameters and apply
the same function to all of them. This function is designed to allow the user
to perform larger simulation studies in which the distribution of a particular
statistic is observed.
</p>
<p>When <code>cl</code> is provided, then simulations are done via
<code><a href="parallel.html#topic+parSapply">parSapply</a></code>. If <code>ncpus</code> is greater than
1, then the function creates a cluster via <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
which is stopped (removed) once the process is complete.
</p>


<h3>Value</h3>

<p>A random <code><a href="#topic+diffnet">diffnet</a></code> class object.
</p>
<p><code>rdiffnet_multiple</code> returns either a vector or an array depending
on what <code>statistic</code> is (see <code><a href="base.html#topic+sapply">sapply</a></code> and
<code><a href="parallel.html#topic+parSapply">parSapply</a></code>).
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Asimple example -----------------------------------------------------------
set.seed(123)
z &lt;- rdiffnet(100,10)
z
summary(z)

# A more complex example: Adopt if at least one neighbor has adopted --------
y &lt;- rdiffnet(100, 10, threshold.dist=function(x) 1,
    exposure.args=list(valued=FALSE, normalized=FALSE))

# Re thinking the Adoption of Tetracycline ----------------------------------
newMI &lt;- rdiffnet(seed.graph = medInnovationsDiffNet$graph,
 threshold.dist = threshold(medInnovationsDiffNet), rewire=FALSE)


# Simulation study comparing the diffusion with diff sets of seed nodes -----

# Random seed nodes
set.seed(1)
ans0 &lt;- rdiffnet_multiple(R=50, statistic=function(x) sum(!is.na(x$toa)),
    n = 100, t = 4, seed.nodes = "random", stop.no.diff=FALSE)

# Central seed nodes
set.seed(1)
ans1 &lt;- rdiffnet_multiple(R=50, statistic=function(x) sum(!is.na(x$toa)),
    n = 100, t = 4, seed.nodes = "central", stop.no.diff=FALSE)

boxplot(cbind(Random = ans0, Central = ans1), main="Number of adopters")
</code></pre>

<hr>
<h2 id='read_pajek'>Read foreign graph formats</h2><span id='topic+read_pajek'></span><span id='topic+read_net'></span><span id='topic+read_dl'></span><span id='topic+read_ml'></span>

<h3>Description</h3>

<p>Reading pajek and Ucinet files, this function returns weighted edgelists in the form of
data frames including a data frame of the vertices. (function on development)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pajek(x)

read_ml(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pajek_+3A_x">x</code></td>
<td>
<p>Character scalar. Path to the file to be imported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since .net files allow working with multi-relational networks (more than one
class of edge), the function returns lists of edges and edgeslist with the corresponding
tag on the .net file. For example, if the .net file contains
</p>
<pre>
 *Arcslist :9 "SAMPPR"
 ...
 *Arcslist :10 "SAMNPR"
</pre>
<p>The output will include data frames of edgelists with those tags.
</p>


<h3>Value</h3>

<p>In the case of <code>read_pajek</code>, a list with three elements
</p>
<table>
<tr><td><code>vertices</code></td>
<td>
<p>A data frame with <code class="reqn">n</code> rows and two columns: id and label</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>If not null, a list of data frames with three columns: ego, alter, w (weight)</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>If not null, a list of data frame with three columns: ego, alter, w (weight)</p>
</td></tr>
</table>
<p>For <code>read_ml</code>, a list with two elements:
</p>
<table>
<tr><td><code>adjmat</code></td>
<td>
<p>An array with the graph</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>A list with metadata</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>Source</h3>

<p>From the pajek manual <a href="http://mrvar.fdv.uni-lj.si/pajek/pajekman.pdf">http://mrvar.fdv.uni-lj.si/pajek/pajekman.pdf</a>
</p>


<h3>See Also</h3>

<p>Other Foreign: 
<code><a href="#topic+igraph">igraph</a></code>,
<code><a href="#topic+network">network</a></code>,
<code><a href="#topic+read_ucinet_head">read_ucinet_head</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From .net: Sampson monastery data from UCINET dataset ---------------------

# Reading the arcs/edges format
path &lt;- system.file("extdata", "SAMPSON.NET", package = "netdiffuseR")
SAMPSON &lt;- read_pajek(path)

# Reading the arcslist/edgelist format
path &lt;- system.file("extdata", "SAMPSONL.NET", package = "netdiffuseR")
SAMPSONL &lt;- read_pajek(path)

# From DL (UCINET): Sampson monastery data (again) --------------------------
path &lt;- system.file("extdata", "SAMPSON.DAT", package = "netdiffuseR")
SAMPSONL &lt;- read_ml(path)

</code></pre>

<hr>
<h2 id='read_ucinet_head'>Reads UCINET files</h2><span id='topic+read_ucinet_head'></span><span id='topic+ucinet'></span><span id='topic+UCINET'></span><span id='topic+read_ucinet'></span>

<h3>Description</h3>

<p>Reads UCINET files
</p>
<p>Read UCINET files (binary)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ucinet_head(f)

read_ucinet(f, echo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ucinet_head_+3A_f">f</code></td>
<td>
<p>Character scalar. Name of the header file. e.g. <code>mydata.##h</code>.</p>
</td></tr>
<tr><td><code id="read_ucinet_head_+3A_echo">echo</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> shows a message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array including dimnames (if there are) and the following attributes:
</p>
<table>
<tr><td><code>headerversion</code></td>
<td>
<p>Character scalar</p>
</td></tr>
<tr><td><code>year</code></td>
<td>
<p>Integer. Year the file was created</p>
</td></tr>
<tr><td><code>month</code></td>
<td>
<p>Integer. Month of the year the file was created.</p>
</td></tr>
<tr><td><code>day</code></td>
<td>
<p>Integer. Day of the month the file was created.</p>
</td></tr>
<tr><td><code>dow</code></td>
<td>
<p>Integer. Day of the week the file was created.</p>
</td></tr>
<tr><td><code>labtype</code></td>
<td>
</td></tr>
<tr><td><code>infile.dt</code></td>
<td>
<p>Character scalar. Type of data of the array.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Integer vector. Dimensions of the array.</p>
</td></tr>
<tr><td><code>tit</code></td>
<td>
<p>Character scalar. Title of the file.</p>
</td></tr>
<tr><td><code>haslab</code></td>
<td>
<p>Logical vector. Whether  each dim has a label.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Foreign: 
<code><a href="#topic+igraph">igraph</a></code>,
<code><a href="#topic+network">network</a></code>,
<code><a href="#topic+read_pajek">read_pajek</a>()</code>
</p>

<hr>
<h2 id='recode'>Recodes an edgelist such that ids go from 1 to n</h2><span id='topic+recode'></span><span id='topic+recode.data.frame'></span><span id='topic+recode.matrix'></span>

<h3>Description</h3>

<p>Recodes an edgelist such that ids go from 1 to n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(data, ...)

## S3 method for class 'data.frame'
recode(data, ...)

## S3 method for class 'matrix'
recode(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_data">data</code></td>
<td>
<p>Edgelist as either a matrix or dataframe with ego and alter</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>Further arguments for the method (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Required for using most of the package's functions, as ids are used
as a reference for accessing elements in adjacency matrices.
</p>


<h3>Value</h3>

<p>A recoded edgelist as a two-column matrix/data.frame depending
on the class of <code>data</code>. The output includes an attribute called &quot;recode&quot;
which contains a two column data.frame providing a mapping between the
previous code and the new code (see the examples)
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example ------------------------------------------------------------
edgelist &lt;- cbind(c(1,1,3,6),c(4,3,200,1))
edgelist
recoded_edgelist &lt;- recode(edgelist)
recoded_edgelist

# Retrieving the "recode" attribute
attr(recoded_edgelist, "recode")
</code></pre>

<hr>
<h2 id='rescale_vertex_igraph'>Rescale vertex size to be used in <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code>.</h2><span id='topic+rescale_vertex_igraph'></span><span id='topic+igraph_vertex_rescale'></span><span id='topic+vertex_rescale_igraph'></span>

<h3>Description</h3>

<p>This function rescales a vertex size before passing it to
<code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> so that the resulting vertices
have the desired size relative to the x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_vertex_igraph(
  vertex.size,
  par.usr = par("usr"),
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  adjust = 200
)

igraph_vertex_rescale(
  vertex.size,
  par.usr = par("usr"),
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  adjust = 200
)

vertex_rescale_igraph(
  vertex.size,
  par.usr = par("usr"),
  minmax.relative.size = getOption("diffnet.minmax.relative.size", c(0.01, 0.04)),
  adjust = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_vertex_igraph_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Numeric vector of unscaled vertices' sizes. This is unit-free.</p>
</td></tr>
<tr><td><code id="rescale_vertex_igraph_+3A_par.usr">par.usr</code></td>
<td>
<p>Integer vector of length 4 with the coordinates of plotting region.
by default uses <code>par("usr")</code>.</p>
</td></tr>
<tr><td><code id="rescale_vertex_igraph_+3A_minmax.relative.size">minmax.relative.size</code></td>
<td>
<p>A numeric vector of length 2. Represents the
desired min and max vertex sizes relative to the x-axis in terms of percentage
(see details).</p>
</td></tr>
<tr><td><code id="rescale_vertex_igraph_+3A_adjust">adjust</code></td>
<td>
<p>Numeric scalar. Adjustment made to the resulting adjusted size
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>minmax.relative.size</code> limits the minimum and maximum size that a vertex
can take in the plot relative to the x-axis scale. The values for the x-axis
scale are by default retrieved by accessing to <code>par("usr")</code>. By default
the vertex are rescaled to be at least 1% of the size of the plotting region
and no more than 5% of the plotting region, <code>minmax.relative.size=c(.01, .05)</code>.
</p>
<p>The default value for <code>adjust</code> is taken from <code><a href="igraph.html#topic+igraph">igraph</a></code>
version 1.0.1. In particular, the function <code>igraph:::.igraph.shape.circle.plot</code>,
in which before passing the <code>vertex.size</code> to the function
<code><a href="graphics.html#topic+symbols">symbols</a></code>, the vertex size is reduced by 200.
</p>
<p>The rescaling is as follows:
</p>
<p style="text-align: center;"><code class="reqn">%
 v' = \frac{v - \underbar v}{\bar v - \underbar v}\times (\bar s - \underbar s) + \underbar s
</code>
</p>

<p>Where <code class="reqn">v</code> is the vertex size, <code class="reqn">\bar v</code> and <code class="reqn">\underbar v</code> are
the max and min values of <code class="reqn">v</code> respectively, and <code class="reqn">\bar s</code> and
<code class="reqn">\underbar s</code> are the max and min size that vertices take in terms
of <code>minmax.relative.size</code> and <code>par.usr</code>. The adjusted value <code class="reqn">v'</code>
is then multiplied by <code>adjust</code>.
</p>
<p><code>igraph_vertex_rescale</code> and <code>vertex_rescale_igraph</code> are aliases.
</p>


<h3>Value</h3>

<p>An integer vector of the same length as <code>vertex.size</code> with
rescaled values.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other visualizations: 
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+diffusionMap">diffusionMap</a>()</code>,
<code><a href="#topic+drawColorKey">drawColorKey</a>()</code>,
<code><a href="#topic+grid_distribution">grid_distribution</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+plot_adopters">plot_adopters</a>()</code>,
<code><a href="#topic+plot_diffnet2">plot_diffnet2</a>()</code>,
<code><a href="#topic+plot_diffnet">plot_diffnet</a>()</code>,
<code><a href="#topic+plot_infectsuscep">plot_infectsuscep</a>()</code>,
<code><a href="#topic+plot_threshold">plot_threshold</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)

# Random graph and coordinates
set.seed(2134)
g &lt;- barabasi.game(10)
coords &lt;- layout_nicely(g)

# Random size and figures
size &lt;- runif(10)
size &lt;- cbind(size, size)
shap &lt;- sample(c("circle", "square"),10,TRUE)

# Plotting
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mai=rep(.5,4))
for (i in seq(1, 1000, length.out = 4)) {
  # New plot-window
  plot.new()
  plot.window(xlim=range(coords[,1]*i), ylim=range(coords[,2]*i))

  # plotting graph
  plot(g, layout=coords*i, add=TRUE, rescale=FALSE,
       vertex.shape = shap,
       vertex.size  = rescale_vertex_igraph(size) # HERE WE RESCALE!
  )

  # Adding some axis
  axis(1, lwd=0, lwd.ticks = 1)
  axis(2, lwd=0, lwd.ticks = 1)
  box()
}

par(oldpar)

</code></pre>

<hr>
<h2 id='rewire_graph'>Graph rewiring algorithms</h2><span id='topic+rewire_graph'></span>

<h3>Description</h3>

<p>Changes the structure of a graph by altering ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewire_graph(
  graph,
  p,
  algorithm = "endpoints",
  both.ends = FALSE,
  self = FALSE,
  multiple = FALSE,
  undirected = getOption("diffnet.undirected"),
  pr.change = ifelse(self, 0.5, 1),
  copy.first = TRUE,
  althexagons = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewire_graph_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_p">p</code></td>
<td>
<p>Either a [0,1] vector with rewiring probabilities (<code>algorithm="endpoints"</code>),
or an integer vector with number of iterations (<code>algorithm="swap"</code>).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_algorithm">algorithm</code></td>
<td>
<p>Character scalar. Either <code>"swap"</code>, <code>"endpoints"</code>, or <code>"qap"</code>
(see <code><a href="#topic+rewire_qap">rewire_qap</a></code>).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_both.ends">both.ends</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> rewires both ends.</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, allows loops (self edges).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_pr.change">pr.change</code></td>
<td>
<p>Numeric scalar. Probability ([0,1]) of doing a rewire (see details).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_copy.first">copy.first</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> and <code>graph</code> is dynamic uses
the first slice as a baseline for the rest of slices (see details).</p>
</td></tr>
<tr><td><code id="rewire_graph_+3A_althexagons">althexagons</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> uses the compact alternating
hexagons algorithm (currently ignored [on development]).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm <code>"qap"</code> is described in <code><a href="#topic+rewire_qap">rewire_qap</a></code>, and only
uses <code>graph</code> from the arguments (since it is simply relabelling the graph).
</p>
<p>In the case of &quot;swap&quot; and &quot;endpoints&quot;, both algorithms are implemented
sequentially, this is, edge-wise checking self edges and multiple edges over
the changing graph; in other words, at step
<code class="reqn">m</code> (in which either a new endpoint or edge is chosen, depending on the algorithm),
the algorithms verify whether the proposed change creates either multiple edges
or self edges using the resulting graph at step <code class="reqn">m-1</code>.
</p>
<p>The main difference between the two algorithms is that the <code>"swap"</code> algorithm
preserves the degree sequence of the graph and <code>"endpoints"</code> does not.
The <code>"swap"</code> algorithm is specially useful to asses the non-randomness of
a graph's structural properties, furthermore it is this algorithm the one used
in the <code><a href="#topic+struct_test">struct_test</a></code> routine implemented in <span class="pkg">netdiffuseR</span>.
</p>
<p>Rewiring assumes a weighted network, hence <code class="reqn">G(i,j) = k = G(i',j')</code>,
where <code class="reqn">i',j'</code> are the new end points of the edge and <code class="reqn">k</code> may not be equal
to one.
</p>
<p>In the case of dynamic graphs, when <code>copy.first=TRUE</code>, after rewiring the
first slice&ndash;<code class="reqn">t=1</code>&ndash;the rest of slices are generated by rewiring the rewired
version of the first slice. Formally:
</p>
<p style="text-align: center;"><code class="reqn">%
G(t)' = \left\{\begin{array}{ll}
R(G(t)) &amp; \mbox{if }t=1 \\
R(G(1)') &amp; \mbox{otherwise}
\end{array}
\right.
</code>
</p>

<p>Where <code class="reqn">G(t)</code> is the t-th slice, <code class="reqn">G(t)'</code> is the t-th rewired slice, and
<code class="reqn">R</code> is the rewiring function. Otherwise, <code>copy.first=FALSE</code> (default),
The rewiring function is simply <code class="reqn">G(t)' = R(G(t))</code>.
</p>
<p>The following sections describe the way both algorithms were implemented.
</p>


<h3>Value</h3>

<p>A rewired version of the graph.
</p>


<h3><em>Swap</em> algorithm</h3>

<p>The <code>"swap"</code> algorithm chooses randomly two edges <code class="reqn">(a,b)</code> and
<code class="reqn">(c,d)</code> and swaps the 'right' endpoint of boths such that we get
<code class="reqn">(a,d)</code> and <code class="reqn">(c,b)</code> (considering self and multiple edges).
</p>
<p>Following Milo et al. (2004) testing procedure, the algorithm shows to be
well behaved in terms of been unbiased, so after each iteration each possible
structure of the graph has the same probability of been generated. The algorithm
has been implemented as follows:
</p>
<p>Let <code class="reqn">E</code> be the set of edges of the graph <code class="reqn">G</code>. For <code class="reqn">i=1</code> to <code class="reqn">p</code>, do:
</p>

<ol>
<li><p> With probability <code>1-pr.change</code> got to the last step.
</p>
</li>
<li><p> Choose <code class="reqn">e0=(a, b)</code> from <code class="reqn">E</code>. If <code>!self &amp; a == b</code> then go to the last step.
</p>
</li>
<li><p> Choose <code class="reqn">e1=(c, d)</code> from <code class="reqn">E</code>. If <code>!self &amp; c == d </code> then go to the last step.
</p>
</li>
<li><p> Define <code class="reqn">e0'=(a, d)</code> and <code class="reqn">e1' = (c, b)</code>. If <code>!multiple &amp; [G[e0']!= 0 | G[e1'] != 0]</code> then go to the last step.(*)
</p>
</li>
<li><p> Define <code class="reqn">v0 = G[e0]</code> and <code class="reqn">v1 = G[e1]</code>, set <code class="reqn">G[e0]=0</code> and <code class="reqn">G[e1]=0</code>
(and the same to the diagonally opposed coordinates in the case of undirected graphs)
</p>
</li>
<li><p> Set <code class="reqn">G[e0'] = v0</code> and <code class="reqn">G[e1'] = v1</code> (and so with the diagonally opposed coordinates
in the case of undirected graphs).
</p>
</li>
<li><p> Next i.
</p>
</li></ol>

<p>(*) When <code>althexagons=TRUE</code>, the algorithm changes and applies what Rao et al.
(1996) describe as Compact Alternating Hexagons. This modification assures the
algorithm to be able to achieve any structure. The algorithm consists on doing
the following swapping: <code class="reqn">(i1i2,i1i3,i2i3,i2i1,i3i1,i3i2)</code> with values
<code class="reqn">(1,0,1,0,1,0)</code> respectively with <code class="reqn">i1!=i2!=i3</code>. See the examples and
references.
</p>
<p>In Milo et al. (2004) is suggested that in order for the rewired graph to be independent
from the original one researchers usually iterate around <code>nlinks(graph)*100</code>
times, so <code>p=nlinks(graph)*100</code>. On the other hand in Ray et al (2012)
it is shown that in order to achive such it is needed to perform
<code>nlinks(graph)*log(1/eps)</code>, where <code>eps</code><code class="reqn">\sim</code>1e-7, in other words,
around <code>nlinks(graph)*16</code>. We set the default to be 20.
</p>
<p>In the case of Markov chains, the variable <code>pr.change</code> allows making the
algorithm aperiodic. This is relevant only if the
probability self-loop to a particular state is null, for example, if
we set <code>self=TRUE</code> and <code>muliple=TRUE</code>, then in every step the
algorithm will be able to change the state. For more details see
Stanton and Pinar (2012) [p. 3.5:9].
</p>


<h3><em>Endpoints</em> algorithm</h3>

<p>This reconnect either one or both of the endpoints of the edge randomly. As a big
difference with the swap algorithm is that this does not preserves the degree
sequence of the graph (at most the outgoing degree sequence). The algorithm is
implemented as follows:
</p>
<p>Let <code class="reqn">G</code> be the baseline graph and <code class="reqn">G'</code> be a copy of it. Then, For <code class="reqn">l=1</code> to <code class="reqn">|E|</code> do:
</p>

<ol>
<li><p> Pick the <code class="reqn">l</code>-th edge from <code class="reqn">E</code>, define it as <code class="reqn">e = (i,j)</code>.
</p>
</li>
<li><p> Draw <code class="reqn">r</code> from <code class="reqn">U(0,1)</code>, if <code class="reqn">r &gt; p</code> go to the last step.
</p>
</li>
<li><p> If <code>!undirected &amp; i &lt; j</code> go to the last step.
</p>
</li>
<li><p> Randomly select a vertex <code class="reqn">j'</code> (and <code class="reqn">i'</code> if <code>both_ends==TRUE</code>).
And define <code class="reqn">e'=(i, j')</code> (or <code class="reqn">e'=(i', j')</code> if <code>both_ends==TRUE</code>).
</p>
</li>
<li><p> If <code>!self &amp;</code> <code>i==j</code>' (or if <code>both_ends==TRUE &amp; i'==j'</code>) go to the last step.
</p>
</li>
<li><p> If <code>!multiple &amp; G'[e']!= 0</code> then go to the last step.
</p>
</li>
<li><p> Define <code class="reqn">v = G[e]</code>, set <code class="reqn">G'[e] = 0</code> and <code class="reqn">G'[e'] = v</code> (and the
same to the diagonally opposed coordinates in the case of undirected graphs).
</p>
</li>
<li><p> Next <code class="reqn">l</code>.
</p>
</li></ol>

<p>The endpoints algorithm is used by default in <code><a href="#topic+rdiffnet">rdiffnet</a></code> and used
to be the default in <code><a href="#topic+struct_test">struct_test</a></code> (now <code>swap</code> is the default).
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collectivedynamics of &quot;small-world&quot; networks.
Nature, 393(6684), 440–442. <a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>
<p>Milo, R., Kashtan, N., Itzkovitz, S., Newman, M. E. J., &amp; Alon, U.
(2004). On the uniform generation of random graphs with prescribed degree sequences.
Arxiv Preprint condmat0312028, cond-mat/0, 1–4. Retrieved from
<a href="https://arxiv.org/abs/cond-mat/0312028">https://arxiv.org/abs/cond-mat/0312028</a>
</p>
<p>Ray, J., Pinar, A., and Seshadhri, C. (2012).
Are we there yet? When to stop a Markov chain while generating random graphs.
pages 1–21.
</p>
<p>Ray, J., Pinar, A., &amp; Seshadhri, C. (2012). Are We There Yet? When to Stop a
Markov Chain while Generating Random Graphs. In A. Bonato &amp; J. Janssen (Eds.),
Algorithms and Models for the Web Graph (Vol. 7323, pp. 153–164).
Berlin, Heidelberg: Springer Berlin Heidelberg.
<a href="https://doi.org/10.1007/978-3-642-30541-2">doi:10.1007/978-3-642-30541-2</a>
</p>
<p>A . Ramachandra Rao, R. J. and S. B. (1996). A Markov Chain Monte Carlo Method
for Generating Random ( 0 , 1 ) -Matrices with Given Marginals. The Indian
Journal of Statistics, 58, 225–242.
</p>
<p>Stanton, I., &amp; Pinar, A. (2012). Constructing and sampling graphs with a
prescribed joint degree distribution. Journal of Experimental Algorithmics,
17(1), 3.1. <a href="https://doi.org/10.1145/2133803.2330086">doi:10.1145/2133803.2330086</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Checking the consistency of the "swap" ------------------------------------

# A graph with known structure (see Milo 2004)
n &lt;- 5
x &lt;- matrix(0, ncol=n, nrow=n)
x &lt;- as(x, "dgCMatrix")
x[1,c(-1,-n)] &lt;- 1
x[c(-1,-n),n] &lt;- 1

x

# Simulations (increase the number for more precision)
set.seed(8612)
nsim &lt;- 1e4
w &lt;- sapply(seq_len(nsim), function(y) {
 # Creating the new graph
 g &lt;- rewire_graph(x,p=nlinks(x)*100, algorithm = "swap")

 # Categorizing (tag of the generated structure)
 paste0(as.vector(g), collapse="")
})

# Counting
coded &lt;- as.integer(as.factor(w))

plot(table(coded)/nsim*100, type="p", ylab="Frequency %", xlab="Class of graph", pch=3,
 main="Distribution of classes generated by rewiring")

# Marking the original structure
baseline &lt;- paste0(as.vector(x), collapse="")
points(x=7,y=table(as.factor(w))[baseline]/nsim*100, pch=3, col="red")

</code></pre>

<hr>
<h2 id='rgraph_ba'>Scale-free and Homophilic Random Networks</h2><span id='topic+rgraph_ba'></span><span id='topic+scale-free'></span>

<h3>Description</h3>

<p>Generates a scale-free random graph based on Bollabas et al. (2001), also know as
<em>Linearized Chord Diagram</em> (LCD) which has nice mathematical propoerties.
And also scale-free homophilic networks when an vertex attribute <code>eta</code> is
passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgraph_ba(m0 = 1L, m = 1L, t = 10L, graph = NULL, self = TRUE, eta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgraph_ba_+3A_m0">m0</code></td>
<td>
<p>Integer scalar. Number of initial vertices in the graph.</p>
</td></tr>
<tr><td><code id="rgraph_ba_+3A_m">m</code></td>
<td>
<p>Integer scalar. Number of new edges per vertex added.</p>
</td></tr>
<tr><td><code id="rgraph_ba_+3A_t">t</code></td>
<td>
<p>Integer scalar. Number of time periods (steps).</p>
</td></tr>
<tr><td><code id="rgraph_ba_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="rgraph_ba_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="rgraph_ba_+3A_eta">eta</code></td>
<td>
<p>Numeric vector of length <code>t+m0</code>. When specified, it generates
a scale-free homophilic network (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Ballobás et al. (2001) creates a directed random graph of size
<code>t + m0</code>. A big difference with B-A model
is that this allows for loops (self/auto edges) and further multiple links,
nevertheless, as <code class="reqn">t</code> increases, the number of such cases reduces.
</p>
<p>By default, the degree of the first <code>m0</code> vertices is set to be 2 (loops).
When <code>m&gt;1</code>, as described in the paper, each new link from the new vertex
is added one at a time
&ldquo;counting &lsquo;outward half&rsquo; of the edge being added as already contributing to the degrees&rdquo;.
</p>
<p>When <code>self=FALSE</code>, the generated graph is created without autolinks. This
means that at the beginning, if the number of links equals zero, all vertices
have the same probability of receiving a new link.
</p>
<p>When <code>eta</code> is passed, it implements the model specified in De Almeida et al.
(2013), a scale-free homophilic network. To do so <code>eta</code> is rescaled to
be between 0 and 1 and the probability that the node <code class="reqn">i</code> links to node <code class="reqn">j</code>
is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
\frac{(1-A_{ij})k_j}{\sum_j (1-A_{ij})k_j}
</code>
</p>

<p>Where <code class="reqn">A_{ij} = |\eta_i - \eta_j|</code> and
<code class="reqn">k_j</code> is the degree of the <code class="reqn">j</code>-th vertex.
</p>


<h3>Value</h3>

<p>If <code>graph</code> is not provided, a static graph, otherwise an expanded
graph (<code>t</code> aditional vertices) of the same class as <code>graph</code>.
</p>
<p>The resulting graph will have <code>graph$meta$undirected = FALSE</code> if it is of
class <code>diffnet</code> and <code>attr(graph, "undirected")=FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Bollobás, B´., Riordan, O., Spencer, J., &amp; Tusnády, G. (2001). The degree
sequence of a scale-free random graph process. Random Structures &amp; Algorithms,
18(3), 279–290. <a href="https://doi.org/10.1002/rsa.1009">doi:10.1002/rsa.1009</a>
</p>
<p>Albert-László Barabási, &amp; Albert, R. (1999). Emergence of Scaling in Random
Networks. Science, 286(5439), 509–512. <a href="https://doi.org/10.1126/science.286.5439.509">doi:10.1126/science.286.5439.509</a>
</p>
<p>Albert-László Barabási. (2016). Network Science: (1st ed.). Cambridge University Press.
Retrieved from <a href="https://barabasi.com/book/network-science">https://barabasi.com/book/network-science</a>
</p>
<p>De Almeida, M. L., Mendes, G. A., Madras Viswanathan, G., &amp; Da Silva, L. R. (2013).
Scale-free homophilic network. European Physical Journal B, 86(2).
<a href="https://doi.org/10.1140/epjb/e2012-30802-x">doi:10.1140/epjb/e2012-30802-x</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using another graph as a base graph ---------------------------------------
graph &lt;- rgraph_ba()
graph

graph &lt;- rgraph_ba(graph=graph)

# Generating a scale-free homophilic graph (no loops) -----------------------
set.seed(112)
eta &lt;- rep(c(1,1,1,1,2,2,2,2), 20)
ans &lt;- rgraph_ba(t=length(eta) - 1, m=3, self=FALSE, eta=eta)

# Converting it to igraph (so we can plot it)
ig  &lt;- igraph::graph_from_adjacency_matrix(ans)

# Neat plot showing the output
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
plot(ig, vertex.color=c("red","blue")[factor(eta)], vertex.label=NA,
    vertex.size=5, main="Scale-free homophilic graph")
suppressWarnings(plot(dgr(ans), main="Degree distribution"))
par(oldpar)

</code></pre>

<hr>
<h2 id='rgraph_er'>Erdos-Renyi model</h2><span id='topic+rgraph_er'></span><span id='topic+bernoulli'></span>

<h3>Description</h3>

<p>Generates a bernoulli random graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgraph_er(
  n = 10,
  t = 1,
  p = 0.01,
  undirected = getOption("diffnet.undirected"),
  weighted = FALSE,
  self = getOption("diffnet.self"),
  as.edgelist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgraph_er_+3A_n">n</code></td>
<td>
<p>Integer. Number of vertices</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_t">t</code></td>
<td>
<p>Integer. Number of time periods</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_p">p</code></td>
<td>
<p>Double. Probability of a link between ego and alter.</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. Whether the graph is undirected or not.</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Whether the graph is weighted or not.</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_self">self</code></td>
<td>
<p>Logical. Whether it includes self-edges.</p>
</td></tr>
<tr><td><code id="rgraph_er_+3A_as.edgelist">as.edgelist</code></td>
<td>
<p>Logical. When TRUE the graph is presented as an edgelist
instead of an adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of nodes <code class="reqn">\{i,j\}</code>, an edge is created
with probability <code class="reqn">p</code>, this is, <code class="reqn">Pr\{Link i-j\} = Pr\{x&lt;p\}</code>, where <code class="reqn">x</code> is drawn from a <code class="reqn">Uniform(0,1)</code>.
</p>
<p>When <code>weighted=TRUE</code>, the strength of ties is given by
the random draw <code class="reqn">x</code> used to compare against <code class="reqn">p</code>, hence, if <code class="reqn">x &lt; p</code>
then the strength will be set to <code class="reqn">x</code>.
</p>
<p>In the case of dynamic graphs, the algorithm is repeated <code class="reqn">t</code> times, so the
networks are uncorrelated.
</p>


<h3>Value</h3>

<p>A graph represented by an adjacency matrix (if <code>t=1</code>), or an array of
adjacency matrices (if <code>t&gt;1</code>).
</p>


<h3>Note</h3>

<p>The resulting adjacency matrix is store as a dense matrix, not as a
sparse matrix, hence the user should be careful when choosing the size of
the network.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Barabasi, Albert-Laszlo. &quot;Network science book&quot; Retrieved November 1 (2015)
<a href="https://barabasi.com/book/network-science">https://barabasi.com/book/network-science</a>.
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting the seed
set.seed(13)

# Generating an directed graph
rgraph_er(undirected=FALSE, p = 0.1)

# Comparing P(tie)
x &lt;- rgraph_er(1000, p=.1)
sum(x)/length(x)

# Several period random gram
rgraph_er(t=5)
</code></pre>

<hr>
<h2 id='rgraph_ws'>Watts-Strogatz model</h2><span id='topic+rgraph_ws'></span><span id='topic+small-world'></span>

<h3>Description</h3>

<p>Generates a small-world random graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgraph_ws(
  n,
  k,
  p,
  both.ends = FALSE,
  self = FALSE,
  multiple = FALSE,
  undirected = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgraph_ws_+3A_n">n</code></td>
<td>
<p>Integer scalar. Set the size of the graph.</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_k">k</code></td>
<td>
<p>Integer scalar. Set the initial degree of the ring (must be less than <code class="reqn">n</code>).</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_p">p</code></td>
<td>
<p>Numeric scalar/vector of length <code class="reqn">T</code>. Set the probability of changing an edge.</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_both.ends">both.ends</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> rewires both ends.</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, allows loops (self edges).</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
<tr><td><code id="rgraph_ws_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. Passed to <code><a href="#topic+ring_lattice">ring_lattice</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented as in Watts and Strogatz (1998). Starts from an
undirected ring with <code class="reqn">n</code> vertices all with degree <code class="reqn">k</code> (so it must
be an even number), and then rewire each edge by setting the endpoint (so
now you treat it as a digraph) randomly any vertex in <code class="reqn">N \setminus {i}</code>
avoiding multiple links (by default) using the rewiring algorithm described on
the paper.
</p>


<h3>Value</h3>

<p>A random graph of size <code class="reqn">n\times n</code> following the small-world
model. The resulting graph will have <code>attr(graph, "undirected")=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of &quot;small-world&quot;
networks. Nature, 393(6684), 440–2. <a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>
<p>Newman, M. E. J. (2003). The Structure and Function of Complex Networks.
SIAM Review, 45(2), 167–256. <a href="https://doi.org/10.1137/S003614450342480">doi:10.1137/S003614450342480</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+ring_lattice">ring_lattice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)
set.seed(7123)
x0 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, 0))
x1 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, .3))
x2 &lt;- graph_from_adjacency_matrix(rgraph_ws(10,2, 1))

oldpar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
plot(x0, layout=layout_in_circle, edge.curved=TRUE, main="Regular")
plot(x1, layout=layout_in_circle, edge.curved=TRUE, main="Small-world")
plot(x2, layout=layout_in_circle, edge.curved=TRUE, main="Random")
par(oldpar)

</code></pre>

<hr>
<h2 id='ring_lattice'>Ring lattice graph</h2><span id='topic+ring_lattice'></span>

<h3>Description</h3>

<p>Creates a ring lattice with <code class="reqn">n</code> vertices, each one of degree (at most) <code class="reqn">k</code>
as an undirected graph. This is the basis of <code><a href="#topic+rgraph_ws">rgraph_ws</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_lattice(n, k, undirected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_lattice_+3A_n">n</code></td>
<td>
<p>Integer scalar. Size of the graph.</p>
</td></tr>
<tr><td><code id="ring_lattice_+3A_k">k</code></td>
<td>
<p>Integer scalar. Out-degree of each vertex.</p>
</td></tr>
<tr><td><code id="ring_lattice_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. Whether the graph is undirected or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when <code>undirected=TRUE</code>, the degree of each node always
even. So if <code>k=3</code>, then the degree will be <code>2</code>.
</p>


<h3>Value</h3>

<p>A sparse matrix of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> of size
<code class="reqn">n\times n</code>.
</p>


<h3>References</h3>

<p>Watts, D. J., &amp; Strogatz, S. H. (1998). Collective dynamics of
“small-world” networks. Nature, 393(6684), 440–2. <a href="https://doi.org/10.1038/30918">doi:10.1038/30918</a>
</p>


<h3>See Also</h3>

<p>Other simulation functions: 
<code><a href="#topic+permute_graph">permute_graph</a>()</code>,
<code><a href="#topic+rdiffnet">rdiffnet</a>()</code>,
<code><a href="#topic+rewire_graph">rewire_graph</a>()</code>,
<code><a href="#topic+rgraph_ba">rgraph_ba</a>()</code>,
<code><a href="#topic+rgraph_er">rgraph_er</a>()</code>,
<code><a href="#topic+rgraph_ws">rgraph_ws</a>()</code>
</p>

<hr>
<h2 id='round_to_seq'>Takes a numeric vector and maps it into a finite length sequence</h2><span id='topic+round_to_seq'></span>

<h3>Description</h3>

<p>Takes a numeric vector and maps it into a finite length sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_to_seq(x, nlevels = 20, as_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_to_seq_+3A_x">x</code></td>
<td>
<p>A numeric or integer vector.</p>
</td></tr>
<tr><td><code id="round_to_seq_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer scalar. Length of the sequence to be map onto.</p>
</td></tr>
<tr><td><code id="round_to_seq_+3A_as_factor">as_factor</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the resulting vector is factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>length(x)</code> with values mapped to a sequence
with <code>nlevels</code> unique valuess
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+diffmap">diffmap</a></code> and <code><a href="#topic+plot_diffnet2">plot_diffnet2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnorm(100)
w &lt;- data.frame(as.integer(round_to_seq(x, as_factor = TRUE)),x)
plot(w,x)

</code></pre>

<hr>
<h2 id='select_egoalter'>Calculate the number of adoption changes between ego and alter.</h2><span id='topic+select_egoalter'></span><span id='topic+adopt_changes'></span><span id='topic+summary.diffnet_adoptChanges'></span>

<h3>Description</h3>

<p>This function calculates the 16 possible configurations between ego and alter
over two time points in terms of their behavior and tie changes.  From time
one to time two, given a binary state of behavior, ego and alter can be
related in 16 different ways. The function <code>adopt_changes</code> is just an
alias for <code>select_egoalter</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_egoalter(graph, adopt, period = NULL)

adopt_changes(graph, adopt, period = NULL)

## S3 method for class 'diffnet_adoptChanges'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_egoalter_+3A_graph">graph</code></td>
<td>
<p>A dynamic graph (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="select_egoalter_+3A_adopt">adopt</code></td>
<td>
<p><code class="reqn">n\times T</code> matrix. Cumulative adoption matrix obtained from <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="select_egoalter_+3A_period">period</code></td>
<td>
<p>Integer scalar. Optional to make the count for a particular period of time.</p>
</td></tr>
<tr><td><code id="select_egoalter_+3A_object">object</code></td>
<td>
<p>An object of class <code>diffnet_adoptChanges</code>.</p>
</td></tr>
<tr><td><code id="select_egoalter_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 16 possibilities are summarized in this matrix:
</p>

<table>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;">       </td><td style="text-align: right;">       </td><td style="text-align: center;"> Alter </td><td style="text-align: center;">     </td><td style="text-align: center;">     </td><td style="text-align: center;">     </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;">       </td><td style="text-align: right;"> <code class="reqn">t-1</code>   </td><td style="text-align: center;">  No   </td><td style="text-align: center;">     </td><td style="text-align: center;"> Yes </td><td style="text-align: center;">     </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;"> <code class="reqn">t-1</code>   </td><td style="text-align: right;"> <code class="reqn">t</code>     </td><td style="text-align: center;">  No   </td><td style="text-align: center;"> Yes </td><td style="text-align: center;"> No  </td><td style="text-align: center;"> Yes </td>
</tr>
<tr>
 <td style="text-align: right;">
  Ego </td><td style="text-align: right;"> No    </td><td style="text-align: right;"> No    </td><td style="text-align: center;">   1   </td><td style="text-align: center;">  2  </td><td style="text-align: center;">   9 </td><td style="text-align: center;">  10 </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;">       </td><td style="text-align: right;"> Yes   </td><td style="text-align: center;">   3   </td><td style="text-align: center;">  4  </td><td style="text-align: center;"> 11  </td><td style="text-align: center;">  12 </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;"> Yes   </td><td style="text-align: right;"> No    </td><td style="text-align: center;">   5   </td><td style="text-align: center;">  6  </td><td style="text-align: center;"> 13  </td><td style="text-align: center;">  14 </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td><td style="text-align: right;">       </td><td style="text-align: right;"> Yes   </td><td style="text-align: center;">   7   </td><td style="text-align: center;">  8  </td><td style="text-align: center;"> 15  </td><td style="text-align: center;">  16
</td>
</tr>

</table>

<p>The
first two Yes/No columns represent Ego's adoption of the innovation in <code class="reqn">t-1</code>
and <code class="reqn">t</code>; while the first two Yes/No rows represent Alter's adoption of the
innovation in <code class="reqn">t-1</code> and t respectively. So for example, number 4 means that
while neither of the two had addopted the innovation in <code class="reqn">t-1</code>, both have in <code class="reqn">t</code>.
At the same time, number 12 means that ego adopted the innovation in <code class="reqn">t</code>, but
alter had already adopted in <code class="reqn">t-1</code> (so it has it in both, <code class="reqn">t</code> and <code class="reqn">t-1</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>diffnet_adoptChanges</code> and <code>data.frame</code>
with <code class="reqn">n\times (T-1)</code> rows and <code class="reqn">2 + 16\times 3</code>
columns. The column names are:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Integer represting the time period</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Node id</p>
</td></tr>
<tr><td><code>select_a_01</code>, <code>...</code>, <code>select_a_16</code></td>
<td>
<p>Number of new links classified
between categories 1 to 16.</p>
</td></tr>
<tr><td><code>select_d_01</code>, <code>...</code>, <code>select_d_16</code></td>
<td>
<p>Number of remove links classified
between categories 1 to 16.</p>
</td></tr>
<tr><td><code>select_s_01</code>, <code>...</code>, <code>select_s_16</code></td>
<td>
<p>Number of unchanged links
classified between categories 1 to 16.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>References</h3>

<p>Thomas W. Valente, Stephanie R. Dyal, Kar-Hai Chu, Heather Wipfli, Kayo
Fujimoto, <em>Diffusion of innovations theory applied to global tobacco control
treaty ratification</em>, Social Science &amp; Medicine, Volume 145, November 2015,
Pages 89-97, ISSN 0277-9536
<a href="https://doi.org/10.1016/j.socscimed.2015.10.001">doi:10.1016/j.socscimed.2015.10.001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example ------------------------------------------------------------
set.seed(1312)
dn &lt;- rdiffnet(20, 5, seed.graph="small-world")

ans &lt;- adopt_changes(dn)
str(ans)
summary(ans)
</code></pre>

<hr>
<h2 id='struct_equiv'>Structural Equivalence</h2><span id='topic+struct_equiv'></span><span id='topic+print.diffnet_se'></span>

<h3>Description</h3>

<p>Computes structural equivalence between ego and alter in a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct_equiv(graph, v = 1, inf.replace = 0, groupvar = NULL, ...)

## S3 method for class 'diffnet_se'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct_equiv_+3A_graph">graph</code></td>
<td>
<p>Any class of accepted graph format (see <code><a href="#topic+netdiffuseR-graphs">netdiffuseR-graphs</a></code>).</p>
</td></tr>
<tr><td><code id="struct_equiv_+3A_v">v</code></td>
<td>
<p>Numeric scalar. Cohesion constant (see details).</p>
</td></tr>
<tr><td><code id="struct_equiv_+3A_inf.replace">inf.replace</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="struct_equiv_+3A_groupvar">groupvar</code></td>
<td>
<p>Either a character scalar (if <code>graph</code> is diffnet), or a
vector of size <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="struct_equiv_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+approx_geodesic">approx_geodesic</a></code>
(not valid for the print method).</p>
</td></tr>
<tr><td><code id="struct_equiv_+3A_x">x</code></td>
<td>
<p>A <code>diffnet_se</code> class object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Structure equivalence is computed as presented in Valente (1995), and Burt (1987),
in particular
</p>
<p style="text-align: center;"><code class="reqn">%
SE_{ij} = \frac{(dmax_i - d_{ji})^v}{\sum_{k\neq i}^n(dmax_i-d_{ki})^v}
</code>
</p>

<p>with the summation over <code class="reqn">k\neq i</code>, and <code class="reqn">d_{ji}</code>, Eucledian distance in terms of geodesics, is defined as
</p>
<p style="text-align: center;"><code class="reqn">%
d_{ji} = \left[(z_{ji} - z_{ij})^2 + \sum_k^n (z_{jk} - z_{ik})^2 +  \sum_k^n (z_{ki} - z_{kj})^2\right]^\frac{1}{2}
</code>
</p>

<p>with <code class="reqn">z_{ij}</code> as the geodesic (shortest path) from <code class="reqn">i</code> to <code class="reqn">j</code>, and
<code class="reqn">dmax_i</code> equal to largest Euclidean distance between <code class="reqn">i</code> and any other
vertex in the network. All summations are made over <code class="reqn">k\not\in \{i,j\}</code>
</p>
<p>Here, the value of <code class="reqn">v</code> is interpreted as cohesion level. The higher its value,
the higher will be the influence that the closests alters will have over ego (see
Burt's paper in the reference).
</p>
<p>Structural equivalence can be computed either for the entire graph or by groups
of vertices. When, for example, the user knows before hand that the vertices
are distributed accross separated communities, he can make this explicit to
the function and provide a <code>groupvar</code> variable that accounts for this.
Hence, when <code>groupvar</code> is not <code>NULL</code> the algorithm will compute
structural equivalence within communities as marked by <code>groupvar</code>.
</p>


<h3>Value</h3>

<p>If <code>graph</code> is a static graph, a list with the following elements:
</p>
<table>
<tr><td><code>SE</code></td>
<td>
<p>Matrix of size <code class="reqn">n\times n</code> with Structural equivalence</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Matrix of size <code class="reqn">n\times n</code> Euclidean distances</p>
</td></tr>
<tr><td><code>gdist</code></td>
<td>
<p>Matrix of size <code class="reqn">n\times n</code> Normalized geodesic distance</p>
</td></tr>
</table>
<p>In the case of dynamic graph, is a list of size <code>t</code> in which each element
contains a list as described before. When <code>groupvar</code> is specified, the
resulting matrices will be of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>,
otherwise will be of class <code><a href="base.html#topic+matrix">matrix</a></code>.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>References</h3>

<p>Burt, R. S. (1987). &quot;Social Contagion and Innovation: Cohesion versus
Structural Equivalence&quot;. American Journal of Sociology, 92(6), 1287–1335.
<a href="https://doi.org/10.1086/228667">doi:10.1086/228667</a>
</p>
<p>Valente, T. W. (1995). &quot;Network models of the diffusion of innovations&quot; (2nd ed.).
Cresskill N.J.: Hampton Press.
</p>


<h3>See Also</h3>

<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computing structural equivalence for the fakedata -------------------------
data(fakesurvey)

# Coercing it into a diffnet object
fakediffnet &lt;- survey_to_diffnet(
   fakesurvey, "id", c("net1", "net2", "net3"), "toa", "group"
)

# Computing structural equivalence without specifying group
se_all &lt;- struct_equiv(fakediffnet)

# Notice that pairs of individuals from different communities have
# non-zero values
se_all
se_all[[1]]$SE

# ... Now specifying a groupvar
se_group &lt;- struct_equiv(fakediffnet, groupvar="group")

# Notice that pairs of individuals from different communities have
# only zero values.
se_group
se_group[[1]]$SE



</code></pre>

<hr>
<h2 id='struct_test'>Structure dependence test</h2><span id='topic+struct_test'></span><span id='topic+n_rewires'></span><span id='topic+c.diffnet_struct_test'></span><span id='topic+print.diffnet_struct_test'></span><span id='topic+hist.diffnet_struct_test'></span><span id='topic+struct_test_asymp'></span>

<h3>Description</h3>

<p>Test whether or not a network estimates can be considered structurally dependent, i.e.
a function of the network structure. By rewiring the graph and calculating
a particular statistic <code class="reqn">t</code>, the test compares the observed mean of <code class="reqn">t</code>
against the empirical distribution of it obtained from rewiring the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_rewires(graph, p = c(20L, rep(0.1, nslices(graph) - 1)))

struct_test(graph, statistic, R, rewire.args = list(), ...)

## S3 method for class 'diffnet_struct_test'
c(..., recursive = FALSE)

## S3 method for class 'diffnet_struct_test'
print(x, ...)

## S3 method for class 'diffnet_struct_test'
hist(
  x,
  main = "Empirical Distribution of Statistic",
  xlab = expression(Values ~ of ~ t),
  breaks = 20,
  annotated = TRUE,
  b0 = expression(atop(plain("") %up% plain("")), t[0]),
  b = expression(atop(plain("") %up% plain("")), t[]),
  ask = TRUE,
  ...
)

struct_test_asymp(graph, Y, statistic_name = "distance", p = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="struct_test_+3A_graph">graph</code></td>
<td>
<p>A <code><a href="#topic+diffnet">diffnet</a></code> graph.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_p">p</code></td>
<td>
<p>Either a Numeric scalar or vector of length <code>nslices(graph)-1</code>
with the number of rewires per links.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_statistic">statistic</code></td>
<td>
<p>A function that returns either a scalar or a vector.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_r">R</code></td>
<td>
<p>Integer scalar. Number of repetitions.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_rewire.args">rewire.args</code></td>
<td>
<p>List. Arguments to be passed to <code><a href="#topic+rewire_graph">rewire_graph</a></code></p>
</td></tr>
<tr><td><code id="struct_test_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method (see details).</p>
</td></tr>
<tr><td><code id="struct_test_+3A_recursive">recursive</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="struct_test_+3A_x">x</code></td>
<td>
<p>A <code>diffnet_struct_test</code> class object.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the histogram.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_xlab">xlab</code></td>
<td>
<p>Character scalar. x-axis label.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_breaks">breaks</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_annotated">annotated</code></td>
<td>
<p>Logical scalar. When TRUE marks the observed data average and the simulated data average.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_b0">b0</code></td>
<td>
<p>Character scalar. When <code>annotated=TRUE</code>, label for the value of <code>b0</code>.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_b">b</code></td>
<td>
<p>Character scalar. When <code>annotated=TRUE</code>, label for the value of <code>b</code>.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_ask">ask</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, asks the user to type <code>&lt;Enter&gt;</code> to see each plot (as
many as statistics where computed).</p>
</td></tr>
<tr><td><code id="struct_test_+3A_y">Y</code></td>
<td>
<p>Numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="struct_test_+3A_statistic_name">statistic_name</code></td>
<td>
<p>Character scalar. Name of the metric to compute. Currently
this can be either <code>"distance"</code>,<code>"&gt;"</code>,<code>"&lt;"</code>,<code>"=="</code>, <code>"&gt;="</code>,
or <code>"&lt;="</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>struct_test</code> computes the test by generating the null distribution using
Monte Carlo simulations (rewiring). <code>struct_test_asymp</code> computes the
test using an asymptotic approximation. While available, we do not recommend
using the asymptotic approximation since it has not shown good results when
compared to the MC approximation. Furthermore, the asymptotic version has only
been implemented for <code>graph</code> as static graph.
</p>
<p>The output from the <code>hist</code> method is the same as <code><a href="graphics.html#topic+hist.default">hist.default</a></code>.
</p>
<p><code>struct_test</code> is a wrapper for the function <code><a href="boot.html#topic+boot">boot</a></code> from the
<span class="pkg">boot</span> package. Instead of resampling data&ndash;vertices or edges&ndash;in each iteration the function
rewires the original graph using <code><a href="#topic+rewire_graph">rewire_graph</a></code> and applies
the function defined by the user in <code>statistic</code>.
</p>
<p>The default values to <code>rewire_graph</code> via <code>rewire.args</code> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>p</code>          </td><td style="text-align: left;"> Number or Integer with default <code>n_rewires(graph)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>undirected</code> </td><td style="text-align: left;"> Logical scalar with default <code>getOption("diffnet.undirected", FALSE)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>copy.first</code> </td><td style="text-align: left;"> Logical scalar with <code>TRUE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>algorithm</code>  </td><td style="text-align: left;"> Character scalar with default <code>"swap"</code>.
</td>
</tr>

</table>

<p>In <code>struct_test</code> <code>...</code> are passed to <code>boot</code>, otherwise are passed
to the corresponding method (<code><a href="graphics.html#topic+hist">hist</a></code> for instance).
</p>
<p>From the <code>print</code> method, p-value for the null of the statistic been
equal between graph and its rewired versions is computed as follows
</p>
<p style="text-align: center;"><code class="reqn">%
p(\tau)=2\times\min\left(\mbox{Pr}(t\leq\tau), \mbox{Pr}(t\geq\tau)\right) %
</code>
</p>

<p>Where <code class="reqn">\mbox{Pr}\{\cdot\}</code> is approximated using the
Empirical Distribution Function retrieved from the simulations.
</p>
<p>For the case of the asymptotic approximation, under the null we have
</p>
<p style="text-align: center;"><code class="reqn">%
\sqrt{n}\left(\hat\beta(Y,G)-\mu_\beta\right)\sim^d\mbox{N}\left(0,\sigma_\beta^2\right)
</code>
</p>

<p>The test is actually on development by Vega Yon and Valente. A copy of the
working paper can be distributed upon request to <a href="mailto:g.vegayon@gmail.com">g.vegayon@gmail.com</a>.
</p>
<p>The function <code>n_rewires</code> proposes a vector of number of rewirings that
are performed in each iteration.
</p>


<h3>Value</h3>

<p>A list of class <code>diffnet_struct_test</code> containing the following:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>The graph passed to <code>struct_test</code>.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The resulting p-value of the test (see details).</p>
</td></tr>
<tr><td><code>t0</code></td>
<td>
<p>The observed value of the statistic.</p>
</td></tr>
<tr><td><code>mean_t</code></td>
<td>
<p>The average value of the statistic applied to the simulated networks.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The function <code>statistic</code> passed to <code>struct_test</code>.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>A <code>boot</code> class object as return from the call to <code>boot</code>.</p>
</td></tr>
<tr><td><code>rewire.args</code></td>
<td>
<p>The list <code>rewire.args</code> passed to <code>struct_test</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Vega Yon, George G. and Valente, Thomas W. (On development).
</p>
<p>Davidson, R., &amp; MacKinnon, J. G. (2004). Econometric Theory and Methods. New York:
Oxford University Press.
</p>


<h3>See Also</h3>

<p>Other Functions for inference: 
<code><a href="#topic+bootnet">bootnet</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a random graph
set.seed(881)
diffnet &lt;- rdiffnet(100, 5, seed.graph="small-world")

# Testing structure-dependency of threshold
res &lt;- struct_test(
  diffnet,
  function(g) mean(threshold(g), na.rm=TRUE),
  R=100
)

res
hist(res)

# Adding a legend
legend("topright", bty="n",
 legend=c(
   expression(t[0]:~Baseline),
   expression(t:~Rewired~average)
 )
 )

# Concatenating results
c(res, res)

# Running in parallel fashion
res &lt;- struct_test(
  diffnet, function(g) mean(threshold(g), na.rm=TRUE),
  R=100, ncpus=2, parallel="multicore"
)

res

hist(res)
</code></pre>

<hr>
<h2 id='summary.diffnet'>Summary of diffnet objects</h2><span id='topic+summary.diffnet'></span>

<h3>Description</h3>

<p>Summary of diffnet objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
summary(
  object,
  slices = NULL,
  no.print = FALSE,
  skip.moran = FALSE,
  valued = getOption("diffnet.valued", FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.diffnet_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+as_diffnet">diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="summary.diffnet_+3A_slices">slices</code></td>
<td>
<p>Either an integer or character vector. While integer vectors are used as
indexes, character vectors are used jointly with the time period labels.</p>
</td></tr>
<tr><td><code id="summary.diffnet_+3A_no.print">no.print</code></td>
<td>
<p>Logical scalar. When TRUE suppress screen messages.</p>
</td></tr>
<tr><td><code id="summary.diffnet_+3A_skip.moran">skip.moran</code></td>
<td>
<p>Logical scalar. When TRUE Moran's I is not reported (see details).</p>
</td></tr>
<tr><td><code id="summary.diffnet_+3A_valued">valued</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> weights will be considered.
Otherwise non-zero values will be replaced by ones.</p>
</td></tr>
<tr><td><code id="summary.diffnet_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+approx_geodesic">approx_geodesic</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Moran's I is calculated over the
cumulative adoption matrix using as weighting matrix the inverse of the geodesic
distance matrix. All this via <code><a href="#topic+moran">moran</a></code>. For each time period <code>t</code>,
this is calculated as:
</p>
<pre>
 m = moran(C[,t], G^(-1))
</pre>
<p>Where <code>C[,t]</code> is the t-th column of the cumulative adoption matrix,
<code>G^(-1)</code> is the element-wise inverse of the geodesic matrix at time <code>t</code>,
and <code>moran</code> is <span class="pkg">netdiffuseR</span>'s moran's I routine. When <code>skip.moran=TRUE</code>
Moran's I is not reported. This can be useful for both: reducing computing
time and saving memory as geodesic distance matrix can become large. Since
version <code>1.18.0</code>, geodesic matrices are approximated using <code>approx_geodesic</code>
which, as a difference from <code><a href="sna.html#topic+geodist">geodist</a></code> from the
<span class="pkg">sna</span> package, and <code><a href="igraph.html#topic+distances">distances</a></code> from the
<span class="pkg">igraph</span> package returns a matrix of class <code>dgCMatrix</code> (more
details in <code><a href="#topic+approx_geodesic">approx_geodesic</a></code>).
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table>
<tr><td><code>adopt</code></td>
<td>
<p>Integer. Number of adopters at each time point.</p>
</td></tr>
<tr><td><code>cum_adopt</code></td>
<td>
<p>Integer. Number of cumulative adopters at each time point.</p>
</td></tr>
<tr><td><code>cum_adopt_pcent</code></td>
<td>
<p>Numeric. Proportion of comulative adopters at each time point.</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>Numeric. Hazard rate at each time point.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>Numeric. Density of the network at each time point.</p>
</td></tr>
<tr><td><code>moran_obs</code></td>
<td>
<p>Numeric. Observed Moran's I.</p>
</td></tr>
<tr><td><code>moran_exp</code></td>
<td>
<p>Numeric. Expected Moran's I.</p>
</td></tr>
<tr><td><code>moran_sd</code></td>
<td>
<p>Numeric. Standard error of Moran's I under the null.</p>
</td></tr>
<tr><td><code>moran_pval</code></td>
<td>
<p>Numeric. P-value for the observed Moran's I.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>See Also</h3>

<p>Other diffnet methods: 
<code><a href="#topic++25+2A+25">%*%</a>()</code>,
<code><a href="#topic+as.array.diffnet">as.array.diffnet</a>()</code>,
<code><a href="#topic+c.diffnet">c.diffnet</a>()</code>,
<code><a href="#topic+diffnet-arithmetic">diffnet-arithmetic</a></code>,
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+diffnet_index">diffnet_index</a></code>,
<code><a href="#topic+plot.diffnet">plot.diffnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(medInnovationsDiffNet)
summary(medInnovationsDiffNet)

</code></pre>

<hr>
<h2 id='survey_to_diffnet'>Convert survey-like data and edgelists to a <code>diffnet</code> object</h2><span id='topic+survey_to_diffnet'></span><span id='topic+edgelist_to_diffnet'></span>

<h3>Description</h3>

<p>These convenient functions turn network nomination datasets and edgelists with
vertex attributes datasets into diffnet objects. Both work as wrappers of
<code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a></code> and <code><a href="#topic+new_diffnet">new_diffnet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_to_diffnet(
  dat,
  idvar,
  netvars,
  toavar,
  groupvar = NULL,
  no.unsurveyed = TRUE,
  timevar = NULL,
  t = NULL,
  undirected = getOption("diffnet.undirected", FALSE),
  self = getOption("diffnet.self", FALSE),
  multiple = getOption("diffnet.multiple", FALSE),
  keep.isolates = TRUE,
  recode.ids = TRUE,
  warn.coercion = TRUE,
  ...
)

edgelist_to_diffnet(
  edgelist,
  w = NULL,
  t0 = NULL,
  t1 = NULL,
  dat,
  idvar,
  toavar,
  timevar = NULL,
  undirected = getOption("diffnet.undirected", FALSE),
  self = getOption("diffnet.self", FALSE),
  multiple = getOption("diffnet.multiple", FALSE),
  fill.missing = NULL,
  keep.isolates = TRUE,
  recode.ids = TRUE,
  warn.coercion = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_to_diffnet_+3A_dat">dat</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_idvar">idvar</code></td>
<td>
<p>Character scalar. Name of the id variable.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_netvars">netvars</code></td>
<td>
<p>Character vector. Names of the network nomination variables.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_toavar">toavar</code></td>
<td>
<p>Character scalar. Name of the time of adoption variable.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_groupvar">groupvar</code></td>
<td>
<p>Character scalar. Name of cohort variable (e.g. city).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_no.unsurveyed">no.unsurveyed</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the nominated individuals
that do not show in <code>idvar</code> are set to <code>NA</code> (see details).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_timevar">timevar</code></td>
<td>
<p>Character sacalar. In the case of longitudinal data, name of the time var.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_t">t</code></td>
<td>
<p>Integer scalar. Repeat the network <code>t</code> times (if no <code>t0,t1</code> are provided).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_undirected">undirected</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> only the lower triangle of the adjacency matrix will considered (faster).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_self">self</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> autolinks (loops, self edges) are allowed (see details).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> allows multiple edges.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_keep.isolates">keep.isolates</code></td>
<td>
<p>Logical scalar. When FALSE, rows with <code>NA/NULL</code> values
(isolated vertices unless have autolink) will be droped (see details).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_recode.ids">recode.ids</code></td>
<td>
<p>Logical scalar. When TRUE ids are recoded using <code><a href="base.html#topic+as.factor">as.factor</a></code>
(see details).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_warn.coercion">warn.coercion</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> warns coercion from numeric to integer.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+new_diffnet">new_diffnet</a></code>.</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_edgelist">edgelist</code></td>
<td>
<p>Two column matrix/data.frame in the form of ego -source- and
alter -target- (see details).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_w">w</code></td>
<td>
<p>Numeric vector. Strength of ties (optional).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_t0">t0</code></td>
<td>
<p>Integer vector. Starting time of the ties (optional).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_t1">t1</code></td>
<td>
<p>Integer vector. Finishing time of the ties (optional).</p>
</td></tr>
<tr><td><code id="survey_to_diffnet_+3A_fill.missing">fill.missing</code></td>
<td>
<p>Character scalar. In the case of having unmatching ids
between <code>dat</code> and <code>edgelist</code>, fills the data (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of <code>netvars</code>, <code>toavar</code> and <code>groupvar</code>
must be integers. Were these numeric they are coerced into integers, otherwise,
when neither of both, the function returns with error. <code>idvar</code>, on the
other hand, should only be integer when calling <code>survey_to_diffnet</code>,
on the contrary, for <code>edgelist_to_diffnet</code>, <code>idvar</code> may be character.
</p>
<p>In field work it is not unusual that some respondents nominate unsurveyed
individuals. In such case, in order to exclude them from the analysis,
the user can set <code>no.unsurveyed=TRUE</code> (the default), telling the
function to exclude such individuals from the adjacency matrix. This is
done by setting variables in <code>netvars</code> equal to <code>NA</code> when the
nominated id can't be found in <code>idvar</code>.
</p>
<p>If the network nomination process was done in different groups (location
for example) the survey id numbers may be define uniquely within each group
but not across groups (there may be many individuals with <code>id=1</code>,
for example). To encompass this issue, the user can tell the function what
variable can be used to distinguish between groups through the <code>groupvar</code>
argument. When <code>groupvar</code> is provided, function redifines <code>idvar</code>
and the variables in <code>netvars</code> as follows:
</p>
<pre>
   dat[[idvar]] &lt;- dat[[idvar]] + dat[[groupvar]]*z
</pre>
<p>Where <code>z = 10^nchar(max(dat[[idvar]]))</code>.
</p>
<p>For longitudinal data, it is assumed that the <code>toavar</code> holds the same
information through time, this is, time-invariable. This as the package does
not yet support variable times of adoption.
</p>
<p>The <code>fill.missing</code> option can take any of these three values: <code>"edgelist"</code>,
<code>"dat"</code>, or <code>"both"</code>. This argument works as follows:
</p>

<ol>
<li><p> When <code>fill.missing="edgelist"</code> (or <code>"both"</code>) the function
will check which vertices show in <code>dat</code> but do not show in <code>edgelist</code>.
If there is any, the function will include these in <code>edgelist</code> as ego to
<code>NA</code> (so they have no link to anyone), and, if specified, will fill
the <code>t0</code>, <code>t1</code> vectors with <code>NA</code>s for those cases. If
<code>w</code> is also specified, the new vertices will be set to
<code>min(w, na.rm=TRUE)</code>.
</p>
</li>
<li><p> When <code>fill.missing="dat"</code> (or <code>"both"</code>) the function
checks which vertices show in <code>edgelist</code> but not in <code>dat</code>. If
there is any, the function will include these in <code>dat</code> by adding
one row per individual.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code><a href="#topic+diffnet">diffnet</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Vega Yon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fakesurvey">fakesurvey</a></code>, <code><a href="#topic+fakesurveyDyn">fakesurveyDyn</a></code>
</p>
<p>Other data management functions: 
<code><a href="#topic+diffnet-class">diffnet-class</a></code>,
<code><a href="#topic+edgelist_to_adjmat">edgelist_to_adjmat</a>()</code>,
<code><a href="#topic+egonet_attrs">egonet_attrs</a>()</code>,
<code><a href="#topic+isolated">isolated</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a fake survey (data frame)
data(fakesurvey)

# Diffnet object keeping isolated vertices ----------------------------------
dn1 &lt;- survey_to_diffnet(fakesurvey, "id", c("net1", "net2", "net3"), "toa",
   "group", keep.isolates=TRUE)

# Diffnet object NOT keeping isolated vertices
dn2 &lt;- survey_to_diffnet(fakesurvey, "id", c("net1", "net2", "net3"), "toa",
   "group", keep.isolates=FALSE)

# dn1 has an extra vertex than dn2
dn1
dn2

# Loading a longitudinal survey data (two waves) ----------------------------
data(fakesurveyDyn)

groupvar &lt;- "group"
x &lt;- survey_to_diffnet(
   fakesurveyDyn, "id", c("net1", "net2", "net3"), "toa", "group" ,
   timevar = "time", keep.isolates = TRUE, warn.coercion=FALSE)

plot_diffnet(x, vertex.label = rownames(x))

# Reproducing medInnovationsDiffNet object ----------------------------------
data(medInnovations)

# What are the netvars
netvars &lt;- names(medInnovations)[grepl("^net", names(medInnovations))]

medInnovationsDiffNet2 &lt;- survey_to_diffnet(
   medInnovations,
   "id", netvars, "toa", "city",
   warn.coercion=FALSE)

medInnovationsDiffNet2

# Comparing with the package's version
all(diffnet.toa(medInnovationsDiffNet2) == diffnet.toa(medInnovationsDiffNet)) #TRUE
all(
   diffnet.attrs(medInnovationsDiffNet2, as.df = TRUE) ==
   diffnet.attrs(medInnovationsDiffNet, as.df = TRUE),
   na.rm=TRUE) #TRUE


</code></pre>

<hr>
<h2 id='threshold'>Retrive threshold levels from the exposure matrix</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Thresholds are each vertexes exposure at the time of adoption.
Substantively it is the proportion of adopters required for each ego to adopt. (see <code><a href="#topic+exposure">exposure</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(
  obj,
  toa,
  t0 = min(toa, na.rm = TRUE),
  include_censored = FALSE,
  lags = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_obj">obj</code></td>
<td>
<p>Either a <code class="reqn">n\times T</code> matrix (eposure to the innovation obtained from
<code><a href="#topic+exposure">exposure</a></code>) or a <code>diffnet</code> object.</p>
</td></tr>
<tr><td><code id="threshold_+3A_toa">toa</code></td>
<td>
<p>Integer vector. Indicating the time of adoption of the innovation.</p>
</td></tr>
<tr><td><code id="threshold_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. See <code><a href="#topic+toa_mat">toa_mat</a></code>.</p>
</td></tr>
<tr><td><code id="threshold_+3A_include_censored">include_censored</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> (default), threshold</p>
</td></tr>
<tr><td><code id="threshold_+3A_lags">lags</code></td>
<td>
<p>Integer scalar. Number of lags to consider when computing thresholds. <code>lags=1</code>
defines threshold as exposure at <code class="reqn">T-1</code>, where <code>T</code> is time of adoption.
levels are not reported for observations adopting in the first time period.</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+exposure">exposure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default exposure is not computed for vertices adopting at the
first time period, <code>include_censored=FALSE</code>, as estimating threshold for
left censored data may yield biased outcomes.
</p>


<h3>Value</h3>

<p>A vector of size <code class="reqn">n</code> indicating the threshold for each node.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>See Also</h3>

<p>Threshold can be visualized using <code><a href="#topic+plot_threshold">plot_threshold</a></code>
</p>
<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a random graph with random Times of Adoption
set.seed(783)
toa &lt;- sample.int(4, 5, TRUE)
graph &lt;- rgraph_er(n=5, t=max(toa) - min(toa) + 1)

# Computing exposure using Structural Equivalnece
adopt &lt;- toa_mat(toa)
se &lt;- struct_equiv(graph)
se &lt;- lapply(se, function(x) methods::as((x$SE)^(-1), "dgCMatrix"))
expo &lt;- exposure(graph, adopt$cumadopt, alt.graph=se)

# Retrieving threshold
threshold(expo, toa)

# We can do the same by creating a diffnet object
diffnet &lt;- as_diffnet(graph, toa)
threshold(diffnet, alt.graph=se)
</code></pre>

<hr>
<h2 id='toa_diff'>Difference in Time of Adoption (TOA) between individuals</h2><span id='topic+toa_diff'></span>

<h3>Description</h3>

<p>Creates <code class="reqn">n \times n</code> matrix indicating the difference in times of adoption between
each pair of nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toa_diff(obj, t0 = NULL, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toa_diff_+3A_obj">obj</code></td>
<td>
<p>Either an integer vector of size <code class="reqn">n</code> containing time of adoption of the innovation,
or a <code><a href="#topic+diffnet">diffnet</a></code> object.</p>
</td></tr>
<tr><td><code id="toa_diff_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Sets the lower bound of the time window (e.g. 1955).</p>
</td></tr>
<tr><td><code id="toa_diff_+3A_labels">labels</code></td>
<td>
<p>Character vector of size <code class="reqn">n</code>. Labels (ids) of the vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each cell ij of the resulting matrix is calculated as <code class="reqn">toa_j - toa_i</code>, so that whenever its positive it means that the j-th individual (alter)
adopted the innovation sooner.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times n</code> symmetric matrix indicating the difference in times of
adoption between each pair of nodes.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a random vector of time
set.seed(123)
times &lt;- sample(2000:2005, 10, TRUE)

# Computing the TOA differences
toa_diff(times)
</code></pre>

<hr>
<h2 id='toa_mat'>Time of adoption matrix</h2><span id='topic+toa_mat'></span>

<h3>Description</h3>

<p>Creates two matrices recording times of adoption of the innovation. One matrix
records the time period of adoption for each node with zeros elsewhere. The
second records the cumulative time of adoption such that there are ones for
the time of adoption and every time period thereafter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toa_mat(obj, labels = NULL, t0 = NULL, t1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toa_mat_+3A_obj">obj</code></td>
<td>
<p>Either an integer vector of size <code class="reqn">n</code> containing time of adoption of the innovation,
or a <code><a href="#topic+diffnet">diffnet</a></code> object.</p>
</td></tr>
<tr><td><code id="toa_mat_+3A_labels">labels</code></td>
<td>
<p>Character vector of size <code class="reqn">n</code>. Labels (ids) of the vertices.</p>
</td></tr>
<tr><td><code id="toa_mat_+3A_t0">t0</code></td>
<td>
<p>Integer scalar. Sets the lower bound of the time window (e.g. 1955).</p>
</td></tr>
<tr><td><code id="toa_mat_+3A_t1">t1</code></td>
<td>
<p>Integer scalar. Sets the upper bound of the time window (e.g. 2000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to be able to work with time ranges other than <code class="reqn">1,\dots, T</code>
the function receives as input the boundary labels of the time windows through
the variables <code>t0</code> and <code>t</code>. While by default the function assumes that
the the boundaries are given by the range of the <code>times</code> vector, the user
can set a personalized time range exceeding the one given by the <code>times</code>
vector. For instance, times of adoption may range between 2001 and 2005 but the
actual data, the network, is observed between 2000 and 2005 (so there is not
left censoring in the data), hence, the user could write:
</p>
<pre>
adopmats &lt;- toa_mat(times, t0=2000, t1=2005)
</pre>
<p>That way the resulting <code>cumadopt</code> and <code>adopt</code> matrices would have
2005 - 2000 + 1 = 6 columns instead of 2005 - 2001 + 1 = 5 columns, with the
first column of the two matrices containing only zeros (as the first adoption
happend after the year 2000).
</p>


<h3>Value</h3>

<p>A list of two <code class="reqn">n \times T</code>
</p>
<table>
<tr><td><code>cumadopt</code></td>
<td>
<p>has 1's for all years in which a node indicates having the innovation.</p>
</td></tr>
<tr><td><code>adopt</code></td>
<td>
<p>has 1's only for the year of adoption and 0 for the rest.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>George G. Vega Yon &amp; Thomas W. Valente
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random set of times of adoptions
times &lt;- sample(c(NA, 2001:2005), 10, TRUE)

toa_mat(times)

# Now, suppose that we observe the graph from 2000 to 2006
toa_mat(times, t0=2000, t1=2006)

</code></pre>

<hr>
<h2 id='transformGraphBy'>Apply a function to a graph considering non-diagonal structural zeros</h2><span id='topic+transformGraphBy'></span><span id='topic+transformGraphBy.diffnet'></span><span id='topic+transformGraphBy.dgCMatrix'></span>

<h3>Description</h3>

<p>When there are structural zeros given by groups, this function applies
a particular transformation function of a graph by groups returning a
square matrix of the same size of the original one with structural zeros
and the function applied by <code>INDICES</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformGraphBy(graph, INDICES, fun = function(g, ...) g, ...)

## S3 method for class 'diffnet'
transformGraphBy(graph, INDICES, fun = function(g, ...) g, ...)

## S3 method for class 'dgCMatrix'
transformGraphBy(graph, INDICES, fun = function(g, ...) g, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformGraphBy_+3A_graph">graph</code></td>
<td>
<p>A graph</p>
</td></tr>
<tr><td><code id="transformGraphBy_+3A_indices">INDICES</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="transformGraphBy_+3A_fun">fun</code></td>
<td>
<p>A function. This function must return a matrix of class
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> with the same dimension as
<code>dim(g)</code>.</p>
</td></tr>
<tr><td><code id="transformGraphBy_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation function <code>fun</code> must return a square matrix
of size <code class="reqn">m\times m</code>, where <code class="reqn">m</code> is the size of the subgroup
given by <code>INDICES</code>. See examples below
</p>


<h3>Value</h3>

<p>A transformed version of the network, with the desired function applied
by blocks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rewiring a graph by community --------------------------------------------

# Two Random graphs of different size
set.seed(123)
g0 &lt;- rgraph_ba(m=2, self=FALSE)
g1 &lt;- rgraph_ba(m=3, t=19, self=FALSE)

# Need a place to store both networks together!
G &lt;- methods::new(
  Class = "dgCMatrix",
  Dim   = c(1L,1L)*(nnodes(g0) + nnodes(g1)),
  p     = rep(0L, (nnodes(g0) + nnodes(g1)) + 1L)
  )

# Filling the matrix
G[1:nnodes(g0),1:nnodes(g0)]                              &lt;- g0
G[(nnodes(g0) + 1):nnodes(G), (nnodes(g0) + 1):nnodes(G)] &lt;- g1

# Creating an index (community)
indx &lt;- c(rep(1, nnodes(g0)), rep(2, nnodes(g1)))

# Apply the rewiring algorithm per group
ans &lt;- transformGraphBy(G, indx, function(g, ...) {
  rewire_graph(g, 100, "swap")
  })

ans


</code></pre>

<hr>
<h2 id='vertex_covariate_compare'>Comparisons at dyadic level</h2><span id='topic+vertex_covariate_compare'></span>

<h3>Description</h3>

<p>Comparisons at dyadic level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_covariate_compare(graph, X, funname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_covariate_compare_+3A_graph">graph</code></td>
<td>
<p>A matrix of size <code class="reqn">n\times n</code> of class <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="vertex_covariate_compare_+3A_x">X</code></td>
<td>
<p>A numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="vertex_covariate_compare_+3A_funname">funname</code></td>
<td>
<p>Character scalar. Comparison to make (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This auxiliary function takes advantage of the sparseness of <code>graph</code> and
applies a function in the form of <code class="reqn">funname(x_i,x_j)</code>
only to <code class="reqn">(i,j)</code> that have no empty entry. In other words, applies a compares
elements of <code>X</code> only between vertices that have a link; making
<code>nlinks(graph)</code> comparisons instead of looping through <code class="reqn">n\times n</code>,
which is much faster.
</p>
<p><code>funname</code> can take any of the following values:
<code>"distance"</code>, <code>"^2"</code> or <code>"quaddistance"</code>, <code>"&gt;"</code> or <code>"greater"</code>,
<code>"&lt;"</code> or <code>"smaller"</code>, <code>"&gt;="</code> or <code>"greaterequal"</code>,
<code>"&lt;="</code> or <code>"smallerequal"</code>, <code>"=="</code> or <code>"equal"</code>.
</p>


<h3>Value</h3>

<p>A matrix <code>dgCMatrix</code> of size <code class="reqn">n\times n</code> with values in
the form of <code class="reqn">funname(x_i,x_j)</code>.
</p>


<h3>See Also</h3>

<p>Other dyadic-level comparison functions: 
<code><a href="#topic+matrix_compare">matrix_compare</a>()</code>,
<code><a href="#topic+vertex_covariate_dist">vertex_covariate_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic example ------------------------------------------------------------
set.seed(1313)
G &lt;- rgraph_ws(10, 4, .2)
x &lt;- rnorm(10)

vertex_covariate_compare(G, x, "distance")
vertex_covariate_compare(G, x, "^2")
vertex_covariate_compare(G, x, "&gt;=")
vertex_covariate_compare(G, x, "&lt;=")
</code></pre>

<hr>
<h2 id='vertex_covariate_dist'>Computes covariate distance between connected vertices</h2><span id='topic+vertex_covariate_dist'></span><span id='topic+p-norm'></span><span id='topic+mahalanobis'></span><span id='topic+minkowski'></span><span id='topic+vertex_mahalanobis_dist'></span>

<h3>Description</h3>

<p>Computes covariate distance between connected vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_covariate_dist(graph, X, p = 2)

vertex_mahalanobis_dist(graph, X, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_covariate_dist_+3A_graph">graph</code></td>
<td>
<p>A square matrix of size <code class="reqn">n</code> of class dgCMatrix.</p>
</td></tr>
<tr><td><code id="vertex_covariate_dist_+3A_x">X</code></td>
<td>
<p>A numeric matrix of size <code class="reqn">n \times K</code>. Vertices attributes</p>
</td></tr>
<tr><td><code id="vertex_covariate_dist_+3A_p">p</code></td>
<td>
<p>Numeric scalar. Norm to compute</p>
</td></tr>
<tr><td><code id="vertex_covariate_dist_+3A_s">S</code></td>
<td>
<p>Square matrix of size <code>ncol(x)</code>. Usually the var-covar matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faster than <code><a href="stats.html#topic+dist">dist</a></code>, these functions compute distance metrics
between pairs of vertices that are connected (otherwise skip).
</p>
<p>The function <code>vertex_covariate_dist</code> is the simil of <code><a href="stats.html#topic+dist">dist</a></code>
and returns p-norms (Minkowski distance). It is implemented as follows (for
each pair of vertices):
</p>
<p style="text-align: center;"><code class="reqn">%
D_{ij} = \left(\sum_{k=1}^K \left|X_{ik} - X_{jk}\right|^{p} \right)^{1/p}\mbox{ if }graph_{i,j}\neq 0
</code>
</p>

<p>In the case of mahalanobis distance, for each pair of vertex <code class="reqn">(i,j)</code>, the
distance is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">%
D_{ij} = \left( (X_i - X_j)\times S \times (X_i - X_j)' \right)^{1/2}\mbox{ if }graph_{i,j}\neq 0
</code>
</p>



<h3>Value</h3>

<p>A matrix of size <code class="reqn">n\times n</code> of class <code>dgCMatrix</code>. Will
be symmetric only if <code>graph</code> is symmetric.
</p>


<h3>Author(s)</h3>

<p>George G. Vega Yon
</p>


<h3>References</h3>

<p>Mahalanobis distance. (2016, September 27). In Wikipedia, The Free Encyclopedia.
Retrieved 20:31, September 27, 2016, from
<a href="https://en.wikipedia.org/w/index.php?title=Mahalanobis_distance&amp;oldid=741488252">https://en.wikipedia.org/w/index.php?title=Mahalanobis_distance&amp;oldid=741488252</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code> in the stats package.
</p>
<p>Other statistics: 
<code><a href="#topic+bass">bass</a></code>,
<code><a href="#topic+classify_adopters">classify_adopters</a>()</code>,
<code><a href="#topic+cumulative_adopt_count">cumulative_adopt_count</a>()</code>,
<code><a href="#topic+dgr">dgr</a>()</code>,
<code><a href="#topic+ego_variance">ego_variance</a>()</code>,
<code><a href="#topic+exposure">exposure</a>()</code>,
<code><a href="#topic+hazard_rate">hazard_rate</a>()</code>,
<code><a href="#topic+infection">infection</a>()</code>,
<code><a href="#topic+moran">moran</a>()</code>,
<code><a href="#topic+struct_equiv">struct_equiv</a>()</code>,
<code><a href="#topic+threshold">threshold</a>()</code>
</p>
<p>Other dyadic-level comparison functions: 
<code><a href="#topic+matrix_compare">matrix_compare</a>()</code>,
<code><a href="#topic+vertex_covariate_compare">vertex_covariate_compare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Distance (aka p norm) -----------------------------------------------------
set.seed(123)
G &lt;- rgraph_ws(20, 4, .1)
X &lt;- matrix(runif(40), ncol=2)

vertex_covariate_dist(G, X)[1:5, 1:5]

# Mahalanobis distance ------------------------------------------------------
S &lt;- var(X)

M &lt;- vertex_mahalanobis_dist(G, X, S)

# Example with diffnet objects ----------------------------------------------

data(medInnovationsDiffNet)
X &lt;- cbind(
  medInnovationsDiffNet[["proage"]],
  medInnovationsDiffNet[["attend"]]
)

S &lt;- var(X, na.rm=TRUE)
ans &lt;- vertex_mahalanobis_dist(medInnovationsDiffNet, X, S)

</code></pre>

<hr>
<h2 id='weighted_var'>Computes weighted variance</h2><span id='topic+weighted_var'></span><span id='topic+wvar'></span>

<h3>Description</h3>

<p>Computes weighted variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_var(x, w)

wvar(x, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_var_+3A_x">x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="weighted_var_+3A_w">w</code></td>
<td>
<p>A numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weighted_variance</code> implements weighted variance computation
in the following form:
</p>
<p style="text-align: center;"><code class="reqn">%
\frac{\sum_i w_i'(x_i - \bar x)^2}{(1-n)}
</code>
</p>

<p>where <code class="reqn">w_i'=w_i/\sum_i w_i</code>, and
<code class="reqn">\bar x = \sum_i w_i'x_i</code>.
</p>


<h3>Value</h3>

<p>Numeric scalar with the weighted variance.
</p>


<h3>See Also</h3>

<p>This function is used in <code><a href="#topic+diffmap">diffmap</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
