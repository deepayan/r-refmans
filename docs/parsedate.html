<!DOCTYPE html><html><head><title>Help for package parsedate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parsedate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#parsedate-package'><p>Parse date from any format, including ISO 8601</p></a></li>
<li><a href='#format_iso_8601'><p>Format date and time according to ISO 8601</p></a></li>
<li><a href='#parse_date'><p>Parse date from any format</p></a></li>
<li><a href='#parse_iso_8601'><p>Parse date from an ISO 8601 format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Recognize and Parse Dates in Various Formats, Including All ISO
8601 Formats</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>G치bor Cs치rdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>G치bor Cs치rdi, Linus Torvalds</td>
</tr>
<tr>
<td>Description:</td>
<td>Parse dates automatically, without the need of
    specifying a format. Currently it includes the git date parser.
    It can also recognize and parse all ISO 8601 formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, withr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gaborcsardi/parsedate">https://github.com/gaborcsardi/parsedate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gaborcsardi/parsedate/issues">https://github.com/gaborcsardi/parsedate/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 10:25:40 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 10:52:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='parsedate-package'>Parse date from any format, including ISO 8601</h2><span id='topic+parsedate-package'></span>

<h3>Description</h3>

<p>Three useful functions to parse and format dates.
</p>

<ul>
<li> <p><code><a href="#topic+parse_iso_8601">parse_iso_8601</a></code> recognizes and parses all valid ISO
8601 date and time formats. It can also be used as an ISO 8601
validator.
</p>
</li>
<li> <p><code><a href="#topic+parse_date">parse_date</a></code> can parse a date when you don't know
which format it is in. First it tries all ISO 8601 formats.
Then it tries git's versatile date parser. Lastly, it tries
<code>as.POSIXct</code>.
</p>
</li>
<li> <p><code><a href="#topic+format_iso_8601">format_iso_8601</a></code> formats a date (and time) in
a specific ISO 8601 format.
</p>
</li></ul>


<hr>
<h2 id='format_iso_8601'>Format date and time according to ISO 8601</h2><span id='topic+format_iso_8601'></span>

<h3>Description</h3>

<p>Format a date in a fixed format that is ISO 8601 valid, and
can be used to compare dates as character strings. It converts
the date(s) to UTC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_iso_8601(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_iso_8601_+3A_date">date</code></td>
<td>
<p>The date(s) to format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of formatted dates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_iso_8601(parse_iso_8601("2013-02-08"))
format_iso_8601(parse_iso_8601("2013-02-08 09:34:00"))
format_iso_8601(parse_iso_8601("2013-02-08 09:34:00+01:00"))
format_iso_8601(parse_iso_8601("2013-W06-5"))
format_iso_8601(parse_iso_8601("2013-039"))
</code></pre>

<hr>
<h2 id='parse_date'>Parse date from any format</h2><span id='topic+parse_date'></span>

<h3>Description</h3>

<p>Recognize and parse dates from a wide range of formats. The current
algorithm is the following:
</p>

<ol>
<li><p> Try parsing dates using all valid ISO 8601 formats, by
calling <code><a href="#topic+parse_iso_8601">parse_iso_8601</a></code>.
</p>
</li>
<li><p> If this fails, then try parsing them using the git
date parser.
</p>
</li>
<li><p> If this fails, then try parsing them using <code>as.POSIXct</code>.
(It is unlikely that this step will parse any dates that the
first two steps couldn't, but it is still a logical fallback,
to make sure that we can parse at least as many dates as
<code>as.POSIXct</code>.
</p>
</li></ol>

<p><code>parse_date</code> returns quickly in case of empty input elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_date(dates, approx = TRUE, default_tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_date_+3A_dates">dates</code></td>
<td>
<p>A character vector. An error is reported if
the function cannot coerce this parameter to a character vector.</p>
</td></tr>
<tr><td><code id="parse_date_+3A_approx">approx</code></td>
<td>
<p>Logical flag, whether the git parse should try
hard(er). If this is set to <code>TRUE</code>, then the current time is used
to fill in the missing parts of the date and time.</p>
</td></tr>
<tr><td><code id="parse_date_+3A_default_tz">default_tz</code></td>
<td>
<p>Time zone to assume for dates that don't specify a
time zone explicitly. Defaults to UTC, and an empty string means the
local time zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All dates are returned in the UTC time zone. If you preder a different
time zone, simply use '.POSIXct()' on the result, see examples below.
</p>


<h3>Value</h3>

<p>A <code>POSIXct</code> vector. <code>NA</code> is returned for
the dates that <code>parse_date</code> could not parse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some easy examples
parse_date("2014-12-12")
parse_date("04/15/99")
parse_date("15/04/99")

# Ambiguous format, parsed assuming MM/DD/YY
parse_date("12/11/99")
parse_date("11/12/99")

# Fill in the current date and time
parse_date("03/20")
parse_date("12")

# But not for this, because this is ISO 8601
parse_date("2014")

# Handle vectors and empty input
parse_date(c("2014","2015","","2016"))

# Convert result to local time
tz &lt;- format(Sys.time(), "%Z")
as.POSIXct(parse_date("2014-12-13T11:12:13"), tz)

# Local time zone
parse_date("2014-12-13T11:12:13", default_tz = "CET")
parse_date("2014-12-13T11:12:13", default_tz = "UTC")

# Convert results to different timezone
parse_date("2015-12-13T11:12:13")
.POSIXct(parse_date("2015-12-13T11:12:13"), tz = "CET")
</code></pre>

<hr>
<h2 id='parse_iso_8601'>Parse date from an ISO 8601 format</h2><span id='topic+parse_iso_8601'></span>

<h3>Description</h3>

<p>See <a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a> and links therein
for the complete standard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_iso_8601(dates, default_tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_iso_8601_+3A_dates">dates</code></td>
<td>
<p>A character vector. An error is reported if
the function cannot coerce this parameter to a character vector.</p>
</td></tr>
<tr><td><code id="parse_iso_8601_+3A_default_tz">default_tz</code></td>
<td>
<p>Time zone to assume for dates that don't specify a
time zone explicitly. Defaults to UTC, and an empty string means the
local time zone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>POSIXct</code> vector. <code>NA</code> is returned for
the dates that <code>parse_date</code> could not parse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Missing fields
parse_iso_8601("2013-02-08 09")
parse_iso_8601("2013-02-08 09:30")

# Separator between date and time can be a 'T'
parse_iso_8601("2013-02-08T09")
parse_iso_8601("2013-02-08T09:30")
parse_iso_8601("2013-02-08T09:30:26")

# Fractional seconds, minutes, hours
parse_iso_8601("2013-02-08T09:30:26.123")
parse_iso_8601("2013-02-08T09:30.5")
parse_iso_8601("2013-02-08T09,25")

# Zulu time zone is UTC
parse_iso_8601("2013-02-08T09:30:26Z")

# ISO weeks, not very intuitive
parse_iso_8601("2013-W06-5")
parse_iso_8601("2013-W01-1")
parse_iso_8601("2009-W01-1")
parse_iso_8601("2009-W53-7")

# Day of the year
parse_iso_8601("2013-039")
parse_iso_8601("2013-039 09:30:26Z")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
