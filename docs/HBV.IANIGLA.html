<!DOCTYPE html><html><head><title>Help for package HBV.IANIGLA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HBV.IANIGLA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alerce_data'><p>Alerce's glacier data for modeling</p></a></li>
<li><a href='#Glacier_Disch'><p>Glacier discharge conceptual model</p></a></li>
<li><a href='#glacio_hydro_hbv'><p>Synthetic glacio-hydrological data for modeling</p></a></li>
<li><a href='#lumped_hbv'><p>Lumped HBV catchment data</p></a></li>
<li><a href='#PET'><p>Potential evapotranspiration models</p></a></li>
<li><a href='#Precip_model'><p>Altitude gradient based precipitation models</p></a></li>
<li><a href='#Routing_HBV'><p>Routing bucket type models</p></a></li>
<li><a href='#semi_distributed_hbv'><p>Semi-distributed HBV model data</p></a></li>
<li><a href='#SnowGlacier_HBV'><p>Snow and ice-melt models</p></a></li>
<li><a href='#Soil_HBV'><p>Empirical soil moisture routine</p></a></li>
<li><a href='#Temp_model'><p>Altitude gradient base air temperature models</p></a></li>
<li><a href='#tupungato_data'><p>Tupungato River basin data</p></a></li>
<li><a href='#UH'><p>Transfer function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modular Hydrological Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Ezequiel Toum &lt;etoum@mendoza-conicet.gob.ar&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ezequiel Toum &lt;etoum@mendoza-conicet.gob.ar&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The HBV hydrological model (Bergström, S. and Lindström, G., (2015) &lt;<a href="https://doi.org/10.1002%2Fhyp.10510">doi:10.1002/hyp.10510</a>&gt;) has been split in modules to allow the user to build his/her own model. This version was developed by the author in IANIGLA-CONICET (Instituto Argentino de Nivologia, Glaciologia y Ciencias Ambientales - Consejo Nacional de Investigaciones Cientificas y Tecnicas) for hydroclimatic studies in the Andes. HBV.IANIGLA incorporates routines for clean and debris covered glacier melt simulations. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/ezetoum27/hbv.ianigla">https://gitlab.com/ezetoum27/hbv.ianigla</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/ezetoum27/hbv.ianigla/-/issues">https://gitlab.com/ezetoum27/hbv.ianigla/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-23 13:08:41 UTC; eze</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-23 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alerce_data'>Alerce's glacier data for modeling</h2><span id='topic+alerce_data'></span>

<h3>Description</h3>

<p>A dataset containing all necessary information to simulate a three year
glacier surface mass balance. The ice body is located on Monte Tronador,
nearby the border between Argentina and Chile in the Andes of Northern Patagonia.
Alerce is a medium size mountain glacier with an area of about 2.33 km2 that
ranges between 1629 and 2358 <code>masl</code> and it shows a SE aspect (IANIGLA-ING, 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alerce_data
</code></pre>


<h3>Format</h3>

<p>A list with five elements
</p>

<dl>
<dt>mass_balance</dt><dd><p>data frame with the estimated annual mass balance and the acceptable uncertainty bounds.</p>
</dd>
<dt>mb_dates</dt><dd><p>data frame containing the first fix days of the winter and summer mass balances.</p>
</dd>
<dt>meteo_data</dt><dd><p>data frame with the precipitation gauge and air temperatures records. The former
series is recorded at Puerto Montt's station (Chile) and the last one is measured at Bariloche's
airport (Argentina)</p>
</dd>
<dt>topography</dt><dd><p>data frame with: elevation zone number, minimum, maximum and mean altitude
values for the elevation range and the relative area.</p>
</dd>
<dt>station_height</dt><dd><p>numeric vector with the stations heights. Air temperature refers to
Bariloche's airport and precipitation to Puerto Montt station. Units are in <code>masl</code> (meters
above sea level).</p>
</dd>
</dl>



<h3>References</h3>

<p>IANIGLA-ING. IANIGLA-Inventario Nacional de Glaciares. 2018. Informe de las subcuencas de los
ríos Manso, Villegas y Foyel. Cuenca de los ríos Manso y Puelo. IANIGLA-CONICET, Ministerio
de Ambiente y Desarrollo Sustentable de la Nación. Technical report, IANIGLA, 2018b.[p8]
</p>

<hr>
<h2 id='Glacier_Disch'>Glacier discharge conceptual model</h2><span id='topic+Glacier_Disch'></span>

<h3>Description</h3>

<p>Implement the conceptual water storage and release formulation for
glacier runoff routing. The current model version follows the approach proposed
by <cite>Stahl et al. (2008)</cite> (hereafter S08) for the Bridge River basin. Note that
the bucket storage and release concepts for glacier runoff modeling are also
described in <cite>Jansson et al. (2002)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Glacier_Disch(
       model,
       inputData,
       initCond,
       param
       )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Glacier_Disch_+3A_model">model</code></td>
<td>
<p>numeric integer with the model's choice. The current HBV.IANIGLA version
only supports the <strong>S08</strong> approach.
</p>

<ul>
<li><p> 1:<strong>S08</strong> glacier storage and release model.
</p>
</li></ul>

<p><img src="../help/figures/glacier_discharge_hbv.png" width=200 alt="glacier_discharge_hbv.png" /></p>
</td></tr>
<tr><td><code id="Glacier_Disch_+3A_inputdata">inputData</code></td>
<td>
<p>numeric matrix with two columns:
</p>
<p><strong>Model 1</strong>
</p>

<ul>
<li> <p><code>column_1</code>: snow water equivalent above the glacier <code class="reqn">[mm/\Delta t]</code>.
The series can be obtained from the <a href="#topic+SnowGlacier_HBV">SnowGlacier_HBV</a> function output.
</p>
</li>
<li> <p><code>column_2</code>:  melted snow + melted ice + rainfall <code class="reqn">[mm/\Delta t]</code>. This
series comes from the <strong>TotScal</strong> column in the <a href="#topic+SnowGlacier_HBV">SnowGlacier_HBV</a>
function output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Glacier_Disch_+3A_initcond">initCond</code></td>
<td>
<p>numeric value with the initial glacier reservoir
water content <strong><code>SG</code></strong> <code class="reqn">[mm]</code>.</p>
</td></tr>
<tr><td><code id="Glacier_Disch_+3A_param">param</code></td>
<td>
<p>numeric vector with the following values:
</p>
<p><strong>Model 1 (S08)</strong>
</p>

<ul>
<li> <p><code>KGmin</code>: minimal outflow rate <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>dKG</code>:  maximum outflow rate increase <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>AG</code>: scale factor <code class="reqn">[mm]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with the following columns:
</p>
<p><strong>Model 1 (S08)</strong>
</p>

<ul>
<li> <p><code>Q</code>: glacier discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SG</code>: glacier's bucket water storage content series <code class="reqn">[1/\Delta t]</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Jansson, P., Hock, R., Schneider, T., 2003. The concept of glacier storage: a review.
J. Hydrol., Mountain Hydrology and Water Resources 282, 116–129.
https://doi.org/10.1016/S0022-1694(03)00258-0
</p>
<p>Stahl, K., Moore, R.D., Shea, J.M., Hutchinson, D., Cannon, A.J., 2008. Coupled
modelling of glacier and streamflow response to future climate scenarios.
Water Resour. Res. 44, W02422. https://doi.org/10.1029/2007WR005956
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## Create an input data and run the module
DataMatrix &lt;- cbind(
                    runif(n = 100, min = 0, max = 50),
                    runif(n = 100, min = 0, max = 200)
                    )

dischGl    &lt;- Glacier_Disch(model = 1, inputData = DataMatrix,
                           initCond = 100, param = c(0.1, 0.9, 10))

</code></pre>

<hr>
<h2 id='glacio_hydro_hbv'>Synthetic glacio-hydrological data for modeling</h2><span id='topic+glacio_hydro_hbv'></span>

<h3>Description</h3>

<p>A dataset containing all the necessary information to simulate almost 15 year
of catchment streamflow in a synthetic basin. This example was though to improve
user's skills on the HBV.IANIGLA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glacio_hydro_hbv
</code></pre>


<h3>Format</h3>

<p>A list with five elements
</p>

<dl>
<dt>basin</dt><dd><p>data frame containing elevation band names and the hypsometric values
for modeling the catchment.</p>
</dd>
<dt>tair</dt><dd><p>numeric matrix with the air temperature series (columns) for the 15
elevation bands.</p>
</dd>
<dt>prec</dt><dd><p>numeric matrix with the precipitation series (columns) for the 15
elevation bands.</p>
</dd>
<dt>pet</dt><dd><p>numeric matrix with the potential evapotranspiration series (columns) for the 15
elevation bands.</p>
</dd>
<dt>qout</dt><dd><p>numeric matrix containing the total basin discharge, the streamflow coming
from the soil portion of the basin and the part that is generated in the glaciers.</p>
</dd>
</dl>


<hr>
<h2 id='lumped_hbv'>Lumped HBV catchment data</h2><span id='topic+lumped_hbv'></span>

<h3>Description</h3>

<p>Here you will find what I consider the starting point dataset to begin the modeling with
HBV.IANIGLA. This data is for modeling the streamflow of a synthetic basin
with a perfect fit. For running the model you will have to connect the different
package's modules (or functions) in order to get what I consider
the most simple hydrological model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lumped_hbv
</code></pre>


<h3>Format</h3>

<p>A data frame containing:
</p>

<dl>
<dt>Date</dt><dd><p>date series.</p>
</dd>
<dt>T(ºC)</dt><dd><p>air temperature series.</p>
</dd>
<dt>P(mm/d)</dt><dd><p>total ammount of precipitation per day.</p>
</dd>
<dt>PET(mm/d)</dt><dd><p>potential evapotranspiration series.</p>
</dd>
<dt>qout(mm/d)</dt><dd><p>specific basin discharge. This are the values that you have to reproduce.</p>
</dd>
</dl>


<hr>
<h2 id='PET'>Potential evapotranspiration models</h2><span id='topic+PET'></span>

<h3>Description</h3>

<p>Calculate your potential evapotranspiration series. This module was
design to provide a simple and straight forward way to calculate
one of the inputs for the soil routine (to show how does it works), but for real
world application I strongly recommend the use of the specialized
<a href="https://CRAN.R-project.org/package=Evapotranspiration"><code>Evapotranspiration</code></a>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PET(
  model,
  hemis,
  inputData,
  elev,
  param
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PET_+3A_model">model</code></td>
<td>
<p>numeric value with model option:
</p>

<ul>
<li><p> 1: Calder's model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PET_+3A_hemis">hemis</code></td>
<td>
<p>numeric value indicating the hemisphere:
</p>

<ul>
<li><p> 1: southern hemisphere.
</p>
</li>
<li><p> 2: northern hemisphere.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PET_+3A_inputdata">inputData</code></td>
<td>
<p>numeric matrix with the following columns:
</p>
<p><strong>Calder's model</strong>
</p>

<ul>
<li> <p><code>column_1</code>: julian dates, e.g: <code>as.matrix( c(1:365) )</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PET_+3A_elev">elev</code></td>
<td>
<p>numeric vector with the following values:
</p>
<p><strong>Calder's model</strong>
</p>

<ul>
<li><p> 1: <code>zref</code>: the reference height where potential evapotranspiration or
input data to calculate PET is known.
</p>
</li>
<li><p> 2: <code>ztopo</code>: target PET's topographic height.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PET_+3A_param">param</code></td>
<td>
<p>numeric vector with the following values:
</p>
<p><strong>Calder's model</strong>
</p>

<ul>
<li><p> 1: <code>PET</code>: climatological daily mean potential evapotranspiration [mm].
</p>
</li>
<li><p> 2: <code>gradPET</code>: evapotranspiration decrease gradient [mm/100 m].
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the potential evapotranspiration series.
</p>


<h3>References</h3>

<p>Calder, I.R., Harding, R.J., Rosier, P.T.W., 1983. An objective assessment of soil-moisture
deficit models. J. Hydrol. 60, 329–355. https://doi.org/10.1016/0022-1694(83)90030-6
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## Run the model for a year in the southern hemisphere
potEvap &lt;- PET(model = 1,
               hemis = 1,
               inputData = as.matrix(1:365),
               elev = c(1000, 1500),
               param = c(4, 0.5))

</code></pre>

<hr>
<h2 id='Precip_model'>Altitude gradient based precipitation models</h2><span id='topic+Precip_model'></span>

<h3>Description</h3>

<p>Extrapolate precipitation gauge measurements to another heights. In this package
version you can use the classical linear gradient model or a modified version which
sets a threshold altitude for precipitation increment (avoiding unreliable estimations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Precip_model(
       model,
       inputData,
       zmeteo,
       ztopo,
       param
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Precip_model_+3A_model">model</code></td>
<td>
<p>numeric value with model option:
</p>

<ul>
<li><p> 1: linear precipitation gradient (LP).
</p>
</li>
<li><p> 2: linear precipitation gradient with an upper threshold (LPM).
</p>
</li></ul>
</td></tr>
<tr><td><code id="Precip_model_+3A_inputdata">inputData</code></td>
<td>
<p>numeric vector with precipitation gauge series <code class="reqn">[mm/\Delta t]</code>.</p>
</td></tr>
<tr><td><code id="Precip_model_+3A_zmeteo">zmeteo</code></td>
<td>
<p>numeric value indicating the altitude of the precipitation gauge <code class="reqn">[masl]</code>.</p>
</td></tr>
<tr><td><code id="Precip_model_+3A_ztopo">ztopo</code></td>
<td>
<p>numeric value with the target height <code class="reqn">[masl]</code>.</p>
</td></tr>
<tr><td><code id="Precip_model_+3A_param">param</code></td>
<td>
<p>numeric vector with the following parameters:
</p>
<p><strong>LP</strong>
</p>

<ul>
<li><p> 1: precipitation gradient (<code>gradP</code>) [%/100m].
</p>
</li></ul>

<p><strong>LPM</strong>
</p>

<ul>
<li><p> 1: precipitation gradient (<code>gradP</code>) [%/100m].
</p>
</li>
<li><p> 2: threshold height. Precipitation does not increase when the altitude (<code>ztopo</code>)
is higher than this parameter <code class="reqn">[masl]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the extrapolated precipitation series.
</p>


<h3>References</h3>

<p>For some interesting work on precipitation gradients at catchment and
synoptic scale see:
</p>
<p>Immerzeel, W.W., Petersen, L., Ragettli, S., Pellicciotti, F., 2014.
The importance of observed gradients of air temperature and precipitation for modeling
runoff from a glacierized watershed in the Nepalese Himalayas.
Water Resour. Res. 50, 2212–2226. https://doi.org/10.1002/2013WR014506
</p>
<p>Viale, M., Nuñez, M.N., 2010. Climatology of Winter Orographic Precipitation over the
Subtropical Central Andes and Associated Synoptic and Regional Characteristics.
J. Hydrometeorol. 12, 481–507. https://doi.org/10.1175/2010JHM1284.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## LP case
set.seed(369)

precLP &lt;- Precip_model(model = 1, inputData = runif(n = 365, max = 30, min = 0),
                        zmeteo = 3000, ztopo = 4700, param = c(5))

## LPM case
set.seed(369)

precLPM &lt;- Precip_model(model = 2, inputData = runif(n = 365, max = 30, min = 0),
                        zmeteo = 3000, ztopo = 4700, param = c(5, 4500))

</code></pre>

<hr>
<h2 id='Routing_HBV'>Routing bucket type models</h2><span id='topic+Routing_HBV'></span>

<h3>Description</h3>

<p>Implement one of the five different bucket formulations for
runoff routing. The output of this function is the input series of the
transfer function (<code><a href="#topic+UH">UH</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Routing_HBV(
       model,
       lake,
       inputData,
       initCond,
       param
       )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Routing_HBV_+3A_model">model</code></td>
<td>
<p>numeric integer indicating which reservoir formulation to use:
</p>

<ul>
<li><p> 1: Three series of reservoirs. Lake option is allowed.
</p>
<p><img src="../help/figures/bucket_3_outlet_3.png" width=200 alt="bucket_3_outlet_3.png" />
</p>
</li>
<li><p> 2: Two series of reservoirs. Lake option is allowed.
</p>
<p><img src="../help/figures/bucket_2_outlet_2.png" width=200 alt="bucket_2_outlet_2.png" />
</p>
</li>
<li><p> 3: Two reservoirs and three outlets. Lake option is allowed.
</p>
<p><img src="../help/figures/bucket_2_outlet_3.png" width=200 alt="bucket_2_outlet_3.png" />
</p>
</li>
<li><p> 4: One reservoir and two outlets. Lake is NOT allowed.
</p>
<p><img src="../help/figures/bucket_1_outlet_2.png" width=200 alt="bucket_1_outlet_2.png" />
</p>
</li>
<li><p> 5: One reservoir and three outlets. Lake is NOT allowed.
</p>
<p><img src="../help/figures/bucket_1_outlet_3.png" width=200 alt="bucket_1_outlet_3.png" />
</p>
</li></ul>
</td></tr>
<tr><td><code id="Routing_HBV_+3A_lake">lake</code></td>
<td>
<p>logical. A <code>TRUE</code> value will enable the lake option (only available
on <strong>models 1, 2 and 3</strong>). When modeling a lake, HBV.IANIGLA considers
that this water body exist on the bottom bucket, so you will also have to provide
a lake evaporation and precipitation series in the <strong><code>inputData</code></strong> matrix.</p>
</td></tr>
<tr><td><code id="Routing_HBV_+3A_inputdata">inputData</code></td>
<td>
<p>numeric matrix with three columns (two of them depends on
<strong><code>lake</code></strong> option).
</p>

<ul>
<li> <p><code>column_1</code>: effective runoff series <code class="reqn">[mm/\Delta T]</code>. This is
the output of the <code><a href="#topic+Soil_HBV">Soil_HBV</a></code> module.
</p>
</li>
<li> <p><code>column_2</code>: only if  <strong><code>lake = TRUE</code></strong>. Precipitation series
falling in the lake. <strong>When using it remember that the precipitation should
be rescaled according to the relative area of the lake in the basin</strong>.
</p>
</li>
<li> <p><code>column_3</code>: only if  <strong><code>lake = TRUE</code></strong>. Lake's evaporation
series. <strong>When using it remember that the precipitation should
be rescaled according to the relative area of the lake in the basin</strong>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Routing_HBV_+3A_initcond">initCond</code></td>
<td>
<p>numeric vector with the following initial state variables.
</p>

<ul>
<li> <p><code>SLZ0</code>: initial water content of the lower reservoir <code class="reqn">[mm]</code>. This
state variable is compulsory for all <strong>model</strong> options.
</p>
</li>
<li> <p><code>SUZ0</code>: initial water content of the intermediate reservoir <code class="reqn">[mm]</code>.
This option does not make sense for <strong>models 4 and 5</strong>.
</p>
</li>
<li> <p><code>STZ0</code>: initial water content of the upper reservoir <code class="reqn">[mm]</code>.
This option only make sense for <strong>model 1</strong>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Routing_HBV_+3A_param">param</code></td>
<td>
<p>numeric vector. The length depends on the <strong>model</strong>'s choice:
</p>
<p><strong>Model 1</strong>
</p>

<ul>
<li> <p><code>K0</code>: top bucket (<code>STZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K1</code>: intermediate bucket (<code>SUZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K2</code>: lower bucket (<code>SLZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>UZL</code>: maximum flux rate between <code>STZ</code> and
<code>SUZ</code> <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>PERC</code>: maximum flux rate between <code>SUZ</code> and
<code>SLZ</code> <code class="reqn">[mm/\Delta t]</code>.
</p>
</li></ul>

<p><strong>Model 2</strong>
</p>

<ul>
<li> <p><code>K1</code>: intermediate bucket (<code>SUZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K2</code>: lower bucket (<code>SLZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>PERC</code>: maximum flux rate between <code>SUZ</code> and
<code>SLZ</code> <code class="reqn">[mm/\Delta t]</code>.
</p>
</li></ul>

<p><strong>Model 3</strong>
</p>

<ul>
<li> <p><code>K0</code>: top output (<code>Q0</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K1</code>: intermediate bucket (<code>SUZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K2</code>: lower bucket (<code>SLZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>UZL</code>: minimum water content of <code>SUZ</code> for supplying fast runoff
(<code>Q0</code>) to the total reservoir discharge (<code>Qg</code>) <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>PERC</code>: maximum flux rate between <code>SUZ</code> and
<code>SLZ</code> <code class="reqn">[mm/\Delta t]</code>.
</p>
</li></ul>

<p><strong>Model 4</strong>
</p>

<ul>
<li> <p><code>K1</code>: intermediate output (<code>Q1</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K2</code>: lower bucket (<code>SLZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>PERC</code>: minimum water content of <code>SLZ</code> for supplying intermediate
runoff (<code>Q1</code>) to the total reservoir discharge (<code>Qg</code>) <code class="reqn">[mm]</code>.
</p>
</li></ul>

<p><strong>Model 5</strong>
</p>

<ul>
<li> <p><code>K0</code>: top output (<code>Q0</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K1</code>: intermediate output (<code>Q1</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>K2</code>: lower bucket (<code>SLZ</code>) storage constant <code class="reqn">[1/\Delta t]</code>.
</p>
</li>
<li> <p><code>UZL</code>: minimum water content of <code>SLZ</code> for supplying fast runoff
(<code>Q0</code>) to the total reservoir discharge (<code>Qg</code>) <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>PERC</code>: minimum water content of <code>SLZ</code> for supplying intermediate
runoff (<code>Q1</code>) to the total reservoir discharge (<code>Qg</code>) <code class="reqn">[mm]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with the following columns:
</p>
<p><strong>Model 1</strong>
</p>

<ul>
<li> <p><code>Qg</code>: total buckets output discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q0</code>: top bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q1</code>: intermediate bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q2</code>: lower bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>STZ</code>: top reservoir storage <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>SUZ</code>: intermediate reservoir storage <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>SLZ</code>: lower reservoir storage <code class="reqn">[mm]</code>.
</p>
</li></ul>

<p><strong>Model 2</strong>
</p>

<ul>
<li> <p><code>Qg</code>: total buckets output discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q1</code>: intermediate bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q2</code>: lower bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SUZ</code>: intermediate reservoir storage <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>SLZ</code>: lower reservoir storage <code class="reqn">[mm]</code>.
</p>
</li></ul>

<p><strong>Model 3</strong>
</p>

<ul>
<li> <p><code>Qg</code>: total buckets output discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q0</code>: intermediate bucket fast discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q1</code>: intermediate bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q2</code>: lower bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SUZ</code>: intermediate reservoir storage <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>SLZ</code>: lower reservoir storage <code class="reqn">[mm]</code>.
</p>
</li></ul>

<p><strong>Model 4</strong>
</p>

<ul>
<li> <p><code>Qg</code>: total buckets output discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q1</code>: lower bucket intermediate discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q2</code>: lower bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SLZ</code>: lower reservoir storage <code class="reqn">[mm]</code>.
</p>
</li></ul>

<p><strong>Model 5</strong>
</p>

<ul>
<li> <p><code>Qg</code>: total buckets output discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q0</code>: lower bucket fast discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q1</code>: lower bucket intermediate discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>Q2</code>: lower bucket discharge <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SLZ</code>: lower reservoir storage <code class="reqn">[mm]</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Bergström, S., Lindström, G., 2015. Interpretation of runoff processes in
hydrological modelling—experience from the HBV approach. Hydrol. Process. 29, 3535–3545.
https://doi.org/10.1002/hyp.10510
</p>
<p>Beven, K.J., 2012. Rainfall - Runoff Modelling, 2 edition. ed. Wiley, Chichester.
</p>
<p>Seibert, J., Vis, M.J.P., 2012. Teaching hydrological modeling with a user-friendly
catchment-runoff-model software package. Hydrol Earth Syst Sci 16, 3315–3325.
https://doi.org/10.5194/hess-16-3315-2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## Case example with the first model
inputMatrix &lt;- cbind(
                     runif(n = 200, max = 100, min = 0),
                     runif(n = 200, max = 50, min = 5),
                     runif(n = 100, max = 3, min = 1)
                     )

routeMod1   &lt;- Routing_HBV(model = 1, lake = TRUE, inputData = inputMatrix,
                     initCond = c(10, 15, 20), param = c(0.1, 0.05, 0.001, 1, 0.8))


</code></pre>

<hr>
<h2 id='semi_distributed_hbv'>Semi-distributed HBV model data</h2><span id='topic+semi_distributed_hbv'></span>

<h3>Description</h3>

<p>Here you will find the <strong>lumped model's</strong> next step. A semi-distributed model seems more
similar to what we try to simulate in real world hydrology. This dataset
allows you to experiment with a synthetic HBV.IANIGLA semi-distributed exercise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semi_distributed_hbv
</code></pre>


<h3>Format</h3>

<p>A list with five elements
</p>

<dl>
<dt>basin</dt><dd><p>data frame containing elevation band names and the hypsometric values
for modeling the catchment.</p>
</dd>
<dt>tair</dt><dd><p>numeric matrix with the air temperature series (columns) for the 15
elevation bands.</p>
</dd>
<dt>prec</dt><dd><p>numeric matrix with the precipitation series (columns) for the 15
elevation bands.</p>
</dd>
<dt>pet</dt><dd><p>numeric matrix with the potential evapotranspiration series (columns) for
the 15 elevation bands.</p>
</dd>
<dt>qout</dt><dd><p>numeric vector with the synthetic catchment discharge.</p>
</dd>
</dl>


<hr>
<h2 id='SnowGlacier_HBV'>Snow and ice-melt models</h2><span id='topic+SnowGlacier_HBV'></span>

<h3>Description</h3>

<p>Allows you to simulate snow accumulation and melting processes
using a temperature index approach. The function also incorporates options
for clean and debris covered glacier surface mass balance simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SnowGlacier_HBV(
       model,
       inputData,
       initCond,
       param
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SnowGlacier_HBV_+3A_model">model</code></td>
<td>
<p>numeric indicating which model you will use:
</p>

<ul>
<li><p> 1: temperature index model.
</p>
</li>
<li><p> 2: temperature index model with a variable snow cover area as input data
(as in the Snowmelt Runoff Model - SRM).
</p>
</li>
<li><p> 3: temperature index model with a variable glacier area as input data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SnowGlacier_HBV_+3A_inputdata">inputData</code></td>
<td>
<p>numeric matrix being columns the input variables. As in the whole
package functions, <code>NA_real_</code>  values are forbidden. When speaking about model
options we refer to the <strong><code>model</code></strong> argument.
</p>
<p><strong>Model 1:</strong> </p>

<ul>
<li> <p><code>column_1</code>: air temperature series <code class="reqn">[°C/\Delta t]</code>.
</p>
</li>
<li> <p><code>column_2</code>: precipitation series <code class="reqn">[mm/\Delta t]</code>.
</p>
</li></ul>

<p><strong>Model 2:</strong> </p>

<ul>
<li> <p><code>column_1</code>: air temperature <code class="reqn">[°C/\Delta t]</code>.
</p>
</li>
<li> <p><code>column_2</code>: precipitation <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>column_3</code>: snow cover area. Values between [0 ; 1] <code class="reqn">[-]</code>.
</p>
</li></ul>

<p><strong>Model 3:</strong> </p>

<ul>
<li> <p><code>column_1</code>: air temperature  <code class="reqn">[°C/\Delta t]</code>.
</p>
</li>
<li> <p><code>column_2</code>: precipitation  <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>column_3</code>: glacier cover area. This area values are relative to the
total surface area of the basin <code class="reqn">[-]</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SnowGlacier_HBV_+3A_initcond">initCond</code></td>
<td>
<p>numeric vector with the following values.
</p>

<ul>
<li> <p><code>SWE0</code>: initial snow water equivalent <code class="reqn">[mm]</code>.
</p>
</li>
<li><p> numeric integer indicating the surface type. <em>1</em>: clean ice; <em>2</em>: soil;
<em>3</em>: debris-covered ice.
</p>
</li>
<li><p> area of the glacier(s) (in the elevation band) relative to the basin; e.g.: 0.1 <code class="reqn">[-]</code>.
This option is required in <em>Model 1</em> and <em>Model 2</em> when surface is a glacier.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SnowGlacier_HBV_+3A_param">param</code></td>
<td>
<p>numeric vector with the following values:
</p>

<ol>
<li> <p><code>SFCF</code>: snowfall correction factor <code class="reqn">[-]</code>.
</p>
</li>
<li> <p><code>Tr</code>: solid and liquid precipitation threshold temperature <code class="reqn">[ºC]</code>.
</p>
</li>
<li> <p><code>Tt</code>: melt temperature <code class="reqn">[ºC]</code>.
</p>
</li>
<li> <p><code>fm</code>: snowmelt factor <code class="reqn">[mm/°C.\Delta t]</code>.
</p>
</li>
<li> <p><code>fi</code>: icemelt factor <code class="reqn">[mm/°C.\Delta t]</code>.
</p>
</li>
<li> <p><code>fic</code>: debris-covered ice-melt factor <code class="reqn">[mm/°C.\Delta t]</code>.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with the following columns:
</p>
<p><strong>Model 1</strong>
</p>
<p>** if surface is soil,
</p>

<ol>
<li> <p><code>Prain</code>: precip. as rainfall.
</p>
</li>
<li> <p><code>Psnow</code>: precip. as snowfall.
</p>
</li>
<li> <p><code>SWE</code>: snow water equivalent.
</p>
</li>
<li> <p><code>Msnow</code>: melted snow.
</p>
</li>
<li> <p><code>Total</code>: <code>Prain</code> + <code>Msnow</code>.
</p>
</li></ol>

<p>** if surface is ice,
</p>

<ol>
<li> <p><code>Prain</code>: precip. as rainfall.
</p>
</li>
<li> <p><code>Psnow</code>: precip. as snowfall.
</p>
</li>
<li> <p><code>SWE</code>: snow water equivalent.
</p>
</li>
<li> <p><code>Msnow</code>: melted snow.
</p>
</li>
<li> <p><code>Mice</code>: melted ice.
</p>
</li>
<li> <p><code>Mtot</code>: <code>Msnow</code> + <code>Mice</code>.
</p>
</li>
<li> <p><code>Cum</code>: <code>Psnow</code> - <code>Mtot</code>.
</p>
</li>
<li> <p><code>Total</code>: <code>Prain</code> + <code>Mtot</code>.
</p>
</li>
<li> <p><code>TotScal</code>: <code>Total</code> * initCond[3].
</p>
</li></ol>

<p><strong>Model 2</strong>
</p>
<p>** if surface is soil,
</p>

<ol>
<li> <p><code>Prain</code>: precip. as rainfall.
</p>
</li>
<li> <p><code>Psnow</code>: precip. as snowfall.
</p>
</li>
<li> <p><code>SWE</code>: snow water equivalent.
</p>
</li>
<li> <p><code>Msnow</code>: melted snow.
</p>
</li>
<li> <p><code>Total</code>: <code>Prain</code> + <code>Msnow</code>.
</p>
</li>
<li> <p><code>TotScal</code>: <code>Msnow</code> * <code>SCA</code> + <code>Prain</code>.
</p>
</li></ol>

<p>** if surface is ice -&gt; as in <em>Model 1</em>
</p>
<p><strong>Model 3</strong>
</p>
<p>** if surface is soil -&gt; as in <em>Model 1</em>
</p>
<p>** if surface is ice,
</p>

<ol>
<li> <p><code>Prain</code>: precip. as rainfall.
</p>
</li>
<li> <p><code>Psnow</code>: precip. as snowfall.
</p>
</li>
<li> <p><code>SWE</code>: snow water equivalent.
</p>
</li>
<li> <p><code>Msnow</code>: melted snow.
</p>
</li>
<li> <p><code>Mice</code>: melted ice.
</p>
</li>
<li> <p><code>Mtot</code>: <code>Msnow</code> + <code>Mice</code>.
</p>
</li>
<li> <p><code>Cum</code>: <code>Psnow</code> - <code>Mtot</code>.
</p>
</li>
<li> <p><code>Total</code>: <code>Prain</code> + <code>Mtot</code>.
</p>
</li>
<li> <p><code>TotScal</code>: <code>Total</code> *  inputData[i, 3].
</p>
</li></ol>



<h3>References</h3>

<p>Bergström, S., Lindström, G., 2015. Interpretation of runoff processes in hydrological
modelling—experience from the HBV approach. Hydrol. Process. 29, 3535–3545.
https://doi.org/10.1002/hyp.10510
</p>
<p>DeWalle, D. R., &amp; Rango, A. (2008). Principles of Snow Hydrology.
</p>
<p>Parajka, J., Merz, R., Blöschl, G., 2007. Uncertainty and multiple objective calibration
in regional water balance modelling: case study in 320 Austrian catchments.
Hydrol. Process. 21, 435–446. https://doi.org/10.1002/hyp.6253
</p>
<p>Seibert, J., Vis, M.J.P., 2012. Teaching hydrological modeling with a user-friendly
catchment-runoff-model software package. Hydrol Earth Syst Sci 16, 3315–3325.
https://doi.org/10.5194/hess-16-3315-2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## Debris-covered ice
ObsTemp   &lt;- sin(x = seq(0, 10*pi, 0.1))
ObsPrecip &lt;- runif(n = 315, max = 50, min = 0)
ObsGCA    &lt;- seq(1, 0.8, -0.2/314)

## Fine debris covered layer assumed. Note that the ice-melt factor is cumpulsory but harmless.
DebrisCovGlac &lt;- SnowGlacier_HBV(model = 3,
                                 inputData = cbind(ObsTemp, ObsPrecip, ObsGCA),
                                 initCond = c(10, 3, 1),
                                 param = c(1, 1, 0, 3, 1, 6))

</code></pre>

<hr>
<h2 id='Soil_HBV'>Empirical soil moisture routine</h2><span id='topic+Soil_HBV'></span>

<h3>Description</h3>

<p>This module allows you to account for actual evapotranspiration,
abstractions, antecedent conditions and effective runoff. The formulation enables
non linear relationships between soil box water input (rainfall plus snowmelt) and
the effective runoff. This effective value is the input series to the routine function
(<code><a href="#topic+Routing_HBV">Routing_HBV</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Soil_HBV(
       model,
       inputData,
       initCond,
       param
       )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Soil_HBV_+3A_model">model</code></td>
<td>
<p>numeric integer suggesting one of the following options:
</p>

<ul>
<li><p> 1: Classical HBV soil moisture routine.
</p>
</li>
<li><p> 2: HBV soil moisture routine with varying area. This option should
be used with <code><a href="#topic+SnowGlacier_HBV">SnowGlacier_HBV</a></code>'s <strong><em>model 3</em></strong>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="Soil_HBV_+3A_inputdata">inputData</code></td>
<td>
<p>numeric matrix with the following series
</p>
<p><strong>Model 1</strong>
</p>

<ul>
<li> <p><code>column_1</code>: <code>Total = Prain + Msnow</code> <code class="reqn">[mm/\Delta t]</code>. This
series comes from the output of the <code><a href="#topic+SnowGlacier_HBV">SnowGlacier_HBV</a></code> module.
</p>
</li>
<li> <p><code>column_2</code>: potential evapotranspiration  <code class="reqn">[mm/\Delta t]</code>. Since
the package has a simple model (<code><a href="#topic+PET">PET</a></code>) to obtain this
series I strongly recommend using the
<a href="https://CRAN.R-project.org/package=Evapotranspiration"><code>Evapotranspiration</code></a>
package.
</p>
</li></ul>

<p><strong>Model 2</strong>
</p>

<ul>
<li> <p><code>column_1</code>: as in <strong>model 1</strong>.
</p>
</li>
<li> <p><code>column_2</code>: as in <strong>model 1</strong>.
</p>
</li>
<li> <p><code>column_3</code> : relative soil area (ratio of soil surface over
basin area). When the glacier area changes the soil does the same, so coherence
between this two series should be seek.This value is used to scale the effective
runoff accordingly (<code>Rech</code> column in the matrix output).
</p>
</li></ul>
</td></tr>
<tr><td><code id="Soil_HBV_+3A_initcond">initCond</code></td>
<td>
<p>numeric vector with the following values:
</p>

<ol>
<li><p> initial soil water content <code class="reqn">[mm]</code>. This is a model state variable
and is internally used as first soil moisture value.
</p>
</li>
<li><p> relative area <code class="reqn">[-]</code>. Only needed when using <strong><code>model 1</code></strong>.
This is the soil surface proportion relative to the catchment as a whole, so
the values should never supersede one (1). This value is used to scale the effective
runoff accordingly (<code>Rech</code> column in the matrix output).
</p>
</li></ol>
</td></tr>
<tr><td><code id="Soil_HBV_+3A_param">param</code></td>
<td>
<p>numeric vector with the following values:
</p>

<ol>
<li> <p><code>FC</code>: fictitious soil field capacity <code class="reqn">[mm]</code>.
</p>
</li>
<li> <p><code>LP</code>: parameter to get actual ET <code class="reqn">[-]</code>.
</p>
</li>
<li> <p><code class="reqn">\beta</code>: exponential value that allows for non-linear relations between
soil box water input (rainfall plus snowmelt) and the effective runoff <code class="reqn">[-]</code>.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with the following columns:
</p>

<ol>
<li> <p><code>Rech</code>: recharge series <code class="reqn">[mm/\Delta t]</code>. This is the input to
the <code><a href="#topic+Routing_HBV">Routing_HBV</a></code> module.
</p>
</li>
<li> <p><code>Eact</code>: actual evapotranspiration series <code class="reqn">[mm/\Delta t]</code>.
</p>
</li>
<li> <p><code>SM</code>: soil moisture series <code class="reqn">[mm/\Delta t]</code>.
</p>
</li></ol>



<h3>References</h3>

<p>Bergström, S., Lindström, G., 2015. Interpretation of runoff processes in hydrological
modelling—experience from the HBV approach. Hydrol. Process. 29, 3535–3545.
https://doi.org/10.1002/hyp.10510
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

# HBV soil routine with variable area
## Calder's model
potEvap &lt;- PET(model = 1, hemis = 1, inputData = as.matrix(1:315), elev = c(1000, 1500),
              param = c(4, 0.5))

## Debris-covered ice
 ObsTemp   &lt;- sin(x = seq(0, 10*pi, 0.1))
 ObsPrecip &lt;- runif(n = 315, max = 50, min = 0)
 ObsGCA    &lt;- seq(1, 0.8, -0.2/314)

## Fine debris covered layer assumed. Note that the ice-melt factor is cumpulsory but harmless.
DebrisCovGlac &lt;- SnowGlacier_HBV(model = 3, inputData = cbind(ObsTemp, ObsPrecip, ObsGCA),
                                 initCond = c(10, 3, 1), param = c(1, 1, 0, 3, 1, 6))

## Soil routine
ObsSoCA     &lt;- 1 - ObsGCA
inputMatrix &lt;- cbind(DebrisCovGlac[ , 9], potEvap, ObsSoCA)

soil &lt;- Soil_HBV(model = 2, inputData = inputMatrix, initCond = c(50), param = c(200, 0.5, 2))

</code></pre>

<hr>
<h2 id='Temp_model'>Altitude gradient base air temperature models</h2><span id='topic+Temp_model'></span>

<h3>Description</h3>

<p>Extrapolate air temperature records to another heights. In this package
version you can use the classical linear gradient model or a modified version which
sets an upper altitudinal threshold air temperature decrement (avoiding unreliable estimations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Temp_model(
       model,
       inputData,
       zmeteo,
       ztopo,
       param
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Temp_model_+3A_model">model</code></td>
<td>
<p>numeric value with model option:
</p>

<ul>
<li><p> 1: linear air temperature gradient (LT).
</p>
</li>
<li><p> 2: linear air temperature gradient with an upper threshold (LTM).
</p>
</li></ul>
</td></tr>
<tr><td><code id="Temp_model_+3A_inputdata">inputData</code></td>
<td>
<p>numeric vector with air temperature record series [ºC/<code class="reqn">\Delta t</code>].</p>
</td></tr>
<tr><td><code id="Temp_model_+3A_zmeteo">zmeteo</code></td>
<td>
<p>numeric value indicating the altitude where the air temperature is recorded
<code class="reqn">[masl]</code>.</p>
</td></tr>
<tr><td><code id="Temp_model_+3A_ztopo">ztopo</code></td>
<td>
<p>numeric value with the target height <code class="reqn">[masl]</code>.</p>
</td></tr>
<tr><td><code id="Temp_model_+3A_param">param</code></td>
<td>
<p>numeric vector with the following parameters:
</p>
<p><strong>LT</strong>
</p>

<ul>
<li><p> 1: air temperature linear gradient (<code>grad_t</code>) [ºC/km].
</p>
</li></ul>

<p><strong>LPM</strong>
</p>

<ul>
<li><p> 1: air temperature linear gradient (<code>grad_t</code>) [ºC/km].
</p>
</li>
<li><p> 2: threshold height. Air temperature does not decrease when the altitude (<code>ztopo</code>)
is higher than this value <code class="reqn">[masl]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the extrapolated air temperature series.
</p>


<h3>References</h3>

<p>Immerzeel, W.W., Petersen, L., Ragettli, S., Pellicciotti, F., 2014.
The importance of observed gradients of air temperature and precipitation for modeling
runoff from a glacierized watershed in the Nepalese Himalayas.
Water Resour. Res. 50, 2212–2226. https://doi.org/10.1002/2013WR014506
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## simple linear model
airTemp &lt;- Temp_model(
                      model = 1,
                      inputData = runif(200, max = 25, min = -10),
                      zmeteo = 2000, ztopo = 3500, param = c(-6.5)
                      )

</code></pre>

<hr>
<h2 id='tupungato_data'>Tupungato River basin data</h2><span id='topic+tupungato_data'></span>

<h3>Description</h3>

<p>A dataset containing a minimal information to simulate the streamflow  discharge
of the Tupungato catchment. The basin is located in the north of the Mendoza province
(Argentina - 32.90º S; 69.76º W) and has an area of about 1769 <code class="reqn">km^2</code>. This catchment is
the main tributary of the Mendoza River basin (~50 % of the annual discharge), a stream that
supplies with water to most of the province population (~64 %).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tupungato_data
</code></pre>


<h3>Format</h3>

<p>A list with four elements
</p>

<dl>
<dt>hydro_meteo</dt><dd><p>data frame with the air temperature, precipitation and streamflow (mean, lower and upper bounds) series.</p>
</dd>
<dt>snow_cover</dt><dd><p>data frame containing the snow cover (from MODIS) series for each elevation band.</p>
</dd>
<dt>topography</dt><dd><p>data frame with: elevation zone number, minimum, maximum and mean altitude
values for the elevation range and the relative area of each polygon.</p>
</dd>
<dt>station_height</dt><dd><p>numeric vector with the station (Toscas) height (in masl).</p>
</dd>
</dl>


<hr>
<h2 id='UH'>Transfer function</h2><span id='topic+UH'></span>

<h3>Description</h3>

<p>Use a triangular transfer function to adjust the timing of the
simulated streamflow discharge. This module represents the runoff routing in
the streams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UH(
  model,
  Qg,
  param
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UH_+3A_model">model</code></td>
<td>
<p>numeric integer with the transfer function model. The current HBV.IANIGLA
model only allows for a single option.
</p>

<ul>
<li><p> 1: triangular function with a static base.
</p>
</li></ul>
</td></tr>
<tr><td><code id="UH_+3A_qg">Qg</code></td>
<td>
<p>numeric vector with the water that gets into the stream.
If you are not modeling glaciers is the output of the
<code><a href="#topic+Routing_HBV">Routing_HBV</a></code> module, otherwise, is the sum of the <code><a href="#topic+Routing_HBV">Routing_HBV</a></code>
output plus the glacier discharge coming from the <code><a href="#topic+Glacier_Disch">Glacier_Disch</a></code> module.</p>
</td></tr>
<tr><td><code id="UH_+3A_param">param</code></td>
<td>
<p>numeric vector with the following values,
</p>
<p><strong>Model 1</strong>
</p>

<ul>
<li> <p><code>Bmax</code>: base of the transfer function triangle <code class="reqn">[timestep]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the simulated streamflow discharge.
</p>


<h3>References</h3>

<p>Bergström, S., Lindström, G., 2015. Interpretation of runoff processes in hydrological
modelling—experience from the HBV approach. Hydrol. Process.
29, 3535–3545. https://doi.org/10.1002/hyp.10510
</p>
<p>Parajka, J., Merz, R., &amp; Blöschl, G. (2007). Uncertainty and multiple objective
calibration in regional water balance modelling: Case study in 320 Austrian catchments.
Hydrological Processes, 21(4), 435-446. https://doi.org/10.1002/hyp.6253
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example. I strongly recommend to see
# the package vignettes in order to improve your skills on HBV.IANIGLA

## Routing example
inputMatrix &lt;- cbind(runif(n = 200, max = 100, min = 0), runif(n = 200, max = 50, min = 5),
                 runif(n = 100, max = 3, min = 1))

routeMod1   &lt;- Routing_HBV(model = 1, lake = TRUE, inputData = inputMatrix,
                         initCond = c(10, 15, 20), param = c(0.1, 0.05, 0.001, 1, 0.8))

## UH
dischOut &lt;- UH(model = 1, Qg = routeMod1[ , 1], param = 2.2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
