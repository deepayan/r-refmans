<!DOCTYPE html><html lang="en-US"><head><title>Help for package paleoAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paleoAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculateImplicitParameters'><p>Calculate Implicit Parameters for Modeling Time-Series of Fossil Assemblages</p></a></li>
<li><a href='#getProbOccViaPresAbs'><p>Estimate the Per-Species Probability of Occurrence as a Function of an Environmental Gradient from Presence-Absence Data</p></a></li>
<li><a href='#getRecoveredTransitionDuration'><p>Measure the Duration of a Transition Period from Recovered Sequence of Fossil Assemblages with DCA-1 Scores</p></a></li>
<li><a href='#getSampleDCA'><p>Get the Detrended correspondence Analysis (DCA) Score Value for A Single Sample</p></a></li>
<li><a href='#getSpeciesSpecificRescaledKDE'><p>This is a function for Fitting a KDE to a specific species in Community Ecology Data</p></a></li>
<li><a href='#getTimestepAbundances'><p>Simulate Fossil Assemblages with Abundances at each Time-Step</p></a></li>
<li><a href='#gulfOfAlaska'><p>Benthic Foram Abundances from the Gulf of Alaska Reported by Sharon et al 2021</p></a></li>
<li><a href='#hirnantian'><p>Katian-Hirnantian Graptolite Assemblages Reported by Sheets et al. (2016)</p></a></li>
<li><a href='#plotFossilAssemblageSeriesDCA'><p>Plot the Recovered DCA Values of a Fossil Assemblage Series</p></a></li>
<li><a href='#plotGradientKDE'><p>Plot Kernel Density Estimates of Species Abundance Across a Focal Gradient</p></a></li>
<li><a href='#plotHeatmapComparison'><p>Plots a Heatmap Comparison</p></a></li>
<li><a href='#sampleFossilSeries'><p>Sample Fossil Assemblage Series</p></a></li>
<li><a href='#setupSimulatedGradientChange'><p>Create a Stochastic Time-Series of Gradient Change For Use in Simulating Assemblage Change</p></a></li>
<li><a href='#simMixedAssemblageSample'><p>Simulate a Mixed Fossil Assemblage Composed of Communities at Different Gradient Values, and Sample the Lumped Assemblage</p></a></li>
<li><a href='#simulateFossilAssemblageSeries'><p>Simulate Time-Series of Successive Fossil Assemblages</p></a></li>
<li><a href='#simulateGradientQuantile'><p>Repeatedly Simulate Sampled Assemblages at some Gradient Value, and Return a Quantile Based on Recovered Gradient Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Assemblage Models of Abundance for the Fossil Record</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-16</td>
</tr>
<tr>
<td>Author:</td>
<td>David W Bapst [aut, cre],
  Christina L Belanger [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David W Bapst &lt;dwbapst@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, vegan</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for fitting abundance distributions over environmental gradients to the species in ecological communities, and tools for simulating the fossil assemblages from those abundance models for such communities, as well as simulating assemblages across various patterns of sedimentary history and sampling. These tools are for particular use with fossil records with detailed age models and abundance distributions used for calculating environmental gradients from ordinations or other indices based on fossil assemblages.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-16 19:22:50 UTC; dwbapst</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 16:20:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculateImplicitParameters'>Calculate Implicit Parameters for Modeling Time-Series of Fossil Assemblages</h2><span id='topic+calculateImplicitParameters'></span>

<h3>Description</h3>

<p>Given a sufficient set of parameters for simulating fossil assemblages 
as a time-series, this function calculates the full set of parameters
necessary for running each component model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateImplicitParameters(
  eventChangeScale,
  bgGradientValue,
  fullGradientRange,
  eventSampleWidthRatio = NULL,
  sampleWidth = NULL,
  eventDuration = NULL,
  sedRatePerTimestep = NULL,
  maxSampleTimeStep = 500,
  minSampleTimeStep = 3,
  samplingCompleteness,
  transitionDurationRatio,
  bioturbDepthRatio
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateImplicitParameters_+3A_eventchangescale">eventChangeScale</code></td>
<td>
<p>A value indicating the amount relative to 
the background value (<code>bgGradientValue</code>) and the maximum 
possible change as indicated by <code>fullGradientRange</code> 
(in other words, simulated change must be within observed gradient, 
so <code>eventChangeScale</code> is a proportional multiplier of 
the total possible change).</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_bggradientvalue">bgGradientValue</code></td>
<td>
<p>The gradient value expected during 
background intervals during which no notable excursion is 
occurring on that environmental gradient.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_fullgradientrange">fullGradientRange</code></td>
<td>
<p>A vector of two values giving the minimum 
and maximum gradient values observed in the empirical data.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_eventsamplewidthratio">eventSampleWidthRatio</code></td>
<td>
<p>How long should an event be relative 
to the amount of time (or sediment) captured within a sedimentary sample? 
This parameter is used for simulating event duration, 
sample width and sedimentation rate where any two of these three 
are defined and the third is not defined. 
This value is referred to as <em>Resolution Potential</em> 
in Belanger &amp; Bapst (2023).</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_samplewidth">sampleWidth</code></td>
<td>
<p>The 'width' of a sample relative to core depth 
or outcrop height, usually given in linear units (usually centimeters). 
For taking sediment samples from a core, this is straightforward 
(how thick is each sediment sample taken?) but for outcrops this 
may be more difficult to determine 
(what is the thickness of a horizon in a shale unit?).</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_eventduration">eventDuration</code></td>
<td>
<p>The duration (in time-units) of a 
simulated event during which the environmental gradient 
is at an excursion 'peak' level.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_sedratepertimestep">sedRatePerTimestep</code></td>
<td>
<p>The rate of sedimentation, given as a 
ratio of sediment thickness (given in linear dimensions, 
in the same units as <code>sampleWidth</code>), over time 
(given in the same time units as <code>eventDuration</code>.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_maxsampletimestep">maxSampleTimeStep</code></td>
<td>
<p>The maximum number of individual time-steps 
used for simulating a sample.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_minsampletimestep">minSampleTimeStep</code></td>
<td>
<p>The minimum number of individual time-steps 
used for simulating a sample.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_samplingcompleteness">samplingCompleteness</code></td>
<td>
<p>The relative completeness of stratigraphic 
sampling. For example, if two-centimeter wide samples of sediment are 
taken from a sediment core, every ten centimeters, then the 
<code>samplingCompleteness</code> is two over 10, or that
<code>samplingCompleteness = 1/5</code>. A simulation with a sampling 
completeness of 1 would be comparable to exhaustively sampling a 
core that recorded no gaps in sedimentation over its history. 
Rocky outcrops are more complicated, as fossil-bearing horizons 
may be relatively thin compared to the thickness of the section, 
such that outcrop-based fossil records should be simulated as 
having <em>very low</em> <code>samplingCompleteness</code>.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_transitiondurationratio">transitionDurationRatio</code></td>
<td>
<p>The ratio of how long the transition 
between peak and background intervals should be, relative to the 
length of the peak 'event' duration (<code>eventDuration</code>). 
The longer this transition interval, the more chances of 
an assemblage being sampled that represents transitional gradient values.</p>
</td></tr>
<tr><td><code id="calculateImplicitParameters_+3A_bioturbdepthratio">bioturbDepthRatio</code></td>
<td>
<p>The ratio of the sediment depth to which 
bioturbation occurs, made relative to the width of a 
sediment sample (<code>sampleWidth</code>). 
A <code>sampleWidth</code> of 3 cm and a <code>biotubDepthRatio</code> 
of 5 implies a bioturbation depth of 15 cm (<code>3 * 5</code>).  
Bioturbation depth varies considerably in the modern ocean, but is 
often the depth of active bioturbation is about 10 cm, such that the 
top ten centimeters of sediment 
(and the organic remains in those ten centimeters of sediment) 
are being regularly moved up and down by organism activity. 
For the purposes of this model, a bioturbation zone depth of 
10 centimeters means that sampling a centimeter of sediment 
at location X, the apparent fossil assemblage that would be 
recovered is just as likely to include specimens that were 
deposited five centimeters away as those deposited at location X.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the models considered in <code>paleoAM</code>, some parameterizations 
may be equivalent, even though the a particular analysis might 
be better simulated using a particular set of parameters. 
Allowing various different parameterizations is a useful 
generalization, but requires translating those equivalent parameters 
from one set to another (e.g. specifying parameters A, C &amp; D, 
but running a simulation that requires parameters A, B &amp; C).
</p>
<p>This function mainly exists to calculate unspecified parameters 
for <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code> and also to 
identify conflicting parameter specifications.
</p>


<h3>Value</h3>

<p>Returns a list giving the full set of parameters necessary for running <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>


<h3>References</h3>

<p>Belanger, Christina L., and David W. Bapst. 2023.
&quot;Simulating our ability to accurately detect abrupt 
changes in assemblage-based paleoenvironmental proxies.&quot; 
Palaeontologia Electronica 26 (2), 1-32
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>
</p>

<hr>
<h2 id='getProbOccViaPresAbs'>Estimate the Per-Species Probability of Occurrence as a Function of an Environmental Gradient from Presence-Absence Data</h2><span id='topic+getProbOccViaPresAbs'></span>

<h3>Description</h3>

<p>This function calculates how species presence (not abundance) varies as a function of an underlying environmental gradient, using only the pattern of presence-absence observed in a given data set (usually data on species abundance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProbOccViaPresAbs(
  origAbundData,
  gradientOrigDCA,
  occurrenceFloor = 0,
  nBreaksGradientHist = 20
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getProbOccViaPresAbs_+3A_origabunddata">origAbundData</code></td>
<td>
<p>The abundance data of the data you wish to model the abundance of.</p>
</td></tr>
<tr><td><code id="getProbOccViaPresAbs_+3A_gradientorigdca">gradientOrigDCA</code></td>
<td>
<p>The environmental gradient along which abundance 
varies, which you are fitting a KDE to.</p>
</td></tr>
<tr><td><code id="getProbOccViaPresAbs_+3A_occurrencefloor">occurrenceFloor</code></td>
<td>
<p>The minimum occurrence for every species, in every bin. 
The default is zero &ndash; increasing this value means every species has a 
non-zero chance of occurring in every bin, which tends to result in wildly 
more diverse assemblages than what is observed in the fossil record, so use with caution.</p>
</td></tr>
<tr><td><code id="getProbOccViaPresAbs_+3A_nbreaksgradienthist">nBreaksGradientHist</code></td>
<td>
<p>The default is 20. Twenty what they asked? Twenty something.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rationale for this function was that simulating assemblages using the KDEs of species abundance alone (calculated with <code>getSpeciesSpecificRescaledKDE</code> tended to create very diversity-high assemblages that did not reflect reality. Accounting for species presence at all using separate models brings simulated assemblages much closer to real assemblages.
</p>


<h3>Value</h3>

<p>An approximate function, created with <code>approx</code> that describes the 
relationship between gradient and probability of occurrence for all species.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data(gulfOfAlaska)

alaskaProbOccur &lt;- getProbOccViaPresAbs(
   gradientOrigDCA = DCA1_GOA, 
   origAbundData = abundData_GOA
   )

</code></pre>

<hr>
<h2 id='getRecoveredTransitionDuration'>Measure the Duration of a Transition Period from Recovered Sequence of Fossil Assemblages with DCA-1 Scores</h2><span id='topic+getRecoveredTransitionDuration'></span>

<h3>Description</h3>

<p>How long did a transition proceed from background to peak 'event' v
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRecoveredTransitionDuration(
  simRecord,
  bgUpperEnvelope,
  eventLowerEnvelope = NULL,
  returnAsAge = FALSE,
  trueEventDuration = NA,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRecoveredTransitionDuration_+3A_simrecord">simRecord</code></td>
<td>
<p>A simulated fossil record with assemblage change across multiple time-steps, with sedimentary thickness modeled.</p>
</td></tr>
<tr><td><code id="getRecoveredTransitionDuration_+3A_bgupperenvelope">bgUpperEnvelope</code></td>
<td>
<p>The upper envelope on what is considered a background value for a gradient value derived from the assemblage.</p>
</td></tr>
<tr><td><code id="getRecoveredTransitionDuration_+3A_eventlowerenvelope">eventLowerEnvelope</code></td>
<td>
<p>The lower envelope on what is considered an event value for a gradient value derived from the assemblage.</p>
</td></tr>
<tr><td><code id="getRecoveredTransitionDuration_+3A_returnasage">returnAsAge</code></td>
<td>
<p>Should the estimated duration of the transition be returned as a duration in time-units? If <code>FALSE</code> (the default), the value is instead returned as a ratio relative to the true event duration.</p>
</td></tr>
<tr><td><code id="getRecoveredTransitionDuration_+3A_trueeventduration">trueEventDuration</code></td>
<td>
<p>The true duration of the event. This must be provided by the user if <code>returnAsAge = TRUE</code> to calculate the duration of the transition interval in simulation time-units.</p>
</td></tr>
<tr><td><code id="getRecoveredTransitionDuration_+3A_plot">plot</code></td>
<td>
<p>Should the data be plotted with the estimated transition interval on it, for visual checking?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The envelope values can be calculated different ways, or even picked arbitrarily by the user. For example, <code>bgUpperEnvelope</code> is the upper envelope on what is considered a background value for a gradient value derived from the assemblage (for example, an ordination score). One way a user could calculate <code>bgUpperEnvelope</code> would be to repeatedly simulate assemblages at the background value, calculate their apparent gradient value and estimate a 0.95 or 0.975 quantile. This can be done easily with function <code><a href="#topic+simulateGradientQuantile">simulateGradientQuantile</a></code>.
</p>


<h3>Value</h3>

<p>A single value, reflecting (by default) a ratio of transition duration over the event duration. Can be modified with argument <code>returnAsAge</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateGradientQuantile">simulateGradientQuantile</a></code>
</p>

<hr>
<h2 id='getSampleDCA'>Get the Detrended correspondence Analysis (DCA) Score Value for A Single Sample</h2><span id='topic+getSampleDCA'></span>

<h3>Description</h3>

<p>For a single simulated assemblage sample, projects its location in DCA space defined by the original abundance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleDCA(
  simSample,
  origAbundData,
  useTransformedRelAbundance = TRUE,
  projectIntoOrigDCA = TRUE,
  returnDCAforOrigAndSim = FALSE,
  whichAxes = 1,
  powerRootTransform = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSampleDCA_+3A_simsample">simSample</code></td>
<td>
<p>The assemblage data for a single sample (presumably from a simulation).</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_origabunddata">origAbundData</code></td>
<td>
<p>The original matrix of abundance data, to be used to
project the simulated data into the same detrended correspondence analysis (DCA) space.</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_usetransformedrelabundance">useTransformedRelAbundance</code></td>
<td>
<p>Should the DCA be analyzed</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_projectintoorigdca">projectIntoOrigDCA</code></td>
<td>
<p>Should the new simulated data be projected in the DCA generated by analyzing the original data? This is <code>TRUE</code> by default, which is what most users will likely use, as it is the preferable way to consider how the new simulated data relates to the original data.</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_returndcafororigandsim">returnDCAforOrigAndSim</code></td>
<td>
<p>Should the DCA score values for both the new simulated data and the original abundance data be returned? Default is <code>FALSE</code> as projecting the new data into the original DCA space means the original data should never be meaningfully different the original score values.</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_whichaxes">whichAxes</code></td>
<td>
<p>Which dimensional score from the DCA should be used? By default this is 1. Unclear under what circumstances one would ever use a value other than 1, though, as detrending the correspondence analysis causes distortion along all scores other than the first axis of the ordination. Only the first score can be returned when <code>projectIntoOrigDCA = TRUE</code>.</p>
</td></tr>
<tr><td><code id="getSampleDCA_+3A_powerroottransform">powerRootTransform</code></td>
<td>
<p>The power-root transform to be used on the abundance data before applying the DCA. By default this is 1, which means the data is not transformed at all. Note that the power-root transform is only performed if <code>useTransformedRelAbundance = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Detrended correspondence analysis (DCA) is a common method 
for producing an ordination of ecological data. 
It isn't the only such method.
</p>


<h3>Value</h3>

<p>A vector, containing either a single value, the DCA score value of the simulated sample, when <code>returnDCAforOrigAndSim = FALSE</code>, or a vector of the DCA scores for the original data and
</p>


<h3>See Also</h3>

<p>This function is ultimately just a wrapper for using <code>decorana</code> in package <code>vegan</code>.
</p>

<hr>
<h2 id='getSpeciesSpecificRescaledKDE'>This is a function for Fitting a KDE to a specific species in Community Ecology Data</h2><span id='topic+getSpeciesSpecificRescaledKDE'></span>

<h3>Description</h3>

<p>This function fits a KDE to the abundance data of a particular species from 
community data given some ecological gradient variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpeciesSpecificRescaledKDE(
  gradientOrigDCA,
  origAbundData,
  abundanceFloorRatio = 0.5,
  nBreaksGradientHist = 20,
  modeledSiteAbundance = 10000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSpeciesSpecificRescaledKDE_+3A_gradientorigdca">gradientOrigDCA</code></td>
<td>
<p>The environmental gradient along which abundance 
varies, which you are fitting a KDE to.</p>
</td></tr>
<tr><td><code id="getSpeciesSpecificRescaledKDE_+3A_origabunddata">origAbundData</code></td>
<td>
<p>The abundance data of the data you wish to model the abundance of.</p>
</td></tr>
<tr><td><code id="getSpeciesSpecificRescaledKDE_+3A_abundancefloorratio">abundanceFloorRatio</code></td>
<td>
<p>The minimum value for the abundance in a given 
interval along the gradient &ndash; a probably arbitration value that is set to 0.5 by default.</p>
</td></tr>
<tr><td><code id="getSpeciesSpecificRescaledKDE_+3A_nbreaksgradienthist">nBreaksGradientHist</code></td>
<td>
<p>The default is 20. Twenty what they asked? Twenty something.</p>
</td></tr>
<tr><td><code id="getSpeciesSpecificRescaledKDE_+3A_modeledsiteabundance">modeledSiteAbundance</code></td>
<td>
<p>The number of abundances the relative abundances 
will by multiplied by to formulate the KDE. The default is 10000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many ways, this is an attempt to measure empirical representations of
the abundance response curves relative to environmental gradients,
as portrayed in figure within Patzkowsky &amp; Holland (2012).
</p>
<p>The ecological gradient variable is often an environmental gradient, 
such as depth, oxygenation, altitude, precipitation, 
but this is not necessarily so.
</p>


<h3>Value</h3>

<p>A list containing the KDEs describing change in abundance for 
each species across the specified gradient.
</p>


<h3>References</h3>

<p>Patzkowsky, M.E. and Holland, S.M., 2012. <em>Stratigraphic Paleobiology: 
Understanding the Distribution of Fossil Taxa in Time and Space.</em>
University of Chicago Press. 259 pages.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getProbOccViaPresAbs">getProbOccViaPresAbs</a></code>, <code><a href="#topic+plotGradientKDE">plotGradientKDE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data(gulfOfAlaska)

alaskaKDEs &lt;- getSpeciesSpecificRescaledKDE(
    gradientOrigDCA = DCA1_GOA, 
    origAbundData = abundData_GOA, 
    abundanceFloorRatio = 0.5, 
    nBreaksGradientHist = 20, 
    modeledSiteAbundance = 10000
    )
    
plotGradientKDE(
    speciesKDEs = alaskaKDEs,
    fullGradientRange = c(min(DCA1_GOA), max(DCA1_GOA))
    )

</code></pre>

<hr>
<h2 id='getTimestepAbundances'>Simulate Fossil Assemblages with Abundances at each Time-Step</h2><span id='topic+getTimestepAbundances'></span>

<h3>Description</h3>

<p>Given a set of KDEs fit to species abundance and models of species occurrence relative to an environmental gradient, and given a sequence of gradient values, and a number of specimens to sample at each time-step, obtains a matrix containing abundances for species as a series of simulated assemblages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimestepAbundances(
  kdeRescaled,
  probSpeciesOccur,
  gradientValues,
  specimensPerTimestep
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTimestepAbundances_+3A_kderescaled">kdeRescaled</code></td>
<td>
<p>The list of modeled KDEs for species abundance, output from <code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>.</p>
</td></tr>
<tr><td><code id="getTimestepAbundances_+3A_probspeciesoccur">probSpeciesOccur</code></td>
<td>
<p>The output from <code><a href="#topic+getProbOccViaPresAbs">getProbOccViaPresAbs</a></code></p>
</td></tr>
<tr><td><code id="getTimestepAbundances_+3A_gradientvalues">gradientValues</code></td>
<td>
<p>A vector of gradient values to simulate over. A separate 'true' assemblage / community will be simulated for each value in the respective vector.</p>
</td></tr>
<tr><td><code id="getTimestepAbundances_+3A_specimenspertimestep">specimensPerTimestep</code></td>
<td>
<p>The number of specimens returned in a given time-step by <code>getTimestepAbundances</code>, usually set to an unrealistically high number to represent the true 'unsampled' fossil assemblage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getTimestepAbundances</code> represents simulating the original biotic community that was present at some given point in time, which is not the same thing as a fossil assemblage that might be collected from sediments today as finite samples. That is covered by feeding the output from this function to <code>sampleFossilSeries</code>.
</p>
<p>Thus, this function is generally run before running <code><a href="#topic+sampleFossilSeries">sampleFossilSeries</a></code>, 
however most users will likely never run either function, 
instead running <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>


<h3>Value</h3>

<p>A matrix containing abundances for species as a series of simulated assemblages.
</p>


<h3>See Also</h3>

<p>This function is generally run before running <code><a href="#topic+sampleFossilSeries">sampleFossilSeries</a></code>. 
Most users will likely never run either function, instead running <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>

<hr>
<h2 id='gulfOfAlaska'>Benthic Foram Abundances from the Gulf of Alaska Reported by Sharon et al 2021</h2><span id='topic+gulfOfAlaska'></span><span id='topic+fullDataTable_GOA'></span><span id='topic+DCA1_GOA'></span><span id='topic+abundData_GOA'></span>

<h3>Description</h3>

<p>Loads the foraminifera abundances collected and published by Sharon et al. (2021),
as used in the simulation analyses published in Belanger and Bapst (2023).
</p>


<h3>Format</h3>

<p>This data set is composed of three objects: 
</p>

<dl>
<dt>fullDataTable_GOA</dt><dd><p>The full data table containing sample IDs, DCA-1
scores and species abundances.</p>
</dd>
<dt>DCA1_GOA</dt><dd><p>A vector of just the DCA-1 scores for each sample.</p>
</dd>
<dt>abundData_GOA</dt><dd><p>The number of specimens identified as a particular
species for each sample.</p>
</dd></dl>



<h3>Details</h3>

<p>This data set contains the absolute abundances (number of specimens identified)
for 48 species of benthic foraminifera, across 355 samples, taken from Sharon 
et al (2021). These samples were collected from the less than 63 micrometer size-fractions
taken from Integrated Ocean Drilling Program Expedition 341 Site U141 and the 
co-located jumbo piston core, respectively located at 697 meters and 682 meters
water depth in the Gulf of Alaska (Jaeger et al., 2014).
</p>


<h3>Source</h3>

<p>Belanger, Christina L., and David W. Bapst. 2023.
&quot;Simulating our ability to accurately detect abrupt 
changes in assemblage-based paleoenvironmental proxies.&quot; 
Palaeontologia Electronica 26 (2), 1-32
</p>
<p>Jaeger, J.M., Gulick, S.P.S., LeVay, L.J., Asahi, H., Bahlburg, H., 
Belanger, C.L., Berbel, G.B.B., Childress, L.B., Cowan, E.A., Drab, L., 
Forwick, M., Fukumura, A., Ge, S., Gupta, S.M., Kioka, A., Konno, S., 
März, C.E., Matsuzaki, K.M., McClymont, E.L., Mix, A.C., Moy, C.M., 
Müller, J., Nakamura, A., Ojima, T., Ridgway, K.D., Rodrigues Ribeiro, F., 
Romero, O.E., Slagle, A.L., Stoner, J.S., St-Onge, G., Suto, I., 
Walczak, M.H., and Worthington, L.L., 2014. Expedition 341 summary. 
In Jaeger, J.M., Gulick, S.P.S., LeVay, L.J., and the 
Expedition 341 Scientists, Proceedings of IODP, 341: College Station, TX 
(Integrated Ocean Drilling Program). 
</p>
<p>Sharon, Christina Belanger, Jianghui Du, and Alan Mix. 
&quot;Reconstructing paleo‐oxygenation for the last 54,000 years in the 
Gulf of Alaska using cross‐validated benthic foraminiferal and 
geochemical records.&quot; Paleoceanography and Paleoclimatology 
36, no. 2 (2021): e2020PA003986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hirnantian">hirnantian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gulfOfAlaska)

########################
# (This is not to be run, just showing how data was loaded)
#
# # Loading the data files used by Belanger &amp; Bapst 2023
#     # taken from Sharon et al. supplemental
# fullDataTable_GOA &lt;- read.table(
#    "foram_abundances_forSimulations.txt",
#    header = TRUE)
# 
# DCA1_GOA &lt;- fullDataTable_GOA$DCA1
# abundData_GOA &lt;- fullDataTable_GOA[,-(1:5)]
#
# save(fullDataTable_GOA, DCA1_GOA, abundData_GOA, 
#    file = "data/gulfOfAlaska.Rdata")


</code></pre>

<hr>
<h2 id='hirnantian'>Katian-Hirnantian Graptolite Assemblages Reported by Sheets et al. (2016)</h2><span id='topic+hirnantian'></span><span id='topic+graptCommData'></span><span id='topic+graptSampleInfo'></span>

<h3>Description</h3>

<p>This is a data set of relative abundances for planktonic graptolite species 
from two sections that cross the Katian-Hirnantian boundary in the late Paleozoic.
</p>


<h3>Format</h3>

<p>This dataset is composed of two objects: 
</p>

<dl>
<dt>graptCommData</dt><dd><p>A data table of sample IDs and
relative species abundances.</p>
</dd>
<dt>graptSampleInfo</dt><dd><p>A data table of additional locality and geologic age
information related to each sample.</p>
</dd></dl>



<h3>Details</h3>

<p>This data set contains the relative abundances 
(proportion of specimens identified)
for 43 species of planktonic graptolites, 
across 34 samples taken from two outcrops: 
(a) a section at Vininni Creek in Nevada, USA, and 
(b) a second section at Blackstone River in the Yukon, Canada. 
Both of these sections cross the Katian-Hirnantian boundary and the
relative abundances reported here were provided as supplementary material
with Sheets et al. (2016).
</p>


<h3>Source</h3>

<p>Sheets, H. David, Charles E. Mitchell, Michael J. Melchin, Jason Loxton, 
Petr Štorch, Kristi L. Carlucci, and Andrew D. Hawkins. 
&quot;Graptolite community responses to global climate change and 
the Late Ordovician mass extinction.&quot; Proceedings of the National 
Academy of Sciences 113, no. 30 (2016): 8380-8385.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gulfOfAlaska">gulfOfAlaska</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hirnantian)

########################
# # (This is not to be run, just showing how data was loaded)
#  
# # Sheets et al. community abundance data
# graptCommData &lt;- read.csv(
#    "grapt_abundances_Sheets_et_al_Vinini&amp;Blackstone_01-09-22.csv"
#    , row.names = 1, header = TRUE
#    )
#
# # sample specific info
# graptSampleInfo &lt;- read.csv(
#    "grapt_siteData_SheetsEtAl.csv",
#    row.names = 1, header = TRUE, 
#    stringsAsFactors = TRUE
#    )  
#
# save(graptCommData, graptSampleInfo, 
#    file = "data/hirnantian.Rdata")

</code></pre>

<hr>
<h2 id='plotFossilAssemblageSeriesDCA'>Plot the Recovered DCA Values of a Fossil Assemblage Series</h2><span id='topic+plotFossilAssemblageSeriesDCA'></span>

<h3>Description</h3>

<p>Makes a plot of the simulated generating gradient over time along with the
recovered gradient values in the same plot for a given simulated time series 
of fossil assemblages, particularly those from
<code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFossilAssemblageSeriesDCA(
  ...,
  colSimGenerating = "black",
  colSimRecovered = "navy"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotFossilAssemblageSeriesDCA_+3A_...">...</code></td>
<td>
<p>This function takes either the output from 
<code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code> or requires specifying 
the three arguments <code>simTimeVar</code>, a data-frame of time-steps, 
sedimentary width and gradient values for a time-series simulation); 
<code>gradientRecovered</code>, the recovered gradient values; and
<code>sampleAge</code>, the age of individual samples.</p>
</td></tr>
<tr><td><code id="plotFossilAssemblageSeriesDCA_+3A_colsimgenerating">colSimGenerating</code></td>
<td>
<p>What color should be used for the generating 
(&quot;true&quot;) gradient values?</p>
</td></tr>
<tr><td><code id="plotFossilAssemblageSeriesDCA_+3A_colsimrecovered">colSimRecovered</code></td>
<td>
<p>What color should be used for the recovered 
gradient values calculated from the simulated data?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will generally only be run on the output 
from <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>, although the function is 
written so that the necessary elements can be provided separately.
</p>


<h3>Value</h3>

<p>Returns nothing at all. Just a plot. That's all!
</p>

<hr>
<h2 id='plotGradientKDE'>Plot Kernel Density Estimates of Species Abundance Across a Focal Gradient</h2><span id='topic+plotGradientKDE'></span>

<h3>Description</h3>

<p>This function plots each rescaled KDE fit to each specific-specific 
rise-and-fall in abundance across some ecological gradient variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGradientKDE(
  speciesKDEs,
  fullGradientRange,
  xlim = NULL,
  ylim = c(0, 1),
  logY = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGradientKDE_+3A_specieskdes">speciesKDEs</code></td>
<td>
<p>A list of rescaled-KDE data, where each element is a 
different species, such as that output by <code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>.</p>
</td></tr>
<tr><td><code id="plotGradientKDE_+3A_fullgradientrange">fullGradientRange</code></td>
<td>
<p>The minimum and maximum value of the ecological 
gradient variable at which ecological assemblage data was observed. 
If <code>xlim</code> isn't given, this defines the horizontal axis limits for resulting plot.</p>
</td></tr>
<tr><td><code id="plotGradientKDE_+3A_xlim">xlim</code>, <code id="plotGradientKDE_+3A_ylim">ylim</code></td>
<td>
<p>Vectors of two elements, defining the minimum and maximum 
values for the horizontal (x) axis and vertical (y) axis, respectively. 
The default for <code>xlim</code> is <code>NULL</code> and only needs to be defined 
if different axis limits than <code>fullGradientRange</code> is desired. 
The default for <code>ylim</code> is <code>c(0,1)</code> which likely leaves considerable
empty white space above the KDEs, which can be reduced by adjusting this argument.</p>
</td></tr>
<tr><td><code id="plotGradientKDE_+3A_logy">logY</code></td>
<td>
<p>Should the vertical axis (the relative height of rescaled KDEs) 
be portrayed with logarithmic scaling?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many ways, this is an attempt to create empirical versions of the the
hypothetical figures portraying abundance response curves 
relative to an environmental gradient in Patzkowsky &amp; Holland (2012).
</p>
<p>The ecological gradient variable is often an environmental characteristic, 
such as depth, oxygenation, altitude, precipitation, 
but this is not necessarily so.
</p>


<h3>Value</h3>

<p>Nothing is returned, just a plot is made.
</p>


<h3>References</h3>

<p>Patzkowsky, M.E. and Holland, S.M., 2012. <em>Stratigraphic Paleobiology: 
Understanding the Distribution of Fossil Taxa in Time and Space.</em>
University of Chicago Press. 259 pages.
</p>


<h3>See Also</h3>

<p>This function mainly exists to look at the output from 
<code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code> for a fossil assemblage.
</p>

<hr>
<h2 id='plotHeatmapComparison'>Plots a Heatmap Comparison</h2><span id='topic+plotHeatmapComparison'></span>

<h3>Description</h3>

<p>This function is a complex wrapper of the functions <code>contour</code> and <code>filled.contour</code> which allows a user to combine colored contours for the surface of a third variables plotted across a two-dimensional space, with contour lines of the third variable's surface also plotted in that same two-dimensional space. This is often a common plotting need for this package, and thus is included here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeatmapComparison(
  x,
  y,
  z,
  xlim = range(x, finite = TRUE),
  ylim = range(y, finite = TRUE),
  zlim = range(z, finite = TRUE),
  xlog = FALSE,
  ylog = FALSE,
  xtick = pretty(x),
  ytick = pretty(y),
  contourLevels = NULL,
  nlevels = 10,
  contourLineLevels = NULL,
  contour.lwd = 2,
  additionalFeatures = NULL,
  palette = "plasma",
  xlab = "x",
  ylab = "y",
  main = "main title",
  gradientKeyLabel = "color gradient key",
  mtext_line = 3,
  margins = c(5, 6, 5, 5)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHeatmapComparison_+3A_x">x</code>, <code id="plotHeatmapComparison_+3A_y">y</code></td>
<td>
<p>The horizontal (<code>x</code>) and vertical (<code>y</code>) variables that determine the two-dimensional space within which the third variable (<code>z</code>) is plotted as a surface.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_z">z</code></td>
<td>
<p>The values of the third variable (<code>z</code>) that will be used to define the plotted surface for contours, given as a matrix with the same number of rows as the length of <code>x</code>, and the same number of columns as the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_xlim">xlim</code>, <code id="plotHeatmapComparison_+3A_ylim">ylim</code>, <code id="plotHeatmapComparison_+3A_zlim">zlim</code></td>
<td>
<p>These are two-element vectors giving the minimum and maximum limits for the horizontal variable (<code>x</code>), vertical variable (<code>y</code>), and the variable defining the surface plotted (<code>z</code>) within the two dimensional space defined by <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_xlog">xlog</code>, <code id="plotHeatmapComparison_+3A_ylog">ylog</code></td>
<td>
<p>Should the <code>x</code> or <code>y</code> axes be displayed with log-scaling?</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_xtick">xtick</code>, <code id="plotHeatmapComparison_+3A_ytick">ytick</code></td>
<td>
<p>Vectors that give the positions of the tick-marks for <code>x</code> and <code>y</code> axes.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_contourlevels">contourLevels</code></td>
<td>
<p>A vector of values at which to put the breaks between the color-filled contours for <code>z</code>, Also determines the
different levels show on the color-gradient key shown to the side of the contour plot.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_nlevels">nlevels</code></td>
<td>
<p>The number of different color levels to use, if <code>contourLevels</code> is not defined.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_contourlinelevels">contourLineLevels</code></td>
<td>
<p>A vector of values at which to put the distinct contour lines for <code>z</code>. This must be defined for contour lines to be plotted.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_contour.lwd">contour.lwd</code></td>
<td>
<p>The thickness of plotted contour lines.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_additionalfeatures">additionalFeatures</code></td>
<td>
<p>Additional features to add to the contour space, such as</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_palette">palette</code></td>
<td>
<p>The color palette to use for <code>filled.contour</code>. By default, the palette <code>"plasma"</code> is used.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_xlab">xlab</code>, <code id="plotHeatmapComparison_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the <code>x</code> and <code>y</code> axes.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_main">main</code></td>
<td>
<p>The plot's main title.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_gradientkeylabel">gradientKeyLabel</code></td>
<td>
<p>The optional label text for the color gradient key for <code>z</code>, shown to the right of the main contour plot. This label will be shown to the right of the key.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_mtext_line">mtext_line</code></td>
<td>
<p>The distant in the margin away from the key at which the <code>gradientKeyLabel</code> is displayed. The default value is 3.</p>
</td></tr>
<tr><td><code id="plotHeatmapComparison_+3A_margins">margins</code></td>
<td>
<p>The size of the margins for the result plot. The default configuration gives some extra room on the left-hand size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>filled.contour</code> doesn't easy allow for sequential modifications, like adding additional contour lines to an existing contour plot, and so this function simplifies having to write the second <code>contour</code> plot as an argument for <code>plot.axes</code> in <code>filled.contour</code>.
</p>


<h3>Value</h3>

<p>This function returns nothing at all as output. It just makes a plot.
</p>

<hr>
<h2 id='sampleFossilSeries'>Sample Fossil Assemblage Series</h2><span id='topic+sampleFossilSeries'></span>

<h3>Description</h3>

<p>Given a time-series of 'true' fossil assemblages simulated in precise time,
this function then chunks that 'true' ecological signal into sedimentary
packages, which contain specimens from assemblages spanning the time interval
during which that sediment accumulated. Further more, the inclusion of 
specimens from even more distant assemblages is used to model bioturbation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleFossilSeries(
  bioturbIntensity,
  bioturbZoneDepth,
  distBetweenSamples,
  sampleWidth,
  simTimeVar,
  timestepAbundances,
  nSpecimens
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleFossilSeries_+3A_bioturbintensity">bioturbIntensity</code></td>
<td>
<p>The degree of mixing within the bioturbation zone, as a value between 0 and 1. When intensity is 1, a given sample will consist only</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_bioturbzonedepth">bioturbZoneDepth</code></td>
<td>
<p>The sediment depth to which bioturbation occurs. For example, Bioturbation depth varies considerably in the modern ocean, but is often around 10 centimeters &ndash; with the top ten centimeters of sediment (and the organic remains in those ten centimeters of sediment) being regularly moved up and down by organism activity. For the purposes of this model, a bioturbation zone depth of 10 centimeters means that sampling a centimeter of sediment at location X, the apparent fossil assemblage that would be recovered is just as likely to include specimens that were deposited five centimeters away as those deposited at location X.</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_distbetweensamples">distBetweenSamples</code></td>
<td>
<p>The sedimentary thickness between successive 
samples, in the same units as <code>sampleWidth</code>.</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_samplewidth">sampleWidth</code></td>
<td>
<p>The 'width' of a sample relative to core depth 
or outcrop height, usually given in linear units (usually centimeters). 
For taking sediment samples from a core, this is straightforward 
(how thick is each sediment sample taken?) but for outcrops this 
may be more difficult to determine 
(what is the thickness of a horizon in a shale unit?).</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_simtimevar">simTimeVar</code></td>
<td>
<p>A data-frame specifying time-steps, sedimentary depth and environmental gradient values for simulating a time-series of sampled fossil assemblages.</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_timestepabundances">timestepAbundances</code></td>
<td>
<p>A matrix containing abundances for species as a series of simulated assemblages, output by <code><a href="#topic+getTimestepAbundances">getTimestepAbundances</a></code>.</p>
</td></tr>
<tr><td><code id="sampleFossilSeries_+3A_nspecimens">nSpecimens</code></td>
<td>
<p>The number of specimens selected in each individual sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is where bioturbation processes are handled, 
as well as time-averaging from samples capturing several 
sedimentary horizons reflecting multiple original fossil assemblages.
</p>
<p>This function is generally run after running <code><a href="#topic+getTimestepAbundances">getTimestepAbundances</a></code>. 
Most users will likely never run either function, instead running
<code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>


<h3>Value</h3>

<p>A list composed of four components:
<code>simTimeVar</code>, the input data-frame specifying time-steps, sedimentary depth and environmental gradient values;
<code>abundanceTable</code>, a table of the abundances of species in each sample;
<code>sampleIntervals</code>, a table specifying when in time each sample 'begins' and 'ends' in time (based on the sedimentation rate),
and <code>bioturbIntervals</code>, a table specifying which intervals are 'included' in a sample
</p>


<h3>See Also</h3>

<p>This function is generally run after running
<code><a href="#topic+getTimestepAbundances">getTimestepAbundances</a></code>. Most users will likely never run either function, instead running <code><a href="#topic+simulateFossilAssemblageSeries">simulateFossilAssemblageSeries</a></code>.
</p>

<hr>
<h2 id='setupSimulatedGradientChange'>Create a Stochastic Time-Series of Gradient Change For Use in Simulating Assemblage Change</h2><span id='topic+setupSimulatedGradientChange'></span>

<h3>Description</h3>

<p>Given a series of inputs, simulates a sequence of gradient change 
against time for use in testing how environmental change alters 
the recovered sequence of fossil assemblages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupSimulatedGradientChange(
  nEvents,
  peakGradientValue,
  bgGradientValue,
  bgDurationRange,
  transitionDuration,
  eventDuration,
  halfGradientOnly = FALSE,
  includeInitialBackgroundPhase = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setupSimulatedGradientChange_+3A_nevents">nEvents</code></td>
<td>
<p>Number of events to occur in a simulated sequence 
of gradient change.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_peakgradientvalue">peakGradientValue</code></td>
<td>
<p>The gradient value at the 'peak' for 
an event that represents an excursion on that environmental gradient.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_bggradientvalue">bgGradientValue</code></td>
<td>
<p>The gradient value expected during 
background intervals during which no notable excursion is 
occurring on that environmental gradient.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_bgdurationrange">bgDurationRange</code></td>
<td>
<p>A vector of two values, representing the 
minimum and maximum duration (in time units) of a 
background interval between successive events.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_transitionduration">transitionDuration</code></td>
<td>
<p>How long the transition between peak and 
background intervals should be. The longer this interval, 
the more chances of an assemblage being sampled that 
represents transitional gradient values.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_eventduration">eventDuration</code></td>
<td>
<p>The duration (in time-units) of a 
simulated event during which the environmental gradient 
is at an excursion 'peak' level.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_halfgradientonly">halfGradientOnly</code></td>
<td>
<p>Whether to simulate only half of 
a background-event sequence, either beginning or terminating 
the simulation at the peak value. 
Only a single event can be simulated, so <code>nEvents</code> must be 1. 
The default is <code>FALSE</code> which signals to not simulated a half-gradient.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_includeinitialbackgroundphase">includeInitialBackgroundPhase</code></td>
<td>
<p>A logical indicating whether 
to include a lengthy background phase, for use in calibrating a simulation. 
This function is mainly for diagnostic purposes 
and may be removed in future updates.</p>
</td></tr>
<tr><td><code id="setupSimulatedGradientChange_+3A_plot">plot</code></td>
<td>
<p>Should the simulated gradient be shown as a plot?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is rather complicated and was written at a time 
when it was envisioned that simulations would involve time series 
of many repeated events with varying background intervals 
between them, rather than simulated sequences having only one event. 
In practice, use of paleoAM has tended to find the latter to be more useful.
</p>


<h3>Value</h3>

<p>A list with five components: 
<code>simGradient</code>, a data frame giving the change in gradient values over time; 
<code>approxGradientSeriesFunction</code>, the simulated gradient given as an interpolated function;
<code>eventStartEndTimes</code>, a vector of when each event and its preceding transition begin in time-units;
<code>eventPhaseStartTimes</code>, a vector of when each new event phase (at the peak gradient value) begin in time-units;
and <code>backgroundStartEnd</code>, a value indicating the time-step when the beginning background interval ends.
</p>

<hr>
<h2 id='simMixedAssemblageSample'>Simulate a Mixed Fossil Assemblage Composed of Communities at Different Gradient Values, and Sample the Lumped Assemblage</h2><span id='topic+simMixedAssemblageSample'></span>

<h3>Description</h3>

<p>This function simulate a mixed fossil assemblage by simulating a series of communities across a defined range of gradient values, lumps them into a single mixed assemblage, and then samples that assemblage as defined by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMixedAssemblageSample(
  kdeRescaled,
  probSpeciesOccur,
  gradientValues,
  specimensPerTimestep,
  nSpecimens
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMixedAssemblageSample_+3A_kderescaled">kdeRescaled</code></td>
<td>
<p>The list of modeled KDEs for species abundance, output from <code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>.</p>
</td></tr>
<tr><td><code id="simMixedAssemblageSample_+3A_probspeciesoccur">probSpeciesOccur</code></td>
<td>
<p>The output from <code><a href="#topic+getProbOccViaPresAbs">getProbOccViaPresAbs</a></code></p>
</td></tr>
<tr><td><code id="simMixedAssemblageSample_+3A_gradientvalues">gradientValues</code></td>
<td>
<p>A vector of gradient values to simulate over. A separate 'true' assemblage / community will be simulated for each value in the respective vector.</p>
</td></tr>
<tr><td><code id="simMixedAssemblageSample_+3A_specimenspertimestep">specimensPerTimestep</code></td>
<td>
<p>The number of specimens returned in a given time-step by <code>getTimestepAbundances</code>, usually set to an unrealistically high number to represent the true 'unsampled' fossil assemblage.</p>
</td></tr>
<tr><td><code id="simMixedAssemblageSample_+3A_nspecimens">nSpecimens</code></td>
<td>
<p>The number of specimens selected in each individual sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly written for simulating what artificial mixtures of assemblages at different gradient values would look like if sampled and assumed to be a single cohesive assemblage.
</p>


<h3>Value</h3>

<p>A matrix containing the species abundances in the resulting mixed assemblage.
</p>

<hr>
<h2 id='simulateFossilAssemblageSeries'>Simulate Time-Series of Successive Fossil Assemblages</h2><span id='topic+simulateFossilAssemblageSeries'></span>

<h3>Description</h3>

<p>Given a set of parameters and models describing species abundance,
stochastically models changes in an underlying biotic gradient and simulates
ecological change and a sequence of samples representing change in recovered
fossil assemblages over that interval, 
including estimating the recovered gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateFossilAssemblageSeries(
  kdeRescaled,
  probSpeciesOccur,
  origAbundData,
  eventChangeScale,
  bgGradientValue,
  fullGradientRange,
  eventSampleWidthRatio = NULL,
  sampleWidth = NULL,
  eventDuration = NULL,
  sedRatePerTimestep = NULL,
  samplingCompleteness,
  transitionDurationRatio,
  bioturbDepthRatio,
  bioturbIntensity,
  nEvents,
  nSpecimens,
  specimensPerTimestep = 10000,
  halfGradientOnly = FALSE,
  useTransformedRelAbundance = TRUE,
  projectIntoOrigDCA = TRUE,
  powerRootTransform = 1,
  maxSampleTimeStep = 500,
  minSampleTimeStep = 3,
  includeInitialBackgroundPhase = FALSE,
  plot = FALSE,
  thinOutput = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateFossilAssemblageSeries_+3A_kderescaled">kdeRescaled</code></td>
<td>
<p>The list of modeled KDEs for species abundance, output from <code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_probspeciesoccur">probSpeciesOccur</code></td>
<td>
<p>The output from <code><a href="#topic+getProbOccViaPresAbs">getProbOccViaPresAbs</a></code></p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_origabunddata">origAbundData</code></td>
<td>
<p>The original matrix of abundance data, to be used to
project the simulated data into the same detrended correspondence analysis (DCA) space.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_eventchangescale">eventChangeScale</code></td>
<td>
<p>A value indicating the amount relative to 
the background value (<code>bgGradientValue</code>) and the maximum 
possible change as indicated by <code>fullGradientRange</code> 
(in other words, simulated change must be within observed gradient, 
so <code>eventChangeScale</code> is a proportional multiplier of 
the total possible change).</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_bggradientvalue">bgGradientValue</code></td>
<td>
<p>The gradient value expected during 
background intervals during which no notable excursion is 
occurring on that environmental gradient.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_fullgradientrange">fullGradientRange</code></td>
<td>
<p>A vector of two values giving the minimum 
and maximum gradient values observed in the empirical data.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_eventsamplewidthratio">eventSampleWidthRatio</code></td>
<td>
<p>How long should an event be relative 
to the amount of time (or sediment) captured within a sedimentary sample? 
This parameter is used for simulating event duration, 
sample width and sedimentation rate where any two of these three 
are defined and the third is not defined. 
This value is referred to as <em>Resolution Potential</em> 
in Belanger &amp; Bapst (2023).</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_samplewidth">sampleWidth</code></td>
<td>
<p>The 'width' of a sample relative to core depth 
or outcrop height, usually given in linear units (usually centimeters). 
For taking sediment samples from a core, this is straightforward 
(how thick is each sediment sample taken?) but for outcrops this 
may be more difficult to determine 
(what is the thickness of a horizon in a shale unit?).</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_eventduration">eventDuration</code></td>
<td>
<p>The duration (in time-units) of a 
simulated event during which the environmental gradient 
is at an excursion 'peak' level.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_sedratepertimestep">sedRatePerTimestep</code></td>
<td>
<p>The rate of sedimentation, given as a 
ratio of sediment thickness (given in linear dimensions, 
in the same units as <code>sampleWidth</code>), over time 
(given in the same time units as <code>eventDuration</code>.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_samplingcompleteness">samplingCompleteness</code></td>
<td>
<p>The relative completeness of stratigraphic 
sampling. For example, if two-centimeter wide samples of sediment are 
taken from a sediment core, every ten centimeters, then the 
<code>samplingCompleteness</code> is two over 10, or that
<code>samplingCompleteness = 1/5</code>. A simulation with a sampling 
completeness of 1 would be comparable to exhaustively sampling a 
core that recorded no gaps in sedimentation over its history. 
Rocky outcrops are more complicated, as fossil-bearing horizons 
may be relatively thin compared to the thickness of the section, 
such that outcrop-based fossil records should be simulated as 
having <em>very low</em> <code>samplingCompleteness</code>.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_transitiondurationratio">transitionDurationRatio</code></td>
<td>
<p>The ratio of how long the transition 
between peak and background intervals should be, relative to the 
length of the peak 'event' duration (<code>eventDuration</code>). 
The longer this transition interval, the more chances of 
an assemblage being sampled that represents transitional gradient values.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_bioturbdepthratio">bioturbDepthRatio</code></td>
<td>
<p>The ratio of the sediment depth to which 
bioturbation occurs, made relative to the width of a 
sediment sample (<code>sampleWidth</code>). 
A <code>sampleWidth</code> of 3 cm and a <code>biotubDepthRatio</code> 
of 5 implies a bioturbation depth of 15 cm (<code>3 * 5</code>).  
Bioturbation depth varies considerably in the modern ocean, but is 
often the depth of active bioturbation is about 10 cm, such that the 
top ten centimeters of sediment 
(and the organic remains in those ten centimeters of sediment) 
are being regularly moved up and down by organism activity. 
For the purposes of this model, a bioturbation zone depth of 
10 centimeters means that sampling a centimeter of sediment 
at location X, the apparent fossil assemblage that would be 
recovered is just as likely to include specimens that were 
deposited five centimeters away as those deposited at location X.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_bioturbintensity">bioturbIntensity</code></td>
<td>
<p>The degree of mixing within the bioturbation zone, as a value between 0 and 1. When intensity is 1, a given sample will consist only</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_nevents">nEvents</code></td>
<td>
<p>Number of events to occur in a simulated sequence 
of gradient change.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_nspecimens">nSpecimens</code></td>
<td>
<p>The number of specimens selected in each individual sample.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_specimenspertimestep">specimensPerTimestep</code></td>
<td>
<p>The number of specimens returned in a 
given time-step by <code>getTimestepAbundances</code>, usually set to an 
unrealistically high number to represent the 
true 'unsampled' fossil assemblage. Default is 10000.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_halfgradientonly">halfGradientOnly</code></td>
<td>
<p>Whether to simulate only half of 
a background-event sequence, either beginning or terminating 
the simulation at the peak value. 
Only a single event can be simulated, so <code>nEvents</code> must be 1. 
The default is <code>FALSE</code> which signals to not simulated a half-gradient.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_usetransformedrelabundance">useTransformedRelAbundance</code></td>
<td>
<p>Should the DCA be analyzed</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_projectintoorigdca">projectIntoOrigDCA</code></td>
<td>
<p>Should the new simulated data be projected in the DCA generated by analyzing the original data? This is <code>TRUE</code> by default, which is what most users will likely use, as it is the preferable way to consider how the new simulated data relates to the original data.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_powerroottransform">powerRootTransform</code></td>
<td>
<p>The power-root transform to be used on the abundance data before applying the DCA. By default this is 1, which means the data is not transformed at all. Note that the power-root transform is only performed if <code>useTransformedRelAbundance = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_maxsampletimestep">maxSampleTimeStep</code></td>
<td>
<p>The maximum number of individual time-steps 
used for simulating a sample.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_minsampletimestep">minSampleTimeStep</code></td>
<td>
<p>The minimum number of individual time-steps 
used for simulating a sample.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_includeinitialbackgroundphase">includeInitialBackgroundPhase</code></td>
<td>
<p>A logical indicating whether 
to include a lengthy background phase, for use in calibrating a simulation. 
This function is mainly for diagnostic purposes 
and may be removed in future updates.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_plot">plot</code></td>
<td>
<p>Should the simulated time-series of fossil assemblages 
be shown as a sequence of generating and recovered gradient values 
against time? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulateFossilAssemblageSeries_+3A_thinoutput">thinOutput</code></td>
<td>
<p>Should the output be thinned to just the 
sample properties and intrinsic variables? Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different parameterizations may be given as input, 
allowing different parameters to be unspecified.
Missing parameters are then calculated from the specified 
ones using <code><a href="#topic+calculateImplicitParameters">calculateImplicitParameters</a></code>.
</p>


<h3>Value</h3>

<p>Returns a list, which by default has seven components: 
<code>implicitParameters</code>, the full list of parameters used for generating the simulated data; 
<code>simGradientChangeOut</code>, the simulated time-series of gradient change output by <code>setupSimulatedGradientChange</code>;
<code>maxTime</code>, the total duration of the entire simulated time-series from start to end;
<code>simTimeVar</code>, a data frame specifying time-steps, sedimentary depth and environmental gradient values for simulating a time-series of sampled fossil assemblages, used as input in <code><a href="#topic+sampleFossilSeries">sampleFossilSeries</a></code>;
<code>fossilSeries</code>, a list containing the simulated time-series of sampled fossil assemblages from <code><a href="#topic+sampleFossilSeries">sampleFossilSeries</a></code>,
<code>ecology</code>, the recovered ecological variables for each simulated sample, 
as returned by internal function <code>quantifyCommunityEcology</code>,
and <code>sampleProperties</code>, a list containing a number of variables specific to individual .
</p>
<p>If <code>thinList = TRUE</code> is used, then the output list
contains only two components: 
<code>sampleProperties</code> and <code>implicitParameters</code>.
The <code>implicitParameters</code> component is the same as in the full output,
but the <code>sampleProperties</code> component only contains information on when 
(in both time and sedimentary depth) a given sample is located in the 
simulated time-series, and the variable <code>scoreDCA1_recovered</code>.
</p>


<h3>References</h3>

<p>Belanger, Christina L., and David W. Bapst. 2023.
&quot;Simulating our ability to accurately detect abrupt 
changes in assemblage-based paleoenvironmental proxies.&quot; 
Palaeontologia Electronica 26 (2), 1-32
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateImplicitParameters">calculateImplicitParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an example with Gulf of Alaska data

# load data
data(gulfOfAlaska)

alaskaKDEs &lt;- getSpeciesSpecificRescaledKDE(
    gradientOrigDCA = DCA1_GOA, 
    origAbundData = abundData_GOA, 
    abundanceFloorRatio = 0.5, 
    nBreaksGradientHist = 20, 
    modeledSiteAbundance = 10000
    )
    
alaskaProbOccur &lt;- getProbOccViaPresAbs(
   gradientOrigDCA = DCA1_GOA, 
   origAbundData = abundData_GOA
   )

# Run the simulation of fossil assemblages
    # simulateFossilAssemblageSeries has lots of arguments...
    # below they are broken up into groups, seperate by #
    # matches scenarios from fig 13 of Belanger &amp; Bapst
    
fossilSeriesOut &lt;- simulateFossilAssemblageSeries(
      # inputs
      kdeRescaled = alaskaKDEs,
      probSpeciesOccur = alaskaProbOccur,
      origAbundData = abundData_GOA,
      fullGradientRange = c(min(DCA1_GOA), max(DCA1_GOA)),
      
      # let's make it relatively mild event 
        # with a long transition 
      eventChangeScale = 0.5,
      bgGradientValue = -1,
      transitionDurationRatio = 1,
       
      # don't need to define eventSampleWidthRatio 
        # - only need to define three of eventSampleWidthRatio, 
        # sampleWidth, eventDuration, sedRatePerTimestep
      sampleWidth = 3,
      eventDuration = 100, 
      sedRatePerTimestep = 0.1,
      
      # sample every third sample-width worth of core
      samplingCompleteness = 1/3,
      # no bioturbation 
      bioturbDepthRatio = 0,
      bioturbIntensity = 0,
           
      nEvents = 1,
      nSpecimens = 100,
      # let's plot it
      plot = TRUE
      )


</code></pre>

<hr>
<h2 id='simulateGradientQuantile'>Repeatedly Simulate Sampled Assemblages at some Gradient Value, and Return a Quantile Based on Recovered Gradient Values</h2><span id='topic+simulateGradientQuantile'></span>

<h3>Description</h3>

<p>This function simulates assemblages at a single given gradient value, and returns a specified quantile on the recovered gradient values for the sake of defining an envelope around on recovered gradient values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateGradientQuantile(
  quantileProbs = c(0.95),
  nSamplesSim,
  gradientValue,
  origAbundData,
  kdeRescaled,
  probSpeciesOccur,
  powerRootTransform = 1,
  specimensPerTimestep = 10000,
  nSpecimens
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateGradientQuantile_+3A_quantileprobs">quantileProbs</code></td>
<td>
<p>The quantile for which to return on the recovered gradient values from the simulated assemblages. (Technically multiple quantiles can be given, for which a value will be returned for each.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_nsamplessim">nSamplesSim</code></td>
<td>
<p>The number of samples to simulate.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_gradientvalue">gradientValue</code></td>
<td>
<p>The gradient value to simulate assemblages at.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_origabunddata">origAbundData</code></td>
<td>
<p>The original matrix of abundance data, to be used to
project the simulated data into the same detrended correspondence analysis (DCA) space.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_kderescaled">kdeRescaled</code></td>
<td>
<p>The list of modeled KDEs for species abundance, output from <code><a href="#topic+getSpeciesSpecificRescaledKDE">getSpeciesSpecificRescaledKDE</a></code>.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_probspeciesoccur">probSpeciesOccur</code></td>
<td>
<p>The output from <code><a href="#topic+getProbOccViaPresAbs">getProbOccViaPresAbs</a></code></p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_powerroottransform">powerRootTransform</code></td>
<td>
<p>The power-root transform to be used on the abundance data before applying the DCA. By default this is 1, which means the data is not transformed at all. Note that the power-root transform is only performed if <code>useTransformedRelAbundance = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_specimenspertimestep">specimensPerTimestep</code></td>
<td>
<p>The number of specimens returned in a given time-step by <code>getTimestepAbundances</code>, usually set to an unrealistically high number to represent the true 'unsampled' fossil assemblage.</p>
</td></tr>
<tr><td><code id="simulateGradientQuantile_+3A_nspecimens">nSpecimens</code></td>
<td>
<p>The number of specimens selected in each individual sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is most useful with applications like <code>getRecoveredTransitionDuration</code> which use envelope values to define features of a recovered sequence of gradient values for comparing simulated and empirical data.
</p>


<h3>Value</h3>

<p>A value for each quantile specified in <code>quantileProbs</code>. May be multiple values if <code>quantileProbs</code> is a vector with more than one value.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
