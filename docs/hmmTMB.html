<!DOCTYPE html><html><head><title>Help for package hmmTMB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hmmTMB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_character_formula'><p>Read formula with as.character without splitting</p></a></li>
<li><a href='#as_sparse'><p>Transforms matrix to dgTMatrix</p></a></li>
<li><a href='#bdiag_check'><p>Create block diagonal matrix (safe version)</p></a></li>
<li><a href='#cov_grid'><p>Grid of covariates</p></a></li>
<li><a href='#Dist'><p>R6 class for probability distribution</p></a></li>
<li><a href='#find_re'><p>Find s(, bs = &quot;re&quot;) terms in formula</p></a></li>
<li><a href='#HMM'><p>R6 class for hidden Markov model</p></a></li>
<li><a href='#hmmTMB_cols'><p>hmmTMB colour palette</p></a></li>
<li><a href='#hmmTMB-package'><p>hmmTMB: Fit Hidden Markov Models using Template Model Builder</p></a></li>
<li><a href='#invmlogit'><p>Multivarite inverse logit function</p></a></li>
<li><a href='#is_whole_number'><p>Check if number of whole number</p></a></li>
<li><a href='#logLik.HMM'><p>logLik function for SDE objects</p></a></li>
<li><a href='#logsumexp'><p>Log of sum of exponentials</p></a></li>
<li><a href='#make_formulas'><p>Process formulas and store in nested list</p></a></li>
<li><a href='#make_matrices'><p>Create model matrices</p></a></li>
<li><a href='#MarkovChain'><p>R6 class for HMM hidden process model</p></a></li>
<li><a href='#mlogit'><p>Multivariate logit function</p></a></li>
<li><a href='#mvnorm_invlink'><p>Multivariate Normal inverse link function</p></a></li>
<li><a href='#mvnorm_link'><p>Multivariate Normal link function</p></a></li>
<li><a href='#na_fill'><p>Fill in NAs</p></a></li>
<li><a href='#Observation'><p>R6 class for HMM observation model</p></a></li>
<li><a href='#prec_to_cov'><p>Get covariance matrix from precision matrix</p></a></li>
<li><a href='#quad_pos_solve'><p>Solve for positive root of quadratic ax^2 + bx + c = 0 when it exists</p></a></li>
<li><a href='#strip_comments'><p>Strip comments marked with a hash from a character vector</p></a></li>
<li><a href='#update.HMM'><p>Update a model to a new model by changing one formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Hidden Markov Models using Template Model Builder</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theo Michelot &lt;theo.michelot@dal.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting hidden Markov models using automatic differentiation 
  and Laplace approximation, allowing for fast inference and flexible covariate
  effects (including random effects and smoothing splines) on model parameters.
  The package is described by Michelot (2022) &lt;<a href="https://arxiv.org/abs/2211.14139">arXiv:2211.14139</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TheoMichelot/hmmTMB">https://github.com/TheoMichelot/hmmTMB</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R6, mgcv, TMB, ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stringr, optimx, CircStats, MASS, tmbstan, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rstan, testthat, knitr, moveHMM, scico, MSwM, unmarked</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 20:14:11 UTC; theo</td>
</tr>
<tr>
<td>Author:</td>
<td>Theo Michelot [aut, cre],
  Richard Glennie [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_character_formula'>Read formula with as.character without splitting</h2><span id='topic+as_character_formula'></span>

<h3>Description</h3>

<p>Read formula with as.character without splitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_character_formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_character_formula_+3A_x">x</code></td>
<td>
<p>R formula</p>
</td></tr>
<tr><td><code id="as_character_formula_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Citation: this function was taken from the R package
formula.tools: 
Christopher Brown (2018). formula.tools: Programmatic Utilities for Manipulating Formulas,
Expressions, Calls, Assignments and Other R Objects. R package version 1.7.1.
https://CRAN.R-project.org/package=formula.tools
</p>

<hr>
<h2 id='as_sparse'>Transforms matrix to dgTMatrix</h2><span id='topic+as_sparse'></span>

<h3>Description</h3>

<p>Transforms matrix to dgTMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sparse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sparse_+3A_x">x</code></td>
<td>
<p>Matrix or vector. If this is a vector, it is formatted into
a single-column matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparse matrix of class dgTMatrix
</p>

<hr>
<h2 id='bdiag_check'>Create block diagonal matrix (safe version)</h2><span id='topic+bdiag_check'></span>

<h3>Description</h3>

<p>This version of bdiag checks whether the matrices passed as
arguments are NULL. This avoids errors that would arise if
using bdiag directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdiag_check(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdiag_check_+3A_...">...</code></td>
<td>
<p>Matrix or list of matrices (only the first argument is used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Block diagonal matrix
</p>

<hr>
<h2 id='cov_grid'>Grid of covariates</h2><span id='topic+cov_grid'></span>

<h3>Description</h3>

<p>Grid of covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_grid(var, data = NULL, obj = NULL, covs = NULL, formulas, n_grid = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_grid_+3A_var">var</code></td>
<td>
<p>Name of variable</p>
</td></tr>
<tr><td><code id="cov_grid_+3A_data">data</code></td>
<td>
<p>Data frame containing the covariates. If not provided, data
are extracted from obj</p>
</td></tr>
<tr><td><code id="cov_grid_+3A_obj">obj</code></td>
<td>
<p>HMM model object containing data and formulas</p>
</td></tr>
<tr><td><code id="cov_grid_+3A_covs">covs</code></td>
<td>
<p>Optional named list for values of covariates (other than 'var') 
that should be used in the plot (or dataframe with single row). If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.</p>
</td></tr>
<tr><td><code id="cov_grid_+3A_formulas">formulas</code></td>
<td>
<p>List of formulas used in the model</p>
</td></tr>
<tr><td><code id="cov_grid_+3A_n_grid">n_grid</code></td>
<td>
<p>Grid size (number of points). Default: 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of covariates, with 'var' defined over a grid,
and other covariates fixed to their mean (numeric) or first level
(factor).
</p>

<hr>
<h2 id='Dist'>R6 class for probability distribution</h2><span id='topic+Dist'></span>

<h3>Description</h3>

<p>Contains the probability density/mass function, and the link and inverse link 
functions for a probability distribution.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Dist-new"><code>Dist$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-name"><code>Dist$name()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-pdf"><code>Dist$pdf()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-cdf"><code>Dist$cdf()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-rng"><code>Dist$rng()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-link"><code>Dist$link()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-invlink"><code>Dist$invlink()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-npar"><code>Dist$npar()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-parnames"><code>Dist$parnames()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-parapprox"><code>Dist$parapprox()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-fixed"><code>Dist$fixed()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-code"><code>Dist$code()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-name_long"><code>Dist$name_long()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-set_npar"><code>Dist$set_npar()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-set_parnames"><code>Dist$set_parnames()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-set_code"><code>Dist$set_code()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-pdf_apply"><code>Dist$pdf_apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-rng_apply"><code>Dist$rng_apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-n2w"><code>Dist$n2w()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-w2n"><code>Dist$w2n()</code></a>
</p>
</li>
<li> <p><a href="#method-Dist-clone"><code>Dist$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Dist-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$new(
  name,
  pdf,
  rng,
  cdf = NULL,
  link,
  invlink,
  npar,
  parnames,
  parapprox = NULL,
  fixed = NULL,
  name_long = name
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of distribution</p>
</dd>
<dt><code>pdf</code></dt><dd><p>Probability density/mass function of the distribution
(e.g. <code>dnorm</code> for normal distribution).</p>
</dd>
<dt><code>rng</code></dt><dd><p>Random generator function of the distribution (e.g.
<code>rnorm</code> for normal distribution).</p>
</dd>
<dt><code>cdf</code></dt><dd><p>Cumulative distribution function of the distribution
(e.g., <code>pnorm</code> for normal distribution). This is used to compute
pseudo-residuals.</p>
</dd>
<dt><code>link</code></dt><dd><p>Named list of link functions for distribution parameters</p>
</dd>
<dt><code>invlink</code></dt><dd><p>Named list of inverse link functions for distribution
parameters</p>
</dd>
<dt><code>npar</code></dt><dd><p>Number of parameters of the distribution</p>
</dd>
<dt><code>parnames</code></dt><dd><p>Character vector with name of each parameter</p>
</dd>
<dt><code>parapprox</code></dt><dd><p>Function that takes a sample and produces approximate 
values for the unknown parameters</p>
</dd>
<dt><code>fixed</code></dt><dd><p>Vector with element for each parameter which is TRUE if 
parameter is fixed</p>
</dd>
<dt><code>name_long</code></dt><dd><p>Long version of the name of the distribution, possibly 
more user-readable than name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new Dist object
</p>


<hr>
<a id="method-Dist-name"></a>



<h4>Method <code>name()</code></h4>

<p>Return name of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$name()</pre></div>


<hr>
<a id="method-Dist-pdf"></a>



<h4>Method <code>pdf()</code></h4>

<p>Return pdf of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$pdf()</pre></div>


<hr>
<a id="method-Dist-cdf"></a>



<h4>Method <code>cdf()</code></h4>

<p>Return cdf of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$cdf()</pre></div>


<hr>
<a id="method-Dist-rng"></a>



<h4>Method <code>rng()</code></h4>

<p>Return random generator function of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$rng()</pre></div>


<hr>
<a id="method-Dist-link"></a>



<h4>Method <code>link()</code></h4>

<p>Return link function of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$link()</pre></div>


<hr>
<a id="method-Dist-invlink"></a>



<h4>Method <code>invlink()</code></h4>

<p>Return inverse link function of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$invlink()</pre></div>


<hr>
<a id="method-Dist-npar"></a>



<h4>Method <code>npar()</code></h4>

<p>Return number of parameters of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$npar()</pre></div>


<hr>
<a id="method-Dist-parnames"></a>



<h4>Method <code>parnames()</code></h4>

<p>Return names of parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$parnames()</pre></div>


<hr>
<a id="method-Dist-parapprox"></a>



<h4>Method <code>parapprox()</code></h4>

<p>Return function that approximates parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$parapprox()</pre></div>


<hr>
<a id="method-Dist-fixed"></a>



<h4>Method <code>fixed()</code></h4>

<p>Return which parameters are fixed
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$fixed()</pre></div>


<hr>
<a id="method-Dist-code"></a>



<h4>Method <code>code()</code></h4>

<p>Return code of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$code()</pre></div>


<hr>
<a id="method-Dist-name_long"></a>



<h4>Method <code>name_long()</code></h4>

<p>Human-readable name of Dist object
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$name_long()</pre></div>


<hr>
<a id="method-Dist-set_npar"></a>



<h4>Method <code>set_npar()</code></h4>

<p>Set number of parameters this distribution has
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$set_npar(new_npar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_npar</code></dt><dd><p>Number of parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dist-set_parnames"></a>



<h4>Method <code>set_parnames()</code></h4>

<p>Set parameter names
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$set_parnames(new_parnames)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_parnames</code></dt><dd><p>Parameter names</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dist-set_code"></a>



<h4>Method <code>set_code()</code></h4>

<p>Set distribution code
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$set_code(new_code)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_code</code></dt><dd><p>Distribution code</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dist-pdf_apply"></a>



<h4>Method <code>pdf_apply()</code></h4>

<p>Evaluate probability density/mass function
</p>
<p>This method is used in the Dist$obs_probs() method. It is a wrapper 
around Dist$pdf(), which prepares the parameters and passes them to the 
function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$pdf_apply(x, par, log = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Value at which the function should be evaluated</p>
</dd>
<dt><code>par</code></dt><dd><p>Vector of parameters. The entries should be named if
they are not in the same order as expected by the R function. (E.g.
shape/scale rather than shape/rate for gamma distribution.)</p>
</dd>
<dt><code>log</code></dt><dd><p>Logical. If TRUE, the log-density is returned. 
Default: FALSE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Probability density/mass function evaluated at x for
parameters par
</p>


<hr>
<a id="method-Dist-rng_apply"></a>



<h4>Method <code>rng_apply()</code></h4>

<p>Random number generator
</p>
<p>This method is a wrapper around Dist$rng(), which prepares the parameters 
and passes them to the function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$rng_apply(n, par)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of realisations to generate</p>
</dd>
<dt><code>par</code></dt><dd><p>Vector of parameters. The entries should be named if
they are not in the same order as expected by the R function. (E.g.
shape/scale rather than shape/rate for gamma distribution.)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of <code>n</code> realisations of this distribution
</p>


<hr>
<a id="method-Dist-n2w"></a>



<h4>Method <code>n2w()</code></h4>

<p>Natural to working parameter transformation
</p>
<p>This method transforms parameters from the natural scale (i.e., their domain
of definition) to the &quot;working&quot; or &quot;linear predictor&quot; scale (i.e., the real
line). It is a wrapper for Dist$link().
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$n2w(par)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>par</code></dt><dd><p>List of parameters</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of parameters on the working scale
</p>


<hr>
<a id="method-Dist-w2n"></a>



<h4>Method <code>w2n()</code></h4>

<p>Working to natural parameter transformation
</p>
<p>This method transforms parameters from the &quot;working&quot; or &quot;linear predictor&quot; 
scale (i.e., the real line) to the natural scale (i.e., their domain
of definition). It is a wrapper for Dist$invlink().
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$w2n(wpar, as_matrix = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wpar</code></dt><dd><p>Vector of working parameters</p>
</dd>
<dt><code>as_matrix</code></dt><dd><p>Logical. If TRUE, the natural parameters are
returned as a matrix with one row for each state and one column
for each parameter. If FALSE, the natural parameters are returned
as a list (default).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List or matrix of parameters on natural scale
</p>


<hr>
<a id="method-Dist-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dist$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='find_re'>Find s(, bs = &quot;re&quot;) terms in formula</h2><span id='topic+find_re'></span>

<h3>Description</h3>

<p>This function is used to identify the variables &quot;x&quot; which are 
included as s(x, bs = &quot;re&quot;) in the formula, in particular to
check that they are factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_re(form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_re_+3A_form">form</code></td>
<td>
<p>Model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of names of variables for which a random
effect term is included in the model.
</p>

<hr>
<h2 id='HMM'>R6 class for hidden Markov model</h2><span id='topic+HMM'></span>

<h3>Description</h3>

<p>Encapsulates the observation and hidden state models for a hidden
Markov model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HMM-new"><code>HMM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-obs"><code>HMM$obs()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-hid"><code>HMM$hid()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-out"><code>HMM$out()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-tmb_obj"><code>HMM$tmb_obj()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-tmb_obj_joint"><code>HMM$tmb_obj_joint()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-tmb_rep"><code>HMM$tmb_rep()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-states"><code>HMM$states()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-coeff_fe"><code>HMM$coeff_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-coeff_re"><code>HMM$coeff_re()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-coeff_list"><code>HMM$coeff_list()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-fixpar"><code>HMM$fixpar()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-coeff_array"><code>HMM$coeff_array()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-lambda"><code>HMM$lambda()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-update_par"><code>HMM$update_par()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-sd_re"><code>HMM$sd_re()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-par"><code>HMM$par()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-set_priors"><code>HMM$set_priors()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-priors"><code>HMM$priors()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-iters"><code>HMM$iters()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-out_stan"><code>HMM$out_stan()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-llk"><code>HMM$llk()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-edf"><code>HMM$edf()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-suggest_initial"><code>HMM$suggest_initial()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-setup"><code>HMM$setup()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-fit_stan"><code>HMM$fit_stan()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-fit"><code>HMM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-mle"><code>HMM$mle()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-forward_backward"><code>HMM$forward_backward()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-pseudores"><code>HMM$pseudores()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-viterbi"><code>HMM$viterbi()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-sample_states"><code>HMM$sample_states()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-state_probs"><code>HMM$state_probs()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-post_coeff"><code>HMM$post_coeff()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-post_linpred"><code>HMM$post_linpred()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-post_fn"><code>HMM$post_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-predict"><code>HMM$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-confint"><code>HMM$confint()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-simulate"><code>HMM$simulate()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-check"><code>HMM$check()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-plot_ts"><code>HMM$plot_ts()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-plot_dist"><code>HMM$plot_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-plot"><code>HMM$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-AIC_marginal"><code>HMM$AIC_marginal()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-AIC_conditional"><code>HMM$AIC_conditional()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-print_obspar"><code>HMM$print_obspar()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-print_tpm"><code>HMM$print_tpm()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-formulation"><code>HMM$formulation()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-print"><code>HMM$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HMM-clone"><code>HMM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HMM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new HMM object
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$new(obs = NULL, hid = NULL, file = NULL, init = NULL, fixpar = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obs</code></dt><dd><p>Observation object, created with <code>Observation$new()</code>.
This contains the formulation for the observation model.</p>
</dd>
<dt><code>hid</code></dt><dd><p>MarkovChain object, created with <code>MarkovChain$new()</code>.
This contains the formulation for the state process model.</p>
</dd>
<dt><code>file</code></dt><dd><p>Path to specification file for HMM. If this argument is
used, then <code>obs</code> and <code>hid</code> are unnecessary.</p>
</dd>
<dt><code>init</code></dt><dd><p>HMM object, used to initialise the parameters for this model.
If <code>init</code> is passed, then all parameters that are included in init
and in the present model are copied. This may be useful when fitting
increasingly complex models: start from a simple model, then pass it as
init to create a more complex model, and so on.</p>
</dd>
<dt><code>fixpar</code></dt><dd><p>Named list, with optional elements: 'hid', 'obs', 'delta0',
'lambda_obs', and 'lambda_hid'. Each element is a named vector of 
parameters in coeff_fe that should either be fixed (if the corresponding
element is set to NA) or estimated to a common value (using integers or
factor levels).don See examples in the vignettes, and check the TMB
documentation to understand the inner workings (argument <code>map</code>
of <code>TMB::MakeADFun()</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new HMM object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)
</pre>
</div>


<hr>
<a id="method-HMM-obs"></a>



<h4>Method <code>obs()</code></h4>

<p>Observation object for this model
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$obs()</pre></div>


<hr>
<a id="method-HMM-hid"></a>



<h4>Method <code>hid()</code></h4>

<p>MarkovChain object for this model
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$hid()</pre></div>


<hr>
<a id="method-HMM-out"></a>



<h4>Method <code>out()</code></h4>

<p>Output of optimiser after model fitting
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$out()</pre></div>


<hr>
<a id="method-HMM-tmb_obj"></a>



<h4>Method <code>tmb_obj()</code></h4>

<p>Model object created by TMB. This is the output of 
the TMB function <code>MakeADFun</code>, and it is a list including elements
</p>

<dl>
<dt><code>fn</code></dt><dd><p>Objective function</p>
</dd>
<dt><code>gr</code></dt><dd><p>Gradient function of fn</p>
</dd>
<dt><code>par</code></dt><dd><p>Vector of initial parameters on working scale</p>
</dd>
</dl>



<h5>Usage</h5>

<div class="r"><pre>HMM$tmb_obj()</pre></div>


<hr>
<a id="method-HMM-tmb_obj_joint"></a>



<h4>Method <code>tmb_obj_joint()</code></h4>

<p>Model object created by TMB for the joint likelihood of
the fixed and random effects. This is the output of the TMB function 
<code>MakeADFun</code>, and it is a list including elements
</p>

<dl>
<dt><code>fn</code></dt><dd><p>Objective function</p>
</dd>
<dt><code>gr</code></dt><dd><p>Gradient function of fn</p>
</dd>
<dt><code>par</code></dt><dd><p>Vector of initial parameters on working scale</p>
</dd>
</dl>



<h5>Usage</h5>

<div class="r"><pre>HMM$tmb_obj_joint()</pre></div>


<hr>
<a id="method-HMM-tmb_rep"></a>



<h4>Method <code>tmb_rep()</code></h4>

<p>Output of the TMB function <code>sdreport</code>, which includes 
estimates and standard errors for all model parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$tmb_rep()</pre></div>


<hr>
<a id="method-HMM-states"></a>



<h4>Method <code>states()</code></h4>

<p>Vector of estimated states, after <code>viterbi</code> has
been run
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$states()</pre></div>


<hr>
<a id="method-HMM-coeff_fe"></a>



<h4>Method <code>coeff_fe()</code></h4>

<p>Coefficients for fixed effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$coeff_fe()</pre></div>


<hr>
<a id="method-HMM-coeff_re"></a>



<h4>Method <code>coeff_re()</code></h4>

<p>Coefficients for random effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$coeff_re()</pre></div>


<hr>
<a id="method-HMM-coeff_list"></a>



<h4>Method <code>coeff_list()</code></h4>

<p>List of all model coefficients
</p>
<p>These are the parameters estimated by the model, including
fixed and random effect parameters for the observation parameters
and the transition probabilities, (transformed) initial
probabilities, and smoothness parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$coeff_list()</pre></div>


<hr>
<a id="method-HMM-fixpar"></a>



<h4>Method <code>fixpar()</code></h4>

<p>Fixed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$fixpar(all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>Logical. If FALSE, only user-specified fixed
parameters are returned, but not parameters that are fixed
by definition (e.g., size of binomial distribution).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HMM-coeff_array"></a>



<h4>Method <code>coeff_array()</code></h4>

<p>Array of working parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$coeff_array()</pre></div>


<hr>
<a id="method-HMM-lambda"></a>



<h4>Method <code>lambda()</code></h4>

<p>Smoothness parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$lambda()</pre></div>


<hr>
<a id="method-HMM-update_par"></a>



<h4>Method <code>update_par()</code></h4>

<p>Update parameters stored inside model object
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$update_par(par_list = NULL, iter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>par_list</code></dt><dd><p>List with elements for coeff_fe_obs, 
coeff_fe_hid, coeff_re_obs, coeff_re_hid, log_delta0, 
log_lambda_hid, and log_lambda_obs</p>
</dd>
<dt><code>iter</code></dt><dd><p>Optional argument to update model parameters based on MCMC
iterations (if using rstan). Either the index of the iteration to use,
or &quot;mean&quot; if the posterior mean should be used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HMM-sd_re"></a>



<h4>Method <code>sd_re()</code></h4>

<p>Standard deviation of smooth terms (or random effects)
</p>
<p>This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$sd_re()</pre></div>



<h5>Returns</h5>

<p>List of standard deviations for observation model and
hidden state model.
</p>


<hr>
<a id="method-HMM-par"></a>



<h4>Method <code>par()</code></h4>

<p>Model parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$par(t = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>returns parameters at time t, default is t = 1</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt><code>obspar</code></dt><dd><p>Parameters of observation model</p>
</dd>
<dt><code>tpm</code></dt><dd><p>Transition probability matrix of hidden state model</p>
</dd>
</dl>



<hr>
<a id="method-HMM-set_priors"></a>



<h4>Method <code>set_priors()</code></h4>

<p>Set priors for coefficients
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$set_priors(new_priors = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_priors</code></dt><dd><p>is a list of matrices for optionally 
coeff_fe_obs, coeff_fe_hid, log_lambda_obs log_lambda_hid 
each matrix has two rows (first row = mean, second row = sd) 
specifying parameters for Normal priors</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HMM-priors"></a>



<h4>Method <code>priors()</code></h4>

<p>Extract stored priors
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$priors()</pre></div>


<hr>
<a id="method-HMM-iters"></a>



<h4>Method <code>iters()</code></h4>

<p>Iterations from stan MCMC fit
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$iters(type = "response")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>Either &quot;response&quot; for parameters on the response (natural)
scale, or &quot;raw&quot; for parameters on the linear predictor scale.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>see output of as.matrix in stan
</p>


<hr>
<a id="method-HMM-out_stan"></a>



<h4>Method <code>out_stan()</code></h4>

<p>fitted stan object from MCMC fit
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$out_stan()</pre></div>



<h5>Returns</h5>

<p>the stanfit object
</p>


<hr>
<a id="method-HMM-llk"></a>



<h4>Method <code>llk()</code></h4>

<p>Log-likelihood at current parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$llk()</pre></div>



<h5>Returns</h5>

<p>Log-likelihood
</p>


<hr>
<a id="method-HMM-edf"></a>



<h4>Method <code>edf()</code></h4>

<p>Effective degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$edf()</pre></div>



<h5>Returns</h5>

<p>Number of effective degrees of freedom
(accounting for flexibility in non-parametric 
terms implied by smoothing)
</p>


<hr>
<a id="method-HMM-suggest_initial"></a>



<h4>Method <code>suggest_initial()</code></h4>

<p>Suggest initial parameter values
</p>
<p>Uses K-means clustering to split the data into naive &quot;states&quot;, and
estimates observation parameters within each of these states. This is
meant to help with selecting initial parameter values before model
fitting, but users should still think about the values carefully,
and try multiple set of initial parameter values to ensure
convergence to the global maximum of the likelihood function.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$suggest_initial()</pre></div>



<h5>Returns</h5>

<p>List of initial parameters
</p>


<hr>
<a id="method-HMM-setup"></a>



<h4>Method <code>setup()</code></h4>

<p>TMB setup
</p>
<p>This creates an attribute <code>tmb_obj</code>, which can be used to 
evaluate the negative log-likelihood function.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$setup(silent = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>silent</code></dt><dd><p>Logical. If TRUE, all tracing outputs are hidden (default).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HMM-fit_stan"></a>



<h4>Method <code>fit_stan()</code></h4>

<p>Fit model using tmbstan
</p>
<p>Consult documentation of the tmbstan package for more information.
After this method has been called, the Stan output can be accessed
using the method <code>out_stan()</code>. This Stan output can for example 
be visualised using functions from the rstan package. The parameters
stored in this HMM object are automatically updated to the mean 
posterior estimate, although this can be changed using 
<code>update_par()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$fit_stan(..., silent = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to tmbstan</p>
</dd>
<dt><code>silent</code></dt><dd><p>Logical. If FALSE, all tracing outputs are shown (default).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HMM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Model fitting
</p>
<p>The negative log-likelihood of the model is minimised using the
function <code>optimx()</code>. TMB uses the Laplace approximation to integrate 
the random effects out of the likelihood.
</p>
<p>After the model has been fitted, the output of <code>optimx()</code> can be
accessed using the method <code>out()</code>. The estimated parameters can
be accessed using the methods <code>par()</code> (for the HMM parameters, 
possibly dependent on covariates), <code>predict()</code> (for uncertainty
quantification and prediction of the HMM parameters for new covariate 
values), <code>coeff_fe()</code> (for estimated fixed effect coefficients on
the linear predictor scale), and <code>coeff_re()</code> (for estimated random
effect coefficients on the linear predictor scale).
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$fit(silent = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>silent</code></dt><dd><p>Logical. If FALSE, all tracing outputs are shown (default).</p>
</dd>
<dt><code>...</code></dt><dd><p>Other arguments to optimx which is used to optimise likelihood, 
see ?optimx</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)

# Fit HMM
hmm$fit(silent = TRUE)
</pre>
</div>


<hr>
<a id="method-HMM-mle"></a>



<h4>Method <code>mle()</code></h4>

<p>Get maximum likelihood estimates once model fitted
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$mle()</pre></div>



<h5>Returns</h5>

<p>list of maximum likelihood estimates as described as
input for the function update_par()
</p>


<hr>
<a id="method-HMM-forward_backward"></a>



<h4>Method <code>forward_backward()</code></h4>

<p>Forward-backward algorithm 
</p>
<p>The forward probability for time step t and state j 
is the joint pdf/pmf of observations up to time t and of being in
state j at time t, p(Z[1], Z[2], ..., Z[t], S[t] = j).
The backward probability for time t and state j is the
conditional pdf/pmf of observations between time t + 1 and n,
given state j at time t, p(Z[t+1], Z[t+2], ..., Z[n] | S[t] = j).
This function returns their logarithm, for use in other methods
<code>state_probs</code>, and <code>sample_states</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$forward_backward()</pre></div>



<h5>Returns</h5>

<p>Log-forward and log-backward probabilities
</p>


<hr>
<a id="method-HMM-pseudores"></a>



<h4>Method <code>pseudores()</code></h4>

<p>Pseudo-residuals
</p>
<p>Compute pseudo-residuals for the fitted model. If the fitted model
is the &quot;true&quot; model, the pseudo-residuals follow a standard normal 
distribution. Deviations from normality suggest lack of fit.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$pseudores()</pre></div>



<h5>Returns</h5>

<p>List (of length the number of variables), where each element is
a vector of pseudo-residuals (of length the number of data points)
</p>


<hr>
<a id="method-HMM-viterbi"></a>



<h4>Method <code>viterbi()</code></h4>

<p>Viterbi algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$viterbi()</pre></div>



<h5>Returns</h5>

<p>Most likely state sequence
</p>


<hr>
<a id="method-HMM-sample_states"></a>



<h4>Method <code>sample_states()</code></h4>

<p>Sample posterior state sequences using forward-filtering
backward-sampling 
</p>
<p>The forward-filtering backward-sampling algorithm returns a
sequence of states, similarly to the Viterbi algorithm, but it generates
it from the posterior distribution of state sequences, i.e., accounting
for uncertainty in the state classification. Multiple generated sequences
will therefore generally not be the same.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$sample_states(nsamp = 1, full = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nsamp</code></dt><dd><p>Number of samples to produce</p>
</dd>
<dt><code>full</code></dt><dd><p>If TRUE and model fit by fit_stan then parameter estimates are 
sampled from the posterior samples before simulating each sequence</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix where each column is a different sample of state sequences,
and each row is a time of observation
</p>


<hr>
<a id="method-HMM-state_probs"></a>



<h4>Method <code>state_probs()</code></h4>

<p>Compute posterior probability of being in each state
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$state_probs()</pre></div>



<h5>Returns</h5>

<p>matrix with a row for each observation and a column for each state
</p>


<hr>
<a id="method-HMM-post_coeff"></a>



<h4>Method <code>post_coeff()</code></h4>

<p>Posterior sampling for model coefficients
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$post_coeff(n_post)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_post</code></dt><dd><p>Number of posterior samples</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with one column for each coefficient and one row
for each posterior draw
</p>


<hr>
<a id="method-HMM-post_linpred"></a>



<h4>Method <code>post_linpred()</code></h4>

<p>Posterior sampling for linear predictor
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$post_linpred(n_post)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_post</code></dt><dd><p>Number of posterior samples</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List with elements obs and hid, where each is a matrix 
with one column for each predictor and one row for each posterior draw
</p>


<hr>
<a id="method-HMM-post_fn"></a>



<h4>Method <code>post_fn()</code></h4>

<p>Create posterior simulations of a function of a model component
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$post_fn(fn, n_post, comp = NULL, ..., level = 0, return_post = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Function which takes a vector of linear predictors as input
and produces either a scalar or vector output</p>
</dd>
<dt><code>n_post</code></dt><dd><p>Number of posterior simulations</p>
</dd>
<dt><code>comp</code></dt><dd><p>Either &quot;obs&quot; for observation model linear predictor, or
&quot;hid&quot; for hidden model linear predictor</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments passed to fn</p>
</dd>
<dt><code>level</code></dt><dd><p>Confidence interval level if required (e.g., 0.95 for 95
confidence intervals). Default is 0, i.e., confidence intervals are not
returned.</p>
</dd>
<dt><code>return_post</code></dt><dd><p>Logical indicating whether to return the posterior
samples. If FALSE (default), only mean estimates and confidence intervals
are returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt>post</dt><dd><p>If return_post = TRUE, this is a vector (for scalar 
outputs of fn) or matrix (for vector outputs) with a column for 
each simulation</p>
</dd>
<dt>mean</dt><dd><p>Mean over posterior samples</p>
</dd>
<dt>lcl</dt><dd><p>Lower confidence interval bound (if level !=0)</p>
</dd>
<dt>ucl</dt><dd><p>Upper confidence interval bound (if level !=0)</p>
</dd>
</dl>



<hr>
<a id="method-HMM-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict estimates from a fitted model
</p>
<p>By default, this returns point estimates of the HMM parameters
for a new data frame of covariates. See the argument 'n_post'
to also get confidence intervals.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$predict(
  what,
  t = 1,
  newdata = NULL,
  n_post = 0,
  level = 0.95,
  return_post = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>Which estimates to predict? Options include 
transition probability matrices &quot;tpm&quot;, 
stationary distributions &quot;delta&quot;, or 
observation distribution parameters &quot;obspar&quot;</p>
</dd>
<dt><code>t</code></dt><dd><p>Time points to predict at</p>
</dd>
<dt><code>newdata</code></dt><dd><p>New dataframe to use for prediction</p>
</dd>
<dt><code>n_post</code></dt><dd><p>If greater than zero then n_post posterior 
samples are produced, and used to create confidence intervals.</p>
</dd>
<dt><code>level</code></dt><dd><p>Level of the confidence intervals, e.g. CI = 0.95
will produce 95% confidence intervals (default)</p>
</dd>
<dt><code>return_post</code></dt><dd><p>Logical. If TRUE, a list of posterior samples
is returned.</p>
</dd>
<dt><code>...</code></dt><dd><p>Other arguments to the respective functions 
for hid$tpm, hid$delta, obs$par</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Named array of predictions and confidence intervals, 
if requested
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)

# Fit HMM
hmm$fit(silent = TRUE)

# Get transition probability matrix with confidence intervals
hmm$predict(what = "tpm", n_post = 1000)
</pre>
</div>


<hr>
<a id="method-HMM-confint"></a>



<h4>Method <code>confint()</code></h4>

<p>Confidence intervals for working parameters
</p>
<p>This function computes standard errors for all fixed effect model
parameters based on the diagonal of the inverse of the Hessian matrix,
and then derives Wald-type confidence intervals.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$confint(level = 0.95)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>level</code></dt><dd><p>Level of confidence intervals. Defaults to 0.95, i.e., 95%
confidence intervals.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of matrices with three columns: mle (maximum likelihood 
estimate), lcl (lower confidence limit), and ucl (upper confidence
limit). One such matrix is produced for the working parameters of the
observation model, the working parameters of the hidden state model,
the smoothness parameters of the observation model, and the smoothness
parameters of the hidden state model.
</p>


<hr>
<a id="method-HMM-simulate"></a>



<h4>Method <code>simulate()</code></h4>

<p>Simulate from hidden Markov model
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$simulate(n, data = NULL, silent = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of time steps to simulate</p>
</dd>
<dt><code>data</code></dt><dd><p>Optional data frame including covariates</p>
</dd>
<dt><code>silent</code></dt><dd><p>if TRUE then no messages are printed</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Data frame including columns of data (if provided), and simulated
data variables
</p>


<hr>
<a id="method-HMM-check"></a>



<h4>Method <code>check()</code></h4>

<p>Compute goodness-of-fit statistics using simulation
</p>
<p>Many time series are simulated from the fitted model, and the
statistic(s) of interest are calculated for each. A histogram of 
those values can for example be used to compare to the observed
value of the statistic. An observation far in the tails of the
distribution of simulated statistics suggests lack of fit.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$check(check_fn, nsims = 100, full = FALSE, silent = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>check_fn</code></dt><dd><p>Goodness-of-fit function which accepts &quot;data&quot; as input
and returns a statistic (either a vector or a single number) to be
compared between observed data and simulations.</p>
</dd>
<dt><code>nsims</code></dt><dd><p>Number of simulations to perform</p>
</dd>
<dt><code>full</code></dt><dd><p>If model fitted with 'fit_stan', then full = TRUE
will sample from posterior for each simulation</p>
</dd>
<dt><code>silent</code></dt><dd><p>Logical. If FALSE, simulation progress is shown. 
(Default: TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List with elements:
</p>

<dl>
<dt>obs_stat: </dt><dd><p>Vector of values of goodness-of-fit statistics for the
observed data</p>
</dd>
<dt>stats: </dt><dd><p>Matrix of values of goodness-of-fit statistics for the
simulated data sets (one row for each statistic, and one column for each
simulation)</p>
</dd>
<dt>plot: </dt><dd><p>ggplot object</p>
</dd>
</dl>



<hr>
<a id="method-HMM-plot_ts"></a>



<h4>Method <code>plot_ts()</code></h4>

<p>Time series plot coloured by states
</p>
<p>Creates a plot of the data coloured by the most likely state sequence,
as estimated by the Viterbi algorithm. If one variable name is passed
as input, it is plotted against time. If two variables are passed, they
are plotted against each other.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$plot_ts(var, var2 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>Name of the variable to plot.</p>
</dd>
<dt><code>var2</code></dt><dd><p>Optional name of a second variable, for 2-d plot.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A ggplot object
</p>


<hr>
<a id="method-HMM-plot_dist"></a>



<h4>Method <code>plot_dist()</code></h4>

<p>Plot observation distributions weighted by frequency in Viterbi 
</p>
<p>This is a wrapper around Observation$plot_dist, where the
distribution for each state is weighted by the proportion of time
spent in that state (according to the Viterbi state sequence).
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$plot_dist(var)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>Name of data variable</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Plot of distribution with data histogram
</p>


<hr>
<a id="method-HMM-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot a model component
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$plot(
  what,
  var = NULL,
  covs = NULL,
  i = NULL,
  j = NULL,
  n_grid = 50,
  n_post = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>what</code></dt><dd><p>Name of model component to plot: should be one of &quot;tpm&quot;
(transition probabilities), &quot;delta&quot; (stationary state probabilities), 
or &quot;obspar&quot; (state-dependent observation parameters)</p>
</dd>
<dt><code>var</code></dt><dd><p>Name of covariate to plot on x-axis</p>
</dd>
<dt><code>covs</code></dt><dd><p>Optional named list for values of covariates (other than 'var') 
that should be used in the plot (or dataframe with single row). If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.</p>
</dd>
<dt><code>i</code></dt><dd><p>If plotting tpm then rows of tpm; if plotting delta then indices
of states to plot; if plotting obspar then full names of parameters 
to plot (e.g., obsvar.mean)</p>
</dd>
<dt><code>j</code></dt><dd><p>If plotting tpm then columnss of tpm to plot; if plotting delta 
then this is ignored,; if plotting obspar then indices of states to plot</p>
</dd>
<dt><code>n_grid</code></dt><dd><p>Number of points in grid over x-axis (default: 50)</p>
</dd>
<dt><code>n_post</code></dt><dd><p>Number of posterior simulations to use when computing
confidence intervals; default: 1000. See <code>predict</code> function for 
more detail.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A ggplot object
</p>


<hr>
<a id="method-HMM-AIC_marginal"></a>



<h4>Method <code>AIC_marginal()</code></h4>

<p>Marginal Akaike Information Criterion
</p>
<p>The marginal AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum marginal log-likelihood (of fixed 
effects), and k is the number of degrees
of freedom of the fixed effect component of
the model
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$AIC_marginal()</pre></div>



<h5>Returns</h5>

<p>Marginal AIC
</p>


<hr>
<a id="method-HMM-AIC_conditional"></a>



<h4>Method <code>AIC_conditional()</code></h4>

<p>Conditional Akaike Information Criterion
</p>
<p>The conditional AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum joint log-likelihood (of fixed and random
effects), and k is the number of effective degrees
of freedom of the model (accounting for flexibility
in non-parametric terms implied by smoothing)
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$AIC_conditional()</pre></div>



<h5>Returns</h5>

<p>Conditional AIC
</p>


<hr>
<a id="method-HMM-print_obspar"></a>



<h4>Method <code>print_obspar()</code></h4>

<p>Print observation parameters at t = 1
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$print_obspar()</pre></div>


<hr>
<a id="method-HMM-print_tpm"></a>



<h4>Method <code>print_tpm()</code></h4>

<p>Print observation parameters at t = 1
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$print_tpm()</pre></div>


<hr>
<a id="method-HMM-formulation"></a>



<h4>Method <code>formulation()</code></h4>

<p>Print model formulation
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$formulation()</pre></div>


<hr>
<a id="method-HMM-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print HMM object
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$print()</pre></div>


<hr>
<a id="method-HMM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HMM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `HMM$new`
## ------------------------------------------------

# Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)

## ------------------------------------------------
## Method `HMM$fit`
## ------------------------------------------------

# Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)

# Fit HMM
hmm$fit(silent = TRUE)

## ------------------------------------------------
## Method `HMM$predict`
## ------------------------------------------------

# Load data set (included with R)
data(nottem)
data &lt;- data.frame(temp = as.vector(t(nottem)))

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = data, n_states = 2)
par0 &lt;- list(temp = list(mean = c(40, 60), sd = c(5, 5)))
obs &lt;- Observation$new(data = data, n_states = 2, 
                       dists = list(temp = "norm"),
                       par = par0)

# Create HMM
hmm &lt;- HMM$new(hid = hid, obs = obs)

# Fit HMM
hmm$fit(silent = TRUE)

# Get transition probability matrix with confidence intervals
hmm$predict(what = "tpm", n_post = 1000)
</code></pre>

<hr>
<h2 id='hmmTMB_cols'>hmmTMB colour palette</h2><span id='topic+hmmTMB_cols'></span>

<h3>Description</h3>

<p>hmmTMB colour palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmTMB_cols
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 6.
</p>

<hr>
<h2 id='hmmTMB-package'>hmmTMB: Fit Hidden Markov Models using Template Model Builder</h2><span id='topic+hmmTMB'></span><span id='topic+hmmTMB-package'></span>

<h3>Description</h3>

<p>Fitting hidden Markov models using automatic differentiation and Laplace approximation, allowing for fast inference and flexible covariate effects (including random effects and smoothing splines) on model parameters. The package is described by Michelot (2022) <a href="https://arxiv.org/abs/2211.14139">arXiv:2211.14139</a>.
</p>


<h3>Details</h3>

<p>The package hmmTMB is based on three main classes (i.e., types of objects):
MarkovChain, Observation, and HMM. Type ?MarkovChain, ?Observation or ?HMM
to find their documentation, or consult the package vignettes for detailed
examples of the hmmTMB workflow.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Theo Michelot <a href="mailto:theo.michelot@dal.ca">theo.michelot@dal.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Richard Glennie [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/TheoMichelot/hmmTMB">https://github.com/TheoMichelot/hmmTMB</a>
</p>
</li></ul>


<hr>
<h2 id='invmlogit'>Multivarite inverse logit function</h2><span id='topic+invmlogit'></span>

<h3>Description</h3>

<p>Multivarite inverse logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invmlogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invmlogit_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='is_whole_number'>Check if number of whole number</h2><span id='topic+is_whole_number'></span>

<h3>Description</h3>

<p>Check if number of whole number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_whole_number(x, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_whole_number_+3A_x">x</code></td>
<td>
<p>number to check or vector of numbers</p>
</td></tr>
<tr><td><code id="is_whole_number_+3A_tol">tol</code></td>
<td>
<p>how far away from whole number is ok?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if it is a whole number within tolerance
</p>

<hr>
<h2 id='logLik.HMM'>logLik function for SDE objects</h2><span id='topic+logLik.HMM'></span>

<h3>Description</h3>

<p>This function makes it possible to call generic R methods such
as AIC and BIC on HMM objects. It is based on the number of
degrees of freedom of the *conditional* AIC (rather than
marginal AIC), i.e., including degrees of freedom from the
smooth/random effect components of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMM'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.HMM_+3A_object">object</code></td>
<td>
<p>HMM model object</p>
</td></tr>
<tr><td><code id="logLik.HMM_+3A_...">...</code></td>
<td>
<p>For compatibility with S3 method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum log-likelihood value for the model, with attributes
<code>df</code> (degrees of freedom) and <code>nobs</code> (number of observations)
</p>

<hr>
<h2 id='logsumexp'>Log of sum of exponentials</h2><span id='topic+logsumexp'></span>

<h3>Description</h3>

<p>Log of sum of exponentials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logsumexp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logsumexp_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='make_formulas'>Process formulas and store in nested list</h2><span id='topic+make_formulas'></span>

<h3>Description</h3>

<p>Process formulas and store in nested list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_formulas(input_forms, var_names, par_names, n_states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_formulas_+3A_input_forms">input_forms</code></td>
<td>
<p>Nested list of formulas, with two levels: observed variable, 
and parameter of the observation distribution. The formulas can contain 
state-specific terms, e.g. &quot;~ state1(x1) + x2&quot;.</p>
</td></tr>
<tr><td><code id="make_formulas_+3A_var_names">var_names</code></td>
<td>
<p>character vector name of each observation variable</p>
</td></tr>
<tr><td><code id="make_formulas_+3A_par_names">par_names</code></td>
<td>
<p>list with element for each observation variable that
contains character vector of name of each parameter in its distribution</p>
</td></tr>
<tr><td><code id="make_formulas_+3A_n_states">n_states</code></td>
<td>
<p>Number of states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formulas for the observation parameters can be different for the
different states, using special functions of the form &quot;state1&quot;, &quot;state2&quot;, etc.
This method processes the list of formulas passed by the user to extract the 
state-specific formulas. Missing formulas are assumed to be intercept-only ~1.
</p>


<h3>Value</h3>

<p>Nested list of formulas, with three levels: observed variable,
parameter of the observation distribution, and state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_forms &lt;- list(step = list(shape = ~ state1(x1) + x2,
                                scale = ~ x1),
                    count = list(lambda = ~ state1(x1) + state2(s(x2, bs = "cs"))))

make_formulas(input_forms = input_forms, 
              var_names = names(input_forms), 
              par_names = lapply(input_forms, names), 
              n_states = 2)
              
</code></pre>

<hr>
<h2 id='make_matrices'>Create model matrices</h2><span id='topic+make_matrices'></span>

<h3>Description</h3>

<p>Create model matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_matrices(formulas, data, new_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_matrices_+3A_formulas">formulas</code></td>
<td>
<p>List of formulas (possibly nested, e.g. for use within Observation)</p>
</td></tr>
<tr><td><code id="make_matrices_+3A_data">data</code></td>
<td>
<p>Data frame including covariates</p>
</td></tr>
<tr><td><code id="make_matrices_+3A_new_data">new_data</code></td>
<td>
<p>Optional new data set, including covariates for which
the design matrices should be created. This needs to be passed in addition
to the argument '<code>data</code>', for cases where smooth terms or factor
covariates are included, and the original data set is needed to determine
the full range of covariate values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of
</p>

<ul>
<li><p> X_fe Design matrix for fixed effects
</p>
</li>
<li><p> X_re Design matrix for random effects
</p>
</li>
<li><p> S Smoothness matrix
</p>
</li>
<li><p> ncol_fe Number of columns of X_fe for each parameter
</p>
</li>
<li><p> ncol_re Number of columns of X_re and S for each random effect
</p>
</li></ul>


<hr>
<h2 id='MarkovChain'>R6 class for HMM hidden process model</h2><span id='topic+MarkovChain'></span>

<h3>Description</h3>

<p>Contains the parameters and model formulas for the hidden process model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MarkovChain-new"><code>MarkovChain$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-formula"><code>MarkovChain$formula()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-formulas"><code>MarkovChain$formulas()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-tpm"><code>MarkovChain$tpm()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-ref"><code>MarkovChain$ref()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-ref_mat"><code>MarkovChain$ref_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-ref_delta0"><code>MarkovChain$ref_delta0()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-coeff_fe"><code>MarkovChain$coeff_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-delta"><code>MarkovChain$delta()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-delta0"><code>MarkovChain$delta0()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-stationary"><code>MarkovChain$stationary()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-fixpar"><code>MarkovChain$fixpar()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-coeff_re"><code>MarkovChain$coeff_re()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-X_fe"><code>MarkovChain$X_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-X_re"><code>MarkovChain$X_re()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-lambda"><code>MarkovChain$lambda()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-sd_re"><code>MarkovChain$sd_re()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-nstates"><code>MarkovChain$nstates()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-terms"><code>MarkovChain$terms()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-unique_ID"><code>MarkovChain$unique_ID()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-initial_state"><code>MarkovChain$initial_state()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_tpm"><code>MarkovChain$update_tpm()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_coeff_fe"><code>MarkovChain$update_coeff_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_coeff_re"><code>MarkovChain$update_coeff_re()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_X_fe"><code>MarkovChain$update_X_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_X_re"><code>MarkovChain$update_X_re()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_delta0"><code>MarkovChain$update_delta0()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_lambda"><code>MarkovChain$update_lambda()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-update_fixpar"><code>MarkovChain$update_fixpar()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-make_mat"><code>MarkovChain$make_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-make_mat_grid"><code>MarkovChain$make_mat_grid()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-tpm2par"><code>MarkovChain$tpm2par()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-par2tpm"><code>MarkovChain$par2tpm()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-linpred"><code>MarkovChain$linpred()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-simulate"><code>MarkovChain$simulate()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-formulation"><code>MarkovChain$formulation()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-print"><code>MarkovChain$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MarkovChain-clone"><code>MarkovChain$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MarkovChain-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new MarkovChain object
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$new(
  data,
  formula = NULL,
  n_states,
  tpm = NULL,
  initial_state = "estimated",
  fixpar = NULL,
  ref = 1:n_states
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Data frame, needed to create model matrices, and to identify the
number of time series (which each have a separate initial distribution)</p>
</dd>
<dt><code>formula</code></dt><dd><p>Either (1) R formula, used for all transition probabilities, 
or (2) matrix of character strings giving the formula for each transition
probability, with &quot;.&quot; along the diagonal (or for reference elements; see
<code>ref</code> argument). (Default: no covariate dependence.)</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of states. If not specified, then <code>formula</code> 
needs to be provided as a matrix, and n_states is deduced from its dimensions.</p>
</dd>
<dt><code>tpm</code></dt><dd><p>Optional transition probability matrix, to initialise the model
parameters (intercepts in model with covariates). If not provided, the default 
is a matrix with 0.9 on the diagonal.</p>
</dd>
<dt><code>initial_state</code></dt><dd><p>Specify model for initial state distribution. There
are five different options: 
</p>

<ul>
<li><p> &quot;estimated&quot;: a separate initial distribution is estimated for 
each ID (default)
</p>
</li>
<li><p> &quot;stationary&quot;: the initial distribution is fixed to the
stationary distribution of the transition probability matrix for the 
first time point of each ID
</p>
</li>
<li><p> &quot;shared&quot;: a common initial distribution is estimated for all IDs
</p>
</li>
<li><p> integer value between 1 and n_states: used as the known initial 
state for all IDs
</p>
</li>
<li><p> vector of integers between 1 and n_states (of length the number 
of IDs): each element is used as the known initial state for the 
corresponding ID
</p>
</li></ul>
</dd>
<dt><code>fixpar</code></dt><dd><p>List with optional elements &quot;hid&quot; (fixed parameters for
transition probabilities), &quot;lambda_hid&quot; (fixed smoothness parameters), 
and &quot;delta0&quot; (fixed parameters for initial distribution). Each element is 
a named vector of coefficients that should either be fixed (if the 
corresponding element is set to NA) or estimated to a common value (using 
integers or factor levels).</p>
</dd>
<dt><code>ref</code></dt><dd><p>Vector of indices for reference transition probabilities, 
of length <code>n_states</code>. The i-th element is the index for the 
reference in the i-th row of the transition probability matrix. For 
example, ref = c(1, 1) means that the first element of the first row
Pr(1&gt;1) and the first element of the second row Pr(2&gt;1) are used as 
reference elements and are not estimated. If this is not provided,
the diagonal transition probabilities are used as references.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new MarkovChain object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set from MSwM package
data(energy, package = "MSwM")

# Create 2-state covariate-free model and initialise transition 
# probability matrix
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       tpm = matrix(c(0.8, 0.3, 0.2, 0.7), 2, 2))

# Create 2-state model with non-linear effect of Oil on all transition 
# probabilities
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       formula = ~ s(Oil, k = 5, bs = "cs"))

# Create 2-state model with quadratic effect of Oil on Pr(1 &gt; 2)
structure &lt;- matrix(c(".", "~poly(Oil, 2)",
                      "~1", "."),
                    ncol = 2, byrow = TRUE)
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       formula = structure)
</pre>
</div>


<hr>
<a id="method-MarkovChain-formula"></a>



<h4>Method <code>formula()</code></h4>

<p>Formula of MarkovChain model
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$formula()</pre></div>


<hr>
<a id="method-MarkovChain-formulas"></a>



<h4>Method <code>formulas()</code></h4>

<p>List of formulas for MarkovChain model
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$formulas()</pre></div>


<hr>
<a id="method-MarkovChain-tpm"></a>



<h4>Method <code>tpm()</code></h4>

<p>Get transition probability matrices
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$tpm(t = 1, linpred = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>Time index or vector of time indices; default = 1. If t = &quot;all&quot; 
then all transition probability matrices are returned.</p>
</dd>
<dt><code>linpred</code></dt><dd><p>Optional custom linear predictor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Array with one slice for each transition probability matrix
</p>


<hr>
<a id="method-MarkovChain-ref"></a>



<h4>Method <code>ref()</code></h4>

<p>Indices of reference elements in transition probability
matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$ref()</pre></div>


<hr>
<a id="method-MarkovChain-ref_mat"></a>



<h4>Method <code>ref_mat()</code></h4>

<p>Matrix of reference elements in transition probability
matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$ref_mat()</pre></div>


<hr>
<a id="method-MarkovChain-ref_delta0"></a>



<h4>Method <code>ref_delta0()</code></h4>

<p>Indices of reference elements in initial distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$ref_delta0()</pre></div>


<hr>
<a id="method-MarkovChain-coeff_fe"></a>



<h4>Method <code>coeff_fe()</code></h4>

<p>Current parameter estimates (fixed effects)
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$coeff_fe()</pre></div>


<hr>
<a id="method-MarkovChain-delta"></a>



<h4>Method <code>delta()</code></h4>

<p>Stationary distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$delta(t = NULL, linpred = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>Time point(s) for which stationary distribution should be returned. 
If t = &quot;all&quot;, all deltas are returned; else this should be a vector of
time indices. If NULL (default), the stationary distribution for the first
time step is returned.</p>
</dd>
<dt><code>linpred</code></dt><dd><p>Optional custom linear predictor</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix of stationary distributions. Each row corresponds to
a row of the design matrices, and each column corresponds to a state.
</p>


<hr>
<a id="method-MarkovChain-delta0"></a>



<h4>Method <code>delta0()</code></h4>

<p>Initial distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$delta0(log = FALSE, as_matrix = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>log</code></dt><dd><p>Logical indicating whether to return the log of the initial
probabilities (default: FALSE). If TRUE, then the last element is
excluded, as it is not estimated.</p>
</dd>
<dt><code>as_matrix</code></dt><dd><p>Logical indicating whether the output should be
formatted as a matrix (default). If as_matrix is FALSE and log is
TRUE, the result is formatted as a column vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix with one row for each time series ID, and one column
for each state. For each ID, the i-th element of the corresponding 
row is the probability Pr(S[1] = i)
</p>


<hr>
<a id="method-MarkovChain-stationary"></a>



<h4>Method <code>stationary()</code></h4>

<p>Use stationary distribution as initial distribution?
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$stationary()</pre></div>


<hr>
<a id="method-MarkovChain-fixpar"></a>



<h4>Method <code>fixpar()</code></h4>

<p>Fixed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$fixpar(all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>Logical. If FALSE, only user-specified fixed
parameters are returned, but not parameters that are fixed
for some other reason (e.g., from '.' in formula)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-coeff_re"></a>



<h4>Method <code>coeff_re()</code></h4>

<p>Current parameter estimates (random effects)
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$coeff_re()</pre></div>


<hr>
<a id="method-MarkovChain-X_fe"></a>



<h4>Method <code>X_fe()</code></h4>

<p>Fixed effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$X_fe()</pre></div>


<hr>
<a id="method-MarkovChain-X_re"></a>



<h4>Method <code>X_re()</code></h4>

<p>Random effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$X_re()</pre></div>


<hr>
<a id="method-MarkovChain-lambda"></a>



<h4>Method <code>lambda()</code></h4>

<p>Smoothness parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$lambda()</pre></div>


<hr>
<a id="method-MarkovChain-sd_re"></a>



<h4>Method <code>sd_re()</code></h4>

<p>Standard deviation of smooth terms
</p>
<p>This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$sd_re()</pre></div>


<hr>
<a id="method-MarkovChain-nstates"></a>



<h4>Method <code>nstates()</code></h4>

<p>Number of states
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$nstates()</pre></div>


<hr>
<a id="method-MarkovChain-terms"></a>



<h4>Method <code>terms()</code></h4>

<p>Terms of model formulas
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$terms()</pre></div>


<hr>
<a id="method-MarkovChain-unique_ID"></a>



<h4>Method <code>unique_ID()</code></h4>

<p>Number of time series
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$unique_ID()</pre></div>


<hr>
<a id="method-MarkovChain-initial_state"></a>



<h4>Method <code>initial_state()</code></h4>

<p>Initial state (see constructor argument)
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$initial_state()</pre></div>


<hr>
<a id="method-MarkovChain-update_tpm"></a>



<h4>Method <code>update_tpm()</code></h4>

<p>Update transition probability matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_tpm(tpm)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tpm</code></dt><dd><p>New transition probability matrix</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_coeff_fe"></a>



<h4>Method <code>update_coeff_fe()</code></h4>

<p>Update coefficients for fixed effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_coeff_fe(coeff_fe)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coeff_fe</code></dt><dd><p>Vector of coefficients for fixed effect parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_coeff_re"></a>



<h4>Method <code>update_coeff_re()</code></h4>

<p>Update coefficients for random effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_coeff_re(coeff_re)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coeff_re</code></dt><dd><p>Vector of coefficients for random effect parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_X_fe"></a>



<h4>Method <code>update_X_fe()</code></h4>

<p>Update design matrix for fixed effects
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_X_fe(X_fe)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X_fe</code></dt><dd><p>new design matrix for fixed effects</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_X_re"></a>



<h4>Method <code>update_X_re()</code></h4>

<p>Update design matrix for random effects
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_X_re(X_re)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X_re</code></dt><dd><p>new design matrix for random effects</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_delta0"></a>



<h4>Method <code>update_delta0()</code></h4>

<p>Update initial distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_delta0(delta0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delta0</code></dt><dd><p>Either a matrix where the i-th row is the initial
distribution for the i-th time series in the data, or a vector which is
then used for all time series. Entries of each row of delta0 should sum
to one.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_lambda"></a>



<h4>Method <code>update_lambda()</code></h4>

<p>Update smoothness parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_lambda(lambda)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lambda</code></dt><dd><p>New smoothness parameter vector</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-update_fixpar"></a>



<h4>Method <code>update_fixpar()</code></h4>

<p>Update information about fixed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$update_fixpar(fixpar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fixpar</code></dt><dd><p>New list of fixed parameters, in the same format
expected by MarkovChain$new()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MarkovChain-make_mat"></a>



<h4>Method <code>make_mat()</code></h4>

<p>Make model matrices
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$make_mat(data, new_data = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Data frame containing all needed covariates</p>
</dd>
<dt><code>new_data</code></dt><dd><p>Optional new data set, including covariates for which
the design matrices should be created. This needs to be passed in addition
to the argument '<code>data</code>', for cases where smooth terms or factor
covariates are included, and the original data set is needed to determine
the full range of covariate values.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt>X_fe</dt><dd><p>Design matrix for fixed effects</p>
</dd>
<dt>X_re</dt><dd><p>Design matrix for random effects</p>
</dd>
<dt>S</dt><dd><p>Smoothness matrix for random effects</p>
</dd>
<dt>ncol_fe</dt><dd><p>Number of columns of X_fe for each parameter</p>
</dd>
<dt>ncol_re</dt><dd><p>Number of columns of X_re and S for each random effect</p>
</dd>
</dl>



<hr>
<a id="method-MarkovChain-make_mat_grid"></a>



<h4>Method <code>make_mat_grid()</code></h4>

<p>Design matrices for grid of covariates
</p>
<p>Used in plotting functions such as HMM$plot_tpm and HMM$plot_stat_dist
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$make_mat_grid(var, data, covs = NULL, n_grid = 1000)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>Name of variable</p>
</dd>
<dt><code>data</code></dt><dd><p>Data frame containing the covariates</p>
</dd>
<dt><code>covs</code></dt><dd><p>Optional named list for values of covariates (other than 'var') 
that should be used in the plot (or dataframe with single row). If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.</p>
</dd>
<dt><code>n_grid</code></dt><dd><p>Grid size (number of points). Default: 1000.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the same elements as the output of make_mat, 
plus a data frame of covariates values.
</p>


<hr>
<a id="method-MarkovChain-tpm2par"></a>



<h4>Method <code>tpm2par()</code></h4>

<p>Transform transition probabilities to working scale
</p>
<p>Apply the multinomial logit link function to get the corresponding 
parameters on the working scale (i.e., linear predictor scale).
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$tpm2par(tpm)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tpm</code></dt><dd><p>Transition probability matrix</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of parameters on linear predictor scale
</p>


<hr>
<a id="method-MarkovChain-par2tpm"></a>



<h4>Method <code>par2tpm()</code></h4>

<p>Transform working parameters to transition probabilities
</p>
<p>Apply the inverse multinomial logit link function to transform the 
parameters on the working scale (i.e., linear predictor scale) into 
the transition probabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$par2tpm(par)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>par</code></dt><dd><p>Vector of parameters on working scale</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Transition probability matrix
</p>


<hr>
<a id="method-MarkovChain-linpred"></a>



<h4>Method <code>linpred()</code></h4>

<p>Linear predictor for transition probabilities
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$linpred()</pre></div>


<hr>
<a id="method-MarkovChain-simulate"></a>



<h4>Method <code>simulate()</code></h4>

<p>Simulate from Markov chain
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$simulate(n, data = NULL, new_data = NULL, silent = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of time steps to simulate</p>
</dd>
<dt><code>data</code></dt><dd><p>Optional data frame containing all needed covariates</p>
</dd>
<dt><code>new_data</code></dt><dd><p>Optional new data set, including covariates for which
the design matrices should be created. This needs to be passed in addition
to the argument '<code>data</code>', for cases where smooth terms or factor
covariates are included, and the original data set is needed to determine
the full range of covariate values.</p>
</dd>
<dt><code>silent</code></dt><dd><p>if TRUE then no messages are printed</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Sequence of states of simulated chain
</p>


<hr>
<a id="method-MarkovChain-formulation"></a>



<h4>Method <code>formulation()</code></h4>

<p>Print model formulation
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$formulation()</pre></div>


<hr>
<a id="method-MarkovChain-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print MarkovChain object
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$print()</pre></div>


<hr>
<a id="method-MarkovChain-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MarkovChain$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `MarkovChain$new`
## ------------------------------------------------

# Load data set from MSwM package
data(energy, package = "MSwM")

# Create 2-state covariate-free model and initialise transition 
# probability matrix
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       tpm = matrix(c(0.8, 0.3, 0.2, 0.7), 2, 2))

# Create 2-state model with non-linear effect of Oil on all transition 
# probabilities
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       formula = ~ s(Oil, k = 5, bs = "cs"))

# Create 2-state model with quadratic effect of Oil on Pr(1 &gt; 2)
structure &lt;- matrix(c(".", "~poly(Oil, 2)",
                      "~1", "."),
                    ncol = 2, byrow = TRUE)
hid &lt;- MarkovChain$new(data = energy, n_states = 2,
                       formula = structure)
</code></pre>

<hr>
<h2 id='mlogit'>Multivariate logit function</h2><span id='topic+mlogit'></span>

<h3>Description</h3>

<p>Multivariate logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlogit_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='mvnorm_invlink'>Multivariate Normal inverse link function</h2><span id='topic+mvnorm_invlink'></span>

<h3>Description</h3>

<p>Multivariate Normal inverse link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnorm_invlink(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvnorm_invlink_+3A_x">x</code></td>
<td>
<p>Vector of parameters on linear predictor scale (in the order:
means, SDs, correlations)</p>
</td></tr>
</table>

<hr>
<h2 id='mvnorm_link'>Multivariate Normal link function</h2><span id='topic+mvnorm_link'></span>

<h3>Description</h3>

<p>Multivariate Normal link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnorm_link(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvnorm_link_+3A_x">x</code></td>
<td>
<p>Vector of parameters on natural scale (in the order: means,
SDs, correlations)</p>
</td></tr>
</table>

<hr>
<h2 id='na_fill'>Fill in NAs</h2><span id='topic+na_fill'></span>

<h3>Description</h3>

<p>Replace NA entries in a vector by the last non-NA value. If the first
entry of the vector is NA, it is replaced by the first non-NA value. If the
vector passed as input doesn't contain NAs, it is returned as is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_fill(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_fill_+3A_x">x</code></td>
<td>
<p>Vector in which NAs should be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Copy of x in which NAs have been replaced by nearest available value.
</p>

<hr>
<h2 id='Observation'>R6 class for HMM observation model</h2><span id='topic+Observation'></span>

<h3>Description</h3>

<p>Contains the data, distributions, parameters, and formulas for
the observation model from a hidden Markov model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Observation-new"><code>Observation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-data"><code>Observation$data()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-dists"><code>Observation$dists()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-nstates"><code>Observation$nstates()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-par"><code>Observation$par()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-inipar"><code>Observation$inipar()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-coeff_fe"><code>Observation$coeff_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-coeff_re"><code>Observation$coeff_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-X_fe"><code>Observation$X_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-X_re"><code>Observation$X_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-lambda"><code>Observation$lambda()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-sd_re"><code>Observation$sd_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-formulas"><code>Observation$formulas()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-terms"><code>Observation$terms()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-obs_var"><code>Observation$obs_var()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-known_states"><code>Observation$known_states()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-fixpar"><code>Observation$fixpar()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_par"><code>Observation$update_par()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_coeff_fe"><code>Observation$update_coeff_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_coeff_re"><code>Observation$update_coeff_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_X_fe"><code>Observation$update_X_fe()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_X_re"><code>Observation$update_X_re()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_lambda"><code>Observation$update_lambda()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_data"><code>Observation$update_data()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-update_fixpar"><code>Observation$update_fixpar()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-make_mat"><code>Observation$make_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-make_newdata_grid"><code>Observation$make_newdata_grid()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-n2w"><code>Observation$n2w()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-w2n"><code>Observation$w2n()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-linpred"><code>Observation$linpred()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-obs_probs"><code>Observation$obs_probs()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-cdf"><code>Observation$cdf()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-suggest_initial"><code>Observation$suggest_initial()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-plot_dist"><code>Observation$plot_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-formulation"><code>Observation$formulation()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-print"><code>Observation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Observation-clone"><code>Observation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Observation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create new Observation object
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$new(data, dists, formulas = NULL, n_states, par, fixpar = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Data frame containing response variables (named in dists
and par) and covariates (named in formulas)</p>
</dd>
<dt><code>dists</code></dt><dd><p>Named list of distribution names for each data stream,
with the following options: beta, binom, cat, dir, exp, foldednorm, 
gamma, gamma2, lnorm, mvnorm, nbinom, norm, pois, t, truncnorm, tweedie, 
vm, weibull, wrpcauchy, zibinom, zigamma, zigamma2, zinbinom, zipois, 
ztnbinom, ztpois. See vignette about list of distributions for more 
detail, e.g., list of parameters for each distribution.</p>
</dd>
<dt><code>formulas</code></dt><dd><p>List of formulas for observation parameters. This should
be a nested list, where the outer list has one element for each
observed variable, and the inner lists have one element for each
parameter. Any parameter that is not included is assumed to have the
formula ~1. By default, all parameters have the formula ~1 (i.e., no
covariate effects).</p>
</dd>
<dt><code>n_states</code></dt><dd><p>Number of states (needed to construct model formulas)</p>
</dd>
<dt><code>par</code></dt><dd><p>List of initial observation parameters. This should
be a nested list, where the outer list has one element for each
observed variable, and the inner lists have one element for each
parameter. The choice of good initial values can be important, especially
for complex models; the package vignettes discuss approaches to selecting
them (e.g., see <code>Observation$suggest_initial()</code>).</p>
</dd>
<dt><code>fixpar</code></dt><dd><p>List with optional elements &quot;obs&quot; (fixed coefficients for
observation parameters), and &quot;lambda_obs&quot; (fixed smoothness parameters),
Each element is a named vector of coefficients that should either be 
fixed (if the corresponding element is set to NA) or estimated to a 
common value (using integers or factor levels).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new Observation object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model "energy" with normal distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2)
                       
# Model "energy" with gamma distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "gamma2"),
                       par = par0,
                       n_states = 2)
                       
# Model with non-linear effect of EurDol on mean price
f &lt;- list(Price = list(mean = ~ s(EurDol, k = 5, bs = "cs")))
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2, 
                       formula = f)
</pre>
</div>


<hr>
<a id="method-Observation-data"></a>



<h4>Method <code>data()</code></h4>

<p>Data frame
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$data()</pre></div>


<hr>
<a id="method-Observation-dists"></a>



<h4>Method <code>dists()</code></h4>

<p>List of distributions
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$dists()</pre></div>


<hr>
<a id="method-Observation-nstates"></a>



<h4>Method <code>nstates()</code></h4>

<p>Number of states
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$nstates()</pre></div>


<hr>
<a id="method-Observation-par"></a>



<h4>Method <code>par()</code></h4>

<p>Parameters on natural scale
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$par(t = 1, full_names = TRUE, linpred = NULL, as_list = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>Time index or vector of time indices; default t = 1. If 
t = &quot;all&quot;, then return observation parameters for all time points.</p>
</dd>
<dt><code>full_names</code></dt><dd><p>Logical. If TRUE, the rows of the output
are named in the format &quot;variable.parameter&quot; (default). If
FALSE, the rows are names in the format &quot;parameter&quot;. The
latter is used in various internal functions, when the parameters
need to be passed on to an R function.</p>
</dd>
<dt><code>linpred</code></dt><dd><p>Optional custom linear predictor.</p>
</dd>
<dt><code>as_list</code></dt><dd><p>Logical. If TRUE, the output is a nested list with three levels:
(1) time step, (2) observed variable, (3) observation parameter. If FALSE (default),
the output is an array with one row for each observation parameter, one column for
each state, and one slice for each time step.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Array of parameters with one row for each observation parameter, 
one column for each state, and one slice for each time step. (See as_list
argument for alternative output format.)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model with linear effect of EurDol on mean price
f &lt;- list(Price = list(mean = ~ EurDol))
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2, 
                       formula = f)

# Set slope coefficients
obs$update_coeff_fe(coeff_fe = c(3, 2, 6, -2, log(2), log(2)))

# Observation parameter values for given data rows
obs$par(t = c(1, 10, 20))
</pre>
</div>


<hr>
<a id="method-Observation-inipar"></a>



<h4>Method <code>inipar()</code></h4>

<p>Return initial parameter values supplied
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$inipar()</pre></div>


<hr>
<a id="method-Observation-coeff_fe"></a>



<h4>Method <code>coeff_fe()</code></h4>

<p>Fixed effect parameters on working scale
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$coeff_fe()</pre></div>


<hr>
<a id="method-Observation-coeff_re"></a>



<h4>Method <code>coeff_re()</code></h4>

<p>Random effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$coeff_re()</pre></div>


<hr>
<a id="method-Observation-X_fe"></a>



<h4>Method <code>X_fe()</code></h4>

<p>Fixed effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$X_fe()</pre></div>


<hr>
<a id="method-Observation-X_re"></a>



<h4>Method <code>X_re()</code></h4>

<p>Random effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$X_re()</pre></div>


<hr>
<a id="method-Observation-lambda"></a>



<h4>Method <code>lambda()</code></h4>

<p>Smoothness parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$lambda()</pre></div>


<hr>
<a id="method-Observation-sd_re"></a>



<h4>Method <code>sd_re()</code></h4>

<p>Standard deviation of smooth terms
</p>
<p>This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$sd_re()</pre></div>


<hr>
<a id="method-Observation-formulas"></a>



<h4>Method <code>formulas()</code></h4>

<p>List of model formulas for observation model
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$formulas(raw = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw</code></dt><dd><p>Logical. If FALSE, returns the nested list created by
make_formulas (default). If TRUE, returns formulas passed as input.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-terms"></a>



<h4>Method <code>terms()</code></h4>

<p>Terms of model formulas
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$terms()</pre></div>


<hr>
<a id="method-Observation-obs_var"></a>



<h4>Method <code>obs_var()</code></h4>

<p>Data frame of response variables
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$obs_var(expand = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expand</code></dt><dd><p>If TRUE, then multivariate variables in observations are 
expanded to be univariate, creating extra columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Data frame of observation variables
</p>


<hr>
<a id="method-Observation-known_states"></a>



<h4>Method <code>known_states()</code></h4>

<p>Vector of known states
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$known_states(mat = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mat</code></dt><dd><p>Logical.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-fixpar"></a>



<h4>Method <code>fixpar()</code></h4>

<p>Fixed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$fixpar(all = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>all</code></dt><dd><p>Logical. If FALSE, only user-specified fixed
parameters are returned, but not parameters that are fixed
for some other reason (e.g., size of binomial distribution)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_par"></a>



<h4>Method <code>update_par()</code></h4>

<p>Update parameters
</p>
<p>Updates the 'par' attribute to the list passed as input,
and updates the intercept elements of 'coeff_fe' using
the list passed as input
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_par(par)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>par</code></dt><dd><p>New list of parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_coeff_fe"></a>



<h4>Method <code>update_coeff_fe()</code></h4>

<p>Update coefficients for fixed effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_coeff_fe(coeff_fe)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coeff_fe</code></dt><dd><p>New vector of coefficients for fixed effect 
parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_coeff_re"></a>



<h4>Method <code>update_coeff_re()</code></h4>

<p>Update random effect parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_coeff_re(coeff_re)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>coeff_re</code></dt><dd><p>New vector of coefficients for random effect 
parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_X_fe"></a>



<h4>Method <code>update_X_fe()</code></h4>

<p>Update fixed effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_X_fe(X_fe)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X_fe</code></dt><dd><p>New fixed effect design matrix</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_X_re"></a>



<h4>Method <code>update_X_re()</code></h4>

<p>Update random effect design matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_X_re(X_re)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X_re</code></dt><dd><p>New random effect design matrix</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_lambda"></a>



<h4>Method <code>update_lambda()</code></h4>

<p>Update smoothness parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_lambda(lambda)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lambda</code></dt><dd><p>New smoothness parameter vector</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_data"></a>



<h4>Method <code>update_data()</code></h4>

<p>Update data
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_data(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>New data frame</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-update_fixpar"></a>



<h4>Method <code>update_fixpar()</code></h4>

<p>Update information about fixed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$update_fixpar(fixpar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fixpar</code></dt><dd><p>New list of fixed parameters, in the same format
expected by Observation$new()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Observation-make_mat"></a>



<h4>Method <code>make_mat()</code></h4>

<p>Make model matrices
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$make_mat(new_data = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_data</code></dt><dd><p>Optional new data set, including covariates for which
the design matrices should be created. If this argument is not specified,
the design matrices are based on the original data frame.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with elements:
</p>

<dl>
<dt>X_fe</dt><dd><p>Design matrix for fixed effects</p>
</dd>
<dt>X_re</dt><dd><p>Design matrix for random effects</p>
</dd>
<dt>S</dt><dd><p>Smoothness matrix for random effects</p>
</dd>
<dt>ncol_fe</dt><dd><p>Number of columns of X_fe for each parameter</p>
</dd>
<dt>ncol_re</dt><dd><p>Number of columns of X_re and S for each random effect</p>
</dd>
</dl>



<hr>
<a id="method-Observation-make_newdata_grid"></a>



<h4>Method <code>make_newdata_grid()</code></h4>

<p>Design matrices for grid of covariates
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$make_newdata_grid(var, covs = NULL, n_grid = 1000)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>Name of variable</p>
</dd>
<dt><code>covs</code></dt><dd><p>Optional named list for values of covariates (other than 'var') 
that should be used in the plot (or dataframe with single row). If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.</p>
</dd>
<dt><code>n_grid</code></dt><dd><p>Grid size (number of points). Default: 1000.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the same elements as the output of make_mat, 
plus a data frame of covariates values.
</p>


<hr>
<a id="method-Observation-n2w"></a>



<h4>Method <code>n2w()</code></h4>

<p>Natural to working parameter transformation
</p>
<p>This function applies the link functions of the distribution
parameters, to transform parameters from their natural scale
to the working scale (i.e., linear predictor scale)
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$n2w(par)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>par</code></dt><dd><p>List of parameters on natural scale</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of parameters on working scale
</p>


<hr>
<a id="method-Observation-w2n"></a>



<h4>Method <code>w2n()</code></h4>

<p>Working to natural parameter transformation
</p>
<p>This function applies the inverse link functions of the
distribution parameters, to transform parameters from the working
scale (i.e., linear predictor scale) to their natural scale.
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$w2n(wpar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wpar</code></dt><dd><p>Vector of parameters on working scale</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of parameters on natural scale
</p>


<hr>
<a id="method-Observation-linpred"></a>



<h4>Method <code>linpred()</code></h4>

<p>Compute linear predictor
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$linpred()</pre></div>


<hr>
<a id="method-Observation-obs_probs"></a>



<h4>Method <code>obs_probs()</code></h4>

<p>Observation likelihoods
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$obs_probs(data = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>Optional dataframe to include in form of obs_var() output</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Matrix of likelihoods of observations, with one row for each 
time step, and one column for each state.
</p>


<hr>
<a id="method-Observation-cdf"></a>



<h4>Method <code>cdf()</code></h4>

<p>Cumulative probabilities of observations
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$cdf()</pre></div>



<h5>Returns</h5>

<p>List of cumulative probabilities, with one element for each
observed variable. Matrix rows correspond to time steps, and columns
correspond to states.
</p>


<hr>
<a id="method-Observation-suggest_initial"></a>



<h4>Method <code>suggest_initial()</code></h4>

<p>Suggest initial observation parameters
</p>
<p>The K-means algorithm is used to define clusters of observations
(supposed to approximate the HMM states). Then, for each cluster,
the <code>parapprox</code> function of the relevant <code>Dist</code> object
is used to obtain parameter values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$suggest_initial()</pre></div>



<h5>Returns</h5>

<p>List of initial parameters for each observation variable
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model "energy" with normal distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2)

# Print observation parameters
obs$par()

# Suggest initial parameters
par0_new &lt;- obs$suggest_initial()
par0_new

# Update model parameters to suggested
obs$update_par(par = par0_new)
obs$par()
</pre>
</div>


<hr>
<a id="method-Observation-plot_dist"></a>



<h4>Method <code>plot_dist()</code></h4>

<p>Plot histogram of data and pdfs
</p>
<p>Plot histogram of observations for the variable specified by the argument name, 
overlaid with the pdf of the specified distribution for that data stream. 
Helpful to select initial parameter values for model fitting, or to visualise 
fitted state-dependent distributions.
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$plot_dist(var, weights = NULL, t = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var</code></dt><dd><p>Name of response variable for which the histogram
and pdfs should be plotted.</p>
</dd>
<dt><code>weights</code></dt><dd><p>Optional vector of length the number of pdfs that are
plotted. Useful to visualise a mixture of distributions weighted by the
proportion of time spent in the different states.</p>
</dd>
<dt><code>t</code></dt><dd><p>Index of time step to use for covariates (default: 1).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A ggplot object
</p>


<hr>
<a id="method-Observation-formulation"></a>



<h4>Method <code>formulation()</code></h4>

<p>Print model formulation
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$formulation()</pre></div>


<hr>
<a id="method-Observation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print Observation object
Check constructor arguments
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$print()</pre></div>


<hr>
<a id="method-Observation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Observation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Observation$new`
## ------------------------------------------------

# Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model "energy" with normal distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2)
                       
# Model "energy" with gamma distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "gamma2"),
                       par = par0,
                       n_states = 2)
                       
# Model with non-linear effect of EurDol on mean price
f &lt;- list(Price = list(mean = ~ s(EurDol, k = 5, bs = "cs")))
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2, 
                       formula = f)

## ------------------------------------------------
## Method `Observation$par`
## ------------------------------------------------

# Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model with linear effect of EurDol on mean price
f &lt;- list(Price = list(mean = ~ EurDol))
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2, 
                       formula = f)

# Set slope coefficients
obs$update_coeff_fe(coeff_fe = c(3, 2, 6, -2, log(2), log(2)))

# Observation parameter values for given data rows
obs$par(t = c(1, 10, 20))

## ------------------------------------------------
## Method `Observation$suggest_initial`
## ------------------------------------------------

# Load data set from MSwM package
data(energy, package = "MSwM")

# Initial observation parameters
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 2)))

# Model "energy" with normal distributions
obs &lt;- Observation$new(data = energy, 
                       dists = list(Price = "norm"),
                       par = par0,
                       n_states = 2)

# Print observation parameters
obs$par()

# Suggest initial parameters
par0_new &lt;- obs$suggest_initial()
par0_new

# Update model parameters to suggested
obs$update_par(par = par0_new)
obs$par()
</code></pre>

<hr>
<h2 id='prec_to_cov'>Get covariance matrix from precision matrix</h2><span id='topic+prec_to_cov'></span>

<h3>Description</h3>

<p>The covariance matrix is the inverse of the precision matrix. By default,
the function <code>solve</code> is used for inversion. If it fails (e.g.,
singular system), then <code>MASS::ginv</code> is used instead, and returns the
Moore-Penrose generalised inverse of the precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prec_to_cov(prec_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prec_to_cov_+3A_prec_mat">prec_mat</code></td>
<td>
<p>Precision matrix (either of 'matrix' type
or sparse matrix on which as.matrix can be used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precision matrix
</p>

<hr>
<h2 id='quad_pos_solve'>Solve for positive root of quadratic ax^2 + bx + c = 0 when it exists</h2><span id='topic+quad_pos_solve'></span>

<h3>Description</h3>

<p>Solve for positive root of quadratic ax^2 + bx + c = 0 when it exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quad_pos_solve(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad_pos_solve_+3A_a">a</code></td>
<td>
<p>coefficient of x^2</p>
</td></tr>
<tr><td><code id="quad_pos_solve_+3A_b">b</code></td>
<td>
<p>coefficient of x</p>
</td></tr>
<tr><td><code id="quad_pos_solve_+3A_c">c</code></td>
<td>
<p>scalar coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>real positive root if it exists
</p>

<hr>
<h2 id='strip_comments'>Strip comments marked with a hash from a character vector</h2><span id='topic+strip_comments'></span>

<h3>Description</h3>

<p>Strip comments marked with a hash from a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_comments(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_comments_+3A_str">str</code></td>
<td>
<p>the character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with comments removed (and lines with only comments
completely removed)
</p>

<hr>
<h2 id='update.HMM'>Update a model to a new model by changing one formula</h2><span id='topic+update.HMM'></span>

<h3>Description</h3>

<p>Update a model to a new model by changing one formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HMM'
update(object, type, i, j, change, fit = TRUE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.HMM_+3A_object">object</code></td>
<td>
<p>HMM model object</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_type">type</code></td>
<td>
<p>Character string for the part of the model that is updated
(either &quot;hid&quot; or &quot;obs&quot;)</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_i">i</code></td>
<td>
<p>If type = &quot;hid&quot; then i is the row of the formula containing the 
change. If type = &quot;obs&quot; then i is the observation variable name.</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_j">j</code></td>
<td>
<p>If type = &quot;hid&quot; then j is the column of the formula containing the 
change. If type = &quot;obs&quot; then j is the parameter whose formula is to be 
changed.</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_change">change</code></td>
<td>
<p>The change to make to the formula, see ?update.formula for 
details.</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_fit">fit</code></td>
<td>
<p>If FALSE then change is made but model is not re-fit.</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_silent">silent</code></td>
<td>
<p>If TRUE then no model fitting output is given</p>
</td></tr>
<tr><td><code id="update.HMM_+3A_...">...</code></td>
<td>
<p>Additional arguments are ignored (for compatibility with generic
S3 method)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set from MSwM package
data(energy, package = "MSwM")

# Create hidden state and observation models
hid &lt;- MarkovChain$new(data = energy, n_states = 2)
par0 &lt;- list(Price = list(mean = c(3, 6), sd = c(2, 3)))
obs &lt;- Observation$new(data = energy, n_states = 2,
                       dists = list(Price = "norm"),
                       par = par0)

# Create HMM (no covariate effects)
hmm &lt;- HMM$new(hid = hid, obs = obs)
hmm$hid()$formula()
hmm$obs()$formulas()

# Update transition probability formulas (one at a time)
hmm &lt;- update(hmm, type = "hid", i = 1, j = 2, 
              change = ~ . + Oil, fit = FALSE)
hmm &lt;- update(hmm, type = "hid", i = 2, j = 1, 
              change = ~ . + Gas + Coal, fit = FALSE)
hmm$hid()$formula()

# Update observation parameter formulas (one at a time)
hmm &lt;- update(hmm, type = "obs", i = "Price", j = "mean", 
              change = ~ . + EurDol, fit = FALSE)
hmm$obs()$formulas()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
