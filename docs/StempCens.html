<!DOCTYPE html><html><head><title>Help for package StempCens</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StempCens}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CovarianceM'><p>Covariance matrix for spatio-temporal model</p></a></li>
<li><a href='#CrossStempCens'><p>Cross-Validation in spatio-temporal model with censored/missing responses</p></a></li>
<li><a href='#DiagStempCens'><p>Diagnostic in spatio-temporal model with censored/missing responses</p></a></li>
<li><a href='#EffectiveRange'><p>Effective range for some spatial correlation functions</p></a></li>
<li><a href='#EstStempCens'><p>ML estimation in spatio-temporal model with censored/missing responses</p></a></li>
<li><a href='#PredStempCens'><p>Prediction in spatio-temporal model with censored/missing responses</p></a></li>
<li><a href='#StempCens-package'>
<p>Spatio-Temporal Estimation and Prediction for Censored/Missing Responses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatio-Temporal Estimation and Prediction for Censored/Missing
Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>It estimates the parameters of a censored or missing data in spatio-temporal models using the SAEM algorithm (Delyon et al., 1999). This algorithm is a stochastic approximation of the widely used EM algorithm and an important tool for models in which the E-step does not have an analytic form. Besides the expressions obtained to estimate the parameters to the proposed model, we include the calculations for the observed information matrix using the method developed by Louis (1982). To examine the performance of the fitted model, case-deletion measure are provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, utils, mvtnorm, tmvtnorm, MCMCglmm, ggplot2,
grid, distances, Rdpack</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-20 22:18:22 UTC; 55199</td>
</tr>
<tr>
<td>Author:</td>
<td>Larissa A. Matos <a href="https://orcid.org/0000-0002-2635-0901"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Katherine L. Valeriano
    <a href="https://orcid.org/0000-0001-6388-4753"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Victor H. Lachos <a href="https://orcid.org/0000-0002-7239-2459"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Larissa A. Matos &lt;larissa.amatos@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-21 20:20:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='CovarianceM'>Covariance matrix for spatio-temporal model</h2><span id='topic+CovarianceM'></span>

<h3>Description</h3>

<p>It computes the spatio-temporal covariance matrix for balanced data, i.e., when we have the same temporal indexes
per location. To compute the spatial correlation it provides 5 functions: exponential, gaussian, matern,
spherical and power exponential. To compute the temporal correlation is used an autocorrelation function of an AR(1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovarianceM(phi, rho, tau2, sigma2, distSpa, disTemp, kappa, type.S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovarianceM_+3A_phi">phi</code></td>
<td>
<p>value of the spatial scaling parameter.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_rho">rho</code></td>
<td>
<p>value of the time scaling parameter.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_tau2">tau2</code></td>
<td>
<p>value of the the nugget effect parameter.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_sigma2">sigma2</code></td>
<td>
<p>value of the partial sill.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_distspa">distSpa</code></td>
<td>
<p><code class="reqn">n x n</code> spatial distance matrix without considering repetitions.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_distemp">disTemp</code></td>
<td>
<p><code class="reqn">T x T</code> temporal distance matrix without considering repetitions.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_kappa">kappa</code></td>
<td>
<p>parameter for all spatial covariance functions. In the case of exponential, gaussian and spherical function <code class="reqn">\kappa</code> is equal to zero.
For the power exponential function <code class="reqn">\kappa</code> is a number between 0 and 2. For the matern correlation function is upper than 0.</p>
</td></tr>
<tr><td><code id="CovarianceM_+3A_type.s">type.S</code></td>
<td>
<p>type of spatial correlation function: '<code>exponential</code>' for exponential, '<code>gaussian</code>' for gaussian,
'<code>matern</code>' for matern, '<code>pow.exp</code>' for power exponential and '<code>spherical</code>' for spherical function, respectively.
See the analytical form of these functions in <code><a href="#topic+EffectiveRange">EffectiveRange</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the <code class="reqn">nT x nT</code> spatio-temporal covariance matrix for balanced data.
</p>


<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initial parameter values
phi &lt;- 5;     rho &lt;- 0.45
tau2 &lt;- 0.80; sigma2 &lt;- 2
# Simulating data
n1 &lt;- 10   # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(1000)
x.co &lt;- round(runif(n1,0,10),5)  # X coordinate
y.co &lt;- round(runif(n1,0,10),5)  # Y coordinate
coord &lt;- cbind(x.co,y.co)        # Cartesian coordinates without repetitions
time &lt;- as.matrix(seq(1,n2))     # Time index without repetitions
# Covariance matrix
Ms &lt;- as.matrix(dist(coord))     # Spatial distances
Mt &lt;- as.matrix(dist(time))      # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,distSpa=Ms,disTemp=Mt,kappa=0,type.S="exponential")
</code></pre>

<hr>
<h2 id='CrossStempCens'>Cross-Validation in spatio-temporal model with censored/missing responses</h2><span id='topic+CrossStempCens'></span>

<h3>Description</h3>

<p>This function performs cross-validation in spatio-temporal model with censored/missing responses, which measure
the performance of the predictive model on new test dataset. The cross-validation method for assessing the
model performance is validation set approach (or data split).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossStempCens(Pred.StempCens, yObs.pre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossStempCens_+3A_pred.stempcens">Pred.StempCens</code></td>
<td>
<p>an object of class <code>Pred.StempCens</code> given as output by the <code><a href="#topic+PredStempCens">PredStempCens</a></code> function.</p>
</td></tr>
<tr><td><code id="CrossStempCens_+3A_yobs.pre">yObs.pre</code></td>
<td>
<p>a vector of the observed responses, the test data.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Bias</code></td>
<td>
<p>bias prediction error.</p>
</td></tr>
<tr><td><code>Mspe</code></td>
<td>
<p>mean squared prediction error.</p>
</td></tr>
<tr><td><code>Rmspe</code></td>
<td>
<p>root mean squared prediction error.</p>
</td></tr>
<tr><td><code>Mae</code></td>
<td>
<p>mean absolute error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EstStempCens">EstStempCens</a></code>, <code><a href="#topic+PredStempCens">PredStempCens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initial parameter values
beta &lt;- c(-1,1.50)
phi &lt;- 5;     rho &lt;- 0.6
tau2 &lt;- 0.80; sigma2 &lt;- 2
# Simulating data
n1 &lt;- 7    # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(400)
x.co &lt;- round(runif(n1,0,10),9)    # X coordinate
y.co &lt;- round(runif(n1,0,10),9)    # Y coordinate
coord &lt;- cbind(x.co,y.co)          # Cartesian coordinates without repetitions
coord2 &lt;- cbind(rep(x.co,each=n2),rep(y.co,each=n2)) # Cartesian coordinates with repetitions
time &lt;- as.matrix(seq(1,n2))       # Time index without repetitions
time2 &lt;- as.matrix(rep(time,n1))   # Time index with repetitions
x1 &lt;- rexp(n1*n2,2)
x2 &lt;- rnorm(n1*n2,2,1)
x  &lt;- cbind(x1,x2)
media &lt;- x%*%beta
# Covariance matrix
Ms &lt;- as.matrix(dist(coord))   # Spatial distances
Mt &lt;- as.matrix(dist(time))    # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,Ms,Mt,0,"gaussian")
# Data
require(mvtnorm)
y &lt;- as.vector(rmvnorm(1,mean=as.vector(media),sigma=Cov))
data &lt;- data.frame(coord2,time2,y,x)
names(data) &lt;- c("x.coord","y.coord","time","yObs","x1","x2")
# Splitting the dataset
local.est  &lt;- coord[c(1,2,4,5,6),]
data.est   &lt;- data[data$x.coord%in%local.est[,1] &amp; data$y.coord%in%local.est[,2],]
data.valid &lt;- data[data$x.coord%in%coord[c(3,7),1] &amp; data$y.coord%in%coord[c(3,7),2],]
# Censored
perc &lt;- 0.20
y  &lt;- data.est$yObs
aa &lt;- sort(y);  bb &lt;- aa[1:(perc*nrow(data.est))]
cutof &lt;- bb[perc*nrow(data.est)]
cc &lt;- matrix(1,nrow(data.est),1)*(y&lt;=cutof)
y[cc==1] &lt;- cutof
data.est &lt;- data.frame(data.est[,-c(4,5,6)],y,cc,data.est[,c(5,6)])
names(data.est) &lt;- c("x.coord","y.coord","time","yObs","censored","x1","x2")

# Estimation
y  &lt;- data.est$yObs
x  &lt;- cbind(data.est$x1,data.est$x2)
cc &lt;- data.est$censored
time2  &lt;- as.data.frame(data.est$time)
coord2 &lt;- data.est[,1:2]
LI &lt;- y; LI[cc==1] &lt;- -Inf     # Left-censored
LS &lt;- y
est_teste &lt;- EstStempCens(y, x, cc, time2, coord2, LI, LS, init.phi=3.5, init.rho=0.5,
                 init.tau2=1,type.Data="balanced", method="nlminb", kappa=0,
                 type.S="gaussian", IMatrix=FALSE, M=20, perc=0.25, MaxIter=300,
                 pc=0.20)
# Prediction
locPre &lt;- data.valid[,1:2]
timePre &lt;- as.data.frame(data.valid$time)
xPre &lt;- cbind(data.valid$x1,data.valid$x2)
pre_teste &lt;- PredStempCens(est_teste, locPre, timePre, xPre)
class(pre_teste)

# Cross-validation
cross_teste &lt;- CrossStempCens(pre_teste,data.valid$yObs)
cross_teste$Mspe # MSPE
## End(Not run)
</code></pre>

<hr>
<h2 id='DiagStempCens'>Diagnostic in spatio-temporal model with censored/missing responses</h2><span id='topic+DiagStempCens'></span>

<h3>Description</h3>

<p>Return measures and graphics for diagnostic analysis in spatio-temporal model with censored/missing responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiagStempCens(Est.StempCens, type.diag = "individual", diag.plot = TRUE, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiagStempCens_+3A_est.stempcens">Est.StempCens</code></td>
<td>
<p>an object of class <code>Est.StempCens</code> given as output by the <code><a href="#topic+EstStempCens">EstStempCens</a></code> function. In the <code>EstStempCens</code>function, <code>IMatrix</code> must be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DiagStempCens_+3A_type.diag">type.diag</code></td>
<td>
<p>type of diagnostic: '<code>individual</code>' is related when one observation is deleted,
'<code>time</code>' is related when an entire time is deleted, '<code>location</code>' is related when an entire location is deleted and
'<code>all</code>' the three cases ('<code>individual</code>', '<code>time</code>' and '<code>location</code>').
By default <code>type.diag</code> is <code>individual</code>.</p>
</td></tr>
<tr><td><code id="DiagStempCens_+3A_diag.plot">diag.plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. It indicates if diagnostic plots must be showed. By default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DiagStempCens_+3A_ck">ck</code></td>
<td>
<p>the value for <code>ck</code> considered in the benchmark value for the index plot:
<code class="reqn">mean(GD)+ck*sd(GD)</code>, where <code class="reqn">GD</code> is the vector with all values of the diagnostic measures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the case deletion approach to study the impact of deleting one or
more observations from the dataset on the parameters estimates, using the ideas of
Cook (1977) and Zhu et al. (2001).
The measure is defined by
</p>
<p><code class="reqn">GD_i(\theta*)=(\theta* - \theta*[i])'[-Q**(\theta|\theta*)](\theta* - \theta*[i]), i=1,....m,</code>
</p>
<p>where <code class="reqn">\theta*</code> is the estimate of <code class="reqn">\theta</code> using the complete data, <code class="reqn">\theta*[i]</code>
are the estimates obtained after deletion of the i-th observation (or group of observations) and
<code class="reqn">Q**(\theta|\theta*)</code> is the Hessian matrix.
</p>
<p>We can eliminate an observation, an entire location or an entire time index.
</p>


<h3>Value</h3>

<p>The function returns a list with the diagnostic measures.
</p>

<dl>
<dt>If <code>type.diag == individual | time | location</code>:</dt><dd>
<p><code>GD</code> is a data.frame with the index value of the observation and the GD measure.</p>
</dd>
<dt>If <code>type.diag == all</code>:</dt><dd>
<p><code>GDind</code> is a data.frame with the index value of the observation and the GD measure for individual.
</p>
<p><code>GDtime</code> is a data.frame with the time index value and the GD measure for time.
</p>
<p><code>GDloc</code> is a data.frame with the side index value and the GD measure for location.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EstStempCens">EstStempCens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initial parameter values
beta &lt;- c(-1,1.5)
phi &lt;- 3;   rho &lt;- 0.40
tau2 &lt;- 1;  sigma2 &lt;- 2
# Simulating data
n1 &lt;- 5    # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(98765)
x.co &lt;- round(runif(n1,0,10),9)   # X coordinate
y.co &lt;- round(runif(n1,0,10),9)   # Y coordinate
coord &lt;- cbind(x.co,y.co)         # Cartesian coordinates without repetitions
coord2 &lt;- cbind(rep(x.co,each=n2),rep(y.co,each=n2)) # Cartesian coordinates with repetitions
time &lt;- as.matrix(seq(1,n2))      # Time index without repetitions
time2 &lt;- as.matrix(rep(time,n1))  # Time index with repetitions
x1 &lt;- rexp(n1*n2,2)
x2 &lt;- rnorm(n1*n2,2,1)
x  &lt;- cbind(x1,x2)
media &lt;- x%*%beta
# Covariance matrix
Ms  &lt;- as.matrix(dist(coord))  # Spatial distances
Mt  &lt;- as.matrix(dist(time))   # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,Ms,Mt,0,"exponential")
# Data
require(mvtnorm)
y &lt;- as.vector(rmvnorm(1,mean=as.vector(media),sigma=Cov))
perc &lt;- 0.20
aa &lt;- sort(y); bb &lt;- aa[((1-perc)*n1*n2+1):(n1*n2)]; cutof &lt;- bb[1]
cc &lt;- matrix(1,(n1*n2),1)*(y&gt;=cutof)
y[cc==1] &lt;- cutof
y[17] &lt;- abs(y[17])+2*sd(y)
LI &lt;- y
LS &lt;- y; LS[cc==1] &lt;- Inf    # Right-censored

# Estimation
set.seed(74689)
est &lt;- EstStempCens(y, x, cc, time2, coord2, LI, LS, init.phi=2.5, init.rho=0.5, init.tau2=0.8,
          type.Data="balanced", method="nlminb", kappa=0, type.S="exponential",
          IMatrix=TRUE, lower.lim=c(0.01,-0.99,0.01), upper.lim=c(30,0.99,20), M=20,
          perc=0.25, MaxIter=300, pc=0.20)

# Diagnostic
set.seed(12345)
diag &lt;- DiagStempCens(est, type.diag="time", diag.plot = TRUE, ck=1)
## End(Not run)
</code></pre>

<hr>
<h2 id='EffectiveRange'>Effective range for some spatial correlation functions</h2><span id='topic+EffectiveRange'></span>

<h3>Description</h3>

<p>It computes the effective range for an isotropic spatial correlation function, which is
commonly defined to be the distance from which the correlation becomes small, typically
below 0.05.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EffectiveRange(cor = 0.05, phi, kappa = 0, Sp.model = "exponential")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EffectiveRange_+3A_cor">cor</code></td>
<td>
<p>effective correlation to check for. By default = 0.05.</p>
</td></tr>
<tr><td><code id="EffectiveRange_+3A_phi">phi</code></td>
<td>
<p>spatial scaling parameter.</p>
</td></tr>
<tr><td><code id="EffectiveRange_+3A_kappa">kappa</code></td>
<td>
<p>smoothness parameter, required by the matern and power exponential functions. By default = 0.</p>
</td></tr>
<tr><td><code id="EffectiveRange_+3A_sp.model">Sp.model</code></td>
<td>
<p>type of spatial correlation function: '<code>exponential</code>' for exponential,
'<code>gaussian</code>' for gaussian, '<code>matern</code>' for matern, '<code>pow.exp</code>' for power
exponential and '<code>spherical</code>' for spherical function, respectively. By default = <code>exponential</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available isotropic spatial correlation functions are:
</p>

<dl>
<dt><strong>Exponential</strong>:</dt><dd><p><code class="reqn">Corr(d) = exp{-d/\phi}</code>,</p>
</dd>
<dt><strong>Gaussian</strong>:</dt><dd><p><code class="reqn">Corr(d) = exp{-(d/\phi)^2}</code>,</p>
</dd>
<dt><strong>Matern</strong>:</dt><dd><p><code class="reqn">Corr(d) = 1/(2^(\kappa-1)\Gamma(\kappa))(d/\phi)^\kappa K_\kappa(d/\phi)</code>,</p>
</dd>
<dt><strong>Power exponential</strong>:</dt><dd><p><code class="reqn">Corr(d) = exp{-(d/\phi)^\kappa}</code>,</p>
</dd>
<dt><strong>Spherical</strong>:</dt><dd><p><code class="reqn">Corr(d) = 1 - 1.5 d/\phi + 0.5(d/\phi)^3</code>,</p>
</dd>
</dl>
<p>where <code class="reqn">d</code> is the Euclidean distance between two observations, <code class="reqn">\phi</code> is the spatial scaling
parameter, <code class="reqn">\Gamma(.)</code> is the gamma function, <code class="reqn">\kappa</code> is the smoothness parameter and
<code class="reqn">K_\kappa(.)</code> is the modified Bessel function of the second kind of order <code class="reqn">\kappa</code>.

</p>


<h3>Value</h3>

<p>The function returns the effective range, i.e., the approximate distance from which the
spatial correlation is lower than <code>cor</code>.
</p>


<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- 164.60
range1 &lt;- EffectiveRange(0.05, phi, kappa=0, Sp.model="exponential")
range2 &lt;- EffectiveRange(0.05, phi, kappa=1, Sp.model="pow.exp")
# Note that these functions are equivalent.
</code></pre>

<hr>
<h2 id='EstStempCens'>ML estimation in spatio-temporal model with censored/missing responses</h2><span id='topic+EstStempCens'></span>

<h3>Description</h3>

<p>Return the maximum likelihood estimates of the unknown parameters of spatio-temporal model with censored/missing responses.
The estimates are obtained using SAEM algorithm.
The function also computes the observed information matrix using the method developed by Louis (1982).
The types of censoring considered are left, right, interval or missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstStempCens(
  y,
  x,
  cc,
  time,
  coord,
  LI,
  LS,
  init.phi,
  init.rho,
  init.tau2,
  tau2.fixo = FALSE,
  type.Data = "balanced",
  method = "nlminb",
  kappa = 0,
  type.S = "exponential",
  IMatrix = TRUE,
  lower.lim = c(0.01, -0.99, 0.01),
  upper.lim = c(30, 0.99, 20),
  M = 20,
  perc = 0.25,
  MaxIter = 300,
  pc = 0.2,
  error = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EstStempCens_+3A_y">y</code></td>
<td>
<p>a vector of responses.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_x">x</code></td>
<td>
<p>a matrix or vector of covariates.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_cc">cc</code></td>
<td>
<p>a vector of censoring indicators. For each observation: <code>1</code> if censored/missing and <code>0</code> if non-censored/non-missing.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_time">time</code></td>
<td>
<p>a vector of time.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_coord">coord</code></td>
<td>
<p>a matrix of coordinates of the spatial locations.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_li">LI</code></td>
<td>
<p>lower limit of detection. For each observation: if non-censored/non-missing <code>=y</code>, if left-censored/missing <code>=-Inf</code> or <code>=LOD</code> if right/interval-censored.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_ls">LS</code></td>
<td>
<p>upper limit of detection. For each observation: if non-censored/non-missing <code>=y</code>, if right-censored/missing <code>=Inf</code> or <code>=LOD</code> if left/interval-censored.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_init.phi">init.phi</code></td>
<td>
<p>initial value of the spatial scaling parameter.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_init.rho">init.rho</code></td>
<td>
<p>initial value of the time scaling parameter.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_init.tau2">init.tau2</code></td>
<td>
<p>initial value of the the nugget effect parameter.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_tau2.fixo">tau2.fixo</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Indicate if the nugget effect (<code class="reqn">\tau^2</code>) parameter must be fixed.
By default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_type.data">type.Data</code></td>
<td>
<p>type of the data: '<code>balanced</code>' for balanced data and '<code>unbalanced</code>' for unbalanced data. By default = <code>balanced</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_method">method</code></td>
<td>
<p>optimization method used to estimate (<code class="reqn">\phi</code>, <code class="reqn">\rho</code> and <code class="reqn">\tau^2</code>):
'<code>optim</code>' for the function <code><a href="stats.html#topic+optim">optim</a></code> and '<code>nlminb</code>' for the function <code><a href="stats.html#topic+nlminb">nlminb</a></code>.
By default = <code>nlminb</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_kappa">kappa</code></td>
<td>
<p>parameter for all spatial covariance functions. In the case of exponential, gaussian and spherical function <code class="reqn">\kappa</code> is equal to zero.
For the power exponential function <code class="reqn">\kappa</code> is a number between 0 and 2. For the matern correlation function is upper than 0.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_type.s">type.S</code></td>
<td>
<p>type of spatial correlation function: '<code>exponential</code>' for exponential, '<code>gaussian</code>' for gaussian,
'<code>matern</code>' for matern, '<code>pow.exp</code>' for power exponential and '<code>spherical</code>' for spherical function, respectively.
Default is <code>exponential</code> function.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_imatrix">IMatrix</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Indicate if the observed information matrix will be computed. By default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_lower.lim">lower.lim</code>, <code id="EstStempCens_+3A_upper.lim">upper.lim</code></td>
<td>
<p>vectors of lower and upper bounds for the optimization method.
If unspecified, the default is <code>c(0.01,-0.99,0.01)</code> for the lower bound and <code>c(30,0.99,20)</code> for the upper bound if tau2.fixo=<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo samples for stochastic approximation. By default = <code>20</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_perc">perc</code></td>
<td>
<p>percentage of burn-in on the Monte Carlo sample. By default = <code>0.25</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_maxiter">MaxIter</code></td>
<td>
<p>the maximum number of iterations of the SAEM algorithm. By default = <code>300</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_pc">pc</code></td>
<td>
<p>percentage of iterations of the SAEM algorithm with no memory. By default = <code>0.20</code>.</p>
</td></tr>
<tr><td><code id="EstStempCens_+3A_error">error</code></td>
<td>
<p>the convergence maximum error. By default = <code>1e-6</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatio-temporal Gaussian model is giving by:
</p>
<p><code class="reqn"> Y(s_i,t_j)= \mu(s_i,t_j)+ Z(s_i,t_j) +  \epsilon(s_i,t_j),</code>
</p>
<p>where the deterministic term <code class="reqn">\mu(s_i,t_j)</code> and the stochastic terms <code class="reqn">Z(s_i,t_j)</code>,
<code class="reqn">\epsilon(s_i,t_j)</code> can depend on the observed spatio-temporal indexes for <code class="reqn">Y(s_i,t_j)</code>.
We assume <code class="reqn">Z</code> is normally distributed with zero-mean and covariance matrix <code class="reqn">\Sigma_z = \sigma^2 \Omega_{\phi\rho}</code>,
where <code class="reqn">\sigma^2</code> is the partial sill, <code class="reqn">\Omega_{\phi\rho}</code> is the spatio-temporal correlation matrix,<code class="reqn">\phi</code>
and <code class="reqn">\rho</code> are the spatial and time scaling parameters; <code class="reqn">\epsilon(s_i,t_j)</code> is an independent and
identically distributed measurement error with <code class="reqn">E[\epsilon(s_i,t_j)]=0</code>, variance
<code class="reqn">Var[\epsilon(s_i,t_j)]=\tau^2</code> (the nugget effect) and <code class="reqn">Cov[\epsilon(s_i,t_j), \epsilon(s_k,t_l)]=0</code>
for all <code class="reqn">s_i =! s_k</code> or <code class="reqn">t_j =! t_l</code>.
</p>
<p>In particular, we define <code class="reqn">\mu(s_i,t_j)</code>, the mean of the stochastic process as
</p>
<p><code class="reqn">\mu(s_i,t_j)=\sum_{k=1}^{p} x_k(s_i,t_j)\beta_k,</code>
</p>
<p>where <code class="reqn">x_1(s_i,t_j),..., x_p(s_i,t_j)</code> are known functions of <code class="reqn">(s_i,t_j)</code>, and <code class="reqn">\beta_1,...,\beta_p</code>
are unknown parameters to be estimated. Equivalently, in matrix notation, we have the spatio-temporal linear model as follows:
</p>
<p><code class="reqn">Y = X \beta + Z + \epsilon,</code>
</p>
<p><code class="reqn">Z ~ N(0,\sigma^2 \Omega_{\phi\rho}),</code>
</p>
<p><code class="reqn">\epsilon ~ N(0,\tau^2 I_m).</code>
</p>
<p>Therefore the spatio-temporal process, <code class="reqn">Y</code>, has normal distribution with mean <code class="reqn">E[Y]=X\beta</code> and
variance <code class="reqn">\Sigma=\sigma^2\Omega_{\phi\rho}+\tau^2 I_m</code>. We assume that <code class="reqn">\Sigma</code> is non-singular
and <code class="reqn">X</code> has full rank.
</p>
<p>The estimation process was computed via SAEM algorithm initially proposed by Delyon et al. (1999).
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>Est.StempCens</code> which is a list given by:
</p>

<dl>
<dt><code>m.data</code></dt><dd><p>Returns a list with all data components given in input.</p>
</dd>
<dt><code>m.results</code></dt><dd><p>A list given by:</p>
</dd>
</dl>

<table>
<tr><td><code>theta</code></td>
<td>
<p>final estimation of <code class="reqn">\theta = (\beta, \sigma^2, \tau^2, \phi, \rho)</code>.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>estimated parameters in all iterations, <code class="reqn">\theta = (\beta, \sigma^2, \tau^2, \phi, \rho)</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>estimated <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>estimated <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>
<p>estimated <code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>estimated <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>estimated <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code>Eff.range</code></td>
<td>
<p>estimated effective range.</p>
</td></tr>
<tr><td><code>PsiInv</code></td>
<td>
<p>estimated <code class="reqn">\Psi^-1</code>, where <code class="reqn">\Psi=\Sigma/\sigma^2</code>.</p>
</td></tr>
<tr><td><code>Cov</code></td>
<td>
<p>estimated <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code>SAEMy</code></td>
<td>
<p>stochastic approximation of the first moment for the truncated normal distribution.</p>
</td></tr>
<tr><td><code>SAEMyy</code></td>
<td>
<p>stochastic approximation of the second moment for the truncated normal distribution.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>Hessian matrix, the negative of the conditional expected second derivative matrix given the observed values.</p>
</td></tr>
<tr><td><code>Louis</code></td>
<td>
<p>the observed information matrix using the Louis' method.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log likelihood for SAEM method.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criteria.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criteria.</p>
</td></tr>
<tr><td><code>AICcorr</code></td>
<td>
<p>corrected AIC by the number of parameters.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of iterations needed to convergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulating data
# Initial parameter values
beta &lt;- c(-1,1.50)
phi &lt;- 5;     rho &lt;- 0.45
tau2 &lt;- 0.80; sigma2 &lt;- 1.5
n1 &lt;- 5    # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(1000)
x.coord &lt;- round(runif(n1,0,10),9)    # X coordinate
y.coord &lt;- round(runif(n1,0,10),9)    # Y coordinate
coord  &lt;- cbind(x.coord,y.coord)      # Cartesian coordinates without repetitions
coord2 &lt;- cbind(rep(x.coord,each=n2),rep(y.coord,each=n2)) # Cartesian coordinates with repetitions
time &lt;- as.matrix(seq(1,n2))          # Time index without repetitions
time2 &lt;- as.matrix(rep(time,n1))      # Time index with repetitions
x1 &lt;- rexp(n1*n2,2)
x2 &lt;- rnorm(n1*n2,2,1)
x  &lt;- cbind(x1,x2)
media &lt;- x%*%beta
# Covariance matrix
Ms  &lt;- as.matrix(dist(coord))   # Spatial distances
Mt  &lt;- as.matrix(dist(time))    # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,Ms,Mt,1.5,"matern")
# Data
require(mvtnorm)
y &lt;- as.vector(rmvnorm(1,mean=as.vector(media),sigma=Cov))
perc &lt;- 0.20
aa &lt;- sort(y); bb &lt;- aa[1:(perc*n1*n2)]; cutof &lt;- bb[perc*n1*n2]
cc &lt;- matrix(1,(n1*n2),1)*(y&lt;=cutof)
y[cc==1] &lt;- cutof
LI &lt;- y; LI[cc==1] &lt;- -Inf    # Left-censored
LS &lt;- y

# Estimation
est_teste &lt;- EstStempCens(y, x, cc, time2, coord2, LI, LS, init.phi=3.5,
                 init.rho=0.5, init.tau2=0.7,tau2.fixo=FALSE, kappa=1.5,
                 type.S="matern", IMatrix=TRUE, M=20, perc=0.25,
                 MaxIter=300, pc=0.2)
## End(Not run)

</code></pre>

<hr>
<h2 id='PredStempCens'>Prediction in spatio-temporal model with censored/missing responses</h2><span id='topic+PredStempCens'></span>

<h3>Description</h3>

<p>This function performs spatio-temporal prediction in a set of new <code>S</code> spatial locations for fixed time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredStempCens(Est.StempCens, locPre, timePre, xPre)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredStempCens_+3A_est.stempcens">Est.StempCens</code></td>
<td>
<p>an object of class <code>Est.StempCens</code> given as output by the <code><a href="#topic+EstStempCens">EstStempCens</a></code> function.</p>
</td></tr>
<tr><td><code id="PredStempCens_+3A_locpre">locPre</code></td>
<td>
<p>a matrix of coordinates for which prediction is performed.</p>
</td></tr>
<tr><td><code id="PredStempCens_+3A_timepre">timePre</code></td>
<td>
<p>the time point vector for which prediction is performed.</p>
</td></tr>
<tr><td><code id="PredStempCens_+3A_xpre">xPre</code></td>
<td>
<p>a matrix of covariates for which prediction is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>Pred.StempCens</code> which is a list given by:
</p>
<table>
<tr><td><code>predValues</code></td>
<td>
<p>predicted values.</p>
</td></tr>
<tr><td><code>VarPred</code></td>
<td>
<p>predicted covariance matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Katherine L. Valeriano, Victor H. Lachos and Larissa A. Matos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EstStempCens">EstStempCens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initial parameter values
beta &lt;- c(-1,1.50)
phi  &lt;- 5;    rho &lt;- 0.60
tau2 &lt;- 0.80; sigma2 &lt;- 2
# Simulating data
n1 &lt;- 17   # Number of spatial locations
n2 &lt;- 5    # Number of temporal index
set.seed(12345)
x.co &lt;- round(runif(n1,0,10),9)   # X coordinate
y.co &lt;- round(runif(n1,0,10),9)   # Y coordinate
coord &lt;- cbind(x.co,y.co)         # Cartesian coordinates without repetitions
coord2 &lt;- cbind(rep(x.co,each=n2),rep(y.co,each=n2)) # Cartesian coordinates with repetitions
time &lt;- as.matrix(seq(1,n2))      # Time index without repetitions
time2 &lt;- as.matrix(rep(time,n1))  # Time index with repetitions
x1 &lt;- rexp(n1*n2,2)
x2 &lt;- rnorm(n1*n2,2,1)
x  &lt;- cbind(x1,x2)
media &lt;- x%*%beta
# Covariance matrix
Ms  &lt;- as.matrix(dist(coord))   # Spatial distances
Mt  &lt;- as.matrix(dist(time))    # Temporal distances
Cov &lt;- CovarianceM(phi,rho,tau2,sigma2,Ms,Mt,0.50,"pow.exp")
# Data
require(mvtnorm)
y &lt;- as.vector(rmvnorm(1,mean=as.vector(media),sigma=Cov))
data &lt;- data.frame(coord2,time2,y,x)
names(data) &lt;- c("x.coord","y.coord","time","yObs","x1","x2")
# Splitting the dataset
local.est  &lt;- coord[-c(4,13),]
data.est   &lt;- data[data$x.coord%in%local.est[,1]&amp;data$y.coord%in%local.est[,2],]
data.valid &lt;- data[data$x.coord%in%coord[c(4,13),1]&amp;data$y.coord%in%coord[c(4,13),2],]
# Censored
perc &lt;- 0.10
y &lt;- data.est$yObs
aa &lt;- sort(y);  bb &lt;- aa[1:(perc*nrow(data.est))]
cutof &lt;- bb[perc*nrow(data.est)]
cc &lt;- matrix(1,nrow(data.est),1)*(y&lt;=cutof)
y[cc==1] &lt;- cutof
data.est &lt;- cbind(data.est[,-c(4,5,6)],y,cc,data.est[,c(5,6)])
names(data.est) &lt;- c("x.coord","y.coord","time","yObs","censored","x1","x2")

# Estimation
y  &lt;- data.est$yObs
x  &lt;- cbind(data.est$x1,data.est$x2)
cc &lt;- data.est$censored
time2  &lt;- matrix(data.est$time)
coord2 &lt;- data.est[,1:2]
LI &lt;- y; LI[cc==1] &lt;- -Inf    # Left-censored
LS &lt;- y
est_teste &lt;- EstStempCens(y, x, cc, time2, coord2, LI, LS, init.phi=3.5,
                 init.rho=0.5, init.tau2=1, kappa=0.5, type.S="pow.exp",
                 IMatrix=FALSE, M=20, perc=0.25, MaxIter=300, pc=0.20)
class(est_teste)

# Prediction
locPre &lt;- data.valid[,1:2]
timePre &lt;- matrix(data.valid$time)
xPre &lt;- cbind(data.valid$x1,data.valid$x2)
pre_teste &lt;- PredStempCens(est_teste, locPre, timePre, xPre)
library(ggplot2)
Model &lt;- rep(c("y Observed","y Predicted"),each=10)
station &lt;- rep(rep(c("Station 1", "Station 2"),each=5),times=2)
xcoord1 &lt;- rep(seq(1:5),4)
ycoord1 &lt;- c(data.valid$yObs,pre_teste$predValues)
data2 &lt;- data.frame(Model,station,xcoord1,ycoord1)
ggplot(data=data2,aes(x=xcoord1,y=ycoord1)) + geom_line(aes(color=Model)) +
facet_wrap(station~.,nrow=2) + labs(x="",y="") + theme(legend.position="bottom")
## End(Not run)
</code></pre>

<hr>
<h2 id='StempCens-package'>
Spatio-Temporal Estimation and Prediction for Censored/Missing Responses
</h2><span id='topic+StempCens-package'></span>

<h3>Description</h3>

<p>It estimates the parameters of a censored or missing data in spatio-temporal models using the SAEM algorithm (Delyon et al., 1999). This algorithm is a stochastic approximation of the widely used EM algorithm and an important tool for models in which the E-step does not have an analytic form. Besides the expressions obtained to estimate the parameters to the proposed model, we include the calculations for the observed information matrix using the method developed by Louis (1982). To examine the performance of the fitted model, case-deletion measure are provided.
</p>


<h3>Details</h3>




<p>The functions provided are:
</p>
<p>- <code><a href="#topic+CovarianceM">CovarianceM</a></code>: computes the spatio-temporal covariance matrix for balanced data.
</p>
<p>- <code><a href="#topic+EffectiveRange">EffectiveRange</a></code>: computes the effective range for an isotropic spatial correlation function.
</p>
<p>- <code><a href="#topic+EstStempCens">EstStempCens</a></code>: returns the maximum likelihood estimates of the unknown parameters.
</p>
<p>- <code><a href="#topic+PredStempCens">PredStempCens</a></code>: performs spatio-temporal prediction in a set of new <code>S</code> spatial locations for fixed time points.
</p>
<p>- <code><a href="#topic+CrossStempCens">CrossStempCens</a></code>: performs cross-validation, which measure the performance of the predictive model on new test dataset.
</p>
<p>- <code><a href="#topic+DiagStempCens">DiagStempCens</a></code>: returns measures and graphics for diagnostic analysis.
</p>


<h3>Author(s)</h3>

<p>Larissa A. Matos (<a href="https://orcid.org/0000-0002-2635-0901">ORCID</a>), Katherine L. Valeriano (<a href="https://orcid.org/0000-0001-6388-4753">ORCID</a>) and Victor H. Lachos (<a href="https://orcid.org/0000-0002-7239-2459">ORCID</a>)
</p>
<p><b>Maintainer</b>: Larissa A. Matos (<a href="mailto:larissa.amatos@gmail.com">larissa.amatos@gmail.com</a>).
</p>


<h3>References</h3>

<p>Cook R (1977).
&ldquo;Detection of influential observation in linear regression.&rdquo;
<em>Technometrics</em>, <b>19</b>(1), 15&ndash;18.
doi: <a href="https://doi.org/10.1080/00401706.1977.10489493">10.1080/00401706.1977.10489493</a>.
</p>
<p>Delyon B, Lavielle M, Moulines E (1999).
&ldquo;Convergence of a stochastic approximation version of the EM algorithm.&rdquo;
<em>Annals of Statistics</em>, <b>27</b>(1), 94&ndash;128.
doi: <a href="https://doi.org/10.1214/aos/1018031103">10.1214/aos/1018031103</a>.
</p>
<p>Louis T (1982).
&ldquo;Finding the observed information matrix when using the EM algorithm.&rdquo;
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, <b>44</b>(2), 226&ndash;233.
doi: <a href="https://doi.org/10.1111/j.2517-6161.1982.tb01203.x">10.1111/j.2517-6161.1982.tb01203.x</a>.
</p>
<p>Zhu H, Lee S, Wei B, Zhou J (2001).
&ldquo;Case-deletion measures for models with incomplete data.&rdquo;
<em>Biometrika</em>, <b>88</b>(3), 727&ndash;737.
doi: <a href="https://doi.org/10.1093/biomet/88.3.727">10.1093/biomet/88.3.727</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
