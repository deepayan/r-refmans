<!DOCTYPE html><html><head><title>Help for package HydroPortailStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HydroPortailStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distInfo'><p>Information on available distributions</p></a></li>
<li><a href='#Generate'><p>Random numbers generator</p></a></li>
<li><a href='#GetCdf'><p>Cumulative Distribution Function (cdf)</p></a></li>
<li><a href='#GetEmpFreq'><p>Empirical nonexceedance frequency</p></a></li>
<li><a href='#GetEstimate_BAY'><p>Bayesian estimation of a distribution</p></a></li>
<li><a href='#GetEstimate_HYDRO2'><p>Hydro2 estimate of a distribution</p></a></li>
<li><a href='#GetEstimate_LMOM'><p>L-Moment estimate of a distribution</p></a></li>
<li><a href='#GetEstimate_ML'><p>Maximum-likelihood estimate of a distribution</p></a></li>
<li><a href='#GetEstimate_MOM'><p>Moment estimate of a distribution</p></a></li>
<li><a href='#GetEstimate_ROUGH'><p>Rough estimate of a distribution</p></a></li>
<li><a href='#GetParFeas'><p>Parameter feasibility</p></a></li>
<li><a href='#GetParName'><p>Parameter names.</p></a></li>
<li><a href='#GetParNumber'><p>Number of parameters.</p></a></li>
<li><a href='#GetPdf'><p>Probability Density Function (pdf)</p></a></li>
<li><a href='#GetQfromT'><p>Get quantile from return period</p></a></li>
<li><a href='#GetQuantile'><p>Quantile Function</p></a></li>
<li><a href='#GetReducedVariate'><p>Reduced variate</p></a></li>
<li><a href='#GetTfromQ'><p>Get return period from value</p></a></li>
<li><a href='#GetUncertainty_ML'><p>Maximum-likelihood estimation of uncertainty</p></a></li>
<li><a href='#Hydro3_Estimation'><p>Hydro3 estimation</p></a></li>
<li><a href='#Hydro3_Plot'><p>Hydro3 plot</p></a></li>
<li><a href='#KS'><p>Kolmogorov-Smirnov Test</p></a></li>
<li><a href='#mcmcoptions_def'><p>Default MCMC options</p></a></li>
<li><a href='#Metropolis_OAAT'><p>One-At-A-Time Metropolis sampler</p></a></li>
<li><a href='#Metropolis_OAAT_adaptive'><p>Adaptive One-At-A-Time Metropolis sampler</p></a></li>
<li><a href='#Metropolis_OAAT_jump'><p>One-At-A-Time Metropolis sampler</p></a></li>
<li><a href='#MK'><p>Mann-Kemdall Test</p></a></li>
<li><a href='#options_def'><p>Default estimation options</p></a></li>
<li><a href='#Pettitt'><p>Pettitt Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'HydroPortail' Statistical Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical functions used in the French 'HydroPortail' <a href="https://hydro.eaufrance.fr/">https://hydro.eaufrance.fr/</a>.
    This includes functions to estimate distributions, quantile curves and uncertainties, along with various other utilities.
    Technical details are available (in French) in Renard (2016) <a href="https://hal.inrae.fr/hal-02605318">https://hal.inrae.fr/hal-02605318</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, evd, mvtnorm, numDeriv</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-24 10:20:42 UTC; brenard</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Renard <a href="https://orcid.org/0000-0001-8447-5430"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  INRAE [fnd],
  Ministère de la Transition Ecologique - SCHAPI [fnd],
  European Commission [fnd] (This project has received funding from the
    European Union’s Horizon 2020 research and innovation programme
    under the Marie Sklodowska-Curie grant agreement No 835496)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Renard &lt;benjamin.renard@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 19:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='distInfo'>Information on available distributions</h2><span id='topic+distInfo'></span>

<h3>Description</h3>

<p>A named list containing information (parameters, contraints, notes, warnings, etc.)
for all available univariate distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distInfo
</code></pre>


<h3>Format</h3>

<p>A named list where each element is itself a list containing:
</p>

<dl>
<dt>parName</dt><dd><p>parameters short names</p>
</dd>
<dt>parLongName</dt><dd><p>parameters long names</p>
</dd>
<dt>parSymbol</dt><dd><p>parameters typical symbols</p>
</dd>
<dt>constraints</dt><dd><p>constraints on parameters</p>
</dd>
<dt>url</dt><dd><p>link to more information</p>
</dd>
<dt>note</dt><dd><p>notes</p>
</dd>
<dt>warning</dt><dd><p>warnings: read carefully since this highlights in particular differences with &quot;standard&quot; parameterizations found in e.g. Wikipedia or R.</p>
</dd>
</dl>


<hr>
<h2 id='Generate'>Random numbers generator</h2><span id='topic+Generate'></span>

<h3>Description</h3>

<p>Generate random realizations from a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Generate(dist, par, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generate_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="Generate_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
<tr><td><code id="Generate_+3A_n">n</code></td>
<td>
<p>integer, number of values to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated values as a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Generate('Normal',c(0,1),10)
Generate('GEV',c(100,25,-0.2),10)
Generate('GEV',c(100,25,0.2),10)
Generate('Poisson',0.75,10)
</code></pre>

<hr>
<h2 id='GetCdf'>Cumulative Distribution Function (cdf)</h2><span id='topic+GetCdf'></span>

<h3>Description</h3>

<p>Evaluates the cdf of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCdf(y, dist, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCdf_+3A_y">y</code></td>
<td>
<p>numeric, value at which the cdf is evaluated</p>
</td></tr>
<tr><td><code id="GetCdf_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetCdf_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cdf as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetCdf(0,'Normal',c(0,1))
GetCdf(200,'GEV',c(100,25,-0.2))
GetCdf(200,'GEV',c(100,25,0.2))
GetCdf(3,'Poisson',0.75)
</code></pre>

<hr>
<h2 id='GetEmpFreq'>Empirical nonexceedance frequency</h2><span id='topic+GetEmpFreq'></span>

<h3>Description</h3>

<p>Computes the empirical nonexceedance frequency of the ith sorted value amongst n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEmpFreq(i, n, formula = "Hazen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEmpFreq_+3A_i">i</code></td>
<td>
<p>integer or integer vector, observation rank(s)</p>
</td></tr>
<tr><td><code id="GetEmpFreq_+3A_n">n</code></td>
<td>
<p>integer, number of observations</p>
</td></tr>
<tr><td><code id="GetEmpFreq_+3A_formula">formula</code></td>
<td>
<p>character, formula, available: 'Hazen', 'Standard', 'MinusOne', 'Weibull',
'Benard', 'Cunnane', 'Beard', 'Blom', 'Gringorten', 'Landwehr', 'Tukey'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nonexceedance frequency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetEmpFreq(i=1:10,n=10)
GetEmpFreq(i=1:10,n=10,formula='Standard')
GetEmpFreq(i=1:10,n=10,formula='MinusOne')
GetEmpFreq(i=1:10,n=10,formula='Cunnane')
</code></pre>

<hr>
<h2 id='GetEstimate_BAY'>Bayesian estimation of a distribution</h2><span id='topic+GetEstimate_BAY'></span>

<h3>Description</h3>

<p>Returns MCMC samples from the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_BAY(
  y,
  dist,
  prior,
  par0,
  mult = 0.1,
  eps = 0.1,
  batch.length = 100,
  batch.n = 100,
  moverate.min = 0.1,
  moverate.max = 0.5,
  mult.down = 0.9,
  mult.up = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_BAY_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_prior">prior</code></td>
<td>
<p>list of lists, prior distributions. For each parameter to be estimated, the prior
is a list of the form pr=list(dist=..., par=...). See example below.</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_par0">par0</code></td>
<td>
<p>numeric vector, initial parameter guess. You may use GetEstimate_ROUGH().</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_mult">mult</code></td>
<td>
<p>numeric, initial jump standard deviations are set to mult * abs(par0)</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_eps">eps</code></td>
<td>
<p>numeric, where par0 is zero, initial jump standard deviations are set to eps (to avoid jumps of size zero)</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_batch.length">batch.length</code></td>
<td>
<p>integer, MCMC parameter: length of each non-adaptive batch</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_batch.n">batch.n</code></td>
<td>
<p>integer, MCMC parameter: number of batches (= adaptation period). Total number of simulations is nsim=batch.n*batch.length</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_moverate.min">moverate.min</code></td>
<td>
<p>numeric in (0;1), MCMC parameter: lower bound for the desired move rate interval</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_moverate.max">moverate.max</code></td>
<td>
<p>numeric in (0;1), MCMC parameter: upper bound for the desired move rate interval</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_mult.down">mult.down</code></td>
<td>
<p>numeric in (0;1), MCMC parameter: multiplication factor used to decrease jump size when move rate is too low.</p>
</td></tr>
<tr><td><code id="GetEstimate_BAY_+3A_mult.up">mult.up</code></td>
<td>
<p>numeric (&gt;1, avoid 1/mult.down), MCMC parameter: multiplication factor used to increase jump size when move rate is too high.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric matrix nsim*length(x0), MCMC simulations</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>numeric vector, corresponding values f(x)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
prior1=list(dist='FlatPrior',par=NULL)
prior2=list(dist='LogNormal',par=c(1,1))
prior3=list(dist='Normal',par=c(0,0.25))
prior=list(prior1,prior2,prior3)
par0=GetEstimate_ROUGH(y,'GEV')$par
mcmc=GetEstimate_BAY(y,'GEV',prior,par0,batch.length=50,batch.n=50)
graphicalpar=par(mfrow=c(2,3))
plot(mcmc$x[,1],type='l'); plot(mcmc$x[,2],type='l'); plot(mcmc$x[,3],type='l')
hist(mcmc$x[,1]); hist(mcmc$x[,2]); hist(mcmc$x[,3])
par(graphicalpar)
</code></pre>

<hr>
<h2 id='GetEstimate_HYDRO2'>Hydro2 estimate of a distribution</h2><span id='topic+GetEstimate_HYDRO2'></span>

<h3>Description</h3>

<p>Returns an estimate of a distribution as it was computed in the old HYDRO2 software.
Only available for distributions 'Normal', 'LogNormal', and 'Gumbel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_HYDRO2(y, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_HYDRO2_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_HYDRO2_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>numeric vector, estimated parameter vector.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>numeric, objective fonction (NA for this estimate)</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
GetEstimate_HYDRO2(y,'Normal')
GetEstimate_HYDRO2(y,'LogNormal')
GetEstimate_HYDRO2(y,'Gumbel')
GetEstimate_HYDRO2(y,'GEV')
GetEstimate_HYDRO2(y,'Poisson')
</code></pre>

<hr>
<h2 id='GetEstimate_LMOM'>L-Moment estimate of a distribution</h2><span id='topic+GetEstimate_LMOM'></span>

<h3>Description</h3>

<p>Returns an estimate of a distribution using the method of L-moments.
Note that for some distributions, this is not strictly speaking the L-moment estimate:
For LogNormal and LogPearsonIII, the L-moment estimate of log(data) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_LMOM(y, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_LMOM_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_LMOM_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>numeric vector, estimated parameter vector.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>numeric, objective fonction (NA for this estimate)</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
GetEstimate_LMOM(y,'Normal')
GetEstimate_LMOM(y,'LogNormal')
GetEstimate_LMOM(y,'Gumbel')
GetEstimate_LMOM(y,'GEV')
GetEstimate_LMOM(y,'Poisson')
</code></pre>

<hr>
<h2 id='GetEstimate_ML'>Maximum-likelihood estimate of a distribution</h2><span id='topic+GetEstimate_ML'></span>

<h3>Description</h3>

<p>Returns an estimate of a distribution using the method of maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_ML(
  y,
  dist,
  par0 = NULL,
  method = optim_method_def,
  lower = -Inf,
  upper = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_ML_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_ML_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetEstimate_ML_+3A_par0">par0</code></td>
<td>
<p>numeric vector, initial parameter guess. You may use GetEstimate_ROUGH().</p>
</td></tr>
<tr><td><code id="GetEstimate_ML_+3A_method">method</code></td>
<td>
<p>character, method used to maximize likelihood, see ?optim</p>
</td></tr>
<tr><td><code id="GetEstimate_ML_+3A_lower">lower</code></td>
<td>
<p>numeric vector, lower bounds, see ?optim</p>
</td></tr>
<tr><td><code id="GetEstimate_ML_+3A_upper">upper</code></td>
<td>
<p>numeric vector, upper bounds, see ?optim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>numeric vector, estimated parameter vector.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>numeric, objective fonction (maximum log-likelihood)</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
GetEstimate_ML(y,'Normal')
GetEstimate_ML(y,'LogNormal')
GetEstimate_ML(y,'Gumbel')
GetEstimate_ML(y,'Gumbel',par0=GetEstimate_ROUGH(y,'Gumbel')$par)
GetEstimate_ML(y,'GEV',par0=GetEstimate_ROUGH(y,'GEV')$par)
GetEstimate_ML(y,'Poisson')
</code></pre>

<hr>
<h2 id='GetEstimate_MOM'>Moment estimate of a distribution</h2><span id='topic+GetEstimate_MOM'></span>

<h3>Description</h3>

<p>Returns an estimate of a distribution using the method of moments.
Note that for some distributions, this is not strictly speaking the moment estimate.
For LogPearsonIII for instance, the moment estimate of log(data) is used.
Also for GPD3, the threshold is estimated as min(data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_MOM(y, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_MOM_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_MOM_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>numeric vector, estimated parameter vector.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>numeric, objective fonction (NA for this estimate)</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
GetEstimate_MOM(y,'Normal')
GetEstimate_MOM(y,'LogNormal')
GetEstimate_MOM(y,'Gumbel')
GetEstimate_MOM(y,'GEV')
GetEstimate_MOM(y,'Poisson')
</code></pre>

<hr>
<h2 id='GetEstimate_ROUGH'>Rough estimate of a distribution</h2><span id='topic+GetEstimate_ROUGH'></span>

<h3>Description</h3>

<p>Returns a rough first-guess estimate of a distribution.
This estimate may be poor but it solely aims at being used as a starting point 
for more advanced estimation approaches (e.g. max-likelihood or Bayesian).
It is therefore chosen as an easy-to-compute explicit formula, robust and error-proof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetEstimate_ROUGH(y, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetEstimate_ROUGH_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetEstimate_ROUGH_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>numeric vector, estimated parameter vector.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>numeric, objective fonction (NA for this estimate)</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
GetEstimate_ROUGH(y,'Normal')
GetEstimate_ROUGH(y,'LogNormal')
GetEstimate_ROUGH(y,'Gumbel')
GetEstimate_ROUGH(y,'GEV')
GetEstimate_ROUGH(y,'Poisson')
</code></pre>

<hr>
<h2 id='GetParFeas'>Parameter feasibility</h2><span id='topic+GetParFeas'></span>

<h3>Description</h3>

<p>Evaluates whether a parameter vector is feasible 
(for instance, are scale parameters &gt;0 ?)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetParFeas(dist, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetParFeas_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetParFeas_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feasible
GetParFeas('Normal',c(0,1))
# Not feasible because second parameter (standard deviation) is negative
GetParFeas('Normal',c(0,-1))
</code></pre>

<hr>
<h2 id='GetParName'>Parameter names.</h2><span id='topic+GetParName'></span>

<h3>Description</h3>

<p>Returns the names of the parameters of a distribution, 
in French (default) or English.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetParName(dist, lang = "fr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetParName_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetParName_+3A_lang">lang</code></td>
<td>
<p>character, language ('en' or 'fr')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetParName('Normal')
GetParName('GEV')
GetParName('GEV',lang='en')
</code></pre>

<hr>
<h2 id='GetParNumber'>Number of parameters.</h2><span id='topic+GetParNumber'></span>

<h3>Description</h3>

<p>Returns the number of parameters of a distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetParNumber(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetParNumber_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetParNumber('Normal')
GetParNumber('GEV')
</code></pre>

<hr>
<h2 id='GetPdf'>Probability Density Function (pdf)</h2><span id='topic+GetPdf'></span>

<h3>Description</h3>

<p>Evaluates the pdf of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetPdf(y, dist, par, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetPdf_+3A_y">y</code></td>
<td>
<p>numeric, value at which the pdf is evaluated</p>
</td></tr>
<tr><td><code id="GetPdf_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetPdf_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
<tr><td><code id="GetPdf_+3A_log">log</code></td>
<td>
<p>logical, returns log-pdf if TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pdf or the log-pdf as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetPdf(0,'Normal',c(0,1))
GetPdf(200,'GEV',c(100,25,-0.2))
GetPdf(200,'GEV',c(100,25,0.2))
GetPdf(3,'Poisson',0.75)
</code></pre>

<hr>
<h2 id='GetQfromT'>Get quantile from return period</h2><span id='topic+GetQfromT'></span>

<h3>Description</h3>

<p>Compute the T-quantile from the results of Hydro3_Estimation()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetQfromT(RP, H3, options = options_def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetQfromT_+3A_rp">RP</code></td>
<td>
<p>numeric, return period</p>
</td></tr>
<tr><td><code id="GetQfromT_+3A_h3">H3</code></td>
<td>
<p>list, resulting from a call to Hydro3_Estimation()</p>
</td></tr>
<tr><td><code id="GetQfromT_+3A_options">options</code></td>
<td>
<p>list, see ?Hydro3_Estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>numeric, quantile</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>numeric vector, uncertainty interval</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
H3=Hydro3_Estimation(y,'Normal')
GetQfromT(100,H3)
</code></pre>

<hr>
<h2 id='GetQuantile'>Quantile Function</h2><span id='topic+GetQuantile'></span>

<h3>Description</h3>

<p>Evaluates the quantiles of a distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetQuantile(p, dist, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetQuantile_+3A_p">p</code></td>
<td>
<p>numeric in (0;1), nonexceedance probability</p>
</td></tr>
<tr><td><code id="GetQuantile_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetQuantile_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-quantile as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetQuantile(0.99,'Normal',c(0,1))
GetQuantile(0.99,'GEV',c(100,25,-0.2))
GetQuantile(0.99,'GEV',c(100,25,0.2))
GetQuantile(0.99,'Poisson',0.75)
</code></pre>

<hr>
<h2 id='GetReducedVariate'>Reduced variate</h2><span id='topic+GetReducedVariate'></span>

<h3>Description</h3>

<p>Returns the 'reduced variate' that is used in some quantile plots 
(see e.g. quantile curve on Gumbel paper)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetReducedVariate(p, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetReducedVariate_+3A_p">p</code></td>
<td>
<p>numeric in (0;1), nonexceedance probability</p>
</td></tr>
<tr><td><code id="GetReducedVariate_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reduced variate with nonexceedance probability p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetReducedVariate(0.99,'Normal')
GetReducedVariate(0.99,'Gumbel')
GetReducedVariate(0.99,'GEV')
GetReducedVariate(0.99,'Poisson')
</code></pre>

<hr>
<h2 id='GetTfromQ'>Get return period from value</h2><span id='topic+GetTfromQ'></span>

<h3>Description</h3>

<p>Compute the return period associated with a value from the results of Hydro3_Estimation()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTfromQ(q, H3, options = options_def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTfromQ_+3A_q">q</code></td>
<td>
<p>numeric, value</p>
</td></tr>
<tr><td><code id="GetTfromQ_+3A_h3">H3</code></td>
<td>
<p>list, resulting from a call to Hydro3_Estimation()</p>
</td></tr>
<tr><td><code id="GetTfromQ_+3A_options">options</code></td>
<td>
<p>list, see ?Hydro3_Estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>RP</code></td>
<td>
<p>numeric, return period</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>numeric vector, uncertainty interval</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
H3=Hydro3_Estimation(y,'Normal')
GetTfromQ(3,H3)
</code></pre>

<hr>
<h2 id='GetUncertainty_ML'>Maximum-likelihood estimation of uncertainty</h2><span id='topic+GetUncertainty_ML'></span>

<h3>Description</h3>

<p>Returns an estimate of the uncertainty around the maximum-likelihood estimate, 
in the form of a covariance matrix and some simulations from the corresponding 
Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetUncertainty_ML(y, dist, par, nsim = nsim_def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetUncertainty_ML_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="GetUncertainty_ML_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="GetUncertainty_ML_+3A_par">par</code></td>
<td>
<p>numeric vector, estimated parameter (using GetEstimate_ML()).</p>
</td></tr>
<tr><td><code id="GetUncertainty_ML_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of simulated parameter replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>cov</code></td>
<td>
<p>numeric matrix npar*npar, covariance matrix.</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>numeric matrix nsim*npar, simulated parameter replicates.</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did computation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=c(9.2,9.5,11.4,9.5,9.4,9.6,10.5,11.1,10.5,10.4)
estim=GetEstimate_ML(y,'Gumbel',par0=GetEstimate_ROUGH(y,'Gumbel')$par)
GetUncertainty_ML(y,'Gumbel',par=estim$par)
</code></pre>

<hr>
<h2 id='Hydro3_Estimation'>Hydro3 estimation</h2><span id='topic+Hydro3_Estimation'></span>

<h3>Description</h3>

<p>Main estimation function used in the HydroPortail.
In short, this function estimates a distribution and the associated uncertainty, 
and returns all needed information to display and plot the results 
(parameter estimates, quantile curves, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hydro3_Estimation(
  y,
  dist,
  Emeth = Emeth_def,
  Umeth = Umeth_def,
  options = options_def,
  mcmcoptions = mcmcoptions_def,
  prior = GetDefaultPrior(GetParNumber(dist)),
  do.KS = TRUE,
  do.MK = TRUE,
  do.Pettitt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hydro3_Estimation_+3A_y">y</code></td>
<td>
<p>numeric vector, data.</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_dist">dist</code></td>
<td>
<p>character, distribution name. See dataset distInfo for a description of available distributions.
In particular, type names(distInfo) for the list of available distributions, and 
distInfo[['GEV']] for more information on a particular distribution (here, GEV).</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_emeth">Emeth</code></td>
<td>
<p>character, estimation method. Default is 'LMOM' (L-Moments), available: 
'MOM' (Moments), 'ML' (Maximum Likelihood), 'BAY' (Bayesian).</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_umeth">Umeth</code></td>
<td>
<p>character, uncertainty quantification method. Default is 'PBOOT' (Parametric bootstrap), available: 
'BOOT' (Bootstrap, not recommended), 'NONE', 'ML' (only usable when Emeth='ML' as well), 
and 'BAY' (the only usable method when Emeth='BAY').</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_options">options</code></td>
<td>
<p>list, options, see details below.</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_mcmcoptions">mcmcoptions</code></td>
<td>
<p>list, MCMC options, see details below.</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_prior">prior</code></td>
<td>
<p>list, prior distributions, only used when Emeth='BAY'. See ?GetEstimate_BAY for details.</p>
</td></tr>
<tr><td><code id="Hydro3_Estimation_+3A_do.ks">do.KS</code>, <code id="Hydro3_Estimation_+3A_do.mk">do.MK</code>, <code id="Hydro3_Estimation_+3A_do.pettitt">do.Pettitt</code></td>
<td>
<p>logical, perform KS/MK/Pettitt tests?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'options' allows controlling various properties of the analysis and results.
It is a list with the following components:
</p>

<ul>
<li><p>FreqFormula, character, formula for computing nonexceedance frequency, see ?GetEmpFreq.
</p>
</li>
<li><p>pgrid, numeric vector, probabilities defining the x values where pdf f(x) and cdf F(x) 
are computed. These x values are quantiles from the estimated distribution 
with probabilities pgrid.
</p>
</li>
<li><p>Tgrid, numeric vector, return periods where quantile function q(T) is computed.
</p>
</li>
<li><p>IClevel, numeric, level of uncertainty interval.
</p>
</li>
<li><p>p2T, numeric, conversion factor between nonexceedance probability p and return period T.
p=1-1/(p2T*T). In general p2T=1 but for a peak-over-threshold approach leading to say 3 events
per year on average, p2T=3.
</p>
</li>
<li><p>invertT, logical, when invertT=TRUE, LARGE return periods correspond to SMALL data values.
This is typically used for low-flow statistics.
</p>
</li>
<li><p>splitZeros, logical, when splitZeros=TRUE zero and negative values are removed from the data y before 
estimating the distribution,and are used to estimate the probability of zeros p0. This is 
typically used for low-flow statistics to estimate the probability of zero streamflow.
</p>
</li>
<li><p>lang, chanracter, language ('fr' or 'en').
</p>
</li>
<li><p>nsim, integer, number of replicated parameters representing uncertainty.
</p>
</li></ul>

<p>The argument 'mcmcoptions' is only used when Emeth='BAY' and is a list controlling MCMC properties: 
</p>

<ul>
<li><p>mult, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>eps, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>batch.length, integer, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>batch.n, integer, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>moverate.min, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>moverate.max, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>mult.down, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>mult.up, numeric, see ?Metropolis_OAAT_adaptive
</p>
</li>
<li><p>burn, numeric, burn-in factor, e.g. if burn=0.2 the first 20 percents of MCMC samples are discarded
</p>
</li>
<li><p>slim, integer, sliming factor, e.g. if slim=5 only one MCMC sample every 5 is kept (after burn-in)
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>character, estimated distribution.</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>logical, did estimation succeed?</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>integer, error code (0 if ok).</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>error message.</p>
</td></tr>
<tr><td><code>empirical</code></td>
<td>
<p>data frame, sorted data and empirical estimates 
(nonexceedance frequency, return period and reduced variate) </p>
</td></tr>
<tr><td><code>pcdf</code></td>
<td>
<p>data frame, estimated pdf and cdf</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>data frame, estimated quantiles and uncertainty intervals</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>data frame, estimated parameters and uncertainty intervals</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>list, result of the Kolmogorov-Smirnov test, see ?KS</p>
</td></tr>
<tr><td><code>MK</code></td>
<td>
<p>list, result of the Mann-Kendall test, see ?MK</p>
</td></tr>
<tr><td><code>Pettitt</code></td>
<td>
<p>list, result of the Pettitt test, see ?Pettitt</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>list, parameter uncertainty in the form of a covariance matrix ($cov)
and simulated parameter replicates ($sim). Also contains error-handling flags 
$ok, $err and $message.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
H3=Hydro3_Estimation(y,'Normal')
H3=Hydro3_Estimation(y,'GEV',Emeth='ML',Umeth='ML')
</code></pre>

<hr>
<h2 id='Hydro3_Plot'>Hydro3 plot</h2><span id='topic+Hydro3_Plot'></span>

<h3>Description</h3>

<p>Plot summarizing the results of Hydro3_Estimation()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hydro3_Plot(
  H3,
  useU = FALSE,
  lwd = 2,
  cex.lab = 2,
  cex.axis = 1.3,
  pch = 19,
  col = "red"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hydro3_Plot_+3A_h3">H3</code></td>
<td>
<p>list, resulting from a call to Hydro3_Estimation()</p>
</td></tr>
<tr><td><code id="Hydro3_Plot_+3A_useu">useU</code></td>
<td>
<p>logical, use reduced variate u rather than return period T in plots?</p>
</td></tr>
<tr><td><code id="Hydro3_Plot_+3A_lwd">lwd</code>, <code id="Hydro3_Plot_+3A_cex.lab">cex.lab</code>, <code id="Hydro3_Plot_+3A_cex.axis">cex.axis</code>, <code id="Hydro3_Plot_+3A_pch">pch</code></td>
<td>
<p>numeric, graphical parameters, see ?graphics::par</p>
</td></tr>
<tr><td><code id="Hydro3_Plot_+3A_col">col</code></td>
<td>
<p>character, graphical parameter (points color)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing (just creates a plot)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
H3=Hydro3_Estimation(y,'Normal')
Hydro3_Plot(H3)
</code></pre>

<hr>
<h2 id='KS'>Kolmogorov-Smirnov Test</h2><span id='topic+KS'></span>

<h3>Description</h3>

<p>Applies a one-sample Kolmogorov-Smirnov test (see ?stats::ks.test)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KS(y, dist, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KS_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
<tr><td><code id="KS_+3A_dist">dist</code></td>
<td>
<p>character, distribution name</p>
</td></tr>
<tr><td><code id="KS_+3A_par">par</code></td>
<td>
<p>numeric vector, parameter vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>numeric, p-value of the test</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>numeric, test statistics</p>
</td></tr>
<tr><td><code>xtra</code></td>
<td>
<p>numeric, xtra information: empty for this test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(20)
KS(y,'Normal',c(0,1))
KS(y,'Normal',c(1,1))
KS(y,'Gumbel',c(0,1))
</code></pre>

<hr>
<h2 id='mcmcoptions_def'>Default MCMC options</h2><span id='topic+mcmcoptions_def'></span>

<h3>Description</h3>

<p>A named list containing the default MCMC options.
See ?Hydro3_Estimation for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcoptions_def
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 10.
</p>

<hr>
<h2 id='Metropolis_OAAT'>One-At-A-Time Metropolis sampler</h2><span id='topic+Metropolis_OAAT'></span>

<h3>Description</h3>

<p>Performs nsim iterations of the OAAT Metropolis sampler
(simulated vector is updated one component at a time).
a.k.a block Metropolis sampler with blocks of length one.
Sometimes also called 'Metropolis-within-Gibbs'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Metropolis_OAAT(f, x0, nsim, sdjump, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Metropolis_OAAT_+3A_f">f</code></td>
<td>
<p>function, log-pdf of the target distribution</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_+3A_x0">x0</code></td>
<td>
<p>numeric vector, starting point</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of simulations</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_+3A_sdjump">sdjump</code></td>
<td>
<p>numeric vector, standard deviation of the Gaussian jump for each component</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_+3A_...">...</code></td>
<td>
<p>other arguments passed to f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric matrix nsim*length(x0), MCMC simulations</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>numeric vector, corresponding values f(x)</p>
</td></tr>
<tr><td><code>moverate</code></td>
<td>
<p>numeric vector, move rate associated with each component</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate target distribution: beta(0.8,0.4) X exp(1)
f=function(x){stats::dbeta(x[1],0.8,0.4,log=TRUE)+stats::dexp(x[2],log=TRUE)}
x0=c(0.5,2)
sdjump=c(0.5,1)
mcmc=Metropolis_OAAT(f,x0,1000,sdjump)
graphicalpar=par(mfrow=c(1,3))
plot(mcmc$x);hist(mcmc$x[,1]); hist(mcmc$x[,2])
par(graphicalpar)
</code></pre>

<hr>
<h2 id='Metropolis_OAAT_adaptive'>Adaptive One-At-A-Time Metropolis sampler</h2><span id='topic+Metropolis_OAAT_adaptive'></span>

<h3>Description</h3>

<p>Performs nsim iterations of the Adaptive version of the OAAT Metropolis sampler
(see ?Metropolis_OAAT).
Adaptation is performed by monitoring move rates every batch.length iterations, and 
increasing / decreasing the jump standard deviation if the move rate is not within specified bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Metropolis_OAAT_adaptive(
  f,
  x0,
  sdjump,
  ...,
  batch.length = 100,
  batch.n = 100,
  moverate.min = 0.1,
  moverate.max = 0.5,
  mult.down = 0.9,
  mult.up = 1.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_f">f</code></td>
<td>
<p>function, log-pdf of the target distribution</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_x0">x0</code></td>
<td>
<p>numeric vector, starting point</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_sdjump">sdjump</code></td>
<td>
<p>numeric vector, initial standard deviation of the Gaussian jump for each component</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_...">...</code></td>
<td>
<p>other arguments passed to f</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_batch.length">batch.length</code></td>
<td>
<p>integer, length of each non-adaptive batch</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_batch.n">batch.n</code></td>
<td>
<p>integer, number of batches (= adaptation period). Total number of simulations is nsim=batch.n*batch.length</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_moverate.min">moverate.min</code></td>
<td>
<p>numeric in (0;1), lower bound for the desired move rate interval</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_moverate.max">moverate.max</code></td>
<td>
<p>numeric in (0;1), upper bound for the desired move rate interval</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_mult.down">mult.down</code></td>
<td>
<p>numeric in (0;1), multiplication factor used to decrease jump size when move rate is too low.</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_adaptive_+3A_mult.up">mult.up</code></td>
<td>
<p>numeric (&gt;1, avoid 1/mult.down) multiplication factor used to increase jump size when move rate is too high.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric matrix nsim*length(x0), MCMC simulations</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>numeric vector, corresponding values f(x)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate target distribution: beta(0.8,0.4) X exp(1)
f=function(x){stats::dbeta(x[1],0.8,0.4,log=TRUE)+stats::dexp(x[2],log=TRUE)}
x0=c(0.5,2)
sdjump=c(0.5,1)
mcmc=Metropolis_OAAT_adaptive(f,x0,sdjump)
graphicalpar=par(mfrow=c(1,3))
plot(mcmc$x);hist(mcmc$x[,1]); hist(mcmc$x[,2])
par(graphicalpar)
</code></pre>

<hr>
<h2 id='Metropolis_OAAT_jump'>One-At-A-Time Metropolis sampler</h2><span id='topic+Metropolis_OAAT_jump'></span>

<h3>Description</h3>

<p>Performs a single iteration of the OAAT Metropolis sampler
(simulated vector is updated one component at a time).
a.k.a block Metropolis sampler with blocks of length one.
Sometimes also called 'Metropolis-within-Gibbs'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Metropolis_OAAT_jump(f, x0, fx0, sdjump, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Metropolis_OAAT_jump_+3A_f">f</code></td>
<td>
<p>function, log-pdf of the target distribution</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_jump_+3A_x0">x0</code></td>
<td>
<p>numeric vector, starting point</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_jump_+3A_fx0">fx0</code></td>
<td>
<p>numeric, f(x0)</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_jump_+3A_sdjump">sdjump</code></td>
<td>
<p>numeric vector, standard deviation of the Gaussian jump for each component</p>
</td></tr>
<tr><td><code id="Metropolis_OAAT_jump_+3A_...">...</code></td>
<td>
<p>other arguments passed to f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>numeric vector, updated point after the iteration</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>numeric, updated value f(x)</p>
</td></tr>
<tr><td><code>move</code></td>
<td>
<p>logical vector, TRUE for components of the vector x that changed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Bivariate target distribution: beta(2,10) X exp(1)
f=function(x){stats::dbeta(x[1],2,10,log=TRUE)+stats::dexp(x[2],log=TRUE)}
x0=c(0.5,0.5)
fx0=f(x0)
sdjump=c(0.1,0.1)
Metropolis_OAAT_jump(f,x0,fx0,sdjump)
</code></pre>

<hr>
<h2 id='MK'>Mann-Kemdall Test</h2><span id='topic+MK'></span>

<h3>Description</h3>

<p>Applies the Mann-Kendall trend test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MK(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MK_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>numeric, p-value of the test</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>numeric, test statistics</p>
</td></tr>
<tr><td><code>xtra</code></td>
<td>
<p>numeric, xtra information: empty for this test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
MK(y)
y=y+0.1*(1:length(y))
MK(y)
</code></pre>

<hr>
<h2 id='options_def'>Default estimation options</h2><span id='topic+options_def'></span>

<h3>Description</h3>

<p>A named list containing the default estimation options.
See ?Hydro3_Estimation for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_def
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>

<hr>
<h2 id='Pettitt'>Pettitt Test</h2><span id='topic+Pettitt'></span>

<h3>Description</h3>

<p>Applies the Pettitt step-change test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pettitt(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pettitt_+3A_y">y</code></td>
<td>
<p>numeric vector, data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>numeric, p-value of the test</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>numeric, test statistics</p>
</td></tr>
<tr><td><code>xtra</code></td>
<td>
<p>numeric, xtra information: position of the step change</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=stats::rnorm(50)
Pettitt(y)
y[26:50]=y[26:50]+2
Pettitt(y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
