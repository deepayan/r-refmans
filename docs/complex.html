<!DOCTYPE html><html><head><title>Help for package complex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {complex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cacf'><p>Complex Correlation Function Estimation</p></a></li>
<li><a href='#clm'><p>Complex Linear Model</p></a></li>
<li><a href='#clog'><p>Functions that transform real and imaginary parts of a complex variable</p></a></li>
<li><a href='#complex2mat'><p>Functions to manipulate complex variables and matrices</p></a></li>
<li><a href='#cplot'><p>Scatterplots for complex variables</p></a></li>
<li><a href='#cscale'><p>Functions scale real and imaginary parts of a complex variable</p></a></li>
<li><a href='#cvar'><p>Correlation, Variance and Covariance (Matrices) for complex variables</p></a></li>
<li><a href='#dcnorm'><p>Complex Normal Distribution</p></a></li>
<li><a href='#invert'><p>Function calculates inverse of matrix of complex variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Analysis and Forecasting Using Complex Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-09</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/config-i1/complex">https://github.com/config-i1/complex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/config-i1/complex/issues">https://github.com/config-i1/complex/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of function implementing the instruments for complex-valued modelling,
             including time series analysis and forecasting. This is based on the monograph
             by Svetunkov Sergey and Svetunkov Ivan "Complex-valued Econometrics with Examples in R"
             which is in press by Springer (expected to be published in 2024).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), greybox (&ge; 0.5.0), legion</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, nloptr, mvtnorm, pracma</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-09 11:29:51 UTC; config</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Svetunkov [aut, cre] (Lecturer at Centre for Marketing Analytics
    and Forecasting, Lancaster University, UK)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Svetunkov &lt;ivan@svetunkov.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-09 16:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cacf'>Complex Correlation Function Estimation</h2><span id='topic+cacf'></span><span id='topic+cpacf'></span><span id='topic+print.cacf'></span><span id='topic+plot.cacf'></span>

<h3>Description</h3>

<p>The functions compute (and by default plot) estimates of the Complex Autocovariance,
or Complex Autocorrelation, or Partial Complex Autocorrelation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cacf(x, lag.max = NULL, method = c("direct", "conjugate", "pearson",
  "kendall", "spearman"), type = c("correlation", "covariance", "partial"),
  plot = TRUE, ...)

cpacf(x, lag.max = NULL, method = c("direct", "conjugate", "pearson",
  "kendall", "spearman"), plot = TRUE, ...)

## S3 method for class 'cacf'
print(x, ...)

## S3 method for class 'cacf'
plot(x, which = c(1, 2), ask = length(which) &gt; 1,
  level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cacf_+3A_x">x</code></td>
<td>
<p>vector of complex variables.</p>
</td></tr>
<tr><td><code id="cacf_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum number of lags. See <a href="stats.html#topic+acf">acf</a> for more details.</p>
</td></tr>
<tr><td><code id="cacf_+3A_method">method</code></td>
<td>
<p>method to use in the calculation of the measure. <code>"conjugate"</code> means that it is based
on the multiplication by conjugate number. <code>"direct"</code> means the calculation
without the conjugate (i.e. &quot;pseudo&quot; moment). <code>method</code>
can also be &quot;pearson&quot;, &quot;kendall&quot;, or &quot;spearman&quot;, defining what correlation coefficient
to use after the MDS transformation of complex variables <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="cacf_+3A_type">type</code></td>
<td>
<p>character string giving the type of cACF to be computed. Allowed values
are &quot;correlation&quot; (the default) and &quot;covariance&quot;. Will be partially matched.</p>
</td></tr>
<tr><td><code id="cacf_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the cACF is plotted on complex plane
and as two linear graphs for real and imaginary parts.</p>
</td></tr>
<tr><td><code id="cacf_+3A_...">...</code></td>
<td>
<p>Parameter for the plot() function.</p>
</td></tr>
<tr><td><code id="cacf_+3A_which">which</code></td>
<td>
<p>Determines, which of the plots to produce. 1 is the plot of real
and imaginary parts. 2 is the plot of absolute value and the argument.</p>
</td></tr>
<tr><td><code id="cacf_+3A_ask">ask</code></td>
<td>
<p>Determines, whether to ask before producing a new plot or not.</p>
</td></tr>
<tr><td><code id="cacf_+3A_level">level</code></td>
<td>
<p>Confidence level for the non-rejection region of the correlation
coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>type="correlation"</code> and <code>"covariance"</code>, the estimates are based
on the sample pseudo covariance and use pseudo correlation <a href="#topic+ccor">ccor</a> and complex
covariance <a href="#topic+ccov">ccov</a> respectively. Note that the function does not calculate values for
lag 0. Also, the function will automatically remove NAs. Finally, function does not have
<code>demean</code> parameter (as, for example, is done in <a href="stats.html#topic+acf">acf</a>), because <code>ccov()</code>
and <code>ccor()</code> do that automatically.
</p>
<p><code>cpacf()</code> produces the partial complex ACF based on complex regression model of variable
on its lags.
</p>
<p>The generic function plot has a method for objects of class &quot;cacf&quot;.
</p>
<p>The lag is returned and plotted in units of time, and not numbers of observations.
</p>
<p>There is a print and plot methods for objects of class &quot;cacf&quot;.
</p>


<h3>Value</h3>

<p>An object of class &quot;cacf&quot;, which is a list with the following elements:
</p>

<ul>
<li> <p><code>lag</code> A three dimensional array containing the lags at which the cACF is estimated.
</p>
</li>
<li> <p><code>acf</code> An array with the same dimensions as lag containing the estimated cACF.
</p>
</li>
<li> <p><code>method</code> The method used in calculation (same as the method argument).
</p>
</li>
<li> <p><code>type</code> The type of correlation (same as the type argument).
</p>
</li>
<li> <p><code>n.used</code> The number of observations in the time series.
</p>
</li>
<li> <p><code>series</code> The name of the series x.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="stats.html#topic+acf">acf</a>, <a href="#topic+ccor">ccor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
x &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))

# Calculate cACF
cacf(x)

</code></pre>

<hr>
<h2 id='clm'>Complex Linear Model</h2><span id='topic+clm'></span><span id='topic+sigma.clm'></span><span id='topic+vcov.clm'></span><span id='topic+summary.clm'></span>

<h3>Description</h3>

<p>Function estimates complex variables model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clm(formula, data, subset, na.action, loss = c("likelihood", "OLS", "CLS",
  "MSE", "MAE", "HAM"), orders = c(0, 0, 0), scaling = c("normalisation",
  "standardisation", "max", "none"), parameters = NULL, fast = FALSE, ...)

## S3 method for class 'clm'
sigma(object, type = NULL, ...)

## S3 method for class 'clm'
vcov(object, type = NULL, ...)

## S3 method for class 'clm'
summary(object, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to
that class): a symbolic description of the model to be fitted. Can also include
<code>trend</code>, which would add the global trend.</p>
</td></tr>
<tr><td><code id="clm_+3A_data">data</code></td>
<td>
<p>a data frame or a matrix, containing the variables in the model.</p>
</td></tr>
<tr><td><code id="clm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="clm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the
data contain NAs. The default is set by the na.action setting of
<a href="base.html#topic+options">options</a>, and is <a href="stats.html#topic+na.fail">na.fail</a> if that is unset. The
factory-fresh default is <a href="stats.html#topic+na.omit">na.omit</a>. Another possible value
is NULL, no action. Value <a href="stats.html#topic+na.exclude">na.exclude</a> can be useful.</p>
</td></tr>
<tr><td><code id="clm_+3A_loss">loss</code></td>
<td>
<p>The type of Loss Function used in optimization. <code>loss</code> can
be:
</p>

<ul>
<li> <p><code>OLS</code> - Ordinary Least Squares method, relying on the minimisation of
the conjoint variance of the error term;
</p>
</li>
<li> <p><code>CLS</code> - Complex Least Squares method, relying on the minimisation of
the complex variance of the error term;
</p>
</li>
<li> <p><code>likelihood</code> - the model is estimated via the maximisation of the
likelihood of the complex Normal distribution;
</p>
</li>
<li> <p><code>MSE</code> (Mean Squared Error),
</p>
</li>
<li> <p><code>MAE</code> (Mean Absolute Error),
</p>
</li>
<li> <p><code>HAM</code> (Half Absolute Moment),
</p>
</li></ul>

<p>A user can also provide their own function here as well, making sure
that it accepts parameters <code>actual</code>, <code>fitted</code> and <code>B</code>. Here is an
example:
</p>
<p><code>lossFunction &lt;- function(actual, fitted, B, xreg) return(mean(abs(actual-fitted)))</code>
<code>loss=lossFunction</code></p>
</td></tr>
<tr><td><code id="clm_+3A_orders">orders</code></td>
<td>
<p>vector of orders of complex ARIMA(p,d,q).</p>
</td></tr>
<tr><td><code id="clm_+3A_scaling">scaling</code></td>
<td>
<p>NOT YET IMPLEMENTED!!! Defines what type of scaling to do for the variables.
See <a href="#topic+cscale">cscale</a> for the explanation of the options.</p>
</td></tr>
<tr><td><code id="clm_+3A_parameters">parameters</code></td>
<td>
<p>vector of parameters of the linear model. When <code>NULL</code>, it
is estimated.</p>
</td></tr>
<tr><td><code id="clm_+3A_fast">fast</code></td>
<td>
<p>if <code>TRUE</code>, then the function won't check whether
the data has variability and whether the regressors are correlated. Might
cause trouble, especially in cases of multicollinearity.</p>
</td></tr>
<tr><td><code id="clm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to internal functions.</p>
</td></tr>
<tr><td><code id="clm_+3A_object">object</code></td>
<td>
<p>Object of class &quot;clm&quot; estimated via <code>clm()</code> function.</p>
</td></tr>
<tr><td><code id="clm_+3A_type">type</code></td>
<td>
<p>Type of sigma to return. This is calculated based on the residuals
of the estimated model and can be <code>"direct"</code>, based on the direct variance,
<code>"conjugate"</code>, based on the conjugate variance and <code>"matrix"</code>, returning
covariance matrix for the complex error. If <code>NULL</code> then will return value based
on the loss used in the estimation: OLS -&gt; &quot;conjugate&quot;, CLS -&gt; &quot;direct&quot;, likelihood -&gt;
&quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="clm_+3A_level">level</code></td>
<td>
<p>What confidence level to use for the parameters of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function, similar to <a href="stats.html#topic+lm">lm</a>, but supporting several estimation
techniques for complex variables regression.
</p>


<h3>Value</h3>

<p>Function returns <code>model</code> - the final model of the class
&quot;clm&quot;, which contains:
</p>

<ul>
<li><p> coefficients - estimated parameters of the model,
</p>
</li>
<li><p> FI - Fisher Information of parameters of the model. Returned only when <code>FI=TRUE</code>,
</p>
</li>
<li><p> fitted - fitted values,
</p>
</li>
<li><p> residuals - residuals of the model,
</p>
</li>
<li><p> mu - the estimated location parameter of the distribution,
</p>
</li>
<li><p> scale - the estimated scale parameter of the distribution. If a formula was provided for
scale, then an object of class &quot;scale&quot; will be returned.
</p>
</li>
<li><p> logLik - log-likelihood of the model. Only returned, when <code>loss="likelihood"</code>
and in a special case of complex least squares.
</p>
</li>
<li><p> loss - the type of the loss function used in the estimation,
</p>
</li>
<li><p> lossFunction - the loss function, if the custom is provided by the user,
</p>
</li>
<li><p> lossValue - the value of the loss function,
</p>
</li>
<li><p> df.residual - number of degrees of freedom of the residuals of the model,
</p>
</li>
<li><p> df - number of degrees of freedom of the model,
</p>
</li>
<li><p> call - how the model was called,
</p>
</li>
<li><p> rank - rank of the model,
</p>
</li>
<li><p> data - data used for the model construction,
</p>
</li>
<li><p> terms - terms of the data. Needed for some additional methods to work,
</p>
</li>
<li><p> B - the value of the optimised parameters. Typically, this is a duplicate of coefficients,
</p>
</li>
<li><p> other - the list of all the other parameters either passed to the
function or estimated in the process, but not included in the standard output
(e.g. <code>alpha</code> for Asymmetric Laplace),
</p>
</li>
<li><p> timeElapsed - the time elapsed for the estimation of the model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="greybox.html#topic+alm">alm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### An example with mtcars data and factors
x &lt;- complex(real=rnorm(1000,10,10), imaginary=rnorm(1000,10,10))
a0 &lt;- 10 + 15i
a1 &lt;- 2-1.5i
y &lt;- a0 + a1 * x + 1.5*complex(real=rnorm(length(x),0,1), imaginary=rnorm(length(x),0,1))

complexData &lt;- cbind(y=y,x=x)
complexModel &lt;- clm(y~x, complexData)
summary(complexModel)

plot(complexModel, 7)

</code></pre>

<hr>
<h2 id='clog'>Functions that transform real and imaginary parts of a complex variable</h2><span id='topic+clog'></span><span id='topic+cexp'></span>

<h3>Description</h3>

<p>Function <code>clog()</code> will take logarithm of real and imaginary parts separately
and then merge the resulting variable in the complex one. The function
<code>cexp()</code> does the opposite transform, taking exponent of parts and then
merging them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clog(y, base = exp(1))

cexp(y, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clog_+3A_y">y</code></td>
<td>
<p>vector of a complex variable in the original scale.</p>
</td></tr>
<tr><td><code id="clog_+3A_base">base</code></td>
<td>
<p>a positive or complex number: the base with respect to which
logarithms/powers are computed. Defaults to exp(1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same size as <code>y</code>, containing transformed complex variable.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cscale">cscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
y &lt;- complex(real=rnorm(100,100,10), imaginary=rnorm(100,100,10))

yLog &lt;- clog(y)
cexp(yLog)

</code></pre>

<hr>
<h2 id='complex2mat'>Functions to manipulate complex variables and matrices</h2><span id='topic+complex2mat'></span><span id='topic+complex2vec'></span><span id='topic+mat2complex'></span><span id='topic+vec2complex'></span>

<h3>Description</h3>

<p><code>complex2mat()</code> constructs a matrix from the provided complex variable,
while <code>complex2vec()</code> returns a vector (in mathematical sense), both of them
split the real and imaginary parts. <code>mat2complex()</code> and <code>vec2complex()</code> do
the reverse of the respective functions. See details for explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex2mat(x)

complex2vec(x)

mat2complex(x)

vec2complex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex2mat_+3A_x">x</code></td>
<td>
<p>vector or matrix of complex variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complex variable x + iy can be represented as a vector (x y)' or as a matrix:
(x -y)
(y  x)
</p>
<p><code>complex2mat()</code> returns the latter, while <code>complex2vec()</code> returns the
former. If a user provides a vector of complex variables, the values are stacked above
each other. If a matrix is provided, a higher dimensional matrix is returned.
</p>
<p><code>mat2complex()</code> and <code>vec2complex()</code> return complex variables based on provided
matrix.
</p>
<p>The function is needed to calculate some statistics for complex variables in vector form.
</p>


<h3>Value</h3>

<p>A matrix with real and imaginary parts of x split into columns (and rows in case
of <code>complex2mat()</code>).
</p>
<p>#' @references </p>

<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+clm">clm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
x &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))

# Get a matrix and a vector for one value
complex2mat(x[1])
complex2vec(x[1])

# Get matrices for all values
complex2mat(x)
complex2vec(x)

</code></pre>

<hr>
<h2 id='cplot'>Scatterplots for complex variables</h2><span id='topic+cplot'></span>

<h3>Description</h3>

<p>Function produces six scatterplots to show relations between the two complex variables x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot(x, y, which = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot_+3A_x">x</code></td>
<td>
<p>vector of a complex variable.</p>
</td></tr>
<tr><td><code id="cplot_+3A_y">y</code></td>
<td>
<p>second vector of a complex variable.</p>
</td></tr>
<tr><td><code id="cplot_+3A_which">which</code></td>
<td>
<p>defines, what type of plot to produce. <code>which=1</code> will produce
six scatterplots, while <code>which=2</code> will produce a scatterplot of data after
multidimensional scaling (creating projections of complex variables to x and y axes).</p>
</td></tr>
<tr><td><code id="cplot_+3A_...">...</code></td>
<td>
<p>otehr parameters passed to plot method. Works only for <code>which=2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots are positioned to satisfy two rules:
1. When a scatterplot for a c.r.v. is produced, the real part should be in x-axis,
while the imaginary should be in the y-axis.
2. When parts of variables x and y are compared, the part for $x$ should be in x-axis,
while the part for y should be in y-axis, which should the reflect the idea that x could
be an explanatory variable for y.
</p>


<h3>Value</h3>

<p>The function produces a plot and does not return any value
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ccor">ccor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
x &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))
y &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))

cplot(x, y)

</code></pre>

<hr>
<h2 id='cscale'>Functions scale real and imaginary parts of a complex variable</h2><span id='topic+cscale'></span><span id='topic+cdescale'></span>

<h3>Description</h3>

<p>Function <code>cscale()</code> will do the scaling based on the selected method, while
the function <code>cdescale()</code> will transform the variable to get to the
original units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cscale(y, scaling = c("normalisation", "standardisation", "max"))

cdescale(yScaled, y, scaling = c("normalisation", "standardisation", "max"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cscale_+3A_y">y</code></td>
<td>
<p>vector of a complex variable in the original scale.</p>
</td></tr>
<tr><td><code id="cscale_+3A_scaling">scaling</code></td>
<td>
<p>scaling method to use. &quot;normalisation&quot; implies scaling
to make sure that <code>y</code> lie in [0, 1] (subtract the minimum value and divide by
the range). &quot;standardisation&quot; standardises the variable (i.e. subtract the mean
then divide by standard deviation). &quot;max&quot; just divides the variable by the
maximum value.</p>
</td></tr>
<tr><td><code id="cscale_+3A_yscaled">yScaled</code></td>
<td>
<p>vector of the already scaled complex variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same size as <code>y</code>, containing scaled complex variable.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
y &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))

yScaled &lt;- cscale(y)
cdescale(yScaled, y)

</code></pre>

<hr>
<h2 id='cvar'>Correlation, Variance and Covariance (Matrices) for complex variables</h2><span id='topic+cvar'></span><span id='topic+ccov'></span><span id='topic+ccor'></span><span id='topic+ccov2cor'></span><span id='topic+covar'></span>

<h3>Description</h3>

<p>Functions <code>cvar()</code>, <code>ccov()</code> and <code>ccor()</code> return respectively
complex variance, covariance and correlation based on the
provided complex vector/matrix <code>x</code>. Function <code>covar()</code> returns the covariance
matrix based on a complex vector/matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvar(x, method = c("direct", "conjugate"), df = NULL, ...)

ccov(x, y, method = c("direct", "conjugate"), df = NULL, ...)

ccor(x, y, method = c("direct", "conjugate", "pearson", "kendall",
  "spearman"), ...)

ccov2cor(V)

covar(x, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvar_+3A_x">x</code></td>
<td>
<p>vector or matrix of complex variables. If it is matrix then the
variable <code>y</code> is ignored.</p>
</td></tr>
<tr><td><code id="cvar_+3A_method">method</code></td>
<td>
<p>method to use in the calculation of the measure. <code>"conjugate"</code> means that it is based
on the multiplication by conjugate number. <code>"direct"</code> means the calculation
without the conjugate (i.e. &quot;pseudo&quot; moment). For <code>ccor</code> the variable <code>method</code>
can also be &quot;pearson&quot;, &quot;kendall&quot;, or &quot;spearman&quot;, defining what correlation coefficient
to use after the MDS transformation of complex variables <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="cvar_+3A_df">df</code></td>
<td>
<p>Number of degrees of freedom to use in the calculation of the statistics.</p>
</td></tr>
<tr><td><code id="cvar_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>mean()</code> functions. For example, this can be
<code>na.rm=TRUE</code> to remove missing values or <code>trim</code> to define the trimming
in the mean (see <a href="base.html#topic+mean">mean</a>).</p>
</td></tr>
<tr><td><code id="cvar_+3A_y">y</code></td>
<td>
<p>second vector to calculate covariance or correlations with.</p>
</td></tr>
<tr><td><code id="cvar_+3A_v">V</code></td>
<td>
<p>complex (pseudo)covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the parametric correlation is supported by the function. If <code>x</code>
is matrix, then <code>y</code> is ignored.
</p>
<p><code>covar()</code> function returns a covariance matrix calculated for the provided complex
vector or matrix <code>x</code>.
</p>


<h3>Value</h3>

<p>A scalar or a matrix with resulting complex variables.
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>References</h3>


<ul>
<li><p> Svetunkov, S. &amp; Svetunkov I. (2022) Complex Autoregressions. In Press.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate random complex variables
x &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))
y &lt;- complex(real=rnorm(100,10,10), imaginary=rnorm(100,10,10))

# Create a matrix of complex variables
z &lt;- cbind(x,y)

# Calculate measures
cvar(x)
cvar(z)
ccor(x,y)
ccor(z)

</code></pre>

<hr>
<h2 id='dcnorm'>Complex Normal Distribution</h2><span id='topic+dcnorm'></span><span id='topic+cnormal'></span><span id='topic+pcnorm'></span><span id='topic+qcnorm'></span><span id='topic+rcnorm'></span>

<h3>Description</h3>

<p>Density, cumulative distribution, quantile functions and random number
generation for the Complex Normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcnorm(q, mu = 0, sigma2 = 1, varsigma2 = 0, log = FALSE, ...)

pcnorm(lower = -Inf, upper = Inf, mu = 0, sigma2 = 1, varsigma2 = 0,
  ...)

qcnorm(p, mu = 0, sigma2 = 1, varsigma2 = 0, ...)

rcnorm(n = 1, mu = 0, sigma2 = 1, varsigma2 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_mu">mu</code></td>
<td>
<p>vector of location parameters (means).</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_sigma2">sigma2</code></td>
<td>
<p>vector of conjugate variances.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_varsigma2">varsigma2</code></td>
<td>
<p>vector of direct variances.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_log">log</code></td>
<td>
<p>if <code>TRUE</code>, then probabilities are returned in
logarithms.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_...">...</code></td>
<td>
<p>Other parameters passed to the <code>mvtnorm</code> functions.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_lower">lower</code></td>
<td>
<p>complex number of lower limits of length n.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_upper">upper</code></td>
<td>
<p>complex number of upper limits of length n.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="dcnorm_+3A_n">n</code></td>
<td>
<p>number of observations. Should be a single number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complex Normal distribution is a special case of a multivariate normal
distribution, which is parametrised using direct and conjugate variances
instead of the covariance matrix.
</p>
<p>These functions are just wrappers for the functions from the <code>mvtnorm</code>
package.
</p>
<p>Note that <code>sigma2</code> and <code>varsigma2</code> are the conjugate and direct
variances, not the standard deviations!
</p>
<p>Both <code>pcnorm</code> and <code>qcnorm</code> are returned for the lower
tail of the distribution.
</p>
<p>All the functions are defined for non-negative values only.
</p>


<h3>Value</h3>

<p>Depending on the function, various things are returned
(usually either vector or scalar):
</p>

<ul>
<li> <p><code>dcnorm</code> returns the density function values for the
provided parameters, based on <a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a> function.
</p>
</li>
<li> <p><code>pcnorm</code> returns the values of the cumulative function
for the provided parameters, based on <a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a> function.
</p>
</li>
<li> <p><code>qcnorm</code> returns quantiles of the distribution,
based on <a href="mvtnorm.html#topic+qmvnorm">qmvnorm</a> function.
</p>
</li>
<li> <p><code>rcnorm</code> returns a vector of random variables
generated from the Complex Normal distribution,
based on <a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a> function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dcnorm(89+90i, 100+100i, 2, 1+1i)
pcnorm(90+90i, 110+110i, 100+100i, 2, 1+1i)
qcnorm(0.95, 100+100i, 2, 1+1i)
rcnorm(1000, 100+100i, 2, 1+1i)

</code></pre>

<hr>
<h2 id='invert'>Function calculates inverse of matrix of complex variables</h2><span id='topic+invert'></span>

<h3>Description</h3>

<p>The function accepts a square complex matrix and returns inverse of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_+3A_x">x</code></td>
<td>
<p>The square matrix of complex variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix of the same size as the original
matrix <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Ivan Svetunkov, <a href="mailto:ivan@svetunkov.ru">ivan@svetunkov.ru</a>
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+solve">solve</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
invert(matrix(complex(real=c(1,2), imaginary=c(1.1,2.1)), 2, 2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
