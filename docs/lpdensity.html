<!DOCTYPE html><html lang="en"><head><title>Help for package lpdensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpdensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lpdensity-package'><p>lpdensity: Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#bw_IMSE'><p>Internal function.</p></a></li>
<li><a href='#bw_IROT'><p>Internal function.</p></a></li>
<li><a href='#bw_MSE'><p>Internal function.</p></a></li>
<li><a href='#bw_ROT'><p>Internal function.</p></a></li>
<li><a href='#Cgenerate'><p>Internal function.</p></a></li>
<li><a href='#coef.lpbwdensity'><p>Coef Method for Local Polynomial Density Bandwidth Selection</p></a></li>
<li><a href='#coef.lpdensity'><p>Coef Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#confint.lpdensity'><p>Confint Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#Ggenerate'><p>Internal function.</p></a></li>
<li><a href='#lpbwdensity'><p>Data-driven Bandwidth Selection for Local Polynomial Density Estimators</p></a></li>
<li><a href='#lpdensity'><p>Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#lpdensity_fn'><p>Supporting Function for <code>lpdensity</code></p></a></li>
<li><a href='#lpdensity.plot'><p>Plot Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#lpdensityUnique'><p>Internal function.</p></a></li>
<li><a href='#normal_dgps'><p>Internal function.</p></a></li>
<li><a href='#plot.lpdensity'><p>Plot Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#print.lpbwdensity'><p>Print Method for Local Polynomial Density Bandwidth Selection</p></a></li>
<li><a href='#print.lpdensity'><p>Print Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#Sgenerate'><p>Internal function.</p></a></li>
<li><a href='#summary.lpbwdensity'><p>Summary Method for Local Polynomial Density Bandwidth Selection</p></a></li>
<li><a href='#summary.lpdensity'><p>Summary Method for Local Polynomial Density Estimation and Inference</p></a></li>
<li><a href='#Tgenerate'><p>Internal function.</p></a></li>
<li><a href='#vcov.lpdensity'><p>Vcov Method for Local Polynomial Density Estimation and Inference</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Local Polynomial Density Estimation and Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Matias D. Cattaneo [aut],
  Michael Jansson [aut],
  Xinwei Ma [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xinwei Ma &lt;x1ma@ucsd.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Without imposing stringent distributional assumptions or shape restrictions, nonparametric estimation has been popular in economics and other social sciences for counterfactual analysis, program evaluation, and policy recommendations. This package implements a novel density (and derivatives) estimator based on local polynomial regressions, documented in Cattaneo, Jansson and Ma (2022) &lt;<a href="https://doi.org/10.18637%2Fjss.v101.i02">doi:10.18637/jss.v101.i02</a>&gt;: lpdensity() to construct local polynomial based density (and derivatives) estimator, and lpbwdensity() to perform data-driven bandwidth selection. </td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, MASS</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-06 05:53:49 UTC; xinweima</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-06 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lpdensity-package'>lpdensity: Local Polynomial Density Estimation and Inference</h2><span id='topic+lpdensity-package'></span>

<h3>Description</h3>

<p>Without imposing stringent distributional assumptions or shape restrictions,
nonparametric estimation has been popular in economics and other social
sciences for counterfactual analysis, program evaluation, and policy recommendations.
This package implements a novel density (and derivatives) estimator based on local polynomial
regressions, documented in Cattaneo, Jansson and Ma (2020, 2023).
</p>
<p><code><a href="#topic+lpdensity">lpdensity</a></code> implements the local polynomial regression based density (and derivatives)
estimator. Robust bias-corrected inference methods, both pointwise (confidence intervals) and
uniform (confidence bands), are also implemented. <code><a href="#topic+lpbwdensity">lpbwdensity</a></code> implements the bandwidth
selection methods. See Cattaneo, Jansson and Ma (2022) for more implementation details and illustrations.
</p>
<p>Related <code>Stata</code> and <code>R</code> packages useful for nonparametric estimation and inference are
available at <a href="https://nppackages.github.io/">https://nppackages.github.io/</a>.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>References</h3>

<p>Calonico, S., M. D. Cattaneo, and M. H. Farrell. 2018.
On the Effect of Bias Estimation on Coverage Accuracy in Nonparametric Inference.
<em>Journal of the American Statistical Association</em>, 113(522): 767-779.
<a href="https://doi.org/10.1080/01621459.2017.1285776">doi:10.1080/01621459.2017.1285776</a>
</p>
<p>Calonico, S., M. D. Cattaneo, and M. H. Farrell. 2022.
Coverage Error Optimal Confidence Intervals for Local Polynomial Regression.
<em>Bernoulli</em>, 28(4): 2998-3022.
<a href="https://doi.org/10.3150/21-BEJ1445">doi:10.3150/21-BEJ1445</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2020.
Simple Local Polynomial Density Estimators.
<em>Journal of the American Statistical Association</em>, 115(531): 1449-1455.
<a href="https://doi.org/10.1080/01621459.2019.1635480">doi:10.1080/01621459.2019.1635480</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2022.
lpdensity: Local Polynomial Density Estimation and Inference.
<em>Journal of Statistical Software</em>, 101(2): 1â€“25.
<a href="https://doi.org/10.18637/jss.v101.i02">doi:10.18637/jss.v101.i02</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2023.
Local Regression Distribution Estimators.
<em>Journal of Econometrics</em>, 240(2): 105074.
<a href="https://doi.org/10.1016/j.jeconom.2021.01.006">doi:10.1016/j.jeconom.2021.01.006</a>
</p>

<hr>
<h2 id='bw_IMSE'>Internal function.</h2><span id='topic+bw_IMSE'></span>

<h3>Description</h3>

<p>Calculates integrated MSE-optimal bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_IMSE(
  data,
  grid,
  p,
  v,
  kernel,
  Cweights,
  Pweights,
  massPoints,
  stdVar,
  regularize,
  nLocalMin,
  nUniqueMin
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_IMSE_+3A_data">data</code></td>
<td>
<p>Numeric vector, the data.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_v">v</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector, the counterfactual weights.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector, the survey sampling weights.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_masspoints">massPoints</code></td>
<td>
<p>Boolean, whether whether point estimates and standard errors
should be corrected if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_stdvar">stdVar</code></td>
<td>
<p>Boolean, whether the data should be standardized for bandwidth selection.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_regularize">regularize</code></td>
<td>
<p>Boolean, Whether the bandwidth should be regularized.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, minimum number of observations in each local neighborhood.</p>
</td></tr>
<tr><td><code id="bw_IMSE_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, minimum number of unique observations in each local neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar: a single bandwidth.
</p>

<hr>
<h2 id='bw_IROT'>Internal function.</h2><span id='topic+bw_IROT'></span>

<h3>Description</h3>

<p>Calculates integrated rule-of-thumb bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_IROT(
  data,
  grid,
  p,
  v,
  kernel,
  Cweights,
  Pweights,
  massPoints,
  stdVar,
  regularize,
  nLocalMin,
  nUniqueMin
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_IROT_+3A_data">data</code></td>
<td>
<p>Numeric vector, the data.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_v">v</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector, the counterfactual weights.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector, the survey sampling weights.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_masspoints">massPoints</code></td>
<td>
<p>Boolean, whether point estimates and standard errors
should be corrected if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_stdvar">stdVar</code></td>
<td>
<p>Boolean, whether the data should be standardized for bandwidth selection.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_regularize">regularize</code></td>
<td>
<p>Boolean, Whether the bandwidth should be regularized.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, minimum number of observations in each local neighborhood.</p>
</td></tr>
<tr><td><code id="bw_IROT_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, minimum number of unique observations in each local neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar: a single bandwidth.
</p>

<hr>
<h2 id='bw_MSE'>Internal function.</h2><span id='topic+bw_MSE'></span>

<h3>Description</h3>

<p>Calculates MSE-optimal bandwidths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_MSE(
  data,
  grid,
  p,
  v,
  kernel,
  Cweights,
  Pweights,
  massPoints,
  stdVar,
  regularize,
  nLocalMin,
  nUniqueMin
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_MSE_+3A_data">data</code></td>
<td>
<p>Numeric vector, the data.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_v">v</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector, the counterfactual weights.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector, the survey sampling weights.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_masspoints">massPoints</code></td>
<td>
<p>Boolean, whether whether point estimates and standard errors
should be corrected if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_stdvar">stdVar</code></td>
<td>
<p>Boolean, whether the data should be standardized for bandwidth selection.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_regularize">regularize</code></td>
<td>
<p>Boolean, whether the bandwidth should be regularized.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, minimum number of observations in each local neighborhood.</p>
</td></tr>
<tr><td><code id="bw_MSE_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, minimum number of unique observations in each local neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector: bandwidth sequence.
</p>

<hr>
<h2 id='bw_ROT'>Internal function.</h2><span id='topic+bw_ROT'></span>

<h3>Description</h3>

<p>Calculates rule-of-thumb bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_ROT(
  data,
  grid,
  p,
  v,
  kernel,
  Cweights,
  Pweights,
  massPoints,
  stdVar,
  regularize,
  nLocalMin,
  nUniqueMin
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_ROT_+3A_data">data</code></td>
<td>
<p>Numeric vector, the data.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_v">v</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector, the counterfactual weights.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector, the survey sampling weights.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_masspoints">massPoints</code></td>
<td>
<p>Boolean, whether whether point estimates and standard errors
should be corrected if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_stdvar">stdVar</code></td>
<td>
<p>Boolean, whether the data should be standardized for bandwidth selection.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_regularize">regularize</code></td>
<td>
<p>Boolean, whether the bandwidth should be regularized.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, minimum number of observations in each local
neighborhood.</p>
</td></tr>
<tr><td><code id="bw_ROT_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, minimum number of unique observations in
each local neighborhood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector: a bandwidth sequence.
</p>

<hr>
<h2 id='Cgenerate'>Internal function.</h2><span id='topic+Cgenerate'></span>

<h3>Description</h3>

<p>Generate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cgenerate(k, p, low = -1, up = 1, kernel = "triangular")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cgenerate_+3A_k">k</code></td>
<td>
<p>Nonnegative integer, extra order (usually p+1).</p>
</td></tr>
<tr><td><code id="Cgenerate_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, the polynomial order.</p>
</td></tr>
<tr><td><code id="Cgenerate_+3A_low">low</code>, <code id="Cgenerate_+3A_up">up</code></td>
<td>
<p>Scalar, between -1 and 1, region of integration.</p>
</td></tr>
<tr><td><code id="Cgenerate_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (p+1)-by-1 matrix.
</p>

<hr>
<h2 id='coef.lpbwdensity'>Coef Method for Local Polynomial Density Bandwidth Selection</h2><span id='topic+coef.lpbwdensity'></span>

<h3>Description</h3>

<p>The coef method for local polynomial density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwdensity'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lpbwdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpbwdensity&quot; object, obtained by calling <code><a href="#topic+lpbwdensity">lpbwdensity</a></code>.</p>
</td></tr>
<tr><td><code id="coef.lpbwdensity_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing grid points and selected bandwidths.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwdensity">lpbwdensity</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwdensity">coef.lpbwdensity</a></code>, <code><a href="#topic+print.lpbwdensity">print.lpbwdensity</a></code>, <code><a href="#topic+summary.lpbwdensity">summary.lpbwdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Construct bandwidth
coef(lpbwdensity(X))

</code></pre>

<hr>
<h2 id='coef.lpdensity'>Coef Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+coef.lpdensity'></span>

<h3>Description</h3>

<p>The coef method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.lpdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained by calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="coef.lpdensity_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing grid points and density estimates using p- and q-th order local polynomials.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report results
coef(lpdensity(data = X, bwselect = "imse-dpi"))

</code></pre>

<hr>
<h2 id='confint.lpdensity'>Confint Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+confint.lpdensity'></span>

<h3>Description</h3>

<p>The confint method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
confint(object, parm = NULL, level = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.lpdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained by calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="confint.lpdensity_+3A_parm">parm</code></td>
<td>
<p>Integer, indicating which parameters are to be given confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.lpdensity_+3A_level">level</code></td>
<td>
<p>Numeric scalar between 0 and 1, the significance level for computing confidence intervals</p>
</td></tr>
<tr><td><code id="confint.lpdensity_+3A_...">...</code></td>
<td>
<p>Additional options, including (i) <code>grid</code> specifies a subset of grid points
to display the bandwidth; (ii) <code>gridIndex</code> specifies the indices of grid points
to display the bandwidth (this is the same as <code>parm</code>); (iii) <code>alpha</code> specifies the significance level
(this is <code>1-level</code>); (iv)
<code>CIuniform</code> specifies whether displaying pointwise confidence intervals (<code>FALSE</code>, default) or
the uniform confidence band (<code>TRUE</code>); (v) <code>CIsimul</code> specifies the number of simulations used
to construct critical values (default is 2000).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing grid points and confidence interval end points using p- and q-th order local polynomials.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report 95% confidence intervals
est1 &lt;- lpdensity(data = X, bwselect = "imse-dpi")
confint(est1)

# Report results for a subset of grid points
confint(est1, parm=est1$Estimate[4:10, "grid"])
confint(est1, grid=est1$Estimate[4:10, "grid"])
confint(est1, gridIndex=4:10)

# Report the 99% uniform confidence band
# Fix the seed for simulating critical values
set.seed(42); confint(est1, level=0.99, CIuniform=TRUE)
set.seed(42); confint(est1, alpha=0.01, CIuniform=TRUE)

</code></pre>

<hr>
<h2 id='Ggenerate'>Internal function.</h2><span id='topic+Ggenerate'></span>

<h3>Description</h3>

<p>Generate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ggenerate(p, low = -1, up = 1, kernel = "triangular")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ggenerate_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="Ggenerate_+3A_low">low</code>, <code id="Ggenerate_+3A_up">up</code></td>
<td>
<p>Scalar, between -1 and 1, the region of integration.</p>
</td></tr>
<tr><td><code id="Ggenerate_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (p+1)-by-(p+1) matrix.
</p>

<hr>
<h2 id='lpbwdensity'>Data-driven Bandwidth Selection for Local Polynomial Density Estimators</h2><span id='topic+lpbwdensity'></span>

<h3>Description</h3>

<p><code><a href="#topic+lpbwdensity">lpbwdensity</a></code> implements the bandwidth selection methods for local
polynomial based density (and derivatives) estimation proposed and studied
in Cattaneo, Jansson and Ma (2020, 2023).
See Cattaneo, Jansson and Ma (2022) for more implementation details and illustrations.
</p>
<p>Companion command: <code><a href="#topic+lpdensity">lpdensity</a></code> for estimation and robust bias-corrected inference.
</p>
<p>Related <code>Stata</code> and <code>R</code> packages useful for nonparametric estimation and inference are
available at <a href="https://nppackages.github.io/">https://nppackages.github.io/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpbwdensity(
  data,
  grid = NULL,
  p = NULL,
  v = NULL,
  kernel = c("triangular", "uniform", "epanechnikov"),
  bwselect = c("mse-dpi", "imse-dpi", "mse-rot", "imse-rot"),
  massPoints = TRUE,
  stdVar = TRUE,
  regularize = TRUE,
  nLocalMin = NULL,
  nUniqueMin = NULL,
  Cweights = NULL,
  Pweights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpbwdensity_+3A_data">data</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the raw data.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_grid">grid</code></td>
<td>
<p>Numeric, specifies the grid of evaluation points. When set to default, grid points
will be chosen as 0.05-0.95 percentiles of the data, with a step size of 0.05.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial used to construct point
estimates. (Default is <code>2</code>.)</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_v">v</code></td>
<td>
<p>Nonnegative integer, specifies the derivative of the distribution function to be estimated. <code>0</code> for
the distribution function, <code>1</code> (default) for the density funtion, etc.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_kernel">kernel</code></td>
<td>
<p>String, specifies the kernel function, should be one of <code>"triangular"</code>, <code>"uniform"</code> or
<code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_bwselect">bwselect</code></td>
<td>
<p>String, specifies the method for data-driven bandwidth selection. This option will be
ignored if <code>bw</code> is provided. Can be (1) <code>"mse-dpi"</code> (default, mean squared error-optimal
bandwidth selected for each grid point); or (2) <code>"imse-dpi"</code> (integrated MSE-optimal bandwidth,
common for all grid points); (3) <code>"mse-rot"</code> (rule-of-thumb bandwidth with Gaussian
reference model); and (4) <code>"imse-rot"</code> (integrated rule-of-thumb bandwidth with Gaussian
reference model).</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_masspoints">massPoints</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether point estimates and standard errors
should be adjusted if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_stdvar">stdVar</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether the data should be standardized for
bandwidth selection.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_regularize">regularize</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether the bandwidth should be
regularized. When set to <code>TRUE</code>, the bandwidth is chosen such that the local region includes
at least <code>nLocalMin</code> observations and at least <code>nUniqueMin</code> unique observations.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, specifies the minimum number of observations in each local neighborhood. This option
will be ignored if <code>regularize=FALSE</code>. Default is <code>20+p+1</code>.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, specifies the minimum number of unique observations in each local neighborhood. This option
will be ignored if <code>regularize=FALSE</code>. Default is <code>20+p+1</code>.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector, specifies the weights used
for counterfactual distribution construction. Should have the same length as the data.
This option will be ignored if <code>bwselect</code> is <code>"mse-rot"</code> or <code>"imse-rot"</code>.</p>
</td></tr>
<tr><td><code id="lpbwdensity_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector, specifies the weights used
in sampling. Should have the same length as the data.
This option will be ignored if <code>bwselect</code> is <code>"mse-rot"</code> or <code>"imse-rot"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>BW</code></td>
<td>
<p>A matrix containing (1) <code>grid</code> (grid point), (2) <code>bw</code> (bandwidth),
(3) <code>nh</code> (number of observations in each local neighborhood), and
(4) <code>nhu</code> (number of unique observations in each local neighborhood).</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing options passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>References</h3>

<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2020.
Simple Local Polynomial Density Estimators.
<em>Journal of the American Statistical Association</em>, 115(531): 1449-1455.
<a href="https://doi.org/10.1080/01621459.2019.1635480">doi:10.1080/01621459.2019.1635480</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2022.
lpdensity: Local Polynomial Density Estimation and Inference.
<em>Journal of Statistical Software</em>, 101(2): 1â€“25.
<a href="https://doi.org/10.18637/jss.v101.i02">doi:10.18637/jss.v101.i02</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2023.
Local Regression Distribution Estimators.
<em>Journal of Econometrics</em>, 240(2): 105074.
<a href="https://doi.org/10.1016/j.jeconom.2021.01.006">doi:10.1016/j.jeconom.2021.01.006</a>
</p>


<h3>See Also</h3>

<p>Supported methods: <code><a href="#topic+coef.lpbwdensity">coef.lpbwdensity</a></code>, <code><a href="#topic+print.lpbwdensity">print.lpbwdensity</a></code>, <code><a href="#topic+summary.lpbwdensity">summary.lpbwdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Construct bandwidth
bw1 &lt;- lpbwdensity(X)
summary(bw1)

# Display bandwidths for a subset of grid points
summary(bw1, grid=bw1$BW[4:10, "grid"])
summary(bw1, gridIndex=4:10)

</code></pre>

<hr>
<h2 id='lpdensity'>Local Polynomial Density Estimation and Inference</h2><span id='topic+lpdensity'></span>

<h3>Description</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> implements the local polynomial regression based density (and derivatives)
estimator proposed in Cattaneo, Jansson and Ma (2020).  Robust bias-corrected inference methods,
both pointwise (confidence intervals) and uniform (confidence bands), are also implemented
following the results in Cattaneo, Jansson and Ma (2020, 2023).
See Cattaneo, Jansson and Ma (2022) for more implementation details and illustrations.
</p>
<p>Companion command: <code><a href="#topic+lpbwdensity">lpbwdensity</a></code> for bandwidth selection.
</p>
<p>Related <code>Stata</code> and <code>R</code> packages useful for nonparametric estimation and inference are
available at <a href="https://nppackages.github.io/">https://nppackages.github.io/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpdensity(
  data,
  grid = NULL,
  bw = NULL,
  p = NULL,
  q = NULL,
  v = NULL,
  kernel = c("triangular", "uniform", "epanechnikov"),
  scale = NULL,
  massPoints = TRUE,
  bwselect = c("mse-dpi", "imse-dpi", "mse-rot", "imse-rot"),
  stdVar = TRUE,
  regularize = TRUE,
  nLocalMin = NULL,
  nUniqueMin = NULL,
  Cweights = NULL,
  Pweights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpdensity_+3A_data">data</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the raw data.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_grid">grid</code></td>
<td>
<p>Numeric, specifies the grid of evaluation points. When set to default, grid points
will be chosen as 0.05-0.95 percentiles of the data, with a step size of 0.05.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_bw">bw</code></td>
<td>
<p>Numeric, specifies the bandwidth
used for estimation. Can be (1) a positive scalar (common
bandwidth for all grid points); or (2) a positive numeric vector specifying bandwidths for
each grid point (should be the same length as <code>grid</code>).</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial used to construct point
estimates. (Default is <code>2</code>.)</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_q">q</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial used to construct
confidence intervals/bands (a.k.a. the bias correction order). Default is <code>p+1</code>. When set to be
the same as <code>p</code>, no bias correction will be performed. Otherwise it should be
strictly larger than <code>p</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_v">v</code></td>
<td>
<p>Nonnegative integer, specifies the derivative of the distribution function to be estimated. <code>0</code> for
the distribution function, <code>1</code> (default) for the density funtion, etc.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_kernel">kernel</code></td>
<td>
<p>String, specifies the kernel function, should be one of <code>"triangular"</code>, <code>"uniform"</code>, and
<code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_scale">scale</code></td>
<td>
<p>Numeric, specifies how
estimates are scaled. For example, setting this parameter to 0.5 will scale down both the
point estimates and standard errors by half. Default is <code>1</code>. This parameter is useful if only
part of the sample is employed for estimation, and should not be confused with <code>Cweights</code>
or <code>Pweights</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_masspoints">massPoints</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether point estimates and standard errors
should be adjusted if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_bwselect">bwselect</code></td>
<td>
<p>String, specifies the method for data-driven bandwidth selection. This option will be
ignored if <code>bw</code> is provided. Options are (1) <code>"mse-dpi"</code> (default, mean squared error-optimal
bandwidth selected for each grid point); (2) <code>"imse-dpi"</code> (integrated MSE-optimal bandwidth,
common for all grid points); (3) <code>"mse-rot"</code> (rule-of-thumb bandwidth with Gaussian
reference model); and (4) <code>"imse-rot"</code> (integrated rule-of-thumb bandwidth with Gaussian
reference model).</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_stdvar">stdVar</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether the data should be standardized for
bandwidth selection.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_regularize">regularize</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, specifies whether the bandwidth should be
regularized. When set to <code>TRUE</code>, the bandwidth is chosen such that the local region includes
at least <code>nLocalMin</code> observations and at least <code>nUniqueMin</code> unique observations.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_nlocalmin">nLocalMin</code></td>
<td>
<p>Nonnegative integer, specifies the minimum number of observations in each local neighborhood. This option
will be ignored if <code>regularize=FALSE</code>. Default is <code>20+p+1</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_nuniquemin">nUniqueMin</code></td>
<td>
<p>Nonnegative integer, specifies the minimum number of unique observations in each local neighborhood. This option
will be ignored if <code>regularize=FALSE</code>. Default is <code>20+p+1</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric, specifies the weights used
for counterfactual distribution construction. Should have the same length as the data.</p>
</td></tr>
<tr><td><code id="lpdensity_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric, specifies the weights used
in sampling. Should have the same length as the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bias correction is only used for the construction of confidence intervals/bands, but not for point
estimation. The point estimates, denoted by <code>f_p</code>, are constructed using local polynomial estimates
of order <code>p</code>, while the centering of the confidence intervals/bands, denoted by <code>f_q</code>, are constructed
using local polynomial estimates of order <code>q</code>. The confidence intervals/bands take the form:
<code>[f_q - cv * SE(f_q) , f_q + cv * SE(f_q)]</code>, where <code>cv</code> denotes the appropriate critical value and <code>SE(f_q)</code>
denotes an standard error estimate for the centering of the confidence interval/band. As a result,
the confidence intervals/bands may not be centered at the point estimates because they have been bias-corrected.
Setting <code>q</code> and <code>p</code> to be equal results on centered at the point estimate confidence intervals/bands,
but requires undersmoothing for valid inference (i.e., (I)MSE-optimal bandwdith for the density point estimator
cannot be used). Hence the bandwidth would need to be specified manually when <code>q=p</code>, and the
point estimates will not be (I)MSE optimal. See Cattaneo, Jansson and Ma (2020, 2023) for details, and also
Calonico, Cattaneo, and Farrell (2018, 2022) for robust bias correction methods.
</p>
<p>Sometimes the density point estimates may lie outside of the confidence intervals/bands, which can happen
if the underlying distribution exhibits high curvature at some evaluation point(s). One possible solution
in this case is to increase the polynomial order <code>p</code> or to employ a smaller bandwidth.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>A matrix containing (1) <code>grid</code> (grid points), (2) <code>bw</code> (bandwidths),
(3) <code>nh</code> (number of observations in each local neighborhood),
(4) <code>nhu</code> (number of unique observations in each local neighborhood),
(5) <code>f_p</code> (point estimates with p-th order local polynomial),
(6) <code>f_q</code> (point estimates with q-th order local polynomial, only if option <code>q</code> is nonzero),
(7) <code>se_p</code> (standard error corresponding to <code>f_p</code>), and (8) <code>se_q</code> (standard error
corresponding to <code>f_q</code>).</p>
</td></tr>
<tr><td><code>CovMat_p</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>f_p</code>.</p>
</td></tr>
<tr><td><code>CovMat_q</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>f_q</code>.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing options passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>References</h3>

<p>Calonico, S., M. D. Cattaneo, and M. H. Farrell. 2018. On the Effect of Bias Estimation on Coverage Accuracy in Nonparametric Inference. <em>Journal of the American Statistical Association</em>, 113(522): 767-779. <a href="https://doi.org/10.1080/01621459.2017.1285776">doi:10.1080/01621459.2017.1285776</a>
</p>
<p>Calonico, S., M. D. Cattaneo, and M. H. Farrell. 2022. Coverage Error Optimal Confidence Intervals for Local Polynomial Regression. <em>Bernoulli</em>, 28(4): 2998-3022. <a href="https://doi.org/10.3150/21-BEJ1445">doi:10.3150/21-BEJ1445</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2020. Simple Local Polynomial Density Estimators. <em>Journal of the American Statistical Association</em>, 115(531): 1449-1455. <a href="https://doi.org/10.1080/01621459.2019.1635480">doi:10.1080/01621459.2019.1635480</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2022. lpdensity: Local Polynomial Density Estimation and Inference. <em>Journal of Statistical Software</em>, 101(2): 1â€“25. <a href="https://doi.org/10.18637/jss.v101.i02">doi:10.18637/jss.v101.i02</a>
</p>
<p>Cattaneo, M. D., M. Jansson, and X. Ma. 2023. Local Regression Distribution Estimators. <em>Journal of Econometrics</em>, 240(2): 105074. <a href="https://doi.org/10.1016/j.jeconom.2021.01.006">doi:10.1016/j.jeconom.2021.01.006</a>
</p>


<h3>See Also</h3>

<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>, <code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>, <code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report results
est1 &lt;- lpdensity(data = X, bwselect = "imse-dpi")
summary(est1)

# Report results for a subset of grid points
summary(est1, grid=est1$Estimate[4:10, "grid"])
summary(est1, gridIndex=4:10)

# Report the 99% uniform confidence band
set.seed(42) # fix the seed for simulating critical values
summary(est1, alpha=0.01, CIuniform=TRUE)

# Plot the estimates and confidence intervals
plot(est1, legendTitle="My Plot", legendGroups=c("X"))

# Plot the estimates and the 99% uniform confidence band
set.seed(42) # fix the seed for simulating critical values
plot(est1, alpha=0.01, CIuniform=TRUE, legendTitle="My Plot", legendGroups=c("X"))

# Adding a histogram to the background
plot(est1, legendTitle="My Plot", legendGroups=c("X"),
  hist=TRUE, histData=X, histBreaks=seq(-1.5, 1.5, 0.25))

</code></pre>

<hr>
<h2 id='lpdensity_fn'>Supporting Function for <code><a href="#topic+lpdensity">lpdensity</a></code></h2><span id='topic+lpdensity_fn'></span>

<h3>Description</h3>

<p><code>lpdensity_fn</code> implements the local polynomial density estimator. This
function is for internal use, and there is no error handling or robustness check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpdensity_fn(
  data,
  grid,
  bw,
  p,
  q,
  v,
  kernel,
  Cweights,
  Pweights,
  massPoints,
  showSE = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpdensity_fn_+3A_data">data</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the raw data.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_grid">grid</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the grid on which
density is estimated.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_bw">bw</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the bandwidth
used for estimation. Should be strictly positive, and have the same length as
<code>grid</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_p">p</code></td>
<td>
<p>Integer, nonnegative, the order of the local-polynomial used to construct point
estimates.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_q">q</code></td>
<td>
<p>Integer, nonnegative, the order of the local-polynomial used to construct
confidence interval (a.k.a. the bias correction order).</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_v">v</code></td>
<td>
<p>Integer, nonnegative, the derivative of distribution function to be estimated. <code>0</code> for
the distribution function, <code>1</code> (default) for the density funtion, etc.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel function, should be one of <code>"triangular"</code>,
<code>"uniform"</code> or <code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_cweights">Cweights</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the weights used
for counterfactual distribution construction. Should have the same length as sample size.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_pweights">Pweights</code></td>
<td>
<p>Numeric vector or one dimensional matrix/data frame, the weights used
in sampling. Should have the same length as sample size, and nonnegative.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_masspoints">massPoints</code></td>
<td>
<p>Boolean, whether whether point estimates and standard errors
should be corrected if there are mass points in the data.</p>
</td></tr>
<tr><td><code id="lpdensity_fn_+3A_showse">showSE</code></td>
<td>
<p><code>TRUE</code> (default) or <code>FALSE</code>, whether standard errors should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recommend: use <code><a href="#topic+lpdensity">lpdensity</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>grid</code></td>
<td>
<p>grid points.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>bandwidth for each grid point.</p>
</td></tr>
<tr><td><code>nh</code></td>
<td>
<p>Effective sample size for each grid point.</p>
</td></tr>
<tr><td><code>f_p</code></td>
<td>
<p>Density estimates on the grid with local polynomial of order <code>p</code>,
with the same length as <code>grid</code>.</p>
</td></tr>
<tr><td><code>f_q</code></td>
<td>
<p>Density estimates on the grid with local polynomial of order <code>q</code>,
with the same length as <code>grid</code>. This is reported only if <code>q</code> is greater than
0.</p>
</td></tr>
<tr><td><code>se_p</code></td>
<td>
<p>Standard errors corresponding to <code>hat_p</code>.</p>
</td></tr>
<tr><td><code>se_q</code></td>
<td>
<p>Standard errors corresponding to <code>hat_q</code>. This is reported only
if <code>q</code> is greater than 0.</p>
</td></tr>
</table>

<hr>
<h2 id='lpdensity.plot'>Plot Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+lpdensity.plot'></span>

<h3>Description</h3>

<p>This has been replaced by <code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpdensity.plot(
  ...,
  alpha = NULL,
  type = NULL,
  lty = NULL,
  lwd = NULL,
  lcol = NULL,
  pty = NULL,
  pwd = NULL,
  pcol = NULL,
  grid = NULL,
  CItype = NULL,
  CIuniform = FALSE,
  CIsimul = 2000,
  CIshade = NULL,
  CIcol = NULL,
  hist = FALSE,
  histData = NULL,
  histBreaks = NULL,
  histFillCol = 3,
  histFillShade = 0.2,
  histLineCol = "white",
  title = NULL,
  xlabel = NULL,
  ylabel = NULL,
  legendTitle = NULL,
  legendGroups = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpdensity.plot_+3A_...">...</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained from calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar between 0 and 1, specifies the significance level for plotting
confidence intervals/bands. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_type">type</code></td>
<td>
<p>String, one of <code>"line"</code> (default), <code>"points"</code> and <code>"both"</code>, specifies how
the point estimates are plotted. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_lty">lty</code></td>
<td>
<p>Line type for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for solid line, <code>2</code> for dashed line, <code>3</code> for dotted line.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_lwd">lwd</code></td>
<td>
<p>Line width for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. Should be strictly positive. For other options, see the instructions for
<code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If more than one is provided, they will be applied
to each data series accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_lcol">lcol</code></td>
<td>
<p>Line color for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code> for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_pty">pty</code></td>
<td>
<p>Scatter plot type for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. For options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_pwd">pwd</code></td>
<td>
<p>Scatter plot size for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. Should be strictly positive. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_pcol">pcol</code></td>
<td>
<p>Scatter plot color for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, specifies a subset of grid points
to plot point estimates. This option is effective only if <code>type</code> is <code>"points"</code> or
<code>"both"</code>; or if <code>CItype</code> is <code>"ebar"</code> or
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_citype">CItype</code></td>
<td>
<p>String, one of <code>"region"</code> (shaded region, default), <code>"line"</code> (dashed lines),
<code>"ebar"</code> (error bars), <code>"all"</code> (all of the previous) or <code>"none"</code> (no confidence region),
how the confidence region should be plotted. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_ciuniform">CIuniform</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), plotting either pointwise confidence intervals (<code>FALSE</code>) or
uniform confidence bands (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_cisimul">CIsimul</code></td>
<td>
<p>Positive integer, specifies the number of simulations used to construct critical values (default is <code>2000</code>). This
option is ignored if <code>CIuniform=FALSE</code>.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_cishade">CIshade</code></td>
<td>
<p>Numeric, specifies the opaqueness of the confidence region, should be between 0 (transparent) and
1. Default is 0.2. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_cicol">CIcol</code></td>
<td>
<p>Color of the confidence region. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_hist">hist</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), specifies whether a histogram should be added to the background.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_histdata">histData</code></td>
<td>
<p>Numeric vector, specifies the data used to construct the histogram plot.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_histbreaks">histBreaks</code></td>
<td>
<p>Numeric vector, specifies the breakpoints between histogram cells.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_histfillcol">histFillCol</code></td>
<td>
<p>Color of the histogram cells.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_histfillshade">histFillShade</code></td>
<td>
<p>Opaqueness of the histogram cells, should be between 0 (transparent) and
1. Default is 0.2.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_histlinecol">histLineCol</code></td>
<td>
<p>Color of the histogram lines.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_title">title</code>, <code id="lpdensity.plot_+3A_xlabel">xlabel</code>, <code id="lpdensity.plot_+3A_ylabel">ylabel</code></td>
<td>
<p>Strings, specifies the title of the plot and labels for the x- and y-axis.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_legendtitle">legendTitle</code></td>
<td>
<p>String, specifies the legend title.</p>
</td></tr>
<tr><td><code id="lpdensity.plot_+3A_legendgroups">legendGroups</code></td>
<td>
<p>String vector, specifies the group names used in legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stadnard <code>ggplot</code> object is returned, hence can be used for further customization.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>

<hr>
<h2 id='lpdensityUnique'>Internal function.</h2><span id='topic+lpdensityUnique'></span>

<h3>Description</h3>

<p>Find unique elements and their frequencies in a numeric vector. This function
has a similar performance as the built-in R function <code>unique</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpdensityUnique(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lpdensityUnique_+3A_x">x</code></td>
<td>
<p>Numeric vector, already sorted in ascending order.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>unique</code></td>
<td>
<p>A vector containing unique elements in <code>x</code>.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>The frequency of each element in <code>x</code>.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>The last occurrence of each element in <code>x</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='normal_dgps'>Internal function.</h2><span id='topic+normal_dgps'></span>

<h3>Description</h3>

<p>Calculates density and higher order derivatives for Gaussian models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_dgps(x, v, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal_dgps_+3A_x">x</code></td>
<td>
<p>Scalar, point of evaluation.</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_v">v</code></td>
<td>
<p>Nonnegative integer, the derivative order (0 indicates cdf, 1 indicates pdf, etc.).</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_mean">mean</code></td>
<td>
<p>Scalar, the mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_sd">sd</code></td>
<td>
<p>Strictly positive scalar, the standard deviation of the normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar corresponding to the value of the normal density function or derivatives thereof.
</p>

<hr>
<h2 id='plot.lpdensity'>Plot Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+plot.lpdensity'></span>

<h3>Description</h3>

<p>The plot method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
plot(
  ...,
  alpha = NULL,
  type = NULL,
  lty = NULL,
  lwd = NULL,
  lcol = NULL,
  pty = NULL,
  pwd = NULL,
  pcol = NULL,
  grid = NULL,
  CItype = NULL,
  CIuniform = FALSE,
  CIsimul = 2000,
  CIshade = NULL,
  CIcol = NULL,
  hist = FALSE,
  histData = NULL,
  histBreaks = NULL,
  histFillCol = 3,
  histFillShade = 0.2,
  histLineCol = "white",
  title = NULL,
  xlabel = NULL,
  ylabel = NULL,
  legendTitle = NULL,
  legendGroups = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpdensity_+3A_...">...</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained from calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar between 0 and 1, specifies the significance level for plotting
confidence intervals/bands. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_type">type</code></td>
<td>
<p>String, one of <code>"line"</code> (default), <code>"points"</code> and <code>"both"</code>, specifies how
the point estimates are plotted. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_lty">lty</code></td>
<td>
<p>Line type for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for solid line, <code>2</code> for dashed line, <code>3</code> for dotted line.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_lwd">lwd</code></td>
<td>
<p>Line width for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. Should be strictly positive. For other options, see the instructions for
<code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If more than one is provided, they will be applied
to each data series accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_lcol">lcol</code></td>
<td>
<p>Line color for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code> for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_pty">pty</code></td>
<td>
<p>Scatter plot type for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. For options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_pwd">pwd</code></td>
<td>
<p>Scatter plot size for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. Should be strictly positive. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_pcol">pcol</code></td>
<td>
<p>Scatter plot color for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_grid">grid</code></td>
<td>
<p>Numeric vector, specifies a subset of grid points
to plot point estimates. This option is effective only if <code>type</code> is <code>"points"</code> or
<code>"both"</code>; or if <code>CItype</code> is <code>"ebar"</code> or
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_citype">CItype</code></td>
<td>
<p>String, one of <code>"region"</code> (shaded region, default), <code>"line"</code> (dashed lines),
<code>"ebar"</code> (error bars), <code>"all"</code> (all of the previous) or <code>"none"</code> (no confidence region),
how the confidence region should be plotted. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_ciuniform">CIuniform</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), plotting either pointwise confidence intervals (<code>FALSE</code>) or
uniform confidence bands (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_cisimul">CIsimul</code></td>
<td>
<p>Positive integer, specifies the number of simulations used to construct critical values (default is <code>2000</code>). This
option is ignored if <code>CIuniform=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_cishade">CIshade</code></td>
<td>
<p>Numeric, specifies the opaqueness of the confidence region, should be between 0 (transparent) and
1. Default is 0.2. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_cicol">CIcol</code></td>
<td>
<p>Color of the confidence region. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code>ggplot2</code> or <code><a href="graphics.html#topic+par">par</a></code>. If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_hist">hist</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), specifies whether a histogram should be added to the background.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_histdata">histData</code></td>
<td>
<p>Numeric vector, specifies the data used to construct the histogram plot.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_histbreaks">histBreaks</code></td>
<td>
<p>Numeric vector, specifies the breakpoints between histogram cells.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_histfillcol">histFillCol</code></td>
<td>
<p>Color of the histogram cells.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_histfillshade">histFillShade</code></td>
<td>
<p>Opaqueness of the histogram cells, should be between 0 (transparent) and
1. Default is 0.2.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_histlinecol">histLineCol</code></td>
<td>
<p>Color of the histogram lines.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_title">title</code>, <code id="plot.lpdensity_+3A_xlabel">xlabel</code>, <code id="plot.lpdensity_+3A_ylabel">ylabel</code></td>
<td>
<p>Strings, specifies the title of the plot and labels for the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_legendtitle">legendTitle</code></td>
<td>
<p>String, specifies the legend title.</p>
</td></tr>
<tr><td><code id="plot.lpdensity_+3A_legendgroups">legendGroups</code></td>
<td>
<p>String vector, specifies the group names used in legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stadnard <code>ggplot</code> object is returned, hence can be used for further customization.
</p>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Generate a density discontinuity at 0
X &lt;- X - 0.5; X[X&gt;0] &lt;- X[X&gt;0] * 2

# Density estimation, left of 0 (scaled by the relative sample size)
est1 &lt;- lpdensity(data = X[X&lt;=0], grid = seq(-2.5, 0, 0.05), bwselect = "imse-dpi",
  scale = sum(X&lt;=0)/length(X))
# Density estimation, right of 0 (scaled by the relative sample size)
est2 &lt;- lpdensity(data = X[X&gt;0],  grid = seq(0, 2, 0.05), bwselect = "imse-dpi",
  scale = sum(X&gt;0)/length(X))

# Plot
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"))

# Plot uniform confidence bands
set.seed(42) # fix the seed for simulating critical values
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"), CIuniform=TRUE)

# Adding a histogram to the background
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"),
  hist=TRUE, histBreaks=seq(-2.4, 2, 0.2), histData=X)

# Plot point estimates for a subset of evaluation points
plot(est1, est2, legendTitle="My Plot", legendGroups=c("Left", "Right"),
  type="both", CItype="all", grid=seq(-2, 2, 0.5))
</code></pre>

<hr>
<h2 id='print.lpbwdensity'>Print Method for Local Polynomial Density Bandwidth Selection</h2><span id='topic+print.lpbwdensity'></span>

<h3>Description</h3>

<p>The print method for local polynomial density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwdensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lpbwdensity_+3A_x">x</code></td>
<td>
<p>Class &quot;lpbwdensity&quot; object, obtained by calling <code><a href="#topic+lpbwdensity">lpbwdensity</a></code>.</p>
</td></tr>
<tr><td><code id="print.lpbwdensity_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwdensity">lpbwdensity</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwdensity">coef.lpbwdensity</a></code>, <code><a href="#topic+print.lpbwdensity">print.lpbwdensity</a></code>, <code><a href="#topic+summary.lpbwdensity">summary.lpbwdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Construct bandwidth
print(lpbwdensity(X))

</code></pre>

<hr>
<h2 id='print.lpdensity'>Print Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+print.lpdensity'></span>

<h3>Description</h3>

<p>The print method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lpdensity_+3A_x">x</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained from calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="print.lpdensity_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report results
print(lpdensity(data = X, bwselect = "imse-dpi"))

</code></pre>

<hr>
<h2 id='Sgenerate'>Internal function.</h2><span id='topic+Sgenerate'></span>

<h3>Description</h3>

<p>Generate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sgenerate(p, low = -1, up = 1, kernel = "triangular")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sgenerate_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="Sgenerate_+3A_low">low</code>, <code id="Sgenerate_+3A_up">up</code></td>
<td>
<p>Scalar, between -1 and 1, the region of integration.</p>
</td></tr>
<tr><td><code id="Sgenerate_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (p+1)-by-(p+1) matrix.
</p>

<hr>
<h2 id='summary.lpbwdensity'>Summary Method for Local Polynomial Density Bandwidth Selection</h2><span id='topic+summary.lpbwdensity'></span>

<h3>Description</h3>

<p>The summary method for local polynomial density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwdensity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpbwdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpbwdensity&quot; object, obtained by calling <code><a href="#topic+lpbwdensity">lpbwdensity</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lpbwdensity_+3A_...">...</code></td>
<td>
<p>Additional options, including (i) <code>grid</code> specifies a subset of grid points
to display the bandwidth; (ii) <code>gridIndex</code> specifies the indices of grid points
to display the bandwidth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwdensity">lpbwdensity</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwdensity">coef.lpbwdensity</a></code>, <code><a href="#topic+print.lpbwdensity">print.lpbwdensity</a></code>, <code><a href="#topic+summary.lpbwdensity">summary.lpbwdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Construct bandwidth
bw1 &lt;- lpbwdensity(X)
summary(bw1)

# Display bandwidths for a subset of grid points
summary(bw1, grid=bw1$BW[4:10, "grid"])
summary(bw1, gridIndex=4:10)

</code></pre>

<hr>
<h2 id='summary.lpdensity'>Summary Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+summary.lpdensity'></span>

<h3>Description</h3>

<p>The summary method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained from calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lpdensity_+3A_...">...</code></td>
<td>
<p>Additional options, including (i) <code>grid</code> specifies a subset of grid points
to display results; (ii) <code>gridIndex</code> specifies the indices of grid points
to display results; (iii) <code>alpha</code> specifies the significance level; (iv)
<code>CIuniform</code> specifies whether displaying pointwise confidence intervals (<code>FALSE</code>, default) or
the uniform confidence band (<code>TRUE</code>); (v) <code>CIsimul</code> specifies the number of simulations used
to construct critical values (default is <code>2000</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report results
est1 &lt;- lpdensity(data = X, bwselect = "imse-dpi")
summary(est1)

# Report results for a subset of grid points
summary(est1, grid=est1$Estimate[4:10, "grid"])
summary(est1, gridIndex=4:10)

# Report the 99% uniform confidence band
set.seed(42) # fix the seed for simulating critical values
summary(est1, alpha=0.01, CIuniform=TRUE)

</code></pre>

<hr>
<h2 id='Tgenerate'>Internal function.</h2><span id='topic+Tgenerate'></span>

<h3>Description</h3>

<p>Generate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tgenerate(p, low = -1, up = 1, kernel = "triangular")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tgenerate_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="Tgenerate_+3A_low">low</code>, <code id="Tgenerate_+3A_up">up</code></td>
<td>
<p>Scalar, between -1 and 1, the region of integration.</p>
</td></tr>
<tr><td><code id="Tgenerate_+3A_kernel">kernel</code></td>
<td>
<p>String, the kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (p+1)-by-(p+1) matrix.
</p>

<hr>
<h2 id='vcov.lpdensity'>Vcov Method for Local Polynomial Density Estimation and Inference</h2><span id='topic+vcov.lpdensity'></span>

<h3>Description</h3>

<p>The vcov method for local polynomial density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpdensity'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.lpdensity_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained by calling <code><a href="#topic+lpdensity">lpdensity</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.lpdensity_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>stdErr</code></td>
<td>
<p>A matrix containing grid points and standard errors using p- and q-th order local polynomials.</p>
</td></tr>
<tr><td><code>CovMat_p</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>f_p</code>.</p>
</td></tr>
<tr><td><code>CovMat_q</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>f_q</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma (maintainer), University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdensity">lpdensity</a></code> for local polynomial density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpdensity">coef.lpdensity</a></code>, <code><a href="#topic+confint.lpdensity">confint.lpdensity</a></code>,
<code><a href="#topic+plot.lpdensity">plot.lpdensity</a></code>, <code><a href="#topic+print.lpdensity">print.lpdensity</a></code>, <code><a href="#topic+summary.lpdensity">summary.lpdensity</a></code>,
<code><a href="#topic+vcov.lpdensity">vcov.lpdensity</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42); X &lt;- rnorm(2000)

# Estimate density and report results
vcov(lpdensity(data = X, bwselect = "imse-dpi"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
