<!DOCTYPE html><html><head><title>Help for package beadplexr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {beadplexr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+3A+3D'><p>Walrus operator</p></a></li>
<li><a href='#approx_adjust'><p>Approximate bandwidth adjustment.</p></a></li>
<li><a href='#as_data_frame_analyte'><p>Cast list of analytes to <code>data.frame</code></p></a></li>
<li><a href='#assign_analyte_id'><p>Assign analyte ID</p></a></li>
<li><a href='#calc_analyte_mfi'><p>Calculate the analyte intensity</p></a></li>
<li><a href='#calc_centre'><p>Calculate population center</p></a></li>
<li><a href='#calc_dist_to_centre'><p>Calculate euclidean distance between two points.</p></a></li>
<li><a href='#calc_std_conc'><p>Calculate standard concentration</p></a></li>
<li><a href='#calculate_concentration'><p>Calculate concentration.</p></a></li>
<li><a href='#cluster_events'><p>Clustering with trimming</p></a></li>
<li><a href='#count_neighbours'><p>Count neighbours for each element in a binary matrix</p></a></li>
<li><a href='#density_cut'><p>Density cut.</p></a></li>
<li><a href='#despeckle'><p>Despeckle parameters</p></a></li>
<li><a href='#dist_chebyshev'><p>Chebyshev distance</p></a></li>
<li><a href='#do_find_turning_points'><p>Find turning points</p></a></li>
<li><a href='#facs_plot'><p>Plot FACS data.</p></a></li>
<li><a href='#fit_standard_curve'><p>Fit a standard curve</p></a></li>
<li><a href='#geometric_mean'><p>Calculate geometric mean</p></a></li>
<li><a href='#get_col_names_args'><p>Get column names from the method arguments</p></a></li>
<li><a href='#harmonic_mean'><p>Calculate harmonic mean</p></a></li>
<li><a href='#ident_bead_pop'><p>Identify bead populations</p></a></li>
<li><a href='#identify_analyte'><p>Identify analyte</p></a></li>
<li><a href='#identify_assay_analyte'><p>Identify multiplex assay analytes</p></a></li>
<li><a href='#load_panel'><p>Load panel information</p></a></li>
<li><a href='#lplex'><p>LEGENDplex example data</p></a></li>
<li><a href='#pad_matrix'><p>Pad a matrix</p></a></li>
<li><a href='#panel_name_file'><p>Get file name from panel name</p></a></li>
<li><a href='#plot_concentrations'><p>Plot concentrations</p></a></li>
<li><a href='#raise_deprecated'><p>Warn about deprecated parameters or functions</p></a></li>
<li><a href='#read_fcs'><p>Read a fcs file.</p></a></li>
<li><a href='#simplex'><p>Simulated beadplex data</p></a></li>
<li><a href='#trim_population'><p>Trim cluster.</p></a></li>
<li><a href='#turning_point'><p>Turning points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Multiplex Cytometric Bead Assays</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Reproducible and automated analysis of multiplex bead assays such
    as CBA (Morgan et al. 2004; &lt;<a href="https://doi.org/10.1016%2Fj.clim.2003.11.017">doi:10.1016/j.clim.2003.11.017</a>&gt;), LEGENDplex
    (Yu et al. 2015; &lt;<a href="https://doi.org/10.1084%2Fjem.20142318">doi:10.1084/jem.20142318</a>&gt;), and MACSPlex (Miltenyi
    Biotec 2014; Application note: Data acquisition and analysis without the
    MACSQuant analyzer;
    <a href="https://www.miltenyibiotec.com/upload/assets/IM0021608.PDF">https://www.miltenyibiotec.com/upload/assets/IM0021608.PDF</a>). The
    package provides functions for streamlined reading of fcs files, and
    identification of bead clusters and analyte expression. The package eases
    the calculation of standard curves and the subsequent calculation of the
    analyte concentration.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/ustervbo/beadplexr">https://gitlab.com/ustervbo/beadplexr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/ustervbo/beadplexr/-/issues">https://gitlab.com/ustervbo/beadplexr/-/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, gridExtra, hexbin, knitr, rmarkdown, stringr,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, dplyr, drc, fpc, ggplot2, mclust, purrr, tibble,
tidyr, yaml, rlang</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-16 10:43:28 UTC; ulrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrik Stervbo <a href="https://orcid.org/0000-0002-2831-8868"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrik Stervbo &lt;ulrik.stervbo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-16 11:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='+3A+3D'>Walrus operator</h2><span id='topic++3A+3D'></span>

<h3>Description</h3>

<p>See <code>rlang::<a href="rlang.html#topic+nse-force">:=</a></code> for details.
</p>

<hr>
<h2 id='approx_adjust'>Approximate bandwidth adjustment.</h2><span id='topic+approx_adjust'></span>

<h3>Description</h3>

<p>Approximates the adjust argument to <code>stats::density()</code> needed to find the required number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_adjust(.x, .k, .lower = 0.4, .upper = 2, .step = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_adjust_+3A_.x">.x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="approx_adjust_+3A_.k">.k</code></td>
<td>
<p>Numeric giving the number of expected clusters.</p>
</td></tr>
<tr><td><code id="approx_adjust_+3A_.lower">.lower</code>, <code id="approx_adjust_+3A_.upper">.upper</code></td>
<td>
<p>The interval for possible value of adjust.</p>
</td></tr>
<tr><td><code id="approx_adjust_+3A_.step">.step</code></td>
<td>
<p>A numeric giving the increment to adjust. Sometimes low values
are needed to find a proper adjust value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the first value of the <code><a href="stats.html#topic+density">stats::density()</a></code> <code>adjust</code>
argument which gives the <code>.k</code> number of clusters. It it quite crude in that
every value of adjust from <code>.lower</code> to <code>.upper</code> is tested until the desired
number of clusters is found. A cluster is defined by a peak, and should no
suitable <code>adjust</code> value be found, NA is returned.
</p>


<h3>Value</h3>

<p>A numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
.x &lt;- c(rnorm(100, 2, 1), rnorm(100, 9, 1))
approx_adjust(.x, 2)
</code></pre>

<hr>
<h2 id='as_data_frame_analyte'>Cast list of analytes to <code>data.frame</code></h2><span id='topic+as_data_frame_analyte'></span>

<h3>Description</h3>

<p>A well structured list, such at those loaded by <code><a href="#topic+load_panel">load_panel()</a></code>, is cast to a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_data_frame_analyte(
  .analytes,
  .id_bead = "Bead group",
  .id_analyte = "Analyte ID"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_data_frame_analyte_+3A_.analytes">.analytes</code></td>
<td>
<p>The named list to be cast. It usually is loaded using
<code><a href="#topic+load_panel">load_panel()</a></code>. See Details for expected structure.</p>
</td></tr>
<tr><td><code id="as_data_frame_analyte_+3A_.id_bead">.id_bead</code>, <code id="as_data_frame_analyte_+3A_.id_analyte">.id_analyte</code></td>
<td>
<p>The name of the column to hold the bead group and the analyte ID, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each analyte in the <code>list</code> passed to the function is expected to be a named
list with named elements <code>name</code> and <code>concentration</code>. The name of the <code>list</code>
with the analyte specific information is the analyte ID.
</p>
<p>Because of the particular setup of the LEGENDplex assay with two bead groups,
the analytes are expected to be wrapped in another <code>list</code>.
</p>


<h3>Value</h3>

<p>A <code>data-frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.analytes &lt;-  list(A = list(
                A1 = list(name = "name_a1", concentration = 500),
                A2 = list(name = "name_a2", concentration = 50000)))

as_data_frame_analyte(.analytes)
</code></pre>

<hr>
<h2 id='assign_analyte_id'>Assign analyte ID</h2><span id='topic+assign_analyte_id'></span>

<h3>Description</h3>

<p>Replace internal cluster IDs with informative analyte IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_analyte_id(
  df,
  .parameter,
  .analyte_id,
  .column_name,
  .cluster_column_name = paste0("cluster_", .column_name),
  .desc = FALSE,
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_analyte_id_+3A_df">df</code></td>
<td>
<p>The tidy data.frame, with indication of clusters</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.parameter">.parameter</code></td>
<td>
<p>The parameter to order the cluster centers by</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.analyte_id">.analyte_id</code></td>
<td>
<p>A character vector giving the name of the clusters.
The <strong>order</strong> is important and must match the expected order of clusters.</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column to hold the
analyte ID. If the column exists it will be silently dropped.</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.cluster_column_name">.cluster_column_name</code></td>
<td>
<p>A character giving the name of the column where
the clusters are identified. Will be dropped from the data.frame.</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.desc">.desc</code></td>
<td>
<p>A boolean giving whether the sort order is descending.</p>
</td></tr>
<tr><td><code id="assign_analyte_id_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>data.frame</em> with cluster names instead of cluster ids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beadplexr)
library(ggplot2)

data("lplex")

df &lt;- lplex[[1]] |&gt;
  bp_clara(.parameter = c("FSC-A", "SSC-A"), .column_name = "analyte", .k = 2)

df |&gt;
  beadplexr:::assign_analyte_id(.parameter = c("FSC-A", "SSC-A"),
                                   .analyte_id = c("A", "B"),
                                   .column_name = "pop name",
                                   .cluster_column_name = "analyte") |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = `pop name`) +
  geom_point()

df |&gt;
  beadplexr:::assign_analyte_id(.parameter = c("FSC-A", "SSC-A"),
                                   .analyte_id = c("A", "B"),
                                   .column_name = "pop name",
                                   .cluster_column_name = "analyte", .desc = TRUE) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = `pop name`) +
  geom_point()

## End(Not run)

</code></pre>

<hr>
<h2 id='calc_analyte_mfi'>Calculate the analyte intensity</h2><span id='topic+calc_analyte_mfi'></span>

<h3>Description</h3>

<p>The mean fluorescence intensity (MFI) of the analyte
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_analyte_mfi(
  df,
  .parameter,
  .column_name = "analyte",
  .mean_fun = c("geometric", "harmonic", "arithmetic"),
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_analyte_mfi_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="calc_analyte_mfi_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of column(s) where populations
are identified.</p>
</td></tr>
<tr><td><code id="calc_analyte_mfi_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column to store the
population information.</p>
</td></tr>
<tr><td><code id="calc_analyte_mfi_+3A_.mean_fun">.mean_fun</code></td>
<td>
<p>A character giving the mean function to use.</p>
</td></tr>
<tr><td><code id="calc_analyte_mfi_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summarized <code>data.frame</code>
</p>


<h3>Mean calculation</h3>

<p>The calculation of the harmonic mean is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 n\frac{1}{\sum_{i=1}^n \frac{1}{x_i}}
</code>
</p>

<p><code>NA</code>s are removed before calculation
</p>
<p>The geometric mean is given by:
</p>
<p style="text-align: center;"><code class="reqn">
  \left(\prod_{i=1}^n x_i \right)^\frac{1}{n}
</code>
</p>

<p>but implemented as:
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{1}{n}\exp{\sum_{i=1}^n\log(x_i)}
</code>
</p>

<p><code>NA</code>s are removed before calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)
library(dplyr)

data("lplex")

df &lt;- lplex[[1]] |&gt;
  filter(`FSC-A` &gt; 4e5L, `FSC-A` &lt; 6.3e5L) |&gt;
  identify_analyte(.parameter = "FL6-H",
                   .analyte_id = as.character(c(1:7)))

df |&gt;
  calc_analyte_mfi(.parameter = "FL2-H")

df |&gt;
  calc_analyte_mfi(.parameter = "FL2-H",
              .mean_fun = "harmonic")
</code></pre>

<hr>
<h2 id='calc_centre'>Calculate population center</h2><span id='topic+calc_centre'></span>

<h3>Description</h3>

<p>Calculate population center
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_centre(.x, .method = "density")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_centre_+3A_.x">.x</code></td>
<td>
<p>A numerical vector.</p>
</td></tr>
<tr><td><code id="calc_centre_+3A_.method">.method</code></td>
<td>
<p>A character giving the method to use. Currently only density is available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::calc_centre(.x = rnorm(100))

</code></pre>

<hr>
<h2 id='calc_dist_to_centre'>Calculate euclidean distance between two points.</h2><span id='topic+calc_dist_to_centre'></span>

<h3>Description</h3>

<p>Calculate euclidean distance between two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_dist_to_centre(.x, .c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_dist_to_centre_+3A_.x">.x</code></td>
<td>
<p>A numerical vector with coordinates to a point.</p>
</td></tr>
<tr><td><code id="calc_dist_to_centre_+3A_.c">.c</code></td>
<td>
<p>A numerical vector with the coordinates to the center.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector with the euclidean distance between the two points.
</p>


<h3>Note</h3>

<p>This function does mot make use of the base function dist, as that
dist-function is about twice as slow as the implementation here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::calc_dist_to_centre(.x = c(10, 15), .c = c(1, 2))

</code></pre>

<hr>
<h2 id='calc_std_conc'>Calculate standard concentration</h2><span id='topic+calc_std_conc'></span>

<h3>Description</h3>

<p>Given a start concentration and dilution factor, the concentration of the given standard samples is calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_std_conc(.standard_sample, .start_concentration, .dilution_factor = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_std_conc_+3A_.standard_sample">.standard_sample</code></td>
<td>
<p>a vector giving the standard samples. The sample with
the highest value is given the start concentration, and a
<code>.standard_sample</code> with the value of 0, is set to 0 if it exists. See
Details for details on how order is assessed.</p>
</td></tr>
<tr><td><code id="calc_std_conc_+3A_.start_concentration">.start_concentration</code></td>
<td>
<p>a numeric vector giving the initial standard
concentration. If longer than one the maximum value is taken as start
concentration.</p>
</td></tr>
<tr><td><code id="calc_std_conc_+3A_.dilution_factor">.dilution_factor</code></td>
<td>
<p>a numeric vector giving the dilution factor. If a
single element is passed, this is applied to all standard samples as a
dilution series. If more then one value is given, it must be of equal
length as the <code>.standard_sample</code>, and each element is taken as the dilution
factor to the previous element, using 1 for the first element. The order of
dilution factors must match that of the ordered <code>.standard_sample</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the manuals to the LEGENDplex system, standard are labeled 0 to 8, where 8
indicate the highest concentration and 0 the background (no analyte). The standard is diluted at 1:4 so that
</p>
<div class="sourceCode"><pre>[s7] = [start]
[s6] = [s7]/4
[s5] = [s6]/4
[s4] = [s5]/4
[s3] = [s4]/4
[s2] = [s3]/4
[s1] = [s2]/4
[s0] = 0
</pre></div>
<p>It might happen, that a dilution step is missing in which case the dilution
is corrected to accommodate the missing step. However, since it is inspired
guess work and out of the ordinary, a warning is thrown, see Examples.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Standard sample order</h3>

<p>If the vector is numeric, the values are ordered numerically from high to low.
</p>
<p>If the vector is not numeric, things become a little more difficult, because
sorting a vector like <code>c("a", "c", "0", "b")</code> by default results in <code>c("0", "a", "b", "c")</code>, which means that '0' is the highest value and will be
assigned the start concentration and the sample 'a' is then the first
dilution.
</p>
<p>To avoid this problem, the vector is split into two: one containing numerical
values and one containing alphabetical. Each vector is then sorted
appropriately and combined, see Examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
calc_std_conc(.standard_sample = c(7:0),
                                 .start_concentration = 5000)

suppressWarnings(
# Sample 5 is missing - raises a warning
calc_std_conc(.standard_sample = c(7, 6, 4, 3, 2, 1, 0),
                                 .start_concentration = 5000)
)

calc_std_conc(.standard_sample = rep(c(7:0), 2),
                                 .start_concentration = 5000)
calc_std_conc(.standard_sample = c(9:0),
                                .start_concentration = 5000)

calc_std_conc(.standard_sample = c(letters[1:7], 0),
                                 .start_concentration = 5000)
calc_std_conc(.standard_sample = c(letters[1:7], 0, 1),
                                 .start_concentration = 5000)

calc_std_conc(.standard_sample = c(7:1, 0),
                                 .start_concentration = 5000,
                                 .dilution_factor = c(1, 2, 2, 2, 4, 6, 6, 0))

# If 0 exists it is always set to 0
calc_std_conc(.standard_sample = c(7:1, 0),
                                 .start_concentration = 5000,
                                 .dilution_factor = c(1, 2, 2, 2, 4, 6, 6, 100000))
calc_std_conc(.standard_sample = c(8:1),
                                 .start_concentration = 5000,
                                 .dilution_factor = c(1, 2, 2, 2, 4, 6, 6, 100000))
</code></pre>

<hr>
<h2 id='calculate_concentration'>Calculate concentration.</h2><span id='topic+calculate_concentration'></span>

<h3>Description</h3>

<p>Calculate the concentration in a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_concentration(
  df,
  .model,
  .parameter = "FL2.H",
  .value = "Calc.conc",
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_concentration_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="calculate_concentration_+3A_.model">.model</code></td>
<td>
<p>An object of class <code>drc</code> with the fitted dose-response model.</p>
</td></tr>
<tr><td><code id="calculate_concentration_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of column(s) where populations
are identified.</p>
</td></tr>
<tr><td><code id="calculate_concentration_+3A_.value">.value</code></td>
<td>
<p>A character giving the name of the column to store the calculated concentration</p>
</td></tr>
<tr><td><code id="calculate_concentration_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>df</code> with the calculated concentration and error added in two columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beadplexr)
library(drc)
data(ryegrass)

ryegrass_m &lt;-
  fit_standard_curve(df = ryegrass,
                     .parameter = "rootl",
                     .concentration = "conc")

sample_data &lt;-
  calculate_concentration(df = ryegrass[sample(1:nrow(ryegrass), 5),],
                          .model = ryegrass_m,
                          .parameter = "rootl")
</code></pre>

<hr>
<h2 id='cluster_events'>Clustering with trimming</h2><span id='topic+cluster_events'></span><span id='topic+bp_kmeans'></span><span id='topic+bp_clara'></span><span id='topic+bp_dbscan'></span><span id='topic+bp_mclust'></span><span id='topic+bp_density_cut'></span>

<h3>Description</h3>

<p>Cluster identification with various algorithms and subsequent trimming of each cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bp_kmeans(df, .parameter, .column_name, .k, .trim = 0, .data = NULL, ...)

bp_clara(df, .parameter, .column_name, .k, .trim = 0, .data = NULL, ...)

bp_dbscan(
  df,
  .parameter,
  .column_name,
  .eps = 0.2,
  .MinPts = 50,
  .data = NULL,
  ...
)

bp_mclust(
  df,
  .parameter,
  .column_name,
  .k,
  .trim = 0,
  .sample_frac = 0.05,
  .max_subset = 500,
  .data = NULL,
  ...
)

bp_density_cut(df, .parameter, .column_name, .k, .trim = 0, .data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_events_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of column(s) where populations
are identified.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column to store the
population information.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.k">.k</code></td>
<td>
<p>Numeric giving the number of expected clusters, or a set of initial
cluster centers.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.trim">.trim</code></td>
<td>
<p>A numeric between 0 and 1, giving the fraction of points to
remove by marking them NA.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to appropriate methods, see below.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.eps">.eps</code></td>
<td>
<p>Reachability distance, see <code><a href="fpc.html#topic+dbscan">fpc::dbscan()</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.minpts">.MinPts</code></td>
<td>
<p>Reachability minimum no. of points, see <code><a href="fpc.html#topic+dbscan">fpc::dbscan()</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.sample_frac">.sample_frac</code></td>
<td>
<p>A numeric between 0 and 1 giving the fraction of points
to use in initialisation of <code>Mclust()</code>.</p>
</td></tr>
<tr><td><code id="cluster_events_+3A_.max_subset">.max_subset</code></td>
<td>
<p>A numeric giving the maximum of events to use in
initialisation of <code>Mclust()</code>, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data.frame in <code>df</code> with the cluster classification added in
the column given by <code>.column_name</code>.
</p>


<h3>Additional parameters</h3>

<p>Information on additional arguments passed, can be found here:
</p>

<dl>
<dt>clara</dt><dd><p><code><a href="cluster.html#topic+clara">cluster::clara()</a></code></p>
</dd>
<dt>kmeans</dt><dd><p><code><a href="stats.html#topic+kmeans">kmeans()</a></code></p>
</dd>
<dt>dbscan</dt><dd><p><code><a href="fpc.html#topic+dbscan">fpc::dbscan()</a></code></p>
</dd>
<dt>mclust</dt><dd><p><code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code></p>
</dd>
<dt>density_cut</dt><dd><p><code><a href="#topic+approx_adjust">approx_adjust()</a></code></p>
</dd>
</dl>



<h3>Default parameters to <code>clara()</code></h3>

<p><code><a href="cluster.html#topic+clara">cluster::clara()</a></code> is by default called with the following parameters:
</p>

<dl>
<dt>samples</dt><dd><p>100</p>
</dd>
<dt>pamLike</dt><dd><p>TRUE</p>
</dd>
</dl>



<h3>Parameters to dbscan</h3>

<p>It requires some trial and error to get the right parameters for the
density based clustering, but the parameters usually stay stable throughout an
entire experiment and over time (assuming that there is only little drift in
the flow cytometer). There is no guarantee that the correct number of clusters
are returned, and it might be better to use this on the forward - side
scatter discrimination.
</p>
<p>Scaling of the parameters seems to be appropriate in most cases for the
forward - side scatter discrimination and is automatically performed.
</p>


<h3>Parameters to mclust</h3>

<p>Mclust is is slow and memory hungry on large datasets. Using a subset of the
data to initialise the clustering greatly improves the speed. I have found
that a subset sample of 500 even works well and gives no markedly better
clustering than a subset of 5000 events, but initialisation with 500 makes
the clustering complete about 12 times faster than with 5000 events.
</p>


<h3>Parameters to density_cut</h3>

<p>This simple function works by smoothing a density function until the desired number
of clusters are found. The segregation of the clusters follows at the lowest
point between two clusters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim_population">trim_population()</a></code>, <code><a href="#topic+identify_analyte">identify_analyte()</a></code>.
</p>
<p>Mclust and dbscan seems to do an excellent job at separating on the forward
and side scatter parameters. Mclust and clara both perform well separating
beads in the APC channel, but clara is about 3 times faster than Mclust.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)
library(dplyr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  # Speed things up a bit by selecting one fourth of the events.
  # Probably not something you'd usually do
  dplyr::sample_frac(0.25) |&gt;
  bp_kmeans(.parameter = c("FSC-A", "SSC-A"),
            .column_name = "population", .trim = 0.1, .k = 2) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

library(beadplexr)
library(dplyr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  # Speed things up a bit by selecting one fourth of the events.
  # Probably not something you'd usually do
  dplyr::sample_frac(0.25) |&gt;
  bp_clara(.parameter = c("FSC-A", "SSC-A"),
           .column_name = "population", .trim = 0.1, .k = 2) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

lplex[[1]] |&gt;
  # Speed things up a bit by selecting one fourth of the events.
  # Probably not something you'd usually do
  dplyr::sample_frac(0.25) |&gt;
  bp_clara(.parameter = c("FSC-A", "SSC-A"),
           .column_name = "population", .trim = 0, .k = 2) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

## Not run: 
library(beadplexr)
library(dplyr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  # Speed things up a bit by selecting one fourth of the events.
  # Probably not something you'd usually do
  dplyr::sample_frac(0.25) |&gt;
  bp_dbscan(.parameter = c("FSC-A", "SSC-A"), .column_name = "population",
            eps = 0.2, MinPts = 50) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

pop1 &lt;- lplex[[1]] |&gt;
  # Speed things up a bit by selecting one fourth of the events.
  # Probably not something you'd usually do
  dplyr::sample_frac(0.25) |&gt;
  bp_dbscan(.parameter = c("FSC-A", "SSC-A"), .column_name = "population",
    eps = 0.2, MinPts = 50) |&gt;
  dplyr::filter(population == "1")

pop1 |&gt;
  bp_dbscan(.parameter = c("FL6-H", "FL2-H"), .column_name = "population",
    eps = 0.2, MinPts = 50) |&gt;
  pull(population) |&gt;
  unique()

pop1 |&gt;
  bp_dbscan(.parameter = c("FL6-H", "FL2-H"), .column_name = "population",
    eps = 0.2, MinPts = 50, scale = FALSE) |&gt;
  pull(population) |&gt;
  unique()

## End(Not run)
library(beadplexr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  bp_mclust(.parameter = c("FSC-A", "SSC-A"),
           .column_name = "population", .trim = 0, .k = 2) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()
library(beadplexr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  bp_density_cut(.parameter = c("FSC-A"),
           .column_name = "population", .trim = 0, .k = 2) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

</code></pre>

<hr>
<h2 id='count_neighbours'>Count neighbours for each element in a binary matrix</h2><span id='topic+count_neighbours'></span>

<h3>Description</h3>

<p>Count neighbours for each element in a binary matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_neighbours(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_neighbours_+3A_x">x</code></td>
<td>
<p>The matrix to count the neighbours in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> giving the number of elements with non-zero
values in neighbouring cells of the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(
c(1L, 1L, 0L,
  1L, 1L, 0L,
  0L, 1L, 1L),
nrow = 3,
ncol = 3,
byrow = TRUE
)
beadplexr:::count_neighbours(x)

x &lt;- matrix(
  c(TRUE, TRUE, FALSE,
    TRUE, TRUE, FALSE,
   FALSE, TRUE, TRUE),
  nrow = 3,
  ncol = 3,
 byrow = TRUE
)
beadplexr:::count_neighbours(x)

x &lt;- matrix(
  c(1, 1, 0, 0,
    1, 0, 0, 0,
    0, 1, 1 ,1,
    0, 1, 1, 1),
  nrow = 4,
  ncol = 4,
  byrow = TRUE
)
beadplexr:::count_neighbours(x)

## Not run: 
  x &lt;- matrix(
    c("1", "1", "0",
      "1", "1", "0",
      "0", "1", "1"),
    nrow = 3,
    ncol = 3,
    byrow = TRUE
  )
  #beadplexr:::count_neighbours(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='density_cut'>Density cut.</h2><span id='topic+density_cut'></span>

<h3>Description</h3>

<p>Cut data based on density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_cut(.x, .k, .lower = 0.1, .upper = 2, .step = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_cut_+3A_.x">.x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="density_cut_+3A_.k">.k</code></td>
<td>
<p>Numeric giving the number of expected clusters.</p>
</td></tr>
<tr><td><code id="density_cut_+3A_.lower">.lower</code>, <code id="density_cut_+3A_.upper">.upper</code></td>
<td>
<p>The interval for possible value of adjust.</p>
</td></tr>
<tr><td><code id="density_cut_+3A_.step">.step</code></td>
<td>
<p>A numeric giving the increment to adjust. Sometimes low values
are needed to find a proper adjust value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor, see <code><a href="base.html#topic+cut">base::cut()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
.x &lt;- c(rnorm(200, 0, 1), rnorm(200, 0.8, 1))
.k &lt;-  2
density_cut(.x, .k)

</code></pre>

<hr>
<h2 id='despeckle'>Despeckle parameters</h2><span id='topic+despeckle'></span>

<h3>Description</h3>

<p>Remove lonely, noisy data points in a 2D scatter matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despeckle(df, .parameters, .bins = 256L, .neighbours = 4L, .data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despeckle_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="despeckle_+3A_.parameters">.parameters</code></td>
<td>
<p>A character of the length of two giving the parameters to
despeckle.</p>
</td></tr>
<tr><td><code id="despeckle_+3A_.bins">.bins</code></td>
<td>
<p>A numeric giving the resolution of the raster matrix. Increasing
the resolution results in more isolated events.</p>
</td></tr>
<tr><td><code id="despeckle_+3A_.neighbours">.neighbours</code></td>
<td>
<p>A numeric giving the minimum number of neighbours. Points
with fewer neighbours are removed.</p>
</td></tr>
<tr><td><code id="despeckle_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="despeckle_+3A_...">...</code></td>
<td>
<p>Deprecated. It's use has no effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of the two parameters are binned into the given number of bins.
They are then cast into a 2D matrix, with the bins of the first of the
parameters ending up as rows, the bins of the second parameter as
columns, and combinations are marked by <code>1</code>.
</p>
<p>The rows of the <code>df</code> where lonely points are found in <code>.parameters</code> are removed.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with noisy points removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  ggplot() +
  aes(x = `FL6-H`, y = `FL2-H`) +
  geom_point()

lplex[[1]] |&gt;
  despeckle(.parameters = c("FL6-H", "FL2-H"), .neighbours = 8) |&gt;
  ggplot() +
  aes(x = `FL6-H`, y = `FL2-H`) +
  geom_point()

lplex[[1]] |&gt;
  despeckle(.parameters = c("FL6-H", "FL2-H"), .bin = 128) |&gt;
  ggplot() +
  aes(x = `FL6-H`, y = `FL2-H`) +
  geom_point()

</code></pre>

<hr>
<h2 id='dist_chebyshev'>Chebyshev distance</h2><span id='topic+dist_chebyshev'></span>

<h3>Description</h3>

<p>Chebyshev distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_chebyshev(x, diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_chebyshev_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="dist_chebyshev_+3A_diag">diag</code></td>
<td>
<p>logical value indicating whether the diagonal of the distance
matrix should be printed by <code>print.dist</code>.</p>
</td></tr>
<tr><td><code id="dist_chebyshev_+3A_upper">upper</code></td>
<td>
<p>logical value indicating whether the upper triangle of the
distance matrix should be printed by <code>print.dist</code> .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chebyshev distance returns an object of class &quot;<code>dist</code>&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(100), nrow = 5)
dist_chebyshev(x)

</code></pre>

<hr>
<h2 id='do_find_turning_points'>Find turning points</h2><span id='topic+do_find_turning_points'></span>

<h3>Description</h3>

<p>Find turning points (minima and maxima) in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_find_turning_points(.x, .return = c("value", "index"), .adjust = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_find_turning_points_+3A_.x">.x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="do_find_turning_points_+3A_.return">.return</code></td>
<td>
<p>A character giving the desired return type.</p>
</td></tr>
<tr><td><code id="do_find_turning_points_+3A_.adjust">.adjust</code></td>
<td>
<p>A numeric giving the adjustment to the <code>adjust</code> argument of <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="do_find_turning_points_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="stats.html#topic+density">stats::density()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the two elements <code>maxima</code> and <code>minima</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
.x &lt;- c(rnorm(100, 2, 1), rnorm(100, 9, 1))
tpi &lt;- do_find_turning_points(.x, .return = "index", .adjust = 1)

dx &lt;- density(.x, adjust = 1, n = length(.x))
plot(dx)
points(dx$x[tpi$maxima], dx$y[tpi$maxima], pch = 19, col = "red")
points(dx$x[tpi$minima], dx$y[tpi$minima], pch = 19, col = "blue")

do_find_turning_points(.x, .return = "value", .adjust = 1)
</code></pre>

<hr>
<h2 id='facs_plot'>Plot FACS data.</h2><span id='topic+facs_plot'></span><span id='topic+facs_scatter'></span><span id='topic+facs_density2d'></span><span id='topic+facs_density1d'></span><span id='topic+facs_hexbin'></span>

<h3>Description</h3>

<p>Wrappers around building a ggplot with <code>geom_point</code>,
<code>geom_density_2d</code>, and <code>geom_hex</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facs_plot(
  df,
  .x = "FSC-A",
  .y = "SSC-A",
  .type = c("scatter", "density1d", "density2d", "hexbin"),
  .data = NULL,
  ...
)

facs_scatter(
  df,
  .x = "FSC-A",
  .y = "SSC-A",
  .beads = NULL,
  .plot_distinct = TRUE,
  .data = NULL
)

facs_density2d(df, .x = "FSC-A", .y = "SSC-A", .beads = NULL, .data = NULL)

facs_density1d(df, .x = "FSC-A", .beads = NULL, .data = NULL)

facs_hexbin(df, .x = "FSC-A", .y = "SSC-A", .bins = 75, .data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facs_plot_+3A_df">df</code></td>
<td>
<p>The data to be plotted in a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.x">.x</code>, <code id="facs_plot_+3A_.y">.y</code></td>
<td>
<p>Character vector with the column name for the variable to plot
on the x or y-axis.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.type">.type</code></td>
<td>
<p>Character vector giving the type of plot being used. Options are
one of <code>"scatter", "density", "hexbin"</code>.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_...">...</code></td>
<td>
<p>Arguments passed to the individual functions.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.beads">.beads</code></td>
<td>
<p>Character vector to with the column name with identification of
beads. If used it will show up with the aesthetic 'color'. Defaults to not
being used.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.plot_distinct">.plot_distinct</code></td>
<td>
<p>Boolean to decide if only distinct events should be
plotted. If used, the number of data points might be greatly reduced which
could make for faster plotting. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="facs_plot_+3A_.bins">.bins</code></td>
<td>
<p>Numeric vector giving number of bins in both vertical and
horizontal directions. Set to 75 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plot functions are meant to provide a quick way of viewing the FACS
data. For more control, use <code>ggplot2</code> directly.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beadplexr)
data("lplex")

df &lt;-  lplex[[1]]
df$bead_group &lt;- ifelse(df$`FSC-A` &lt; 4e5L, "A", "B")

# Using facs_plot
facs_plot(df, .type = "scatter")
facs_plot(df, .type = "density1d")
facs_plot(df, .type = "density2d")
facs_plot(df, .type = "hexbin")

facs_plot(df, .type = "scatter", .beads = "bead_group")
facs_plot(df, .type = "density1d", .beads = "bead_group")
facs_plot(df, .type = "hexbin", .bins = 50)

facs_plot(df, .x = "FL2-H", .type = "scatter", .beads = "bead_group")

# Individual functions
facs_scatter(df)

facs_scatter(df, .beads = "bead_group", .plot_distinct = FALSE)
facs_scatter(df, .beads = "bead_group")

facs_scatter(df, .x = "FL2-H", .y = "FL6-H", .beads = "bead_group")

facs_density1d(df)
facs_density1d(df, .beads = "bead_group")

facs_density2d(df)
facs_density2d(df, .beads = "bead_group")

facs_hexbin(df)
facs_hexbin(df, .bins = 30)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_standard_curve'>Fit a standard curve</h2><span id='topic+fit_standard_curve'></span>

<h3>Description</h3>

<p>Fit a logistic function to the standard concentrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_standard_curve(
  df,
  .parameter = "FL2.H",
  .concentration = "Concentration",
  .fct = "LL.5",
  .data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_standard_curve_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="fit_standard_curve_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of column(s) where populations
are identified.</p>
</td></tr>
<tr><td><code id="fit_standard_curve_+3A_.concentration">.concentration</code></td>
<td>
<p>A character giving the name of the column with the
standard concentration.</p>
</td></tr>
<tr><td><code id="fit_standard_curve_+3A_.fct">.fct</code></td>
<td>
<p>A character giving the name of the logistic function to use in
the fit, see <code><a href="drc.html#topic+drm">drc::drm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_standard_curve_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="fit_standard_curve_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="drc.html#topic+drm">drc::drm()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>drc</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beadplexr)
library(drc)
data(ryegrass)

ryegrass_m &lt;-
  fit_standard_curve(df = ryegrass,
                     .parameter = "rootl",
                     .concentration = "conc")

summary(ryegrass_m)

</code></pre>

<hr>
<h2 id='geometric_mean'>Calculate geometric mean</h2><span id='topic+geometric_mean'></span>

<h3>Description</h3>

<p>Calculate geometric mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometric_mean(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometric_mean_+3A_.x">.x</code></td>
<td>
<p>A numeric to take the geometric mean of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value
</p>


<h3>Mean calculation</h3>

<p>The geometric mean is given by:
</p>
<p style="text-align: center;"><code class="reqn">
  \left(\prod_{i=1}^n x_i \right)^\frac{1}{n}
</code>
</p>

<p>but implemented as:
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{1}{n}\exp{\sum_{i=1}^n\log(x_i)}
</code>
</p>

<p><code>NA</code>s are removed before calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::geometric_mean(runif(10))

</code></pre>

<hr>
<h2 id='get_col_names_args'>Get column names from the method arguments</h2><span id='topic+get_col_names_args'></span>

<h3>Description</h3>

<p>Get column names from the method arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col_names_args(.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_col_names_args_+3A_.list">.list</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>a character with the column names. If an element names .column_name
is <em>not</em> present in the <code>.list</code>, an empty vector is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)

list(.column_name = "XXX") |&gt; beadplexr:::get_col_names_args()
list(A = list(.column_name = "XXX")) |&gt; beadplexr:::get_col_names_args()
list(A = list(.column_name = "Inner"), .column_name = "Outer") |&gt; beadplexr:::get_col_names_args()
list(A = "ccc") |&gt; beadplexr:::get_col_names_args()

</code></pre>

<hr>
<h2 id='harmonic_mean'>Calculate harmonic mean</h2><span id='topic+harmonic_mean'></span>

<h3>Description</h3>

<p>Calculate harmonic mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic_mean(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_mean_+3A_.x">.x</code></td>
<td>
<p>A numeric to take the harmonic mean of</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value
</p>


<h3>Mean calculation</h3>

<p>The calculation of the harmonic mean is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 n\frac{1}{\sum_{i=1}^n \frac{1}{x_i}}
</code>
</p>

<p><code>NA</code>s are removed before calculation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::harmonic_mean(runif(10))

</code></pre>

<hr>
<h2 id='ident_bead_pop'>Identify bead populations</h2><span id='topic+ident_bead_pop'></span>

<h3>Description</h3>

<p>This is a convenience function which allows to subset the data before calling
<code><a href="#topic+identify_analyte">identify_analyte()</a></code>. The data is subset only if <code>.column_name</code> and
<code>.cluster</code> are given. Otherwise, the function is identical to calling
<code><a href="#topic+identify_analyte">identify_analyte()</a></code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ident_bead_pop(
  .analytes,
  .column_name = NULL,
  .cluster = NULL,
  .call_args,
  df,
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ident_bead_pop_+3A_.analytes">.analytes</code></td>
<td>
<p>A vector or list giving the IDs of the analytes.</p>
</td></tr>
<tr><td><code id="ident_bead_pop_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column to subset by.</p>
</td></tr>
<tr><td><code id="ident_bead_pop_+3A_.cluster">.cluster</code></td>
<td>
<p>A character of the length of one giving the element to subset
by.</p>
</td></tr>
<tr><td><code id="ident_bead_pop_+3A_.call_args">.call_args</code></td>
<td>
<p>A list giving the parameters passed on to <code>identify_analyte()</code>.</p>
</td></tr>
<tr><td><code id="ident_bead_pop_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="ident_bead_pop_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenience function to identify analytes in a subset
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "a"
</code></pre>

<hr>
<h2 id='identify_analyte'>Identify analyte</h2><span id='topic+identify_analyte'></span>

<h3>Description</h3>

<p>Identify analyte
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_analyte(
  df,
  .parameter,
  .analyte_id,
  .column_name = "analyte",
  .k = length(.analyte_id),
  .trim = 0,
  .desc = FALSE,
  .method = c("clara", "kmeans", "dbscan", "mclust", "density_cut"),
  .data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_analyte_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of column(s) where populations
are identified.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.analyte_id">.analyte_id</code></td>
<td>
<p>A character vector giving the ID of the analyte.
The <strong>order</strong> is important and must match the expected order of analytes.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column to store the
population information.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.k">.k</code></td>
<td>
<p>Numeric giving the number of expected clusters, or a set of initial
cluster centers.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.trim">.trim</code></td>
<td>
<p>A numeric between 0 and 1, giving the fraction of points to
remove by marking them NA.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.desc">.desc</code></td>
<td>
<p>A boolean to indicate if the centers of the analytes should be
arranged in a descending fashion before assigning the names.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.method">.method</code></td>
<td>
<p>A character giving the clustering method to use.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="identify_analyte_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to appropriate methods, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the process of:
</p>

<ul>
<li><p> Finding analyte clusters
</p>
</li>
<li><p> Trimming the clusters by removing the cluster members most distant from
the cluster center
</p>
</li>
<li><p> Sorting the analyte clusters based on their centers
</p>
</li>
<li><p> Giving each analyte cluster a useful name
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame with analyte IDs in a separate column
</p>


<h3>Additional parameters</h3>

<p>Information on additional arguments passed, can be found here:
</p>

<dl>
<dt>clara</dt><dd><p><code><a href="cluster.html#topic+clara">cluster::clara()</a></code></p>
</dd>
<dt>kmeans</dt><dd><p><code><a href="stats.html#topic+kmeans">kmeans()</a></code></p>
</dd>
<dt>dbscan</dt><dd><p><code><a href="fpc.html#topic+dbscan">fpc::dbscan()</a></code></p>
</dd>
<dt>mclust</dt><dd><p><code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code></p>
</dd>
<dt>density_cut</dt><dd><p><code><a href="#topic+approx_adjust">approx_adjust()</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+cluster_events">cluster_events()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beadplexr)
library(ggplot2)

data("lplex")

df &lt;- lplex[[1]]
df |&gt;
  identify_analyte(.parameter = c("FSC-A", "SSC-A"),
                      .analyte_id = c("A", "B"),
                      .column_name = "analyte",
                      .method = "clara", .trim = 0.02) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = analyte) +
  geom_point()

df |&gt;
  identify_analyte(.parameter = c("FSC-A", "SSC-A"),
                      .analyte_id = c("A", "B"),
                      .column_name = "analyte",
                      .method = "clara", .desc = TRUE) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = analyte) +
  geom_point()

df |&gt;
  identify_analyte(.parameter = c("FSC-A", "SSC-A"),
                      .analyte_id = c("A", "B"),
                      .column_name = "analyte",
                      .method = "dbscan") |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = analyte) +
  geom_point()

## End(Not run)
</code></pre>

<hr>
<h2 id='identify_assay_analyte'>Identify multiplex assay analytes</h2><span id='topic+identify_assay_analyte'></span><span id='topic+identify_legendplex_analyte'></span><span id='topic+identify_cba_analyte'></span><span id='topic+identify_macsplex_analyte'></span>

<h3>Description</h3>

<p>Convenience functions to identify analytes in different multiplex systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_legendplex_analyte(df, .analytes, .method_args, .data = NULL)

identify_cba_analyte(
  df,
  .analytes,
  .method_args,
  .trim_fs = NULL,
  .parameter_fs = NULL,
  .data = NULL
)

identify_macsplex_analyte(
  df,
  .analytes,
  .method_args,
  .trim_fs = NULL,
  .parameter_fs = NULL,
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_assay_analyte_+3A_df">df</code></td>
<td>
<p>A tidy data.frame.</p>
</td></tr>
<tr><td><code id="identify_assay_analyte_+3A_.analytes">.analytes</code></td>
<td>
<p>A vector or list giving the IDs of the analytes. The
<strong>order</strong> is important and must match the expected order of analytes.</p>
</td></tr>
<tr><td><code id="identify_assay_analyte_+3A_.method_args">.method_args</code></td>
<td>
<p>A list giving the parameters passed on to <code>identify_analyte()</code>.</p>
</td></tr>
<tr><td><code id="identify_assay_analyte_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="identify_assay_analyte_+3A_.trim_fs">.trim_fs</code></td>
<td>
<p>A numeric between 0 and 1, giving the fraction of points to
remove from the forward side scatter.</p>
</td></tr>
<tr><td><code id="identify_assay_analyte_+3A_.parameter_fs">.parameter_fs</code></td>
<td>
<p>A character giving the names of the forward and side
scatter parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions wraps around the process of:
</p>

<ul>
<li><p> Trim or subset on forward side scatter
</p>
</li>
<li><p> Identifying analytes. For LEGENDplex in both bead groups
</p>
</li></ul>

<p>If the forward side scatter events are not trimmed, the function is equivalent
to call <code><a href="#topic+identify_analyte">identify_analyte()</a></code> with CBA or MACSPlex data.
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Analytes</h3>

<p>The parameter <code>.analytes</code> is either a simple vector with the IDs or, in the
case of the LEGENDplex system, a list giving the IDs of analytes among the groups A and B.
</p>
<p>A list for the LEGENDplex system might look like this:
</p>
<div class="sourceCode"><pre>  list(A = c("A1", "A2"),
       B = c("B1", "B2"))
</pre></div>
<p>The <strong>order</strong> of analyte IDs is important and must match the expected order of analytes.
</p>


<h3>Method arguments</h3>

<p>The parameter <code>.method_args</code> is a list of key-value pairs passed to <code><a href="#topic+identify_analyte">identify_analyte()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beadplexr)
library(dplyr)
data("lplex")
df &lt;- lplex[[1]]

panel_info &lt;- load_panel(.panel_name = "Human Growth Factor Panel (13-plex)")

args_ident_analyte &lt;- list(fs = list(.parameter = c("FSC-A", "SSC-A"),
                                     .column_name = "Bead group",
                                     .trim = 0.1,
                                     .method = "clara"),
                           analytes = list(.parameter = "FL6-H",
                                           .column_name = "Analyte ID",
                                           .trim = 0,
                                           .method = "clara"))

annot_events &lt;- identify_legendplex_analyte(df = df,
                                            .analytes = panel_info$analytes,
                                            .method_args = args_ident_analyte)

annot_events |&gt; facs_plot(.beads = "Bead group")

annot_events |&gt;
  filter(`Bead group` == "A") |&gt;
  facs_plot(.x = "FL2-H", .y = "FL6-H", .beads = "Analyte ID")

annot_events |&gt;
  filter(`Bead group` == "B") |&gt;
  facs_plot(.x = "FL2-H", .y = "FL6-H", .beads = "Analyte ID")

## End(Not run)
## Not run: 
library(beadplexr)
data(simplex)

df &lt;- simplex[["cba"]]

analytes &lt;- vector("list", 30) |&gt; setNames(as.character(c(1:30)))

args_ident_analyte &lt;- list(.parameter = c("APC", "APC-Cy7"),
                           .column_name = "Analyte ID",
                           .trim = 0.1,
                           .method = "clara")
annot_events &lt;- identify_cba_analyte(df = df,
                     .analytes = analytes,
                     .method_args = args_ident_analyte)

annot_events |&gt; facs_plot(.x = "FSC", .y = "SSC")

annot_events |&gt;
  facs_plot(.x = "APC", .y = "APC-Cy7", .beads = "Analyte ID")

annot_events &lt;- identify_cba_analyte(df = df,
                     .analytes = analytes,
                     .method_args = args_ident_analyte,
                     .trim_fs = 0.1,
                     .parameter_fs = c("FSC", "SSC"))

annot_events |&gt; facs_plot(.x = "FSC", .y = "SSC", .beads = "Bead events")

# Looks strange because some true beads events have randomly been placed far
# from the center in the forward-side scatter when the data was created
annot_events |&gt;
  facs_plot(.x = "APC", .y = "APC-Cy7", .beads = "Analyte ID")

## End(Not run)
## Not run: 
library(beadplexr)
data(simplex)

df &lt;- simplex[["mplex"]]
analytes &lt;- vector("list", 10) |&gt; setNames(as.character(c(1:10)))

args_ident_analyte &lt;- list(.parameter = c("FITC", "PE"),
                           .column_name = "Analyte ID",
                           .trim = 0.1,
                           .method = "clara")

annot_events &lt;- identify_macsplex_analyte(df = df,
                                     .analytes = analytes,
                                     .method_args = args_ident_analyte)

annot_events |&gt; facs_plot(.x = "FSC", .y = "SSC")

annot_events |&gt;
  facs_plot(.x = "FITC", .y = "PE", .beads = "Analyte ID")

annot_events &lt;- identify_macsplex_analyte(df = df,
                                     .analytes = analytes,
                                     .method_args = args_ident_analyte,
                                     .trim_fs = 0.1,
                                     .parameter_fs = c("FSC", "SSC"))

annot_events |&gt; facs_plot(.x = "FSC", .y = "SSC", .beads = "Bead events")
# Looks strange because some true beads events have randomly been placed far
# from the center in the forward-side scatter when the data was created
annot_events |&gt;
  facs_plot(.x = "FITC", .y = "PE", .beads = "Analyte ID")

## End(Not run)
</code></pre>

<hr>
<h2 id='load_panel'>Load panel information</h2><span id='topic+load_panel'></span>

<h3>Description</h3>

<p>The panel information are stored in <code>resources</code> in the package directory
and can be loaded by providing a file or panel name, or a search pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_panel(.file_name = NULL, .panel_name = NULL, .panel_pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_panel_+3A_.file_name">.file_name</code></td>
<td>
<p>Character vector giving the name of an external panel info
file. See below for the expected components.</p>
</td></tr>
<tr><td><code id="load_panel_+3A_.panel_name">.panel_name</code></td>
<td>
<p>Character vector giving the name of the panel. See below
for accepted panel names.</p>
</td></tr>
<tr><td><code id="load_panel_+3A_.panel_pattern">.panel_pattern</code></td>
<td>
<p>The pattern to look for. Can be a regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an explicit <code>.file_name</code> is given, <code>.panel_name</code> and
<code>.panel_pattern</code> are ignored. If no file is given but a
<code>.panel_name</code> is, the <code>.panel_pattern</code> i ignored. Only if no
<code>.file_name</code> and <code>.panel_name</code> are given, is the
<code>.panel_pattern</code> used.
</p>


<h3>Value</h3>

<p>A <code>list</code>
</p>


<h3>Included panels</h3>


<ul>
<li><p> Human Adipokine Panel* (13-plex)
</p>
</li>
<li><p> Human Anti-Virus Response Panel (13-plex)
</p>
</li>
<li><p> Human CD8/NK Panel (13-plex)
</p>
</li>
<li><p> Human Cytokine Panel 2 (13-plex)
</p>
</li>
<li><p> Human Growth Factor Panel (13-plex)
</p>
</li>
<li><p> Human Inflammation Panel (13-plex)
</p>
</li>
<li><p> Human Metabolic Panel 1 (4-plex)
</p>
</li>
<li><p> Human Proinflammatory Chemokine Panel (13-plex)
</p>
</li>
<li><p> Human T Helper Cytokine Panels (13-plex)
</p>
</li>
<li><p> Mouse Anti-Virus Response Panel (13-plex)
</p>
</li>
<li><p> Mouse Cytokine Panel 2 (13-plex)
</p>
</li>
<li><p> Mouse Free Active/Total TGF-b1 Panel (Mouse/Rat) (1-plex)
</p>
</li>
<li><p> Mouse HSC Panel (13-plex)
</p>
</li>
<li><p> Mouse IgE Panel (1-plex)
</p>
</li>
<li><p> Mouse Immunoglobulin Isotyping Panel (6-plex)
</p>
</li>
<li><p> Mouse Inflammation Panel (13-plex)
</p>
</li>
<li><p> Mouse Proinflammatory Chemokine Panel (13-plex)
</p>
</li>
<li><p> Mouse T Helper Cytokine Panels (13-plex)
</p>
</li></ul>



<h3>Example panel file</h3>

<p>The panel information files are formatted in YAML. It has three main parts:
</p>

<ul>
<li><p> Some general information about the panel - The order of the major bead
groups in the forward and side scatter - Analytes, where each bead ID is
listed for each major bead group. The bead IDs are further complemented
with the name of the analyte and the start concentration of the standard
value
</p>
</li></ul>

<p>The 'Human Th Cytokine Panel (13-plex)' YAML file is found in
<code>/resources/legendplex_human_th_cytokine_panel_13-plex.yml</code> of the
package directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)

.panel_name &lt;- "Human T Helper Cytokine Panels (13-plex)"
panel_info &lt;- load_panel(.panel_name = .panel_name)
panel_info$panel_name

.file_name &lt;- system.file("resources",
                          "legendplex_human_cytokine_panel_2_13-plex.yml",
                          package = "beadplexr")
panel_info &lt;- load_panel(.file_name = .file_name)
panel_info$panel_name

panel_info &lt;- load_panel(.file_name = .file_name, .panel_name = .panel_name)
panel_info$panel_name

suppressWarnings(
# The pattern matches several files, which raises a warning
panel_info &lt;- load_panel(.panel_pattern = "panel_2_13-plex")
)
panel_info$panel_name

</code></pre>

<hr>
<h2 id='lplex'>LEGENDplex example data</h2><span id='topic+lplex'></span>

<h3>Description</h3>

<p>Data from a &quot;Human Growth Factor Panel (13-plex)&quot; LEGENDplex experiment, with
8 controls and 1 human serum samples, all in duplicates. The beads were
measured on a CytoFLEX cytometer, and the fcs-files were processed using
<code><a href="#topic+read_fcs">read_fcs()</a></code>, with default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lplex")
</code></pre>


<h3>Format</h3>

<p>A list with 18 elements. Each element is a data.frame about 5000 rows
and 4 columns (the exact number varies a little due to the data
acquisition):
</p>

<dl>
<dt>FSC-A</dt><dd><p>The forward scatter parameter</p>
</dd>
<dt>SSC-A</dt><dd><p>The side scatter parameter</p>
</dd>
<dt>FL6-H</dt><dd><p>Intensity in the FL6 channel</p>
</dd>
<dt>FL2-H</dt><dd><p>Intensity in the FL2 channel</p>
</dd>
</dl>

<p>The list contains 8 standard samples in duplicates, and one serum
sample, also in duplicate. The names of each element have the
format K3 (internal panel shorthand), C:number: for standards and
S:number: for serum sample, and a number indicating the replicate
(1 or 2).
</p>


<h3>Source</h3>

<p>Ulrik Stervbo, 2016, Unpublished
</p>

<hr>
<h2 id='pad_matrix'>Pad a matrix</h2><span id='topic+pad_matrix'></span>

<h3>Description</h3>

<p>Pad a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_matrix(x, pad_size = 1L, pad = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_matrix_+3A_x">x</code></td>
<td>
<p>The matrix to pad.</p>
</td></tr>
<tr><td><code id="pad_matrix_+3A_pad_size">pad_size</code></td>
<td>
<p>An integer giving the number of columns/rows to pad with.</p>
</td></tr>
<tr><td><code id="pad_matrix_+3A_pad">pad</code></td>
<td>
<p>A single value giving the padding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(c(1:9), nrow = 3, ncol = 3)
beadplexr:::pad_matrix(x)

x &lt;- matrix(c(1:4), nrow = 2, ncol = 2)
beadplexr:::pad_matrix(x)
beadplexr:::pad_matrix(x, pad_size = 2L)
beadplexr:::pad_matrix(x, pad = NA)
beadplexr:::pad_matrix(x, pad = "xx")

x &lt;- matrix(c(1:6), nrow = 3, ncol = 2)
beadplexr:::pad_matrix(x)

</code></pre>

<hr>
<h2 id='panel_name_file'>Get file name from panel name</h2><span id='topic+panel_name_file'></span>

<h3>Description</h3>

<p>Conversion from panel name to internal panel info file name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel_name_file(.panel_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_name_file_+3A_.panel_name">.panel_name</code></td>
<td>
<p>Character vector giving the name of the panel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::panel_name_file(.panel_name = "Human Th Cytokine Panel (13-plex)")

</code></pre>

<hr>
<h2 id='plot_concentrations'>Plot concentrations</h2><span id='topic+plot_concentrations'></span><span id='topic+plot_std_curve'></span><span id='topic+plot_target_est_conc'></span><span id='topic+plot_estimate'></span>

<h3>Description</h3>

<p>Plot concentrations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_std_curve(
  df,
  .model,
  .title = NULL,
  .parameter = "FL2.H",
  .concentration = "Concentration",
  .data = NULL
)

plot_target_est_conc(
  df,
  .title = NULL,
  .concentration = "Calc.conc",
  .std_concentration = "Concentration",
  .data = NULL
)

plot_estimate(
  .sample_data,
  .standard_data,
  .model,
  .title = NULL,
  .parameter = "FL2.H",
  .concentration = "Concentration"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_concentrations_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> with the data to be plotted.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.model">.model</code></td>
<td>
<p>An object of class <code>drc</code> with the fitted dose-response model.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.title">.title</code></td>
<td>
<p>A character giving the title of the plot.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of the column with the MFI</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.concentration">.concentration</code></td>
<td>
<p>A character giving the name of the column with the with the calculated concentrations.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.std_concentration">.std_concentration</code></td>
<td>
<p>A character giving the name of the column with the standard concentration.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.sample_data">.sample_data</code></td>
<td>
<p>A <code>data.frame</code> with the calculated sample concentrations.</p>
</td></tr>
<tr><td><code id="plot_concentrations_+3A_.standard_data">.standard_data</code></td>
<td>
<p>A <code>data.frame</code> with the calculated standard
concentrations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beadplexr)
library(drc)
data(ryegrass)

ryegrass_m &lt;-
  fit_standard_curve(df = ryegrass,
                     .parameter = "rootl",
                     .concentration = "conc")
recalc_std &lt;-
  calculate_concentration(df = ryegrass,
                          .model = ryegrass_m,
                          .parameter = "rootl")
sample_data &lt;-
  calculate_concentration(df = ryegrass[sample(1:nrow(ryegrass), 5),],
                          .model = ryegrass_m,
                          .parameter = "rootl")

plot_std_curve(ryegrass,
               ryegrass_m,
               .parameter = "rootl",
               .concentration = "conc")

plot_target_est_conc(df = recalc_std,
                     .concentration = "Calc.conc",
                     .std_concentration = "conc")
plot_estimate(
  .sample_data = sample_data,
  .standard_data = ryegrass,
  .model = ryegrass_m,
  .parameter = "rootl",
  .concentration = "conc")

</code></pre>

<hr>
<h2 id='raise_deprecated'>Warn about deprecated parameters or functions</h2><span id='topic+raise_deprecated'></span>

<h3>Description</h3>

<p>Warn about deprecated parameters or functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raise_deprecated(old, new, caller = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raise_deprecated_+3A_old">old</code></td>
<td>
<p>A character giving the old function or parameter.</p>
</td></tr>
<tr><td><code id="raise_deprecated_+3A_new">new</code></td>
<td>
<p>A character giving the replacement function or parameter.</p>
</td></tr>
<tr><td><code id="raise_deprecated_+3A_caller">caller</code></td>
<td>
<p>A character vector giving the function with the deprecated
parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Just raise a warning
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beadplexr:::raise_deprecated("XX", "YY")
beadplexr:::raise_deprecated(old = "XX", new = "YY", caller = "ZZZ")
beadplexr:::raise_deprecated(old = "XX", new = "YY", caller = "ZZZ()")

</code></pre>

<hr>
<h2 id='read_fcs'>Read a fcs file.</h2><span id='topic+read_fcs'></span>

<h3>Description</h3>

<p>Is deprecated. See the vignette &quot;Preparing flow-data for use with with
<code>beadplexr</code>&quot; for an example of preparing flow-data to be used with
<code>beadplexr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fcs(
  .file_name,
  .fsc_ssc = c("FSC-A", "SSC-A"),
  .bead_channels = c("FL6-H", "FL2-H"),
  .filter = list(`FSC-A` = c(200000L, 800000L), `SSC-A` = c(200000L, 1000000L), `FL6-H` =
    c(7.3, Inf)),
  .compensation = "guess",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fcs_+3A_.file_name">.file_name</code></td>
<td>
<p>The path and name of the file to be read.</p>
</td></tr>
<tr><td><code id="read_fcs_+3A_.fsc_ssc">.fsc_ssc</code></td>
<td>
<p>The names of the forward and side scatter channels. A
character vector of length of two.</p>
</td></tr>
<tr><td><code id="read_fcs_+3A_.bead_channels">.bead_channels</code></td>
<td>
<p>The names of the channels with bead events. A character
vector of length of at least two.</p>
</td></tr>
<tr><td><code id="read_fcs_+3A_.filter">.filter</code></td>
<td>
<p>Optional list of upper and lower cutoff for individual
channels. Use <code>.filter = NULL</code> for no filtering at all.</p>
</td></tr>
<tr><td><code id="read_fcs_+3A_.compensation">.compensation</code></td>
<td>
<p>A character vector, a compensation matrix, or
<code>NULL</code>. See 'Details' for extended information of the argument.</p>
</td></tr>
<tr><td><code id="read_fcs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>flowCore::read.FCS</code></p>
</td></tr>
</table>

<hr>
<h2 id='simplex'>Simulated beadplex data</h2><span id='topic+simplex'></span>

<h3>Description</h3>

<p>Very simple, simulated multiplex data to demonstrate the clustering
functionality of the <strong>beadplexr</strong> package on CBA and MACSPlex assays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simplex)
</code></pre>


<h3>Format</h3>

<p>A list with three elements. Each element is a <code>data.frame</code> of 3000 to 9000 rows. The exact format depends on the assay simulated:
</p>

<dl>
<dt>lplex</dt><dd>
<p>Simulated LEGENDplex data. A single <code>data.frame</code> with the columns:
</p>

<dl>
<dt>FSC</dt><dd><p>The forward scatter parameter</p>
</dd>
<dt>SSC</dt><dd><p>The side scatter parameter</p>
</dd>
<dt>APC</dt><dd><p>Intensity in the APC channel</p>
</dd>
<dt>PE</dt><dd><p>Intensity in the PE channel</p>
</dd>
</dl>

</dd>
<dt>mplex</dt><dd>
<p>Simulated MACSPlex data. A single <code>data.frame</code> with the columns:
</p>

<dl>
<dt>FSC</dt><dd><p>The forward scatter parameter</p>
</dd>
<dt>SSC</dt><dd><p>The side scatter parameter</p>
</dd>
<dt>FITC</dt><dd><p>Intensity in the FITC channel</p>
</dd>
<dt>PE</dt><dd><p>Intensity in the PE channel</p>
</dd>
<dt>APC</dt><dd><p>Intensity in the PE channel</p>
</dd>
</dl>

</dd>
<dt>cba</dt><dd>
<p>Simulated CBA data. A single <code>data.frame</code> with the columns:
</p>

<dl>
<dt>FSC</dt><dd><p>The forward scatter parameter</p>
</dd>
<dt>SSC</dt><dd><p>The side scatter parameter</p>
</dd>
<dt>APC</dt><dd><p>Intensity in the APC channel</p>
</dd>
<dt>APC-Cy7</dt><dd><p>Intensity in the APC-Cy7 channel</p>
</dd>
<dt>PE</dt><dd><p>Intensity in the PE channel</p>
</dd>
</dl>

</dd>
</dl>



<h3>Source</h3>

<p>Artificial
</p>

<hr>
<h2 id='trim_population'>Trim cluster.</h2><span id='topic+trim_population'></span>

<h3>Description</h3>

<p>Remove the points furthest form the center of the cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_population(
  df,
  .parameter,
  .column_name = "population",
  .trim = 0.1,
  .data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_population_+3A_df">df</code></td>
<td>
<p>The tidy data.frame with clusters to be modified.</p>
</td></tr>
<tr><td><code id="trim_population_+3A_.parameter">.parameter</code></td>
<td>
<p>A character giving the name of dimensions to calculate
distance on.</p>
</td></tr>
<tr><td><code id="trim_population_+3A_.column_name">.column_name</code></td>
<td>
<p>A character giving the name of the column with the
cluster information.</p>
</td></tr>
<tr><td><code id="trim_population_+3A_.trim">.trim</code></td>
<td>
<p>A numeric between 0 and 1, giving the fraction of points to
remove.</p>
</td></tr>
<tr><td><code id="trim_population_+3A_.data">.data</code></td>
<td>
<p>Deprecated. Use <code>df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The euclidean distance is calculated for each point defined by
<code>.parameter</code> to the center of the cluster. The cluster designation of
the <code>.trim</code> most distant points are changed to <code>NA</code>.
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beadplexr)
library(dplyr)
library(ggplot2)

data("lplex")

lplex[[1]] |&gt;
  filter(`FSC-A` &gt; 3.2e5L) |&gt;
  mutate(population = "1") |&gt;
  trim_population(.parameter = c("FSC-A", "SSC-A"), .column_name = "population", .trim = 0.1) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()

lplex[[1]] |&gt;
  filter(`FSC-A` &gt; 3.2e5L) |&gt;
  mutate(population = "1") |&gt;
  trim_population(.parameter = c("FSC-A", "SSC-A"),
                  .column_name = "population", .trim = 0.8) |&gt;
  ggplot() +
  aes(x = `FSC-A`, y = `SSC-A`, colour = population) +
  geom_point()
</code></pre>

<hr>
<h2 id='turning_point'>Turning points</h2><span id='topic+turning_point'></span>

<h3>Description</h3>

<p>Find turning points (minima and maxima) in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turning_point(
  .x,
  .which = c("both", "minima", "maxima"),
  .return = c("value", "index"),
  .adjust = 1.5,
  .k = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turning_point_+3A_.x">.x</code></td>
<td>
<p>A numeric vector or a list of numeric vectors. If the list is
named, the names become column names in the returned data.frames</p>
</td></tr>
<tr><td><code id="turning_point_+3A_.which">.which</code></td>
<td>
<p>A character indicating the values of interest.</p>
</td></tr>
<tr><td><code id="turning_point_+3A_.return">.return</code></td>
<td>
<p>A character giving the desired return type.</p>
</td></tr>
<tr><td><code id="turning_point_+3A_.adjust">.adjust</code></td>
<td>
<p>A numeric giving the adjustment to the <code>adjust</code> argument of <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="turning_point_+3A_.k">.k</code></td>
<td>
<p>Numeric giving the number of expected clusters.</p>
</td></tr>
<tr><td><code id="turning_point_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+approx_adjust">approx_adjust</a></code>
</p>

<dl>
<dt><code>.lower,.upper</code></dt><dd><p>The interval for possible value of adjust.</p>
</dd>
<dt><code>.step</code></dt><dd><p>A numeric giving the increment to adjust. Sometimes low values
are needed to find a proper adjust value.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the two elements <code>maxima</code> and <code>minima</code>. each element
consist of a single <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
.x &lt;- c(rnorm(100, 2, 1), rnorm(100, 9, 1))

turning_point(.x = .x, .adjust = 1)
turning_point(.x = .x, .k = 2)

turning_point(.x = .x, .which = "minima")
turning_point(.x = .x, .which = "maxima")

turning_point(.x = .x, .return = "index")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
