<!DOCTYPE html><html><head><title>Help for package rtmpt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtmpt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a2a'><p>Set process thresholds equal</p></a></li>
<li><a href='#a2const'><p>Set process threshold to constants</p></a></li>
<li><a href='#delta2delta'><p>Set mapping between response categories and encoding plus motor execution times</p></a></li>
<li><a href='#fit_drtmpt'><p>Fit Diffusion-RT-MPT Models</p></a></li>
<li><a href='#fit_ertmpt'><p>Fit Exponential-RT-MPT Models</p></a></li>
<li><a href='#fit_ertmpt_SBC'><p>Simulation-based calibration for RT-MPT models</p></a></li>
<li><a href='#nu2const'><p>Set process drift rate to constants</p></a></li>
<li><a href='#nu2nu'><p>Set process drift rates equal</p></a></li>
<li><a href='#omega2const'><p>Set process relative starting-point to constants</p></a></li>
<li><a href='#omega2omega'><p>Set process relaitve starting-point equal</p></a></li>
<li><a href='#set_resps'><p>Set responses in an <code>ertmpt_model</code> or a <code>drtmpt_model</code></p></a></li>
<li><a href='#sim_ertmpt_data'><p>Simulate data from RT-MPT models</p></a></li>
<li><a href='#sim_ertmpt_data_SBC'><p>Simulate data from an RT-MPT model</p></a></li>
<li><a href='#SimData'><p>Data simulated from the restricted 2HTM</p></a></li>
<li><a href='#tau2tau'><p>Set process completion times equal</p></a></li>
<li><a href='#tau2zero'><p>Set process completion times to zero</p></a></li>
<li><a href='#theta2const'><p>Set process probabilities to constants</p></a></li>
<li><a href='#theta2theta'><p>Set process probabilities equal</p></a></li>
<li><a href='#to_drtmpt_data'><p>Transform data to be used in Diffusion RT-MPT model fitting</p></a></li>
<li><a href='#to_drtmpt_model'><p>Create a model list to fit a Diffusion-RT-MPT</p></a></li>
<li><a href='#to_ertmpt_data'><p>Transform data to be used in RT-MPT model fitting</p></a></li>
<li><a href='#to_ertmpt_model'><p>Create a model list to fit an RT-MPT</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting (Exponential/Diffusion) RT-MPT Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphael Hartmann [aut, cre],
  Karl C. Klauer [cph, aut, ctb, ths],
  Constantin G. Meyer-Grant [aut, ctb],
  Henrik Singmann [ctb, aut],
  Jean Marie Linhart [ctb],
  Frederick Novomestky [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raphael Hartmann &lt;raphael.hartmann@protonmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, data.table, loo, methods, Ryacas, stats, stringr,
truncnorm, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GSL (&gt;=2.3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit (exponential or diffusion) response-time extended multinomial processing tree (RT-MPT) models 
      by Klauer and	Kellen (2018) &lt;<a href="https://doi.org/10.1016%2Fj.jmp.2017.12.003">doi:10.1016/j.jmp.2017.12.003</a>&gt; and Klauer, Hartmann, and Meyer-Grant (submitted). 
      The RT-MPT class not only incorporate	frequencies like traditional multinomial processing tree (MPT) models, 
      but also latencies. This enables it	to estimate process completion times and encoding plus motor execution times 
      next to the process probabilities	of traditional MPTs. 'rtmpt' is a hierarchical Bayesian framework and posterior 
      samples are sampled using a Metropolis-within-Gibbs sampler (for exponential RT-MPTs) or Hamiltonian-within-Gibbs 
      sampler (for diffusion RT-MPTs).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-25 13:02:51 UTC; hartmann</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a2a'>Set process thresholds equal</h2><span id='topic+a2a'></span><span id='topic+set_a_equal'></span>

<h3>Description</h3>

<p>Setting multiple process thresholds (parameter a) equal. One of the process thresholds will be estimated and the other
named thresholds will be set to equal the former. The equality can be removed by only using one name of a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2a(model, names, keep_consts = FALSE)

set_a_equal(model, names, keep_consts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a2a_+3A_model">model</code></td>
<td>
<p>A list of the class <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="a2a_+3A_names">names</code></td>
<td>
<p>Character vector giving the names of the processes for which the process thresholds should be equal. If
<code>length(names) = 1</code> then the corresponding process threshold will be estimated (i.e., it will be set to NA)</p>
</td></tr>
<tr><td><code id="a2a_+3A_keep_consts">keep_consts</code></td>
<td>
<p>Can be one of the following
</p>

<ul>
<li><p> logical value: <code>FALSE</code> (default) means none of the constants for <code>names</code> in the <code>model</code> will be kept; The thresholds of
the reference process (i.e., first of <code>names</code> in alphabetical order) will be set to <code>NA</code> (i.e., will be estimated) and the others
will be set to the name of the reference process (i.e., will be set to equal the reference process thresholds). <code>TRUE</code> means
the constant of the reference process threshold (if specified) is used for all other processes.
</p>
</li>
<li><p> numeric value: index for <code>names</code>. If 1, the constant of the first process in <code>names</code> (in original order defined by the user) is
used for all other thresholds of the processes in <code>names</code>. If 2, the constant of the second process is used. And so on.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2const">a2const</a></code>, <code><a href="#topic+nu2const">nu2const</a></code>, <code><a href="#topic+nu2nu">nu2nu</a></code>, <code><a href="#topic+omega2const">omega2const</a></code>, and <code><a href="#topic+omega2omega">omega2omega</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process thresholds for both detection processes ("do" and "dn")
# will be set equal.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## make do = dn
new_model &lt;- a2a(model = model, names = c("do", "dn"))
new_model


## make do = dn
new_model &lt;- set_a_equal(model = model, names = c("do", "dn"))
new_model
</code></pre>

<hr>
<h2 id='a2const'>Set process threshold to constants</h2><span id='topic+a2const'></span><span id='topic+set_a_const'></span>

<h3>Description</h3>

<p>Setting process thresholds (parameter a) to constants or change it back to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2const(model, names, constants = NA)

set_a_const(model, names, constants = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a2const_+3A_model">model</code></td>
<td>
<p>An object of the class <code>rtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="a2const_+3A_names">names</code></td>
<td>
<p>Character vector with process names.</p>
</td></tr>
<tr><td><code id="a2const_+3A_constants">constants</code></td>
<td>
<p>Numerical vector of length one or <code>length(names)</code>. You have the following options for the elements of the numeric vector:
</p>

<ul>
<li> <p><code>0 &lt; constants</code>: set the named threshold parameter(s) to constant value(s) larger than zero
</p>
</li>
<li> <p><code>NA</code>: estimate the named threshold parameter(s)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2a">a2a</a></code>, <code><a href="#topic+nu2const">nu2const</a></code>, <code><a href="#topic+nu2nu">nu2nu</a></code>, <code><a href="#topic+omega2const">omega2const</a></code> and <code><a href="#topic+omega2omega">omega2omega</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process threshold for guessing (g) will be set to 1.0.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## setting threshold for g to a constant (1.0):
new_model &lt;- a2const(model = model, names = c("g"), constants = c(1.0))
new_model


## setting threshold of g to a constant (1.0):
new_model &lt;- set_a_const(model = model, names = c("g"), constants = c(1.0))
new_model
</code></pre>

<hr>
<h2 id='delta2delta'>Set mapping between response categories and encoding plus motor execution times</h2><span id='topic+delta2delta'></span><span id='topic+set_deltas_equal'></span>

<h3>Description</h3>

<p>Mapping response categories with encoding and motor execution times (deltas). Unlike the processes there are no names for 
the different deltas and therefore a mapping from response categories to different deltas must be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta2delta(model, trees, categories, mappings = 0)

set_deltas_equal(model, trees, categories, mappings = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta2delta_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code> or <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="delta2delta_+3A_trees">trees</code></td>
<td>
<p>Character or numerical vector giving the trees</p>
</td></tr>
<tr><td><code id="delta2delta_+3A_categories">categories</code></td>
<td>
<p>Character or numerical vector identifying category/ies within 
the specified <code>trees</code> for which the deltas should be changed.</p>
</td></tr>
<tr><td><code id="delta2delta_+3A_mappings">mappings</code></td>
<td>
<p>Numerical vector of length <code>length(categories)</code> providing the mappings. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code>, <code><a href="#topic+theta2theta">theta2theta</a></code>, and <code><a href="#topic+tau2tau">tau2tau</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times will be set to different responses 
###########################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## changing the model to have two different encoding and motor execution 
## times for "old" and "new" responses.
new_model &lt;- delta2delta(model = model, trees = c(0, 1), 
                         categories = c(1,3), mappings = c(1,1))
new_model


model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## changing the model to have two different encoding and motor execution 
## times for "old" and "new" responses.
new_model &lt;- delta2delta(model = model, trees = c(0, 1), 
                         categories = c(1,3), mappings = c(1,1))
new_model
                                 

## changing the model to have two different encoding and response execution 
## times for "old" and "new" responses.
new_model &lt;- set_deltas_equal(model = model, trees = c(0, 1), 
                              categories = c(1,3), mappings = c(1,1))
new_model
</code></pre>

<hr>
<h2 id='fit_drtmpt'>Fit Diffusion-RT-MPT Models</h2><span id='topic+fit_drtmpt'></span>

<h3>Description</h3>

<p>Given model and data, this function a Hamiltonian MCMC sampler and stores the samples in an mcmc.list called <code>samples</code>.
Posterior predictive checks developed by Klauer (2010), deviance information criterion (DIC; Spiegelhalter et al., 2002),
99% and 95% highest density intervals (HDI) together with the median will be provided for the main parameters in a list
called <code>diags</code>. Optionally, the <code>indices</code> widely applicable information criterion (WAIC; Watanabe, 2010; Vehtari et al., 2017) and
leave-one-out cross-validation (LOO; Vehtari et al., 2017) can be saved. Additionally the log-likelihood (<code>LogLik</code>) can also be stored.
Some specifications of the function call are also saved in <code>specs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_drtmpt(
  model,
  data,
  n.chains = 4,
  n.iter = 1000,
  n.phase1 = 1000,
  n.phase2 = 2000,
  n.thin = 1,
  Rhat_max = 1.1,
  Irep = 1000,
  prior_params = NULL,
  flags = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_drtmpt_+3A_model">model</code></td>
<td>
<p>A list of the class <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_data">data</code></td>
<td>
<p>Optimally, a list of class <code>drtmpt_data</code>. Also possible is a <code>data.frame</code> or a
path to the text file. Both, <code>data.frame</code> and the text file must contain the column names &quot;subj&quot;,
&quot;group&quot;, &quot;tree&quot;, &quot;cat&quot;, and &quot;rt&quot; preferably but not necessarily in this order. The values of the latter must
be in milliseconds. It is always advised to use <code><a href="#topic+to_drtmpt_data">to_drtmpt_data</a></code> first, which gives back a
<code>drtmpt_data</code> list with information about the changes in the data, that were needed.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of chains to use. Default is 4. Must be larger than 1 and smaller or equal to 16.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of samples per chain. Default is 1000.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_n.phase1">n.phase1</code></td>
<td>
<p>Number of samples for phase 1 (adaptation phase). Default is 1000.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_n.phase2">n.phase2</code></td>
<td>
<p>Number of samples for phase 2. Default is 2000.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning factor. Default is 1.</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_rhat_max">Rhat_max</code></td>
<td>
<p>Maximal Potential scale reduction factor: A lower threshold that needs to be reached before the actual sampling starts. Default is 1.05</p>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_irep">Irep</code></td>
<td>
<p>Every <code>Irep</code> samples an interim state with the current maximal potential scale reduction
factor is shown. Default is 1000. The following statements must hold true for <code>Irep</code>:
</p>

<ul>
<li> <p><code>n.phase1</code> is a multiple of <code>Irep</code>
</p>
</li>
<li> <p><code>n.phase2</code> is a multiple of <code>Irep</code>
</p>
</li>
<li> <p><code>n.phase1</code> is smaller than or equal to <code>n.phase2</code>,
</p>
</li>
<li> <p><code>Irep</code> is a multiple of <code>n.thin</code> and
</p>
</li>
<li> <p><code>n.iter</code> is a multiple of <code>Irep / n.thin</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_prior_params">prior_params</code></td>
<td>
<p>Named list with prior parameters. All parameters have default values, that lead to uninformative priors. Vectors are not allowed.
Allowed parameters are:
</p>

<ul>
<li> <p><code>prec_epsilon</code>: prior precision for population means of process-related parameters.
Default is <code>1.0</code>.
</p>
</li>
<li> <p><code>delta_df</code>: degrees of freedom of t-distribution for motor times. Default is <code>10</code>.
</p>
</li>
<li> <p><code>delta_mu</code>: mean of t-distribution for motor times. Default is <code>0.5</code>.
</p>
</li>
<li> <p><code>delta_scale</code>: scale of t-distribution for motor times. Default is <code>1.0</code>.
</p>
</li>
<li> <p><code>SIGMA_Corr_eta</code>: shape parameter for LKJ distribution for process-related parameters. Default is <code>4.0</code>.
</p>
</li>
<li> <p><code>SIGMA_SD_rho</code>: scale parameter of half-Cauchy distribution for process-related parameters. Default is <code>2.5</code>.
</p>
</li>
<li> <p><code>GAMMA_Corr_eta</code>: shape parameter for LKJ distribution for motor-related parameters. Default is <code>4.0</code>.
</p>
</li>
<li> <p><code>GAMMA_SD_rho</code>: scale parameter of half-Cauchy distribution for motor-related parameters. Default is <code>0.5</code>.
</p>
</li>
<li> <p><code>Omega2_alpha</code>: shape parameter of gamma distribution for residual variance. Default is <code>0.0025</code>.
</p>
</li>
<li> <p><code>Omega2_beta</code>: rate parameter of gamma distribution for residual variance. Default is <code>0.5</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_flags">flags</code></td>
<td>
<p>Either NULL or a list of
</p>

<ul>
<li> <p><code>old_label</code> If set to <code>TRUE</code> the old labels of &quot;subj&quot; and &quot;group&quot; of the data will be used in the elements of the output list.
Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>indices</code> Model selection indices. If set to <code>TRUE</code> the log-likelihood for each iteration and trial will be
stored temporarily and with that the WAIC and LOO will be calculated via the <code>loo</code> package. If you want to have this
log-likelihood matrix stored in the output of this function, you can set <code>loglik</code> to <code>TRUE</code>. Default for
<code>indices</code> is <code>FALSE</code>.
</p>
</li>
<li> <p><code>loglik</code> If set to <code>TRUE</code> and <code>indices = TRUE</code> the log-likelihood matrix for each iteration and trial will
be saved in the output as a matrix. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>random_init</code> If set to <code>TRUE</code> the initial values are randomly drawn. If <code>FLASE</code> maximum likelihood is used
for initial values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_drtmpt_+3A_control">control</code></td>
<td>
<p>Either NULL or a list of
</p>

<ul>
<li> <p><code>maxthreads</code> for the ML estimation of the initial values and the calculation of the DIC values one can use more than
<code>n.chains</code> threads for parallelization. Default is 4 like <code>n.chians</code>. <code>maxthreads</code> must be larger or equal to
<code>n.chains</code>.
</p>
</li>
<li> <p><code>maxtreedepth1_3</code> maxtree-depth of the no-U-turn algorithm in Phases 1 to 3
</p>
</li>
<li> <p><code>maxtreedepth4</code> maxtree-depth of the no-U-turn algorithm in Phases 4
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_fit</code> containing
</p>

<ul>
<li> <p><code>samples</code>: the posterior samples as an <code>mcmc.list</code> object,
</p>
</li>
<li> <p><code>diags</code>: some diagnostics like deviance information criterion, posterior predictive checks for the frequencies and latencies,
potential scale reduction factors, and also the 99% and 95% HDIs and medians for the group-level parameters,
</p>
</li>
<li> <p><code>specs</code>: some model specifications like the model, arguments of the model call, and information about the data transformation,
</p>
</li>
<li> <p><code>indices</code> (optional): if enabled, WAIC and LOO,
</p>
</li>
<li> <p><code>LogLik</code> (optional): if enabled, the log-likelihood matrix used for WAIC and LOO.
</p>
</li>
<li> <p><code>summary</code> includes posterior mean and median of the main parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A latent-trait approach. <em>Psychometrika, 75(1)</em>, 70-98.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P., &amp; Van Der Linde, A. (2002). Bayesian measures of model complexity and fit.
<em>Journal of the royal statistical society: Series b (statistical methodology), 64(4)</em>, 583-639.
</p>
<p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing, 27(5)</em>, 1413-1432.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely applicable information criterion in singular learning theory.
<em>Journal of Machine Learning Research, 11(Dec)</em>, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each response.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

data_file &lt;- system.file("extdata/data.txt", package="rtmpt")
data &lt;- read.table(file = data_file, header = TRUE)
data_list &lt;- to_drtmpt_data(raw_data = data, model = model)

# This might take some time
drtmpt_out &lt;- fit_drtmpt(model = model, data = data_list, Rhat_max = 1.1)
drtmpt_out

</code></pre>

<hr>
<h2 id='fit_ertmpt'>Fit Exponential-RT-MPT Models</h2><span id='topic+fit_ertmpt'></span>

<h3>Description</h3>

<p>Given model and data, this function calls an altered version of the C++ program by Klauer and Kellen (2018) to sample from
the posterior distribution via a Metropolis-Gibbs sampler and storing it in an mcmc.list called <code>samples</code>. 
Posterior predictive checks developed by Klauer (2010), deviance information criterion (DIC; Spiegelhalter et al., 2002),
99% and 95% highest density intervals (HDI) together with the median will be provided for the main parameters in a list 
called <code>diags</code>. Optionally, the <code>indices</code> widely applicable information criterion (WAIC; Watanabe, 2010; Vehtari et al., 2017) and 
leave-one-out cross-validation (LOO; Vehtari et al., 2017) can be saved. Additionally the log-likelihood (<code>LogLik</code>) can also be stored. 
Some specifications of the function call are also saved in <code>specs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ertmpt(
  model,
  data,
  n.chains = 4,
  n.iter = 5000,
  n.burnin = 200,
  n.thin = 1,
  Rhat_max = 1.05,
  Irep = 1000,
  prior_params = NULL,
  indices = FALSE,
  save_log_lik = FALSE,
  old_label = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ertmpt_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_data">data</code></td>
<td>
<p>Optimally, a list of class <code>ertmpt_data</code>. Also possible is a <code>data.frame</code> or a 
path to the text file. Both, <code>data.frame</code> and the text file must contain the column names &quot;subj&quot;, 
&quot;group&quot;, &quot;tree&quot;, &quot;cat&quot;, and &quot;rt&quot; preferably but not necessarily in this order. The values of the latter must 
be in milliseconds. It is always advised to use <code><a href="#topic+to_ertmpt_data">to_ertmpt_data</a></code> first, which gives back an <code>ertmpt_data</code> list
with informations about the changes in the data, that were needed.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of chains to use. Default is 4. Must be larger than 1 and smaller or equal to 16.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of samples per chain. Default is 5000.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of warm-up samples. Default is 200.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning factor. Default is 1.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_rhat_max">Rhat_max</code></td>
<td>
<p>Maximal Potential scale reduction factor: A lower threshold that needs to be reached before the actual sampling starts. Default is 1.05</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_irep">Irep</code></td>
<td>
<p>Every <code>Irep</code> samples an interim state with the current maximal potential scale reduction
factor is shown. Default is 1000. The following statements must hold true for <code>Irep</code>:
</p>

<ul>
<li> <p><code>n.burnin</code> is smaller than or equal to <code>Irep</code>,
</p>
</li>
<li> <p><code>Irep</code> is a multiple of <code>n.thin</code> and
</p>
</li>
<li> <p><code>n.iter</code> is a multiple of <code>Irep / n.thin</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_prior_params">prior_params</code></td>
<td>
<p>Named list with prior parameters. All parameters have default values, that lead to uninformative priors. Vectors are not allowed.
Allowed parameters are:
</p>

<ul>
<li> <p><code>mean_of_exp_mu_beta</code>: This is the a priori expected exponential rate (<code>E(exp(beta)) = E(lambda)</code>) and 
<code>1/mean_of_exp_mu_beta</code> is the a priori expected process time (<code>1/E(exp(beta)) = E(tau)</code>). The default
mean is set to <code>10</code>, such that the expected a priori process time is <code>0.1</code> seconds.
</p>
</li>
<li> <p><code>var_of_exp_mu_beta</code>: The a priori group-specific variance of the exponential rates. Since
<code>exp(mu_beta)</code> is Gamma distributed, the rate of the distribution is just mean divided by variance and
the shape is the mean times the rate. The default is set to <code>100</code>.
</p>
</li>
<li> <p><code>mean_of_mu_gamma</code>: This is the a priori expected <em>mean parameter</em> of the encoding and response execution times,
which follow a normal distribution truncated from below at zero, so <code>E(mu_gamma) &lt; E(gamma)</code>. The default is <code>0</code>.
</p>
</li>
<li> <p><code>var_of_mu_gamma</code>: The a priori group-specific variance of the <em>mean parameter</em>. Its default is <code>10</code>.
</p>
</li>
<li> <p><code>mean_of_omega_sqr</code>: This is the a priori expected residual variance (<code>E(omega^2)</code>). Its distribution
differs from the one used in the paper. Here it is a Gamma distribution instead of an improper one. The default
is <code>0.005</code>.
</p>
</li>
<li> <p><code>var_of_omega_sqr</code>: The a priori variance of the residual variance (<code>Var(omega^2)</code>). The default is
<code>0.01</code>. The default of the mean and variance is equivalent to a shape and rate of <code>0.0025</code> and 
<code>0.5</code>, respectivly.
</p>
</li>
<li> <p><code>df_of_sigma_sqr</code>: A priori degrees of freedom for the individual variance of the response executions. The
individual variance has a scaled inverse chi-squared prior with <code>df_of_sigma_sqr</code> degrees of freedom and
<code>omega^2</code> as scale. <code>2</code> is the default and it should be an integer.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_SIGMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the process 
related parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_SIGMA</code> is a scaling factor, that scales this 
matrix (<code>S=sf_of_scale_matrix_SIGMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_GAMMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the encoding and
motor execution parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_GAMMA</code> is a scaling factor, that scales 
this matrix (<code>S=sf_of_scale_matrix_GAMMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>prec_epsilon</code>: This is epsilon in the paper. It is the precision of mu_alpha and all xi (scaling parameter
in the scaled inverse Wishart distribution). Its default is also <code>1</code>.
</p>
</li>
<li> <p><code>add_df_to_invWish</code>: If <code>P</code> is the number of parameters or rather the size of the scale matrix used in the (scaled)
inverse Wishart distribution then <code>add_df_to_invWish</code> is the number of degrees of freedom that can be added to it. So
<code>DF = P + add_df_to_invWish</code>. The default for <code>add_df_to_invWish</code> is <code>1</code>, such that the correlations are uniformly 
distributed within <code>[-1, 1]</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_indices">indices</code></td>
<td>
<p>Model selection indices. If set to <code>TRUE</code> the log-likelihood for each iteration and trial will be stored temporarily
and with that the WAIC and LOO will be calculated via the <code>loo</code> package. If you want to have this log-likelihood matrix stored in the
output of this function, you can set <code>save_log_lik</code> to <code>TRUE</code>. The default for <code>indices</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_save_log_lik">save_log_lik</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>indices = TRUE</code> the log-likelihood matrix for each iteration and trial will
be saved in the output as a matrix. Its default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_+3A_old_label">old_label</code></td>
<td>
<p>If set to <code>TRUE</code> the old labels of &quot;subj&quot; and &quot;group&quot; of the data will be used in the elements of the output list. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_fit</code> containing 
</p>

<ul>
<li> <p><code>samples</code>: the posterior samples as an <code>mcmc.list</code> object,
</p>
</li>
<li> <p><code>diags</code>: some diagnostics like deviance information criterion, posterior predictive checks for the frequencies and latencies, 
potential scale reduction factors, and also the 99% and 95% HDIs and medians for the group-level parameters,
</p>
</li>
<li> <p><code>specs</code>: some model specifications like the model, arguments of the model call, and information about the data transformation,
</p>
</li>
<li> <p><code>indices</code> (optional): if enabled, WAIC and LOO,
</p>
</li>
<li> <p><code>LogLik</code> (optional): if enabled, the log-likelihood matrix used for WAIC and LOO. 
</p>
</li>
<li> <p><code>summary</code> includes posterior mean and median of the main parameters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Hartmann, R., Johannsen, L., &amp; Klauer, K. C. (2020). rtmpt: An R package for fitting response-time extended multinomial processing tree models. 
<em>Behavior Research Methods, 52</em>(3), 1313–1338. 
</p>
<p>Hartmann, R., &amp; Klauer, K. C. (2020). Extending RT-MPTs to enable equal process times. <em>Journal of Mathematical Psychology, 96</em>, 102340.
</p>
<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A latent-trait approach. <em>Psychometrika, 75(1)</em>, 70-98.
</p>
<p>Klauer, K. C., &amp; Kellen, D. (2018). RT-MPTs: Process models for response-time distributions based on multinomial processing trees with 
applications to recognition memory. <em>Journal of Mathematical Psychology, 82</em>, 111-130.
</p>
<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P., &amp; Van Der Linde, A. (2002). Bayesian measures of model complexity and fit. 
<em>Journal of the royal statistical society: Series b (statistical methodology), 64(4)</em>, 583-639.
</p>
<p>Vehtari, A., Gelman, A., &amp; Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. 
<em>Statistics and Computing, 27(5)</em>, 1413-1432.
</p>
<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely applicable information criterion in singular learning theory. 
<em>Journal of Machine Learning Research, 11(Dec)</em>, 3571-3594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each response.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

data_file &lt;- system.file("extdata/data.txt", package="rtmpt")
data &lt;- read.table(file = data_file, header = TRUE)
data_list &lt;- to_ertmpt_data(raw_data = data, model = model)

# This might take some time
ertmpt_out &lt;- fit_ertmpt(model = model, data = data_list, Rhat_max = 1.1)
ertmpt_out

# Type ?SimData for another working example.
</code></pre>

<hr>
<h2 id='fit_ertmpt_SBC'>Simulation-based calibration for RT-MPT models</h2><span id='topic+fit_ertmpt_SBC'></span>

<h3>Description</h3>

<p>Simulate data from RT-MPT models using <code>ertmpt_model</code> objects. The difference to <code><a href="#topic+sim_ertmpt_data">sim_ertmpt_data</a></code> is that here only scalars are allowed. This makes it usable for
simulation-based calibration (SBC; Talts et al., 2018). You can specify the random seed, number of subjects, number of trials, and some
parameters (same as <code>prior_params</code> from <code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ertmpt_SBC(
  model,
  seed,
  n.eff_samples = 99,
  n.chains = 4,
  n.iter = 5000,
  n.burnin = 200,
  n.thin = 1,
  Rhat_max = 1.05,
  Irep = 1000,
  n.subj = 40,
  n.trials = 30,
  prior_params = NULL,
  sim_list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ertmpt_SBC_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_seed">seed</code></td>
<td>
<p>Random seed number.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.eff_samples">n.eff_samples</code></td>
<td>
<p>Number of effective samples. Default is 99, leading to 100 possible ranks (from 0 to 99).</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of chains to use. Default is 4. Must be larger than 1 and smaller or equal to 16.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of samples per chain. Default is 5000. Must be larger or equal to <code>n.eff_samples</code>.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.burnin">n.burnin</code></td>
<td>
<p>Number of warm-up samples. Default is 200.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.thin">n.thin</code></td>
<td>
<p>Thinning factor. Default is 1.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_rhat_max">Rhat_max</code></td>
<td>
<p>Maximal Potential scale reduction factor: A lower threshold that needs to be reached before the actual sampling starts. Default is 1.05</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_irep">Irep</code></td>
<td>
<p>Every <code>Irep</code> samples an interim state with the current maximal potential scale reduction
factor is shown. Default is 1000. The following statements must hold true for <code>Irep</code>:
</p>

<ul>
<li> <p><code>n.burnin</code> is smaller than or equal to <code>Irep</code>,
</p>
</li>
<li> <p><code>Irep</code> is a multiple of <code>n.thin</code> and
</p>
</li>
<li> <p><code>n.iter</code> is a multiple of <code>Irep / n.thin</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.subj">n.subj</code></td>
<td>
<p>Number of subjects. Default is 40.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_n.trials">n.trials</code></td>
<td>
<p>Number of trials per tree. Default is 30.</p>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_prior_params">prior_params</code></td>
<td>
<p>Named list of parameters from which the data will be generated. This must be the same named list as <code>prior_params</code> from
<code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code> and has the same defaults. It is not recommended to use the defaults since they lead to many probabilities close or
equal to <code>0</code> and/or <code>1</code> and to RTs close or equal to <code>0</code>. Allowed parameters are:
</p>

<ul>
<li> <p><code>mean_of_exp_mu_beta</code>: This is the expected exponential rate (<code>E(exp(beta)) = E(lambda)</code>) and
<code>1/mean_of_exp_mu_beta</code> is the expected process time (<code>1/E(exp(beta)) = E(tau)</code>). The default
mean is set to <code>10</code>, such that the expected process time is <code>0.1</code> seconds.
</p>
</li>
<li> <p><code>var_of_exp_mu_beta</code>: The group-specific variance of the exponential rates. Since
<code>exp(mu_beta)</code> is Gamma distributed, the rate of the distribution is just mean divided by variance and
the shape is the mean times the rate. The default is set to <code>100</code>.
</p>
</li>
<li> <p><code>mean_of_mu_gamma</code>: This is the expected <em>mean parameter</em> of the encoding and response execution times,
which follow a normal distribution truncated from below at zero, so <code>E(mu_gamma) &lt; E(gamma)</code>. The default is <code>0</code>.
</p>
</li>
<li> <p><code>var_of_mu_gamma</code>: The group-specific variance of the <em>mean parameter</em>. Its default is <code>10</code>.
</p>
</li>
<li> <p><code>mean_of_omega_sqr</code>: This is the expected residual variance (<code>E(omega^2)</code>). The default is <code>0.005</code>.
</p>
</li>
<li> <p><code>var_of_omega_sqr</code>: The variance of the residual variance (<code>Var(omega^2)</code>). The default is
<code>0.01</code>. The default of the mean and variance is equivalent to a shape and rate of <code>0.0025</code> and
<code>0.5</code>, respectivly.
</p>
</li>
<li> <p><code>df_of_sigma_sqr</code>: degrees of freedom for the individual variance of the response executions. The
individual variance follows a scaled inverse chi-squared distribution with <code>df_of_sigma_sqr</code> degrees of freedom and
<code>omega^2</code> as scale. <code>2</code> is the default and it should be an integer.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_SIGMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the process
related parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_SIGMA</code> is a scaling factor, that scales this
matrix (<code>S=sf_of_scale_matrix_SIGMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_GAMMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the encoding and
motor execution parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_GAMMA</code> is a scaling factor that scales
this matrix (<code>S=sf_of_scale_matrix_GAMMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>prec_epsilon</code>: This is epsilon in the paper. It is the precision of mu_alpha and all xi (scaling parameter
in the scaled inverse Wishart distribution). Its default is also <code>1</code>.
</p>
</li>
<li> <p><code>add_df_to_invWish</code>: If <code>P</code> is the number of parameters or rather the size of the scale matrix used in the (scaled)
inverse Wishart distribution then <code>add_df_to_invWish</code> is the number of degrees of freedom that can be added to it. So
<code>DF = P + add_df_to_invWish</code>. The default for <code>add_df_to_invWish</code> is <code>1</code>, such that the correlations are uniformly
distributed within <code>[-1, 1]</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_ertmpt_SBC_+3A_sim_list">sim_list</code></td>
<td>
<p>Object of class <code>ertmpt_sim</code>. This is also an output object. Can be used to re-fit the model if <code>n.eff_samples</code> was not achieved in a previous fitting attempt.
It will then use the data stored in this object. Default is NULL and this object will be created anew.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_sbc</code> containing
</p>

<ul>
<li> <p><code>ranks</code>: the rank statistic for all parameters,
</p>
</li>
<li> <p><code>sim_list</code>: an object of the class <code>ertmpt_sim</code>,
</p>
</li>
<li> <p><code>fit_list</code>: an object of the class <code>ertmpt_fit</code>,
</p>
</li>
<li> <p><code>specs</code>: some specifications like the model, seed number, etc.,
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Talts, S., Betancourt, M., Simpson, D., Vehtari, A., &amp; Gelman, A. (2018). Validating Bayesian inference algorithms with simulation-based calibration. <em>arXiv preprint arXiv:1804.06788</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

mdl_2HTM &lt;- "
# targets
d+(1-d)*g     ; 0
(1-d)*(1-g)   ; 1

# lures
(1-d)*g       ; 0
d+(1-d)*(1-g) ; 1

# d: detect; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

params &lt;- list(mean_of_exp_mu_beta = 10,
               var_of_exp_mu_beta = 10,
               mean_of_mu_gamma = 0.5,
               var_of_mu_gamma = 0.0025,
               mean_of_omega_sqr = 0.005,
               var_of_omega_sqr = 0.000025,
               df_of_sigma_sqr = 10,
               sf_of_scale_matrix_SIGMA = 0.1,
               sf_of_scale_matrix_GAMMA = 0.01,
               prec_epsilon = 10,
               add_df_to_invWish = 5)

R = 2 # typically 2000 with n.eff_samples = 99, but this will run many days
rank_mat &lt;- matrix(NA, ncol = 393, nrow = 2)
for (r in 1:R) {
  SBC_out &lt;- fit_ertmpt_SBC(model, seed = r*123, prior_params = params,
                           n.eff_samples = 99, n.thin = 5,
                           n.iter = 5000, n.burnin = 2000, Irep = 5000)
  rank_mat[r, ] &lt;- SBC_out$ranks
}


</code></pre>

<hr>
<h2 id='nu2const'>Set process drift rate to constants</h2><span id='topic+nu2const'></span><span id='topic+set_nu_const'></span>

<h3>Description</h3>

<p>Setting process drif rate (parameter nu) to constants or change it back to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2const(model, names, constants = NA)

set_nu_const(model, names, constants = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nu2const_+3A_model">model</code></td>
<td>
<p>An object of the class <code>rtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="nu2const_+3A_names">names</code></td>
<td>
<p>Character vector with process names.</p>
</td></tr>
<tr><td><code id="nu2const_+3A_constants">constants</code></td>
<td>
<p>Numerical vector of length one or <code>length(names)</code>. You have the following options for the elements of the numeric vector:
</p>

<ul>
<li> <p><code>-Inf &lt; constants &lt; Inf</code>: set the named drift rate parameter(s) to constant value(s)
</p>
</li>
<li> <p><code>NA</code>: estimate the named drift rate parameter(s)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2const">a2const</a></code>, <code><a href="#topic+a2a">a2a</a></code>, <code><a href="#topic+nu2nu">nu2nu</a></code>, <code><a href="#topic+omega2const">omega2const</a></code> and <code><a href="#topic+omega2omega">omega2omega</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process drift rate for guessing (g) will be set to 1.0.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## setting drift rate for g to a constant (1.0):
new_model &lt;- nu2const(model = model, names = c("g"), constants = c(1.0))
new_model


## setting drift rate of g to a constant (1.0):
new_model &lt;- set_nu_const(model = model, names = c("g"), constants = c(1.0))
new_model
</code></pre>

<hr>
<h2 id='nu2nu'>Set process drift rates equal</h2><span id='topic+nu2nu'></span><span id='topic+set_nu_equal'></span>

<h3>Description</h3>

<p>Setting multiple process drift rates (nu) equal. One of the process drift rates will be estimated and the other
named drift rates will be set to equal the former. The equality can be removed by only using one name of a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nu2nu(model, names, keep_consts = FALSE)

set_nu_equal(model, names, keep_consts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nu2nu_+3A_model">model</code></td>
<td>
<p>A list of the class <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="nu2nu_+3A_names">names</code></td>
<td>
<p>Character vector giving the names of the processes for which the process drift rates should be equal. If
<code>length(names) = 1</code> then the corresponding process drift rates will be estimated (i.e., it will be set to NA)</p>
</td></tr>
<tr><td><code id="nu2nu_+3A_keep_consts">keep_consts</code></td>
<td>
<p>Can be one of the following
</p>

<ul>
<li><p> logical value: <code>FALSE</code> (default) means none of the constants for <code>names</code> in the <code>model</code> will be kept; The drift rates of
the reference process (i.e., first of <code>names</code> in alphabetical order) will be set to <code>NA</code> (i.e., will be estimated) and the others
will be set to the name of the reference process (i.e., will be set to equal the reference process drift rate). <code>TRUE</code> means
the constant of the reference process drift rate (if specified) is used for all other processes.
</p>
</li>
<li><p> numeric value: index for <code>names</code>. If 1, the constant of the first process in <code>names</code> (in original order defined by the user) is
used for all other drift rates of the processes in <code>names</code>. If 2, the constant of the second process is used. And so on.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2const">a2const</a></code>, <code><a href="#topic+a2a">a2a</a></code>, <code><a href="#topic+nu2const">nu2const</a></code>, <code><a href="#topic+omega2const">omega2const</a></code>, and <code><a href="#topic+omega2omega">omega2omega</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process drift rates for both detection processes ("do" and "dn")
# will be set equal.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## make do = dn
new_model &lt;- nu2nu(model = model, names = c("do", "dn"))
new_model


## make do = dn
new_model &lt;- set_nu_equal(model = model, names = c("do", "dn"))
new_model
</code></pre>

<hr>
<h2 id='omega2const'>Set process relative starting-point to constants</h2><span id='topic+omega2const'></span><span id='topic+set_omega_const'></span>

<h3>Description</h3>

<p>Setting process relative starting-point (parameter omega) to constants or change it back to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omega2const(model, names, constants = NA)

set_omega_const(model, names, constants = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omega2const_+3A_model">model</code></td>
<td>
<p>An object of the class <code>rtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="omega2const_+3A_names">names</code></td>
<td>
<p>Character vector with process names.</p>
</td></tr>
<tr><td><code id="omega2const_+3A_constants">constants</code></td>
<td>
<p>Numerical vector of length one or <code>length(names)</code>. You have the following options for the elements of the numeric vector:
</p>

<ul>
<li> <p><code>0 &lt; constants &lt; 0</code>: set the named relaitve starting-point parameter(s) to constant value(s) larger than zero and smaller than 1
</p>
</li>
<li> <p><code>NA</code>: estimate the named relaitve starting-point parameter(s)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2const">a2const</a></code>, <code><a href="#topic+a2a">a2a</a></code>, <code><a href="#topic+nu2const">nu2const</a></code>, <code><a href="#topic+nu2nu">nu2nu</a></code>, and <code><a href="#topic+omega2omega">omega2omega</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process relative starting-point for guessing (g) will be set to 0.5.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## setting relative starting-point for g to a constant (1.0):
new_model &lt;- omega2const(model = model, names = c("g"), constants = c(0.5))
new_model


## setting relative starting-point of g to a constant (0.5):
new_model &lt;- set_omega_const(model = model, names = c("g"), constants = c(0.5))
new_model
</code></pre>

<hr>
<h2 id='omega2omega'>Set process relaitve starting-point equal</h2><span id='topic+omega2omega'></span><span id='topic+set_omegas_equal'></span>

<h3>Description</h3>

<p>Setting multiple process relaitve starting-points (omegas) equal. One of the process relaitve starting-points will be estimated and the
other named relaitve starting-points will be set to equal the former. The equality can be removed by only using one name of a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omega2omega(model, names, keep_consts = FALSE)

set_omegas_equal(model, names, keep_consts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omega2omega_+3A_model">model</code></td>
<td>
<p>A list of the class <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="omega2omega_+3A_names">names</code></td>
<td>
<p>Character vector giving the names of the processes for which the process relaitve starting-points should be equal. If
<code>length(names) = 1</code> then the corresponding process relaitve starting-point will be estimated (i.e., it will be set to NA)</p>
</td></tr>
<tr><td><code id="omega2omega_+3A_keep_consts">keep_consts</code></td>
<td>
<p>Can be one of the following
</p>

<ul>
<li><p> logical value: <code>FALSE</code> (default) means none of the constants for <code>names</code> in the <code>model</code> will be kept; The relaitve starting-points of
the reference process (i.e., first of <code>names</code> in alphabetical order) will be set to <code>NA</code> (i.e., will be estimated) and the others
will be set to the name of the reference process (i.e., will be set to equal the reference process relative starting-point). <code>TRUE</code> means
the constant of the reference process relaitve starting-point (if specified) is used for all other processes.
</p>
</li>
<li><p> numeric value: index for <code>names</code>. If 1, the constant of the first process in <code>names</code> (in original order defined by the user) is
used for all other relaitve starting-points of the processes in <code>names</code>. If 2, the constant of the second process is used. And so on.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+a2const">a2const</a></code>, <code><a href="#topic+a2a">a2a</a></code>, <code><a href="#topic+nu2const">nu2const</a></code>, <code><a href="#topic+nu2nu">nu2nu</a></code>, and <code><a href="#topic+omega2const">omega2const</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process relaitve starting-points for both detection processes ("do" and "dn")
# will be set equal.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## make do = dn
new_model &lt;- omega2omega(model = model, names = c("do", "dn"))
new_model


## make do = dn
new_model &lt;- set_omegas_equal(model = model, names = c("do", "dn"))
new_model
</code></pre>

<hr>
<h2 id='set_resps'>Set responses in an <code>ertmpt_model</code> or a <code>drtmpt_model</code></h2><span id='topic+set_resps'></span>

<h3>Description</h3>

<p>Change the responses for a tree and the categories within that tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_resps(model, tree, categories, values = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_resps_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code> or <code>drtmpt_model</code>.</p>
</td></tr>
<tr><td><code id="set_resps_+3A_tree">tree</code></td>
<td>
<p>Character or numerical value of the tree for which the responses 
should be changed.</p>
</td></tr>
<tr><td><code id="set_resps_+3A_categories">categories</code></td>
<td>
<p>Character or numerical vector identifying category/ies within 
the specified <code>tree</code> for which the responses should be changed.</p>
</td></tr>
<tr><td><code id="set_resps_+3A_values">values</code></td>
<td>
<p>Numerical vector of length <code>length(categories)</code> providing the responses. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code> or <code>drtmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times will be set to different values 
#   for each response.
#########################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## changing the model to have two different encoding and response execution 
## times for "old" and "new" responses.
for(i in c(0,1)) model &lt;- set_resps(model = model, tree = i, 
                                    categories = i*2+1, values = 1)


#' model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)

## changing the model to have two different encoding and response execution 
## times for "old" and "new" responses.
for(i in c(0,1)) model &lt;- set_resps(model = model, tree = i, 
                                    categories = i*2+1, values = 1)
                                 
</code></pre>

<hr>
<h2 id='sim_ertmpt_data'>Simulate data from RT-MPT models</h2><span id='topic+sim_ertmpt_data'></span>

<h3>Description</h3>

<p>Simulate data from RT-MPT models using <code>ertmpt_model</code> objects. 
You can specify the random seed, number of subjects, number of trials per tree, and some
parameters (mainly the same as <code>prior_params</code> from <code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ertmpt_data(model, seed, n.subj, n.trials, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ertmpt_data_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_+3A_seed">seed</code></td>
<td>
<p>Random seed number.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_+3A_n.subj">n.subj</code></td>
<td>
<p>Number of subjects.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_+3A_n.trials">n.trials</code></td>
<td>
<p>Number of trials per tree.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_+3A_params">params</code></td>
<td>
<p>Named list of parameters from which the data will be generated. This must be the same named list as <code>prior_params</code> from 
<code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code>, except for &quot;mean_of_mu_alpha&quot; and &quot;var_of_mu_alpha&quot;, and has the same defaults. The difference to <code>prior_params</code> 
is, that vectors are allowed, but must match the length of the parameters in the <code>model</code>. It is not recommended to use the defaults 
since they lead to many probabilities close or equal to <code>0</code> and/or <code>1</code> and to RTs close or equal to <code>0</code>. Allowed parameters are:
</p>

<ul>
<li> <p><code>mean_of_mu_alpha</code>: Probit transformed mean probability. If you want to have a group-level mean probability of 
<code>0.6</code>, use <code>mean_of_mu_alpha = qnorm(0.6)</code> in the <code>params</code> list. Default is <code>0</code> or <code>qnorm(.5)</code>.
</p>
</li>
<li> <p><code>var_of_mu_alpha</code>: Variance of the probit transformed group-level mean probability. If specified, mu_alpha will be sampled from 
N(<code>mean_of_mu_alpha, var_of_mu_alpha</code>). If not, mu_alpha <code>= mean_of_mu_alpha</code>. 
</p>
</li>
<li> <p><code>mean_of_exp_mu_beta</code>: This is the expected exponential rate (<code>E(exp(beta)) = E(lambda)</code>) and 
<code>1/mean_of_exp_mu_beta</code> is the expected process time (<code>1/E(exp(beta)) = E(tau)</code>). The default
mean is set to <code>10</code>, such that the expected process time is <code>0.1</code> seconds. For a mean process time of <code>200</code> ms, wirte 
<code>mean_of_exp_mu_beta = 1000/200</code>.
</p>
</li>
<li> <p><code>var_of_exp_mu_beta</code>: The group-specific variance of the exponential rates. Since
<code>exp(mu_beta)</code> is Gamma distributed, the rate of the distribution is just mean divided by variance and
the shape is the mean times the rate. If specified, exp(mu_beta) is sampled from 
Gamma<code>shape = mean_of_exp_mu_beta^2/var_of_exp_mu_beta, rate = mean_of_exp_mu_beta/var_of_exp_mu_beta</code>). If not, 
mu_alpha <code>= mean_of_exp_mu_beta</code>.
</p>
</li>
<li> <p><code>mean_of_mu_gamma</code>: This is the expected <em>mean parameter</em> of the encoding and response execution times,
which follow a normal distribution truncated from below at zero, so <code>E(mu_gamma) &lt; E(gamma)</code>. The default is <code>0</code>.
For a mean motor time of <code>550</code> ms write <code>mean_of_mu_gamma = 550/1000</code>.
</p>
</li>
<li> <p><code>var_of_mu_gamma</code>: The group-specific variance of the <em>mean parameter</em>. If specified, mu_gamma is sampled from
N(<code>mean_of_mu_gamma, var_of_mu_gamma</code>). If not, mu_gamma <code>= mean_of_mu_gamma</code>.
</p>
</li>
<li> <p><code>mean_of_omega_sqr</code>: This is the expected residual variance (<code>E(omega^2)</code>). The default is <code>0.005</code>.
</p>
</li>
<li> <p><code>var_of_omega_sqr</code>: The variance of the residual variance (<code>Var(omega^2)</code>). If specified, omega_sqr is sampled from
GAMMA(<code>shape = mean_of_omega_sqr^2/var_of_omega_sqr, rate = mean_of_omega_sqr/var_of_omega_sqr</code>). If not, 
omega_sqr <code>= mean_of_omega_sqr</code>.
<code>0.01</code>. The default of the mean and variance is equivalent to a shape and rate of <code>0.0025</code> and 
<code>0.5</code>, respectivly.
</p>
</li>
<li> <p><code>df_of_sigma_sqr</code>: Degrees of freedom for the individual variance of the response executions. The
individual variance follows a scaled inverse chi-squared distribution with <code>df_of_sigma_sqr</code> degrees of freedom and
<code>omega^2</code> as scale. <code>2</code> is the default and it should be an integer.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_SIGMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the process 
related parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_SIGMA</code> is a scaling factor, that scales this 
matrix (<code>S=sf_of_scale_matrix_SIGMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_GAMMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the encoding and
motor execution parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_GAMMA</code> is a scaling factor that scales 
this matrix (<code>S=sf_of_scale_matrix_GAMMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>prec_epsilon</code>: This is epsilon in the paper. It is the precision of xi (scaling parameter
in the scaled inverse Wishart distribution). Its default is also <code>1</code>.
</p>
</li>
<li> <p><code>add_df_to_invWish</code>: If <code>P</code> is the number of parameters or rather the size of the scale matrix used in the (scaled)
inverse Wishart distribution then <code>add_df_to_invWish</code> is the number of degrees of freedom that can be added to it. So
<code>DF = P + add_df_to_invWish</code>. The default for <code>add_df_to_invWish</code> is <code>1</code>, such that the correlations are uniformly 
distributed within <code>[-1, 1]</code>.
</p>
</li>
<li> <p><code>SIGMA</code>: Variance-covariance matrix of the process-related parameters. It must match the number of process-related parameters to be estimated. 
If scalars or vectors are given, they will be transformed into diagonal matrices using <code>diag(SIGMA)</code>.
If not specified it will be randomly generated using <code>diag(xi)%*%rinvwishart(nu, S)%*%diag(xi)</code>, where nu is the number of
process-related group-level parameters to be estimated plus <code>add_df_to_invWish</code>, S is the identity matrix multiplied by 
<code>sf_of_scale_matrix_SIGMA</code>, and xi (randomly generated from N(<code>1, 1/prec_epsilon</code>)) are the scaling factors for the scaled inverse wishart distribution.
If <code>SIGMA</code> is used, <code>sf_of_scale_matrix_SIGMA</code> and <code>add_df_to_invWish</code> will be ignored for the process-related parameters.
</p>
</li>
<li> <p><code>GAMMA</code>: Variance-covariance matrix of the motor time parameters. It must match the number of motor time parameters to be estimated. 
If scalars or vectors are given, they will be transformed into diagonal matrices using <code>diag(SIGMA)</code>.
If not specified it will be randomly generated using <code>diag(xi)%*%rinvwishart(nu, S)%*%diag(xi)</code>, where nu is the number of
motor time group-level parameters to be estimated plus <code>add_df_to_invWish</code>, S is the identity matrix multiplied by 
<code>sf_of_scale_matrix_GAMMA</code>, and xi (randomly generated from N(<code>1, 1/prec_epsilon</code>)) are the scaling factors for the scaled inverse wishart distribution.
If <code>GAMMA</code> is used, <code>sf_of_scale_matrix_GAMMA</code> and <code>add_df_to_invWish</code> will be ignored for the motor time parameters.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_sim</code> containing 
</p>

<ul>
<li> <p><code>data</code>: the data.frame with the simulated data,
</p>
</li>
<li> <p><code>gen_list</code>: a list containing lists of the group-level and subject-specific parameters for the process-related parameters and the motor-related
parameters, and the trial-specific probabilities, process-times, and motor-times,
</p>
</li>
<li> <p><code>specs</code>: some specifications like the model, seed number, etc.,
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g     ; 0
(1-do)*(1-g)    ; 1

# lures
(1-dn)*g        ; 0
dn+(1-dn)*(1-g) ; 1

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

# random group-level parameters
params &lt;- list(mean_of_mu_alpha = 0, 
               #var_of_mu_alpha = 1
               mean_of_exp_mu_beta = 10, 
               var_of_exp_mu_beta = 10, 
               mean_of_mu_gamma = 0.5, 
               var_of_mu_gamma = 0.0025, 
               mean_of_omega_sqr = 0.005, 
               var_of_omega_sqr = 0.000025,
               df_of_sigma_sqr = 10, 
               sf_of_scale_matrix_SIGMA = 0.1, 
               sf_of_scale_matrix_GAMMA = 0.01, 
               prec_epsilon = 10,
               add_df_to_invWish = 5)

sim_dat &lt;- sim_ertmpt_data(model, seed = 123, n.subj = 40, n.trials = 30, params = params)

# fixed group-level parameters
params &lt;- list(mean_of_mu_alpha = 0, 
               mean_of_exp_mu_beta = 10, 
               mean_of_mu_gamma = 0.5, 
               mean_of_omega_sqr = 0.005, 
               df_of_sigma_sqr = 10, 
               sf_of_scale_matrix_SIGMA = 0.1, 
               sf_of_scale_matrix_GAMMA = 0.01, 
               prec_epsilon = 10,
               add_df_to_invWish = 5,
               SIGMA = diag(9),   # independent process-related params
               GAMMA = diag(2))   # independent motor time params

sim_dat &lt;- sim_ertmpt_data(model, seed = 123, n.subj = 40, n.trials = 30, params = params)

</code></pre>

<hr>
<h2 id='sim_ertmpt_data_SBC'>Simulate data from an RT-MPT model</h2><span id='topic+sim_ertmpt_data_SBC'></span>

<h3>Description</h3>

<p>Simulate data from RT-MPT models using <code>ertmpt_model</code> objects. The difference to <code><a href="#topic+sim_ertmpt_data">sim_ertmpt_data</a></code> is that here only scalars are allowed. This makes it usable for 
simulation-based calibration (SBC; Talts et al., 2018). You can specify the random seed, number of subjects, number of trials, and some
parameters (same as <code>prior_params</code> from <code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ertmpt_data_SBC(model, seed, n.subj, n.trials, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ertmpt_data_SBC_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_SBC_+3A_seed">seed</code></td>
<td>
<p>Random seed number.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_SBC_+3A_n.subj">n.subj</code></td>
<td>
<p>&lt;- Number of subjects.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_SBC_+3A_n.trials">n.trials</code></td>
<td>
<p>&lt;- Number of trials per tree.</p>
</td></tr>
<tr><td><code id="sim_ertmpt_data_SBC_+3A_params">params</code></td>
<td>
<p>Named list of parameters from which the data will be generated. This must be the same named list as <code>prior_params</code> from 
<code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code> and has the same defaults. It is not recommended to use the defaults since they lead to many probabilities close or 
equal to <code>0</code> and/or <code>1</code> and to RTs close or equal to <code>0</code>. Allowed parameters are:
</p>

<ul>
<li> <p><code>mean_of_exp_mu_beta</code>: This is the expected exponential rate (<code>E(exp(beta)) = E(lambda)</code>) and 
<code>1/mean_of_exp_mu_beta</code> is the expected process time (<code>1/E(exp(beta)) = E(tau)</code>). The default
mean is set to <code>10</code>, such that the expected process time is <code>0.1</code> seconds.
</p>
</li>
<li> <p><code>var_of_exp_mu_beta</code>: The group-specific variance of the exponential rates. Since
<code>exp(mu_beta)</code> is Gamma distributed, the rate of the distribution is just mean divided by variance and
the shape is the mean times the rate. The default is set to <code>100</code>.
</p>
</li>
<li> <p><code>mean_of_mu_gamma</code>: This is the expected <em>mean parameter</em> of the encoding and response execution times,
which follow a normal distribution truncated from below at zero, so <code>E(mu_gamma) &lt; E(gamma)</code>. The default is <code>0</code>.
</p>
</li>
<li> <p><code>var_of_mu_gamma</code>: The group-specific variance of the <em>mean parameter</em>. Its default is <code>10</code>.
</p>
</li>
<li> <p><code>mean_of_omega_sqr</code>: This is the expected residual variance (<code>E(omega^2)</code>). The default is <code>0.005</code>.
</p>
</li>
<li> <p><code>var_of_omega_sqr</code>: The variance of the residual variance (<code>Var(omega^2)</code>). The default is
<code>0.01</code>. The default of the mean and variance is equivalent to a shape and rate of <code>0.0025</code> and 
<code>0.5</code>, respectivly.
</p>
</li>
<li> <p><code>df_of_sigma_sqr</code>: degrees of freedom for the individual variance of the response executions. The
individual variance follows a scaled inverse chi-squared distribution with <code>df_of_sigma_sqr</code> degrees of freedom and
<code>omega^2</code> as scale. <code>2</code> is the default and it should be an integer.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_SIGMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the process 
related parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_SIGMA</code> is a scaling factor, that scales this 
matrix (<code>S=sf_of_scale_matrix_SIGMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>sf_of_scale_matrix_GAMMA</code>: The original scaling matrix (S) of the (scaled) inverse Wishart distribution for the encoding and
motor execution parameters is an identity matrix <code>S=I</code>. <code>sf_of_scale_matrix_GAMMA</code> is a scaling factor that scales 
this matrix (<code>S=sf_of_scale_matrix_GAMMA*I</code>). Its default is <code>1</code>.
</p>
</li>
<li> <p><code>prec_epsilon</code>: This is epsilon in the paper. It is the precision of mu_alpha and all xi (scaling parameter
in the scaled inverse Wishart distribution). Its default is also <code>1</code>.
</p>
</li>
<li> <p><code>add_df_to_invWish</code>: If <code>P</code> is the number of parameters or rather the size of the scale matrix used in the (scaled)
inverse Wishart distribution then <code>add_df_to_invWish</code> is the number of degrees of freedom that can be added to it. So
<code>DF = P + add_df_to_invWish</code>. The default for <code>add_df_to_invWish</code> is <code>1</code>, such that the correlations are uniformly 
distributed within <code>[-1, 1]</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_sim</code> containing 
</p>

<ul>
<li> <p><code>data</code>: the data.frame with the simulated data,
</p>
</li>
<li> <p><code>gen_list</code>: a list containing lists of the group-level and subject-specific parameters for the process-related parameters and the motor-related
parameters, and the trial-specific probabilities, process-times, and motor-times,
</p>
</li>
<li> <p><code>specs</code>: some specifications like the model, seed number, etc.,
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Talts, S., Betancourt, M., Simpson, D., Vehtari, A., &amp; Gelman, A. (2018). Validating Bayesian inference algorithms with simulation-based calibration. <em>arXiv preprint arXiv:1804.06788</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g     ; 0
(1-do)*(1-g)    ; 1

# lures
(1-dn)*g        ; 0
dn+(1-dn)*(1-g) ; 1

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

params &lt;- list(mean_of_exp_mu_beta = 10, 
               var_of_exp_mu_beta = 10, 
               mean_of_mu_gamma = 0.5, 
               var_of_mu_gamma = 0.0025, 
               mean_of_omega_sqr = 0.005, 
               var_of_omega_sqr = 0.000025,
               df_of_sigma_sqr = 10, 
               sf_of_scale_matrix_SIGMA = 0.1, 
               sf_of_scale_matrix_GAMMA = 0.01, 
               prec_epsilon = 10,
               add_df_to_invWish = 5)

sim_dat &lt;- rtmpt:::sim_ertmpt_data_SBC(model, seed = 123, n.subj = 40, 
                                      n.trials = 30, params = params)

</code></pre>

<hr>
<h2 id='SimData'>Data simulated from the restricted 2HTM</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>Data set generated from a restricted Two-High Threshold model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimData
</code></pre>


<h3>Format</h3>

<p>A data frame with five variables:
</p>

<dl>
<dt><code>subj</code></dt><dd><p>subjects number</p>
</dd>
<dt><code>group</code></dt><dd><p>group label of the subjects</p>
</dd>
<dt><code>tree</code></dt><dd><p>condition of the current trial</p>
</dd>
<dt><code>cat</code></dt><dd><p>observed response category</p>
</dd>
<dt><code>rt</code></dt><dd><p>observed response time in ms</p>
</dd>
</dl>



<h3>Details</h3>

<p>Fourty subjects with thirty trials per condition (Studied items, new Items) were simulated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################################
# Detect-Guess variant of the restricted Two-High Threshold model.
###################################################################

head(SimData)

mdl_2HTM &lt;- "
# targets
d+(1-d)*g     ; 0
(1-d)*(1-g)   ; 1

# lures
(1-d)*g       ; 0
d+(1-d)*(1-g) ; 1

# d: detect; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

data &lt;- to_ertmpt_data(raw_data = SimData, model = model)

# this might take some time to run
ertmpt_out &lt;- fit_ertmpt(model = model, data = data)

# convergence
## traceplot and summary of the first six parameters
coda::traceplot(ertmpt_out$samples[,1:6])
summary(ertmpt_out)

</code></pre>

<hr>
<h2 id='tau2tau'>Set process completion times equal</h2><span id='topic+tau2tau'></span><span id='topic+set_taus_equal'></span>

<h3>Description</h3>

<p>Setting multiple process completion times (taus) equal. This means all process times of negative outcomes will be
set equal and all process times of positive outcomes will be set equal. Only two process times (one for the negative
and one for the positive outcome) of the named processes will be estimated. The equality can be removed by just 
naming only one process name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau2tau(model, names, outcome, keep_zeros = FALSE)

set_taus_equal(model, names, outcome, keep_zeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau2tau_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="tau2tau_+3A_names">names</code></td>
<td>
<p>Character vector giving the names of the processes for which the process completion times should be equal. If 
<code>length(names) = 1</code> then the corresponding process completion times (for negative and positive outcomes) will be 
estimates (i.e., they will be set to NA)</p>
</td></tr>
<tr><td><code id="tau2tau_+3A_outcome">outcome</code></td>
<td>
<p>Character (no vector) indicating for which process outcome the process completion times should 
be set equal. Allowed characters are:
</p>

<ul>
<li> <p><code>"minus"</code>: the negative outcome of the processes.
</p>
</li>
<li> <p><code>"plus"</code>: the positive outcome of the processes.
</p>
</li>
<li> <p><code>"both"</code>: the negative and positive outcome of the processes. This will set all process completion times for
the &quot;minus&quot; outcome equal and all process completion times for the &quot;plus&quot; outcome equal.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tau2tau_+3A_keep_zeros">keep_zeros</code></td>
<td>
<p>Can be one of the following
</p>

<ul>
<li><p> logical value: <code>FALSE</code> (default) means none of the zeros for <code>names</code> in the <code>model</code> will be kept; The times of
the reference process (i.e., first of <code>names</code> in alphabetical order) will be set to <code>NA</code> (i.e., will be estimated) and the others
will be set to the name of the reference process (i.e., will be set to equal the reference process times). <code>TRUE</code> means
the zero(s) of the reference process times (if specified) is used for the same outcome of all other processes. 
</p>
</li>
<li><p> numeric value: index for <code>names</code>. If 1, the zero(s) of the first process in <code>names</code> (in original order defined by the user) is 
used for the same outcome of all other processes in <code>names</code>. If 2, the zero(s) of the second process is used. And so on.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code>.
</p>


<h3>Note</h3>

<p>If you use <code>theta2theta()</code> and <code>tau2tau()</code> with the same process names you might just change the EQN or MDL file accordingly
by using the same process name for all processes which should have equal process times and probabilities.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code> and <code><a href="#topic+theta2theta">theta2theta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process completion times for both detection processes ("do" and "dn") will be
# set equal.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## make do = dn
new_model &lt;- tau2tau(model = model, names = c("do", "dn"), outcome = "both")
new_model


## make do = dn
new_model &lt;- set_taus_equal(model = model, names = c("do", "dn"), outcome = "both")
new_model
</code></pre>

<hr>
<h2 id='tau2zero'>Set process completion times to zero</h2><span id='topic+tau2zero'></span><span id='topic+set_tau_zero'></span>

<h3>Description</h3>

<p>Setting process completion times (taus) to zero or change it back to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau2zero(model, names, outcomes, values = 0)

set_tau_zero(model, names, outcomes, values = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau2zero_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="tau2zero_+3A_names">names</code></td>
<td>
<p>Character vector with process names.</p>
</td></tr>
<tr><td><code id="tau2zero_+3A_outcomes">outcomes</code></td>
<td>
<p>Character vector of length <code>length(names)</code> indicating for which process outcome the process completion time should 
be zero or changed back to be estimated. Allowed characters are:
</p>

<ul>
<li> <p><code>"minus"</code>: the negative outcome of the process.
</p>
</li>
<li> <p><code>"plus"</code>: the positive outcome of the process.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tau2zero_+3A_values">values</code></td>
<td>
<p>Numerical vector of length one or <code>length(names)</code>. You have the following options for the elements of the numeric vector:
</p>

<ul>
<li> <p><code>0</code>: suppress the process time/rate, i.e., set the process completion time (tau) with the specified output to zero.
</p>
</li>
<li> <p><code>NA</code>: estimate the process time (tau)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+theta2theta">theta2theta</a></code> and <code><a href="#topic+tau2tau">tau2tau</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process completion times for both failed detections will be suppressed.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## removing the process times (tau) for the failed (="minus") detection ("do" and "dn") 
new_model &lt;- tau2zero(model = model, names = c("dn", "do"),
                      outcomes = c("minus", "minus"), values = 0)
new_model


## removing the process times (tau) for the failed (="minus") detection ("do" and "dn") 
new_model &lt;- set_tau_zero(model = model, names = c("dn", "do"),
                          outcomes = c("minus", "minus"), values = 0)
new_model
</code></pre>

<hr>
<h2 id='theta2const'>Set process probabilities to constants</h2><span id='topic+theta2const'></span><span id='topic+set_theta_const'></span>

<h3>Description</h3>

<p>Setting process probabilities (thetas) to constants or change it back to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2const(model, names, constants = NA)

set_theta_const(model, names, constants = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta2const_+3A_model">model</code></td>
<td>
<p>An object of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="theta2const_+3A_names">names</code></td>
<td>
<p>Character vector with process names.</p>
</td></tr>
<tr><td><code id="theta2const_+3A_constants">constants</code></td>
<td>
<p>Numerical vector of length one or <code>length(names)</code>. You have the following options for the elements of the numeric vector:
</p>

<ul>
<li> <p><code>0 &lt; constants &lt; 1</code>: set the named probability to a constant value between zero and one
</p>
</li>
<li> <p><code>NA</code>: estimate the named probability
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>ertmpt_model</code>.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code>, <code><a href="#topic+theta2theta">theta2theta</a></code> and <code><a href="#topic+tau2tau">tau2tau</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process probability for guessing (g) will be set to 0.5.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## setting g to a constant (0.5):
new_model &lt;- theta2const(model = model, names = c("g"), constants = c(0.5))
new_model
                    

## setting g to a constant (0.5):
new_model &lt;- set_theta_const(model = model, names = c("g"), constants = c(0.5))
new_model
</code></pre>

<hr>
<h2 id='theta2theta'>Set process probabilities equal</h2><span id='topic+theta2theta'></span><span id='topic+set_thetas_equal'></span>

<h3>Description</h3>

<p>Setting multiple process probabilities (thetas) equal. One of the process probabilities will be estimated and
the other named process(es) will be set to equal the former. The equality can be removed by only using one name of a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2theta(model, names, keep_consts = FALSE)

set_thetas_equal(model, names, keep_consts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta2theta_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
<tr><td><code id="theta2theta_+3A_names">names</code></td>
<td>
<p>Character vector giving the names of the processes for which the process probabilities should be equal. If 
<code>length(names) = 1</code> then the corresponding process probability will be estimates (i.e., it will be set to NA)</p>
</td></tr>
<tr><td><code id="theta2theta_+3A_keep_consts">keep_consts</code></td>
<td>
<p>Can be one of the following
</p>

<ul>
<li><p> logical value: <code>FALSE</code> (default) means none of the constants for <code>names</code> in the <code>model</code> will be kept; The probability of
the reference process (i.e., first of <code>names</code> in alphabetical order) will be set to <code>NA</code> (i.e., will be estimated) and the others
will be set to the name of the reference process (i.e., will be set to equal the reference process probability). <code>TRUE</code> means
the constant of the reference process probability (if specified) is used for all other processes. 
</p>
</li>
<li><p> numeric value: index for <code>names</code>. If 1, the constant of the first process in <code>names</code> (in original order defined by the user) is 
used for all other probabilities of the processes in <code>names</code>. If 2, the constant of the second process is used. And so on.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code>.
</p>


<h3>Note</h3>

<p>If you use <code>theta2theta()</code> and <code>tau2tau()</code> with the same process names you might just change the EQN or MDL file accordingly
by using the same process name for all processes which should have equal process times and probabilities.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code> and <code><a href="#topic+tau2tau">tau2tau</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each category.
# The process probabilities for both detection processes ("do" and "dn") will be
# set equal.
####################################################################################

mdl_2HTM &lt;- "
# targets
do+(1-do)*g
(1-do)*(1-g)

# lures
(1-dn)*g
dn+(1-dn)*(1-g)

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)

## make do = dn
new_model &lt;- theta2theta(model = model, names = c("do", "dn"))
new_model


## make do = dn
new_model &lt;- set_thetas_equal(model = model, names = c("do", "dn"))
new_model
</code></pre>

<hr>
<h2 id='to_drtmpt_data'>Transform data to be used in Diffusion RT-MPT model fitting</h2><span id='topic+to_drtmpt_data'></span>

<h3>Description</h3>

<p>Transform data, such that it can be used in <code><a href="#topic+fit_drtmpt">fit_drtmpt</a></code>. This implies changing each value/label in
&quot;subj&quot;, &quot;group&quot;, &quot;tree&quot;, and &quot;cat&quot; to numbers such that it starts from zero (e.g. data$tree = c(1,1,3,3,2,2,...)
will be changed to data$tree = c(0,0,2,2,1,1,...)) and the columns will be ordered in the right way.
&quot;rt&quot; must be provided in milliseconds. If it has decimal places it will be rounded to a whole number.
<code><a href="#topic+fit_drtmpt">fit_drtmpt</a></code> will automatically call this function if its input is not already a <code>drtmpt_data</code> list,
but it is advised to use it anyway because it provides information about the transformations of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_drtmpt_data(raw_data, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_drtmpt_data_+3A_raw_data">raw_data</code></td>
<td>
<p><code>data.frame</code> or path to data containing columns &quot;subj&quot;, &quot;group&quot;, &quot;tree&quot;, &quot;cat&quot;, and &quot;rt&quot;.
If not provided in this order it will be reordered and unused variables will be moved to the end of the
new data frame.</p>
</td></tr>
<tr><td><code id="to_drtmpt_data_+3A_model">model</code></td>
<td>
<p>A list of the class <code>drtmpt_model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_data</code> containing transformed data and information about
the transformation that has been done.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each response.
####################################################################################

eqn_2HTM &lt;- "
# CORE MPT EQN
# tree ; cat  ; mpt
target ; hit  ; do
target ; hit  ; (1-do)*g
target ; miss ; (1-do)*(1-g)

  lure ;  f_a ; (1-dn)*g
  lure ;  c_r ; dn
  lure ;  c_r ; (1-dn)*(1-g)
"

model &lt;- to_drtmpt_model(eqn_file = eqn_2HTM)

data_file &lt;- system.file("extdata/labeled_data.txt", package="rtmpt")
data &lt;- read.table(file = data_file, header = TRUE)

data_list &lt;- to_drtmpt_data(raw_data = data, model = model)
data_list

</code></pre>

<hr>
<h2 id='to_drtmpt_model'>Create a model list to fit a Diffusion-RT-MPT</h2><span id='topic+to_drtmpt_model'></span>

<h3>Description</h3>

<p>Create a model list of the class <code>drtmpt_model</code> by providing either <code>eqn_file</code> or <code>mdl_file</code>.
If both are provided <code>mdl_file</code> will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_drtmpt_model(eqn_file = NULL, mdl_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_drtmpt_model_+3A_eqn_file">eqn_file</code></td>
<td>
<p>Character string as shown in example 2 or path to the text file that specifies the Diffusion
(RT-)MPT model with standard .eqn syntax (Heck et al., 2018; Hu, 1999). E.g. <code>studied ; hit ; (1-do)*g</code> for a correct guess
in the detect-guess 2HT model.</p>
</td></tr>
<tr><td><code id="to_drtmpt_model_+3A_mdl_file">mdl_file</code></td>
<td>
<p>Character string as shown in example 1 or path to the text file that specifies the Diffusion
(RT-)MPT model and gives on each line the equation of one category using <code>+</code> to separate branches
and <code>*</code> to separate processes (Singmann and Kellen, 2013). E.g. <code>do+(1-do)*g</code> for the category &quot;hit&quot; in the detect-guess
2HT model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>drtmpt_model</code>.
</p>


<h3>Note</h3>

<p>Within a branch of a (RT-)MPT model it is not allowed to have the same process two or more times.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Heck, D. W., Arnold, N. R., &amp; Arnold, D. (2018). TreeBUGS: An R package for hierarchical
multinomial-processing-tree modeling. <em>Behavior Research Methods, 50(1)</em>, 264-284.
</p>
<p>Hu, X. (1999). Multinomial processing tree models: An implementation.
<em>Behavior Research Methods, Instruments, &amp; Computers, 31(4)</em>, 689-695.
</p>
<p>Singmann, H., &amp; Kellen, D. (2013). MPTinR: Analysis of multinomial processing tree models in R.
<em>Behavior Research Methods, 45(2)</em>, 560-575.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code>, <code><a href="#topic+theta2theta">theta2theta</a></code>, and <code><a href="#topic+tau2tau">tau2tau</a></code> for
functions to change the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################################
# Detect-Guess variant of the Two-High Threshold model
#   with constant guessing and
#   suppressed process completion times for both failed detections.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

## 1. using the mdl syntax
mdl_2HTM &lt;- "
# targets
do+(1-do)*g     ; 0
(1-do)*(1-g)    ; 1

# lures
(1-dn)*g        ; 0
dn+(1-dn)*(1-g) ; 1

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_drtmpt_model(mdl_file = mdl_2HTM)
model

## 2. using the eqn syntax
eqn_2HTM &lt;- "
# CORE MPT EQN
# tree ; cat ; mpt
     0 ;   0 ; do
     0 ;   0 ; (1-do)*g
     0 ;   1 ; (1-do)*(1-g)

     1 ;   2 ; (1-dn)*g
     1 ;   3 ; dn
     1 ;   3 ; (1-dn)*(1-g)

# OPTIONAL MPT CONSTRAINTS
#     tree ; cat ;  MAP
resp:    0 ;   0 ;    0
resp:    0 ;   1 ;    1
resp:    1 ;   2 ;    0
resp:    1 ;   3 ;    1
# different motor execution times for old and new responses.
"

model &lt;- to_drtmpt_model(eqn_file = eqn_2HTM)
model

</code></pre>

<hr>
<h2 id='to_ertmpt_data'>Transform data to be used in RT-MPT model fitting</h2><span id='topic+to_ertmpt_data'></span><span id='topic+to_rtmpt_data'></span>

<h3>Description</h3>

<p>Transform data, such that it can be used in <code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code>. This implies changing each value/label in
&quot;subj&quot;, &quot;group&quot;, &quot;tree&quot;, and &quot;cat&quot; to numbers such that it starts from zero (e.g. data$tree = c(1,1,3,3,2,2,...)
will be changed to data$tree = c(0,0,2,2,1,1,...)) and the columns will be ordered in the right way.
&quot;rt&quot; must be provided in milliseconds. If it has decimal places it will be rounded to a whole number.
<code><a href="#topic+fit_ertmpt">fit_ertmpt</a></code> will automatically call this function if its input is not already an <code>ertmpt_data</code> list, 
but it is advised to use it anyway because it provides information about the transformations of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_ertmpt_data(raw_data, model)

to_rtmpt_data(raw_data, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_ertmpt_data_+3A_raw_data">raw_data</code></td>
<td>
<p><code>data.frame</code> or path to data containing columns &quot;subj&quot;, &quot;group&quot;, &quot;tree&quot;, &quot;cat&quot;, and &quot;rt&quot;. 
If not provided in this order it will be reordered and unused variables will be moved to the end of the
new data frame.</p>
</td></tr>
<tr><td><code id="to_ertmpt_data_+3A_model">model</code></td>
<td>
<p>A list of the class <code>ertmpt_model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_data</code> containing transformed data and information about 
the transformation that has been done.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################################################################
# Detect-Guess variant of the Two-High Threshold model.
# The encoding and motor execution times are assumed to be equal for each response.
####################################################################################

eqn_2HTM &lt;- "
# CORE MPT EQN
# tree ; cat  ; mpt
target ; hit  ; do
target ; hit  ; (1-do)*g
target ; miss ; (1-do)*(1-g)
       
  lure ;  f_a ; (1-dn)*g
  lure ;  c_r ; dn
  lure ;  c_r ; (1-dn)*(1-g)
"

model &lt;- to_ertmpt_model(eqn_file = eqn_2HTM)

data_file &lt;- system.file("extdata/labeled_data.txt", package="rtmpt")
data &lt;- read.table(file = data_file, header = TRUE)

data_list &lt;- to_ertmpt_data(raw_data = data, model = model)
data_list 


eqn_2HTM &lt;- "
# CORE MPT EQN
# tree ; cat  ; mpt
target ; hit  ; do
target ; hit  ; (1-do)*g
target ; miss ; (1-do)*(1-g)
       
  lure ;  f_a ; (1-dn)*g
  lure ;  c_r ; dn
  lure ;  c_r ; (1-dn)*(1-g)
"

model &lt;- to_rtmpt_model(eqn_file = eqn_2HTM)

data_file &lt;- system.file("extdata/labeled_data.txt", package="rtmpt")
data &lt;- read.table(file = data_file, header = TRUE)

data_list &lt;- to_rtmpt_data(raw_data = data, model = model)
data_list 

</code></pre>

<hr>
<h2 id='to_ertmpt_model'>Create a model list to fit an RT-MPT</h2><span id='topic+to_ertmpt_model'></span><span id='topic+to_rtmpt_model'></span>

<h3>Description</h3>

<p>Create a model list of the class <code>ertmpt_model</code> by providing either <code>eqn_file</code> or <code>mdl_file</code>.
If both are provided <code>mdl_file</code> will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_ertmpt_model(eqn_file = NULL, mdl_file = NULL)

to_rtmpt_model(eqn_file = NULL, mdl_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_ertmpt_model_+3A_eqn_file">eqn_file</code></td>
<td>
<p>Character string as shown in example 2 or path to the text file that specifies the 
(RT-)MPT model with standard .eqn syntax (Heck et al., 2018; Hu, 1999). E.g. <code>studied ; hit ; (1-do)*g</code> for a correct guess 
in the detect-guess 2HT model.</p>
</td></tr>
<tr><td><code id="to_ertmpt_model_+3A_mdl_file">mdl_file</code></td>
<td>
<p>Character string as shown in example 1 or path to the text file that specifies the 
(RT-)MPT model and gives on each line the equation of one category using <code>+</code> to separate branches 
and <code>*</code> to separate processes (Singmann and Kellen, 2013). E.g. <code>do+(1-do)*g</code> for the category &quot;hit&quot; in the detect-guess 
2HT model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>ertmpt_model</code>.
</p>


<h3>Note</h3>

<p>Within a branch of a (RT-)MPT model it is not allowed to have the same process two or more times.
</p>


<h3>Author(s)</h3>

<p>Raphael Hartmann
</p>


<h3>References</h3>

<p>Heck, D. W., Arnold, N. R., &amp; Arnold, D. (2018). TreeBUGS: An R package for hierarchical 
multinomial-processing-tree modeling. <em>Behavior Research Methods, 50(1)</em>, 264-284.
</p>
<p>Hu, X. (1999). Multinomial processing tree models: An implementation. 
<em>Behavior Research Methods, Instruments, &amp; Computers, 31(4)</em>, 689-695.
</p>
<p>Singmann, H., &amp; Kellen, D. (2013). MPTinR: Analysis of multinomial processing tree models in R. 
<em>Behavior Research Methods, 45(2)</em>, 560-575.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta2delta">delta2delta</a></code>, <code><a href="#topic+theta2const">theta2const</a></code>, <code><a href="#topic+tau2zero">tau2zero</a></code>, <code><a href="#topic+theta2theta">theta2theta</a></code>, and <code><a href="#topic+tau2tau">tau2tau</a></code> for 
functions to change the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################################
# Detect-Guess variant of the Two-High Threshold model
#   with constant guessing and
#   suppressed process completion times for both failed detections.
# The encoding and motor execution times are assumed to be different for each response.
########################################################################################

## 1. using the mdl syntax
mdl_2HTM &lt;- "
# targets
do+(1-do)*g     ; 0
(1-do)*(1-g)    ; 1

# lures
(1-dn)*g        ; 0
dn+(1-dn)*(1-g) ; 1

# do: detect old; dn: detect new; g: guess

# OPTIONAL MPT CONSTRAINTS
# for constant thetas and suppressed taus
# please use theta2cons() and tau2
"

model &lt;- to_ertmpt_model(mdl_file = mdl_2HTM)
model

## 2. using the eqn syntax
eqn_2HTM &lt;- "
# CORE MPT EQN
# tree ; cat ; mpt
     0 ;   0 ; do
     0 ;   0 ; (1-do)*g
     0 ;   1 ; (1-do)*(1-g)
       
     1 ;   2 ; (1-dn)*g
     1 ;   3 ; dn
     1 ;   3 ; (1-dn)*(1-g)

# OPTIONAL MPT CONSTRAINTS
# for constant thetas and suppressed taus
# please use theta2cons() and tau2

#     tree ; cat ;  MAP
resp:    0 ;   0 ;    0
resp:    0 ;   1 ;    1
resp:    1 ;   2 ;    0
resp:    1 ;   3 ;    1
# different motor execution times for old and new responses.
"

model &lt;- to_ertmpt_model(eqn_file = eqn_2HTM)
model


mdl_2HTM &lt;- "
# targets
do+(1-do)*g     ; 0
(1-do)*(1-g)    ; 1

# lures
(1-dn)*g        ; 0
dn+(1-dn)*(1-g) ; 1

# do: detect old; dn: detect new; g: guess
"

model &lt;- to_rtmpt_model(mdl_file = mdl_2HTM)
model

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
