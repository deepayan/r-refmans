<!DOCTYPE html><html><head><title>Help for package networkDynamic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {networkDynamic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activate'><p> Dynamic Activation and Inactivation of Edges and Vertices</p></a></li>
<li><a href='#activity.attribute'><p> Activity Attributes for Dynamically Extended Networks</p></a></li>
<li><a href='#add.methods'>
<p>PID-aware versions of functions for adding edges and vertices to networkDynamic objects</p></a></li>
<li><a href='#add.vertices.active'>
<p>add.verticies.active, add.edges.active</p></a></li>
<li><a href='#adjust.activity'>
<p>Adjust the activity ranges in all of the spells of a networkDynamic object</p></a></li>
<li><a href='#age.at'>
<p>Age of active edges or vertices at a query time point</p></a></li>
<li><a href='#as.data.frame.networkDynamic'>
<p>Extracts the edge timing information from a networkDynamic object and represent as a data.frame.</p></a></li>
<li><a href='#as.network.networkDynamic'>
<p>Remove &lsquo;networkDynamic&rsquo; class name from networkDynamic object.</p></a></li>
<li><a href='#as.networkDynamic'>
<p>as.networkDynamic</p></a></li>
<li><a href='#attribute.activity.functions'>
<p>Functions to activate and query dynamic attributes on vertices, edges, and networks</p></a></li>
<li><a href='#cls33_10_16_96'>
<p>Daniel McFarland's Streaming Classroom Interactions Dataset</p></a></li>
<li><a href='#delete.activity'><p> Remove Timing Information in a Dynamically Extended Network Object</p></a></li>
<li><a href='#duration.matrix'><p> Construct a edge spells list from base network and toggle list.</p></a></li>
<li><a href='#get.dyads.active'>
<p>Return the set of vertex ids of edges active at a given time</p></a></li>
<li><a href='#get.networks'><p>Obtain a list of collapsed networks sampled periodically from a networkDynamic object</p></a></li>
<li><a href='#get.timing.info'><p> Retrieve the timing information present in a networkDynamic.</p></a></li>
<li><a href='#is.active'><p> Determine Activation State of Edges and Vertices</p></a></li>
<li><a href='#nd_test_nets'>
<p>networkDynamic testing networks</p></a></li>
<li><a href='#net.obs.period'>
<p>Network attribute describing the observation properties of a networkDynamic object</p></a></li>
<li><a href='#network.collapse'>
<p>Convert a time range of a networkDynamic object into a static network object.</p></a></li>
<li><a href='#network.dynamic.check'><p> Verify a Dynamically Extended Network Object</p></a></li>
<li><a href='#network.extensions'><p> Dynamically Extended Core Network Functions</p></a></li>
<li><a href='#network.extract'><p> Temporal Extracts/Cross-sections of Dynamically Extended Network Objects</p></a></li>
<li><a href='#networkDynamic'>
<p>Convert various forms of network timing information into networkDynamic objects.</p></a></li>
<li><a href='#networkDynamic-internal'><p>Internal networkDynamic objects</p></a></li>
<li><a href='#networkDynamic-package'>
<p>Dynamic Extensions for Network Objects</p></a></li>
<li><a href='#Newcomb'><p>Newcomb's Fraternity Networks</p></a></li>
<li><a href='#persistent.ids'>
<p>Use and manipulate persistent ids of network elements</p></a></li>
<li><a href='#print.networkDynamic'>
<p>Provide a view of a networkDynamic object including timing information</p></a></li>
<li><a href='#read.son'>
<p>Read .son-formatted (SoNIA) input files containing longitudinal network data and  create a corresponding networkDynamic object</p></a></li>
<li><a href='#reconcile.activity'>
<p>Modify the activity spells of vertices to match incident edges or the other way around</p></a></li>
<li><a href='#spells.overlap'>
<p>Functions to compare and search spell intervals</p></a></li>
<li><a href='#when.vertex.attrs.match'>
<p>return the times at which the TEA attributes of elements of a network match a value</p></a></li>
<li><a href='#windsurfers'>
<p>Lin Freeman's Dynamic Network of Windsurfer Social Interactions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.11.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-10?</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Extensions for Network Objects</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), network (&ge; 1.17.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common, methods, networkLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>network</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple interface routines to facilitate the handling of network objects with complex intertemporal data. This is a part of the "statnet" suite of packages for network analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org/">https://statnet.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 09:48:24 UTC; skyebend</td>
</tr>
<tr>
<td>Author:</td>
<td>Carter T. Butts [aut],
  Ayn Leslie-Cook [aut],
  Pavel N. Krivitsky [aut],
  Skye Bender-deMoll [aut, cre],
  Zack Almquist [ctb],
  David R. Hunter [ctb],
  Li Wang [ctb],
  Kirk Li [ctb],
  Steven M. Goodreau [ctb],
  Jeffrey Horner [ctb],
  Martina Morris [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Skye Bender-deMoll &lt;skyebend@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='activate'> Dynamic Activation and Inactivation of Edges and Vertices </h2><span id='topic+activate'></span><span id='topic+activate.edges'></span><span id='topic+activate.vertices'></span><span id='topic+deactivate.edges'></span><span id='topic+deactivate.vertices'></span>

<h3>Description</h3>

<p><code>activate</code> and <code>deactivate</code> set spells of activity and inactivity respectively for elements (edges and vertices) in a dynamic network.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate.edges(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    e = seq_along(x$mel))
activate.vertices(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    v = seq_len(network.size(x)))

deactivate.edges(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    e = seq_along(x$mel))
deactivate.vertices(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    v = seq_len(network.size(x)), deactivate.edges = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activate_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="network.html#topic+network">network</a></code>. </p>
</td></tr>
<tr><td><code id="activate_+3A_onset">onset</code></td>
<td>
<p> an optional vector of timepoints that specifies the starts of the interval(s). This must be accompanied by one of <code>terminus</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="activate_+3A_terminus">terminus</code></td>
<td>
<p> an optional vector of timepoints that specifies the ends of the interval(s). This must be accompanied by one of <code>onset</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="activate_+3A_length">length</code></td>
<td>
<p> an optional vector of interval lengths for the interval(s). This must be accompanied by one of <code>onset</code> or <code>terminus</code>. </p>
</td></tr>
<tr><td><code id="activate_+3A_at">at</code></td>
<td>
<p> optional, one or more time points to be activated. </p>
</td></tr>
<tr><td><code id="activate_+3A_e">e</code></td>
<td>
<p> optional, one or more IDs indicating edges to be modified. Ids can be repeated to indicate multiple time values per element.</p>
</td></tr>
<tr><td><code id="activate_+3A_v">v</code></td>
<td>
<p> optional, one or more IDs indicating vertices to be modified. Ids can be repeated to indicate multiple time values per element.</p>
</td></tr>
<tr><td><code id="activate_+3A_deactivate.edges">deactivate.edges</code></td>
<td>
<p>optional, TRUE setting will automatically deactivate all the edges associated with the vertex being deactivated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An element in a dynamically extended network class is considered to be either &ldquo;active&rdquo; or &ldquo;inactive&rdquo; at any point in time, with the substantive meaning of &ldquo;activity&rdquo; determined by the specific application context.  The <code>activate</code> and <code>deactivate</code> functions provide an interface for controlling the state of the elements in a dynamic network.
</p>
<p><code>activate.edges</code> and <code>activate.vertices</code> have identical behavior, except for the elements they modify (the same is true for the <code>deactivate.*</code> functions).  
</p>
<p>There are several ways to specify the activity spell, and the general syntax rules are described at <code><a href="#topic+activity.attribute">activity.attribute</a></code>.  Activity can be set for a single time point, using either <code>at</code>, or by setting onset=terminus.  Activity can be set for an interval [onset,terminus), using a valid combination of the <code>onset</code>, <code>terminus</code> and <code>length</code> attributes.
</p>
<p>This allows for a wide range of options when specifying spells, but a correct specification must use only one of these forms:
</p>
<pre>
  at
  onset and terminus 
  onset and length
  terminus and length
  or, you can provide no timing information 
</pre>
<p>If provided with no timing information, the element is activated/deactivated from <code>-Inf</code> to <code>Inf</code>.   
The specified interval spans the period from the onset (inclusive) to the terminus (exclusive), so [onset,terminus).
</p>
<p>There are some special behaviors associated with the arguments  <code>Inf</code> and <code>-Inf</code>.
</p>

<ul>
<li><p> The open-ended interval <code>c(-Inf,x)</code> includes <code>-Inf</code>.  For consistency, we also allow the open-ended interval <code>c(x, Inf)</code> to include <code>Inf</code>. 
Thus [onset, terminus) will be interpreted as [onset, terminus] when terminus = <code>Inf</code>.
</p>
</li>
<li><p> The arguments  <code>Inf</code> or <code>-Inf</code> are only valid when used to specify an interval, they can not be used 
to specify status at a time point using  <code>at</code>.   In addition, they cannot be paired with themselves in a call.
That is, both <code>(Inf,Inf)</code> and <code>(-Inf,-Inf)</code> are not valid specifications for any spell.
</p>
</li>
<li><p> Both <code>deactivate.*(x)</code> and <code>deactivate.*(x, -Inf, Inf)</code> create the null spell &ndash; specifying inactivity over the entire time span. Note that
by convention the null spell is stored as <code>(Inf,Inf)</code>.
</p>
</li></ul>

<p>Calling the activation/deactivation functions with a vector of spell modifiers and a vector of elements to be modified
(for example, <code>at=c(1,3,5 7), v=c(1:4)</code>) allows multiple elements in the network 
to be activated/deactivated simultaneously (note, not multiple spells for a single element).  
The spell modifiers are applied sequentially to the selected elements.   
If the length of the spell vector is less than the number of elements, 
the spell modifiers are recycled as needed.  
When multiple network elements are activated in a single call, the spell modifiers must all be of one type, 
either <code>at</code>, or a valid mix of <code>onset</code>, <code>terminus</code> and <code>length</code>.
</p>
<p>The <code>activate.*</code> and <code>deactivate.*</code> functions in general modify spells in similar, if opposite, ways.  
However, there are some behaviors that are specific to each function.
</p>
 
<ul>
<li><p> Effects on an element that has no existing activity attributes.
</p>

<ul>
<li><p> For activate: the element is marked as being inactive before the onset time, then active for the specified spell, then inactive from the terminus on.  
</p>
</li>
<li><p> For deactivate: the element is marked as being active before the onset time, then inactive for the specified spell, then active from the terminus on (i.e., the opposite of <code>activate.*</code>.
</p>
</li></ul>

</li>
<li><p> Effects of the <code>at</code>  specification.
</p>

<ul>
<li><p> For activate: the element is activated at that time point.  
</p>
</li>
<li><p> For deactivate: the element is deactivated at the  time point, but only if the time point is currently activated as a 0-length spell.
</p>
</li></ul>

</li></ul>

<p>Currently, there is no support for activating multiple spells for a single element
in a single call. To activate 2 spells for a node,  for example, one must call
activate.vertices twice.  It is advisable to remove duplicate edges or
vertices from the <code>e</code> or <code>v</code> input vectors.
</p>
<p>Edge/vertex activity is tracked through an attribute called (eponymously) &ldquo;active&rdquo;, and which is explained in more detail under <a href="#topic+activity.attribute">activity.attribute</a>.  This may be modified or otherwise accessed using standard class methods (e.g., <code><a href="network.html#topic+attribute.methods">get.edge.attribute</a></code>), as well as the specialized methods described here.
</p>


<h3>Value</h3>

<p>None.  (But all four commands modify their arguments as a side-effect.)
</p>


<h3>Note</h3>

<p> This function may not be entirely stable in the long run, since it makes explicit reference to internal elements of the network object; some syntactic changes could occur in the future. </p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a></p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>See Also</h3>

 <p><code><a href="#topic+is.active">is.active</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle &lt;- network.initialize(3)  # create a toy network
add.edge(triangle,1,2)    # add an edge between vertices 1 and 2
add.edge(triangle,2,3)    # add more edges
add.edge(triangle,3,1)

# turn on all edges at time 1 only (0 length spell)
activate.edges(triangle,at=1) 

# activate edge (1,2) from t=2 to t=3
activate.edges(triangle,onset=2, terminus=3,
               e=get.edgeIDs(triangle,v=1,alter=2))
               
# activate edge (2,3) from t=4 for 2 time lengths
activate.edges(triangle,onset=4, length=2, 
               e=get.edgeIDs(triangle,v=2,alter=3))
               
deactivate.edges(triangle, at=2, e=1) # does not work since the spell is not 0-length
is.active(triangle, at=2, e=1:3)

deactivate.edges(triangle, e=1, onset=2, length=0.1)  # this deactivates the vertex
is.active(triangle, at=2, e=1:3)  

# this activates edges 2 and 3 at time 5
activate.edges(triangle, e=2:3, at=5)

# this activates edge 1 at multiple times;
deactivate.edges(triangle)
activate.edges(triangle, e=c(1,1,1), at=6:8)
is.active(triangle, at=6, e=1:3)
is.active(triangle, at=7, e=1:3)
is.active(triangle, at=8, e=1:3)

# this activates vertex 1 for two spells, (0,1) and (3,4)
test &lt;- network.initialize(3)
activate.vertices(test,onset=0:3,terminus=1:4,v=c(1,2,3,1))
get.vertex.activity(test, as.spellList=TRUE)


</code></pre>

<hr>
<h2 id='activity.attribute'> Activity Attributes for Dynamically Extended Networks </h2><span id='topic+activity.attribute'></span>

<h3>Description</h3>

<p>Dynamically extended networks are <code>networkDynamic</code> class objects (extensions of <a href="network.html#topic+network">network</a> objects) whose vertex and edge elements include timing information. This page describes the types of timing information currently available, and the general syntax for setting or querying this information.
</p>


<h3>Details</h3>

<p>Currently, each edge and vertex in a dynamically extended network is presumed to be in one of two states at any given point in time:  (&ldquo;active&rdquo; or &ldquo;inactive&rdquo;).  The state of a network element (i.e., edge or vertex) is governed by an attribute with the name &ldquo;active&rdquo;, which is considered a reserved term for purposes of this package.
</p>
<p>The activity attribute consists of a two-column numeric matrix.  Each
row contains an activity spell, and the two columns 
encode onset and terminus times respectively. Elements are presumed
inactive until the onset of their first activity spell, and are
likewise presumed inactive after the termination of their last active spell.
</p>
<p>Spells are taken to span the period from the onset
(inclusive) to the terminus (exclusive), so [onset,terminus). 
They must be consecutive, ordered forward in time, and strictly
non-overlapping.  
</p>
<p>The syntax for defining or querying spells can specify either an instantaneous time point or an interval.  The commands for this include <code>at=</code>,  <code>onset=</code>, <code>terminus=</code> and <code>length=</code>.  Any numeric values may be used in the interval specifications, including  <code>Inf</code> and <code>-Inf</code>, (with some restrictions, see below).  A spell with <code>onset=-Inf</code> represents onset censoring. A spell with <code>terminus=Inf</code> represents terminus censoring. <code>Inf</code> and <code>-Inf</code> cannot be used with the <code>at</code> specification. Similarly, <code>onset</code> can not be <code>Inf</code> and <code>terminus</code> can not be <code>-Inf</code>.
</p>
<p>The general syntax rules for specifying spells are as follows:
</p>
<p>To specify a spell as a single time point:
</p>

<ul>
<li><p> use the <code>at</code> argument, or
</p>
</li>
<li><p> use <code>onset=terminus</code>. 
</p>
</li></ul>

<p>To specify a spell as a particular interval, one of the following combinations of <code>onset</code>, <code>terminus</code> and <code>length</code> is required:
</p>

<ul>
<li> <p><code>onset</code> and <code>terminus</code> 
</p>
</li>
<li> <p><code>onset</code> and <code>length</code> 
</p>
</li>
<li> <p><code>terminus</code> and <code>length</code>  
</p>
</li></ul>

<p>The special &ldquo;null&rdquo; spell is used to designate elements that are never active (i.e., have no valid activity spells).  These can only be set by the <code>deactivate</code> function (see <code><a href="#topic+activity.attribute">activity.attribute</a></code>) and by convention are stored as <code>c(Inf,Inf)</code>.  &ldquo;Null&rdquo; spells are incompatible with other spells, and should be replaced whenever an activation enters the element's event history.
</p>
<p>Although it is possible to access and modify the activity spells using <a href="network.html#topic+network">network</a> attribute methods (e.g., <code><a href="network.html#topic+attribute.methods">get.edge.attribute</a></code>)  it is not recommended, and extreme care should be taken to preserve the structure of the spell matrix. The preferred way to modify the spells of a network element is with the <code><a href="#topic+activate">activate</a></code> related methods. Vertices and edges with specific activity ranges can be selected using <code><a href="#topic+network.extensions">network.extensions</a></code>.
</p>
<p>In addition, a number of special functions are also provided to simplify common tasks related to the <code>active</code> attribute (noted below). 
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+is.active">is.active</a></code>, <code><a href="#topic+activate">activate</a></code>, <code><a href="#topic+activate.vertices">activate.vertices</a></code>,<code><a href="#topic+activate.edges">activate.edges</a></code>, <code><a href="#topic+deactivate.vertices">deactivate.vertices</a></code>,<code><a href="#topic+deactivate.edges">deactivate.edges</a></code>,<code><a href="#topic+network.extensions">network.extensions</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle &lt;- network.initialize(3)  # create a toy network

activate.vertices(triangle,onset=1,terminus=5,v=1) 
activate.vertices(triangle,onset=1,terminus=10,v=2)
activate.vertices(triangle,onset=4,terminus=10,v=3)
deactivate.vertices(triangle,onset=2, length=2, v=1)

get.vertex.activity(triangle) # vertex spells
</code></pre>

<hr>
<h2 id='add.methods'>
PID-aware versions of functions for adding edges and vertices to networkDynamic objects
</h2><span id='topic+add.edges.networkDynamic'></span><span id='topic+add.vertices.networkDynamic'></span><span id='topic+add.edge.networkDynamic'></span>

<h3>Description</h3>

<p>The methods (<code>add.vertices.networkDynamic</code>, <code>add.edge.networkDynamic</code>, <code>add.edges.networkDynamic</code>) override their network-package counterparts in order to permit assigning <a href="#topic+persistent.ids">persistent.ids</a> to newly-added elements if the pid is defined.  They can be defined by the user with the <code>vertex.pids</code> argument, or, if not specified, a unique random id will be generated. (Note that any new values added by default to a <code>vertex.names</code> pid will not be numeric.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkDynamic'
add.vertices(x, nv, vattr = NULL, last.mode = TRUE, 
    vertex.pid = NULL, ...)

## S3 method for class 'networkDynamic'
add.edges(x, tail, head, names.eval = NULL, vals.eval = NULL, 
    edge.pid = NULL, ...)
    
## S3 method for class 'networkDynamic'
add.edge(x, tail, head, names.eval = NULL, vals.eval = NULL, 
    edge.check = FALSE, edge.pid = NULL, ...)    
    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>network</code> or <code>networkDynamic</code> (see <code><a href="network.html#topic+add.vertices">add.vertices</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_nv">nv</code></td>
<td>
<p>number of vertices to be added. (see <code><a href="network.html#topic+add.vertices">add.vertices</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_vattr">vattr</code></td>
<td>
<p>optionally, a list of attributes with one entry per new vertex. (see <code><a href="network.html#topic+add.vertices">add.vertices</a></code> in network), not interpreted as a dynamic attribute</p>
</td></tr>
<tr><td><code id="add.methods_+3A_last.mode">last.mode</code></td>
<td>
<p>logical; should the new vertices be added to the last (rather than the first) mode of a bipartite network? (see <code><a href="network.html#topic+add.vertices">add.vertices</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_vertex.pid">vertex.pid</code></td>
<td>
<p>a vector of vertex.pids to be assigned to the newly-added vertices</p>
</td></tr>
<tr><td><code id="add.methods_+3A_edge.pid">edge.pid</code></td>
<td>
<p>a vector of edge.pids to be assigned to the newly-added edges</p>
</td></tr>
<tr><td><code id="add.methods_+3A_names.eval">names.eval</code></td>
<td>
<p>see <code><a href="network.html#topic+add.edges">add.edges</a></code> in network), not interpreted as a dynamic attribute</p>
</td></tr>
<tr><td><code id="add.methods_+3A_vals.eval">vals.eval</code></td>
<td>
<p>see <code><a href="network.html#topic+add.edges">add.edges</a></code> in network), not interpreted as a dynamic attribute</p>
</td></tr>
<tr><td><code id="add.methods_+3A_edge.check">edge.check</code></td>
<td>
<p>see <code><a href="network.html#topic+add.edges">add.edges</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_head">head</code></td>
<td>
<p>see <code><a href="network.html#topic+add.edges">add.edges</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_tail">tail</code></td>
<td>
<p>see <code><a href="network.html#topic+add.edges">add.edges</a></code> in network)</p>
</td></tr>
<tr><td><code id="add.methods_+3A_...">...</code></td>
<td>
<p>possible additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The networkDynamic versions of these methods call the network versions internally. See <a href="#topic+persistent.ids">persistent.ids</a> for additional details about the PID mechanism. 
</p>


<h3>Value</h3>


<ul>
<li><p><code>add.verticies</code> (invisibly) returns a reference to the network with the new vertices added. Pids will be added/created if a <code>vertex.pid</code> attribute is set.
</p>
</li>
<li><p><code>add.edge</code> and <code>add.edges</code> (invisibly) return a reference to the network with the new edges added. Pids will be added/created if a <code>vertex.pid</code> attribute is set.
</p>
</li></ul>



<h3>Note</h3>

<p>Adding edges via the extraction/replacement operators <code>[,]</code> bypasses the pid code and will break the edge pids defined for the network. Similarly, <code><a href="#topic+add.vertices.active">add.vertices.active</a></code> and <code><a href="#topic+add.edges.active">add.edges.active</a></code> do not yet support including pids. 
</p>


<h3>Author(s)</h3>

<p>lxwang, skyebend, the statnet team
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+persistent.ids">persistent.ids</a></code>, <code><a href="network.html#topic+add.vertices">add.vertices</a></code>, <code><a href="network.html#topic+add.edges">add.edge</a></code>, <code><a href="network.html#topic+add.edges">add.edges</a></code> in network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add vertices while using vertex.names as pids
nd &lt;- as.networkDynamic(network.initialize(3))
set.network.attribute(nd,"vertex.pid","vertex.names")
add.vertices(nd,nv=2,vertex.pid=c(4,5)) # specify pids for two new vertices
network.vertex.names(nd) # peek at pids

# add vertices and edges w/ auto-generated pids
nd &lt;- as.networkDynamic(network.initialize(3))
initialize.pids(nd)
get.vertex.attribute(nd,'vertex.pid') # peek at pids
add.vertices(nd,nv=2) # silently generate pids for vertices
get.vertex.attribute(nd,'vertex.pid') # peek at pids
add.edges(nd,1,2) # silently generate a pid for the edge
get.edge.attribute(nd,'edge.pid')

</code></pre>

<hr>
<h2 id='add.vertices.active'>
add.verticies.active, add.edges.active
</h2><span id='topic+add.vertices.active'></span><span id='topic+add.edges.active'></span>

<h3>Description</h3>

<p>Convenience functions for adding a set of verticies (or edges) and setting them to be active in a single call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'active'
add.vertices(x, nv, vattr = NULL, last.mode = TRUE,
            onset = NULL, terminus = NULL, length = NULL, at = NULL, ...)

## S3 method for class 'active'
add.edges(x, tail, head, names.eval = NULL, vals.eval = NULL, 
         onset = NULL, terminus = NULL, length = NULL, at = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.vertices.active_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="network.html#topic+network">network</a></code> or <code><a href="#topic+networkDynamic">networkDynamic</a></code>. </p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_nv">nv</code></td>
<td>
<p>the number of vertices to add</p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_tail">tail</code></td>
<td>
<p>a vector of vertex IDs corresponding to the tail (source, ego) of each edge to be added</p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_head">head</code></td>
<td>
<p>a vector of vertex IDs corresponding to the head (target, alter) of each edge to be added</p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_onset">onset</code></td>
<td>
<p> an optional vector of time points that specifies the starts of the interval(s). This must be accompanied by one of <code>terminus</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_terminus">terminus</code></td>
<td>
<p> an optional vector of time points that specifies the ends of the interval(s). This must be accompanied by one of <code>onset</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_length">length</code></td>
<td>
<p> an optional vector of interval lengths for the interval(s). This must be accompanied by one of <code>onset</code> or <code>terminus</code>. </p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_at">at</code></td>
<td>
<p> optional, one or more time points to be activated. </p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_names.eval">names.eval</code></td>
<td>
<p>optional list of length equal to the number of edges, with each element containing a list of names for the attributes of the corresponding edge. not currently interpreted in a dynamic context, but passed directly to <code><a href="network.html#topic+add.edges">add.edges</a></code></p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_vals.eval">vals.eval</code></td>
<td>
<p>an optional list of lists of edge attribute values (matching <code>names.eval</code>). Not currently interpreted in a dynamic context, but passed directly to <code><a href="network.html#topic+add.edges">add.edges</a></code></p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_vattr">vattr</code></td>
<td>
<p>optionally, a list of attributes with one entry per new vertex. not currently interpreted in a dynamic context, but passed directly to <code><a href="network.html#topic+add.vertices">add.vertices</a></code></p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_last.mode">last.mode</code></td>
<td>
<p>logical; should the new vertices be added to the last (rather than the first) mode of a bipartite network?</p>
</td></tr>
<tr><td><code id="add.vertices.active_+3A_...">...</code></td>
<td>
<p>possible future additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially a wrapper for a call to <code><a href="network.html#topic+add.vertices">add.vertices</a></code> and <code><a href="#topic+activate.vertices">activate.vertices</a></code>  or <code><a href="network.html#topic+add.edges">add.edges</a></code> and <code><a href="#topic+activate.edges">activate.edges</a></code> when setting up a network object. These are not the S3 methods that their name appears to imply, since there is no &quot;active&quot; class.  See <code><a href="#topic+add.edges.networkDynamic">add.edges.networkDynamic</a></code>, etc.
</p>


<h3>Value</h3>

<p>The passed in network object with class set to <code><a href="#topic+networkDynamic">networkDynamic</a></code> and the specified number of new vertices or edges added and activated
</p>


<h3>Note</h3>

<p>Order of arguments was changed in version 1.9 for S3 method consistency. Does not currently support the multiple-vertex head- and tail-sets of <code>add.edges</code> or <code>add.edge</code>.</p>


<h3>Author(s)</h3>

<p>Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a></p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+activate.vertices">activate.vertices</a></code>, <code><a href="#topic+activate.edges">activate.edges</a></code>,<code><a href="network.html#topic+add.vertices">add.vertices</a></code>,<code><a href="network.html#topic+add.edges">add.edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nw &lt;- network.initialize(5)
activate.vertices(nw,onset=0,terminus=10)
network.size(nw)  # just 5 nodes
# add some new nodes with times
add.vertices.active(nw,2,onset=10,terminus=12)
network.size(nw)  # now we have 7 nodes

# add 2 edges edges, and activate them
add.edges(nw, tail=c(1,2),head=c(2,3))
activate.edges(nw,onset=0,terminus=10,e=1:2)

# instead add and activate at the same time
add.edges.active(nw, tail=c(3,4),head=c(4,5),onset=10,terminus=12)
</code></pre>

<hr>
<h2 id='adjust.activity'>
Adjust the activity ranges in all of the spells of a networkDynamic object
</h2><span id='topic+adjust.activity'></span>

<h3>Description</h3>

<p>Transforms the values of all the activity spells of vertices and edges, as well as spells of dynamic TEA attributes (and the <code>net.obs.period</code> if it exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.activity(nd, offset = 0, factor = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust.activity_+3A_nd">nd</code></td>
<td>

<p>networkDynamic object to be modified
</p>
</td></tr>
<tr><td><code id="adjust.activity_+3A_offset">offset</code></td>
<td>

<p>numeric value to be added (or subtracted) to all spell values
</p>
</td></tr>
<tr><td><code id="adjust.activity_+3A_factor">factor</code></td>
<td>

<p>numeric factor for multiplying all spell values
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spell values are modified by first adding the value of <code>offset</code> and then multiplying by <code>factor</code>. If a <code><a href="#topic+net.obs.period">net.obs.period</a></code> attribute exists, it's observation spell values are transformed, and the <code>time.increment</code> value is multiplied by <code>factor</code>. 
</p>


<h3>Value</h3>

<p>The <code>nd</code> argument is modified in place and returned invisibly.
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+attribute.activity.functions">attribute.activity.functions</a></code> and <code><a href="#topic+net.obs.period">net.obs.period</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert steps of an imaginary discrete sim
# with each steps corresponding to 1 day
# into decimal 'years' since 1990
sim&lt;-network.initialize(5)
activate.vertices(sim,onset=0,terminus=2546)
add.edges.active(sim,head=1:4,tail=2:5,onset=0,terminus=2546)
set.network.attribute(sim,'net.obs.period',list(
   observations=list(c(0,2546)),mode="discrete", 
   time.increment=1,time.unit="step"))

# do the transformation
adjust.activity(sim,offset=1990*365.25,factor=1/365.25)

# modify the 'units' of net.obs.period
obs &lt;-get.network.attribute(sim,'net.obs.period')
obs$time.unit&lt;-'year'
set.network.attribute(sim,'net.obs.period',obs)

# peek at the new values
as.data.frame(sim)
get.network.attribute(sim,'net.obs.period')
</code></pre>

<hr>
<h2 id='age.at'>
Age of active edges or vertices at a query time point 
</h2><span id='topic+edges.age.at'></span><span id='topic+dyads.age.at'></span><span id='topic+vertices.age.at'></span>

<h3>Description</h3>

<p>Reports the age of edges or vertices at a specific time point. More precisely, the duration of time between the query time point and the onset of the activity spell active at that point. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges.age.at(nD, at, e = seq_along(nD$mel), active.default = TRUE)
dyads.age.at(nD, at, tails, heads, active.default=TRUE,
                    format.out = c("vector", "edgelist", "matrix"))
vertices.age.at(nD, at, v=seq_len(network.size(nD)), active.default=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="age.at_+3A_nd">nD</code></td>
<td>

<p>a <code><a href="#topic+networkDynamic">networkDynamic</a></code> object to be evaluated
</p>
</td></tr>
<tr><td><code id="age.at_+3A_at">at</code></td>
<td>

<p>numeric query time point which edge or vertex ages should be evaluated at
</p>
</td></tr>
<tr><td><code id="age.at_+3A_e">e</code></td>
<td>

<p>numeric vector of edges ids for which ages / durations should be reported
</p>
</td></tr>
<tr><td><code id="age.at_+3A_v">v</code></td>
<td>

<p>numeric vector of vertex ids for which ages / durations should be reported
</p>
</td></tr>
<tr><td><code id="age.at_+3A_tails">tails</code></td>
<td>

<p>numeric vector of vertex ids incident on  the 'tail' of edges for which ages / durations should be reported 
</p>
</td></tr>
<tr><td><code id="age.at_+3A_heads">heads</code></td>
<td>

<p>numeric vector of vertex ids incident on  the 'head' of edges for which ages / durations should be reported
</p>
</td></tr>
<tr><td><code id="age.at_+3A_active.default">active.default</code></td>
<td>

<p>logical, if <code>TRUE</code> edges or vertices with no activity specified will be considered always active (see <code><a href="#topic+is.active">is.active</a></code>)
</p>
</td></tr>
<tr><td><code id="age.at_+3A_format.out">format.out</code></td>
<td>

<p>character value indicating out the output should be structured. <code>vector</code> returns output as a vector, <code>edgelist</code> returns a 3-column matrix in which the first columns are the tail and head vertex ids of the edge and the 3rd column is the age, <code>matrix</code> returns an adjacency matrix with the edge ages as values. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edges or vertices that are not active at time <code>at</code> will return <code>NA</code>. For edges or vertices with multiple activity spells, this function <em>does not</em> report the total duration of activity across all spells, only the duration from the start of the spell with which the <code>at</code> point intersects. 
</p>
<p><code>dyads.age.at</code> reports the age of edges corresponding to each dyad (tail,head).  It cannot be used with hypergraphic or multiplex networks because a pair of vertex ids may not uniquely correspond to an edge. If <code>tails</code> and <code>heads</code> are not specified, they will default to the tails and heads of all existing (but not necessarily active) edges in the network.  Ordering and index position should correspond to <code><a href="network.html#topic+valid.eids">valid.eids</a></code>.
</p>


<h3>Value</h3>

<p>By default, a numeric vector indicating the age of the network element at the query time point, or NA if the element is not active or (in the case of edges) deleted. Elements of the vector return correspond to the values of <code>e</code> or <code>v</code> or <code>(tails,heads)</code> respectively. 
</p>


<h3>Author(s)</h3>

<p>skyebend 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+get.edge.activity">get.edge.activity</a></code>, <code><a href="#topic+is.active">is.active</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up an example network for testing
test&lt;-network.initialize(5)
add.edges(test,tail = 1:4,head=2:5 )
activate.edges(test,onset=0:2,terminus=c(2,3,3),e=1:3)
activate.vertices(test,v = 1:4,onset=-3:0,terminus=5:8)

# how old are each of the edges at time point 2.0 ?
edges.age.at(test,at=2.0)

# how old is vertex id 2 time point 3
vertices.age.at(test,at=3, v=2)

# how old are the edges [1,2] and [3,4] at time point 2
dyads.age.at(test,at=2,tails=c(1,3),heads=c(2,4))

dyads.age.at(test,at=2,format.out='matrix')

</code></pre>

<hr>
<h2 id='as.data.frame.networkDynamic'>
Extracts the edge timing information from a networkDynamic object and represent as a data.frame.
</h2><span id='topic+as.data.frame.networkDynamic'></span>

<h3>Description</h3>

<p>Creates a data.frame giving lists of edges and their activity spells corresponding to the <code><a href="#topic+networkDynamic">networkDynamic</a></code> object. An observation window may be specified, and edge spells with values outside the window will be omitted or truncated/censored to the observation window bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkDynamic'
as.data.frame(x, row.names = NULL, optional = FALSE, e =seq_along(x$mel), 
             start = NULL, end = NULL, active.default=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.networkDynamic_+3A_x">x</code></td>
<td>
<p>a networkDynamic object</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_row.names">row.names</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_optional">optional</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_e">e</code></td>
<td>
<p>vector of edge ids that should be included in the output.</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_start">start</code></td>
<td>
<p>optional, numeric onset-censoring time: time at which the network was first
observed. Edge spells with earlier onset times are given this
as their onset time (and marked as left censored). See Details for
the default values.</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_end">end</code></td>
<td>
<p>optional right-censoring time: time at which the network was last
observed. Edge spells with larger terminus are given this
as their terminus time (and marked as right censored). See Details for
the default values.</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_active.default">active.default</code></td>
<td>
<p>logical indicating if edges with no defined activity spells should be considered active by default (and appear as a row in output)</p>
</td></tr>
<tr><td><code id="as.data.frame.networkDynamic_+3A_...">...</code></td>
<td>
<p>possible additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exports the edge dynamics of a <code><a href="#topic+networkDynamic">networkDynamic</a></code> object as a <code><a href="base.html#topic+data.frame">data.frame</a></code> giving a table of edges with their activity spells, including whether an activity spell was &ldquo;censored&rdquo; (onset or termination was not observed within the observation window). 
If a <code><a href="#topic+net.obs.period">net.obs.period</a></code> attribute exists, the maximal and minimal values will be used as censoring times by default.  Censoring times can also be provided using the <code>start</code> and <code>end</code> arguments (which will override <code>net.obs.period</code>), and censoring can be prevented by setting <code>start=-Inf, end=Inf</code>.  Edge spells that exceed the censoring bounds will have their onset and/or terminus time appropriately truncated to match and will be marked as censored.  Spells which are fully outside the censoring bounds will be deleted and the corresponding rows will not be returned.  
</p>
<p>Note that the spell overlap rules mean that when edge spells are modeled as momentary events (onset==terminus), any events have onset==terminus==end of the the observation window will not be returned. This will likely be the case for networks created by the <code><a href="#topic+networkDynamic">networkDynamic</a></code> converter function.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing timed relational information
describing the networkDynamic object, having the following columns:
</p>
<table>
<tr><td><code>onset</code>, <code>terminus</code></td>
<td>
<p>Onset and terminus times of an edge, respectively, if
not censored, and left and right censoring times, if censored.</p>
</td></tr>
<tr><td><code>tail</code>, <code>head</code></td>
<td>
<p>Tail and head of the edge.</p>
</td></tr>
<tr><td><code>onset.censored</code>, <code>terminus.censored</code></td>
<td>
<p>TRUE if onset/terminus time is censored.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>the duration (terminus-onset) of each spell, evaluated after censoring</p>
</td></tr>
<tr><td><code>edge.id</code></td>
<td>
<p>the id of the edge the row corresponds to</p>
</td></tr>
</table>
<p>The output <code>data.frame</code> will be sorted by edge.id, onset,terminus. This means that for most (non-multiplex) networks the group of spells for a specific edge will appear in sequential lines of output, but the overall output is not in a temporal order. 
</p>


<h3>Note</h3>

<p>Vertex and attribute activity are not included in the returned data.frame. If an edge has multiple activity spells, it will have multiple rows in the output. When output in censored, it may not match values returned by <code><a href="#topic+get.edge.activity">get.edge.activity</a></code>
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+get.edge.activity">get.edge.activity</a></code>,<code><a href="#topic+get.vertex.activity">get.vertex.activity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;-network.initialize(3)
net[1,2]&lt;-1;
net[2,3]&lt;-1;
## censoring
activate.edges(net,onset=1,terminus=Inf,e=1)
activate.edges(net,onset=2,terminus=3,e=2)
activate.vertices(net, onset=1, terminus=Inf, v=1)
as.data.frame(net)
</code></pre>

<hr>
<h2 id='as.network.networkDynamic'>
Remove &lsquo;networkDynamic&rsquo; class name from networkDynamic object.
</h2><span id='topic+as.network.networkDynamic'></span>

<h3>Description</h3>

<p>Changes the class of a <code>networkDynamic</code> object to a plain <code>network</code> object while leaving all attributes (including dynamic attributes) intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'networkDynamic'
as.network(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.network.networkDynamic_+3A_x">x</code></td>
<td>

<p>A <code>networkDynamic</code> object that will have its class name stripped. 
</p>
</td></tr>
<tr><td><code id="as.network.networkDynamic_+3A_...">...</code></td>
<td>

<p>Possible additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary use-case for this method is to force some other S3 method (like <code>simulate</code> in the <code>tergm</code> package, plot, or print) to use 'network' instead of 'networkDynamic' in method dispatching.  Dynamic features data structures be left intact but not recognized by corresponding methods, so effectively broken.  
</p>


<h3>Value</h3>

<p>Returns the original network with the <code>networkDynamic</code> class name removed but all other attributes unchanged
</p>


<h3>Author(s)</h3>

<p>Skye Bender-deMoll
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+network.extract">network.extract</a></code> for extracting parts of a networkDynamic, and <code><a href="#topic+network.collapse">network.collapse</a></code> for extracting part of a networkDynamic as a static network. <code><a href="#topic+as.networkDynamic">as.networkDynamic</a></code> for the inverse operation (adding the networkDynamic class to a static network).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test&lt;-network.initialize(2)
add.edges.active(test,tail=1,head=2,onset=1,terminus=2)
is.networkDynamic(test)
test&lt;-as.network(test)
is.networkDynamic(test)

</code></pre>

<hr>
<h2 id='as.networkDynamic'>
as.networkDynamic
</h2><span id='topic+as.networkDynamic'></span><span id='topic+as.networkDynamic.network'></span><span id='topic+as.networkDynamic.networkDynamic'></span><span id='topic+as.networkDynamic.networkLite'></span>

<h3>Description</h3>

<p>The <code>as.networkDynamic</code> generic provides a very basic conversion to 
<code>networkDynamic</code> from other network types. It is generally recommended 
to use the <code><a href="#topic+networkDynamic">networkDynamic</a></code> function instead of 
<code>as.networkDynamic</code>, because <code><a href="#topic+networkDynamic">networkDynamic</a></code> provides a 
number of additional features for handling temporal information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>                 
## S3 method for class 'networkDynamic'
as.networkDynamic(object,...)

## S3 method for class 'network'
as.networkDynamic(object,...)

## S3 method for class 'networkLite'
as.networkDynamic(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.networkDynamic_+3A_object">object</code></td>
<td>
<p>a <code>network</code>, <code>networkLite</code>, or <code>networkDynamic</code> object</p>
</td></tr>
<tr><td><code id="as.networkDynamic_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.networkDynamic.network</code> converts a <code>network</code> object into 
a <code>networkDynamic</code> object by adding a <code>networkDynamic</code> class.
</p>
<p><code>as.networkDynamic.networkLite</code> converts a <code>networkLite</code> object into 
a <code>networkDynamic</code> object by first converting it to a <code>network</code> 
object and then adding a <code>networkDynamic</code> class. (<code>networkLite</code>s are
a backend data structure used in some <code>EpiModel</code> and <code>statnet</code>
packages, providing improved performance for certain applications, especially
when working with vertex and edge attributes that can be stored as atomic
vectors. Currently, <code>networkLite</code>s come with the restriction that the
network attributes <code>hyper</code>, <code>multiple</code>, and <code>loops</code> must be
<code>FALSE</code>. See <code><a href="networkLite.html#topic+networkLite-package">networkLite-package</a></code> for more information.)
</p>
<p>Such conversions between network types are used when starting a dynamic 
simulation from a cross-sectional network and returning the simulation history 
as a dynamic network, as done in the <code>tergm</code> package for example.
</p>


<h3>Value</h3>

<p>For <code>as.networkDynamic.network</code> the input object is returned with a 
<code>networkDynamic</code> class added. For <code>as.networkDynamic.networkLite</code>, 
the input object is converted to a <code>network</code> object and then the 
<code>networkDynamic</code> class is added. For 
<code>as.networkDynamic.networkDynamic</code> the input object is returned 
unchanged.
</p>


<h3>Author(s)</h3>

<p>Pavel, Zack W Almquist &lt;almquist@uci.edu&gt;
</p>


<h3>See Also</h3>

<p>For the inverse (removing the <code>networkDynamic</code> class) see
<code><a href="#topic+as.network.networkDynamic">as.network.networkDynamic</a></code> and
<code><a href="networkLite.html#topic+as.networkLite.network">as.networkLite.network</a></code> (which applies to <code>networkDynamic</code>s).
For extracting cross-sectional information from a <code>networkDynamic</code> (which
is often more appropriate than simply removing the <code>networkDynamic</code>
class), see <code><a href="#topic+network.collapse">network.collapse</a></code> and <code><a href="#topic+network.extract">network.extract</a></code>.
For more general construction of <code>networkDynamic</code>s, see
<code><a href="#topic+networkDynamic">networkDynamic</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> nd &lt;- as.networkDynamic(network.initialize(3))
 class(nd)
 is.networkDynamic(nd)
 
 nwL &lt;- networkLite::networkLite(3)
 nwD &lt;- as.networkDynamic(nwL)
 class(nwD)
 is.networkDynamic(nwD)
</code></pre>

<hr>
<h2 id='attribute.activity.functions'>
Functions to activate and query dynamic attributes on vertices, edges, and networks
</h2><span id='topic+attribute.activity.functions'></span><span id='topic+activate.vertex.attribute'></span><span id='topic+get.vertex.attribute.active'></span><span id='topic+activate.edge.attribute'></span><span id='topic+activate.edge.value'></span><span id='topic+get.edge.value.active'></span><span id='topic+get.edge.attribute.active'></span><span id='topic+activate.network.attribute'></span><span id='topic+get.network.attribute.active'></span><span id='topic+deactivate.edge.attribute'></span><span id='topic+deactivate.vertex.attribute'></span><span id='topic+deactivate.network.attribute'></span><span id='topic+list.vertex.attributes.active'></span><span id='topic+list.edge.attributes.active'></span><span id='topic+list.network.attributes.active'></span><span id='topic+TEAs'></span><span id='topic+dynamic.attributes'></span>

<h3>Description</h3>

<p>These functions set, query and modify attributes of networkDynamic objects used to represent values which change over time. These dynamic or &quot;temporally extended attributes&quot; are stored as standard attributes with a specially defined structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate.vertex.attribute(x, prefix, value, onset = NULL, terminus = NULL, 
    length = NULL, at = NULL, v = seq_len(network.size(x)), dynamic.only = FALSE)

activate.edge.attribute(x, prefix, value, onset = NULL, terminus = NULL, 
    length = NULL, at = NULL, e = seq_along(x$mel), dynamic.only = FALSE)
    
activate.edge.value(x, prefix, value, onset = NULL, terminus = NULL, 
    length = NULL, at = NULL, e = seq_along(x$mel), dynamic.only = FALSE)
    
activate.network.attribute(x, prefix, value, onset = NULL, terminus = NULL, 
    length = NULL, at = NULL, dynamic.only = FALSE)    
    
## S3 method for class 'active'
get.vertex.attribute(x, prefix, onset = NULL, terminus = NULL, 
          length = NULL, at = NULL, rule = c("any", "all","earliest","latest"), 
          na.omit = FALSE, null.na = TRUE, active.default = TRUE,
          dynamic.only = FALSE, require.active = FALSE,
          return.tea = FALSE, unlist = TRUE, ...)   
 
## S3 method for class 'active'
get.edge.attribute(x, prefix, onset = NULL, terminus = NULL,
          length = NULL, at = NULL, rule = c("any", "all","earliest","latest"), 
          active.default = TRUE, dynamic.only = FALSE, require.active = FALSE, 
          return.tea = FALSE, unlist = TRUE, ..., el) 

## S3 method for class 'active'
get.edge.value(x, prefix, onset = NULL, terminus = NULL,
          length = NULL, at = NULL, rule = c("any", "all","earliest","latest"), 
          active.default = TRUE, dynamic.only = FALSE, require.active = FALSE, 
          return.tea = FALSE, unlist = TRUE, ...) 

## S3 method for class 'active'
get.network.attribute(x, prefix, onset = NULL, terminus = NULL,length = NULL, 
                at = NULL, rule = c("any", "all","earliest","latest"), 
                dynamic.only = FALSE, return.tea=FALSE, unlist=TRUE, ...) 
                
deactivate.vertex.attribute (x, prefix, onset=NULL, terminus=NULL,
          length = NULL, at = NULL, v = seq_len(network.size(x)), dynamic.only = FALSE)
                 
deactivate.edge.attribute (x, prefix, onset = NULL, terminus = NULL,
          length = NULL, at = NULL, e = seq_along(x$mel), dynamic.only = FALSE)

deactivate.network.attribute(x, prefix, onset = NULL, terminus = NULL, 
          length = NULL, at = NULL, dynamic.only = FALSE)
                
## S3 method for class 'active'
list.vertex.attributes(x, onset = NULL, terminus = NULL,length = NULL, 
                at = NULL, na.omit = FALSE, rule = c("any", "all"), 
                v = seq_len(network.size(x)), require.active = FALSE, 
                active.default = TRUE, dynamic.only = FALSE, ...)
                
## S3 method for class 'active'
list.edge.attributes(x, onset = NULL, terminus = NULL,length = NULL, 
                at = NULL, na.omit = FALSE, rule = c("any", "all"), 
                e = seq_along(x$mel), require.active = FALSE, 
                active.default = TRUE, dynamic.only = FALSE, ...)
                
## S3 method for class 'active'
list.network.attributes(x, onset = NULL, terminus = NULL,length = NULL, 
                at = NULL, na.omit = FALSE, rule = c("any", "all"),
                dynamic.only = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute.activity.functions_+3A_x">x</code></td>
<td>

<p>a <code>networkDynamic</code> object
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_prefix">prefix</code></td>
<td>

<p>character string for the name of the attribute to be stored (will be stored as prefix.active)
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_value">value</code></td>
<td>

<p>an object that is the value of the attribute to be stored. If <code>value</code> is a <code>list</code>, it is assumed that each element corresponds to an index in <code>v</code>.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_onset">onset</code></td>
<td>

<p>an optional vector of time-points that specifies the starts of the interval(s) at which the <code>value</code> argument should be considered active for each vertex/edge.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_terminus">terminus</code></td>
<td>

<p>an optional vector of time-points that specifies the ends of the interval(s) at which the <code>value</code> argument should be considered active for each vertex/edge.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_length">length</code></td>
<td>

<p>an optional vector of interval lengths for the interval(s) which should be activated for each vertex/edge. This must be accompanied by one of <code>onset</code> or <code>terminus</code>.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_at">at</code></td>
<td>

<p>optional, one or more time points (corresponding to vertices/edges) at which values should be activated for each vertex/edge
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_v">v</code></td>
<td>

<p>optional, one or more IDs indicating which vertices should have the TEA attribute added (default is all vertices)
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_e">e</code></td>
<td>

<p>optional, one or more edge IDs indicating which edge should have the TEA attribute added. Default is all edges. Note: Currently values of <code>e</code> correspond to elements of <code>x$mel</code>, including null elements from deleted edges. So if some edges have been deleted from the network, <code>e</code> may need to be padded out appropriately and can be longer than <code>network.edgecount(x)</code>. 
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_dynamic.only">dynamic.only</code></td>
<td>

<p>If dynamic.only==TRUE, only TEAs are considered; otherwise, non-TEA attributes are also employed (with activity as defined by active.default). 
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_require.active">require.active</code></td>
<td>

<p>logical. If TRUE, NA will be returned instead of an attribute value if the associated vertex or edge is inactive for the query period. When vertex or edge activity has not be explicitly set, the state is controlled by <code>active.default</code>.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_active.default">active.default</code></td>
<td>

<p>logical; should underlying vertices or edges without an activity attribute be regarded as active by default?
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_na.omit">na.omit</code></td>
<td>

<p>logical; should values from missing vertices/edges be removed? (implemented for vertices, but removal means that the index may not correspond to vertex.id for returned values)
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_null.na">null.na</code></td>
<td>

<p>logical; should <code>NULL</code> values be replaced with NAs? 
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_rule">rule</code></td>
<td>

<p>a character string indicating how the attribute activity spells should be matched against the query spell for this query: 
</p>

<ul>
<li> <p><code>any</code> (default) match attribute values if they overlap with any part of the query interval.  
</p>
</li>
<li> <p><code>all</code> match an attribute value only if it overlaps with the entire query interval, 
</p>
</li>
<li> <p><code>earliest</code> match a single value corresponding to the earliest attribute overlaping any part of the query spell, 
</p>
</li>
<li> <p><code>latest</code> match a single value corresponding to the earliest attribute overlaping any part of the query spell.
</p>
</li></ul>

</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_return.tea">return.tea</code></td>
<td>

<p>logical; if <code>return.tea=TRUE</code>, will return an (appropriately truncated) activity attribute- a list with the first element a list of values and the second element the spell matrix of corresponding spell(s) matching according to <code>rule</code>. Also sets <code>unlist=FALSE</code> and <code>dynamic.only=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_unlist">unlist</code></td>
<td>

<p>logical; should retrieved attributes be unlisted prior to being returned? Setting to FALSE is necessary to correctly fetch list objects stored as attributes.
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_...">...</code></td>
<td>

<p>possible additional arguments
</p>
</td></tr>
<tr><td><code id="attribute.activity.functions_+3A_el">el</code></td>
<td>

<p>unused argument that exists solely for consistency with <code>network</code>; do not use this argument!
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide easy ways to work with temporally extended attributes, making it possible to store attributes on a dynamic network that should be represented as changing values and different points in time. Because the serve as wrappers for get.*.attribute and set.*.attribute, many of the arguments are directly passed through. 
</p>
<p>The activate.*.attribute methods act as a cross between  activate.*  set.*.attribute methods.  They are used to activate an attribute for a given spell, and in so doing set a value for that spell.  The corresponding deactivate methods are more straightforward, deactivating the attribute over a set interval (and removing any spells/values as needed).
</p>
<p>A dynamic or Temporally Extended Attribute (TEA) is an edge, vertex, or network attribute satisfying the following properties:
</p>

<ol>
<li><p> Its name consists of an arbitrary prefix, together with the suffix &quot;.active&quot;.
</p>
</li>
<li><p> Its value consists of a two-element list, whose respective contents must be maintained in order as follows:
</p>

<ul>
<li><p> a. A list of value entries, such that the ith list element is the value of the attribute for the ith spell in the associated activity matrix.  An attribute not active at any given point in time is defined as having a value of NA (but the reverse is not true &ndash; an active attribute can also take a value of NA).
</p>
</li>
<li><p> b. A two-column numeric matrix, conforming to the specifications for activity attributes in the networkDynamic package.  Every active spell indicated in the activity matrix must correspond to exactly one entry of the associated value list, and these must be maintained in order (i.e., the value of the attribute for the ith active spell is the ith element in the value list).
</p>
</li></ul>

</li></ol>

<p>There are several ways to specify the activity spell, and the general syntax rules are described at <code><a href="#topic+activity.attribute">activity.attribute</a></code>.  Activity can be set for a single time point, using either <code>at</code>, or by setting onset=terminus.  Activity can be set for an interval [onset,terminus), using a valid combination of the <code>onset</code>, <code>terminus</code> and <code>length</code> attributes. 
</p>
<p>This allows for a wide range of options when specifying spells, but a correct specification must use only one of these forms:
</p>
<pre>
  at
  onset and terminus 
  onset and length
  terminus and length
</pre>
<p>If the <code>set</code> and <code>deactivate</code> functions are provided with no timing information, the element is activated/deactivated from <code>-Inf</code> to <code>Inf</code>. The specified interval spans the period from the onset (inclusive) to the terminus (exclusive), so <code>[onset,terminus)</code>. For more details, see <code><a href="#topic+activate">activate</a></code> The <code>get</code> query functions will give an error if no timing information is provided. 
</p>
<p>When the activity arguments have a length greater than 1, the elements are assumed to correspond to the vertex or edge ids that should have that activity specified, not to the elements of <code>value</code>. In other words, it is possible to use one function call to activate multiple values on multiple vertices with a different activity time on each vertex, but it is not possible to activate multiple values at multiple times on a single vertex with one call. 
</p>
<p><code>activate.edge.value</code> is a wrapper for <code>activate.edge.attribute</code>. 
</p>
<p>When the attribute query has a non-zero duration (i.e. <code>length</code> &gt; 0, or <code>onset!=terminus</code>) it is possible that the query spell will match against multiple attribute values for each network element. If multiple values match and <code>return.tea=FALSE</code>, a warning will be generated and only the earliest value will be returned. To avoid the warning, this behavior (or its opposite) can be specified by setting <code>rule='earliest'</code> or <code>rule='latest'</code>.
</p>


<h3>Value</h3>

<p>The set methods modify their network argument internally and also invisibly return a reference to the modified network. The get methods return the attribute object appropriate for the time range specified query spell parameters.  If query results in multiple values and <code>return.tea=FALSE</code> only the first (earliest) is returned along with a warning. Note that <code>get.edge.value.active</code> returns <code>NULL</code> if no attributes names match, where <code>get.vertex.attribute.active</code> returns <code>NA</code>s.  Also of <code>null.na=FALSE</code> and <code>unlist=TRUE</code>, the index position for returned values may not correspond to the vertex.id because NULL values will be omited.
</p>


<h3>Note</h3>

<p>Attribute activity is only checked against vertex and edge activity during fetching if <code>require.active=TRUE</code>.  Otherwise the attributes for a vertex can take values (be active) when the vertex itself is inactive. Likewise for edges.  The because they must check all attributes on all network elements, the <code>list.*.active</code> functions are generally more computationally expensive that a <code>get</code> call for checking if a specific attribute exists. Note that  <code>get.edge.attribute.active</code> currently calls <code>get.edge.attribute.active</code> and does not support a list of edges as input. 
</p>


<h3>Author(s)</h3>

<p>skyebend, ayn, carter, pavel, martina, steve
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="network.html#topic+set.vertex.attribute">set.vertex.attribute</a></code>, <code><a href="network.html#topic+get.vertex.attribute">get.vertex.attribute</a></code>,<code><a href="network.html#topic+list.vertex.attributes">list.vertex.attributes</a></code>,<code><a href="#topic+activate.vertices">activate.vertices</a></code>, <code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+activate">activate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#initialize network
test&lt;-network.initialize(5)

#activate vertex attribute
test&lt;-activate.vertex.attribute(test,"letter","a",onset=0,terminus=1)
test&lt;-activate.vertex.attribute(test,"number","4",onset=1,terminus=2)
test&lt;-activate.vertex.attribute(test,"number","5",onset=2,terminus=3)

#list active/all vertex attributes
list.vertex.attributes.active(test, onset=0,terminus=3,dynamic.only=TRUE)
list.vertex.attributes.active(test, onset=1,terminus=3,dynamic.only=FALSE)

#get values for specific vertex attribute
get.vertex.attribute.active(test,"letter",onset=2,terminus=3)

#deactive vertex attribute
test &lt;- deactivate.vertex.attribute(test, "letter", onset=0, terminus=3)
list.vertex.attributes.active(test, onset=0,terminus=3,dynamic.only=TRUE)

#initialize edges
test[1,2]&lt;-1
test[2,3]&lt;-1

#activate edge attribute
test&lt;-activate.edge.attribute(test,"number",1,onset=0,terminus=2)
test&lt;-activate.edge.attribute(test,"number",5,onset=2,terminus=5)
test&lt;-activate.edge.attribute(test,"letter","a",onset=1,terminus=4)

#list edge attributes
list.edge.attributes.active(test, onset=0,terminus=4,dynamic.only=TRUE)
list.edge.attributes.active(test, onset=0,terminus=4,dynamic.only=FALSE)

#get values for specific edge attribute
get.edge.value.active(test,"number",onset=3,terminus=4)

#deactive edge attribute
test &lt;- deactivate.edge.attribute(test, "letter", onset=0, terminus=3)
list.edge.attributes.active(test, onset=0,terminus=3,dynamic.only=TRUE)

#activate network attribute
test &lt;- activate.network.attribute(test,"alist",list("a","b"),onset=1,terminus=2)
test &lt;- activate.network.attribute(test,"alist",list("c","d"),onset=2,terminus=3)
test &lt;- activate.network.attribute(test,"aspace",list("1","2"),onset=1,terminus=2)
test &lt;- activate.network.attribute(test,"aspace",list("3","4"),onset=2,terminus=3)

#list network attributes
list.network.attributes.active(test, onset=0,terminus=3,dynamic.only=TRUE)
list.network.attributes.active(test, onset=0,terminus=3,dynamic.only=FALSE)

#get values for specific network attribute
get.network.attribute.active(test,"alist",at=2.5,unlist=FALSE)

#deactive network attribute
test &lt;- deactivate.network.attribute(test, "alist", onset=0, terminus=3)
list.network.attributes.active(test, onset=0,terminus=3,dynamic.only=TRUE)

# activate multiple values on multiple vertices at multiple times
test&lt;-network.initialize(3)
activate.vertex.attribute(test,"letters",c("a","b","c"),onset=c(0,1,2),terminus=c(1,2,3))

# peek at TEA structure using non-TEA attribute query
get.vertex.attribute(test,"letters.active",unlist=FALSE)

# compare different 'rules'
test&lt;-network.initialize(1)
activate.vertex.attribute(test,'color','red',onset=0,terminus=1)
activate.vertex.attribute(test,'color','green',onset=1,terminus=2)
activate.vertex.attribute(test,'color','blue',onset=2,terminus=3)

get.vertex.attribute.active(test,'color',onset=0,terminus=3)
get.vertex.attribute.active(test,'color',onset=0,terminus=3,return.tea=TRUE)
get.vertex.attribute.active(test,'color',onset=0,terminus=3,rule='earliest')
get.vertex.attribute.active(test,'color',onset=0,terminus=3,rule='latest')

</code></pre>

<hr>
<h2 id='cls33_10_16_96'>
Daniel McFarland's Streaming Classroom Interactions Dataset
</h2><span id='topic+cls33_10_16_96'></span><span id='topic+McFarland_cls33_10_16_96'></span>

<h3>Description</h3>

<p>A dynamic network object describing continuous time streams of social interactions between teachers and students in a classroom observed by Daniel McFarland in 1996.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(McFarland_cls33_10_16_96)</code></pre>


<h3>Format</h3>

<p>The format is is a <a href="#topic+networkDynamic">networkDynamic</a> object  named <code>cls33_10_16_96</code> with node and edge <a href="#topic+activity.attribute">activity.attribute</a>s defined by spell matricies and associated vertex attributes and dynamic edge attributes. 
</p>


<h3>Details</h3>

<p>The dynamic network object has 20 vertices and directed edges and covers a time range of 0.0 to 49.0 minutes of class time. The vertex attribute <code>gender</code> gives gender ('M' or 'F') of each person and <code>type</code> gives a crude role ('grade11','grade12','instructor').  The original dataset id for the vertices is included as <code>data_id</code> and defined as a persistent.id. The edges include a dynamic attribute (TEA) <code>interaction_type</code> with values 'saction', 'social' and 'task' (see explanation below) and a <code>weight</code> assigned by the reacher to that interaction (direct comunication is given more weight than indirect 'broadcast' communication).
</p>
<p>A .son formatted input file with the same data as well as seperate tsv files for vertices and edges are located in the /inst/extdata directory.
</p>
<p>The data for these classroom interactions consists of streaming observations of conversation turns. The conversation turns were recorded as pairs of senders and receivers and for types of content. Speakers were viewed as directing their communication in one of two fashions: (1) indirect soundings, such as lectures (where a teacher addresses all students); and (2) direct interactions that are focused on particular others. Each type of directional speech is viewed as having different forms of network reception - indirect speech reaches all bystanders as passive hearers and directed speech reaches the focal person as an active co-author of the conversation (Goffman 1981).
</p>
<p>Two types of interaction are found to prevail in classroom contexts: task and sociable (McFarland, in press). Task interactions are those behaviors that pertain to the ongoing teacher prescribed task (content is academic). In contrast, sociable interactions concern everyday concerns of adolescents' social lives, such as parties, dating, social outings, plans, etc. While the content is the key distinction, it is often the case that these speech acts are distinguishable in style as well, where sociable behaviors are more play-like, fast-paced, and free than the more constrained academic styles of speech during lessons (Cazden 1988). Last, observations also recorded when task and sociable forms of interaction were laminated with evaluative meaning. Such evaluations were seen as being either positive or negative - either giving praise or attempting a reprimand (Ridgeway and Johnson).
</p>
<p>The class (#33) is an economics class composed of 11th and 12th graders at a magnet high school. On this day, economics has two teachers. The first is the usual teacher and the second is a businessman who donates his time a couple days a month to assist the class with their lesson on stock investments. After a minute of undefined class time, the two teachers prescribe collaborative group work and assist students in conducting it. The students are assigned groups within which they are to study the stock market and make mock investments they can follow over time. The groups compete with each other over the course of the semester to see who can make the greatest profit.
</p>
<p>The network narrative for the class opens with the teacher trying to focus student attention and then lecturing while the visiting professional assists each group. The teacher prescribes group work but continues to lecture, thereby preventing the desired social routine from fully taking effect. Eventually the students are doing group projects while the adults move from group to group, facilitating their progress, and stabilizing interaction patterns. The routine of group work is basically characterized by dyadic task and social interactions that persist in multiple clusters. Not all persons engage in these groups, and a couple students sit quietly by themselves. The group work routine breaks down as social activity increases within the groups', and then the teacher emits broadcast sanctions in an effort to redirect student attention back on task (16 minutes). The task breaks down again at the end of class, but this time because the adults make closing announcements.
</p>
<p>So the network illustrates that teachers are involved in this task engaging their students as they monitor interaction. When students become too social, a teacher usually arrives, disperses the group, and then reforms it via task interactions (revolution in type of behavior, McFarland 2004). Hence, the &ldquo;dance&rdquo; here entails relatively bounded groups of individuals that free-associate over tasks and drift into social affairs, and teachers who refocus affairs by indirect means of broadcasts or by direct means of directed speech. 
</p>


<h3>Source</h3>

<p>Dr. Daniel McFarland, Stanford University <a href="https://ed.stanford.edu/faculty/mcfarland">https://ed.stanford.edu/faculty/mcfarland</a>
</p>


<h3>References</h3>

<p>McFarland, Daniel A. 2005. &ldquo;Why Work When You Can Play? Dynamics of Formal and Informal Organization in Classrooms.&rdquo; Chapter 8 in The Social Organization of Schooling, edited by Larry Hedges and Barbara Schneider (pp. 147-174). New York: Russell Sage Foundation.
</p>
<p>McFarland, Daniel A. 2004. &ldquo;Resistance as a Social Drama - A Study of Change-Oriented Encounters.&rdquo; American Journal of Sociology 109 (6): 1249-1318.
</p>
<p>McFarland, Daniel A. 2001. &ldquo;Student Resistance: How the Formal and Informal Organization of Classrooms Facilitate Everyday Forms of Student Defiance.&rdquo; American Journal of Sociology 107 (3): 612-78.
</p>
<p>McFarland, Daniel A. and Skye Bender-deMoll. 2003. &ldquo;Classroom Structuration: A Study of Network Stabilization.&rdquo; Working paper, Stanford University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(McFarland_cls33_10_16_96)
</code></pre>

<hr>
<h2 id='delete.activity'> Remove Timing Information in a Dynamically Extended Network Object </h2><span id='topic+delete.edge.activity'></span><span id='topic+delete.vertex.activity'></span>

<h3>Description</h3>

<p>Removes the activity spells of a given set of vertices or edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.edge.activity(x, e=seq_along(x$mel))

delete.vertex.activity(x, v=seq_len(network.size(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.activity_+3A_x">x</code></td>
<td>
<p> an object, of class <code>network</code> or <code>networkDynamic</code>. </p>
</td></tr>
<tr><td><code id="delete.activity_+3A_e">e</code></td>
<td>
<p> the edges of <code>x</code> that will have their timing information
deleted; default = all. </p>
</td></tr>
<tr><td><code id="delete.activity_+3A_v">v</code></td>
<td>
<p> the vertices of <code>x</code> that will have their timing information
deleted; default = all. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Though the timing information of the edges and/or vertices may be
removed, other networkDynamic methods will assume activity or
inactivity across all time points, based on the argument
<code>active.default</code>. 
</p>


<h3>Value</h3>

<p>An object with the same class as <code>x</code>, equivalent to <code>x</code> without the
activity spells of the edges <code>e</code> or the vertices <code>v</code>.  
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+activate">activate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(networkDynamic)
  data(flo)
  net1 &lt;- network(flo)
  activate.edges(net1)
  activate.vertices(net1)
  net2 &lt;- net1
  delete.edge.activity(net1, e=seq(2,40,2))
  delete.edge.activity(net2)
  delete.vertex.activity(net2)
  is.active(net1, at=0, e=c(1,2), active.default=FALSE)
  is.active(net1, at=0, e=c(1,2), active.default=TRUE)
  is.active(net2, at=0, e=1:16, active.default=FALSE)
  is.active(net2, at=0, e=1:16, active.default=TRUE)
</code></pre>

<hr>
<h2 id='duration.matrix'> Construct a edge spells list from base network and toggle list. </h2><span id='topic+duration.matrix'></span>

<h3>Description</h3>

<p>Given a network object and a toggle list, it will construct a list of edges and activity spells and return that as a data frame. The network object does not need to have edges; it only needs to have enough vertices to cover all the edges specified in the toggle list.
</p>
<p>The toggle list should be a three column matrix or data frame, where the first column is the toggle time, the second column is the tail vertex id of the edge, and the third column is the head vertex id of the edge. A toggle represents a switch from active state to inactive, or vice-versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration.matrix(nw0, changes, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration.matrix_+3A_nw0">nw0</code></td>
<td>
<p> an object of class <code>network</code> </p>
</td></tr>
<tr><td><code id="duration.matrix_+3A_changes">changes</code></td>
<td>
<p> a matrix or data frame, listing the toggles for edges as specified in the above description </p>
</td></tr>
<tr><td><code id="duration.matrix_+3A_start">start</code></td>
<td>
<p> integer, specifies the starting time of the network's dynamic activity </p>
</td></tr>
<tr><td><code id="duration.matrix_+3A_end">end</code></td>
<td>
<p> integer, specifies the ending time of the network's dynamic activity </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame that lists the edge spells specified by the toggles. The columns in the data frame are 
<code>start end tail head left.censored right.censored duration</code>. Left and right censoring and duration are calculated
automatically from the toggle list and the start and end times.
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.networkDynamic">as.networkDynamic</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(networkDynamic)
  # duration matrix test
  net &lt;-network.initialize(3)
  net[1,2]&lt;-1;
  net[2,3]&lt;-1;
  net[1,3]&lt;-1;
  class(net)
  # toggle list: time, tail, head
  tog=matrix(c(1,1,2, 1,2,3, 2,1,2, 4,1,3, 4,1,2), ncol=3, byrow=TRUE)
  networkDynamic:::duration.matrix(net, tog, 0, 5)
</code></pre>

<hr>
<h2 id='get.dyads.active'>
Return the set of vertex ids of edges active at a given time
</h2><span id='topic+get.dyads.active'></span>

<h3>Description</h3>

<p>Constructs a matrix, essentially an edgelist, of the pairs of vertices connected by edges active within the query spell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dyads.active(nD, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
                rule = c("any", "all", "earliest", "latest"), active.default = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.dyads.active_+3A_nd">nD</code></td>
<td>

<p>networkDynamic object to be queried
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_onset">onset</code></td>
<td>

<p>optional numeric value giving onset time of query spell
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_terminus">terminus</code></td>
<td>

<p>optional numeric value giving terminus time of query spell
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_length">length</code></td>
<td>

<p>optional numeric value giving length (duration) of query spell
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_at">at</code></td>
<td>

<p>optional numeric value giving single time point to query
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_rule">rule</code></td>
<td>

<p>a character string indicating the definition of &quot;active&quot; for this query: <code>any</code> (default) to define active as any active spell during the interval, or <code>all</code> to define active as being active over the entire interval. For this functions, the values of <code>earliest</code> and <code>latest</code> are equivalent to <code>any</code> and are only included for consistency.
</p>
</td></tr>
<tr><td><code id="get.dyads.active_+3A_active.default">active.default</code></td>
<td>

<p>logical; should elements without an activity attribute be regarded as active by default? Default to <code>TRUE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+is.active">is.active</a></code> internally.  The ordering of matrix rows is arbitrary.  The ordering of vertices in non-directed networks corresponds to how they were set in the data structure (i.e. does not enforce i &gt; j) If no edges are active or exist, a matrix with zero rows will be returned. 
</p>


<h3>Value</h3>

<p>Returns a two-column numeric matrix in which the first column gives a tail vertex.id and the second column gives the head vertex.id and each row corresponds to the existence of an active relationship between the vertices for the given query spell. 
</p>


<h3>Note</h3>

<p>This function does not support hypergraphic networks. 
</p>


<h3>Author(s)</h3>

<p>skyebend 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+is.active">is.active</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(windsurfers)
 get.dyads.active(windsurfers,onset=2,terminus=3)
</code></pre>

<hr>
<h2 id='get.networks'>Obtain a list of collapsed networks sampled periodically from a networkDynamic object</h2><span id='topic+get.networks'></span>

<h3>Description</h3>

<p>Given a start time, end time, and increment (or vectors of onsets and termini) to express sampling intervals, return a list of collapsed networks from a networkDynamic object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get.networks(dnet, start = NULL, end = NULL, time.increment = NULL, 
               onsets=NULL, termini=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.networks_+3A_dnet">dnet</code></td>
<td>

<p>A <code>networkDynamic</code> object with possible vertex, edge, network, and attribute spell information. 
</p>
</td></tr>
<tr><td><code id="get.networks_+3A_start">start</code></td>
<td>
<p> numeric value giving the start of the sampling interval</p>
</td></tr>
<tr><td><code id="get.networks_+3A_end">end</code></td>
<td>
<p> numeric value giving the end of the sampling interval</p>
</td></tr>
<tr><td><code id="get.networks_+3A_time.increment">time.increment</code></td>
<td>
<p>value for the offset (and duration) between sucessive samples. Will default to 1 if not otherwise specified</p>
</td></tr>
<tr><td><code id="get.networks_+3A_onsets">onsets</code></td>
<td>
<p> A numeric vector containing the onset times of the networks to be extracted.   This must be accompanied by <code>termini</code> of the same length.
</p>
</td></tr>
<tr><td><code id="get.networks_+3A_termini">termini</code></td>
<td>
<p> A numeric vector containing the terminus times of the networks to be extracted.   This must be  accompanied by <code>onsets</code> of the same length.
</p>
</td></tr>
<tr><td><code id="get.networks_+3A_...">...</code></td>
<td>
<p> Additional arguments to <code><a href="#topic+network.collapse">network.collapse</a></code> (such as <code>rule</code>,<code>active.default</code>,<code>retain.all.vertices</code>) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling (&quot;slicing&quot;) intervals may be defined using either the <code>start</code>, <code>end</code>, and <code>time.increment</code> parameters, or by providing parallel vectors of <code>onsets</code> and <code>termini</code>. If values are not specefied but a <code><a href="#topic+net.obs.period">net.obs.period</a></code> attribute exists to describe the 'natural' sampling parameters, <code>start</code> and <code>end</code> will defult to the max an min of the observations element, with <code>time.increment</code> set to its corresponding value in the <code>net.obs.period</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> of static <code>network</code> objects corresponding to the specified sampling intervals of the <code>networkDynamic</code>
</p>


<h3>Note</h3>

<p>See Note in <code><a href="#topic+network.collapse">network.collapse</a></code>.
</p>


<h3>Author(s)</h3>

<p>Kirk Li, Skye Bender-deMoll
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+network.collapse">network.collapse</a></code> for obtaining a slice of static network, <code><a href="#topic+network.extract">network.extract</a></code> for extracting sub-ranges of a networkDynamic, <code><a href="#topic+get.vertex.attribute.active">get.vertex.attribute.active</a></code> for more on TEA attributes, and <code><a href="#topic+as.network.networkDynamic">as.network.networkDynamic</a></code> for stripping the the networkDynamic class from an object. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a networkDynamic with some basic activity and time extended attributes (TEA)
test &lt;- network.initialize(5)
add.edges.active(test, tail=c(1,2,3), head=c(2,3,4),onset=0,terminus=1)
activate.edges(test,onset=3,terminus=5)
activate.edges(test,onset=-2,terminus=-1)
activate.edge.attribute(test,'weight',5,onset=3,terminus=4)
activate.edge.attribute(test,'weight',3,onset=4,terminus=5,e=1:2)

# obtain the list of networks
list &lt;- get.networks(test,start=0, end=5)

# aggregate over a longer time period with specified rule
list &lt;- get.networks(test,start=0, end=6,time.increment=2,rule='latest')

# use 'at' style extraction of momentary slices via onsets &amp; termini
list &lt;- get.networks(test,onsets=0:5,termini=0:5)

# ensure that all networks returned will be the same size
list &lt;- get.networks(test,onsets=0:5,termini=0:5,retain.all.vertices=TRUE)


# find out how many edges in each sampling point with apply
sapply(get.networks(test,start=0,end=5),network.edgecount)

# generate a list of matrices
lapply(get.networks(test,start=0,end=5),as.matrix)


</code></pre>

<hr>
<h2 id='get.timing.info'> Retrieve the timing information present in a networkDynamic. </h2><span id='topic+get.change.times'></span><span id='topic+get.edge.activity'></span><span id='topic+get.vertex.activity'></span>

<h3>Description</h3>

<p>These methods return either the activity spells of each vertex or edge
or the unique time points at which edges and vertices become active or
inactive. 
</p>
<p>Finds all of the unique time points at which the edges and/or vertices
become active or inactive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.change.times(x, vertex.activity=TRUE, edge.activity=TRUE, ignore.inf=TRUE,
             vertex.attribute.activity = TRUE, edge.attribute.activity = TRUE,
             network.attribute.activity = TRUE)
get.vertex.activity(x, v=seq_len(network.size(x)), 
                   as.spellList=FALSE, active.default=TRUE)
get.edge.activity(x, e=seq_along(x$mel), as.spellList=FALSE, active.default=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.timing.info_+3A_x">x</code></td>
<td>
<p> an object, of class <code>network</code> or <code>networkDynamic</code>. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_vertex.activity">vertex.activity</code></td>
<td>
<p> logical, whether the times at which vertices become
active or inactive is to be returned. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_edge.activity">edge.activity</code></td>
<td>
<p> logical, whether the times at which edges become
active or inactive is to be returned. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_vertex.attribute.activity">vertex.attribute.activity</code></td>
<td>
<p>logical, whether the times attached to any dynamic vertex attributes should be returned</p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_edge.attribute.activity">edge.attribute.activity</code></td>
<td>
<p>logical, whether the times attached to any dynamic edge attributes should be returned</p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_network.attribute.activity">network.attribute.activity</code></td>
<td>
<p>logical, whether the times attached to any dynamic network attributes should be returned</p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_ignore.inf">ignore.inf</code></td>
<td>
<p>logical, whether Inf value will be ignored or not. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_e">e</code></td>
<td>
<p> IDs for the edges whose activity spells are wanted. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_v">v</code></td>
<td>
<p> IDs for the vertices whose activity spells are wanted. </p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_as.spelllist">as.spellList</code></td>
<td>
<p>should data be returned in spell matrix form? TODO: should this be callsed as.spellmatrix instead?</p>
</td></tr>
<tr><td><code id="get.timing.info_+3A_active.default">active.default</code></td>
<td>
<p>logical, should edges / vertices with no spell activity defined be treated as always active (<code>TRUE</code>) and included in output, or never active (<code>FALSE</code>) and skipped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the <code>get.change.times</code> function, the default settings return a
vector of all of the finite time points at which any edge or any
vertex becomes active or inactive, or any of their dynamic attributes change. If only one of the logical
arguments, say <code>vertex.activity</code>, is set to <code>FALSE</code>, then
the time points for the corresponding parts of the data structure will not be returned.  If both are
<code>FALSE</code>, numeric(0) is returned.
</p>
<p>For the <code>get.vertex.activity</code> and <code>get.edge.activity</code> functions, a list
of activity spells is returned with each list element corresponding to the id of the vertex or edge. Deleted edges will appear as NULL entries, as will any spell marked as inactive with the 'null' (Inf,Inf) spell.  If the argument <code>as.spellList=TRUE</code> the activity spells are instead formatted as a <code>data.frame</code> and include additional columns to indicate possible onset- and terminus-censoring.  Any 'null' spells and deleted edges will be omited. 
</p>
<p>For <code>get.vertex.activity</code> the columns are <code>[onset,terminus,vertex.id,onset.censored,terminus.censored,duration]</code>. 
</p>
<p>For <code>get.edge.activity</code> the columns are <code>[onset, terminus, tail, head, onset.censored, terminus.censored, duration, edge.id] </code>. 
</p>
<p>The data.frames will be sorted by id, onset, terminus.
</p>
<p>If a <code>net.obs.period</code> network attribute is set, the range of its <code>$observations</code> element is substituted in for the -Inf and Inf values that otherwise indicate the onset- and terminus-censored observations.  
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>,skyebend </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+activity.attribute">activity.attribute</a></code>,<code><a href="#topic+net.obs.period">net.obs.period</a></code>,<code><a href="#topic+as.data.frame.networkDynamic">as.data.frame.networkDynamic</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(networkDynamic)
  data(flo)
  net1 &lt;- network(flo)
  activate.edges(net1, onset=1:20, terminus=101:120)
  activate.vertices(net1, at=seq(2,32,2))
  get.change.times(net1)
  get.edge.activity(net1)
  get.edge.activity(net1,as.spellList=TRUE)
  get.vertex.activity(net1)
  
  a &lt;-network.initialize(5)
  activate.vertices(a,onset=0,terminus=Inf)
  get.change.times(a,ignore.inf=FALSE)


</code></pre>

<hr>
<h2 id='is.active'> Determine Activation State of Edges and Vertices </h2><span id='topic+is.active'></span>

<h3>Description</h3>

<p>Query the activity state of one or more network elements (edges or vertices) for either a single time point or an extended interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.active(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, e = NULL, v = NULL, 
    rule = c("any", "all","earliest","latest"), active.default = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.active_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="network.html#topic+network">network</a></code>. </p>
</td></tr>
<tr><td><code id="is.active_+3A_onset">onset</code></td>
<td>
<p> an optional vector of timepoints that specifies the start of the queried interval(s). This must be accompanied by one of <code>terminus</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="is.active_+3A_terminus">terminus</code></td>
<td>
<p> an optional vector of timepoints that specifies the end of the queried interval(s). This must be accompanied by one of <code>onset</code> or <code>length</code>. </p>
</td></tr>
<tr><td><code id="is.active_+3A_length">length</code></td>
<td>
<p> an optional vector of interval lengths for the queried interval(s). This must be
accompanied by one of <code>onset</code> or <code>terminus</code>. </p>
</td></tr>
<tr><td><code id="is.active_+3A_at">at</code></td>
<td>
<p> an optional vector of single time point(s) to query. </p>
</td></tr>
<tr><td><code id="is.active_+3A_e">e</code></td>
<td>
<p> a vector of edge IDs to evaluate. </p>
</td></tr>
<tr><td><code id="is.active_+3A_v">v</code></td>
<td>
<p> a vector of vertex IDs to evaluate. </p>
</td></tr>
<tr><td><code id="is.active_+3A_rule">rule</code></td>
<td>
<p> a character string indicating the definition of &quot;active&quot; for this query:  <code>any</code> (default) to define active as any active spell during the interval, or <code>all</code> to define active as being active over the entire interval.  Because we are only testing for activity, the values of <code>earliest</code> and <code>latest</code> are equivilent to <code>any</code> and are only included for compatibility with calling functions.  </p>
</td></tr>
<tr><td><code id="is.active_+3A_active.default">active.default</code></td>
<td>
<p>logical; should elements without an activity attribute be regarded as active by default?  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to query the activity status of an element at single time point, or over an interval.  
The specification of timepoints and intervals is the same as for the <code><a href="#topic+activate">activate</a></code> function.  
The general rules are discussed in <code><a href="#topic+activity.attribute">activity.attribute</a></code>.
</p>
<p>To query status at a single time point, use one of the following:
</p>

<ul>
<li><p> the <code>at</code> argument, or 
</p>
</li>
<li><p> set <code>onset=terminus</code>.
</p>
</li></ul>
 
<p>To query status over a particular interval, one of the following valid combinations of <code>onset</code>, <code>terminus</code> and <code>length</code> is required:
</p>

<ul>
<li> <p><code>onset</code> and <code>terminus</code>.
</p>
</li>
<li> <p><code>onset</code> and <code>length</code>.
</p>
</li>
<li> <p><code>terminus</code> and <code>length</code>.  
</p>
</li>
<li><p> or, you can specify no information.
</p>
</li></ul>

<p>If the query is specified with no timing information the spell is defined as <code>(-Inf,Inf)</code>.
The query interval spans the period from the onset (inclusive) to the terminus (exclusive), so [onset,terminus).
</p>
<p>There are some special behaviors associated with the arguments  <code>Inf</code> and <code>-Inf</code>.
</p>

<ul>
<li><p> The open-ended interval <code>c(-Inf,x)</code> includes <code>-Inf</code>.  For consistency, we also allow the open-ended interval <code>c(x, Inf)</code> to include <code>Inf</code>. 
Thus [onset, terminus) will be interpreted as [onset, terminus] when terminus = <code>Inf</code>.
</p>
</li>
<li><p> Queries for intervals specified by <code>c(Inf, Inf)</code> or <code>c(-Inf, -Inf)</code> are ignored.
</p>
</li></ul>

<p>If the <code>e</code> argument includes edge ids corresponding to deleted edges, a warning will be generated because the length of the output vector will not match the vector of edge ids.  In this case it is a good idea to use <code><a href="network.html#topic+valid.eids">valid.eids</a></code> to determine the edge ids.
</p>


<h3>Value</h3>

<p>A logical vector indicating the activity states of vertices or edges.  In the case of vertices, the elements of the vector correspond to the vertex ids provided via the <code>v</code> paramter.  In the edges case, if the network has deleted edges, they will be omited from the result so the elements of the vector may not correspond to the eids provided via the <code>e</code> parameter.
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+activate">activate</a></code>, <code><a href="network.html#topic+valid.eids">valid.eids</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle &lt;- network.initialize(3)  # create a toy network
add.edge(triangle,1,2)    # add an edge between vertices 1 and 2
add.edge(triangle,2,3)    # add more edges
add.edge(triangle,3,1)

# turn on all edges at time 1 only (0 length spell)
activate.edges(triangle,at=1) 
# activate edge (1,2) from t=2 to t=3
activate.edges(triangle,onset=2, terminus=3,
               e=get.edgeIDs(triangle,v=1,alter=2))
# activate edge (2,3) from t=4 for 2 time lengths
activate.edges(triangle,onset=4, length=2, 
               e=get.edgeIDs(triangle,v=2,alter=3))

# are the edges active at a particular time?
is.active(triangle, at=1, e=1:3)
is.active(triangle, at=4, e=seq_along(triangle$mel))

# delete an edge
delete.edges(triangle,e=2)
is.active(triangle, at=4, e=seq_along(triangle$mel))
# gives warning, and only two values returned, which edges are they?
# much safer to use
is.active(triangle, at=4, e=valid.eids(triangle))



</code></pre>

<hr>
<h2 id='nd_test_nets'>
networkDynamic testing networks
</h2><span id='topic+nd_test_nets'></span>

<h3>Description</h3>

<p>A list of <code><a href="#topic+networkDynamic">networkDynamic</a></code> objects to be used for testing package functions. Each network exemplifies a possible extreme case for the data structure representation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nd_test_nets)</code></pre>


<h3>Format</h3>

<p>A list of <code><a href="#topic+networkDynamic">networkDynamic</a></code> objects. Each element is named with a short description
</p>


<h3>Details</h3>

<p>This list of networks is intended for testing purposes.  Each element is a network with a different unusual configuration of the <code><a href="#topic+networkDynamic">networkDynamic</a></code> data structure.  The idea is that the items on the list can be used when testing functions that use <code>networkDynamic</code> objects to make sure that they can properly handle (or explicitly reject) a wide range of network configurations and parameter settings. A short description of each test case can be printed with <code>names(nd_test_nets)</code>. Note that these test cases are intended for checking that functions process the data structures without error, but in most cases the networks are too trivial to be useful in testing algorithm results. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(nd_test_nets)
# print the list of test cases
names(nd_test_nets)
# check that network.size.active works
# (or at least doesn't fail)
# for many types of networks
lapply(nd_test_nets,network.size.active,at=1)

</code></pre>

<hr>
<h2 id='net.obs.period'>
Network attribute describing the observation properties of a networkDynamic object
</h2><span id='topic+net.obs.period'></span>

<h3>Description</h3>

<p><code>net.obs.period</code> is an optional network-level attribute that gives meta-information about the characteristics of the observations, time range and temporal model of a <code>networkDynamic</code> object.  
</p>


<h3>Format</h3>

<p>If the attribute is present, it is required to have a specific structure.  It is a 4-element <code>list</code> with named values.
</p>

<ul>
<li><p> the <code>observations</code> element is a list of two-elment spell vectors that give the onset and terminus of the time period(s) during which the network was observed or simulated
</p>
</li>
<li> <p><code>mode</code> A string indicating the temporal model of the network: either <code>discrete</code> or <code>continuous</code>
</p>
</li>
<li> <p><code>time.increment</code> is an indicator of the &lsquo;natural&rsquo; time unit for iterating over the network (primarily useful for discrete time models)
</p>
</li>
<li> <p><code>time.unit</code> is the name of the unit used by all of the spells in the object: often set to <code>step</code> for discrete simulations. 
</p>
</li></ul>



<h3>Details</h3>

<p>Some functions that work with <code>networkDynamic</code> objects need to know information about the observation design of the network. Is it discrete or continuous time model? When did the observation (or simulation) of the network processes start and end? What are the time units? This information may be stored in the <em>optional</em> <code>net.obs.period</code> network attribute. 
</p>
<p>Some examples of possible <code>net.obs.period</code> values for various networks:
</p>

<ul>
<li><p>  for an stergm output it might be:
<code>list(observations=list(c(0,100)),mode="discrete", time.increment=1,time.unit="step")</code>
</p>
</li>
<li><p> For Lin's windsurfers , which is missing all observations on day 25:
<code>list(observations=list(c(0,25),c(26,31)),mode="discrete", time.increment=1,time.unit="day")</code>
</p>
</li>
<li><p> For McFarland's classroom data:
<code>list(observations=list(c(0,55),),mode="continuous", time.increment=NA,time.unit="minute")</code>
</p>
</li>
<li><p> A fictitious instantaneous panel example :
<code>list(observations=list(c(0,0),c(21,21),c(56.5,56.5),c(68,68)),mode="discrete", time.increment=0,time.unit="seconds")</code>
</p>
<p>The values of the <code>net.obs.period</code> object are not checked for consistency with activity spells of the network itself. 
</p>
</li></ul>



<h3>References</h3>

<p>Link to page on statnet wiki?
</p>


<h3>See Also</h3>

<p>Several of the <code><a href="#topic+networkDynamic">networkDynamic</a></code> converter functions set the <code>net.obs.period</code> attribute on their output object. See also <code><a href="#topic+activity.attribute">activity.attribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nd&lt;-network.initialize(5)
activate.vertices(nd,onset=0,terminus=100)
set.network.attribute(nd,'net.obs.period',list(observations=list(c(0,100)),
                      mode="discrete", time.increment=1,time.unit="step"))
# find the overall `expected' time range for the object
range(get.network.attribute(nd,'net.obs.period')$observations)
</code></pre>

<hr>
<h2 id='network.collapse'>
Convert a time range of a networkDynamic object into a static network object.
</h2><span id='topic+network.collapse'></span><span id='topic++25k+25'></span>

<h3>Description</h3>

<p>This function provides an easy way to sensibly collapse the time-related information in a <code>networkDynamic</code> object and return a plain <code>network</code> object with a set of vertices, edges, and attributes that appropriately correspond to those appearing in the original <code>networkDynamic</code> object during the query interval. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.collapse(dnet, onset = NULL, terminus = NULL, at = NULL, length = NULL, 
                 rule = c("any", "all","earliest","latest"), active.default = TRUE, 
                 retain.all.vertices=FALSE, rm.time.info=TRUE, ...)
dnet%k%at                 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.collapse_+3A_dnet">dnet</code></td>
<td>

<p>A <code>networkDynamic</code> object with possible vertex, edge, network, and attribute spell information. 
</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_onset">onset</code></td>
<td>
<p> optionally, the start of the specified interval.  This must be  accompanied by one of <code>terminus</code> or <code>length</code>.
</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_terminus">terminus</code></td>
<td>
<p> optionally, the end of the specified interval.  This must be  accompanied by one of <code>onset</code> or <code>length</code>.
</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_length">length</code></td>
<td>
<p> optionally, the length of the specified interval. This must be  accompanied by one of <code>onset</code> or <code>terminus</code>.
</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_at">at</code></td>
<td>
<p> optionally, a single time point.</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_rule">rule</code></td>
<td>
<p> a text string for defining &ldquo;active&rdquo; for this call:  <code>any</code> if elements active at any time during the interval are to be used, or <code>all</code> if elements must be active over the entire interval. The value <code>earliest</code> behaves like <code>any</code> but specifies that when multiple attribute values are encountered, only the earliest will be returned. The value <code>latest</code> behaves like <code>any</code> but specifies that when multiple attribute values are encountered, only the latest will be returned. </p>
</td></tr>
<tr><td><code id="network.collapse_+3A_active.default">active.default</code></td>
<td>
<p> logical; should elements without an activity attribute be regarded as active by default?</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_retain.all.vertices">retain.all.vertices</code></td>
<td>
<p> logical; should the extracted network retain all vertices, ignoring the vertex activity spells of x in order to ensure that the network returned has the same size as dnet?</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_rm.time.info">rm.time.info</code></td>
<td>
<p>logical; if <code>TRUE</code>, the <code><a href="#topic+net.obs.period">net.obs.period</a></code> attribute will be removed (if it exists), and the activity summary attributes <code>activity.count</code> and <code>activity.duration</code> will not be attached to edges and vertices</p>
</td></tr>
<tr><td><code id="network.collapse_+3A_...">...</code></td>
<td>
<p> Possible additional arguments (not yet invented) to handle aggregation of attributes. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>First performs a <code><a href="#topic+network.extract">network.extract</a></code> on the passed networkDynamic object with the specified time range to get the appropriate set of active edges.  Extracts appropriate values from any dynamic attributes and stores them as static attributes and optionally (if <code>rm.time.info=FALSE</code>) computes some crude summary attributes for edge and vertex spells (<code>activity.count</code>, <code>activity.duration</code>),. Then removes all <code><a href="#topic+activity.attribute">activity.attribute</a></code> and <code><a href="#topic+dynamic.attributes">dynamic.attributes</a></code> information and returns a plain network without the <code>networkDynamic</code> class.
</p>
<p>The <code>%k%</code> operator (&lsquo;K&rsquo; for kollapse) is a shortcut for the 'at' version of <code>network.collapse</code>.
</p>
<p>If no temporal arguments are specified, defaults to collapsing entire time range of the input network (<code>onset=-Inf,terminus=Inf</code>). Original network is not modified. 
</p>
<p>Arbitrary attribute values may be returned when query spells with a duration are used for continuous time networks (i.e. anything other than 'at') or query spells that don't line up with the discrete units for discrete time networks are used.  If a query spell intersects with multiple attribute values, a warning will be produced and only the earliest value will be used (see <code><a href="#topic+get.vertex.attribute.active">get.vertex.attribute.active</a></code>). To avoid ambiguity (and the warning), appropriate handling can be specified by setting <code>rule='earliest'</code> or <code>rule='latest'</code> to indicate which of the multiple values should be returned. 
</p>
<p>The duration values returned for edges do not account for any potential &lsquo;censoring&rsquo; of observations in the original network. 
</p>


<h3>Value</h3>

<p>A new 'static' <code>network</code> object corresponding to the specified time range of the <code>networkDynamic</code> argument.  If the original network contained dynamic TEA attributes (i.e. 'weight.active'), the appropriate (if possible) value is queried and stored as a non-TEA attribute ('weight').
</p>


<h3>Note</h3>

<p>This function may be quite computationally expensive if the network contains lots of attributes. For many tasks it is possible to avoid collapsing the network by using <code><a href="#topic+is.active">is.active</a></code>, the dynamic <code><a href="#topic+network.extensions">network.extensions</a></code>, and the <code><a href="#topic+attribute.activity.functions">attribute.activity.functions</a></code>.
</p>


<h3>Author(s)</h3>

<p>Skye Bender-deMoll
</p>


<h3>See Also</h3>

<p>See also  <code><a href="#topic+network.extract">network.extract</a></code> for extracting sub-ranges of a networkDynamic, <code><a href="#topic+get.vertex.attribute.active">get.vertex.attribute.active</a></code> for more on TEA attributes, and <code><a href="#topic+as.network.networkDynamic">as.network.networkDynamic</a></code> for stripping the the networkDynamic class from an object without the expense of modifying or removing the activity attributes. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a network with some basic activity
test&lt;-network.initialize(5)
add.edges.active(test, tail=c(1,2,3), head=c(2,3,4),onset=0,terminus=1)
activate.edges(test,onset=3,terminus=5)
activate.edges(test,onset=-2,terminus=-1)

# collapse the whole thing
net &lt;-network.collapse(test)
is.networkDynamic(net)
get.vertex.attribute(net,'activity.duration')
get.edge.value(net,'activity.count')
get.edge.value(net,'activity.duration')

# add a dynamic edge attribute
activate.edge.attribute(test,'weight',5,onset=3,terminus=4)
activate.edge.attribute(test,'weight',3,onset=4,terminus=5)

# collapse with an interval query
net3&lt;-network.collapse(test,onset=3,terminus=4)
get.edge.value(net3,'weight')

# note that if we use a query that intersects mutiple 
# attribute values it will generate a warning. 
# try commented line below:

# net3&lt;-network.collapse(test,onset=3,terminus=5)

# but should be safe from attribute issues when
# collapsing with a point query
net3&lt;-network.collapse(test,at=3)
get.edge.value(net3,'weight')

# can use operator version for point query instead
net3&lt;-test%k%4.5
get.edge.value(net3,'weight')



</code></pre>

<hr>
<h2 id='network.dynamic.check'> Verify a Dynamically Extended Network Object </h2><span id='topic+network.dynamic.check'></span><span id='topic+is.networkDynamic'></span>

<h3>Description</h3>

<p>Checks a networkDynamic object for any activity information that is not correctly specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.dynamic.check(x, verbose = TRUE, complete = TRUE)
is.networkDynamic(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.dynamic.check_+3A_x">x</code></td>
<td>
<p> an object, hopefully of class <code>networkDynamic</code>. </p>
</td></tr>
<tr><td><code id="network.dynamic.check_+3A_verbose">verbose</code></td>
<td>
<p> logical; should output messages be printed to the
user? </p>
</td></tr>
<tr><td><code id="network.dynamic.check_+3A_complete">complete</code></td>
<td>
<p> logical; should a complete test be ran, including
checks of the activity matrices for edges and vertices, versus a
check of only edge activity invovling non-active vertices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>network.dynamic.check</code> runs three types of checks on an input object:
</p>

<ol>
<li><p>If a complete test is run, vertex spell matrices and edge spell
matrices (if any) are checked for legality, specifically these are
checked for correct dimensionality and proper spell ordering.
</p>
</li>
<li><p>If vertex and edge spell matrices are correctly specified or
assumed to be using <code>complete=FALSE</code>, incident vertices of
active edges (if any) are checked to ensure that they are also
active during the specified period(s).
</p>
</li>
<li><p>If a complete test is run, and any TEA attributes are attached to the network, vertices or edges, they will be checked for correct structure.  
</p>
</li></ol>

<p>If spell matrices are only acted upon by network or
networkDynamic methods, there is no need to run a complete test -
correct dimensionality and spell ordering are guaranteed.
</p>
<p><code>is.networkDynamic</code> checks if its argument has the class 'networkDynamic'.
</p>


<h3>Value</h3>

<p>For <code>network.dynamic.check</code>: A list of logical vectors, one for
each network component checked: 
</p>

<ul>
<li><p><code>$vertex.checks</code> : Whether the spell matrix of each vertex (if any)
is correctly specified
</p>
</li>
<li><p><code>$edge.checks</code> : Whether the spell matrix of each edge (if any)
is correctly specified
</p>
</li>
<li><p><code>$dyad.checks</code> : Corresponding to edges, whether the incident vertices
of each edge are active when the edge is active
</p>
</li>
<li><p><code>$vertex.tea.checks</code> : Corresponding to vertices, whether the vertex has 
correctly formed TEA attributes
</p>
</li>
<li><p><code>$edge.tea.checks</code> : Corresponding to edges, whether the edge has 
correctly formed TEA attributes
</p>
</li>
<li><p><code>$network.tea.checks</code> : Single boolean, whether the network TEA attributes are formed correctly
</p>
</li>
<li><p><code>$net.obs.period.check</code> : NULL, if no <code>net.obs.period</code> network attribute is present, otherwise a single boolean, whether the attribute is formed correctly. 
</p>
</li></ul>

<p>For <code>is.networkDynamic</code>: a boolean which is true if the class matches
</p>


<h3>Author(s)</h3>

<p> Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>, Skye Bender-deMoll </p>


<h3>See Also</h3>

 <p><code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+net.obs.period">net.obs.period</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  test &lt;-network.initialize(2) # make a network
  # only activate one vertex
  activate.vertices(test,onset=2,length=5,v=1) 
  test[1,2] &lt;-1 # add an edge between the verticies
  # activate the edge for a spell not including vertex spell
  activate.edges(test,onset=0,terminus=7, e=1) 
  network.dynamic.check(test) # find the bad edge
  
  # name a vertex attrible like a TEA but with the wrong structure
  set.vertex.attribute(test,'letters','a')
  network.dynamic.check(test)
</code></pre>

<hr>
<h2 id='network.extensions'> Dynamically Extended Core Network Functions </h2><span id='topic+network.extensions'></span><span id='topic+get.edgeIDs.active'></span><span id='topic+get.edges.active'></span><span id='topic+get.neighborhood.active'></span><span id='topic+is.adjacent.active'></span><span id='topic+network.dyadcount.active'></span><span id='topic+network.edgecount.active'></span><span id='topic+network.naedgecount.active'></span><span id='topic+network.size.active'></span>

<h3>Description</h3>

<p>Various core functions from the <a href="network.html#topic+network">network</a> package, with specialized extensions for handling dynamic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.edgeIDs.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    alter = NULL, neighborhood = c("out", "in", "combined"), 
    rule = c("any", "all", "earliest", "latest"), na.omit = TRUE, active.default = TRUE)
get.edges.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    alter = NULL, neighborhood = c("out", "in", "combined"), 
    rule = c("any", "all", "earliest", "latest"), na.omit = TRUE, active.default = TRUE)
get.neighborhood.active(x, v, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    type = c("out", "in", "combined"), rule = c("any", "all", "earliest", "latest"), 
    na.omit = TRUE, active.default = TRUE)

is.adjacent.active(x, vi, vj, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"), na.omit = FALSE, active.default = TRUE)

## S3 method for class 'active'
network.dyadcount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    na.omit = TRUE, active.default = TRUE,...)
## S3 method for class 'active'
network.edgecount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    rule = c("any", "all", "earliest", "latest"),
    na.omit = TRUE, active.default = TRUE,...)
## S3 method for class 'active'
network.naedgecount(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    active.default = TRUE,...)
## S3 method for class 'active'
network.size(x, onset = NULL, terminus = NULL, length = NULL, at = NULL, 
    rule = c("any", "all", "earliest", "latest"),
    active.default = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.extensions_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="network.html#topic+network">network</a></code></p>
</td></tr>
<tr><td><code id="network.extensions_+3A_v">v</code></td>
<td>
<p> a required vertex ID. </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_vi">vi</code></td>
<td>
<p>an optional vertex ID (tail).</p>
</td></tr>
<tr><td><code id="network.extensions_+3A_vj">vj</code></td>
<td>
<p>an optional vertex ID (head).</p>
</td></tr>
<tr><td><code id="network.extensions_+3A_onset">onset</code></td>
<td>
<p> an optional start time for the selection interval. This must be  accompanied by one of <code>terminus</code> or <code>length</code>.  </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_terminus">terminus</code></td>
<td>
<p> an optional end time for the selection interval.  This must be accompanied by one of <code>onset</code> or <code>length</code>.  </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_length">length</code></td>
<td>
<p> the length of the selection interval. This must be  accompanied by one of <code>onset</code> or <code>terminus</code></p>
</td></tr>
<tr><td><code id="network.extensions_+3A_at">at</code></td>
<td>
<p> a time point for selecting edges/vertices. </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_alter">alter</code></td>
<td>
<p> optionally, the ID of another vertex. </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_neighborhood">neighborhood</code></td>
<td>
<p> a text string that indicates whether we are interested in in-edges, out-edges, or both (relative to <code>v</code>).  </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_type">type</code></td>
<td>
<p> a text string that functions as <code>neighborhood</code>, above, for vertex neighborhoods. </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_rule">rule</code></td>
<td>
<p> a text string for defining &ldquo;active&rdquo; for this call:  <code>any</code> (default) to select elements appearing at any time during the specified interval, or <code>all</code> to select only elements active for the entire interval. For these functions, the values of <code>earliest</code> and <code>latest</code> are equivalent to <code>any</code> and are only included for consistency.</p>
</td></tr>
<tr><td><code id="network.extensions_+3A_na.omit">na.omit</code></td>
<td>
<p> logical; should we omit missing edges? </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_active.default">active.default</code></td>
<td>
<p> logical; should elements without an activity attribute be regarded as active by default? </p>
</td></tr>
<tr><td><code id="network.extensions_+3A_...">...</code></td>
<td>
<p>possible additional argumenets</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are &ldquo;dynamically extended&rdquo; versions of their standard <a href="network.html#topic+network">network</a> counterparts.  As such, conventional aspects of their behavior can be found on their respective manual pages (see below).  In all cases, the sole difference between the extended and non-extended versions lies in the ability of the user to specify a time point (or interval), such that only vertices and edges active at the indicated time (or during the indicated interval) are employed by the routine.
</p>

<p>For elements (edges and vertices) lacking an activity attribute, the <code>active.default</code> argument determines appropriate treatment.  By default, all such elements are considered active.
</p>


<h3>Value</h3>

<p>The return value matches that of the original function, suitably filtered.
</p>


<h3>Note</h3>

<p> The current temporal implementation of these routines will be slower compared to the non-temporal versions.  Do not use them unless you have to. </p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p> Butts, C. T.  (2008).  &ldquo;network: a Package for Managing Relational Data in R.&rdquo;  <em>Journal of Statistical Software</em>, 24(2).  <a href="https://www.jstatsoft.org/v24/i02/">https://www.jstatsoft.org/v24/i02/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+network.extract">network.extract</a></code>, <code><a href="#topic+is.active">is.active</a></code>, <code><a href="network.html#topic+get.edges">get.edgeIDs</a></code>, <code><a href="network.html#topic+get.edges">get.edges</a></code>, <code><a href="network.html#topic+get.neighborhood">get.neighborhood</a></code>, <code><a href="network.html#topic+is.adjacent">is.adjacent</a></code>, <code><a href="network.html#topic+network.dyadcount">network.dyadcount</a></code>, <code><a href="network.html#topic+network.edgecount">network.edgecount</a></code>, <code><a href="network.html#topic+network.naedgecount">network.naedgecount</a></code>, <code><a href="network.html#topic+network.size">network.size</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## is.adjacent.active
triangle &lt;- network.initialize(3)    # create a toy network
add.edge(triangle,1,2)               # add an edge between vertices 1 and 2
add.edge(triangle,2,3)               # add a more edges
add.edge(triangle,3,1)
is.adjacent.active(triangle,vi=1,vj=2,onset=2,length=1)

## get.edges.active
net &lt;-network.initialize(5)
net[1,2]&lt;-1;
net[2,3]&lt;-1;
activate.edges(net,onset=1,terminus=Inf,e=1)
activate.edges(net,onset=2,terminus=3,e=2)
get.edges.active(net,v=2,at=1)
get.edges.active(net,v=2,at=1, neighborhood="combined")
get.edges.active(net,v=2,at=2, neighborhood="combined")

## get the ids of the active edges instead (could be multiple incident edges)
get.edgeIDs.active(net,v=2,at=2)

## or get ids of the active nodes in a vertex neighborhood
get.neighborhood.active(net,v=2,at=2)

# returns both edges
get.edges.active(net,v=2,onset=1, terminus=3, neighborhood="combined", rule='any')
# returns only one edge (e=2)
get.edges.active(net,v=2,onset=1, terminus=3, neighborhood="combined", rule='all')

## network.edgecount.active
network.edgecount.active(net, at=1, active.default=FALSE)
network.edgecount.active(net, at=2, active.default=FALSE)
network.edgecount.active(net, at=5, active.default=FALSE)

</code></pre>

<hr>
<h2 id='network.extract'> Temporal Extracts/Cross-sections of Dynamically Extended Network Objects </h2><span id='topic+network.extract'></span><span id='topic++25t+25'></span>

<h3>Description</h3>

<p>Given a networkDynamic and a specified time point (or interval), return a reduced networkDynamic  that only contains the vertices and edges active at the given point or over the given interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.extract(x, onset = NULL, terminus = NULL, length = NULL, at = NULL,
    rule = c("any", "all"), active.default = TRUE, retain.all.vertices = FALSE,
    trim.spells=FALSE)

x %t% at
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.extract_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="network.html#topic+network">network</a></code>. </p>
</td></tr>
<tr><td><code id="network.extract_+3A_onset">onset</code></td>
<td>
<p> optionally, the start of the specified interval.  This must be  accompanied by one of <code>terminus</code> or <code>length</code>.</p>
</td></tr>
<tr><td><code id="network.extract_+3A_terminus">terminus</code></td>
<td>
<p> optionally, the end of the specified interval.  This must be  accompanied by one of <code>onset</code> or <code>length</code>.</p>
</td></tr>
<tr><td><code id="network.extract_+3A_length">length</code></td>
<td>
<p> optionally, the length of the specified interval. This must be  accompanied by one of <code>onset</code> or <code>terminus</code>.</p>
</td></tr>
<tr><td><code id="network.extract_+3A_at">at</code></td>
<td>
<p> optionally, a single time point.</p>
</td></tr>
<tr><td><code id="network.extract_+3A_rule">rule</code></td>
<td>
<p> a text string for defining &ldquo;active&rdquo; for this call:  <code>any</code> if elements active at any time during the interval are to be used, or <code>all</code> if elements must be active over the entire interval. </p>
</td></tr>
<tr><td><code id="network.extract_+3A_active.default">active.default</code></td>
<td>
<p> logical; should elements without an activity attribute be regarded as active by default? </p>
</td></tr>
<tr><td><code id="network.extract_+3A_retain.all.vertices">retain.all.vertices</code></td>
<td>
<p> logical; should the extracted network retain all vertices, ignoring the vertex activity spells of x in order to ensure that the network returned has the same size as x?</p>
</td></tr>
<tr><td><code id="network.extract_+3A_trim.spells">trim.spells</code></td>
<td>
<p> logical; should the spells of vertices, edges and their attributes in the extracted network be trimmed to match the query range? (Sensible thing to do, but could be expensive)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the purposes of extraction, edges are only considered active over some interval if: the edge itself is active over this time period, and both of the incident vertices are also active over the given time period.
</p>
<p>When <code>retain.all.vertices=FALSE</code> (the default), the function has the following behavior:
</p>

<ul>
<li><p> If <code>at</code> is used to specify the spell of interest, the returned network consists of all edges and vertices
active at that time point.  
</p>
</li>
<li><p> If an interval is supplied to specify the spell (via <code>onset</code> and one of <code>terminus</code> or <code>length</code>), edges and vertices active
over the specified interval are used.   If <code>rule="any"</code>, then edges and vertices active at any time during the interval are returned; otherwise, only those active during the entire period are returned. 
</p>
</li></ul>

<p>Vertices in the extracted network will have the same order as the original network, with inactive vertices removed. 
</p>
<p>When <code>retain.all.vertices=TRUE</code>
</p>

<ul>
<li><p>All vertices are preserved in the output net to preserved network size and ids.
</p>
</li>
<li><p>if <code>trim.spells=TRUE</code>, 'retained' vertices will be marked as inactive (they will have 'null' spell (Inf,Inf)) 
</p>
</li>
<li><p>Edges that are active (by the specified <code>rule</code>) during the specified spell are included in the returned network (same as above.)
</p>
</li>
<li><p>Edges with one or more inactive vertices still will be removed (even if the vertex is being 'retained' to preserve network size)
</p>
</li></ul>

<p>If a <code><a href="#topic+net.obs.period">net.obs.period</a></code> network attribute is present, its observation spells will be truncated by the onset and terminus of extraction.  If the onset and terminus do not intersect with any observation spells, the '$observations' component will be set to the 'null' spell <code>c(Inf,Inf)</code>.
</p>
<p><code>%t%</code> (the temporal cross-section operator) is  a
simplified (and less flexible) wrapper for <code>network.extract</code> that
returns the network of active vertices and edges at a given time point.
</p>


<h3>Value</h3>

<p>A <code>networkDynamic</code> object containing the active edges and vertices for the specified spell, when <code>retain.all.vertices=FALSE</code>, otherwise the network object containing all vertices, and only those edges active for the specified spell. 
</p>


<h3>Note</h3>

<p>Note that only active vertices are included by default (<code>retain.all.vertices=FALSE</code>).  As a result, the size of the extracted network may be smaller than the original. Vertex and edge ids will be translated, but may not correspond to their original values. If it is necessary to maintain the identities of vertices, see <code><a href="#topic+persistent.ids">persistent.ids</a></code>. 
</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>, skyebend</p>


<h3>See Also</h3>

 <p><code><a href="#topic+is.active">is.active</a></code>, <code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+network.extensions">network.extensions</a></code>, and <code><a href="network.html#topic+get.inducedSubgraph">get.inducedSubgraph</a></code> for a related non-temporal version, <code><a href="#topic+network.collapse">network.collapse</a></code> to squish a <code>networkDynamic</code> object into a static <code>network</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
triangle &lt;- network.initialize(3)    # create a toy network

# add edges with activity
# first add an edge between vertices 1 and 2
add.edges.active(triangle,onset=0,terminus=10,tail=1,head=2)
# add a more edges
add.edges.active(triangle,onset=0,length=4,tail=2,head=3)      
add.edges.active(triangle,at=4.5,tail=3,head=1)

# specify some vertex activity
activate.vertices(triangle,onset=0,terminus=10)
deactivate.vertices(triangle,onset=1,terminus=2,v=3)

degree&lt;-function(x){as.vector(rowSums(as.matrix(x)) 
  + colSums(as.matrix(x)))} # handmade degree function

degree(triangle) # degree of each vertex, ignoring time

degree(network.extract(triangle,at=0))
degree(network.extract(triangle,at=1)) # just look at t=1
degree(network.extract(triangle,at=2))
degree(network.extract(triangle,at=5))

# watch out for empty networks! they are just an empty list
t10 &lt;- network.extract(triangle,at=10)
t10

# notice difference between 'at' syntax and 'onset,terminus'
# when network is not in discrete time
degree(network.extract(triangle,at=4))
degree(network.extract(triangle,onset=4,terminus=5))

# the %t% (time) operator is like an alias for the 'at' extraction syntax
degree(triangle%t%4)

par(mfrow=c(2,2))
#show multiple plots
plot(triangle,main='ignoring dynamics',displaylabels=TRUE)
plot(network.extract(triangle,onset=1,terminus=2),main='at time 1',displaylabels=TRUE)
plot(network.extract(triangle,onset=2,terminus=3),main='at time 2',displaylabels=TRUE)
plot(network.extract(triangle,onset=5,terminus=6),main='at time 5',displaylabels=TRUE)

</code></pre>

<hr>
<h2 id='networkDynamic'>
Convert various forms of network timing information into networkDynamic objects.
</h2><span id='topic+networkDynamic'></span>

<h3>Description</h3>

<p>Converts various forms of temporal data (spell matrices, togles, lists of networks ) describing dynamics of vertices and edges into networkDynamic objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>networkDynamic(base.net = NULL, edge.toggles = NULL, vertex.toggles =NULL, 
                 edge.spells = NULL, vertex.spells = NULL,
                 edge.changes = NULL, vertex.changes = NULL,
                 network.list = NULL, onsets = NULL, termini = NULL,
                 vertex.pid = NULL, start = NULL, end = NULL, 
                 net.obs.period=NULL,verbose=TRUE,create.TEAs = FALSE,
                 edge.TEA.names=NULL,vertex.TEA.names=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="networkDynamic_+3A_base.net">base.net</code></td>
<td>

<p>A network (or network-coearceable) object which will be used to define network-level properties (directedness,etc) of the output network. When constructing from toggles, the edges in base.net give the initially active set of edges and vertices that the activity states will be toggled from. Network and vertex attributes of <code>base.net</code> will be copied to output (unless they are overwritten by dynamic attributes with the same names) 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_edge.spells">edge.spells</code></td>
<td>

<p>A matrix or data.frame of spells specifying edge timing. Assumed to be [onset,terminus,tail vertex.id, head vertex.id]. Any additional columns can loaded as dynamic attributes (see <code>edge.TEA.names</code>)
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_vertex.spells">vertex.spells</code></td>
<td>

<p>A matrix or data.frame of spells specifying vertex timing. Assumed to be [onset,terminus,vertex.id]
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_edge.toggles">edge.toggles</code></td>
<td>

<p>A matrix or data.frame of toggles giving a sequence of activation and deactivation times for toggles.  Columns are assumed to be [toggle time, tail vertex id of the edge, head vertex id of the edge].
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_vertex.toggles">vertex.toggles</code></td>
<td>

<p>A matrix or data.frame of toggles giving a sequence of activation and deactivation times for vertices. Column order assumed to be [time,vertex.id] 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_edge.changes">edge.changes</code></td>
<td>

<p>A matrix or data.frame of edge changes with at least 4 columns, assumed to be [time, tail, head, direction]
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_vertex.changes">vertex.changes</code></td>
<td>

<p>A matrix or data.frame of vertex changes with at least 3 columns, assumed to be [time, vertex.id,direction]
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_network.list">network.list</code></td>
<td>

<p>a list of network objects assumed to describe sequential panels of network observations. Network sizes may vary if some vertices are only active in certain panels. See onsets, termini, vertex.pid. If base.net not specified, first element of list will be used as base.net. Network, vertex, and edge attributes will be converted to TEAs if <code>create.TEAs=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_onsets">onsets</code></td>
<td>

<p>an optional array of onset times to be assigned to the network panels of network.list. defaults to seq(from=0,length=length(network.list)-1) 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_termini">termini</code></td>
<td>

<p>an optional array of terminus times to be assigned to the network panels of network.list defaults to seq(from=1,length=length(network.list) 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_vertex.pid">vertex.pid</code></td>
<td>

<p>an optional name of a vertex attribute to be used as a unique vertex identifier when constructing from a network list with different sized networks.
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_start">start</code></td>
<td>

<p>Optional argument to indicate the earliest time at which any changes in the network could have been observed or simulated; any spells before this time point are considered onset-censored.
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_end">end</code></td>
<td>

<p>Optional argument to indicate the latest time at which any changes in the network could have been observed or simulated; any spells after this time point are considered terminus-censored.
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_net.obs.period">net.obs.period</code></td>
<td>

<p>Optional argument. A structured list for providing additional information about when and how the network was observed. 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_verbose">verbose</code></td>
<td>

<p>Logical, If TRUE (default), status message will be printed about the assumptions made in the conversion process. 
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_create.teas">create.TEAs</code></td>
<td>
<p>If TRUE, Dynamic TEA attributes will be created corresponding to the static attributes appear on the network elements of <code>network.list</code>
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_edge.tea.names">edge.TEA.names</code></td>
<td>
<p>an optional vector of names for the dynamic (TEA) edge attributes to be imported from the extra columns of <code>edge.spells</code> (if <code>create.TEAs=TRUE</code>)
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_vertex.tea.names">vertex.TEA.names</code></td>
<td>
<p>an optional vector of names for the dynamic (TEA) vertex attributes to be imported from the extra columns of <code>vertex.spells</code> (if <code>create.TEAs=TRUE</code>)
</p>
</td></tr>
<tr><td><code id="networkDynamic_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the creating of the network or processing of attached data objects.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides ways to convert multiple forms of timing information for vertices and edges into network dynamic objects. 
</p>


<h4>Converting from lists of networks</h4>

<p>If the timing information is provided in the form of a lists of networks (specified by the <code>network.list</code> argument ) the assumption is that each network is a discrete &lsquo;panel&rsquo; observation indicating the active set vertices and edges.  By default, each observation is assumed to span a unit interval, (so the 1st goes from 0 to 1, 2nd from 1-2, etc). However, the onset and termini of each observation panel can be explicitly specified via the <code>onsets</code> and <code>termini</code> arguments. If the networks in <code>network.list</code> vary in size, the name of a vertex attribute to be used as a persistent id  must be specified using the <code>vertex.pid</code> attribute so that the vertices in each network can be matched up correctly.  If <code>create.TEAs=TRUE</code>, dynamic attributes will be created for any (non-default) attributes appearing in the list of networks.  Otherwise, network and vertex attributes will be copied from the network specified via <code>base.net</code>.  If <code>base.net</code> is not specified, the first element of <code>network.list</code> will be used.  A <code><a href="#topic+net.obs.period">net.obs.period</a></code> will be constructed to describe the range of observations used to construct the network, or one can be specified directly using the <code>net.obs.period</code> argument. 
</p>



<h4>Converting from matrices of spells, changes or toggles</h4>

<p>Alternatively, timing information for edges and vertices can be provided separately as matrices or data.frames in the forms of tables of spells, changes, or toggles.  For vertices, the arguments are <code>vertex.spells</code>, <code>vertex.changes</code> or <code>vertex.toggles</code>. The columns for each argument have a specific order and function, indicated in the argument definitions above. Edge arguments are named similarly <code>edge.spells</code>, <code>edge.changes</code> or <code>edge.toggles</code>. The vertex ids and &lsquo;head&rsquo; and &lsquo;tail&rsquo; ids must be integer index ids.   Network properties (number of vertices, bipartite, directedness, etc) can currently be specified by including a <code>base.net</code> argument to be used as a template, network and vertex attributes will be copied from <code>base.net</code> as well.  If only edge information is provided, the network size will be imputed from the set of edge endpoints.  
</p>
<p>In the <code>edge.toggles</code> case, the edges present in <code>base.net</code> provide the initial state to be toggled from. If a <code><a href="#topic+net.obs.period">net.obs.period</a></code> is not specified directly using the <code>net.obs.period</code> argument one will be constructed.  Since the correct observation information is not known it may not describe the data accurately. Spells data will be assumed to be 'continuous' and where toggles and changes will be assumed to be 'discrete' and the <code>net.obs.period$observations</code> may include infinate values indicating unknown bounds.
</p>
<p>When constructing a network with separate sources of data for vertex and edge timing, edge and vertex activity will not be made consistent if input data is inconsistent &ndash; edges may be active when their incident vertices are inactive, etc.  These situations can be detected using the <code><a href="#topic+network.dynamic.check">network.dynamic.check</a></code> function and possible resolved using one of the <code><a href="#topic+reconcile.activity">reconcile.activity</a></code> functions. 
</p>
<p>Curently, dynamic attributes (TEAs, see <code><a href="#topic+attribute.activity.functions">attribute.activity.functions</a></code>) for edges or vertices (with onset and termination times matching those of the edge or vertex spell) can be loaded in by by setting <code>create.TEAs=TRUE</code> and including additional columns in the <code>edge.spells</code> or <code>vertex.spells</code> argument and specifying a vector of names for the attributes with <code>edge.TEA.names</code> or <code>vertex.TEA.names</code>. Note that when using a <code><a href="base.html#topic+data.frame">data.frame</a></code> to pass in non-numeric attributes, the default behavior of converting strings to factors should be avoided.
</p>




<h3>Value</h3>

<p>A networkDynamic object with vertex and edge timing specified by the input data. It will also print out information about the assumptions it makes while constructing the network.  
</p>


<h3>Note</h3>

<p>This function provides the features that were formerly (in versions &lt; 0.4) called using as.networkDynamic.* syntax. 
</p>


<h3>Author(s)</h3>

<p>Li Wang lxwang@uw.edu, skyebend, statnet team
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+get.edge.activity">get.edge.activity</a></code>,<code><a href="#topic+get.vertex.activity">get.vertex.activity</a></code>, <code><a href="#topic+network.dynamic.check">network.dynamic.check</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# construct network out of a list of panels of varying sizes
# omiting missing day 25
data(windsurferPanels)
dynBeach&lt;-networkDynamic(network.list=beach[-25], vertex.pid="vertex.names",
                        onsets=c(1:24,26:31),termini=c(2:25,27:32))

# read in tsv files for vertex and edge spells and 
# construct network of McFarland classroom interaction data
# see ?cls33_10_16_96 for more info about this data set

# read vertex data
rawVerts&lt;-read.table(paste(path.package('networkDynamic'),
   "/extdata/cls33_10_16_96_vertices.tsv",sep=''),header=TRUE)

# peek at column headings to find ids and times
names(rawVerts)

# read in interation (edge) data
rawEdges&lt;-read.table(paste(path.package('networkDynamic'),
  "/extdata/cls33_10_16_96_edges.tsv",sep=''),header=TRUE)

# peek at column headings to find ids and times
names(rawEdges)


# construct network using vertex and edge timing information
cls33 &lt;-networkDynamic(vertex.spells=rawVerts[,c(3,4,1)],
                       edge.spells=rawEdges[,c(3,4,1,2)])

# add in the unchanging vertex attribute data
set.vertex.attribute(cls33,"sex",as.vector(rawVerts$sex))
set.vertex.attribute(cls33,"role",as.vector(rawVerts$role))

 ## Not run:   # takes 5 seconds, too slow for CRAN checks
# loop over edge data to add the dynamic attributes on the edge
for(r in 1:nrow(rawEdges)){
  # get the id of the edge from its tail and head
  eid &lt;- get.edgeIDs(cls33,v=rawEdges$from_vertex_id[r],
                     alter=rawEdges$to_vertex_id[r])
  activate.edge.attribute(cls33,'interaction_type',rawEdges$interaction_type[r],
          onset=rawEdges$start_minute[r],terminus=rawEdges$end_minute[r],e=eid)
  activate.edge.attribute(cls33,'weight',rawEdges$weight[r],
          onset=rawEdges$start_minute[r],terminus=rawEdges$end_minute[r],e=eid)
}

# convert the set of newcomb panels with rank weights
data(newcomb)
newRankDyn &lt;-networkDynamic(network.list=newcomb.rank)
get.network.attribute.active(newRankDyn,'title',at=3)
as.matrix(network.collapse(newRankDyn,at=5),attrname='rank')


## End(Not run)


</code></pre>

<hr>
<h2 id='networkDynamic-internal'>Internal networkDynamic objects</h2><span id='topic+.First.lib'></span><span id='topic+insert.spell'></span><span id='topic+delete.spell'></span>

<h3>Description</h3>

<p>Internal networkDynamic objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='networkDynamic-package'>
Dynamic Extensions for Network Objects
</h2><span id='topic+networkDynamic-package'></span>

<h3>Description</h3>

<p>Simple interface routines to facilitate the handling of dynamic network objects with different types of temporal data.  This allows the user to create, store and query networks that change over time.  Changes include edges that form and dissolve over time, and vertices that enter or leave the network.  The package also includes support for defining and querying temporally changing attributes of vertices, edges, and network properties. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> networkDynamic</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-09-25</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> network</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code>networkDynamic</code> package provides support for a simple family of dynamic extensions to the <code><a href="network.html#topic+network">network</a></code> class; these employ the standard <code>network</code> attribute functionality (and hence the resulting objects are still compatible with all conventional routines), but greatly facilitate the practical storage, manipulation and query of dynamic network data. 
</p>
<p>The basis for the dynamic extensions is described in <a href="#topic+activity.attribute">activity.attribute</a>.  Dynamic attributese are explained in <a href="#topic+attribute.activity.functions">attribute.activity.functions</a>.  Id systems which are persistent throughout manipulations and changes in network size are explained in <a href="#topic+persistent.ids">persistent.ids</a>. Other core routines can be found in the links below.
</p>
<p>Additional example data sets can be found in the <code>networkDynamicData</code> package. 
</p>


<h3>Author(s)</h3>

<p>Originally created by Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>, 
</p>
<p>Current Maintainer: Skye Bender-deMoll <a href="mailto:skyebend@uw.edu">skyebend@uw.edu</a>
</p>
<p>Contributions from: 
Pavel Krivitsky <a href="mailto:pavel@uow.edu.au">pavel@uow.edu.au</a>,
Ayn Leslie-Cook <a href="mailto:aynlc3@uw.edu">aynlc3@uw.edu</a>, 
David Hunter <a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a>,
Li Wang <a href="mailto:lxwang@gmail.com">lxwang@gmail.com</a>,
Kirk Li <a href="mailto:kirkli@uw.edu">kirkli@uw.edu</a>,
StevenGoodreau <a href="mailto:goodreau@uw.edu">goodreau@uw.edu</a>,
Zack Almquist <a href="mailto:almquist@uci.edu">almquist@uci.edu</a>, 
Jeffrey Horner <a href="mailto:jeffrey.horner@gmail.com">jeffrey.horner@gmail.com</a>,
Martina Morris <a href="mailto:morrism@u.washington.edu">morrism@u.washington.edu</a>,
Michal Bojanowski <a href="mailto:michal2992@gmail.com">michal2992@gmail.com</a>
</p>
<p>With support from the statnet team <a href="https://statnet.org">https://statnet.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activity.attribute">activity.attribute</a></code>, <code><a href="#topic+activate">activate</a></code>, <code><a href="#topic+is.active">is.active</a></code>, <code><a href="#topic+network.extract">network.extract</a></code>, <code><a href="#topic+network.extensions">network.extensions</a></code> <code><a href="network.html#topic+network">network</a></code> 
</p>

<hr>
<h2 id='Newcomb'>Newcomb's Fraternity Networks</h2><span id='topic+Newcomb'></span><span id='topic+newcomb'></span><span id='topic+newcomb.rank'></span><span id='topic+Newcomb.rank'></span>

<h3>Description</h3>

<p>These 14 networks record weekly sociometric preference rankings
from 17 men attending the University of Michigan in the fall
of 1956; Data were collected longitudinally over 15 weeks,
although data from week 9 are missing.
</p>
<p>The men were recruited to live in off-campus (fraternity)
housing, rented for them as part of the Michigan Group Study
Project supervised by Theodore Newcomb from 1953 to 1956. All
were incoming transfer students with no prior acquaintance of
one another.
</p>
<p>The data set contains two longitudinal networks as <code>network.list</code>.
</p>
<p><code>newcomb.rank</code> is a
<code>network.list</code> object with 14 networks. Each network is complete and the
edge value <code>rank</code> is the preference of the <code class="reqn">i</code>th men for the <code class="reqn">j</code>th
man from <code>1</code> through <code>16</code>.  A <code>1</code> indicates first 
preference, and no ties were allowed.
</p>
<p><code>newcomb</code> is a <code>network.list</code> object that has binary
edge values but is similar in structure to <code>newcomb.rank</code>
and derived from it. Each network has a tie from the <code class="reqn">i</code>th
men to the <code class="reqn">j</code>th man if <code class="reqn">i</code> had a preference for
<code class="reqn">j</code> of 8 or less. Otherwise there is not tie from <code class="reqn">i</code>
to <code class="reqn">j</code>. Note that since these are ranks, the degree of each vertex (and the total number of edges) does not vary over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(newcomb)</code></pre>


<h3>Details</h3>

<p>Use <code>data(package="netdata")</code> to get a full list of networks.</p>


<h3>Licenses and Citation</h3>

<p>If the source of the data set does not specified otherwise,
this data set is protected by the Creative Commons License
<a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set the original authors
should be cited.  In addition this package should be cited as:
</p>
<p>Mark S. Handcock, David Hunter, Carter T. Butts, Steven M. Goodreau,
and Martina Morris. 2003 
<em>statnet: An R package for the Statistical Modeling of Social Networks</em>
<br />
<a href="https://statnet.org/">https://statnet.org/</a>
and the source should be cited as:
</p>
<p>Vladimir Batagelj and Andrej Mrvar (2006): <em>Pajek datasets</em>
<br />
<a href="http://vlado.fmf.uni-lj.si/pub/networks/data/">http://vlado.fmf.uni-lj.si/pub/networks/data/</a> 
</p>


<h3>Source</h3>

<p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/ucidata.htm#newfrat">http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/ucidata.htm#newfrat</a></p>


<h3>References</h3>

<p>See the link above. 
Newcomb T. (1961). The acquaintance process. New York: Holt, Reinhard and Winston.\
Nordlie P. (1958). A longitudinal study of interpersonal attraction in a natural group setting. Unpublished doctoral dissertation, University of Michigan.\
White H., Boorman S. and Breiger R. (1977). Social structure from multiple networks, I. Blockmodels of roles and positions. American Journal of Sociology, 81, 730-780. 
</p>


<h3>See Also</h3>

<p>network, sna</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(newcomb)
</code></pre>

<hr>
<h2 id='persistent.ids'>
Use and manipulate persistent ids of network elements
</h2><span id='topic+persistent.ids'></span><span id='topic+vertex.pid.check'></span><span id='topic+edge.pid.check'></span><span id='topic+get.vertex.id'></span><span id='topic+get.vertex.pid'></span><span id='topic+get.edge.id'></span><span id='topic+get.edge.pid'></span><span id='topic+initialize.pids'></span>

<h3>Description</h3>

<p>Persistent ids (pids) are unique values attached to vertices or edges which remain unchanged throughout network manipulation and extraction processes. The &ldquo;vertex.pid&rdquo; of a vertex is an overall data-set id, unlike the &ldquo;vertex.id&rdquo; which is an index dependent on network size.  These functions provide ways to look up vertex.pids from vertex.ids (and the other way around) and also provide necessary modifications to some standard network functions to safely work with pids. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vertex.id(nd, pid)

get.vertex.pid(nd, id)

get.edge.id(nd, pid)

get.edge.pid(nd, id)

initialize.pids(nd)

vertex.pid.check(nd)

edge.pid.check(nd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persistent.ids_+3A_nd">nd</code></td>
<td>

<p>a <code>network</code> or <code>networkDynamic</code> object to be modified 
</p>
</td></tr>
<tr><td><code id="persistent.ids_+3A_pid">pid</code></td>
<td>
<p>persistent id(s) of the network element(s) for which the network-specific id(s) should be returned</p>
</td></tr>
<tr><td><code id="persistent.ids_+3A_id">id</code></td>
<td>
<p>network-specific (index) id(s)  of the network element for which the persistent id(s) should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The persistent id functionality is an optional feature of <code>networkDynamic</code> objects. If a network-level attribute named <code>vertex.pid</code> exists, its value is required to be the name of a vertex attribute that can safely be used as a vertex.pid. If it is set to <code>NULL</code>, pids will be ignored.   A vertex.pid must have a unique value for all vertices. Persistent ids for edges function in the same way, except the attribute is named <code>edge.pid</code>.
</p>
<p>Some existing network code uses the <code>vertex.names</code> attributes of networks as a persistent id without checking that it is unique. It is possible to indicate that <code>vertex.names</code> can safely be used as a vertex.pid by setting <code>vertex.pid</code> to <code>'vertex.names'</code>
</p>
<p>The function <code>initialize.pids</code> can be used to create a set of pids on all existing vertices (named <code>vertex.pid</code> and edges named <code>edge.pid</code>). The pids are currently initialized with pseudo-random hex strings using the <code><a href="base.html#topic+tempfile">tempfile</a></code> function (something like <code>'4ad912252bc2'</code>). It is especially useful if called after a network object as been constructed and before any extractions are performed. 
</p>
<p>The element addition functions (<code>add.vertices</code>) override their network-package counterparts in order to permit assigning pids to newly-added elements if the pid is defined.  They can be defined by the user with the <code>vertex.pids</code> argument, or, if not specified, a unique random id will be generated. (Note that any new values added by default to a <code>vertex.names</code> pid will not be numeric.)
</p>
<p>Some of the import/conversion methods may set pids. See <code><a href="network.html#topic+network">network</a></code>.
</p>
<p>User-specified pids are checked for uniqueness. The the current auto-generated pid implementation produces ids that are unique within the current network.  They are also <em>almost</em> certain to be unique within an R session (so that vertices will have a unique id if added and removed) and quite likely across sessions, but we need more details on the <code>tempfile</code>'s implementation.
</p>
<p>With the exception of the &quot;check&quot; utilities, all of these functions modify their network argument in place. 
</p>


<h3>Value</h3>

<p>Get methods:
</p>

<ul>
<li><p><code>get.vertex.id</code> returns the vertex.id(s) of vertices corresponding to the vertex.pid(s) provided.
</p>
</li>
<li><p><code>get.vertex.pid</code> returns the vertex.pid(s) of vertices corresponding to the vertex.id(s) provided.
</p>
</li>
<li><p><code>get.edge.id</code> returns the edge.id(s) of edge corresponding to the edge.pid(s) provided.
</p>
</li>
<li><p><code>get.edge.pid</code> returns the edge.pid(s) of edges corresponding to the edge.id(s) provided.
</p>
</li></ul>

<p>Each of the above return <code>NA</code> values where no match is found.
</p>

<ul>
<li><p><code>vertex.pid.check</code> throws an error if the <code>vertex.pid</code> is found to not meet specifications. Otherwise returns <code>TRUE</code> or <code>FALSE</code> and gives a warning if vertex.pid does not exist 
</p>
</li>
<li><p><code>edge.pid.check</code> throws an error if the <code>edge.pid</code> is found to not meet specifications. Otherwise returns <code>TRUE</code> or <code>FALSE</code> and gives a warning if edge.pid does not exist
</p>
</li></ul>



<h3>Note</h3>

<p>Adding edges via the extraction/replacement operators <code>[,]</code> bypasses the pid code and will break the edge pids defined for the network. Similarly, <code><a href="#topic+add.vertices.active">add.vertices.active</a></code> and <code><a href="#topic+add.edges.active">add.edges.active</a></code> do not yet support including pids. 
</p>


<h3>Author(s)</h3>

<p>lxwang, skyebend, the statnet team
</p>


<h3>See Also</h3>

<p>See also <code><a href="network.html#topic+add.vertices">add.vertices</a></code> in network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use vertex.names as a persistent id
net&lt;-network.initialize(5)
set.network.attribute(net, 'vertex.pid','vertex.names')

# find original vertex corresponding to vertex in smaller extracted net
haystack&lt;-network.initialize(30)
activate.vertices(haystack,v=10:20)

# hide a needle somewhere in the haystack
set.vertex.attribute(haystack,'needle',TRUE,v=sample(1:30,1))

# set up the persistand ids with defaults
initialize.pids(haystack)

# some hay is removed over time ...
newstack&lt;-network.extract(haystack,at=100,active.default=FALSE)
network.size(newstack)
# we find the needle!
needleId &lt;-which(get.vertex.attribute(newstack,'needle'))
needleId

# which vertex is the corresponding one in original stack?
oldId&lt;-get.vertex.id(haystack,get.vertex.pid(newstack,needleId))
oldId

# check if we got it right..
get.vertex.attribute(haystack,'needle')[oldId]


# one reason you wouldn't want to use ordinary vertex.names
net&lt;-network.initialize(3)
add.vertices(net,3)
network.vertex.names(net)

# but if you make it a persistant id, new names will be created
net&lt;-network.initialize(3)
set.network.attribute(net,'vertex.pid','vertex.names')
add.vertices(net,3)
network.vertex.names(net)

# try with edges and add/remove vertices
net &lt;-network.initialize(10)
add.edges(net,1:9,2:10)
set.edge.attribute(net,'test',"you found me!",e=7)
initialize.pids(net)
changed&lt;-net
add.vertices(changed,5)
delete.vertices(changed,c(1,3,5,15))
delete.edges(changed,eid=1:3)

# which edge in changed corresponds to edge 7 in net?
network.edgecount(changed)
get.edge.id(changed,get.edge.pid(net,7))
# actually, they are the same because of NULL edges in edgelist
get.edge.attribute(changed,'test',unlist=FALSE)[[7]]
# however, the ids of the vertices have changed
changed$mel[[7]]$inl
net$mel[[7]]$inl

# do they still match up?
get.vertex.pid(changed,changed$mel[[7]]$inl)==get.vertex.pid(net,net$mel[[7]]$inl)


</code></pre>

<hr>
<h2 id='print.networkDynamic'>
Provide a view of a networkDynamic object including timing information
</h2><span id='topic+print.networkDynamic'></span>

<h3>Description</h3>

<p>Prints out some very basic descriptive stats about the network's dynamics, and the the normal information printed for network objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S3 method for class 'networkDynamic'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.networkDynamic_+3A_x">x</code></td>
<td>
<p> an object of class networkDynamic including dynamic relational information
</p>
</td></tr>
<tr><td><code id="print.networkDynamic_+3A_...">...</code></td>
<td>

<p>additional items to be passed for consideration by other classes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some info about the number of time events in a networkDynamic object, then calls print.network
</p>


<h3>Value</h3>

<p>Returns the networkDynamic object passed to the function.
</p>


<h3>Note</h3>

<p>Only prints out the network information without any dynamic data.
</p>


<h3>Author(s)</h3>

<p>Pavel
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+print.network">print.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(networkDynamic)
  data(flo)
  net1 &lt;- network(flo)
  activate.edges(net1, onset=1:20, terminus=101:120)
  activate.vertices(net1, at=seq(2,32,2))
  print(net1)
</code></pre>

<hr>
<h2 id='read.son'>
Read .son-formatted (SoNIA) input files containing longitudinal network data and  create a corresponding networkDynamic object
</h2><span id='topic+read.son'></span>

<h3>Description</h3>

<p>A .son file is a tab-separated text file with two sections, the first describing node attribute events and the second arc attribute events. Each section has a set of defined column names as a header. See the SoNIA file specification for more information: <a href="https://sourceforge.net/p/sonia/wiki/Son_format/">https://sourceforge.net/p/sonia/wiki/Son_format/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.son(file, guess.TEA=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.son_+3A_file">file</code></td>
<td>
<p>path to the file to be read</p>
</td></tr>
<tr><td><code id="read.son_+3A_guess.tea">guess.TEA</code></td>
<td>
<p>logical: should the parser guess that non-changing attribute values are intended to be static instead of TEAs?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="#topic+networkDynamic">networkDynamic</a></code> internally to build a dynamic network out of an array of vertex spells and an array of edge spells.  Vertex and edge attributes will be attached, usually as TEA.  However, If the values of an attribute never change, they will be attached as a static attribute.  This is convenient but will be incorrect if a value was intended to be defined for only a single spell matching with the vertex activation. Setting <code>guess.TEA=FALSE</code> will force all attributes to be loaded as TEAs (slower).
</p>


<h3>Value</h3>

<p>A network dynamic object with vertex and edge durations and attributes corresponding the the spells defined in the input file. 
</p>


<h3>Note</h3>

<p>The current version of this function does not support reading clusters.
</p>


<h3>Author(s)</h3>

<p>Skye Bender-deMoll
</p>


<h3>References</h3>

<p><a href="https://sourceforge.net/p/sonia/wiki/Son_format/">https://sourceforge.net/p/sonia/wiki/Son_format/</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+networkDynamic">networkDynamic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>classroom&lt;-read.son(system.file('extdata/cls33_10_16_96.son',package='networkDynamic'))
</code></pre>

<hr>
<h2 id='reconcile.activity'>
Modify the activity spells of vertices to match incident edges or the other way around
</h2><span id='topic+reconcile.vertex.activity'></span><span id='topic+reconcile.edge.activity'></span><span id='topic+reconcile.activity'></span>

<h3>Description</h3>

<p>When networkDynamic objects are created from real-world data it is often the case that activity information for vertices and edges may not come from the same source and may not match up exactly.  Vertices may be inactive when incident edges are active, etc.  The <code>reconcile.vertex.activity</code> function modifies the activity of a network's vertices acording to the <code>mode</code> specified, while <code>reconcile.edge.activity</code> performs similar operations for edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcile.vertex.activity(net,
                      mode = c ("expand.to.edges", "match.to.edges", "encompass.edges"),
                      edge.active.default = TRUE)

reconcile.edge.activity(net, 
                     mode = c("match.to.vertices", "reduce.to.vertices"), 
                     active.default = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconcile.activity_+3A_net">net</code></td>
<td>
<p>a <code><a href="#topic+networkDynamic">networkDynamic</a></code> object
</p>
</td></tr>
<tr><td><code id="reconcile.activity_+3A_mode">mode</code></td>
<td>
<p> string indicating the method for reconciling
</p>
</td></tr>
<tr><td><code id="reconcile.activity_+3A_edge.active.default">edge.active.default</code></td>
<td>

<p>boolean, should edges with no definied activity be considered active?</p>
</td></tr>
<tr><td><code id="reconcile.activity_+3A_active.default">active.default</code></td>
<td>

<p>boolean, should vertices with no definied activity be considered active?
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The <code>mode</code> argument takes the following values:
</p>
<ul>
<li> <p><code>match.to.edges</code> vertices will be modified so as to be only active when incident edges are active. Existing vertex spells are deleted.
</p>
</li>
<li> <p><code>expand.to.edges</code> vertices activity will be expanded to include the activity periods of any incident edges (still permits isolated vertices). Existing vertex spells are preserved.
</p>
</li>
<li> <p><code>encompass.edges</code> vertices activity will be modified so that it has a single spell beginning with the earliest incident edge activity, and encompasses the last edge activity. (Note that this implies that isolated vertices will become inactive).
</p>
</li>
<li> <p><code>match.to.vertices</code> edges will be modified so as to be active whenever all incident vertices are active. Existing inactive edges will be activated if necessary. 
</p>
</li>
<li> <p><code>reduce.to.vertices</code> edges will be modified so as to have no active spells when incident vertices are inactive. Inactive edges will not be activated.
</p>
</li></ul>



<h3>Value</h3>

<p>The input <code>networkDynamic</code> object is modified in place and returned invisibly.
</p>


<h3>Author(s)</h3>

<p>skyebend, lxwang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nd&lt;-network.initialize(6)
add.edges.active(nd,tail=1:3,head=2:4,onset=1,terminus=3)
add.edges.active(nd,tail=4,head=1,onset=5,terminus=7)
add.edge(nd,tail=1,head=6)
# before
get.vertex.activity(nd,as.spellList=TRUE)
reconcile.vertex.activity(nd)
# after
get.vertex.activity(nd,as.spellList=TRUE)

# induce edge activity for known vertex timing
nd&lt;-network.initialize(4,directed=FALSE)
activate.vertices(nd,onset=1:4,terminus=3:6)
nd[,]&lt;-1
get.edge.activity(nd,as.spellList=TRUE)
reconcile.edge.activity(nd, mode="reduce.to.vertices")
get.edge.activity(nd,as.spellList=TRUE)

</code></pre>

<hr>
<h2 id='spells.overlap'>
Functions to compare and search spell intervals
</h2><span id='topic+spells.overlap'></span><span id='topic+spells.hit'></span><span id='topic+search.spell'></span>

<h3>Description</h3>

<p>spells.overlap checks if two spells overlap at all, spells.hit searches a spell matrix for an overlapping spell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spells.overlap(s1, s2)

spells.hit(needle, haystack)

search.spell(needle, haystack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spells.overlap_+3A_s1">s1</code></td>
<td>

<p>First spell for in the comparison, must be a two-element numeric vector in the form [onset,terminus]
</p>
</td></tr>
<tr><td><code id="spells.overlap_+3A_s2">s2</code></td>
<td>

<p>Second spell for in the comparison, must be a two-element numeric vector in the form [onset,terminus]
</p>
</td></tr>
<tr><td><code id="spells.overlap_+3A_needle">needle</code></td>
<td>

<p>The query spell used in the search, must be a two-element numeric vector in the form [onset,terminus] 
</p>
</td></tr>
<tr><td><code id="spells.overlap_+3A_haystack">haystack</code></td>
<td>

<p>The spell matrix to be searched by <code>needle</code>. Must be two column numeric matrix meeting the order specifications of a spell matrix. See <a href="#topic+activity.attribute">activity.attribute</a>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spell overlap is defined as true if one of the following conditions sets is met, otherwise false:
</p>
<p>onset1 &gt;= onset2 AND onset1 &lt; terminus2
</p>
<p>terminus1 &gt; onset2 AND terminus1 &lt;= terminus2
</p>
<p>onset1 &lt;= onset2 AND terminus1 &gt;= terminus2
</p>


<h3>Value</h3>

<p><code>spells.overlap</code> returns a boolean indicating if the two spells overlap or not.  
</p>
<p><code>spells.hit</code> returns the integer row index of the first (earliest) spell in <code>haystack</code> that overlaps with <code>needle</code>, or -1 if no overlaps are found
</p>
<p><code>search.spell</code> returns a vector containing the row indices of spells in haystack that overlap with needle, or numeric(0) if none found
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+activity.attribute">activity.attribute</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(1,3)
b &lt;- c(2,5.5)
c &lt;- c(-1,10)
d &lt;- c(4,4)
spells.overlap(a,b)
spells.overlap(b,c)
spells.overlap(a,d)

spellmat &lt;- rbind(c(0,1), c(1,2), c(2,3))
spells.hit(c(1,2),spellmat)

</code></pre>

<hr>
<h2 id='when.vertex.attrs.match'>
return the times at which the TEA attributes of elements of a network match a value
</h2><span id='topic+when.vertex.attrs.match'></span><span id='topic+when.edge.attrs.match'></span>

<h3>Description</h3>

<p>The functions query the TEA attributes of network elements (vertices or edges) and return the time that each element matches the specified value.  The match operator defaults to '==', but other binary comparison operators that return logical, such as '&gt;' or even '%in%' can be used as well. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>when.vertex.attrs.match(nd, attrname, value, match.op = "==", rule = "earliest", 
                        no.match = Inf, v = seq_len(network.size(nd)))
                        
when.edge.attrs.match(nd, attrname, value, match.op = "==", rule = "earliest", 
                        no.match = Inf, e = seq_along(nd$mel))                        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="when.vertex.attrs.match_+3A_nd">nd</code></td>
<td>

<p>a <code>networkDynamic</code> object
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_attrname">attrname</code></td>
<td>

<p>character name of the TEA attribute to be queried
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_value">value</code></td>
<td>

<p>the value to be passed to the comparison operator to be matched against the TEA values
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_match.op">match.op</code></td>
<td>

<p>the binary operator to be used in determining a match (defaults to '==')
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_rule">rule</code></td>
<td>

<p>character giving the name of the rule to determine what value should be returned from the spell of matching attributes. Options are <code>'earliest'</code> (the default) and <code>'latest'</code> which will return the onset and terminus of the spell respectively. 
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_no.match">no.match</code></td>
<td>

<p>The value to be returned when the TEA attribute never matches <code>value</code>.  Default is <code>Inf</code>, <code>NA</code> may be useful as well. 
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_v">v</code></td>
<td>

<p>possible numeric vector of vertex ids indicating a subset of vertices to be queried
</p>
</td></tr>
<tr><td><code id="when.vertex.attrs.match_+3A_e">e</code></td>
<td>

<p>possible numeric vector of edge ids indicating a subset of edges to be queried
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>no.match</code> argument is included to make it possible for user to distinguish cases where the attribute is missing from the network element (which will return <code>NA</code>) from cases where the value of the attribute never matches <code>value</code> according to the operation <code>match.op</code>
</p>


<h3>Value</h3>

<p>A numeric vector of attribute onset times (if <code>rule='earliest'</code>) or termination times (if <code>rule='latest'</code>)
</p>


<h3>Note</h3>

<p>this is a draft implementation, suggestions on function and argument names welcome. 
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <a href="#topic+attribute.activity.functions">attribute.activity.functions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a network with TEA attribute
net&lt;-network.initialize(5)
net&lt;-activate.vertex.attribute(net,'test','A',onset=0,terminus=2)
net&lt;-activate.vertex.attribute(net,'test','B',onset=2,terminus=3)
net&lt;-activate.vertex.attribute(net,'test','C',onset=4,terminus=5)

net&lt;-activate.vertex.attribute(net,'weight',0,onset=-Inf,terminus=Inf)
net&lt;-activate.vertex.attribute(net,'weight',-1,at=6,v=2)

# when does 'test' take the value 'B' for each vertex?
when.vertex.attrs.match(net,'test',value='B')

# when is the terminus of when 'test' takes a value 'A' or 'C'?
when.vertex.attrs.match(net,'test',value=c('A','C'),match.op='%in%',rule='latest')

# when does 'weight' first take a value less than 0?
when.vertex.attrs.match(net,'weight',value=0,match.op='&lt;')

</code></pre>

<hr>
<h2 id='windsurfers'>
Lin Freeman's Dynamic Network of Windsurfer Social Interactions
</h2><span id='topic+windsurfers'></span><span id='topic+beach'></span>

<h3>Description</h3>

<p>A dynamic network object describing daily social interactions between windsurfers on California beaches over a months time. Collected by Lin Freeman in 1988.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(windsurfers)</code></pre>


<h3>Format</h3>

<p>The format is is a <a href="#topic+networkDynamic">networkDynamic</a> object with node and edge <a href="#topic+activity.attribute">activity.attribute</a>s defined by spell matricies.
</p>


<h3>Details</h3>

<p>The data in this network was originally collected and
analyzed in aggregate by Freeman et al. (1988) and has since been used in
a number of influential articles (see Cornwell, 2009; Hummon and Doreian,
2003; Zeggelink et al., 1996, etc.). While this network is typically analyzed
in aggregate, it was originally collected as a dynamically evolving network
(where the vertex set is composed of windsurfers and the edge set is composed of interpersonal communication). 
</p>
<p>The network was collected daily (sampled at two time points each day) for 31 days (August 28, 1986 to September 27,1986). From Almquist and Butts, 201:
</p>
<p>&quot;Individuals were tracked with a unique ID, and were divided by Freeman
et al. into those we will here call, 'regulars' (N = 54) &ndash; frequent attendees
who were well-integrated into the social life of the beach community &ndash; and 'irregulars' (N = 41) on ethnographic grounds. The former category was further broken down by the researchers into two groups, Group 1 (N = 22) and Group 2 (N = 21), with 11 individuals not classified as belonging to
either Group 1 or Group 2. Altogether, the union of vertex sets (Vmax )
consists of 95 individuals. On any given day during the observation period,
the number of windsurfers appearing on the beach ranged from 3 to 37, with
the number of communication ties per day ranging from 0 to 96.&quot; 
</p>
<p>The dynamicNetwork object was created from  a list of network objects 
(length 31, but there is one missing entry index 25 marked with an NA). Each list entry is labeled 828, 829 ... 927 &ndash; this corresponds to the date the network was collected. Vertex
attributes include: group1, group2, regular, vertex.names &ndash;
group1, group2, and regular are ethnographically defined (and are
simply dummies in this case, i.e., 0/1), and vertex.names is the original code number used by Lin. This are static vertex attributes. 
</p>
<p>The original set of static networks have been merged into a single dynamic network object with vertex activity coded in a spell matrix following the conventions of networkDynamic objects. There is very high daily turnover of who is present on the beach on each day. 
</p>
<p>Several dynamic network level attributes (e.g., list.network.attributes) have been added by Zack Almquist. These include:
</p>

<ul>
<li> <p><code>atmp</code> atmospheric temperature. 
</p>
</li>
<li> <p><code>cord</code> Grid location on the beach.
</p>
</li>
<li> <p><code>day</code> simply the Monday/Tuesday/etc labeling.
</p>
</li>
<li> <p><code>gst</code> ground surface temperature (celsius).
</p>
</li>
<li> <p><code>week</code> week is the position within the month (e.g., first week in august)
</p>
</li>
<li> <p><code>wspd</code> Wind speed from noaa.gov.
</p>
</li>
<li> <p><code>wvht</code> Wave height noaa.gov.
</p>
</li></ul>

<p>atm, gst, wspd, wvht are from the national atmospheric data (noaa.gov) and come from the
closest beach that had accurate weather data. Day of week is relevant because weekly periodicity of the nodeset is quite high.
</p>


<h3>Source</h3>

<p>Dr. Lin Freeman (Research Professor UCI) and Zack W Almquist (Graduate Student, UCI)
</p>


<h3>References</h3>

<p>Almquist, Zack W. and Butts, Carter T. (2011). &quot;Logistic Network Regression for Scalable Analysis of Networks with Joint Edge/Vertex Dynamics.&quot; IMBS Technical Report MBS 11-03, University of California, Irvine. <br />
</p>
<p>Freeman, L. C., Freeman, S. C., Michaelson, A. G., 1988. &quot;On human social
intelligence.&quot; Journal of Social Biological Structure 11, 415&ndash;425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(windsurfers)

data(windsurferPanels)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
