<!DOCTYPE html><html lang="en"><head><title>Help for package clustur</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustur}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustur-package'><p>clustur: Clustering</p></a></li>
<li><a href='#cluster'><p>Cluster entities together</p></a></li>
<li><a href='#create_sparse_matrix'><p>Create Sparse Matrix</p></a></li>
<li><a href='#example_path'><p>Example Path</p></a></li>
<li><a href='#get_abundance'><p>Get Shared</p></a></li>
<li><a href='#get_bins'><p>Get Clusters</p></a></li>
<li><a href='#get_count_table'><p>Get Count Table</p></a></li>
<li><a href='#get_cutoff'><p>Get Cutoff</p></a></li>
<li><a href='#get_distance_df'><p>Get Distance Data Frame</p></a></li>
<li><a href='#get_metrics'><p>Get Metrics</p></a></li>
<li><a href='#read_count'><p>Read count table</p></a></li>
<li><a href='#read_dist'><p>Read distance matrices</p></a></li>
<li><a href='#split_clusters_to_list'><p>Split Clusters to List</p></a></li>
<li><a href='#validate_count_table'><p>Validate Count Table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Schloss &lt;pschloss@umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool that implements the clustering algorithms from 'mothur' (Schloss PD et al. (2009) &lt;<a href="https://doi.org/10.1128%2FAEM.01541-09">doi:10.1128/AEM.01541-09</a>&gt;). 'clustur' make use of the cluster() and make.shared() command from 'mothur'. Our cluster() function has five different algorithms implemented: 'OptiClust', 'furthest', 'nearest', 'average', and 'weighted'. 'OptiClust' is an optimized clustering method for Operational Taxonomic Units, and you can learn more here, (Westcott SL, Schloss PD (2017) &lt;<a href="https://doi.org/10.1128%2Fmspheredirect.00073-17">doi:10.1128/mspheredirect.00073-17</a>&gt;). The make.shared() command is always applied at the end of the clustering command. This functionality allows us to generate and create clustering and abundance data efficiently.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, methods, Rcpp (&ge; 1.0.12), utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), xml2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.schlosslab.org/clustur/">http://www.schlosslab.org/clustur/</a>,
<a href="https://github.com/SchlossLab/clustur">https://github.com/SchlossLab/clustur</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SchlossLab/clustur/issues">https://github.com/SchlossLab/clustur/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-25 17:08:38 UTC; grejoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Johnson <a href="https://orcid.org/0009-0008-3890-0297"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sarah Westcott [aut],
  Patrick Schloss <a href="https://orcid.org/0000-0002-6935-4275"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-25 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustur-package'>clustur: Clustering</h2><span id='topic+clustur'></span><span id='topic+clustur-package'></span>

<h3>Description</h3>

<p>A tool that implements the clustering algorithms from 'mothur' (Schloss PD et al. (2009) <a href="https://doi.org/10.1128/AEM.01541-09">doi:10.1128/AEM.01541-09</a>). 'clustur' make use of the cluster() and make.shared() command from 'mothur'. Our cluster() function has five different algorithms implemented: 'OptiClust', 'furthest', 'nearest', 'average', and 'weighted'. 'OptiClust' is an optimized clustering method for Operational Taxonomic Units, and you can learn more here, (Westcott SL, Schloss PD (2017) <a href="https://doi.org/10.1128/mspheredirect.00073-17">doi:10.1128/mspheredirect.00073-17</a>). The make.shared() command is always applied at the end of the clustering command. This functionality allows us to generate and create clustering and abundance data efficiently.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrick Schloss <a href="mailto:pschloss@umich.edu">pschloss@umich.edu</a> (<a href="https://orcid.org/0000-0002-6935-4275">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Gregory Johnson <a href="mailto:grejoh@umich.edu">grejoh@umich.edu</a> (<a href="https://orcid.org/0009-0008-3890-0297">ORCID</a>)
</p>
</li>
<li><p> Sarah Westcott <a href="mailto:swestcot@umich.edu">swestcot@umich.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://www.schlosslab.org/clustur/">http://www.schlosslab.org/clustur/</a>
</p>
</li>
<li> <p><a href="https://github.com/SchlossLab/clustur">https://github.com/SchlossLab/clustur</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SchlossLab/clustur/issues">https://github.com/SchlossLab/clustur/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cluster'>Cluster entities together</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Clusters entities represented in a distance matrix and count table using
one of several algorithms and outputs information about the composition and
abundance of each cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(
  distance_object,
  cutoff,
  method = "opticlust",
  feature_column_name_to = "feature",
  bin_column_name_to = "bin",
  random_seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_distance_object">distance_object</code></td>
<td>
<p>The distance object that
was created using the 'read_dist()' function.</p>
</td></tr>
<tr><td><code id="cluster_+3A_cutoff">cutoff</code></td>
<td>
<p>The cutoff you want to cluster towards.</p>
</td></tr>
<tr><td><code id="cluster_+3A_method">method</code></td>
<td>
<p>The method of clustering to be performed: opticlust (default),
furthest, nearest, average, or weighted.</p>
</td></tr>
<tr><td><code id="cluster_+3A_feature_column_name_to">feature_column_name_to</code></td>
<td>
<p>Set the name of the column in the cluster
dataframe that contains the sequence names.</p>
</td></tr>
<tr><td><code id="cluster_+3A_bin_column_name_to">bin_column_name_to</code></td>
<td>
<p>Set the name of the column in the
cluster dataframe that contains the name of the group of sequence names.</p>
</td></tr>
<tr><td><code id="cluster_+3A_random_seed">random_seed</code></td>
<td>
<p>the random seed to use, (default = 123).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'data.frames' that contain abundance, and clustering
results. If you used 'method = opticlust', it will also return clustering
performance metrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 cutoff &lt;- 0.03
 count_table &lt;- read_count(example_path("amazon.full.count_table"))
 distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                            count_table, cutoff)

 cluster_results &lt;- cluster(distance_data,
                            cutoff, method = "opticlust",
                            feature_column_name_to = "sequence",
                            bin_column_name_to = "omu")
 cluster_results &lt;- cluster(distance_data,
                            cutoff, method = "furthest")
 cluster_results &lt;- cluster(distance_data,
                            cutoff, method = "nearest")
 cluster_results &lt;- cluster(distance_data,
                            cutoff, method = "average")
 cluster_results &lt;- cluster(distance_data,
                            cutoff, method = "weighted")


</code></pre>

<hr>
<h2 id='create_sparse_matrix'>Create Sparse Matrix</h2><span id='topic+create_sparse_matrix'></span>

<h3>Description</h3>

<p>Given a list of i indexes, j indexes, and distances values,
we can create a sparse distance matrix for you. Each vector
must have the same size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_sparse_matrix(i_index, j_index, distances)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_sparse_matrix_+3A_i_index">i_index</code></td>
<td>
<p>A list of i indexes, must be numeric</p>
</td></tr>
<tr><td><code id="create_sparse_matrix_+3A_j_index">j_index</code></td>
<td>
<p>A list of j indexes, must be numeric</p>
</td></tr>
<tr><td><code id="create_sparse_matrix_+3A_distances">distances</code></td>
<td>
<p>A list of the distance at the i and j index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'dgTMatrix' from the 'Matrix' library.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 i_values &lt;- as.integer(1:100)
 j_values &lt;- as.integer(sample(1:100, 100, TRUE))
 x_values &lt;- as.numeric(runif(100, 0, 1))
 s_matrix &lt;- create_sparse_matrix(i_values, j_values, x_values)
</code></pre>

<hr>
<h2 id='example_path'>Example Path</h2><span id='topic+example_path'></span>

<h3>Description</h3>

<p>This function was created as a helper function to generate file paths to our
internal data. You should use this function if you
want to follow along with the example, or interact with the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_path(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example_path_+3A_file">file</code></td>
<td>
<p>The file name of the data; leave as NULL (default) to get full
list of example files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the path to the file as a 'character' or a vector of 'character'
giving example filenames if 'fill = NULL'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_path("amazon_phylip.dist")
example_path()
</code></pre>

<hr>
<h2 id='get_abundance'>Get Shared</h2><span id='topic+get_abundance'></span>

<h3>Description</h3>

<p>GetShared returns the generated abundance 'data.frame'
from the 'cluster()' function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_abundance(cluster_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_abundance_+3A_cluster_data">cluster_data</code></td>
<td>
<p>The output from the 'cluster()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a shared data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                           count_table, cutoff, FALSE)
df_clusters &lt;- cluster(distance_data, cutoff, method = "opticlust")
shared &lt;- get_abundance(df_clusters)

</code></pre>

<hr>
<h2 id='get_bins'>Get Clusters</h2><span id='topic+get_bins'></span>

<h3>Description</h3>

<p>GetClusters returns a 'data.frame' of the generated
clusters from the 'cluster()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bins(cluster_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_bins_+3A_cluster_data">cluster_data</code></td>
<td>
<p>The output from the 'cluster()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the created cluster 'data.frame'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                           count_table, cutoff, FALSE)
df_clusters &lt;- cluster(distance_data, cutoff, method = "opticlust")
clusters &lt;- get_bins(df_clusters)

</code></pre>

<hr>
<h2 id='get_count_table'>Get Count Table</h2><span id='topic+get_count_table'></span>

<h3>Description</h3>

<p>This function returns the count table that was used
to generate the distance object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_count_table(distance_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_count_table_+3A_distance_object">distance_object</code></td>
<td>
<p>The output from the 'read.dist()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a count_table 'data.frame'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                           count_table, cutoff, FALSE)
count_table &lt;- get_count_table(distance_data)

</code></pre>

<hr>
<h2 id='get_cutoff'>Get Cutoff</h2><span id='topic+get_cutoff'></span>

<h3>Description</h3>

<p>Returns the distance cutoff of the cluster object from the 'cluster()'
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cutoff(cluster_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cutoff_+3A_cluster_data">cluster_data</code></td>
<td>
<p>The output from the 'cluster()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cutoff value as a 'dbl'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                           count_table, cutoff, FALSE)
df_clusters &lt;- cluster(distance_data, cutoff, method = "opticlust")
cutoff &lt;- get_cutoff(df_clusters)
</code></pre>

<hr>
<h2 id='get_distance_df'>Get Distance Data Frame</h2><span id='topic+get_distance_df'></span>

<h3>Description</h3>

<p>This function will generate a 'data.frame' that contains the distances
of all the indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance_df(distance_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distance_df_+3A_distance_object">distance_object</code></td>
<td>
<p>The output from the 'read.dist()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance 'data.frame'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                                        count_table, cutoff, FALSE)
count_table &lt;- get_count_table(distance_data)

</code></pre>

<hr>
<h2 id='get_metrics'>Get Metrics</h2><span id='topic+get_metrics'></span>

<h3>Description</h3>

<p>GetMetrics returns the generated metrics 'data.frame' from the
'cluster()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metrics(cluster_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_metrics_+3A_cluster_data">cluster_data</code></td>
<td>
<p>The output from the 'cluster()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of metric data.frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cutoff &lt;- 0.2
count_table &lt;- read_count(example_path("amazon.full.count_table"))
distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                           count_table, cutoff, FALSE)
df_clusters &lt;- cluster(distance_data, cutoff, method = "opticlust")
list_of_metrics &lt;- get_metrics(df_clusters)

</code></pre>

<hr>
<h2 id='read_count'>Read count table</h2><span id='topic+read_count'></span>

<h3>Description</h3>

<p>This function will read and return your count table. It can take in
sparse and full count tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_count(count_table_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_count_+3A_count_table_path">count_table_path</code></td>
<td>
<p>The file path of your count table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a count table 'data.frame'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_table &lt;- read_count(example_path("amazon.full.count_table"))
</code></pre>

<hr>
<h2 id='read_dist'>Read distance matrices</h2><span id='topic+read_dist'></span>

<h3>Description</h3>

<p>Read in distances from a file that is formatted with three columns for the
row, column, and distance of a sparse, square matrix or in a phylip-formatted
distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dist(distance_file, count_table, cutoff, is_similarity_matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_dist_+3A_distance_file">distance_file</code></td>
<td>
<p>Either a phylip or column distance file, or a sparse
matrix. The function will detect the format for you.</p>
</td></tr>
<tr><td><code id="read_dist_+3A_count_table">count_table</code></td>
<td>
<p>A table of names and the given abundance per group. Can
be in mothur's sparse or full format. The function will detect the format for
you.</p>
</td></tr>
<tr><td><code id="read_dist_+3A_cutoff">cutoff</code></td>
<td>
<p>The value you wish to use as a cutoff when clustering.</p>
</td></tr>
<tr><td><code id="read_dist_+3A_is_similarity_matrix">is_similarity_matrix</code></td>
<td>
<p>are you using a similarity matrix (default) or
distance matrix?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance 'externalptr' object that contains all your
distance information. Can be accessed using 'get_distance_df()'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 i_values &lt;- as.integer(1:100)
 j_values &lt;- as.integer(sample(1:100, 100, TRUE))
 x_values &lt;- as.numeric(runif(100, 0, 1))
 s_matrix &lt;- create_sparse_matrix(i_values, j_values, x_values)

 sparse_count &lt;- data.frame(
                 Representative_Sequence = 1:100,
                 total = rep(1, times = 100))

 column_path &lt;- example_path("amazon_column.dist")
 phylip_path &lt;- example_path("amazon_phylip.dist")
 count_table &lt;- read_count(example_path("amazon.full.count_table"))

 data_column &lt;- read_dist(column_path, count_table, 0.03)
 data_phylip &lt;- read_dist(phylip_path, count_table, 0.03)
 data_sparse &lt;- read_dist(s_matrix, sparse_count, 0.03)
</code></pre>

<hr>
<h2 id='split_clusters_to_list'>Split Clusters to List</h2><span id='topic+split_clusters_to_list'></span>

<h3>Description</h3>

<p>'split_clusters_to_list()' will extract clusters from the
cluster generated 'data.frame'. It will then turn those clusters
into a list. This allows users to more easily visualize their data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_clusters_to_list(cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_clusters_to_list_+3A_cluster">cluster</code></td>
<td>
<p>The output generated from the 'cluster()' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named 'list' of clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 cutoff &lt;- 0.2
 count_table &lt;- read_count(example_path("amazon.full.count_table"))
 distance_data &lt;- read_dist(example_path("amazon_column.dist"),
                            count_table, cutoff, FALSE)
 cluster_results &lt;- cluster(distance_data, cutoff, method = "opticlust")

 cluster_list &lt;- split_clusters_to_list(cluster_results)
</code></pre>

<hr>
<h2 id='validate_count_table'>Validate Count Table</h2><span id='topic+validate_count_table'></span>

<h3>Description</h3>

<p>If the count table is already valid nothing will change,
otherwise it will add a new group to the count table file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_count_table(count_table_df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_count_table_+3A_count_table_df">count_table_df</code></td>
<td>
<p>The count table 'data.frame' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines whether user supplied count table is valid
</p>


<h3>Value</h3>

<p>A validated count table 'data.frame'
</p>


<h3>Examples</h3>

<pre><code class='language-R'> count_table &lt;- read.delim(example_path("amazon.full.count_table"))
 count_table_valid &lt;- validate_count_table(count_table)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
