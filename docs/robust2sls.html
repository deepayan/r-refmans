<!DOCTYPE html><html><head><title>Help for package robust2sls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robust2sls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta_hausman'><p>Calculates a Hausman test on the difference between robust and full sample</p>
estimates</a></li>
<li><a href='#beta_inf'><p>Calculates valid se for coefficients under H0 of no outliers</p></a></li>
<li><a href='#beta_inf_correction'><p>Calculates the correction factor for inference under H0 of no outliers</p></a></li>
<li><a href='#beta_t'><p>Conducts a t-test on the difference between robust and full sample estimates</p></a></li>
<li><a href='#beta_test_avar'><p>Calculates the asymptotic variance of the difference between robust and full</p>
sample estimators of the structural parameters</a></li>
<li><a href='#case_resampling'><p>Uses nonparametric case resampling for standard errors of parameters and</p>
gauge</a></li>
<li><a href='#constants'><p>Calculate constants across estimation</p></a></li>
<li><a href='#conv_diff'><p>L2 norm between two most recent estimates</p></a></li>
<li><a href='#count_indices'><p>Counts the number of times each index was sampled</p></a></li>
<li><a href='#counttest'><p>Count test</p></a></li>
<li><a href='#estimate_param'><p>Estimation of moments of the data</p></a></li>
<li><a href='#estimate_param_null'><p>Estimation of moments of the data</p></a></li>
<li><a href='#evaluate_boot'><p>Evaluate bootstrap results</p></a></li>
<li><a href='#extract_boot'><p>Extracts bootstrap results for a specific iteration</p></a></li>
<li><a href='#extract_formula'><p>Extract the elements of ivreg formula</p></a></li>
<li><a href='#gauge_avar'><p>Asymptotic variance of gauge</p></a></li>
<li><a href='#gauge_covar'><p>Asymptotic covariance of gauge</p></a></li>
<li><a href='#generate_data'><p>Random data of 2SLS model (Monte Carlo)</p></a></li>
<li><a href='#generate_param'><p>Parameters of 2SLS model (Monte Carlo)</p></a></li>
<li><a href='#globaltest'><p>Global test correcting for multiple hypothesis testing</p></a></li>
<li><a href='#iis_init'><p>Impulse Indicator Saturation (IIS initial estimator)</p></a></li>
<li><a href='#mc_grid'><p>Monte Carlo simulations parameter grid</p></a></li>
<li><a href='#multi_cutoff'><p>Multiple models, varying cut-off</p></a></li>
<li><a href='#multi_cutoff_to_fodr_vec'><p>Creates a vector of the centered FODR across different cut-offs</p></a></li>
<li><a href='#mvn_sup'><p>Multivariate normal supremum simulation</p></a></li>
<li><a href='#new_robust2sls'><p>Constructor of robust2sls class</p></a></li>
<li><a href='#nonmissing'><p>Determine which observations can be used for estimation</p></a></li>
<li><a href='#nonparametric'><p>Create indices for nonparametric bootstrap</p></a></li>
<li><a href='#nonparametric_resampling'><p>Nonparametric resampling from a data frame</p></a></li>
<li><a href='#outlier'><p>Outlier history of single observation</p></a></li>
<li><a href='#outlier_detection'><p>Outlier detection algorithms</p></a></li>
<li><a href='#outliers'><p>Number of outliers</p></a></li>
<li><a href='#outliers_prop'><p>Proportion of outliers</p></a></li>
<li><a href='#plot.robust2sls'><p>Plotting of standardised residuals and outliers</p></a></li>
<li><a href='#print.robust2sls'><p>Helper of robust2sls class</p></a></li>
<li><a href='#proptest'><p>Proportion test</p></a></li>
<li><a href='#robust2sls-package'><p>robust2sls: A package for outlier robust 2SLS inference and testing</p></a></li>
<li><a href='#robustified_init'><p>Robustified 2SLS (full sample initial estimator)</p></a></li>
<li><a href='#saturated_init'><p>Saturated 2SLS (split-sample initial estimator)</p></a></li>
<li><a href='#selection'><p>Create selection (non-outlying) vector from model</p></a></li>
<li><a href='#selection_iis'><p>Create selection (non-outlying) vector from IIS model</p></a></li>
<li><a href='#simes'><p>Simes (1986) procedure for multiple testing</p></a></li>
<li><a href='#sumtest'><p>Scaling sum proportion test across different cut-offs</p></a></li>
<li><a href='#suptest'><p>Supremum proportion test across different cut-offs</p></a></li>
<li><a href='#test_cpv'><p>Critical and p-value for test statistic relative to simulated distribution</p></a></li>
<li><a href='#update_list'><p>Append new iteration results to <code>"robust2sls"</code> object</p></a></li>
<li><a href='#user_init'><p>User-specified initial estimator</p></a></li>
<li><a href='#validate_robust2sls'><p>Validator of robust2sls class</p></a></li>
<li><a href='#varrho'><p>Calculate varrho coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Outlier Robust Two-Stage Least Squares Inference and Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of easy tools for outlier robust inference in
    two-stage least squares (2SLS) models. The user specifies a reference 
    distribution against which observations are classified as outliers or not. 
    After removing the outliers, adjusted standard errors are automatically 
    provided. Furthermore, several statistical tests for the false outlier 
    detection rate can be calculated. The outlier removing algorithm can be 
    iterated a fixed number of times or until the procedure converges. The 
    algorithms and robust inference are described in more detail in Jiao (2019) 
    <a href="https://drive.google.com/file/d/1qPxDJnLlzLqdk94X9wwVASptf1MPpI2w/view">https://drive.google.com/file/d/1qPxDJnLlzLqdk94X9wwVASptf1MPpI2w/view</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jkurle/robust2sls">https://github.com/jkurle/robust2sls</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jkurle/robust2sls/issues">https://github.com/jkurle/robust2sls/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, datasets, doFuture, doParallel, doRNG, future, ggplot2,
grDevices, ivgets, knitr, parallel, rmarkdown, testthat, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>exactci, foreach, ivreg, MASS, mathjaxr, pracma, stats</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-11 14:57:43 UTC; jonas</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Kurle <a href="https://orcid.org/0000-0003-2197-2012"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Kurle &lt;mail@jonaskurle.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-11 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta_hausman'>Calculates a Hausman test on the difference between robust and full sample
estimates</h2><span id='topic+beta_hausman'></span>

<h3>Description</h3>

<p>Calculates a Hausman test on the difference between robust and full sample
estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_hausman(robust2sls_object, iteration, subset = NULL, fp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_hausman_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="beta_hausman_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt; 0 specifying the iteration step for which
parameters to calculate corrected standard errors.</p>
</td></tr>
<tr><td><code id="beta_hausman_+3A_subset">subset</code></td>
<td>
<p>A vector of numeric indices or strings indicating which
coefficients to include in the Hausman test. <code>NULL</code> uses the whole
vector of coefficients.</p>
</td></tr>
<tr><td><code id="beta_hausman_+3A_fp">fp</code></td>
<td>
<p>A logical value whether the fixed point asymptotic variance
(TRUE) or the exact iteration asymptotic variance should be used (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>fp</code> determines whether the fixed point asymptotic variance
should be used. This argument is only respected if the specified
<code>iteration</code> is one of the iterations after the algorithm converged.
</p>


<h3>Value</h3>

<p><code>beta_hausman</code> returns a matrix with the value of the Hausman
test statistic and its corresponding p-value. The attribute
<code>"type of avar"</code> records which asymptotic variance has been used (the
specific iteration or the fixed point). The attribute <code>"coefficients"</code>
stores the names of the coefficients that were included in the Hausman test.
</p>

<hr>
<h2 id='beta_inf'>Calculates valid se for coefficients under H0 of no outliers</h2><span id='topic+beta_inf'></span>

<h3>Description</h3>

<p>Calculates valid se for coefficients under H0 of no outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_inf(robust2sls_object, iteration = 1, exact = FALSE, fp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_inf_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="beta_inf_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt; 0 specifying the iteration step for which
parameters to calculate corrected standard errors.</p>
</td></tr>
<tr><td><code id="beta_inf_+3A_exact">exact</code></td>
<td>
<p>A logical value indicating whether the actually detected share
of outliers (TRUE) or the theoretical share (FALSE) should be used.</p>
</td></tr>
<tr><td><code id="beta_inf_+3A_fp">fp</code></td>
<td>
<p>A logical value whether the fixed point standard error correction
(TRUE) or the exact iteration correction should be computed (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>iteration</code> specifies which iteration of the robust structural
parameter estimates should be calculated. Iteration <code>1</code> refers to the
first robust estimate. Iteration <code>0</code> is not a valid argument since it
is the baseline estimate, which is not robust.
</p>
<p>The parameter <code>exact</code> does not matter much under the null hypothesis of
no outliers since the detected share will converge to the theoretical share.
Under the alternative, this function should not be used.
</p>
<p>Argument <code>fp</code> determines whether the fixed point standard error
correction should be computed. This argument is only respected if the
specified <code>iteration</code> is one of the iterations after the algorithm
converged.
</p>


<h3>Value</h3>

<p><code>beta_inf</code> returns the corrected standard errors for the
structural parameters. These are valid under the null hypothesis of no
outliers in the sample. For comparison, the uncorrected standard errors are
also reported.
</p>

<hr>
<h2 id='beta_inf_correction'>Calculates the correction factor for inference under H0 of no outliers</h2><span id='topic+beta_inf_correction'></span>

<h3>Description</h3>

<p>Calculates the correction factor for inference under H0 of no outliers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_inf_correction(
  robust2sls_object,
  iteration = 1,
  exact = FALSE,
  fp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_inf_correction_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="beta_inf_correction_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt; 0 specifying the iteration step for which
parameters to calculate corrected standard errors.</p>
</td></tr>
<tr><td><code id="beta_inf_correction_+3A_exact">exact</code></td>
<td>
<p>A logical value indicating whether the actually detected share
of outliers (TRUE) or the theoretical share (FALSE) should be used.</p>
</td></tr>
<tr><td><code id="beta_inf_correction_+3A_fp">fp</code></td>
<td>
<p>A logical value whether the fixed point standard error correction
(TRUE) or the exact iteration correction should be computed (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>iteration</code> specifies which iteration of the robust structural
parameter estimates should be calculated. Iteration <code>1</code> refers to the
first robust estimate. Iteration <code>0</code> is not a valid argument since it
is the baseline estimate, which is not robust.
</p>
<p>The parameter <code>exact</code> does not matter much under the null hypothesis of
no outliers since the detected share will converge to the theoretical share.
Under the alternative, this function should not be used.
</p>
<p>Argument <code>fp</code> determines whether the fixed point standard error
correction should be computed. This argument is only respected if the
specified <code>iteration</code> is one of the iterations after the algorithm
converged.
</p>


<h3>Value</h3>

<p><code>beta_inf_correction</code> returns the numeric correction factor.
</p>

<hr>
<h2 id='beta_t'>Conducts a t-test on the difference between robust and full sample estimates</h2><span id='topic+beta_t'></span>

<h3>Description</h3>

<p>Conducts a t-test on the difference between robust and full sample estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_t(robust2sls_object, iteration, element, fp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_t_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="beta_t_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt; 0 specifying the iteration step for which
parameters to calculate corrected standard errors.</p>
</td></tr>
<tr><td><code id="beta_t_+3A_element">element</code></td>
<td>
<p>An index or a string to select the coefficient which is to be
tested. The index should refer to the index of coefficients in the
<code>"ivreg"</code> model object, i.e. <code>$coefficients</code>.</p>
</td></tr>
<tr><td><code id="beta_t_+3A_fp">fp</code></td>
<td>
<p>A logical value whether the fixed point asymptotic variance
(TRUE) or the exact iteration asymptotic variance should be used (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>fp</code> determines whether the fixed point asymptotic variance
should be used. This argument is only respected if the specified
<code>iteration</code> is one of the iterations after the algorithm converged.
</p>


<h3>Value</h3>

<p><code>beta_t</code> returns a matrix with the robust and full sample
estimates of beta, the t statistic on their difference, the standard error of
the difference, and three p-values (two-sided, both one-sided alternatives).
</p>

<hr>
<h2 id='beta_test_avar'>Calculates the asymptotic variance of the difference between robust and full
sample estimators of the structural parameters</h2><span id='topic+beta_test_avar'></span>

<h3>Description</h3>

<p>Calculates the asymptotic variance of the difference between robust and full
sample estimators of the structural parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_test_avar(robust2sls_object, iteration, fp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_test_avar_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="beta_test_avar_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt; 0 specifying the iteration step for which
parameters to calculate corrected standard errors.</p>
</td></tr>
<tr><td><code id="beta_test_avar_+3A_fp">fp</code></td>
<td>
<p>A logical value whether the fixed point asymptotic variance
(TRUE) or the exact iteration asymptotic variance should be computed (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>fp</code> determines whether the fixed point asymptotic variance
should be computed. This argument is only respected if the specified
<code>iteration</code> is one of the iterations after the algorithm converged.
</p>


<h3>Value</h3>

<p><code>beta_test_avar</code> returns a dx by dx variance-covariance matrix of
the difference between the robust and full sample structural parameter
estimates of the 2SLS model.
</p>

<hr>
<h2 id='case_resampling'>Uses nonparametric case resampling for standard errors of parameters and
gauge</h2><span id='topic+case_resampling'></span>

<h3>Description</h3>

<p>Uses nonparametric case resampling for standard errors of parameters and
gauge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_resampling(robust2sls_object, R, coef = NULL, m = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_resampling_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="case_resampling_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of resamples.</p>
</td></tr>
<tr><td><code id="case_resampling_+3A_coef">coef</code></td>
<td>
<p>A numeric or character vector specifying which structural
coefficient estimates should be recorded across bootstrap replications.
<code>NULL</code> means all coefficients are recorded.</p>
</td></tr>
<tr><td><code id="case_resampling_+3A_m">m</code></td>
<td>
<p>A single numeric or vector of integers specifying for which
iterations the bootstrap statistics should be calculated. <code>NULL</code> means
they are calculated for all iterations that were also done in the original
robust2sls_object. Character <code>"convergence"</code> means all bootstrap samples
are run until they converge and the statistics of the first convergent
iteration is recorded.</p>
</td></tr>
<tr><td><code id="case_resampling_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether to run the bootstrap
sampling in parallel or sequentially. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>parallel</code> allows for parallel computing using the
<a href="foreach.html#topic+foreach">foreach</a> package, so the user has to register a parallel backend before
invoking this command.
</p>
<p>Argument <code>coef</code> is useful if the model includes many controls whose
parameters are not of interest. This can reduce the memory space needed to
store the bootstrap results.
</p>


<h3>Value</h3>

<p><code>case_resampling</code> returns an object of class
<code>"r2sls_boot"</code>. This is a list with three named elements. <code>$boot</code>
stores the bootstrap results as a data frame. The columns record the
different test statistics, the iteration <code>m</code>, and the number of the
resample, <code>r</code>. The values corresponding to the original data is stored
as <code>r = 0</code>. <code>$resamples</code> is a list of length <code>R</code> that stores
the indices for each specific resample. <code>$original</code> stores the original
<code>robust2sls_object</code> based on which the bootstrapping was done.
</p>

<hr>
<h2 id='constants'>Calculate constants across estimation</h2><span id='topic+constants'></span>

<h3>Description</h3>

<p><code>constants</code> calculates various values that do not change across the
estimation and records them in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constants(
  call,
  formula,
  data,
  reference = c("normal"),
  sign_level,
  estimator,
  split,
  shuffle,
  shuffle_seed,
  iter,
  criterion,
  max_iter,
  user_model,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constants_+3A_call">call</code></td>
<td>
<p>A record of the original function call.</p>
</td></tr>
<tr><td><code id="constants_+3A_formula">formula</code></td>
<td>
<p>The regression formula specified in the function call.</p>
</td></tr>
<tr><td><code id="constants_+3A_data">data</code></td>
<td>
<p>The dataframe used in the function call.</p>
</td></tr>
<tr><td><code id="constants_+3A_reference">reference</code></td>
<td>
<p>A character vector of length 1 that denotes a valid
reference distribution.</p>
</td></tr>
<tr><td><code id="constants_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the cutoff
in the reference distribution against which observations are judged as
outliers or not.</p>
</td></tr>
<tr><td><code id="constants_+3A_estimator">estimator</code></td>
<td>
<p>A character vector specifying which initial estimator was
used.</p>
</td></tr>
<tr><td><code id="constants_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that specifies how the
sample is split in case of saturated 2SLS. <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="constants_+3A_shuffle">shuffle</code></td>
<td>
<p>A logical value whether the sample is re-arranged in random
order before splitting the sample in case of saturated 2SLS. <code>NULL</code>
otherwise.</p>
</td></tr>
<tr><td><code id="constants_+3A_shuffle_seed">shuffle_seed</code></td>
<td>
<p>A numeric value setting the seed for the shuffling of the
sample. Only used if <code>shuffle == TRUE</code>. NULL otherwise.</p>
</td></tr>
<tr><td><code id="constants_+3A_iter">iter</code></td>
<td>
<p>An integer value setting the number of iterations of the
outlier-detection algorithm.</p>
</td></tr>
<tr><td><code id="constants_+3A_criterion">criterion</code></td>
<td>
<p>A numeric value that determines when the iterated
outlier-detection algorithm stops by comparing it to the sum of squared
differences between the m- and (m-1)-step parameter estimates. NULL if
convergence criterion should not be used.</p>
</td></tr>
<tr><td><code id="constants_+3A_max_iter">max_iter</code></td>
<td>
<p>A numeric value that determines after which iteration the
algorithm stops in case it does not converge.</p>
</td></tr>
<tr><td><code id="constants_+3A_user_model">user_model</code></td>
<td>
<p>A model object of <a href="base.html#topic+class">class</a> <a href="ivreg.html#topic+ivreg">ivreg</a>. Only
required if argument <code>initial_est</code> is set to <code>"user"</code>, otherwise
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="constants_+3A_verbose">verbose</code></td>
<td>
<p>A logical value whether progress during estimation should be
reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that stores values that are constant across the
estimation. It is used to fill parts of the <code>"robust2sls"</code> class object,
which is returned by <a href="#topic+outlier_detection">outlier_detection</a>.
</p>

<dl>
<dt><code>$call</code></dt><dd><p>The captured function call.</p>
</dd>
<dt><code>$verbose</code></dt><dd><p>The verbose argument (TRUE/FALSE).</p>
</dd>
<dt><code>$formula</code></dt><dd><p>The formula argument.</p>
</dd>
<dt><code>$data</code></dt><dd><p>The original data set.</p>
</dd>
<dt><code>$reference</code></dt><dd><p>The chosen reference distribution to classify
outliers.</p>
</dd>
<dt><code>$sign_level</code></dt><dd><p>The significance level determining the cutoff.</p>
</dd>
<dt><code>$psi</code></dt><dd><p>The probability that an observation is not classified as
an outlier under the null hypothesis of no outliers.</p>
</dd>
<dt><code>$cutoff</code></dt><dd><p>The cutoff used to classify outliers if
their standardised residuals are larger than that value.</p>
</dd>
<dt><code>$bias_corr</code></dt><dd><p>A numeric bias correction factor to account for
potential false positives (observations classified as outliers even though
they are not).</p>
</dd>
<dt><code>$initial</code></dt><dd><p>A list storing settings about the initial estimator:
<code>$estimator</code> is the type of the initial estimator (e.g. robustified or
saturated), <code>$split</code> how the sample is split (<code>NULL</code> if argument
not used), <code>$shuffle</code> whether the sample is shuffled before splitting
(<code>NULL</code> if argument not used), <code>$shuffle_seed</code> the value of the
random seed (<code>NULL</code> if argument not used), <code>$user</code> the
user-specified initial model (<code>NULL</code> if not used).</p>
</dd>
<dt><code>$convergence</code></dt><dd><p>A list storing information about the convergence
of the outlier-detection algorithm: <code>$criterion</code> is the user-specified
convergence criterion (<code>NULL</code> if argument not used),
<code>$difference</code> is initialised as <code>NULL</code>. <code>$converged</code> is
initialised as <code>NULL</code>. <code>$iter</code> is initialised as <code>NULL</code>.
<code>$max_iter</code> the maximum number of iterations if does not converge
(<code>NULL</code> if not used or applicable).</p>
</dd>
<dt><code>$iterations</code></dt><dd><p>A list storing information about the iterations
of the algorithm. <code>$setting</code> stores the user-specified
<code>iterations</code> argument. <code>$actual</code> is initialised as <code>NULL</code>
and will store the actual number of iterations done.</p>
</dd>
</dl>


<hr>
<h2 id='conv_diff'>L2 norm between two most recent estimates</h2><span id='topic+conv_diff'></span>

<h3>Description</h3>

<p><code>conv_diff</code> uses an object of class <code>"robust2sls"</code> to calculate the
L2 norm (sum of squared differences) between the most recent outlier-robust
iteration and the previous iteration estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_diff(current, counter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_diff_+3A_current">current</code></td>
<td>
<p>A list object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="conv_diff_+3A_counter">counter</code></td>
<td>
<p>An integer denoting the number of the current iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>conv_diff</code> returns a numeric value, which is the L2 norm
of the difference between the most recent and the previous parameter
estimates. The L2 norm is the sum of squared differences of the estimates.
</p>

<hr>
<h2 id='count_indices'>Counts the number of times each index was sampled</h2><span id='topic+count_indices'></span>

<h3>Description</h3>

<p><code>count_indices</code> takes a list of indices for resampling and counts how
often each index was sampled in each resample. The result is returned in two
versions of a matrix where each row corresponds to a different resample and
each column to one index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_indices(resamples, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_indices_+3A_resamples">resamples</code></td>
<td>
<p>A list of resamples, as created by <a href="#topic+nonparametric">nonparametric</a>.</p>
</td></tr>
<tr><td><code id="count_indices_+3A_indices">indices</code></td>
<td>
<p>The vector of original indices from which the resamples were
drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>count_indices</code> returns a list with two names elements. Each
element is a matrix that stores how often each observation/index was
resampled (column) for each resample (row). <code>$count_clean</code> only has
columns for observations that were available in the indices.
<code>$count_all</code> counts the occurrence of all indices in the range of
indices that were provided, even if the index was actually not available in
the given indices. These are of course zero since they were not available for
resampling. If the given indices do not skip any numbers, the two coincide.
</p>

<hr>
<h2 id='counttest'>Count test</h2><span id='topic+counttest'></span>

<h3>Description</h3>

<p><code>counttest()</code> conducts a test whether the number of detected outliers
deviates significantly from the expected number of outliers under the null
hypothesis that there are no outliers in the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counttest(
  robust2sls_object,
  alpha,
  iteration,
  one_sided = FALSE,
  tsmethod = c("central", "minlike", "blaker")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counttest_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code> or a
list of such objects.</p>
</td></tr>
<tr><td><code id="counttest_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level of the test.</p>
</td></tr>
<tr><td><code id="counttest_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or the character &quot;convergence&quot; that
determines which iteration is used for the test.</p>
</td></tr>
<tr><td><code id="counttest_+3A_one_sided">one_sided</code></td>
<td>
<p>A logical value whether a two-sided test (<code>FALSE</code>)
should be conducted or a one-sided test (<code>TRUE</code>) that rejects only
when the number of detected outliers is above the expected number.</p>
</td></tr>
<tr><td><code id="counttest_+3A_tsmethod">tsmethod</code></td>
<td>
<p>A character specifying the method for calculating two-sided
p-values. Ignored for one-sided test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+outlier_detection">outlier_detection()</a></code> and
<code><a href="#topic+multi_cutoff">multi_cutoff()</a></code> for creating an object of class
<code>"robust2sls"</code> or a list thereof.
</p>
<p>See <code><a href="exactci.html#topic+poisson.exact">exactci::poisson.exact()</a></code> for the
different methods of calculating two-sided p-values.
</p>


<h3>Value</h3>

<p><code>counttest()</code> returns a data frame with the iteration (m) to be
tested, the actual iteration that was tested (generally coincides with the
iteration that was specified to be tested but is the convergent iteration
if the fixed point is tested), the setting of the probability of exceeding
the cut-off (gamma), the number of detected outliers, the expected number
of outliers under the null hypothesis that there are no outliers, the type
of test (one- or two-sided), the p-value, the significance level
<code>alpha</code>, the decision, and which method was used to calculate
(two-sided) p-values. The number of rows of the data frame corresponds to
the length of the argument <code>robust2sls_object</code>.
</p>

<hr>
<h2 id='estimate_param'>Estimation of moments of the data</h2><span id='topic+estimate_param'></span>

<h3>Description</h3>

<p>NOTE (12 Apr 2022): probably superseded by estimate_param_null() function
taken out of testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_param(robust2SLS_object, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_param_+3A_robust2sls_object">robust2SLS_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code> for which
the moments will be calculated.</p>
</td></tr>
<tr><td><code id="estimate_param_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 specifying based on which model iteration
the moments should be estimated. The model iteration affects which
observations are determined to be outliers and these observations will hence
be excluded during the estimation of the moments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DO NOT USE YET!
<code>estimate_param</code> can be used to estimate certain moments of the data
that are required for calculating the asymptotic variance of the gauge. Such
moments are the covariance between the standardised first stage errors and
the structural error <code class="reqn">\Omega</code>, the covariance matrix of the first stage
errors <code class="reqn">\Sigma</code>, the first stage parameter matrix <code class="reqn">\Pi</code>, and more.
</p>


<h3>Value</h3>

<p><code>estimate_param</code> returns a list with a similar structure as the
output of the Monte Carlo functionality <a href="#topic+generate_param">generate_param</a>. Hence, the
resulting list can be given to the function <a href="#topic+gauge_avar">gauge_avar</a> as argument
<code>parameters</code> to return an estimate of the asymptotic variance of the
gauge.
</p>


<h3>Warning</h3>

<p>The function is not yet fully developed. The estimators of the moments are
at the moment not guaranteed to be consistent for the population moments. DO
NOT USE!
</p>

<hr>
<h2 id='estimate_param_null'>Estimation of moments of the data</h2><span id='topic+estimate_param_null'></span>

<h3>Description</h3>

<p><code>estimate_param_null</code> can be used to estimate certain moments of the
data that are required for calculating the asymptotic variance of the gauge.
Such moments are the covariance between the standardised first stage errors
and the structural error <code class="reqn">\Omega</code>, the covariance matrix of the first
stage errors <code class="reqn">\Sigma</code>, the first stage parameter matrix <code class="reqn">\Pi</code>, and
more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_param_null(robust2SLS_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_param_null_+3A_robust2sls_object">robust2SLS_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code> for which
the moments will be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estimate_param_null</code> returns a list with a similar structure as
the output of the Monte Carlo functionality <a href="#topic+generate_param">generate_param</a>. Hence, the
resulting list can be given to the function <a href="#topic+gauge_avar">gauge_avar</a> as argument
<code>parameters</code> to return an estimate of the asymptotic variance of the
gauge.
</p>


<h3>Warning</h3>

<p>The function uses the full sample to estimate the moments. Therefore, they
are only consistent under the null hypothesis of no outliers and estimators
are likely to be inconsistent under the alternative.
</p>

<hr>
<h2 id='evaluate_boot'>Evaluate bootstrap results</h2><span id='topic+evaluate_boot'></span>

<h3>Description</h3>

<p>Evaluate bootstrap results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_boot(r2sls_boot, iterations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_boot_+3A_r2sls_boot">r2sls_boot</code></td>
<td>
<p>An object of <a href="base.html#topic+class">class</a> <code>"r2sls_boot"</code>, as returned
by <a href="#topic+case_resampling">case_resampling</a>.</p>
</td></tr>
<tr><td><code id="evaluate_boot_+3A_iterations">iterations</code></td>
<td>
<p>An integer or numeric vector with values &gt;= 0 specifying
which bootstrap results to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>evaluate_boot</code> returns a data frame with the bootstrap and the
theoretical standard errors. Each row corresponds to a different iteration
step while each column refers to the parameters whose standard errors are
produced.
</p>

<hr>
<h2 id='extract_boot'>Extracts bootstrap results for a specific iteration</h2><span id='topic+extract_boot'></span>

<h3>Description</h3>

<p>Extracts bootstrap results for a specific iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_boot(r2sls_boot, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_boot_+3A_r2sls_boot">r2sls_boot</code></td>
<td>
<p>An object of <a href="base.html#topic+class">class</a> <code>"r2sls_boot"</code>, as returned
by <a href="#topic+case_resampling">case_resampling</a>.</p>
</td></tr>
<tr><td><code id="extract_boot_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 specifying which bootstrap results to
extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>extract_boot</code> returns a matrix with the bootstrap results for
a specific iteration.#'
</p>

<hr>
<h2 id='extract_formula'>Extract the elements of ivreg formula</h2><span id='topic+extract_formula'></span>

<h3>Description</h3>

<p><code>extract_formula</code> takes a formula object for <code><a href="ivreg.html#topic+ivreg">ivreg</a></code>,
i.e. in a format of <code>y ~ x1 + x2 | x1 + z2</code> and extracts the different
elements in a list. Each element is a character vector storing the different
types of regressors. Element <code>y_var</code> refers to the dependent variable,
<code>x1_var</code> to the exogenous regressors, <code>x2_var</code> to the endogenous
regressors, <code>z1_var</code> to the exogenous regressors (which have to be
included again as instruments and hence coincide with <code>x1_var</code>), and
<code>z2_var</code> refers to the outside instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_formula(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_formula_+3A_formula">formula</code></td>
<td>
<p>A formula for the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> function, i.e. in
format <code>y ~ x1 + x2 | z1 + z2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>extract_formula</code> returns a list with five named components,
each of which is a character vector: <code>$y_var</code> refers to the dependent
variable, <code>$x1_var</code> to the exogenous regressors, <code>$x2_var</code> to the
endogenous regressors, <code>$z1_var</code> to the exogenous regressors (which have
to be included again as instruments and hence coincide with <code>$x1_var</code>),
and <code>$z2_var</code> refers to the outside instruments.
</p>

<hr>
<h2 id='gauge_avar'>Asymptotic variance of gauge</h2><span id='topic+gauge_avar'></span>

<h3>Description</h3>

<p><code>gauge_avar</code> calculates the asymptotic variance of the gauge for a
given iteration using a given set of parameters (true or estimated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauge_avar(
  ref_dist = c("normal"),
  sign_level,
  initial_est = c("robustified", "saturated", "iis"),
  iteration,
  parameters,
  split
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauge_avar_+3A_ref_dist">ref_dist</code></td>
<td>
<p>A character vector that specifies the reference distribution
against which observations are classified as outliers. <code>"normal"</code> refers
to the normal distribution.</p>
</td></tr>
<tr><td><code id="gauge_avar_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the cutoff
in the reference distribution against which observations are judged as
outliers or not.</p>
</td></tr>
<tr><td><code id="gauge_avar_+3A_initial_est">initial_est</code></td>
<td>
<p>A character vector that specifies the initial estimator
for the outlier detection algorithm. <code>"robustified"</code> means that the
full sample 2SLS is used as initial estimator. <code>"saturated"</code> splits
the sample into two parts and estimates a 2SLS on each subsample. The
coefficients of one subsample are used to calculate residuals and determine
outliers in the other subsample. <code>"iis"</code> applies impulse indicator
saturation (IIS) as implemented in <code><a href="ivgets.html#topic+ivisat">ivisat</a></code>.</p>
</td></tr>
<tr><td><code id="gauge_avar_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or character <code>"convergence"</code>
representing the iteration for which the outliers are calculated. Uses the
fixed point value if set to <code>"convergence"</code>.</p>
</td></tr>
<tr><td><code id="gauge_avar_+3A_parameters">parameters</code></td>
<td>
<p>A list created by <a href="#topic+generate_param">generate_param</a> or
<a href="#topic+estimate_param_null">estimate_param_null</a> that stores the parameters (true or estimated).
<code>NULL</code> permitted if <code>ref_dist == "normal"</code>.</p>
</td></tr>
<tr><td><code id="gauge_avar_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that determines
in which proportions the sample will be split. Can be <code>NULL</code> if
<code>initial_est == "robustified"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial estimator <code>"iis"</code> uses the asymptotic variances of
<code>"robustified"</code> 2SLS because there is no formal theory for the
multi-block search.
</p>


<h3>Value</h3>

<p><code>gauge_avar</code> returns a numeric value.
</p>

<hr>
<h2 id='gauge_covar'>Asymptotic covariance of gauge</h2><span id='topic+gauge_covar'></span>

<h3>Description</h3>

<p><code>gauge_covar</code> calculates the asymptotic covariance between two FODRs
with different cut-off values s and t for a given iteration using a given set
of parameters (true or estimated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauge_covar(
  ref_dist = c("normal"),
  sign_level1,
  sign_level2,
  initial_est = c("robustified", "saturated", "iis"),
  iteration,
  parameters,
  split
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauge_covar_+3A_ref_dist">ref_dist</code></td>
<td>
<p>A character vector that specifies the reference distribution
against which observations are classified as outliers. <code>"normal"</code> refers
to the normal distribution.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_sign_level1">sign_level1</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the first
cutoff in the reference distribution against which observations are judged
as outliers or not.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_sign_level2">sign_level2</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the second
cutoff in the reference distribution against which observations are judged
as outliers or not.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_initial_est">initial_est</code></td>
<td>
<p>A character vector that specifies the initial estimator
for the outlier detection algorithm. <code>"robustified"</code> means that the full
sample 2SLS is used as initial estimator. <code>"saturated"</code> splits the
sample into two parts and estimates a 2SLS on each subsample. The
coefficients of one subsample are used to calculate residuals and determine
outliers in the other subsample. <code>"iis"</code> applies impulse indicator
saturation (IIS) as implemented in <code><a href="ivgets.html#topic+ivisat">ivisat</a></code>.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or character <code>"convergence"</code>
representing the iteration for which the outliers are calculated. Uses the
fixed point value if set to <code>"convergence"</code>.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_parameters">parameters</code></td>
<td>
<p>A list created by <a href="#topic+generate_param">generate_param</a> or
<a href="#topic+estimate_param_null">estimate_param_null</a> that stores the parameters (true or estimated).
<code>NULL</code> permitted if <code>ref_dist == "normal"</code>.</p>
</td></tr>
<tr><td><code id="gauge_covar_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that determines
in which proportions the sample will be split. Can be <code>NULL</code> if
<code>initial_est == "robustified"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial estimator <code>"iis"</code> uses the asymptotic variances of
<code>"robustified"</code> 2SLS because there is no formal theory for the
multi-block search.
</p>


<h3>Value</h3>

<p><code>gauge_covar</code> returns a numeric value.
</p>

<hr>
<h2 id='generate_data'>Random data of 2SLS model (Monte Carlo)</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p><code>generate_data</code> draws random data for a 2SLS model given the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(parameters, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_parameters">parameters</code></td>
<td>
<p>A list with 2SLS model parameters as created by
<a href="#topic+generate_param">generate_param</a>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n">n</code></td>
<td>
<p>Sample size to be drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>generate_data</code> returns a data frame with <code>n</code> rows
(observations) and the following variables of the 2SLS model: dependent
variable y, exogenous regressors x1, endogenous regressors x2, structural
error u, outside instruments z2, first stage projection errors r1 (identical
to zero) and r2.
</p>

<hr>
<h2 id='generate_param'>Parameters of 2SLS model (Monte Carlo)</h2><span id='topic+generate_param'></span>

<h3>Description</h3>

<p>By default, <code>generate_param</code> creates random parameters of a 2SLS model
that satisfy conditions for 2SLS models, such as positive definite
variance-covariance matrices. The user can also specify certain parameters
directly, which are then checked for their validity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_param(
  dx1,
  dx2,
  dz2,
  intercept = TRUE,
  beta = NULL,
  sigma = 1,
  mean_z = NULL,
  cov_z = NULL,
  Sigma2_half = NULL,
  Omega2 = NULL,
  Pi = NULL,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_param_+3A_dx1">dx1</code></td>
<td>
<p>An integer value specifying the number of exogenous regressors.
This should include the intercept if it is present in the model
(see argument <code>intercept</code>).</p>
</td></tr>
<tr><td><code id="generate_param_+3A_dx2">dx2</code></td>
<td>
<p>An integer value specifying the number of endogenous regressors.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_dz2">dz2</code></td>
<td>
<p>An integer value specifying the number of outside /
excluded instruments.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_intercept">intercept</code></td>
<td>
<p>A logical value (<code>TRUE</code> / <code>FALSE</code>) indicating
whether the model should contain an intercept.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_beta">beta</code></td>
<td>
<p>A numeric vector of length <code>dx1 + dx2</code> specifying the
parameters of the structural equation.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_sigma">sigma</code></td>
<td>
<p>A strictly positive numeric value specifying the standard
deviation of the error in the structural model.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_mean_z">mean_z</code></td>
<td>
<p>A numeric vector of length <code>dx1 + dz2</code> specifying the mean
of the exogenous variables, x1 and z2.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_cov_z">cov_z</code></td>
<td>
<p>A numeric positive definite matrix specifying the
variance-covariance matrix of the exogenous variables, x1 and z2.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_sigma2_half">Sigma2_half</code></td>
<td>
<p>A numeric positive definite matrix of dimension
<code>dx2</code> by <code>dx2</code> such that its square is the variance-covariance
matrix of the random first stage errors (Sigma2).</p>
</td></tr>
<tr><td><code id="generate_param_+3A_omega2">Omega2</code></td>
<td>
<p>A numeric vector of length <code>dx1</code> specifying the
correlation between the scaled random first stage error and the structural
error.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_pi">Pi</code></td>
<td>
<p>A numeric matrix of dimension <code>(dx1 + dz2)</code> by
<code>(dx1 + dx2)</code> specifying the first stage parameter matrix.</p>
</td></tr>
<tr><td><code id="generate_param_+3A_seed">seed</code></td>
<td>
<p>An integer for setting the seed for the random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>generate_param</code> returns a list with the (randomly created or
user-specified) parameters that are required for drawing random data that.
The parameters are generated to fulfill the 2SLS model assumptions.
</p>

<dl>
<dt><code>$structural</code></dt><dd><p>A list with two components storing the mean
(<code>$mean</code>) and variance-covariance matrix (<code>$cov</code>) for the
structural error (u), the random first stage errors (r2), and all
instruments (excluding the intercept since it is not random) (z).</p>
</dd>
<dt><code>$params</code></dt><dd><p>A list storing the parameters of the 2SLS model.
<code>$beta</code> is the coefficient vector (including intercept if present) of
the structural equation, <code>$Pi</code> the coefficient matrix of the first
stage projections, <code>$Omega2</code> the covariance between the structural
error and the endogenous first stage errors, <code>$Sigma2_half</code> the square
root of the variance-covariance matrix of the endogenous first stage
errors, <code>$mean_z</code> the mean of all instruments (excluding the intercept
since it is not random), <code>$cov_z</code> the variance-covariance matrix of
the endogenous first-stage errors, <code>$Ezz</code> the expected value of the
squared instruments.</p>
</dd>
<dt><code>$settings</code></dt><dd><p>A list storing the function call (<code>$call</code>),
whether an intercept is included in the model (<code>$intercept</code>), a
regression formula for the model setup (<code>$formula</code>), and the
dimensions of the regressors and instruments (<code>$dx1</code>, <code>$dx2</code>,
<code>$dz2</code>.</p>
</dd>
<dt><code>$names</code></dt><dd><p>A list storing generic names for the regressors,
instruments, and errors as character vectors (<code>$x1</code>, <code>$x2</code>,
<code>$x</code>, <code>$z2</code>, <code>$z</code>, <code>$r</code>, and <code>$u</code>).</p>
</dd>
</dl>


<hr>
<h2 id='globaltest'>Global test correcting for multiple hypothesis testing</h2><span id='topic+globaltest'></span>

<h3>Description</h3>

<p><code>globaltest()</code> uses several proportion or count tests with different
cut-offs to test a global hypothesis of no outliers using the Simes (1986)
procedure to account for multiple testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globaltest(tests, global_alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globaltest_+3A_tests">tests</code></td>
<td>
<p>A data frame that contains a column named <code>$pval</code>
containing the different p-values for different hypothesis tests, each
stored in a row.</p>
</td></tr>
<tr><td><code id="globaltest_+3A_global_alpha">global_alpha</code></td>
<td>
<p>A numeric value representing the global significance
level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://academic.oup.com/biomet/article/73/3/751/250538">Simes (1986)</a>.
</p>


<h3>Value</h3>

<p>A list with three entries. The first entry named <code>$reject</code>
contains the global rejection decision. The second entry named
<code>$global_alpha</code> stores the global significance level. The third entry
named <code>$tests</code> returns the input data frame <code>tests</code>, appended
with two columns containing the adjusted significance level and respective
rejection decision.
</p>


<h3>See Also</h3>

<p>[proptest()], [counttest()]
</p>

<hr>
<h2 id='iis_init'>Impulse Indicator Saturation (IIS initial estimator)</h2><span id='topic+iis_init'></span>

<h3>Description</h3>

<p>Impulse Indicator Saturation (IIS initial estimator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iis_init(
  data,
  formula,
  gamma,
  t.pval = gamma,
  do.pet = FALSE,
  normality.JarqueB = NULL,
  turbo = FALSE,
  overid = NULL,
  weak = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iis_init_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="iis_init_+3A_formula">formula</code></td>
<td>
<p>A formula in the format <code>y ~ x1 + x2 | x1 + z2</code> where
<code>y</code> is the dependent variable, <code>x1</code> are the exogenous regressors,
<code>x2</code> the endogenous regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="iis_init_+3A_gamma">gamma</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level used for two-sided significance t-test on the impulse indicators.
Corresponds to the probability of falsely classifying an observation as an
outlier.</p>
</td></tr>
<tr><td><code id="iis_init_+3A_t.pval">t.pval</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level for the Parsimonious Encompassing Test (PET).</p>
</td></tr>
<tr><td><code id="iis_init_+3A_do.pet">do.pet</code></td>
<td>
<p>logical. If <code>TRUE</code>, then a Parsimonious Encompassing Test (PET) against the GUM is undertaken at each regressor removal for the joint significance of all the deleted regressors along the current path. If FALSE (default), then a PET is not undertaken at each regressor removal. By default, the numeric value is the same as that of <code>t.pval</code></p>
</td></tr>
<tr><td><code id="iis_init_+3A_normality.jarqueb">normality.JarqueB</code></td>
<td>
<p><code>NULL</code> (the default) or a value between 0 and 1. In the latter case, a test for non-normality is conducted using a significance level equal to <code>normality.JarqueB</code>. If <code>NULL</code>, then no test for non-normality is conducted</p>
</td></tr>
<tr><td><code id="iis_init_+3A_turbo">turbo</code></td>
<td>
<p>logical. If <code>TRUE</code>, then (parts of) paths are not searched twice (or more) unnecessarily, thus yielding a significant potential for speed-gain. However, the checking of whether the search has arrived at a point it has already been comes with a slight computational overhead. Accordingly, if <code>turbo=TRUE</code>, then the total search time might in fact be higher than if <code>turbo=FALSE</code>. This happens if estimation is very fast, say, less than quarter of a second. Hence the default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="iis_init_+3A_overid">overid</code></td>
<td>
<p><code>NULL</code> if no Sargan test of overidentifying restrictions
should be used as a diagnostic check for model selection or a numeric value
between 0 and 1. In the latter case, the test is conducted using this value
as the significance level.</p>
</td></tr>
<tr><td><code id="iis_init_+3A_weak">weak</code></td>
<td>
<p><code>NULL</code> if no weak instrument F-test on the first stage
should be used as a diagnostic check for model selection or a numeric value
between 0 and 1. In the latter case, the test is conducted using this value
as the significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>iis_init</code> returns a list with five elements. The first
four are vectors whose length equals the number of observations in the data
set. Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), it does not ignore observations where any of y, x
or z are missing. It instead sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
stores the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> model object based on which the four
vectors were calculated.
</p>


<h3>Note</h3>

<p>IIS runs multiple models, similar to <code><a href="#topic+saturated_init">saturated_init</a></code> but with
multiple block search. These intermediate models are not recorded. For
simplicity, the element <code>$model</code> of the returned list stores the full
sample model result, identical to <code><a href="#topic+robustified_init">robustified_init</a></code>.
</p>

<hr>
<h2 id='mc_grid'>Monte Carlo simulations parameter grid</h2><span id='topic+mc_grid'></span>

<h3>Description</h3>

<p>WARNING: not for average user - function not completed yet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_grid(
  M,
  n,
  seed,
  parameters,
  formula,
  ref_dist,
  sign_level,
  initial_est,
  iterations,
  convergence_criterion = NULL,
  max_iter = NULL,
  shuffle = FALSE,
  shuffle_seed = 10,
  split = 0.5,
  path = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_grid_+3A_m">M</code></td>
<td>
<p>Number of replications.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_n">n</code></td>
<td>
<p>Sample size for each replication.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_seed">seed</code></td>
<td>
<p>Random seed for the iterations.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_parameters">parameters</code></td>
<td>
<p>A list as created by <a href="#topic+generate_param">generate_param</a> that specifies
the true model.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_formula">formula</code></td>
<td>
<p>A formula that specifies the 2SLS model to be estimated. The
format has to follow <code>y ~ x1 + x2 | x1 + z2</code>, where <code>y</code> is the
dependent variable, <code>x1</code> are the exogenous regressors, <code>x2</code> the
endogenous regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_ref_dist">ref_dist</code></td>
<td>
<p>A character vector that specifies the reference distribution
against which observations are classified as outliers. <code>"normal"</code> refers
to the normal distribution.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the cutoff
in the reference distribution against which observations are judged as
outliers or not.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_initial_est">initial_est</code></td>
<td>
<p>A character vector that specifies the initial estimator
for the outlier detection algorithm. <code>"robustified"</code> means that the full
sample 2SLS is used as initial estimator. <code>"saturated"</code> splits the
sample into two parts and estimates a 2SLS on each subsample. The
coefficients of one subsample are used to calculate residuals and determine
outliers in the other subsample. <code>"user"</code> allows the user to specify a
model based on which observations are classified as outliers.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_iterations">iterations</code></td>
<td>
<p>An integer &gt;= 0 that specifies how often the outlier
detection algorithm is iterated and for which summary statistics will be
calculated. The value <code>0</code> means that outlier classification based on the
initial estimator is done. Alternatively, the character <code>"convergence"</code>
for iteration until convergence.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_convergence_criterion">convergence_criterion</code></td>
<td>
<p>A numeric value that determines whether the
algorithm has converged as measured by the L2 norm of the difference in
coefficients between the current and the previous iteration. Only used when
argument <code>iterations</code> is set to <code>"convergence"</code>.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_max_iter">max_iter</code></td>
<td>
<p>A numeric value &gt;= 1 or NULL. If
<code>iterations = "convergence"</code> is chosen, then the algorithm is stopped
after at most <code>max_iter</code> iterations. If also a
<code>convergence_criterion</code> is chosen then the algorithm stops when either
the criterion is fulfilled or the maximum number of iterations is reached.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_shuffle">shuffle</code></td>
<td>
<p>A logical value or <code>NULL</code>.
<code>initial_est == "saturated"</code>. If <code>TRUE</code> then the sample is shuffled
before creating the subsamples.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_shuffle_seed">shuffle_seed</code></td>
<td>
<p>An integer value that will set the seed for shuffling the
sample or <code>NULL</code>. Only used if <code>initial_est == "saturated"</code> and
<code>shuffle == TRUE</code>.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that determines
in which proportions the sample will be split.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_path">path</code></td>
<td>
<p>A character string or <code>FALSE</code>. The simulation grid can save
the individual results of each different entry in the grid to this
location. Individual results not saved if argument set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mc_grid_+3A_verbose">verbose</code></td>
<td>
<p>A logical value whether any messages should be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mc_grid</code> runs Monte Carlo simulations to assess the performance of
the theory of the gauge, simple proportion tests, and count tests.
</p>


<h3>Value</h3>

<p><code>mc_grid</code> returns a data frame with the results of the Monte
Carlo experiments. Each row corresponds to a specific simulation setup. The
columns record the simulation setup and its results. Currently, the average
proportion of detected outliers (&quot;mean_gauge&quot;) and their variance
(&quot;var_gauge&quot;) are being recorded. Moreover, the theoretical asymptotic
variance (&quot;avar&quot;) and the ratio of simulated to theoretical variance -
adjusted by the sample size - are calculated (&quot;var_ratio&quot;). Furthermore,
tentative results of size and power for the tests are calculated.
</p>


<h3>Details</h3>

<p>Requires the package <a href="https://cran.r-project.org/package=doRNG">doRNG</a>
to be installed, which has been orphaned as of 2022-12-09.
</p>
<p>The following arguments can also be supplied as a vector of their type:
<code>n</code>, <code>sign_level</code>, <code>initial_est</code>, and <code>split</code>. This makes
the function estimate all possible combinations of the arguments. Note that
the initial estimator <code>"robustified"</code> is not affected by the argument
<code>split</code> and hence is not varied in this case.
</p>
<p>For example, specifying <code>n = c(100, 1000)</code> and
<code>sign_level = c(0.01, 0.05)</code> estimates four Monte Carlo experiments with
the four possible combinations of the parameters.
</p>
<p>The <code>path</code> argument allows users to store the <code>M</code> replication
results for all of the individual Monte Carlo simulations that are part of
the grid. The results are saved both as <code>.Rds</code> and <code>.csv</code> files.
The file name is indicative of the simulation setting.
</p>

<hr>
<h2 id='multi_cutoff'>Multiple models, varying cut-off</h2><span id='topic+multi_cutoff'></span>

<h3>Description</h3>

<p><code>multi_cutoff()</code> runs several outlier detection algorithms that differ
in the value of the cut-off that determines whether an observation is
classified as an outlier or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_cutoff(gamma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_cutoff_+3A_gamma">gamma</code></td>
<td>
<p>A numeric vector representing the probability of falsely
classifying an observation as an outlier. One setting of the algorithm per
element of <code>gamma</code> is being run.</p>
</td></tr>
<tr><td><code id="multi_cutoff_+3A_...">...</code></td>
<td>
<p>Arguments for specifying the other settings of the outlier
detection algorithm, <code><a href="#topic+outlier_detection">outlier_detection</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mutli_cutoff</code> uses the
<code><a href="foreach.html#topic+foreach-package">foreach</a></code> and
<code><a href="future.html#topic+future">future</a></code> packages to run several models at the
same time in parallel. This means the user has to register a backend and
thereby determine how the code should be executed. The default is
sequential, i.e. not in parallel. See
<code><a href="future.html#topic+plan">future::plan()</a></code> for details.
</p>


<h3>Value</h3>

<p>A list containing the <code>robust2sls</code> objects, one per setting of
<code>gamma</code>. The length of the list therefore corresponds to the length of
the vector <code>gamma</code>.
</p>

<hr>
<h2 id='multi_cutoff_to_fodr_vec'>Creates a vector of the centered FODR across different cut-offs</h2><span id='topic+multi_cutoff_to_fodr_vec'></span>

<h3>Description</h3>

<p><code>multi_cutoff_to_fodr_vec()</code> takes a list of <code>"robust2sls"</code> objects
and returns a vector of the centered FODR (sample - expected) for different
values of the cut-off c (equivalently gamma):
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[ \sqrt{n}(\widehat{\gamma_{c}} - \gamma_{c}) \]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_cutoff_to_fodr_vec(robust2sls_object, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_cutoff_to_fodr_vec_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>A list of <code>"robust2sls"</code> objects.</p>
</td></tr>
<tr><td><code id="multi_cutoff_to_fodr_vec_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or the character &quot;convergence&quot; that
determines which iteration is used for the test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+outlier_detection">outlier_detection()</a></code> and
<code><a href="#topic+multi_cutoff">multi_cutoff()</a></code> for creating an object of class
<code>"robust2sls"</code> or a list thereof.
</p>


<h3>Value</h3>

<p>A numeric vector of the centered FODR values.
</p>

<hr>
<h2 id='mvn_sup'>Multivariate normal supremum simulation</h2><span id='topic+mvn_sup'></span>

<h3>Description</h3>

<p><code>mvn_sup</code> simulates the distribution of the supremum of the specified
multivariate normal distribution by drawing repeatedly from the multivariate
normal distribution and calculating the maximum of each vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn_sup(n, mu, Sigma, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn_sup_+3A_n">n</code></td>
<td>
<p>An integer determining the number of draws from the multivariate
normal distribution.</p>
</td></tr>
<tr><td><code id="mvn_sup_+3A_mu">mu</code></td>
<td>
<p>A numeric vector representing the mean of the multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="mvn_sup_+3A_sigma">Sigma</code></td>
<td>
<p>A numeric matrix representing the variance-covariance matrix of
the mutlivariate normal distribution.</p>
</td></tr>
<tr><td><code id="mvn_sup_+3A_seed">seed</code></td>
<td>
<p>An integer setting the random seed or <code>NULL</code> if it should
not be set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mvn_sup</code> returns a vector of suprema of length <code>n</code>.
</p>

<hr>
<h2 id='new_robust2sls'>Constructor of robust2sls class</h2><span id='topic+new_robust2sls'></span>

<h3>Description</h3>

<p><code>new_robust2sls</code> turns a list into an object of <a href="base.html#topic+class">class</a>
<code>"robust2sls"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_robust2sls(x = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_robust2sls_+3A_x">x</code></td>
<td>
<p>A list with components of the <code>"robust2sls"</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>new_robust2sls</code> returns an object of class <code>"robust2sls"</code>,
which is a list with a special structure of named components.
</p>


<h3>Warning</h3>

<p>Only checks that the input is a list but not that its components match the
requirements of the <code>"robust2sls"</code> class. Use the validator function
<code>validate_robust2sls</code> for that purpose.
</p>

<hr>
<h2 id='nonmissing'>Determine which observations can be used for estimation</h2><span id='topic+nonmissing'></span>

<h3>Description</h3>

<p><code>nonmissing</code> takes a dataframe and a formula and determines which
observations can principally be used for the estimation of the 2SLS model
that is specified by the formula. Observations where any of the y, x, or z
variables are missing will be set to FALSE. While technically, fitted values
and residuals could be calculated for observations where only any of the
outside instruments is missing, this is often not desirable. This would cause
the sample on which the model is estimated to be different from the sample
on which the outliers are determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonmissing(data, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonmissing_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="nonmissing_+3A_formula">formula</code></td>
<td>
<p>A formula for the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> function, i.e. in
format <code>y ~ x1 + x2 | z1 + z2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector with the same length as the number of
observations in the data set that specifies whether an observation has any
missing values in any of y, x, or z variables. TRUE means not missing, FALSE
means at least one of these variables necessary for estimation is missing.
</p>

<hr>
<h2 id='nonparametric'>Create indices for nonparametric bootstrap</h2><span id='topic+nonparametric'></span>

<h3>Description</h3>

<p><code>nonparametric</code> is used for nonparametric resampling, for example
nonparametric case or error/residual resampling. The function takes a vector
of indices that correspond to the indices of observations that should be used
in the resampling procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonparametric(
  indices,
  R,
  size = length(indices),
  replacement = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonparametric_+3A_indices">indices</code></td>
<td>
<p>A vector of indices (integer) from which to sample.</p>
</td></tr>
<tr><td><code id="nonparametric_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of resamples.</p>
</td></tr>
<tr><td><code id="nonparametric_+3A_size">size</code></td>
<td>
<p>An integer specifying the size of the resample. Standard
bootstrap suggests to resample as many datapoints as in the original sample,
which is set as the default.</p>
</td></tr>
<tr><td><code id="nonparametric_+3A_replacement">replacement</code></td>
<td>
<p>A logical value whether to sample with (TRUE) or without
(FALSE) replacement. Standard bootstrap suggests to resample with
replacement, which is set as the default.</p>
</td></tr>
<tr><td><code id="nonparametric_+3A_seed">seed</code></td>
<td>
<p><code>NULL</code> if seed should not be set explicitly or an integer to
which the seed is set. Since this function is usually used inside other
functions, it might not be desirable to set a seed explicitly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nonparametric</code> returns a list of length <code>R</code> containing
vectors with the resampled indices.
</p>

<hr>
<h2 id='nonparametric_resampling'>Nonparametric resampling from a data frame</h2><span id='topic+nonparametric_resampling'></span>

<h3>Description</h3>

<p>Nonparametric resampling from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonparametric_resampling(df, resample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonparametric_resampling_+3A_df">df</code></td>
<td>
<p>Data frame containing observations to be sampled from.</p>
</td></tr>
<tr><td><code id="nonparametric_resampling_+3A_resample">resample</code></td>
<td>
<p>A vector of indices that extract the observations from the
data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input to the <code>resample</code> argument could for example be generated as
one of the elements in the list generated by the command
<a href="#topic+nonparametric">nonparametric</a>.
</p>
<p>The input to the <code>df</code> argument would be the original data frame for case
resampling. For error/residual resampling, it would be a data frame
containing the residuals from the model.
</p>


<h3>Value</h3>

<p><code>nonparametric_resampling</code> returns a data frame containing the
observations of the resample.
</p>

<hr>
<h2 id='outlier'>Outlier history of single observation</h2><span id='topic+outlier'></span>

<h3>Description</h3>

<p><code>outlier</code> takes a <code>"robust2sls"</code> object and the index of a specific
observation and returns its history of classification across the different
iterations contained in the <code>"robust2sls"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier(robust2sls_object, obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="outlier_+3A_obs">obs</code></td>
<td>
<p>An index (row number) of an observation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>outlier</code> returns a vector that contains the 'type' value for
the given observations across the different iterations. There are three
possible values: 0 if the observations is judged to be an outlier, 1 if not,
and -1 if any of its x, y, or z values required for estimation is missing.
</p>

<hr>
<h2 id='outlier_detection'>Outlier detection algorithms</h2><span id='topic+outlier_detection'></span>

<h3>Description</h3>

<p><code>outlier_detection</code> provides different types of outlier detection
algorithms depending on the arguments provided. The decision whether to
classify an observations as an outlier or not is based on its standardised
residual in comparison to some user-specified reference distribution. <br />
The algorithms differ mainly in two ways. First, they can differ by the use
of initial estimator, i.e. the estimator based on which the first
classification as outliers is made. Second, the algorithm can either be
iterated a fixed number of times or until the difference in coefficient
estimates between the most recent model and the previous one is smaller than
some user-specified convergence criterion. The difference is measured by
the L2 norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier_detection(
  data,
  formula,
  ref_dist = c("normal"),
  sign_level,
  initial_est = c("robustified", "saturated", "user", "iis"),
  user_model = NULL,
  iterations = 1,
  convergence_criterion = NULL,
  max_iter = NULL,
  shuffle = FALSE,
  shuffle_seed = NULL,
  split = 0.5,
  verbose = FALSE,
  iis_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier_detection_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_formula">formula</code></td>
<td>
<p>A formula for the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> function, i.e. in
the format <code>y ~ x1 + x2 | x1 + z2</code> where <code>y</code> is the dependent
variable, <code>x1</code> are the exogenous regressors, <code>x2</code> the endogenous
regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_ref_dist">ref_dist</code></td>
<td>
<p>A character vector that specifies the reference distribution
against which observations are classified as outliers. <code>"normal"</code> refers
to the normal distribution.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the cutoff
in the reference distribution against which observations are judged as
outliers or not.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_initial_est">initial_est</code></td>
<td>
<p>A character vector that specifies the initial estimator
for the outlier detection algorithm. <code>"robustified"</code> means that the
full sample 2SLS is used as initial estimator. <code>"saturated"</code> splits
the sample into two parts and estimates a 2SLS on each subsample. The
coefficients of one subsample are used to calculate residuals and determine
outliers in the other subsample. <code>"user"</code> allows the user to specify a
model based on which observations are classified as outliers. <code>"iis"</code>
applies impulse indicator saturation (IIS) as implemented in
<code><a href="ivgets.html#topic+ivisat">ivisat</a></code>. See section &quot;Warning&quot; for more information
and conditions.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_user_model">user_model</code></td>
<td>
<p>A model object of <a href="base.html#topic+class">class</a> <a href="ivreg.html#topic+ivreg">ivreg</a>. Only
required if argument <code>initial_est</code> is set to <code>"user"</code>, otherwise
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_iterations">iterations</code></td>
<td>
<p>Either an integer &gt;= 0 that specifies how often the outlier
detection algorithm is iterated, or the character vector
<code>"convergence"</code>. In the former case, the value <code>0</code> means that only
outlier classification based on the initial estimator is done. In the latter,
the algorithm is iterated until it converges, i.e. when the difference in
coefficient estimates between the most recent model and the previous one is
smaller than some user-specified convergence criterion.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_convergence_criterion">convergence_criterion</code></td>
<td>
<p>A numeric value or NULL. The algorithm stops as
soon as the difference in coefficient estimates between the most recent model
and the previous one is smaller than <code>convergence_criterion</code>. The
difference is measured by the L2 norm. If the argument is set to a numeric
value but <code>iterations</code> is an integer &gt; 0 then the algorithm stops either
when it converged or when <code>iterations</code> is reached.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_max_iter">max_iter</code></td>
<td>
<p>A numeric value &gt;= 1 or NULL. If
<code>iterations = "convergence"</code> is chosen, then the algorithm is stopped
after at most <code>max_iter</code> iterations. If also a
<code>convergence_criterion</code> is chosen then the algorithm stops when either
the criterion is fulfilled or the maximum number of iterations is reached.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_shuffle">shuffle</code></td>
<td>
<p>A logical value or <code>NULL</code>. Only used if
<code>initial_est == "saturated"</code>. If <code>TRUE</code> then the sample is shuffled
before creating the subsamples.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_shuffle_seed">shuffle_seed</code></td>
<td>
<p>An integer value that will set the seed for shuffling the
sample or <code>NULL</code>. Only used if <code>initial_est == "saturated"</code> and
<code>shuffle == TRUE</code>.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that determines
in which proportions the sample will be split.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_verbose">verbose</code></td>
<td>
<p>A logical value whether progress during estimation should be
reported.</p>
</td></tr>
<tr><td><code id="outlier_detection_+3A_iis_args">iis_args</code></td>
<td>
<p>A list with named entries corresponding to the arguments for
<code><a href="#topic+iis_init">iis_init</a></code> (<code>t.pval</code>, <code>do.pet</code>,
<code>normality.JarqueB</code>, <code>turbo</code>, <code>overid</code>, <code>weak</code>). Can be
<code>NULL</code> if <code>initial_est != "iis"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>outlier_detection</code> returns an object of class
<code>"robust2sls"</code>, which is a list with the following components:
</p>

<dl>
<dt><code>$cons</code></dt><dd><p>A list which stores high-level information about the
function call and some results. <code>$call</code> is the captured function call,
<code>$formula</code> the formula argument, <code>$data</code> the original data set,
<code>$reference</code> the chosen reference distribution to classify outliers,
<code>$sign_level</code> the significance level, <code>$psi</code> the probability that
an observation is not classified as an outlier under the null hypothesis
of no outliers, <code>$cutoff</code> the cutoff used to classify outliers if
their standardised residuals are larger than that value, <code>$bias_corr</code>
a bias correction factor to account for potential false positives
(observations classified as outliers even though they are not). There are
three further elements that are lists themselves. <br /> <br />
<code>$initial</code> stores settings about the initial estimator:
<code>$estimator</code> is the type of the initial estimator (e.g. robustified or
saturated), <code>$split</code> how the sample is split (<code>NULL</code> if argument
not used), <code>$shuffle</code> whether the sample is shuffled before splitting
(<code>NULL</code> if argument not used), <code>$shuffle_seed</code> the value of the
random seed (<code>NULL</code> if argument not used). <br /> <br />
<code>$convergence</code> stores information about the convergence of the
outlier-detection algorithm:
<code>$criterion</code> is the user-specified convergence criterion (<code>NULL</code>
if argument not used), <code>$difference</code> is the L2 norm between the last
coefficient estimates and the previous ones (<code>NULL</code> if argument not
used or only initial estimator calculated). <code>$converged</code> is a logical
value indicating whether the algorithm has converged, i.e. whether the
difference is smaller than the convergence criterion (<code>NULL</code> if
argument not used). <code>$max_iter</code> is the maximum iteration set by the
user (<code>NULL</code> if argument not used or not set). <br /> <br />
<code>$iterations</code> contains information about the user-specified iterations
argument (<code>$setting</code>) and the actual number of iterations that were
done (<code>$actual</code>). The actual number can be lower if the algorithm
converged already before the user-specified number of iterations were
reached.</p>
</dd>
<dt><code>$model</code></dt><dd><p>A list storing the model objects of class
<a href="ivreg.html#topic+ivreg">ivreg</a> for each iteration. Each model is stored under
<code>$m0</code>, <code>$m1</code>, ...</p>
</dd>
<dt><code>$res</code></dt><dd><p>A list storing the residuals of all observations for
each iteration. Residuals of observations where any of the y, x, or z
variables used in the 2SLS model are missing are set to NA. Each vector is
stored under <code>$m0</code>, <code>$m1</code>, ...</p>
</dd>
<dt><code>$stdres</code></dt><dd><p>A list storing the standardised residuals of all
observations for each iteration. Standardised residuals of observations
where any of the y, x, or z variables used in the 2SLS model are missing
are set to NA. Standardisation is done by dividing by sigma, which is not
adjusted for degrees of freedom. Each vector is stored under <code>$m0</code>,
<code>$m1</code>, ...</p>
</dd>
<dt><code>$sel</code></dt><dd><p>A list of logical vectors storing whether an observation
is included in the estimation or not. Observations are excluded (FALSE) if
they either have missing values in any of the x, y, or z variables needed
in the model or when they are classified as outliers based on the model.
Each vector is stored under <code>$m0</code>, <code>$m1</code>, ...</p>
</dd>
<dt><code>$type</code></dt><dd><p>A list of integer vectors indicating whether an
observation has any missing values in x, y, or z (<code>-1</code>), whether it is
classified as an outlier (<code>0</code>) or not (<code>1</code>). Each vector is
stored under <code>$m0</code>, <code>$m1</code>, ...</p>
</dd>
</dl>



<h3>Warning</h3>

<p>Check <a href="https://drive.google.com/file/d/1qPxDJnLlzLqdk94X9wwVASptf1MPpI2w/view">Jiao (2019)</a>
(as well as forthcoming working paper in the future) about conditions on the
initial estimator that should be satisfied for the initial estimator when
using <code>initial_est == "user"</code> (e.g. they have to be Op(1)).
IIS is a generalisation of <code><a href="#topic+saturated_init">Saturated 2SLS</a></code> with
multiple block search but no asymptotic theory exists for IIS.
</p>

<hr>
<h2 id='outliers'>Number of outliers</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p><code>outliers</code> calculates the number of outliers from a <code>"robust2sls"</code>
object for a given iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(robust2sls_object, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliers_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="outliers_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 representing the iteration for which the
outliers are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>outliers</code> returns the number of outliers  for a given iteration
as determined by the outlier-detection algorithm.
</p>

<hr>
<h2 id='outliers_prop'>Proportion of outliers</h2><span id='topic+outliers_prop'></span>

<h3>Description</h3>

<p><code>outliers_prop</code> calculates the proportion of outliers relative to all
non-missing observations in the full sample from a <code>"robust2sls"</code> object
for a given iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers_prop(robust2sls_object, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliers_prop_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="outliers_prop_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 representing the iteration for which the
outliers are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>outliers_prop</code> returns the proportion of outliers for a given
iteration as determined by the outlier-detection algorithm.
</p>

<hr>
<h2 id='plot.robust2sls'>Plotting of standardised residuals and outliers</h2><span id='topic+plot.robust2sls'></span>

<h3>Description</h3>

<p>Plot method for objects of <a href="base.html#topic+class">class</a> <code>"robust2sls"</code>. Plots the
standardised residuals of non-missing observations for a given iteration of
the outlier-detection algorithm and distinguishes whether an observation is
classified as an outlier by colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robust2sls'
plot(x, iteration = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.robust2sls_+3A_x">x</code></td>
<td>
<p>An object of <a href="base.html#topic+class">class</a> <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="plot.robust2sls_+3A_iteration">iteration</code></td>
<td>
<p>Either <code>NULL</code> (default) or an integer specifying the
iteration that should be plotted. The default uses the final model.</p>
</td></tr>
<tr><td><code id="plot.robust2sls_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, see <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.robust2sls</code> returns a graph of <a href="base.html#topic+class">class</a>
<a href="ggplot2.html#topic+ggplot">ggplot</a>.
</p>

<hr>
<h2 id='print.robust2sls'>Helper of robust2sls class</h2><span id='topic+print.robust2sls'></span>

<h3>Description</h3>

<p><code>robust2sls</code> allows the user to create an object of <a href="base.html#topic+class">class</a>
<code>"robust2sls"</code> by specifying the different components of the list. The
validator function <code>validate_robust2sls</code> is called at the end to ensure
that the resulting object is a valid object of <a href="base.html#topic+class">class</a>
<code>"robust2sls"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robust2sls'
print(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.robust2sls_+3A_x">x</code></td>
<td>
<p>An object of <a href="base.html#topic+class">class</a> <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="print.robust2sls_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, <code>TRUE</code> or <code>FALSE</code>, determining
whether detailed (<code>TRUE</code>) or shortened (<code>FALSE</code>) should be printed.</p>
</td></tr>
<tr><td><code id="print.robust2sls_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods, see
<a href="base.html#topic+print">print</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printing summary output
</p>
<p>Print method for objects of <a href="base.html#topic+class">class</a> <code>"robust2sls"</code>. Prints a
high-level summary of the settings and results of the outlier-detection
algorithm.
</p>


<h3>Value</h3>

<p>No return value, prints model summary.
</p>

<hr>
<h2 id='proptest'>Proportion test</h2><span id='topic+proptest'></span>

<h3>Description</h3>

<p><code>proptest()</code> conducts a test whether the false outlier detection rate
(FODR) in the sample deviates significantly from its expected value
(population FODR) under the null hypothesis that there are no outliers in the
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proptest(robust2sls_object, alpha, iteration, one_sided = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proptest_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>An object of class <code>"robust2sls"</code> or a
list of such objects.</p>
</td></tr>
<tr><td><code id="proptest_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level of the test.</p>
</td></tr>
<tr><td><code id="proptest_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or the character &quot;convergence&quot; that
determines which iteration is used for the test.</p>
</td></tr>
<tr><td><code id="proptest_+3A_one_sided">one_sided</code></td>
<td>
<p>A logical value whether a two-sided test (<code>FALSE</code>)
should be conducted or a one-sided test (<code>TRUE</code>) that rejects only
when the false outlier detection rate is above its expected value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+outlier_detection">outlier_detection()</a></code> and
<code><a href="#topic+multi_cutoff">multi_cutoff()</a></code> for creating an object of class
<code>"robust2sls"</code> or a list thereof.
</p>


<h3>Value</h3>

<p><code>proptest()</code> returns a data frame with the iteration (m) to be
tested, the actual iteration that was tested (generally coincides with the
iteration that was specified to be tested but is the convergent iteration if
the fixed point is tested), the setting of the probability of exceeding the
cut-off (gamma), the type of t-test (one- or two-sided), the value of the
test statistic, its p-value, the significance level <code>alpha</code>, and the
decision. The number of rows of the data frame corresponds to the length of
the argument <code>robust2sls_object</code>.
</p>

<hr>
<h2 id='robust2sls-package'>robust2sls: A package for outlier robust 2SLS inference and testing</h2><span id='topic+robust2sls-package'></span>

<h3>Description</h3>

<p>The robust2sls package provides two main functionalities. First, it
implements an algorithm for determining whether an observations is an outlier
based on its standardized residual and re-estimation based on the sub-sample
excluding all outliers. This procedure is often used in empirical research to
show that the results are not driven by outliers. This package has
implemented the algorithm in various forms and the user can select between
different initial estimators and how often the algorithm is iterated. The
statistical inference is adapted to account for potential false positives
(classifying observations as outliers even though they are not).
</p>
<p>Second, the robust2sls package provides easy-to-use statistical tests on
whether the difference between the original and the outlier-robust estimates
is statistically significant. Furthermore, several different statistical
tests are implemented to test whether the sample actually contains outliers.
</p>

<hr>
<h2 id='robustified_init'>Robustified 2SLS (full sample initial estimator)</h2><span id='topic+robustified_init'></span>

<h3>Description</h3>

<p><code>robustified_init</code> estimates the full sample 2SLS model, which is used
as the initial estimator for the iterative procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustified_init(data, formula, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustified_init_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="robustified_init_+3A_formula">formula</code></td>
<td>
<p>A formula in the format <code>y ~ x1 + x2 | x1 + z2</code> where
<code>y</code> is the dependent variable, <code>x1</code> are the exogenous regressors,
<code>x2</code> the endogenous regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="robustified_init_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric cutoff value used to judge whether an observation
is an outlier or not. If its absolute value is larger than the cutoff value,
the observations is classified as an outlier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>robustified_init</code> returns a list with five elements. The first
four are vectors whose length equals the number of observations in the data
set. Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), it does not ignore observations where any of y, x
or z are missing. It instead sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
stores the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> model object based on which the four
vectors were calculated.
</p>

<hr>
<h2 id='saturated_init'>Saturated 2SLS (split-sample initial estimator)</h2><span id='topic+saturated_init'></span>

<h3>Description</h3>

<p><code>saturated_init</code> splits the sample into two sub-samples. The 2SLS model
is estimated on both sub-samples and the estimates of one sub-sample are
used to calculate the residuals and hence outliers from the other sub-sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saturated_init(data, formula, cutoff, shuffle, shuffle_seed, split = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saturated_init_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="saturated_init_+3A_formula">formula</code></td>
<td>
<p>A formula in the format <code>y ~ x1 + x2 | x1 + z2</code> where
<code>y</code> is the dependent variable, <code>x1</code> are the exogenous regressors,
<code>x2</code> the endogenous regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="saturated_init_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric cutoff value used to judge whether an observation
is an outlier or not. If its absolute value is larger than the cutoff value,
the observations is classified as an outlier.</p>
</td></tr>
<tr><td><code id="saturated_init_+3A_shuffle">shuffle</code></td>
<td>
<p>A logical value (<code>TRUE</code> or <code>FALSE</code>) whether the
sample should be split into sub-samples randomly. If <code>FALSE</code>, the sample
is simply cut into two parts using the original order of the supplied data
set.</p>
</td></tr>
<tr><td><code id="saturated_init_+3A_shuffle_seed">shuffle_seed</code></td>
<td>
<p>A numeric value that sets the seed for shuffling the
data set before splitting it. Only used if <code>shuffle == TRUE</code>.</p>
</td></tr>
<tr><td><code id="saturated_init_+3A_split">split</code></td>
<td>
<p>A numeric value strictly between 0 and 1 that determines
in which proportions the sample will be split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>saturated_init</code> returns a list with five elements. The first
four are vectors whose length equals the number of observations in the data
set. Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), it does not ignore observations where any of y, x
or z are missing. It instead sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
is a list with the two initial <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> model objects based
on the two different sub-samples.
</p>


<h3>Warning</h3>

<p>The estimator may have bad properties if the <code>split</code> is too unequal and
the sample size is not large enough.
</p>

<hr>
<h2 id='selection'>Create selection (non-outlying) vector from model</h2><span id='topic+selection'></span>

<h3>Description</h3>

<p><code>selection</code> uses the data and model objects to create a list with five
elements that are used to determine whether the observations are judged as
outliers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(data, yvar, model, cutoff, bias_correction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="selection_+3A_yvar">yvar</code></td>
<td>
<p>A character vector of length 1 that refers to the name of the
dependent variable in the data set.</p>
</td></tr>
<tr><td><code id="selection_+3A_model">model</code></td>
<td>
<p>A model object of <a href="base.html#topic+class">class</a> <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> whose
parameters are used to calculate the residuals.</p>
</td></tr>
<tr><td><code id="selection_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric cutoff value used to judge whether an observation
is an outlier or not. If its absolute value is larger than the cutoff value,
the observations is classified as being an outlier.</p>
</td></tr>
<tr><td><code id="selection_+3A_bias_correction">bias_correction</code></td>
<td>
<p>A numeric factor used to correct the estimate of
sigma under the null hypothesis of no outliers or <code>NULL</code> if no
correction should be done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements. The first four are vectors whose length
equals the number of observations in the data set. Unlike the residuals
stored in a model object (usually accessible via <code>model$residuals</code>), it
does not ignore observations where any of y, x or z are missing. It instead
sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
stores the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> model object based on which the four
vectors were calculated.
</p>


<h3>Warning</h3>

<p>Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), this function returns vectors of the same length as
the original data set even if any of the y, x, or z variables are missing.
The residuals for those observations are set to <code>NA</code>.
</p>

<hr>
<h2 id='selection_iis'>Create selection (non-outlying) vector from IIS model</h2><span id='topic+selection_iis'></span>

<h3>Description</h3>

<p><code>selection_iis</code> uses the data and isat model object to create a list
with five elements that are used to determine whether the observations are
judged as outliers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection_iis(x, data, yvar, complete, rownames_orig, refmodel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_iis_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="ivgets.html#topic+ivisat">ivisat</a></code>.</p>
</td></tr>
<tr><td><code id="selection_iis_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="selection_iis_+3A_yvar">yvar</code></td>
<td>
<p>A character vector of length 1 that refers to the name of the
dependent variable in the data set.</p>
</td></tr>
<tr><td><code id="selection_iis_+3A_complete">complete</code></td>
<td>
<p>A logical vector with the same length as the number of
observations in the data set that specifies whether an observation has any
missing values in any of y, x, or z variables.</p>
</td></tr>
<tr><td><code id="selection_iis_+3A_rownames_orig">rownames_orig</code></td>
<td>
<p>A character vector storing the original rownames of the
dataframe.</p>
</td></tr>
<tr><td><code id="selection_iis_+3A_refmodel">refmodel</code></td>
<td>
<p>A model object that will be stored in <code>$model</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements. The first four are vectors whose length
equals the number of observations in the data set. Unlike the residuals
stored in a model object (usually accessible via <code>model$residuals</code>), it
does not ignore observations where any of y, x or z are missing. It instead
sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
stores the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> model object based on which the four
vectors were calculated.
</p>


<h3>Note</h3>

<p>IIS runs multiple models, similar to <code><a href="#topic+saturated_init">saturated_init</a></code> but with
multiple block search. These intermediate models are not recorded. For
simplicity, the element <code>$model</code> of the returned list stores the full
sample model result, identical to <code><a href="#topic+robustified_init">robustified_init</a></code>.
</p>


<h3>Warning</h3>

<p>Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), this function returns vectors of the same length as
the original data set even if any of the y, x, or z variables are missing.
The residuals for those observations are set to <code>NA</code>.
</p>

<hr>
<h2 id='simes'>Simes (1986) procedure for multiple testing</h2><span id='topic+simes'></span>

<h3>Description</h3>

<p><code>simes()</code> takes a vector of p-values corresponding to individual null
hypotheses and performs the Simes (1986) procedure for the global null
hypothesis. The global null hypothesis is the intersection of all individual
null hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simes(pvals, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simes_+3A_pvals">pvals</code></td>
<td>
<p>A numeric vector of p-values corresponding to the p-values of
the individual null hypotheses.</p>
</td></tr>
<tr><td><code id="simes_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value representing the global significance level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://academic.oup.com/biomet/article/73/3/751/250538">Simes (1986)</a>.
</p>


<h3>Value</h3>

<p><code>simes()</code> returns a list with three named elements.
<code>$reject</code> stores a logical value whether the global null hypothesis has
been rejected. <code>$alpha</code> stores the significance level that was chosen.
<code>$details</code> stores a matrix of the individual null hypothesis p-values,
the adjusted significance level according to Simes' procedure, and the
rejection decision for each individual hypothesis test.
</p>

<hr>
<h2 id='sumtest'>Scaling sum proportion test across different cut-offs</h2><span id='topic+sumtest'></span>

<h3>Description</h3>

<p><code>sumtest()</code> uses the estimations across several cut-offs to test whether
the sum of the deviations between sample and population FODR differ
significantly from its expected value.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[\sum_{k = 1}^{K} \sqrt{n}(\widehat{\gamma}_{c_{k}} - \gamma_{c_{k}}) \]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumtest(robust2sls_object, alpha, iteration, one_sided = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumtest_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>A list of <code>"robust2sls"</code> objects.</p>
</td></tr>
<tr><td><code id="sumtest_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level of the test.</p>
</td></tr>
<tr><td><code id="sumtest_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or the character &quot;convergence&quot; that
determines which iteration is used for the test.</p>
</td></tr>
<tr><td><code id="sumtest_+3A_one_sided">one_sided</code></td>
<td>
<p>A logical value whether a two-sided test (<code>FALSE</code>)
should be conducted or a one-sided test (<code>TRUE</code>) that rejects only
when the false outlier detection rate is above its expected value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sumtest()</code> returns a data frame with one row storing the
iteration that was tested, the value of the test statistic (t-test), the
type of the test (one- or two-sided), the corresponding p-value, the
significance level, and whether the null hypothesis is rejected. The data
frame also contains an attribute named <code>"gammas"</code> that records which
gammas determining the different cut-offs were used in the scaling sum test.
</p>

<hr>
<h2 id='suptest'>Supremum proportion test across different cut-offs</h2><span id='topic+suptest'></span>

<h3>Description</h3>

<p><code>suptest()</code> uses the estimations across several cut-offs to test whether
the supremum/maximum of the deviations between sample and population FODR
differs significantly from its expected value.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
\[ \sup_{c} |\sqrt{n}(\widehat{\gamma}_{c} - \gamma_{c})| \]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suptest(robust2sls_object, alpha, iteration, p = c(0.9, 0.95, 0.99), R = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suptest_+3A_robust2sls_object">robust2sls_object</code></td>
<td>
<p>A list of <code>"robust2sls"</code> objects.</p>
</td></tr>
<tr><td><code id="suptest_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 representing the significance
level of the test.</p>
</td></tr>
<tr><td><code id="suptest_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 0 or the character &quot;convergence&quot; that
determines which iteration is used for the test.</p>
</td></tr>
<tr><td><code id="suptest_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities with values in [0,1] for which the
corresponding quantiles are calculated.</p>
</td></tr>
<tr><td><code id="suptest_+3A_r">R</code></td>
<td>
<p>An integer specifying the number of replications for simulating the
distribution of the test statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>suptest()</code> returns a data frame with one row storing the
iteration that was tested, the value of the test statistic, the corresponding
p-value, the significance level, and whether the null hypothesis is rejected.
The data frame also contains two named attributes. The first attribute is
named <code>"gammas"</code> and records which gammas determining the different
cut-offs were used in the scaling sup test. The second attribute is named
<code>"critical"</code> and records the critical values corresponding to the
different quantiles in the limiting distribution that were specified in
<code>p</code>.
</p>

<hr>
<h2 id='test_cpv'>Critical and p-value for test statistic relative to simulated distribution</h2><span id='topic+test_cpv'></span>

<h3>Description</h3>

<p><code>test_cpv</code> returns the critical value corresponding to a given
quantile of the simulated distribution and the p-value of the test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_cpv(dist, teststat, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_cpv_+3A_dist">dist</code></td>
<td>
<p>A numeric vector of simulated values approximating the
distribution of the test statistic, e.g. generated as in <code>mvn_sup()</code>.</p>
</td></tr>
<tr><td><code id="test_cpv_+3A_teststat">teststat</code></td>
<td>
<p>A numeric value of the test statistic.</p>
</td></tr>
<tr><td><code id="test_cpv_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities with values in [0,1] for which the
corresponding quantiles are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named entries. <code>$pval</code> is the p-value of the
test statistic with respect to the distribution <code>dist</code>. <code>$q</code> is the
vector of sample quantiles in the distribution <code>dist</code> corresponding to
the probabilities specified in <code>p</code>.
</p>

<hr>
<h2 id='update_list'>Append new iteration results to <code>"robust2sls"</code> object</h2><span id='topic+update_list'></span>

<h3>Description</h3>

<p><code>update_list</code> takes an existing <code>"robust2sls"</code> object and appends
the estimation results (<a href="ivreg.html#topic+ivreg">ivreg</a> model object, residuals,
standardised residuals, selection and type vectors) of a new iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_list(current_list, new_info, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_list_+3A_current_list">current_list</code></td>
<td>
<p>A list object of class <code>"robust2sls"</code>.</p>
</td></tr>
<tr><td><code id="update_list_+3A_new_info">new_info</code></td>
<td>
<p>A list with named components <code>$model</code>, <code>$res</code>,
<code>$stdres</code>, <code>$sel</code>, and <code>$type</code>.</p>
</td></tr>
<tr><td><code id="update_list_+3A_name">name</code></td>
<td>
<p>A character vector of length one naming the appended iteration
results. Convention is <code>"m0"</code>, <code>"m1"</code>, <code>"m2"</code> etc. for
iterations 0 (initial), 1, 3...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"robust2sls"</code> whose components
<code>$model</code>, <code>$res</code>, <code>$stdres</code>, <code>$sel</code>, and <code>$type</code> are
now appended with the new iteration results.
</p>

<hr>
<h2 id='user_init'>User-specified initial estimator</h2><span id='topic+user_init'></span>

<h3>Description</h3>

<p><code>user_init</code> uses a model supplied by the user as the initial estimator.
Based on this estimator, observations are classified as outliers or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_init(data, formula, cutoff, user_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="user_init_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="user_init_+3A_formula">formula</code></td>
<td>
<p>A formula in the format <code>y ~ x1 + x2 | x1 + z2</code> where
<code>y</code> is the dependent variable, <code>x1</code> are the exogenous regressors,
<code>x2</code> the endogenous regressors, and <code>z2</code> the outside instruments.</p>
</td></tr>
<tr><td><code id="user_init_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric cutoff value used to judge whether an observation
is an outlier or not. If its absolute value is larger than the cutoff value,
the observations is classified as an outlier.</p>
</td></tr>
<tr><td><code id="user_init_+3A_user_model">user_model</code></td>
<td>
<p>A model object of <a href="base.html#topic+class">class</a> <a href="ivreg.html#topic+ivreg">ivreg</a> whose
parameters are used to calculate the residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>user_init</code> returns a list with five elements. The first
four are vectors whose length equals the number of observations in the data
set. Unlike the residuals stored in a model object (usually accessible via
<code>model$residuals</code>), it does not ignore observations where any of y, x
or z are missing. It instead sets their values to <code>NA</code>.
</p>
<p>The first element is a double vector containing the residuals for each
observation based on the model estimates. The second element contains the
standardised residuals, the third one a logical vector with <code>TRUE</code> if
the observation is judged as not outlying, <code>FALSE</code> if it is an outlier,
and <code>NA</code> if any of y, x, or z are missing. The fourth element of the
list is an integer vector with three values: 0 if the observations is judged
to be an outlier, 1 if not, and -1 if missing. The fifth and last element
stores the <code><a href="ivreg.html#topic+ivreg">ivreg</a></code> user-specified model object based on
which the four vectors were calculated.
</p>


<h3>Warning</h3>

<p>Check <a href="https://drive.google.com/file/d/1qPxDJnLlzLqdk94X9wwVASptf1MPpI2w/view">Jiao (2019)</a>
about conditions on the initial estimator that should be satisfied for the
initial estimator (e.g. they have to be Op(1)).
</p>

<hr>
<h2 id='validate_robust2sls'>Validator of robust2sls class</h2><span id='topic+validate_robust2sls'></span>

<h3>Description</h3>

<p><code>validate_robust2sls</code> checks that the input is a valid object of
<a href="base.html#topic+class">class</a> <code>"robust2sls"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_robust2sls(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_robust2sls_+3A_x">x</code></td>
<td>
<p>An object whose validity of class <code>"robust2sls"</code> is tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the object is a valid <code>"robust2sls"</code> object then the function
returns the object. No return value otherwise.
</p>

<hr>
<h2 id='varrho'>Calculate varrho coefficients</h2><span id='topic+varrho'></span>

<h3>Description</h3>

<p><code>varrho</code> calculates the coefficients for the asymptotic variance of the
gauge (false outlier detection rate) for a specific iteration m &gt;= 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varrho(sign_level, ref_dist = c("normal"), iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varrho_+3A_sign_level">sign_level</code></td>
<td>
<p>A numeric value between 0 and 1 that determines the cutoff
in the reference distribution against which observations are judged as
outliers or not.</p>
</td></tr>
<tr><td><code id="varrho_+3A_ref_dist">ref_dist</code></td>
<td>
<p>A character vector that specifies the reference distribution
against which observations are classified as outliers. <code>"normal"</code> refers
to the normal distribution.</p>
</td></tr>
<tr><td><code id="varrho_+3A_iteration">iteration</code></td>
<td>
<p>An integer &gt;= 1 that specifies the iteration of the outlier
detection algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>varrho</code> returns a list with four components, all of which are
lists themselves. <code>$setting</code> stores the arguments with which the
function was called. <code>$c</code> stores the values of the six different
coefficients for the specified iteration. <code>$fp</code> contains the fixed point
versions of the six coefficients. <code>$aux</code> stores intermediate values
required for calculating the coefficients.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
