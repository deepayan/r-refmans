<!DOCTYPE html><html><head><title>Help for package plumber</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plumber}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#addSerializer'><p>Deprecated functions</p></a></li>
<li><a href='#as_attachment'><p>Return an attachment response</p></a></li>
<li><a href='#do_provision'><p>DigitalOcean Plumber server</p></a></li>
<li><a href='#endpoint_serializer'><p>Endpoint Serializer with Hooks</p></a></li>
<li><a href='#forward'><p>Forward Request to The Next Handler</p></a></li>
<li><a href='#get_character_set'><p>Request character set</p></a></li>
<li><a href='#hookable'><p>Deprecated R6 functions</p></a></li>
<li><a href='#Hookable'><p>Hookable</p></a></li>
<li><a href='#include_file'><p>Send File Contents as Response</p></a></li>
<li><a href='#is_plumber'><p>Determine if Plumber object</p></a></li>
<li><a href='#options_plumber'><p>Plumber options</p></a></li>
<li><a href='#parser_form'><p>Plumber Parsers</p></a></li>
<li><a href='#plumb'><p>Process a Plumber API</p></a></li>
<li><a href='#plumb_api'><p>Process a Package's Plumber API</p></a></li>
<li><a href='#Plumber'><p>Package Plumber Router</p></a></li>
<li><a href='#PlumberEndpoint'><p>Plumber Endpoint</p></a></li>
<li><a href='#PlumberStatic'><p>Static file router</p></a></li>
<li><a href='#PlumberStep'><p>plumber step R6 class</p></a></li>
<li><a href='#pr'><p>Create a new Plumber router</p></a></li>
<li><a href='#pr_cookie'><p>Store session data in encrypted cookies.</p></a></li>
<li><a href='#pr_filter'><p>Add a filter to Plumber router</p></a></li>
<li><a href='#pr_handle'><p>Add handler to Plumber router</p></a></li>
<li><a href='#pr_hook'><p>Register a hook</p></a></li>
<li><a href='#pr_mount'><p>Mount a Plumber router</p></a></li>
<li><a href='#pr_run'><p>Start a server using <code>plumber</code> object</p></a></li>
<li><a href='#pr_set_404'><p>Set the handler that is called when the incoming request can't be served</p></a></li>
<li><a href='#pr_set_api_spec'><p>Set the OpenAPI Specification</p></a></li>
<li><a href='#pr_set_debug'><p>Set debug value to include error messages of routes cause an error</p></a></li>
<li><a href='#pr_set_docs'><p>Set the API visual documentation</p></a></li>
<li><a href='#pr_set_docs_callback'><p>Set the <code>callback</code> to tell where the API visual documentation is located</p></a></li>
<li><a href='#pr_set_error'><p>Set the error handler that is invoked if any filter or endpoint generates an</p>
error</a></li>
<li><a href='#pr_set_parsers'><p>Set the default endpoint parsers for the router</p></a></li>
<li><a href='#pr_set_serializer'><p>Set the default serializer of the router</p></a></li>
<li><a href='#pr_static'><p>Add a static route to the <code>plumber</code> object</p></a></li>
<li><a href='#random_cookie_key'><p>Random cookie key generator</p></a></li>
<li><a href='#register_docs'><p>Add visual documentation for plumber to use</p></a></li>
<li><a href='#register_parser'><p>Manage parsers</p></a></li>
<li><a href='#register_serializer'><p>Register a Serializer</p></a></li>
<li><a href='#serializer_headers'><p>Plumber Serializers</p></a></li>
<li><a href='#session_cookie'><p>Store session data in encrypted cookies.</p></a></li>
<li><a href='#validate_api_spec'><p>Validate OpenAPI Spec</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An API Generator for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/plumber/issues">https://github.com/rstudio/plumber/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rplumber.io">https://www.rplumber.io</a>, <a href="https://github.com/rstudio/plumber">https://github.com/rstudio/plumber</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Gives the ability to automatically generate and serve an HTTP API
    from R functions using the annotations in the R documentation around your
    functions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6 (&ge; 2.0.0), stringi (&ge; 0.3.0), jsonlite (&ge; 0.9.16),
webutils (&ge; 1.1), httpuv (&ge; 1.5.5), crayon, promises (&ge;
1.1.0), sodium, swagger (&ge; 3.33.0), magrittr, mime, lifecycle
(&ge; 0.2.0), ellipsis (&ge; 0.3.0), rlang</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.11.0), rmarkdown, base64enc, htmlwidgets,
visNetwork, later, readr, yaml, arrow, future, coro,
rstudioapi, spelling, mockery (&ge; 0.4.2), geojsonsf, redoc,
rapidoc, sf</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'async.R' 'content-types.R' 'default-handlers.R' 'hookable.R'
'shared-secret-filter.R' 'parser-cookie.R' 'parse-body.R'
'parse-query.R' 'plumber.R' 'deprecated-R6.R' 'deprecated.R'
'digital-ocean.R' 'find-port.R' 'globals.R' 'includes.R'
'json.R' 'new-rstudio-project.R' 'openapi-spec.R'
'openapi-types.R' 'options_plumber.R' 'paths.R' 'plumb-block.R'
'plumb-globals.R' 'plumb.R' 'plumber-response.R'
'plumber-static.R' 'plumber-step.R' 'pr.R' 'pr_set.R'
'serializer.R' 'session-cookie.R' 'ui.R' 'utf8.R'
'utils-pipe.R' 'utils.R' 'validate_api_spec.R' 'zzz.R'</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>Cairo</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-24 02:40:15 UTC; barret</td>
</tr>
<tr>
<td>Author:</td>
<td>Barret Schloerke <a href="https://orcid.org/0000-0001-9986-114X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Jeff Allen [aut, ccp],
  Bruno Tremblay [ctb],
  Frans van Dunn√© [ctb],
  Sebastiaan Vandewoude [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barret Schloerke &lt;barret@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 00:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='addSerializer'>Deprecated functions</h2><span id='topic+addSerializer'></span><span id='topic+getCharacterSet'></span><span id='topic+sessionCookie'></span>

<h3>Description</h3>

<p>Deprecated functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSerializer(name, serializer, verbose = TRUE)

getCharacterSet(contentType = NULL)

sessionCookie(
  key,
  name = "plumber",
  expiration = FALSE,
  http = TRUE,
  secure = FALSE,
  sameSite = FALSE
)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>addSerializer()</code>: See <code><a href="#topic+register_serializer">register_serializer()</a></code>
</p>
</li>
<li> <p><code>getCharacterSet()</code>: See <code><a href="#topic+get_character_set">get_character_set()</a></code>
</p>
</li>
<li> <p><code>sessionCookie()</code>: See <code><a href="#topic+session_cookie">session_cookie()</a></code>
</p>
</li></ul>

<hr>
<h2 id='as_attachment'>Return an attachment response</h2><span id='topic+as_attachment'></span>

<h3>Description</h3>

<p>This will set the appropriate fields in the <code>Content-Disposition</code> header value.
To make sure the attachment is used, be sure your serializer eventually calls <code>serializer_headers</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_attachment(value, filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_attachment_+3A_value">value</code></td>
<td>
<p>Response value to be saved</p>
</td></tr>
<tr><td><code id="as_attachment_+3A_filename">filename</code></td>
<td>
<p>File name to use when saving the attachment.
If no <code>filename</code> is provided, the <code>value</code> will be treated as a regular attachment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with class <code>"plumber_attachment"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# plumber.R

#' @get /data
#' @serializer csv
function() {
  # will cause the file to be saved as `iris.csv`, not `data` or `data.csv`
  as_attachment(iris, "iris.csv")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='do_provision'>DigitalOcean Plumber server</h2><span id='topic+do_provision'></span><span id='topic+do_configure_https'></span><span id='topic+do_deploy_api'></span><span id='topic+do_forward'></span><span id='topic+do_remove_api'></span><span id='topic+do_remove_forward'></span>

<h3>Description</h3>

<p>These methods are now defunct.
Please use the <a href="https://github.com/meztez/plumberDeploy"><code>plumberDeploy</code></a> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_provision(...)

do_configure_https(...)

do_deploy_api(...)

do_forward(...)

do_remove_api(...)

do_remove_forward(...)
</code></pre>

<hr>
<h2 id='endpoint_serializer'>Endpoint Serializer with Hooks</h2><span id='topic+endpoint_serializer'></span>

<h3>Description</h3>

<p>This method allows serializers to return <code>preexec</code>, <code>postexec</code>, and <code>aroundexec</code> (<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>) hooks in addition to a serializer.
This is useful for graphics device serializers which need a <code>preexec</code> and <code>postexec</code> hook to capture the graphics output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endpoint_serializer(
  serializer,
  preexec_hook = NULL,
  postexec_hook = NULL,
  aroundexec_hook = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endpoint_serializer_+3A_serializer">serializer</code></td>
<td>
<p>Serializer method to be used.  This method should already have its initialization arguments applied.</p>
</td></tr>
<tr><td><code id="endpoint_serializer_+3A_preexec_hook">preexec_hook</code></td>
<td>
<p>Function to be run directly before a <a href="#topic+PlumberEndpoint">PlumberEndpoint</a> calls its route method.</p>
</td></tr>
<tr><td><code id="endpoint_serializer_+3A_postexec_hook">postexec_hook</code></td>
<td>
<p>Function to be run directly after a <a href="#topic+PlumberEndpoint">PlumberEndpoint</a> calls its route method.</p>
</td></tr>
<tr><td><code id="endpoint_serializer_+3A_aroundexec_hook">aroundexec_hook</code></td>
<td>
<p>Function to be run around a <a href="#topic+PlumberEndpoint">PlumberEndpoint</a> call. Must handle a <code>.next</code> argument to continue execution. <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>preexec</code> and <code>postexec</code> hooks happened directly before and after a route is executed.
These hooks are specific to a single <a href="#topic+PlumberEndpoint">PlumberEndpoint</a>'s route calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The definition of `serializer_device` returns
# * a `serializer_content_type` serializer
# * `aroundexec` hook
print(serializer_device)
</code></pre>

<hr>
<h2 id='forward'>Forward Request to The Next Handler</h2><span id='topic+forward'></span>

<h3>Description</h3>

<p>This function is used when a filter is done processing a request and wishes
to pass control off to the next handler in the chain. If this is not called
by a filter, the assumption is that the filter fully handled the request
itself and no other filters or endpoints should be evaluated for this
request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward()
</code></pre>

<hr>
<h2 id='get_character_set'>Request character set</h2><span id='topic+get_character_set'></span>

<h3>Description</h3>

<p>Request character set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_character_set(content_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_character_set_+3A_content_type">content_type</code></td>
<td>
<p>Request Content-Type header</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Default to <code>UTF-8</code>. Otherwise return <code>charset</code> defined in request header.
</p>

<hr>
<h2 id='hookable'>Deprecated R6 functions</h2><span id='topic+hookable'></span><span id='topic+plumber'></span>

<h3>Description</h3>

<p>Deprecated R6 functions
</p>
<p>Deprecated R6 functions
</p>
<p>Deprecated R6 functions
</p>
<p>Deprecated R6 functions
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>hookable</code>: See <code><a href="#topic+Hookable">Hookable()</a></code>
</p>
</li>
<li> <p><code>plumber</code>: See <code><a href="#topic+Plumber">Plumber()</a></code>
</p>
</li></ul>


<h3>Super class</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code>hookable</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-hookable-new"><code>hookable$new()</code></a>
</p>
</li>
<li> <p><a href="#method-hookable-clone"><code>hookable$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHook"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHook'><code>plumber::Hookable$registerHook()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-hookable-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new <code>hookable</code>. Throws deprecated warning prompting user to use <code><a href="#topic+Hookable">Hookable</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>hookable$new()</pre></div>


<hr>
<a id="method-hookable-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>hookable$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code><a href="#topic+Plumber">plumber::Plumber</a></code> -&gt; <code>plumber</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-plumber-new"><code>plumber$new()</code></a>
</p>
</li>
<li> <p><a href="#method-plumber-clone"><code>plumber$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addAssets"><a href='../../plumber/html/Plumber.html#method-Plumber-addAssets'><code>plumber::Plumber$addAssets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addEndpoint"><a href='../../plumber/html/Plumber.html#method-Plumber-addEndpoint'><code>plumber::Plumber$addEndpoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addFilter"><a href='../../plumber/html/Plumber.html#method-Plumber-addFilter'><code>plumber::Plumber$addFilter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addGlobalProcessor"><a href='../../plumber/html/Plumber.html#method-Plumber-addGlobalProcessor'><code>plumber::Plumber$addGlobalProcessor()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="call"><a href='../../plumber/html/Plumber.html#method-Plumber-call'><code>plumber::Plumber$call()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="filter"><a href='../../plumber/html/Plumber.html#method-Plumber-filter'><code>plumber::Plumber$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="getApiSpec"><a href='../../plumber/html/Plumber.html#method-Plumber-getApiSpec'><code>plumber::Plumber$getApiSpec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="getDebug"><a href='../../plumber/html/Plumber.html#method-Plumber-getDebug'><code>plumber::Plumber$getDebug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="handle"><a href='../../plumber/html/Plumber.html#method-Plumber-handle'><code>plumber::Plumber$handle()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="mount"><a href='../../plumber/html/Plumber.html#method-Plumber-mount'><code>plumber::Plumber$mount()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="onHeaders"><a href='../../plumber/html/Plumber.html#method-Plumber-onHeaders'><code>plumber::Plumber$onHeaders()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="onWSOpen"><a href='../../plumber/html/Plumber.html#method-Plumber-onWSOpen'><code>plumber::Plumber$onWSOpen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="openAPIFile"><a href='../../plumber/html/Plumber.html#method-Plumber-openAPIFile'><code>plumber::Plumber$openAPIFile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="print"><a href='../../plumber/html/Plumber.html#method-Plumber-print'><code>plumber::Plumber$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="registerHook"><a href='../../plumber/html/Plumber.html#method-Plumber-registerHook'><code>plumber::Plumber$registerHook()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="removeHandle"><a href='../../plumber/html/Plumber.html#method-Plumber-removeHandle'><code>plumber::Plumber$removeHandle()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="route"><a href='../../plumber/html/Plumber.html#method-Plumber-route'><code>plumber::Plumber$route()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="run"><a href='../../plumber/html/Plumber.html#method-Plumber-run'><code>plumber::Plumber$run()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="serve"><a href='../../plumber/html/Plumber.html#method-Plumber-serve'><code>plumber::Plumber$serve()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="set404Handler"><a href='../../plumber/html/Plumber.html#method-Plumber-set404Handler'><code>plumber::Plumber$set404Handler()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setApiSpec"><a href='../../plumber/html/Plumber.html#method-Plumber-setApiSpec'><code>plumber::Plumber$setApiSpec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDebug"><a href='../../plumber/html/Plumber.html#method-Plumber-setDebug'><code>plumber::Plumber$setDebug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDocs"><a href='../../plumber/html/Plumber.html#method-Plumber-setDocs'><code>plumber::Plumber$setDocs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDocsCallback"><a href='../../plumber/html/Plumber.html#method-Plumber-setDocsCallback'><code>plumber::Plumber$setDocsCallback()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setErrorHandler"><a href='../../plumber/html/Plumber.html#method-Plumber-setErrorHandler'><code>plumber::Plumber$setErrorHandler()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setParsers"><a href='../../plumber/html/Plumber.html#method-Plumber-setParsers'><code>plumber::Plumber$setParsers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setSerializer"><a href='../../plumber/html/Plumber.html#method-Plumber-setSerializer'><code>plumber::Plumber$setSerializer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="swaggerFile"><a href='../../plumber/html/Plumber.html#method-Plumber-swaggerFile'><code>plumber::Plumber$swaggerFile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="unmount"><a href='../../plumber/html/Plumber.html#method-Plumber-unmount'><code>plumber::Plumber$unmount()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-plumber-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize a new <code>plumber</code>. Throws deprecated warning prompting user to use <code><a href="#topic+Plumber">Plumber</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>plumber$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>params passed in to <code>Plumber$new()</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-plumber-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>plumber$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Hookable'>Hookable</h2><span id='topic+Hookable'></span>

<h3>Description</h3>

<p>Hookable
</p>
<p>Hookable
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Hookable-registerHook"><code>Hookable$registerHook()</code></a>
</p>
</li>
<li> <p><a href="#method-Hookable-registerHooks"><code>Hookable$registerHooks()</code></a>
</p>
</li>
<li> <p><a href="#method-Hookable-clone"><code>Hookable$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Hookable-registerHook"></a>



<h4>Method <code>registerHook()</code></h4>

<p>Register a hook on a router
</p>


<h5>Usage</h5>

<div class="r"><pre>Hookable$registerHook(stage, handler)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stage</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>handler</code></dt><dd><p>a hook function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Hookable-registerHooks"></a>



<h4>Method <code>registerHooks()</code></h4>

<p>Register hooks on a router
</p>


<h5>Usage</h5>

<div class="r"><pre>Hookable$registerHooks(handlers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>handlers</code></dt><dd><p>a named list of hook functions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Hookable-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Hookable$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='include_file'>Send File Contents as Response</h2><span id='topic+include_file'></span><span id='topic+include_html'></span><span id='topic+include_md'></span><span id='topic+include_rmd'></span>

<h3>Description</h3>

<p>Returns the file at the given path as the response. If you want an endpoint to return a file as an attachment for user to download see <code><a href="#topic+as_attachment">as_attachment()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_file(file, res, content_type = getContentType(tools::file_ext(file)))

include_html(file, res)

include_md(file, res, format = NULL)

include_rmd(file, res, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="include_file_+3A_file">file</code></td>
<td>
<p>The path to the file to return</p>
</td></tr>
<tr><td><code id="include_file_+3A_res">res</code></td>
<td>
<p>The response object into which we'll write</p>
</td></tr>
<tr><td><code id="include_file_+3A_content_type">content_type</code></td>
<td>
<p>If provided, the given value will be sent as the
<code>Content-Type</code> header in the response. Defaults to the contentType of the file extension.
To disable the <code>Content-Type</code> header, set <code>content_type = NULL</code>.</p>
</td></tr>
<tr><td><code id="include_file_+3A_format">format</code></td>
<td>
<p>Passed as the <code>output_format</code> to <code>rmarkdown::render</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>include_html</code> will merely return the file with the proper
<code>content_type</code> for HTML. <code>include_md</code> and <code>include_rmd</code> will
process the given markdown file through <code>rmarkdown::render</code> and return
the resultant HTML as a response.
</p>

<hr>
<h2 id='is_plumber'>Determine if Plumber object</h2><span id='topic+is_plumber'></span>

<h3>Description</h3>

<p>Determine if Plumber object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_plumber(pr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_plumber_+3A_pr">pr</code></td>
<td>
<p>Hopefully a <code><a href="#topic+Plumber">Plumber</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value if <code>pr</code> inherits from <code><a href="#topic+Plumber">Plumber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_plumber(Plumber$new()) # TRUE
is_plumber(list()) # FALSE
</code></pre>

<hr>
<h2 id='options_plumber'>Plumber options</h2><span id='topic+options_plumber'></span><span id='topic+get_option_or_env'></span>

<h3>Description</h3>

<p>There are a number of global options that affect Plumber's behavior. These can
be set globally with <code><a href="base.html#topic+options">options()</a></code> or with <code><a href="#topic+options_plumber">options_plumber()</a></code>. Options set using
<code><a href="#topic+options_plumber">options_plumber()</a></code> should not include the <code>plumber.</code> prefix. Alternatively,
environment variable can be used to set plumber options using uppercase and
underscores (i.e. to set <code>plumber.apiHost</code> you can set environment variable <code>PLUMBER_APIHOST</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_plumber(
  ...,
  port = getOption("plumber.port"),
  docs = getOption("plumber.docs"),
  docs.callback = getOption("plumber.docs.callback"),
  trailingSlash = getOption("plumber.trailingSlash"),
  methodNotAllowed = getOption("plumber.methodNotAllowed"),
  apiURL = getOption("plumber.apiURL"),
  apiScheme = getOption("plumber.apiScheme"),
  apiHost = getOption("plumber.apiHost"),
  apiPort = getOption("plumber.apiPort"),
  apiPath = getOption("plumber.apiPath"),
  maxRequestSize = getOption("plumber.maxRequestSize"),
  sharedSecret = getOption("plumber.sharedSecret"),
  legacyRedirects = getOption("plumber.legacyRedirects")
)

get_option_or_env(x, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="options_plumber_+3A_...">...</code></td>
<td>
<p>Ignored. Should be empty</p>
</td></tr>
<tr><td><code id="options_plumber_+3A_port">port</code>, <code id="options_plumber_+3A_docs">docs</code>, <code id="options_plumber_+3A_docs.callback">docs.callback</code>, <code id="options_plumber_+3A_trailingslash">trailingSlash</code>, <code id="options_plumber_+3A_methodnotallowed">methodNotAllowed</code>, <code id="options_plumber_+3A_apischeme">apiScheme</code>, <code id="options_plumber_+3A_apihost">apiHost</code>, <code id="options_plumber_+3A_apiport">apiPort</code>, <code id="options_plumber_+3A_apipath">apiPath</code>, <code id="options_plumber_+3A_apiurl">apiURL</code>, <code id="options_plumber_+3A_maxrequestsize">maxRequestSize</code>, <code id="options_plumber_+3A_sharedsecret">sharedSecret</code>, <code id="options_plumber_+3A_legacyredirects">legacyRedirects</code></td>
<td>
<p>See details</p>
</td></tr>
<tr><td><code id="options_plumber_+3A_x">x</code></td>
<td>
<p>a character string holding an option name.</p>
</td></tr>
<tr><td><code id="options_plumber_+3A_default">default</code></td>
<td>
<p>if the specified option is not set in the options list,
this value is returned.  This facilitates retrieving an option and
checking whether it is set and setting it separately if not.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>plumber.port</code></dt><dd><p>Port Plumber will attempt to use to start http server.
If the port is already in use, server will not be able to start. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>plumber.docs</code></dt><dd><p>Name of the visual documentation interface to use. Defaults to <code>TRUE</code>, which will use <code>"swagger"</code>.</p>
</dd>
<dt><code>plumber.docs.callback</code></dt><dd><p>A function. Called with
a single parameter corresponding to the visual documentation url after Plumber server is ready. This can be used
by RStudio to open the docs when then API is ran from the editor. Defaults to option <code>NULL</code>.</p>
</dd>
<dt><code>plumber.trailingSlash</code></dt><dd><p>Logical value which allows the router to redirect any request
that has a matching route with a trailing slash. For example, if set to <code>TRUE</code> and the
GET route <code style="white-space: pre;">&#8288;/test/&#8288;</code> existed, then a GET request of <code style="white-space: pre;">&#8288;/test?a=1&#8288;</code> would redirect to
<code style="white-space: pre;">&#8288;/test/?a=1&#8288;</code>. Defaults to <code>FALSE</code>. This option will default to <code>TRUE</code> in a future release.</p>
</dd>
<dt><code>plumber.methodNotAllowed</code></dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Logical value which allows the router to notify that an
unavailable method was requested, but a different request method is allowed. For example,
if set to <code>TRUE</code> and the GET route <code style="white-space: pre;">&#8288;/test&#8288;</code> existed, then a POST request of <code style="white-space: pre;">&#8288;/test&#8288;</code> would
receive a 405 status and the allowed methods. Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>plumber.apiURL</code></dt><dd><p>Server urls for OpenAPI Specification respecting
pattern <code style="white-space: pre;">&#8288;scheme://host:port/path&#8288;</code>. Other <code style="white-space: pre;">&#8288;api*&#8288;</code> options will be ignored when set.</p>
</dd>
<dt><code>plumber.apiScheme</code></dt><dd><p>Scheme used to build OpenAPI url and server url for
OpenAPI Specification. Defaults to <code>http</code>, or an empty string
when used outside a running router.</p>
</dd>
<dt><code>plumber.apiHost</code></dt><dd><p>Host used to build docs url and server url for
OpenAPI Specification. Defaults to <code>host</code> defined by <code>run</code> method, or an empty string
when used outside a running router.</p>
</dd>
<dt><code>plumber.apiPort</code></dt><dd><p>Port used to build OpenAPI url and server url for
OpenAPI Specification. Defaults to <code>port</code> defined by <code>run</code> method, or an empty string
when used outside a running router.</p>
</dd>
<dt><code>plumber.apiPath</code></dt><dd><p>Path used to build OpenAPI url and server url for
OpenAPI Specification. Defaults to an empty string.</p>
</dd>
<dt><code>plumber.maxRequestSize</code></dt><dd><p>Maximum length in bytes of request body. Body larger
than maximum are rejected with http error 413. <code>0</code> means unlimited size. Defaults to <code>0</code>.</p>
</dd>
<dt><code>plumber.sharedSecret</code></dt><dd><p>Shared secret used to filter incoming request.
When <code>NULL</code>, secret is not validated. Otherwise, Plumber compares secret with http header
<code>PLUMBER_SHARED_SECRET</code>. Failure to match results in http error 400. Defaults to <code>NULL</code>.</p>
</dd>
<dt><code>plumber.legacyRedirects</code></dt><dd><p>Plumber will redirect legacy route <code style="white-space: pre;">&#8288;/__swagger__/&#8288;</code> and
<code style="white-space: pre;">&#8288;/__swagger__/index.html&#8288;</code> to <code style="white-space: pre;">&#8288;../__docs__/&#8288;</code> and <code style="white-space: pre;">&#8288;../__docs__/index.html&#8288;</code>. You can disable this
by settings this option to <code>FALSE</code>. Defaults to <code>TRUE</code></p>
</dd>
</dl>



<h3>Value</h3>

<p>The complete, prior set of <code><a href="base.html#topic+options">options()</a></code> values.
If a particular parameter is not supplied, it will return the current value.
If no parameters are supplied, all returned values will be the current <code><a href="base.html#topic+options">options()</a></code> values.
</p>

<hr>
<h2 id='parser_form'>Plumber Parsers</h2><span id='topic+parser_form'></span><span id='topic+parser_json'></span><span id='topic+parser_geojson'></span><span id='topic+parser_text'></span><span id='topic+parser_yaml'></span><span id='topic+parser_csv'></span><span id='topic+parser_tsv'></span><span id='topic+parser_read_file'></span><span id='topic+parser_rds'></span><span id='topic+parser_feather'></span><span id='topic+parser_parquet'></span><span id='topic+parser_octet'></span><span id='topic+parser_multi'></span><span id='topic+parser_none'></span>

<h3>Description</h3>

<p>Parsers are used in Plumber to transform request body received
by the API. Extra parameters may be provided to parser
functions when enabling them on router. This will allow for
non-default behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parser_form()

parser_json(...)

parser_geojson(...)

parser_text(parse_fn = identity)

parser_yaml(...)

parser_csv(...)

parser_tsv(...)

parser_read_file(read_fn = readLines)

parser_rds(...)

parser_feather(...)

parser_parquet(...)

parser_octet()

parser_multi()

parser_none()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parser_form_+3A_...">...</code></td>
<td>
<p>parameters supplied to the appropriate internal function</p>
</td></tr>
<tr><td><code id="parser_form_+3A_parse_fn">parse_fn</code></td>
<td>
<p>function to further decode a text string into an object</p>
</td></tr>
<tr><td><code id="parser_form_+3A_read_fn">read_fn</code></td>
<td>
<p>function used to read a the content of a file. Ex: <code><a href="base.html#topic+readRDS">readRDS()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parsers are optional. When unspecified, only default endpoint parsers are enabled.
You can use <code style="white-space: pre;">&#8288;@parser NAME&#8288;</code> tag to enable parser on endpoint.
Multiple parsers can be enabled on the same endpoint using multiple <code style="white-space: pre;">&#8288;@parser NAME&#8288;</code> tags.
</p>
<p>User should be aware that <code>rds</code> parsing should only be done from a
trusted source. Do not accept <code>rds</code> files blindly.
</p>
<p>See <code><a href="#topic+registered_parsers">registered_parsers()</a></code> for a list of registered parsers names.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>parser_form()</code>: Form query string parser
</p>
</li>
<li> <p><code>parser_json()</code>: JSON parser. See <code><a href="jsonlite.html#topic+read_json">jsonlite::parse_json()</a></code> for more details. (Defaults to using <code>simplifyVectors = TRUE</code>)
</p>
</li>
<li> <p><code>parser_geojson()</code>: GeoJSON parser. See <code><a href="geojsonsf.html#topic+geojson_sf">geojsonsf::geojson_sf()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_text()</code>: Helper parser to parse plain text
</p>
</li>
<li> <p><code>parser_yaml()</code>: YAML parser. See <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_csv()</code>: CSV parser. See <code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_tsv()</code>: TSV parser. See <code><a href="readr.html#topic+read_delim">readr::read_tsv()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_read_file()</code>: Helper parser that writes the binary body to a file and reads it back again using <code>read_fn</code>.
This parser should be used when reading from a file is required.
</p>
</li>
<li> <p><code>parser_rds()</code>: RDS parser. See <code><a href="base.html#topic+readRDS">readRDS()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_feather()</code>: feather parser. See <code><a href="arrow.html#topic+read_feather">arrow::read_feather()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_parquet()</code>: parquet parser. See <code><a href="arrow.html#topic+read_parquet">arrow::read_parquet()</a></code> for more details.
</p>
</li>
<li> <p><code>parser_octet()</code>: Octet stream parser. Returns the raw content.
</p>
</li>
<li> <p><code>parser_multi()</code>: Multi part parser. This parser will then parse each individual body with its respective parser.  When this parser is used, <code>req$body</code> will contain the updated output from <code><a href="webutils.html#topic+parse_multipart">webutils::parse_multipart()</a></code> by adding the <code>parsed</code> output to each part.  Each part may contain detailed information, such as <code>name</code> (required), <code>content_type</code>, <code>content_disposition</code>, <code>filename</code>, (raw, original) <code>value</code>, and <code>parsed</code> (parsed <code>value</code>).  When performing Plumber route argument matching, each multipart part will match its <code>name</code> to the <code>parsed</code> content.
</p>
</li>
<li> <p><code>parser_none()</code>: No parser. Will not process the postBody.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Overwrite `text/json` parsing behavior to not allow JSON vectors to be simplified
#* @parser json list(simplifyVector = FALSE)
# Activate `rds` parser in a multipart request
#* @parser multi
#* @parser rds
pr &lt;- Plumber$new()
pr$handle("GET", "/upload", function(rds) {rds}, parsers = c("multi", "rds"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plumb'>Process a Plumber API</h2><span id='topic+plumb'></span>

<h3>Description</h3>

<p>Process a Plumber API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plumb(file = NULL, dir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plumb_+3A_file">file</code></td>
<td>
<p>The file to parse as the plumber router definition.</p>
</td></tr>
<tr><td><code id="plumb_+3A_dir">dir</code></td>
<td>
<p>The directory containing the <code>plumber.R</code> file to parse as the
plumber router definition. Alternatively, if an <code>entrypoint.R</code> file is
found, it will take precedence and be responsible for returning a runnable
router.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>API routers are the core request handler in plumber. A router is responsible for
taking an incoming request, submitting it through the appropriate filters and
eventually to a corresponding endpoint, if one is found.
</p>
<p>See the <a href="https://www.rplumber.io/articles/programmatic-usage.html">Programmatic Usage</a> article for additional
details on the methods available on this object.
</p>

<hr>
<h2 id='plumb_api'>Process a Package's Plumber API</h2><span id='topic+plumb_api'></span><span id='topic+available_apis'></span>

<h3>Description</h3>

<p>So that packages can ship multiple plumber routers, users should store their Plumber APIs
in the <code>inst</code> subfolder <code>plumber</code> (<code>./inst/plumber/API_1/plumber.R</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plumb_api(package = NULL, name = NULL, edit = FALSE)

available_apis(package = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plumb_api_+3A_package">package</code></td>
<td>
<p>Package to inspect</p>
</td></tr>
<tr><td><code id="plumb_api_+3A_name">name</code></td>
<td>
<p>Name of the package folder to <code><a href="#topic+plumb">plumb()</a></code>.</p>
</td></tr>
<tr><td><code id="plumb_api_+3A_edit">edit</code></td>
<td>
<p>Whether or not to open the API source code for viewing / editing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To view all available Plumber APIs across all packages, please call <code>available_apis()</code>.
A <code>package</code> value may be provided to only display a particular package's Plumber APIs.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Plumber">Plumber</a></code> object. If either <code>package</code> or <code>name</code> is null, the appropriate <code><a href="#topic+available_apis">available_apis()</a></code> will be returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plumb_api()</code>: <code><a href="#topic+plumb">plumb()</a></code>s a package's Plumber API. Returns a <code><a href="#topic+Plumber">Plumber</a></code> router object
</p>
</li>
<li> <p><code>available_apis()</code>: Displays all available package Plumber APIs. Returns a <code>data.frame</code> of <code>package</code>, <code>name</code>, and <code>source_directory</code> information.
</p>
</li></ul>

<hr>
<h2 id='Plumber'>Package Plumber Router</h2><span id='topic+Plumber'></span>

<h3>Description</h3>

<p>Package Plumber Router
</p>
<p>Package Plumber Router
</p>


<h3>Details</h3>

<p>Routers are the core request handler in <span class="pkg">plumber</span>. A router is responsible for
taking an incoming request, submitting it through the appropriate filters and
eventually to a corresponding endpoint, if one is found.
</p>
<p>See the <a href="https://www.rplumber.io/articles/programmatic-usage.html">Programmatic Usage</a> article for additional
details on the methods available on this object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code>Plumber</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>flags</code></dt><dd><p>For internal use only</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>endpoints</code></dt><dd><p>Plumber router endpoints read-only</p>
</dd>
<dt><code>filters</code></dt><dd><p>Plumber router filters read-only</p>
</dd>
<dt><code>mounts</code></dt><dd><p>Plumber router mounts read-only</p>
</dd>
<dt><code>environment</code></dt><dd><p>Plumber router environment read-only</p>
</dd>
<dt><code>routes</code></dt><dd><p>Plumber router routes read-only</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Plumber-new"><code>Plumber$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-run"><code>Plumber$run()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-mount"><code>Plumber$mount()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-unmount"><code>Plumber$unmount()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-registerHook"><code>Plumber$registerHook()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-handle"><code>Plumber$handle()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-removeHandle"><code>Plumber$removeHandle()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-print"><code>Plumber$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-serve"><code>Plumber$serve()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-route"><code>Plumber$route()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-call"><code>Plumber$call()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-onHeaders"><code>Plumber$onHeaders()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-onWSOpen"><code>Plumber$onWSOpen()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setSerializer"><code>Plumber$setSerializer()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setParsers"><code>Plumber$setParsers()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-set404Handler"><code>Plumber$set404Handler()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setErrorHandler"><code>Plumber$setErrorHandler()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDocs"><code>Plumber$setDocs()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDocsCallback"><code>Plumber$setDocsCallback()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setDebug"><code>Plumber$setDebug()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-getDebug"><code>Plumber$getDebug()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-filter"><code>Plumber$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-setApiSpec"><code>Plumber$setApiSpec()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-getApiSpec"><code>Plumber$getApiSpec()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addEndpoint"><code>Plumber$addEndpoint()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addAssets"><code>Plumber$addAssets()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addFilter"><code>Plumber$addFilter()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-addGlobalProcessor"><code>Plumber$addGlobalProcessor()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-openAPIFile"><code>Plumber$openAPIFile()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-swaggerFile"><code>Plumber$swaggerFile()</code></a>
</p>
</li>
<li> <p><a href="#method-Plumber-clone"><code>Plumber$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Plumber-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Plumber</code> router
</p>
<p>See also <code><a href="#topic+plumb">plumb()</a></code>, <code><a href="#topic+pr">pr()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$new(file = NULL, filters = defaultPlumberFilters, envir)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file</code></dt><dd><p>path to file to plumb</p>
</dd>
<dt><code>filters</code></dt><dd><p>a list of Plumber filters</p>
</dd>
<dt><code>envir</code></dt><dd><p>an environment to be used as the enclosure for the routers execution</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Plumber</code> router
</p>


<hr>
<a id="method-Plumber-run"></a>



<h4>Method <code>run()</code></h4>

<p>Start a server using <code>Plumber</code> object.
</p>
<p>See also: <code><a href="#topic+pr_run">pr_run()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$run(
  host = "127.0.0.1",
  port = get_option_or_env("plumber.port", NULL),
  swagger = deprecated(),
  debug = missing_arg(),
  swaggerCallback = missing_arg(),
  ...,
  docs = missing_arg(),
  quiet = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>host</code></dt><dd><p>a string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. &quot;0.0.0.0&quot; represents
all IPv4 addresses and &quot;::/0&quot; represents all IPv6 addresses.</p>
</dd>
<dt><code>port</code></dt><dd><p>a number or integer that indicates the server port that should
be listened on. Note that on most Unix-like systems including Linux and
Mac OS X, port numbers smaller than 1025 require root privileges.
</p>
<p>This value does not need to be explicitly assigned. To explicitly set it, see <code><a href="#topic+options_plumber">options_plumber()</a></code>.</p>
</dd>
<dt><code>swagger</code></dt><dd><p>Deprecated. Please use <code>docs</code> instead. See <code style="white-space: pre;">&#8288;$setDocs(docs)&#8288;</code> or <code style="white-space: pre;">&#8288;$setApiSpec()&#8288;</code> for more customization.</p>
</dd>
<dt><code>debug</code></dt><dd><p>If <code>TRUE</code>, it will provide more insight into your API errors. Using this value will only last for the duration of the run. If a <code style="white-space: pre;">&#8288;$setDebug()&#8288;</code> has not been called, <code>debug</code> will default to <code>interactive()</code> at <code style="white-space: pre;">&#8288;$run()&#8288;</code> time. See <code style="white-space: pre;">&#8288;$setDebug()&#8288;</code> for more details.</p>
</dd>
<dt><code>swaggerCallback</code></dt><dd><p>An optional single-argument function that is
called back with the URL to an OpenAPI user interface when one becomes
ready. If missing, defaults to information previously set with <code style="white-space: pre;">&#8288;$setDocsCallback()&#8288;</code>.
This value will only be used while running the router.</p>
</dd>
<dt><code>...</code></dt><dd><p>Should be empty.</p>
</dd>
<dt><code>docs</code></dt><dd><p>Visual documentation value to use while running the API.
This value will only be used while running the router.
If missing, defaults to information previously set with <code>setDocs()</code>.
For more customization, see <code style="white-space: pre;">&#8288;$setDocs()&#8288;</code> or <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code> for examples.</p>
</dd>
<dt><code>quiet</code></dt><dd><p>If <code>TRUE</code>, don't print routine startup messages.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-mount"></a>



<h4>Method <code>mount()</code></h4>

<p>Mount a Plumber router
</p>
<p>Plumber routers can be ‚Äúnested‚Äù by mounting one into another
using the <code>mount()</code> method. This allows you to compartmentalize your API
by paths which is a great technique for decomposing large APIs into smaller files.
</p>
<p>See also: <code><a href="#topic+pr_mount">pr_mount()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$mount(path, router)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>a character string. Where to mount router.</p>
</dd>
<dt><code>router</code></dt><dd><p>a Plumber router. Router to be mounted.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
root &lt;- pr()

users &lt;- Plumber$new("users.R")
root$mount("/users", users)

products &lt;- Plumber$new("products.R")
root$mount("/products", products)
}
</pre>
</div>


<hr>
<a id="method-Plumber-unmount"></a>



<h4>Method <code>unmount()</code></h4>

<p>Unmount a Plumber router
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$unmount(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>a character string. Where to unmount router.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-registerHook"></a>



<h4>Method <code>registerHook()</code></h4>

<p>Register a hook
</p>
<p>Plumber routers support the notion of &quot;hooks&quot; that can be registered
to execute some code at a particular point in the lifecycle of a request.
Plumber routers currently support four hooks:
</p>

<ol>
<li> <p><code>preroute(data, req, res)</code>
</p>
</li>
<li> <p><code>postroute(data, req, res, value)</code>
</p>
</li>
<li> <p><code>preserialize(data, req, res, value)</code>
</p>
</li>
<li> <p><code>postserialize(data, req, res, value)</code>
</p>
</li></ol>

<p>In all of the above you have access to a disposable environment in the <code>data</code>
parameter that is created as a temporary data store for each request. Hooks
can store temporary data in these hooks that can be reused by other hooks
processing this same request.
</p>
<p>One feature when defining hooks in Plumber routers is the ability to modify
the returned value. The convention for such hooks is: any function that accepts
a parameter named <code>value</code> is expected to return the new value. This could
be an unmodified version of the value that was passed in, or it could be a
mutated value. But in either case, if your hook accepts a parameter
named <code>value</code>, whatever your hook returns will be used as the new value
for the response.
</p>
<p>You can add hooks using the <code>registerHook</code> method, or you can add multiple
hooks at once using the <code>registerHooks</code> method which takes a name list in
which the names are the names of the hooks, and the values are the
handlers themselves.
</p>
<p>See also: <code><a href="#topic+pr_hook">pr_hook()</a></code>, <code><a href="#topic+pr_hooks">pr_hooks()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$registerHook(
  stage = c("preroute", "postroute", "preserialize", "postserialize", "exit"),
  handler
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stage</code></dt><dd><p>a character string. Point in the lifecycle of a request.</p>
</dd>
<dt><code>handler</code></dt><dd><p>a hook function.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$registerHook("preroute", function(req){
  cat("Routing a request for", req$PATH_INFO, "...\n")
})
pr$registerHooks(list(
  preserialize=function(req, value){
    print("About to serialize this value:")
    print(value)

    # Must return the value since we took one in. Here we're not choosing
    # to mutate it, but we could.
    value
  },
  postserialize=function(res){
    print("We serialized the value as:")
    print(res$body)
  }
))

pr$handle("GET", "/", function(){ 123 })
}
</pre>
</div>


<hr>
<a id="method-Plumber-handle"></a>



<h4>Method <code>handle()</code></h4>

<p>Define endpoints
</p>
<p>The ‚Äúhandler‚Äù functions that you define in these handle calls
are identical to the code you would have defined in your plumber.R file
if you were using annotations to define your API. The handle() method
takes additional arguments that allow you to control nuanced behavior
of the endpoint like which filter it might preempt or which serializer
it should use.
</p>
<p>See also: <code><a href="#topic+pr_handle">pr_handle()</a></code>, <code><a href="#topic+pr_get">pr_get()</a></code>, <code><a href="#topic+pr_post">pr_post()</a></code>, <code><a href="#topic+pr_put">pr_put()</a></code>, <code><a href="#topic+pr_delete">pr_delete()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$handle(
  methods,
  path,
  handler,
  preempt,
  serializer,
  parsers,
  endpoint,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>methods</code></dt><dd><p>a character string. http method.</p>
</dd>
<dt><code>path</code></dt><dd><p>a character string. Api endpoints</p>
</dd>
<dt><code>handler</code></dt><dd><p>a handler function.</p>
</dd>
<dt><code>preempt</code></dt><dd><p>a preempt function.</p>
</dd>
<dt><code>serializer</code></dt><dd><p>a serializer function.</p>
</dd>
<dt><code>parsers</code></dt><dd><p>a named list of parsers.</p>
</dd>
<dt><code>endpoint</code></dt><dd><p>a <code>PlumberEndpoint</code> object.</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments for <a href="#topic+PlumberEndpoint">PlumberEndpoint</a> <code>new</code> method (namely <code>lines</code>, <code>params</code>, <code>comments</code>, <code>responses</code> and <code>tags</code>. Excludes <code>envir</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$handle("GET", "/", function(){
  "&lt;html&gt;&lt;h1&gt;Programmatic Plumber!&lt;/h1&gt;&lt;/html&gt;"
}, serializer=plumber::serializer_html())
}
</pre>
</div>


<hr>
<a id="method-Plumber-removeHandle"></a>



<h4>Method <code>removeHandle()</code></h4>

<p>Remove endpoints
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$removeHandle(methods, path, preempt = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>methods</code></dt><dd><p>a character string. http method.</p>
</dd>
<dt><code>path</code></dt><dd><p>a character string. Api endpoints</p>
</dd>
<dt><code>preempt</code></dt><dd><p>a preempt function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print representation of plumber router.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$print(prefix = "", topLevel = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prefix</code></dt><dd><p>a character string. Prefix to append to representation.</p>
</dd>
<dt><code>topLevel</code></dt><dd><p>a logical value. When method executed on top level
router, set to <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments for recursive calls</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A terminal friendly representation of a plumber router.
</p>


<hr>
<a id="method-Plumber-serve"></a>



<h4>Method <code>serve()</code></h4>

<p>Serve a request
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$serve(req, res)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>request object</p>
</dd>
<dt><code>res</code></dt><dd><p>response object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-route"></a>



<h4>Method <code>route()</code></h4>

<p>Route a request
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$route(req, res)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>request object</p>
</dd>
<dt><code>res</code></dt><dd><p>response object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-call"></a>



<h4>Method <code>call()</code></h4>

<p><span class="pkg">httpuv</span> interface call function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$call(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>request object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-onHeaders"></a>



<h4>Method <code>onHeaders()</code></h4>

<p>httpuv interface onHeaders function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$onHeaders(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>request object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-onWSOpen"></a>



<h4>Method <code>onWSOpen()</code></h4>

<p>httpuv interface onWSOpen function. (Required for <span class="pkg">httpuv</span>)
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$onWSOpen(ws)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ws</code></dt><dd><p>WebSocket object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-setSerializer"></a>



<h4>Method <code>setSerializer()</code></h4>

<p>Sets the default serializer of the router.
</p>
<p>See also: <code><a href="#topic+pr_set_serializer">pr_set_serializer()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setSerializer(serializer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>serializer</code></dt><dd><p>a serializer function</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$setSerializer(serializer_unboxed_json())
}
</pre>
</div>


<hr>
<a id="method-Plumber-setParsers"></a>



<h4>Method <code>setParsers()</code></h4>

<p>Sets the default parsers of the router. Initialized to <code>c("json", "form", "text", "octet", "multi")</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setParsers(parsers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parsers</code></dt><dd><p>Can be one of:
</p>

<ul>
<li><p> A <code>NULL</code> value
</p>
</li>
<li><p> A character vector of parser names
</p>
</li>
<li><p> A named <code>list()</code> whose keys are parser names names and values are arguments to be applied with <code><a href="base.html#topic+do.call">do.call()</a></code>
</p>
</li>
<li><p> A <code>TRUE</code> value, which will default to combining all parsers. This is great for seeing what is possible, but not great for security purposes
</p>
</li></ul>

<p>If the parser name <code>"all"</code> is found in any character value or list name, all remaining parsers will be added.
When using a list, parser information already defined will maintain their existing argument values.  All remaining parsers will use their default arguments.
</p>
<p>Example:
</p>
<div class="sourceCode"><pre># provide a character string
parsers = "json"

# provide a named list with no arguments
parsers = list(json = list())

# provide a named list with arguments; include `rds`
parsers = list(json = list(simplifyVector = FALSE), rds = list())

# default plumber parsers
parsers = c("json", "form", "text", "octet", "multi")
</pre></div></dd>
</dl>

</div>


<hr>
<a id="method-Plumber-set404Handler"></a>



<h4>Method <code>set404Handler()</code></h4>

<p>Sets the handler that gets called if an
incoming request can‚Äôt be served by any filter, endpoint, or sub-router.
</p>
<p>See also: <code><a href="#topic+pr_set_404">pr_set_404()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$set404Handler(fun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>a handler function.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$set404Handler(function(req, res) {cat(req$PATH_INFO)})
}
</pre>
</div>


<hr>
<a id="method-Plumber-setErrorHandler"></a>



<h4>Method <code>setErrorHandler()</code></h4>

<p>Sets the error handler which gets invoked if any filter or
endpoint generates an error.
</p>
<p>See also: <code><a href="#topic+pr_set_404">pr_set_404()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setErrorHandler(fun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt><dd><p>a handler function.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
pr &lt;- pr()
pr$setErrorHandler(function(req, res, err) {
  message("Found error: ")
  str(err)
})
}
</pre>
</div>


<hr>
<a id="method-Plumber-setDocs"></a>



<h4>Method <code>setDocs()</code></h4>

<p>Set visual documentation to use for API
</p>
<p>See also: <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code>, <code><a href="#topic+register_docs">register_docs()</a></code>, <code><a href="#topic+registered_docs">registered_docs()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDocs(docs = get_option_or_env("plumber.docs", TRUE), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>docs</code></dt><dd><p>a character value or a logical value. See <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code> for examples.
If using <code><a href="#topic+options_plumber">options_plumber()</a></code>, the value must be set before initializing your Plumber router.</p>
</dd>
<dt><code>...</code></dt><dd><p>Arguments for the visual documentation. See each visual documentation package for further details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-setDocsCallback"></a>



<h4>Method <code>setDocsCallback()</code></h4>

<p>Set a callback to notify where the API's visual documentation is located.
</p>
<p>When set, it will be called with a character string corresponding
to the API docs url. This allows RStudio to locate visual documentation.
</p>
<p>If using <code><a href="#topic+options_plumber">options_plumber()</a></code>, the value must be set before initializing your Plumber router.
</p>
<p>See also: <code><a href="#topic+pr_set_docs_callback">pr_set_docs_callback()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDocsCallback(
  callback = get_option_or_env("plumber.docs.callback", NULL)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>callback</code></dt><dd><p>a callback function for taking action on the docs url. (Also accepts <code>NULL</code> values to disable the <code>callback</code>.)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-setDebug"></a>



<h4>Method <code>setDebug()</code></h4>

<p>Set debug value to include error messages.
</p>
<p>See also: <code style="white-space: pre;">&#8288;$getDebug()&#8288;</code> and <code><a href="#topic+pr_set_debug">pr_set_debug()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setDebug(debug = interactive())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>debug</code></dt><dd><p><code>TRUE</code> provides more insight into your API errors.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-getDebug"></a>



<h4>Method <code>getDebug()</code></h4>

<p>Retrieve the <code>debug</code> value. If it has never been set, the result of <code>interactive()</code> will be used.
</p>
<p>See also: <code style="white-space: pre;">&#8288;$getDebug()&#8288;</code> and <code><a href="#topic+pr_set_debug">pr_set_debug()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$getDebug()</pre></div>


<hr>
<a id="method-Plumber-filter"></a>



<h4>Method <code>filter()</code></h4>

<p>Add a filter to plumber router
</p>
<p>See also: <code><a href="#topic+pr_filter">pr_filter()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$filter(name, expr, serializer)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>a character string. Name of filter</p>
</dd>
<dt><code>expr</code></dt><dd><p>an expr that resolve to a filter function or a filter function</p>
</dd>
<dt><code>serializer</code></dt><dd><p>a serializer function</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-setApiSpec"></a>



<h4>Method <code>setApiSpec()</code></h4>

<p>Allows to modify router autogenerated OpenAPI Specification
</p>
<p>Note, the returned value will be sent through <code><a href="#topic+serializer_unboxed_json">serializer_unboxed_json()</a></code> which will turn all length 1 vectors into atomic values.
To force a vector to serialize to an array of size 1, be sure to call <code><a href="base.html#topic+as.list">as.list()</a></code> on your value. <code>list()</code> objects are always serialized to an array value.
</p>
<p>See also: <code><a href="#topic+pr_set_api_spec">pr_set_api_spec()</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$setApiSpec(api = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>api</code></dt><dd><p>This can be
</p>

<ul>
<li><p> an OpenAPI Specification formatted list object
</p>
</li>
<li><p> a function that accepts the OpenAPI Specification autogenerated by <code>plumber</code> and returns a OpenAPI Specification formatted list object.
</p>
</li>
<li><p> a path to an OpenAPI Specification
</p>
</li></ul>

<p>The value returned will not be validated for OAS compatibility.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-getApiSpec"></a>



<h4>Method <code>getApiSpec()</code></h4>

<p>Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$getApiSpec()</pre></div>


<hr>
<a id="method-Plumber-addEndpoint"></a>



<h4>Method <code>addEndpoint()</code></h4>

<p>addEndpoint has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code>handle()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addEndpoint(
  verbs,
  path,
  expr,
  serializer,
  processors,
  preempt = NULL,
  params = NULL,
  comments
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbs</code></dt><dd><p>verbs</p>
</dd>
<dt><code>path</code></dt><dd><p>path</p>
</dd>
<dt><code>expr</code></dt><dd><p>expr</p>
</dd>
<dt><code>serializer</code></dt><dd><p>serializer</p>
</dd>
<dt><code>processors</code></dt><dd><p>processors</p>
</dd>
<dt><code>preempt</code></dt><dd><p>preempt</p>
</dd>
<dt><code>params</code></dt><dd><p>params</p>
</dd>
<dt><code>comments</code></dt><dd><p>comments</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-addAssets"></a>



<h4>Method <code>addAssets()</code></h4>

<p>addAssets has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code>mount</code> and <code>PlumberStatic$new()</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addAssets(dir, path = "/public", options = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir</code></dt><dd><p>dir</p>
</dd>
<dt><code>path</code></dt><dd><p>path</p>
</dd>
<dt><code>options</code></dt><dd><p>options</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-addFilter"></a>



<h4>Method <code>addFilter()</code></h4>

<p><code style="white-space: pre;">&#8288;$addFilter()&#8288;</code> has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code style="white-space: pre;">&#8288;$filter()&#8288;</code> instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addFilter(name, expr, serializer, processors)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>name</p>
</dd>
<dt><code>expr</code></dt><dd><p>expr</p>
</dd>
<dt><code>serializer</code></dt><dd><p>serializer</p>
</dd>
<dt><code>processors</code></dt><dd><p>processors</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-addGlobalProcessor"></a>



<h4>Method <code>addGlobalProcessor()</code></h4>

<p><code style="white-space: pre;">&#8288;$addGlobalProcessor()&#8288;</code> has been deprecated in v0.4.0 and will be removed in a coming release. Please use <code style="white-space: pre;">&#8288;$registerHook&#8288;</code>(s) instead.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$addGlobalProcessor(proc)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>proc</code></dt><dd><p>proc</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Plumber-openAPIFile"></a>



<h4>Method <code>openAPIFile()</code></h4>

<p>Deprecated. Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$openAPIFile()</pre></div>


<hr>
<a id="method-Plumber-swaggerFile"></a>



<h4>Method <code>swaggerFile()</code></h4>

<p>Deprecated. Retrieve OpenAPI file
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$swaggerFile()</pre></div>


<hr>
<a id="method-Plumber-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Plumber$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+pr">pr()</a></code>,
<code><a href="#topic+pr_run">pr_run()</a></code>,
<code><a href="#topic+pr_get">pr_get()</a></code>, <code><a href="#topic+pr_post">pr_post()</a></code>,
<code><a href="#topic+pr_mount">pr_mount()</a></code>,
<code><a href="#topic+pr_hook">pr_hook()</a></code>, <code><a href="#topic+pr_hooks">pr_hooks()</a></code>, <code><a href="#topic+pr_cookie">pr_cookie()</a></code>,
<code><a href="#topic+pr_filter">pr_filter()</a></code>,
<code><a href="#topic+pr_set_api_spec">pr_set_api_spec()</a></code>, <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code>,
<code><a href="#topic+pr_set_serializer">pr_set_serializer()</a></code>, <code><a href="#topic+pr_set_parsers">pr_set_parsers()</a></code>,
<code><a href="#topic+pr_set_404">pr_set_404()</a></code>, <code><a href="#topic+pr_set_error">pr_set_error()</a></code>,
<code><a href="#topic+pr_set_debug">pr_set_debug()</a></code>,
<code><a href="#topic+pr_set_docs_callback">pr_set_docs_callback()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Plumber$mount`
## ------------------------------------------------

## Not run: 
root &lt;- pr()

users &lt;- Plumber$new("users.R")
root$mount("/users", users)

products &lt;- Plumber$new("products.R")
root$mount("/products", products)

## End(Not run)

## ------------------------------------------------
## Method `Plumber$registerHook`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$registerHook("preroute", function(req){
  cat("Routing a request for", req$PATH_INFO, "...\n")
})
pr$registerHooks(list(
  preserialize=function(req, value){
    print("About to serialize this value:")
    print(value)

    # Must return the value since we took one in. Here we're not choosing
    # to mutate it, but we could.
    value
  },
  postserialize=function(res){
    print("We serialized the value as:")
    print(res$body)
  }
))

pr$handle("GET", "/", function(){ 123 })

## End(Not run)

## ------------------------------------------------
## Method `Plumber$handle`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$handle("GET", "/", function(){
  "&lt;html&gt;&lt;h1&gt;Programmatic Plumber!&lt;/h1&gt;&lt;/html&gt;"
}, serializer=plumber::serializer_html())

## End(Not run)

## ------------------------------------------------
## Method `Plumber$setSerializer`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$setSerializer(serializer_unboxed_json())

## End(Not run)

## ------------------------------------------------
## Method `Plumber$set404Handler`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$set404Handler(function(req, res) {cat(req$PATH_INFO)})

## End(Not run)

## ------------------------------------------------
## Method `Plumber$setErrorHandler`
## ------------------------------------------------

## Not run: 
pr &lt;- pr()
pr$setErrorHandler(function(req, res, err) {
  message("Found error: ")
  str(err)
})

## End(Not run)
</code></pre>

<hr>
<h2 id='PlumberEndpoint'>Plumber Endpoint</h2><span id='topic+PlumberEndpoint'></span>

<h3>Description</h3>

<p>Plumber Endpoint
</p>
<p>Plumber Endpoint
</p>


<h3>Details</h3>

<p>Defines a terminal handler in a Plumber router.
</p>
<p>Parameters values are obtained from parsing blocks of lines in a plumber file.
They can also be provided manually for historical reasons.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code><a href="#topic+PlumberStep">plumber::PlumberStep</a></code> -&gt; <code>PlumberEndpoint</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>verbs</code></dt><dd><p>a character vector. http methods. For historical reasons we have
to accept multiple verbs for a single path. Now it's simpler to just parse
each separate verb/path into its own endpoint, so we just do that.</p>
</dd>
<dt><code>path</code></dt><dd><p>a character string. endpoint path</p>
</dd>
<dt><code>comments</code></dt><dd><p>endpoint comments</p>
</dd>
<dt><code>description</code></dt><dd><p>endpoint description</p>
</dd>
<dt><code>responses</code></dt><dd><p>endpoint responses</p>
</dd>
<dt><code>params</code></dt><dd><p>endpoint parameters</p>
</dd>
<dt><code>tags</code></dt><dd><p>endpoint tags</p>
</dd>
<dt><code>parsers</code></dt><dd><p>step allowed parsers</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PlumberEndpoint-getTypedParams"><code>PlumberEndpoint$getTypedParams()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-canServe"><code>PlumberEndpoint$canServe()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-matchesPath"><code>PlumberEndpoint$matchesPath()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-new"><code>PlumberEndpoint$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-getPathParams"><code>PlumberEndpoint$getPathParams()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-getFunc"><code>PlumberEndpoint$getFunc()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-getFuncParams"><code>PlumberEndpoint$getFuncParams()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-getEndpointParams"><code>PlumberEndpoint$getEndpointParams()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-setPath"><code>PlumberEndpoint$setPath()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberEndpoint-clone"><code>PlumberEndpoint$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="PlumberStep" data-id="exec"><a href='../../plumber/html/PlumberStep.html#method-PlumberStep-exec'><code>plumber::PlumberStep$exec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="PlumberStep" data-id="registerHook"><a href='../../plumber/html/PlumberStep.html#method-PlumberStep-registerHook'><code>plumber::PlumberStep$registerHook()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PlumberEndpoint-getTypedParams"></a>



<h4>Method <code>getTypedParams()</code></h4>

<p>retrieve endpoint typed parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$getTypedParams()</pre></div>


<hr>
<a id="method-PlumberEndpoint-canServe"></a>



<h4>Method <code>canServe()</code></h4>

<p>ability to serve request
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$canServe(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>a request object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a logical. <code>TRUE</code> when endpoint can serve request.
</p>


<hr>
<a id="method-PlumberEndpoint-matchesPath"></a>



<h4>Method <code>matchesPath()</code></h4>

<p>determines if route matches requested path
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$matchesPath(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>a url path</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a logical. <code>TRUE</code> when endpoint matches the requested path.
</p>


<hr>
<a id="method-PlumberEndpoint-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>PlumberEndpoint</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$new(
  verbs,
  path,
  expr,
  envir,
  serializer,
  parsers,
  lines,
  params,
  comments,
  description,
  responses,
  tags,
  srcref
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbs</code></dt><dd><p>Endpoint verb Ex: <code>"GET"</code>, <code>"POST"</code></p>
</dd>
<dt><code>path</code></dt><dd><p>Endpoint path. Ex: <code>"/index.html"</code>, <code>"/foo/bar/baz"</code></p>
</dd>
<dt><code>expr</code></dt><dd><p>Endpoint function or expression that evaluates to a function.</p>
</dd>
<dt><code>envir</code></dt><dd><p>Endpoint environment</p>
</dd>
<dt><code>serializer</code></dt><dd><p>Endpoint serializer. Ex: <code><a href="#topic+serializer_json">serializer_json()</a></code></p>
</dd>
<dt><code>parsers</code></dt><dd><p>Can be one of:
</p>

<ul>
<li><p> A <code>NULL</code> value
</p>
</li>
<li><p> A character vector of parser names
</p>
</li>
<li><p> A named <code>list()</code> whose keys are parser names names and values are arguments to be applied with <code><a href="base.html#topic+do.call">do.call()</a></code>
</p>
</li>
<li><p> A <code>TRUE</code> value, which will default to combining all parsers. This is great for seeing what is possible, but not great for security purposes
</p>
</li></ul>

<p>If the parser name <code>"all"</code> is found in any character value or list name, all remaining parsers will be added.
When using a list, parser information already defined will maintain their existing argument values.  All remaining parsers will use their default arguments.
</p>
<p>Example:
</p>
<div class="sourceCode"><pre># provide a character string
parsers = "json"

# provide a named list with no arguments
parsers = list(json = list())

# provide a named list with arguments; include `rds`
parsers = list(json = list(simplifyVector = FALSE), rds = list())

# default plumber parsers
parsers = c("json", "form", "text", "octet", "multi")
</pre></div></dd>
<dt><code>lines</code></dt><dd><p>Endpoint block</p>
</dd>
<dt><code>params</code></dt><dd><p>Endpoint params</p>
</dd>
<dt><code>comments, description, responses, tags</code></dt><dd><p>Values to be used within the OpenAPI Spec</p>
</dd>
<dt><code>srcref</code></dt><dd><p><code>srcref</code> attribute from block</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PlumberEndpoint</code> object
</p>


<hr>
<a id="method-PlumberEndpoint-getPathParams"></a>



<h4>Method <code>getPathParams()</code></h4>

<p>retrieve endpoint path parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$getPathParams(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>endpoint path</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlumberEndpoint-getFunc"></a>



<h4>Method <code>getFunc()</code></h4>

<p>retrieve endpoint function
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$getFunc()</pre></div>


<hr>
<a id="method-PlumberEndpoint-getFuncParams"></a>



<h4>Method <code>getFuncParams()</code></h4>

<p>retrieve endpoint expression parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$getFuncParams()</pre></div>


<hr>
<a id="method-PlumberEndpoint-getEndpointParams"></a>



<h4>Method <code>getEndpointParams()</code></h4>

<p>retrieve endpoint defined parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$getEndpointParams()</pre></div>


<hr>
<a id="method-PlumberEndpoint-setPath"></a>



<h4>Method <code>setPath()</code></h4>

<p>Updates <code style="white-space: pre;">&#8288;$path&#8288;</code> with a sanitized <code>path</code> and updates the internal path meta-data
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$setPath(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt><dd><p>Path to set <code style="white-space: pre;">&#8288;$path&#8288;</code>. If missing a beginning slash, one will be added.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlumberEndpoint-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberEndpoint$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='PlumberStatic'>Static file router</h2><span id='topic+PlumberStatic'></span>

<h3>Description</h3>

<p>Static file router
</p>
<p>Static file router
</p>


<h3>Details</h3>

<p>Creates a router that is backed by a directory of files on disk.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code><a href="#topic+Plumber">plumber::Plumber</a></code> -&gt; <code>PlumberStatic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PlumberStatic-new"><code>PlumberStatic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberStatic-print"><code>PlumberStatic$print()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberStatic-clone"><code>PlumberStatic$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addAssets"><a href='../../plumber/html/Plumber.html#method-Plumber-addAssets'><code>plumber::Plumber$addAssets()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addEndpoint"><a href='../../plumber/html/Plumber.html#method-Plumber-addEndpoint'><code>plumber::Plumber$addEndpoint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addFilter"><a href='../../plumber/html/Plumber.html#method-Plumber-addFilter'><code>plumber::Plumber$addFilter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="addGlobalProcessor"><a href='../../plumber/html/Plumber.html#method-Plumber-addGlobalProcessor'><code>plumber::Plumber$addGlobalProcessor()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="call"><a href='../../plumber/html/Plumber.html#method-Plumber-call'><code>plumber::Plumber$call()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="filter"><a href='../../plumber/html/Plumber.html#method-Plumber-filter'><code>plumber::Plumber$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="getApiSpec"><a href='../../plumber/html/Plumber.html#method-Plumber-getApiSpec'><code>plumber::Plumber$getApiSpec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="getDebug"><a href='../../plumber/html/Plumber.html#method-Plumber-getDebug'><code>plumber::Plumber$getDebug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="handle"><a href='../../plumber/html/Plumber.html#method-Plumber-handle'><code>plumber::Plumber$handle()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="mount"><a href='../../plumber/html/Plumber.html#method-Plumber-mount'><code>plumber::Plumber$mount()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="onHeaders"><a href='../../plumber/html/Plumber.html#method-Plumber-onHeaders'><code>plumber::Plumber$onHeaders()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="onWSOpen"><a href='../../plumber/html/Plumber.html#method-Plumber-onWSOpen'><code>plumber::Plumber$onWSOpen()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="openAPIFile"><a href='../../plumber/html/Plumber.html#method-Plumber-openAPIFile'><code>plumber::Plumber$openAPIFile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="registerHook"><a href='../../plumber/html/Plumber.html#method-Plumber-registerHook'><code>plumber::Plumber$registerHook()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="removeHandle"><a href='../../plumber/html/Plumber.html#method-Plumber-removeHandle'><code>plumber::Plumber$removeHandle()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="route"><a href='../../plumber/html/Plumber.html#method-Plumber-route'><code>plumber::Plumber$route()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="run"><a href='../../plumber/html/Plumber.html#method-Plumber-run'><code>plumber::Plumber$run()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="serve"><a href='../../plumber/html/Plumber.html#method-Plumber-serve'><code>plumber::Plumber$serve()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="set404Handler"><a href='../../plumber/html/Plumber.html#method-Plumber-set404Handler'><code>plumber::Plumber$set404Handler()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setApiSpec"><a href='../../plumber/html/Plumber.html#method-Plumber-setApiSpec'><code>plumber::Plumber$setApiSpec()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDebug"><a href='../../plumber/html/Plumber.html#method-Plumber-setDebug'><code>plumber::Plumber$setDebug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDocs"><a href='../../plumber/html/Plumber.html#method-Plumber-setDocs'><code>plumber::Plumber$setDocs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setDocsCallback"><a href='../../plumber/html/Plumber.html#method-Plumber-setDocsCallback'><code>plumber::Plumber$setDocsCallback()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setErrorHandler"><a href='../../plumber/html/Plumber.html#method-Plumber-setErrorHandler'><code>plumber::Plumber$setErrorHandler()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setParsers"><a href='../../plumber/html/Plumber.html#method-Plumber-setParsers'><code>plumber::Plumber$setParsers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="setSerializer"><a href='../../plumber/html/Plumber.html#method-Plumber-setSerializer'><code>plumber::Plumber$setSerializer()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="swaggerFile"><a href='../../plumber/html/Plumber.html#method-Plumber-swaggerFile'><code>plumber::Plumber$swaggerFile()</code></a></span></li>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Plumber" data-id="unmount"><a href='../../plumber/html/Plumber.html#method-Plumber-unmount'><code>plumber::Plumber$unmount()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PlumberStatic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>PlumberStatic</code> router
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStatic$new(direc, options)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>direc</code></dt><dd><p>a path to an asset directory.</p>
</dd>
<dt><code>options</code></dt><dd><p>options to be evaluated in the <code>PlumberStatic</code> router environment</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PlumberStatic</code> router
</p>


<hr>
<a id="method-PlumberStatic-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print representation of <code>PlumberStatic()</code> router.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStatic$print(prefix = "", topLevel = TRUE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prefix</code></dt><dd><p>a character string. Prefix to append to representation.</p>
</dd>
<dt><code>topLevel</code></dt><dd><p>a logical value. When method executed on top level
router, set to <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments for recursive calls</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A terminal friendly representation of a <code>PlumberStatic()</code> router.
</p>


<hr>
<a id="method-PlumberStatic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStatic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='PlumberStep'>plumber step R6 class</h2><span id='topic+PlumberStep'></span>

<h3>Description</h3>

<p>an object representing a step in the lifecycle of the treatment
of a request by a plumber router.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Hookable">plumber::Hookable</a></code> -&gt; <code>PlumberStep</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>srcref</code></dt><dd><p>from step block</p>
</dd>
<dt><code>lines</code></dt><dd><p>lines from step block</p>
</dd>
<dt><code>serializer</code></dt><dd><p>step serializer function</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PlumberStep-new"><code>PlumberStep$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberStep-exec"><code>PlumberStep$exec()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberStep-registerHook"><code>PlumberStep$registerHook()</code></a>
</p>
</li>
<li> <p><a href="#method-PlumberStep-clone"><code>PlumberStep$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="plumber" data-topic="Hookable" data-id="registerHooks"><a href='../../plumber/html/Hookable.html#method-Hookable-registerHooks'><code>plumber::Hookable$registerHooks()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PlumberStep-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+PlumberStep">PlumberStep()</a></code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStep$new(expr, envir, lines, serializer, srcref)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>step expr</p>
</dd>
<dt><code>envir</code></dt><dd><p>step environment</p>
</dd>
<dt><code>lines</code></dt><dd><p>step block</p>
</dd>
<dt><code>serializer</code></dt><dd><p>step serializer</p>
</dd>
<dt><code>srcref</code></dt><dd><p><code>srcref</code> attribute from block</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PlumberStep</code> object
</p>


<hr>
<a id="method-PlumberStep-exec"></a>



<h4>Method <code>exec()</code></h4>

<p>step execution function
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStep$exec(req, res)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req, res</code></dt><dd><p>Request and response objects created by a Plumber request</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlumberStep-registerHook"></a>



<h4>Method <code>registerHook()</code></h4>

<p>step hook registration method
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStep$registerHook(
  stage = c("preexec", "postexec", "aroundexec"),
  handler
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stage</code></dt><dd><p>a character string.</p>
</dd>
<dt><code>handler</code></dt><dd><p>a step handler function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PlumberStep-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PlumberStep$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='pr'>Create a new Plumber router</h2><span id='topic+pr'></span>

<h3>Description</h3>

<p>Create a new Plumber router
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr(
  file = NULL,
  filters = defaultPlumberFilters,
  envir = new.env(parent = .GlobalEnv)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_+3A_file">file</code></td>
<td>
<p>Path to file to plumb</p>
</td></tr>
<tr><td><code id="pr_+3A_filters">filters</code></td>
<td>
<p>A list of Plumber filters</p>
</td></tr>
<tr><td><code id="pr_+3A_envir">envir</code></td>
<td>
<p>An environment to be used as the enclosure for the routers execution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="#topic+Plumber">Plumber</a></code> router
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_cookie'>Store session data in encrypted cookies.</h2><span id='topic+pr_cookie'></span>

<h3>Description</h3>

<p><code>plumber</code> uses the crypto R package <code>sodium</code>, to encrypt/decrypt
<code>req$session</code> information for each server request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_cookie(
  pr,
  key,
  name = "plumber",
  expiration = FALSE,
  http = TRUE,
  secure = FALSE,
  same_site = FALSE,
  path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_cookie_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_key">key</code></td>
<td>
<p>The secret key to use. This must be consistent across all R sessions
where you want to save/restore encrypted cookies. It should be produced using
<code><a href="#topic+random_cookie_key">random_cookie_key</a></code>. Please see the &quot;Storing secure keys&quot; section for more details
complex character string to bolster security.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_name">name</code></td>
<td>
<p>The name of the cookie in the user's browser.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_expiration">expiration</code></td>
<td>
<p>A number representing the number of seconds into the future
before the cookie expires or a <code>POSIXt</code> date object of when the cookie expires.
Defaults to the end of the user's browser session.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_http">http</code></td>
<td>
<p>Boolean that adds the <code>HttpOnly</code> cookie flag that tells the browser
to save the cookie and to NOT send it to client-side scripts. This mitigates <a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">cross-site scripting</a>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_secure">secure</code></td>
<td>
<p>Boolean that adds the <code>Secure</code> cookie flag.  This should be set
when the route is eventually delivered over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_same_site">same_site</code></td>
<td>
<p>A character specifying the SameSite policy to attach to the cookie.
If specified, one of the following values should be given: &quot;Strict&quot;, &quot;Lax&quot;, or &quot;None&quot;.
If &quot;None&quot; is specified, then the <code>secure</code> flag MUST also be set for the modern browsers to
accept the cookie. An error will be returned if <code>same_site = "None"</code> and <code>secure = FALSE</code>.
If not specified or a non-character is given, no SameSite policy is attached to the cookie.</p>
</td></tr>
<tr><td><code id="pr_cookie_+3A_path">path</code></td>
<td>
<p>The URI path that the cookie will be available in future requests.
Defaults to the request URI. Set to <code>"/"</code> to make cookie available to
all requests at the host.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cookie's secret encryption <code>key</code> value must be consistent to maintain
<code>req$session</code> information between server restarts.
</p>


<h3>Storing secure keys</h3>

<p>While it is very quick to get started with user session cookies using
<code>plumber</code>, please exercise precaution when storing secure key information.
If a malicious person were to gain access to the secret <code>key</code>, they would
be able to eavesdrop on all <code>req$session</code> information and/or tamper with
<code>req$session</code> information being processed.
</p>
<p>Please: </p>

<ul>
<li><p> Do NOT store keys in source control.
</p>
</li>
<li><p> Do NOT store keys on disk with permissions that allow it to be accessed by everyone.
</p>
</li>
<li><p> Do NOT store keys in databases which can be queried by everyone.
</p>
</li></ul>

<p>Instead, please: </p>

<ul>
<li><p> Use a key management system, such as
<a href="https://github.com/r-lib/keyring">'keyring'</a> (preferred)
</p>
</li>
<li><p> Store the secret in a file on disk with appropriately secure permissions,
such as &quot;user read only&quot; (<code>Sys.chmod("myfile.txt", mode = "0600")</code>),
to prevent others from reading it.
</p>
</li></ul>
<p> Examples of both of these solutions are done in the Examples section.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://github.com/r-lib/sodium">'sodium'</a>: R bindings to 'libsodium'
</p>
</li>
<li> <p><a href="https://doc.libsodium.org/">'libsodium'</a>: A Modern and Easy-to-Use Crypto Library
</p>
</li>
<li> <p><a href="https://github.com/r-lib/keyring">'keyring'</a>: Access the system credential store from R
</p>
</li>
<li> <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives">Set-Cookie flags</a>: Descriptions of different flags for <code>Set-Cookie</code>
</p>
</li>
<li> <p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">Cross-site scripting</a>: A security exploit which allows an attacker to inject into a website malicious client-side code
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Set secret key using `keyring` (preferred method)
keyring::key_set_with_value("plumber_api", password = plumber::random_cookie_key())


pr() %&gt;%
  pr_cookie(
    keyring::key_get("plumber_api"),
    name = "counter"
  ) %&gt;%
  pr_get("/sessionCounter", function(req) {
    count &lt;- 0
    if (!is.null(req$session$counter)){
      count &lt;- as.numeric(req$session$counter)
    }
    req$session$counter &lt;- count + 1
    return(paste0("This is visit #", count))
  }) %&gt;%
  pr_run()


#### -------------------------------- ###


## Save key to a local file
pswd_file &lt;- "normal_file.txt"
cat(plumber::random_cookie_key(), file = pswd_file)
# Make file read-only
Sys.chmod(pswd_file, mode = "0600")

pr() %&gt;%
  pr_cookie(
    readLines(pswd_file, warn = FALSE),
    name = "counter"
  ) %&gt;%
  pr_get("/sessionCounter", function(req) {
    count &lt;- 0
    if (!is.null(req$session$counter)){
      count &lt;- as.numeric(req$session$counter)
    }
    req$session$counter &lt;- count + 1
    return(paste0("This is visit #", count))
  }) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_filter'>Add a filter to Plumber router</h2><span id='topic+pr_filter'></span>

<h3>Description</h3>

<p>Filters can be used to modify an incoming request, return an error, or return
a response prior to the request reaching an endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_filter(pr, name, expr, serializer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_filter_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_filter_+3A_name">name</code></td>
<td>
<p>A character string. Name of filter</p>
</td></tr>
<tr><td><code id="pr_filter_+3A_expr">expr</code></td>
<td>
<p>An expr that resolve to a filter function or a filter function</p>
</td></tr>
<tr><td><code id="pr_filter_+3A_serializer">serializer</code></td>
<td>
<p>A serializer function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with the defined filter added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_filter("foo", function(req, res) {
    print("This is filter foo")
    forward()
  }) %&gt;%
  pr_get("/hi", function() "Hello") %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_handle'>Add handler to Plumber router</h2><span id='topic+pr_handle'></span><span id='topic+pr_get'></span><span id='topic+pr_post'></span><span id='topic+pr_put'></span><span id='topic+pr_delete'></span><span id='topic+pr_head'></span>

<h3>Description</h3>

<p>This collection of functions creates handlers for a Plumber router.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_handle(pr, methods, path, handler, preempt, serializer, endpoint, ...)

pr_get(pr, path, handler, preempt, serializer, endpoint, ...)

pr_post(pr, path, handler, preempt, serializer, endpoint, ...)

pr_put(pr, path, handler, preempt, serializer, endpoint, ...)

pr_delete(pr, path, handler, preempt, serializer, endpoint, ...)

pr_head(pr, path, handler, preempt, serializer, endpoint, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_handle_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_methods">methods</code></td>
<td>
<p>Character vector of HTTP methods</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_path">path</code></td>
<td>
<p>The endpoint path</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_handler">handler</code></td>
<td>
<p>A handler function</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_preempt">preempt</code></td>
<td>
<p>A preempt function</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_serializer">serializer</code></td>
<td>
<p>A Plumber serializer</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_endpoint">endpoint</code></td>
<td>
<p>A <code>PlumberEndpoint</code> object</p>
</td></tr>
<tr><td><code id="pr_handle_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>PlumberEndpoint</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic <code><a href="#topic+pr_handle">pr_handle()</a></code> creates a handle for the given method(s). Specific
functions are implemented for the following HTTP methods:
</p>

<ul>
<li> <p><code>GET</code>
</p>
</li>
<li> <p><code>POST</code>
</p>
</li>
<li> <p><code>PUT</code>
</p>
</li>
<li> <p><code>DELETE</code>
</p>
</li>
<li> <p><code>HEAD</code>
Each function mutates the Plumber router in place and returns
the updated router.
</p>
</li></ul>



<h3>Value</h3>

<p>A Plumber router with the handler added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_handle("GET", "/hi", function() "Hello World") %&gt;%
  pr_run()

pr() %&gt;%
  pr_handle(c("GET", "POST"), "/hi", function() "Hello World") %&gt;%
  pr_run()

pr() %&gt;%
  pr_get("/hi", function() "Hello World") %&gt;%
  pr_post("/echo", function(req, res) {
    if (is.null(req$body)) return("No input")
    list(
      input = req$body
    )
  }) %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_hook'>Register a hook</h2><span id='topic+pr_hook'></span><span id='topic+pr_hooks'></span>

<h3>Description</h3>

<p>Plumber routers support the notion of &quot;hooks&quot; that can be registered
to execute some code at a particular point in the lifecycle of a request.
Plumber routers currently support four hooks:
</p>

<ol>
<li> <p><code>preroute(data, req, res)</code>
</p>
</li>
<li> <p><code>postroute(data, req, res, value)</code>
</p>
</li>
<li> <p><code>preserialize(data, req, res, value)</code>
</p>
</li>
<li> <p><code>postserialize(data, req, res, value)</code>
In all of the above you have access to a disposable environment in the <code>data</code>
parameter that is created as a temporary data store for each request. Hooks
can store temporary data in these hooks that can be reused by other hooks
processing this same request.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>pr_hook(pr, stage, handler)

pr_hooks(pr, handlers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_hook_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_hook_+3A_stage">stage</code></td>
<td>
<p>A character string. Point in the lifecycle of a request.</p>
</td></tr>
<tr><td><code id="pr_hook_+3A_handler">handler</code></td>
<td>
<p>A hook function.</p>
</td></tr>
<tr><td><code id="pr_hook_+3A_handlers">handlers</code></td>
<td>
<p>A named list of hook handlers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One feature when defining hooks in Plumber routers is the ability to modify
the returned value. The convention for such hooks is: any function that accepts
a parameter named <code>value</code> is expected to return the new value. This could
be an unmodified version of the value that was passed in, or it could be a
mutated value. But in either case, if your hook accepts a parameter
named <code>value</code>, whatever your hook returns will be used as the new value
for the response.
</p>
<p>You can add hooks using the <code>pr_hook</code>, or you can add multiple
hooks at once using <code>pr_hooks</code>, which takes a named list in
which the names are the names of the hooks, and the values are the
handlers themselves.
</p>


<h3>Value</h3>

<p>A Plumber router with the defined hook(s) added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_hook("preroute", function(req){
    cat("Routing a request for", req$PATH_INFO, "...\n")
  }) %&gt;%
  pr_hooks(list(
    preserialize = function(req, value){
      print("About to serialize this value:")
      print(value)

      # Must return the value since we took one in. Here we're not choosing
      # to mutate it, but we could.
      value
    },
    postserialize = function(res){
      print("We serialized the value as:")
      print(res$body)
    }
  )) %&gt;%
  pr_handle("GET", "/", function(){ 123 }) %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_mount'>Mount a Plumber router</h2><span id='topic+pr_mount'></span>

<h3>Description</h3>

<p>Plumber routers can be ‚Äúnested‚Äù by mounting one into another
using the <code>mount()</code> method. This allows you to compartmentalize your API
by paths which is a great technique for decomposing large APIs into smaller
files. This function mutates the Plumber router (<code><a href="#topic+pr">pr()</a></code>) in place and
returns the updated router.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_mount(pr, path, router)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_mount_+3A_pr">pr</code></td>
<td>
<p>The host Plumber router.</p>
</td></tr>
<tr><td><code id="pr_mount_+3A_path">path</code></td>
<td>
<p>A character string. Where to mount router.</p>
</td></tr>
<tr><td><code id="pr_mount_+3A_router">router</code></td>
<td>
<p>A Plumber router. Router to be mounted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Plumber router with the supplied router mounted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr1 &lt;- pr() %&gt;%
  pr_get("/hello", function() "Hello")

pr() %&gt;%
  pr_get("/goodbye", function() "Goodbye") %&gt;%
  pr_mount("/hi", pr1) %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_run'>Start a server using <code>plumber</code> object</h2><span id='topic+pr_run'></span>

<h3>Description</h3>

<p><code>port</code> does not need to be explicitly assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_run(
  pr,
  host = "127.0.0.1",
  port = get_option_or_env("plumber.port", NULL),
  ...,
  debug = missing_arg(),
  docs = missing_arg(),
  swaggerCallback = missing_arg(),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_run_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_host">host</code></td>
<td>
<p>A string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. &quot;0.0.0.0&quot; represents
all IPv4 addresses and &quot;::/0&quot; represents all IPv6 addresses.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_port">port</code></td>
<td>
<p>A number or integer that indicates the server port that should
be listened on. Note that on most Unix-like systems including Linux and
Mac OS X, port numbers smaller than 1025 require root privileges.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_...">...</code></td>
<td>
<p>Should be empty.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, it will provide more insight into your API errors.
Using this value will only last for the duration of the run.
If <code><a href="#topic+pr_set_debug">pr_set_debug()</a></code> has not been called, <code>debug</code> will default to <code>interactive()</code> at <code><a href="#topic+pr_run">pr_run()</a></code> time</p>
</td></tr>
<tr><td><code id="pr_run_+3A_docs">docs</code></td>
<td>
<p>Visual documentation value to use while running the API.
This value will only be used while running the router.
If missing, defaults to information previously set with <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code>.
For more customization, see <code><a href="#topic+pr_set_docs">pr_set_docs()</a></code> for examples.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_swaggercallback">swaggerCallback</code></td>
<td>
<p>An optional single-argument function that is called
back with the URL to an OpenAPI user interface when one becomes ready. If
missing, defaults to information set with <code><a href="#topic+pr_set_docs_callback">pr_set_docs_callback()</a></code>.
This value will only be used while running the router.</p>
</td></tr>
<tr><td><code id="pr_run_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, don't print routine startup messages.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_run()

pr() %&gt;%
  pr_run(
    # manually set port
    port = 5762,
    # turn off visual documentation
    docs = FALSE,
    # do not display startup messages
    quiet = TRUE
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_set_404'>Set the handler that is called when the incoming request can't be served</h2><span id='topic+pr_set_404'></span>

<h3>Description</h3>

<p>This function allows a custom error message to be returned when a request
cannot be served by an existing endpoint or filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_404(pr, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_404_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_404_+3A_fun">fun</code></td>
<td>
<p>A handler function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with a modified 404 handler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
handler_404 &lt;- function(req, res) {
  res$status &lt;- 404
  res$body &lt;- "Oops"
}

pr() %&gt;%
  pr_get("/hi", function() "Hello") %&gt;%
  pr_set_404(handler_404) %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='pr_set_api_spec'>Set the OpenAPI Specification</h2><span id='topic+pr_set_api_spec'></span>

<h3>Description</h3>

<p>Allows to modify OpenAPI Specification autogenerated by <code>plumber</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_api_spec(pr, api)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_api_spec_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_api_spec_+3A_api">api</code></td>
<td>
<p>This can be
</p>

<ul>
<li><p> an OpenAPI Specification formatted list object
</p>
</li>
<li><p> a function that accepts the OpenAPI Specification autogenerated by <code>plumber</code> and returns a OpenAPI Specification formatted list object.
</p>
</li>
<li><p> a path to an OpenAPI Specification
</p>
</li></ul>

<p>The value returned will not be validated for OAS compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, the returned value will be sent through <code><a href="#topic+serializer_unboxed_json">serializer_unboxed_json()</a></code> which will turn all length 1 vectors into atomic values.
To force a vector to serialize to an array of size 1, be sure to call <code><a href="base.html#topic+as.list">as.list()</a></code> on your value. <code>list()</code> objects are always serialized to an array value.
</p>


<h3>Value</h3>

<p>The Plumber router with the new OpenAPI Specification object or function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set the API Spec to a function to use the auto-generated OAS object
pr() %&gt;%
  pr_set_api_spec(function(spec) {
    spec$info$title &lt;- Sys.time()
    spec
  }) %&gt;%
  pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
  pr_run()

# Set the API Spec using an object
pr() %&gt;%
  pr_set_api_spec(my_custom_object) %&gt;%
  pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_set_debug'>Set debug value to include error messages of routes cause an error</h2><span id='topic+pr_set_debug'></span>

<h3>Description</h3>

<p>To hide any error messages in production, set the debug value to <code>FALSE</code>.
The <code>debug</code> value is enabled by default for <code><a href="base.html#topic+interactive">interactive()</a></code> sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_debug(pr, debug = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_debug_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_debug_+3A_debug">debug</code></td>
<td>
<p><code>TRUE</code> provides more insight into your API errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with the new debug setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Will contain the original error message
pr() %&gt;%
  pr_set_debug(TRUE) %&gt;%
  pr_get("/boom", function() stop("boom")) %&gt;%
  pr_run()

# Will NOT contain an error message
pr() %&gt;%
  pr_set_debug(FALSE) %&gt;%
  pr_get("/boom", function() stop("boom")) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_set_docs'>Set the API visual documentation</h2><span id='topic+pr_set_docs'></span>

<h3>Description</h3>

<p><code>docs</code> should be either a logical or a character value matching a registered visual documentation.
Multiple handles will be added to <code><a href="#topic+Plumber">Plumber</a></code> object. OpenAPI json
file will be served on paths <code style="white-space: pre;">&#8288;/openapi.json&#8288;</code>. Documentation
will be served on paths <code style="white-space: pre;">&#8288;/__docs__/index.html&#8288;</code> and <code style="white-space: pre;">&#8288;/__docs__/&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_docs(pr, docs = get_option_or_env("plumber.docs", TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_docs_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_docs_+3A_docs">docs</code></td>
<td>
<p>a character value or a logical value.
If using <code><a href="#topic+options_plumber">options_plumber()</a></code>, the value must be set before initializing your Plumber router.</p>
</td></tr>
<tr><td><code id="pr_set_docs_+3A_...">...</code></td>
<td>
<p>Arguments for the visual documentation. See each visual documentation package for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with the new docs settings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## View API using Swagger UI
# Official Website: https://swagger.io/tools/swagger-ui/
# install.packages("swagger")
if (require(swagger)) {
  pr() %&gt;%
    pr_set_docs("swagger") %&gt;%
    pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
    pr_run()
}

## View API using Redoc
# Official Website: https://github.com/Redocly/redoc
if (require(redoc)) {
  pr() %&gt;%
    pr_set_docs("redoc") %&gt;%
    pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
    pr_run()
}

## View API using RapiDoc
# Official Website: https://github.com/mrin9/RapiDoc
if (require(rapidoc)) {
  pr() %&gt;%
    pr_set_docs("rapidoc") %&gt;%
    pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
    pr_run()
}

## Disable the OpenAPI Spec UI
pr() %&gt;%
  pr_set_docs(FALSE) %&gt;%
  pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_set_docs_callback'>Set the <code>callback</code> to tell where the API visual documentation is located</h2><span id='topic+pr_set_docs_callback'></span>

<h3>Description</h3>

<p>When set, it will be called with a character string corresponding
to the API visual documentation url. This allows RStudio to locate visual documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_docs_callback(
  pr,
  callback = get_option_or_env("plumber.docs.callback", NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_docs_callback_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_docs_callback_+3A_callback">callback</code></td>
<td>
<p>a callback function for taking action on the docs url.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using <code><a href="#topic+options_plumber">options_plumber()</a></code>, the value must be set before initializing your Plumber router.
</p>


<h3>Value</h3>

<p>The Plumber router with the new docs callback setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_set_docs_callback(function(url) { message("API location: ", url) }) %&gt;%
  pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_set_error'>Set the error handler that is invoked if any filter or endpoint generates an
error</h2><span id='topic+pr_set_error'></span>

<h3>Description</h3>

<p>Set the error handler that is invoked if any filter or endpoint generates an
error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_error(pr, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_error_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_error_+3A_fun">fun</code></td>
<td>
<p>An error handler function. This should accept <code>req</code>, <code>res</code>, and the error value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with a modified error handler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
handler_error &lt;- function(req, res, err){
  res$status &lt;- 500
  list(error = "Custom Error Message")
}

pr() %&gt;%
  pr_get("/error", function() log("a")) %&gt;%
  pr_set_error(handler_error) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='pr_set_parsers'>Set the default endpoint parsers for the router</h2><span id='topic+pr_set_parsers'></span>

<h3>Description</h3>

<p>By default, Plumber will parse JSON, text, query strings, octet streams, and multipart bodies. This function updates the
default parsers for any endpoint that does not define their own parsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_parsers(pr, parsers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_parsers_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_parsers_+3A_parsers">parsers</code></td>
<td>
<p>Can be one of:
</p>

<ul>
<li><p> A <code>NULL</code> value
</p>
</li>
<li><p> A character vector of parser names
</p>
</li>
<li><p> A named <code>list()</code> whose keys are parser names names and values are arguments to be applied with <code><a href="base.html#topic+do.call">do.call()</a></code>
</p>
</li>
<li><p> A <code>TRUE</code> value, which will default to combining all parsers. This is great for seeing what is possible, but not great for security purposes
</p>
</li></ul>

<p>If the parser name <code>"all"</code> is found in any character value or list name, all remaining parsers will be added.
When using a list, parser information already defined will maintain their existing argument values.  All remaining parsers will use their default arguments.
</p>
<p>Example:
</p>
<div class="sourceCode"><pre># provide a character string
parsers = "json"

# provide a named list with no arguments
parsers = list(json = list())

# provide a named list with arguments; include `rds`
parsers = list(json = list(simplifyVector = FALSE), rds = list())

# default plumber parsers
parsers = c("json", "form", "text", "octet", "multi")
</pre></div></td></tr>
</table>


<h3>Details</h3>

<p>Note: The default set of parsers will be completely replaced if any value is supplied. Be sure to include all of your parsers that you would like to include.
Use <code>registered_parsers()</code> to get a list of available parser names.
</p>


<h3>Value</h3>

<p>The Plumber router with the new default <a href="#topic+PlumberEndpoint">PlumberEndpoint</a> parsers
</p>

<hr>
<h2 id='pr_set_serializer'>Set the default serializer of the router</h2><span id='topic+pr_set_serializer'></span>

<h3>Description</h3>

<p>By default, Plumber serializes responses to JSON. This function updates the
default serializer to the function supplied via <code>serializer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_set_serializer(pr, serializer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_set_serializer_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_set_serializer_+3A_serializer">serializer</code></td>
<td>
<p>A serializer function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Plumber router with the new default serializer
</p>

<hr>
<h2 id='pr_static'>Add a static route to the <code>plumber</code> object</h2><span id='topic+pr_static'></span>

<h3>Description</h3>

<p>Add a static route to the <code>plumber</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_static(pr, path, direc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_static_+3A_pr">pr</code></td>
<td>
<p>A Plumber API. Note: The supplied Plumber API object will also be updated in place as well as returned by the function.</p>
</td></tr>
<tr><td><code id="pr_static_+3A_path">path</code></td>
<td>
<p>The mounted path location of the static folder</p>
</td></tr>
<tr><td><code id="pr_static_+3A_direc">direc</code></td>
<td>
<p>The local folder to be served statically</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr() %&gt;%
  pr_static("/path", "./my_folder/location") %&gt;%
  pr_run()

## End(Not run)

</code></pre>

<hr>
<h2 id='random_cookie_key'>Random cookie key generator</h2><span id='topic+random_cookie_key'></span>

<h3>Description</h3>

<p>Uses a cryptographically secure pseudorandom number generator from <code><a href="sodium.html#topic+helpers">sodium::helpers()</a></code> to generate a 64 digit hexadecimal string.  <a href="https://github.com/r-lib/sodium">'sodium'</a> wraps around <a href="https://doc.libsodium.org/">'libsodium'</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_cookie_key()
</code></pre>


<h3>Details</h3>

<p>Please see <code><a href="#topic+session_cookie">session_cookie</a></code> for more information on how to save the generated key.
</p>


<h3>Value</h3>

<p>A 64 digit hexadecimal string to be used as a key for cookie encryption.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+session_cookie">session_cookie</a></code>
</p>

<hr>
<h2 id='register_docs'>Add visual documentation for plumber to use</h2><span id='topic+register_docs'></span><span id='topic+registered_docs'></span>

<h3>Description</h3>

<p><code><a href="#topic+register_docs">register_docs()</a></code> is used by other packages like <code>swagger</code>, <code>rapidoc</code>, and <code>redoc</code>.
When you load these packages, it calls <code><a href="#topic+register_docs">register_docs()</a></code> to provide a user
interface that can interpret your plumber OpenAPI Specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_docs(name, index, static = NULL)

registered_docs()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_docs_+3A_name">name</code></td>
<td>
<p>Name of the visual documentation</p>
</td></tr>
<tr><td><code id="register_docs_+3A_index">index</code></td>
<td>
<p>A function that returns the HTML content of the landing page of the documentation.
Parameters (besides <code>req</code> and <code>res</code>) will be supplied as if it is a regular <code>GET</code> route.
Default parameter values may be used when setting the documentation <code>index</code> function.
See the example below.</p>
</td></tr>
<tr><td><code id="register_docs_+3A_static">static</code></td>
<td>
<p>A function that returns the path to the static assets (images, javascript, css, fonts) the Docs will use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example from the `swagger` R package
register_docs(
  name = "swagger",
  index = function(version = "3", ...) {
    swagger::swagger_spec(
      api_path = paste0(
        "window.location.origin + ",
        "window.location.pathname.replace(",
          "/\\(__docs__\\\\/|__docs__\\\\/index.html\\)$/, \"\"",
        ") + ",
        "\"openapi.json\""
      ),
      version = version
    )
  },
  static = function(version = "3", ...) {
    swagger::swagger_path(version)
  }
)

# When setting the docs, `index` and `static` function arguments can be supplied
# * via `pr_set_docs()`
# * or through URL query string variables
pr() %&gt;%
  # Set default argument `version = "3"` for the swagger `index` and `static` functions
  pr_set_docs("swagger", version = "3") %&gt;%
  pr_get("/plus/&lt;a:int&gt;/&lt;b:int&gt;", function(a, b) { a + b }) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='register_parser'>Manage parsers</h2><span id='topic+register_parser'></span><span id='topic+registered_parsers'></span>

<h3>Description</h3>

<p>A parser is responsible for decoding the raw body content of a request into
a list of arguments that can be mapped to endpoint function arguments.
For instance, <code><a href="#topic+parser_json">parser_json()</a></code> parse content-type <code>application/json</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_parser(alias, parser, fixed = NULL, regex = NULL, verbose = TRUE)

registered_parsers()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_parser_+3A_alias">alias</code></td>
<td>
<p>An alias to map parser from the <code style="white-space: pre;">&#8288;@parser&#8288;</code> plumber tag to the global parsers list.</p>
</td></tr>
<tr><td><code id="register_parser_+3A_parser">parser</code></td>
<td>
<p>The parser function to be added. This build the parser function. See Details for more information.</p>
</td></tr>
<tr><td><code id="register_parser_+3A_fixed">fixed</code></td>
<td>
<p>A character vector of fixed string to be matched against a request <code>content-type</code> to use <code>parser</code>.</p>
</td></tr>
<tr><td><code id="register_parser_+3A_regex">regex</code></td>
<td>
<p>A character vector of <a href="base.html#topic+regex">regex</a> string to be matched against a request <code>content-type</code> to use <code>parser</code>.</p>
</td></tr>
<tr><td><code id="register_parser_+3A_verbose">verbose</code></td>
<td>
<p>Logical value which determines if a warning should be
displayed when alias in map are overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>parser</code> is evaluated, it should return a parser function.
Parser matching is done first by <code>content-type</code> header matching with <code>fixed</code> then by using
regular expressions with <code>regex</code>. Note that plumber strips <code style="white-space: pre;">&#8288;; charset*&#8288;</code> from <code>content-type</code> header before matching.
</p>
<p>Plumber will try to use <code><a href="#topic+parser_json">parser_json()</a></code> (if available) when no <code>content-type</code> header is found and
the request body starts with <code style="white-space: pre;">&#8288;{&#8288;</code> or <code>[</code>.
</p>
<p>Functions signature should include <code>value</code>, <code>...</code> and
possibly <code>content_type</code>, <code>filename</code>. Other parameters may be provided
if you want to use the headers from <code><a href="webutils.html#topic+parse_multipart">webutils::parse_multipart()</a></code>.
</p>
<p>Parser function structure is something like below.
</p>
<div class="sourceCode r"><pre>function(parser_arguments_here) {
  # return a function to parse a raw value
  function(value, ...) {
    # do something with raw value
  }
}
</pre></div>


<h3>Functions</h3>


<ul>
<li> <p><code>registered_parsers()</code>: Return all registered parsers
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># `content-type` header is mostly used to look up charset and adjust encoding
parser_dcf &lt;- function(...) {
  function(value, content_type = "text/x-dcf", ...) {
    charset &lt;- get_character_set(content_type)
    value &lt;- rawToChar(value)
    Encoding(value) &lt;- charset
    read.dcf(value, ...)
  }
}

# Could also leverage existing parsers
parser_dcf &lt;- function(...) {
  parser_read_file(function(tmpfile) {
    read.dcf(tmpfile, ...)
  })
}

# Register the newly created parser
## Not run: register_parser("dcf", parser_dcf, fixed = "text/x-dcf")
</code></pre>

<hr>
<h2 id='register_serializer'>Register a Serializer</h2><span id='topic+register_serializer'></span><span id='topic+registered_serializers'></span>

<h3>Description</h3>

<p>A serializer is responsible for translating a generated R value into output
that a remote user can understand. For instance, the <code>serializer_json</code>
serializes R objects into JSON before returning them to the user. The list of
available serializers in plumber is global.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_serializer(name, serializer, verbose = TRUE)

registered_serializers()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_serializer_+3A_name">name</code></td>
<td>
<p>The name of the serializer (character string)</p>
</td></tr>
<tr><td><code id="register_serializer_+3A_serializer">serializer</code></td>
<td>
<p>The serializer function to be added.
This function should accept arguments that can be supplied when <code><a href="#topic+plumb">plumb()</a></code>ing a file.
This function should return a function that accepts four arguments: <code>value</code>, <code>req</code>, <code>res</code>, and <code>errorHandler</code>.
See <code>print(serializer_json)</code> for an example.</p>
</td></tr>
<tr><td><code id="register_serializer_+3A_verbose">verbose</code></td>
<td>
<p>Logical value which determines if a message should be printed when overwriting serializers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three main building-block serializers:
</p>

<ul>
<li> <p><code>serializer_headers</code>: the base building-block serializer that is required to have <code><a href="#topic+as_attachment">as_attachment()</a></code> work
</p>
</li>
<li> <p><code>serializer_content_type()</code>: for setting the content type. (Calls <code>serializer_headers()</code>)
</p>
</li>
<li> <p><code>serializer_device()</code>: add endpoint hooks to turn a graphics device on and off in addition to setting the content type. (Uses <code>serializer_content_type()</code>)
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>register_serializer()</code>: Register a serializer with a name
</p>
</li>
<li> <p><code>registered_serializers()</code>: Return a list of all registered serializers
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># `serializer_json()` calls `serializer_content_type()` and supplies a serialization function
print(serializer_json)
# serializer_content_type() calls `serializer_headers()` and supplies a serialization function
print(serializer_content_type)
</code></pre>

<hr>
<h2 id='serializer_headers'>Plumber Serializers</h2><span id='topic+serializer_headers'></span><span id='topic+serializer_content_type'></span><span id='topic+serializer_octet'></span><span id='topic+serializer_csv'></span><span id='topic+serializer_tsv'></span><span id='topic+serializer_html'></span><span id='topic+serializer_json'></span><span id='topic+serializer_unboxed_json'></span><span id='topic+serializer_geojson'></span><span id='topic+serializer_rds'></span><span id='topic+serializer_feather'></span><span id='topic+serializer_parquet'></span><span id='topic+serializer_yaml'></span><span id='topic+serializer_text'></span><span id='topic+serializer_format'></span><span id='topic+serializer_print'></span><span id='topic+serializer_cat'></span><span id='topic+serializer_write_file'></span><span id='topic+serializer_htmlwidget'></span><span id='topic+serializer_device'></span><span id='topic+serializer_jpeg'></span><span id='topic+serializer_png'></span><span id='topic+serializer_svg'></span><span id='topic+serializer_bmp'></span><span id='topic+serializer_tiff'></span><span id='topic+serializer_pdf'></span>

<h3>Description</h3>

<p>Serializers are used in Plumber to transform the R object produced by a
filter/endpoint into an HTTP response that can be returned to the client. See
<a href="https://www.rplumber.io/articles/rendering-output.html#serializers-1">here</a> for
more details on Plumber serializers and how to customize their behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serializer_headers(headers = list(), serialize_fn = identity)

serializer_content_type(type, serialize_fn = identity)

serializer_octet(..., type = "application/octet-stream")

serializer_csv(..., type = "text/csv; charset=UTF-8")

serializer_tsv(..., type = "text/tab-separated-values; charset=UTF-8")

serializer_html(type = "text/html; charset=UTF-8")

serializer_json(..., type = "application/json")

serializer_unboxed_json(auto_unbox = TRUE, ..., type = "application/json")

serializer_geojson(..., type = "application/geo+json")

serializer_rds(version = "2", ascii = FALSE, ..., type = "application/rds")

serializer_feather(type = "application/vnd.apache.arrow.file")

serializer_parquet(type = "application/vnd.apache.parquet")

serializer_yaml(..., type = "text/x-yaml; charset=UTF-8")

serializer_text(
  ...,
  serialize_fn = as.character,
  type = "text/plain; charset=UTF-8"
)

serializer_format(..., type = "text/plain; charset=UTF-8")

serializer_print(..., type = "text/plain; charset=UTF-8")

serializer_cat(..., type = "text/plain; charset=UTF-8")

serializer_write_file(type, write_fn, fileext = NULL)

serializer_htmlwidget(..., type = "text/html; charset=UTF-8")

serializer_device(type, dev_on, dev_off = grDevices::dev.off)

serializer_jpeg(..., type = "image/jpeg")

serializer_png(..., type = "image/png")

serializer_svg(..., type = "image/svg+xml")

serializer_bmp(..., type = "image/bmp")

serializer_tiff(..., type = "image/tiff")

serializer_pdf(..., type = "application/pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serializer_headers_+3A_headers">headers</code></td>
<td>
<p><code>list()</code> of headers to add to the response object</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_serialize_fn">serialize_fn</code></td>
<td>
<p>Function to serialize the data. The result object will be converted to a character string. Ex: <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_type">type</code></td>
<td>
<p>The value to provide for the <code>Content-Type</code> HTTP header.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_...">...</code></td>
<td>
<p>extra arguments supplied to respective internal serialization function.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_auto_unbox">auto_unbox</code></td>
<td>
<p>automatically <code><a href="jsonlite.html#topic+unbox">unbox()</a></code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code><a href="jsonlite.html#topic+unbox">unbox()</a></code> function to unbox individual elements.
An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code><a href="base.html#topic+I">I()</a></code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_version">version</code></td>
<td>
<p>the workspace format version to use.  <code>NULL</code>
specifies the current default version (3). The only other supported
value is 2, the default from <span class="rlang"><b>R</b></span> 1.4.0 to <span class="rlang"><b>R</b></span> 3.5.0.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_ascii">ascii</code></td>
<td>
<p>a logical.  If <code>TRUE</code> or <code>NA</code>, an ASCII
representation is written; otherwise (default) a binary one.
See also the comments in the help for <code><a href="base.html#topic+save">save</a></code>.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_write_fn">write_fn</code></td>
<td>
<p>Function that should write serialized content to the temp file provided. <code>write_fn</code> should have the function signature of <code>function(value, tmp_file){}</code>.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_fileext">fileext</code></td>
<td>
<p>A non-empty character vector giving the file extension. This value will try to be inferred from the content type provided.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_dev_on">dev_on</code></td>
<td>
<p>Function to turn on a graphics device.
The graphics device <code>dev_on</code> function will receive any arguments supplied to the serializer in addition to <code>filename</code>.
<code>filename</code> points to the temporary file name that should be used when saving content.</p>
</td></tr>
<tr><td><code id="serializer_headers_+3A_dev_off">dev_off</code></td>
<td>
<p>Function to turn off the graphics device. Defaults to <code><a href="grDevices.html#topic+dev">grDevices::dev.off()</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>serializer_headers()</code>: Add a static list of headers to each return value. Will add <code>Content-Disposition</code> header if a value is the result of <code>as_attachment()</code>.
</p>
</li>
<li> <p><code>serializer_content_type()</code>: Adds a <code>Content-Type</code> header to the response object
</p>
</li>
<li> <p><code>serializer_octet()</code>: Octet serializer. If content is received that does
not have a <code>"raw"</code> type, then an error will be thrown.
</p>
</li>
<li> <p><code>serializer_csv()</code>: CSV serializer. See also: <code><a href="readr.html#topic+format_delim">readr::format_csv()</a></code>
</p>
</li>
<li> <p><code>serializer_tsv()</code>: TSV serializer. See also: <code><a href="readr.html#topic+format_delim">readr::format_tsv()</a></code>
</p>
</li>
<li> <p><code>serializer_html()</code>: HTML serializer
</p>
</li>
<li> <p><code>serializer_json()</code>: JSON serializer. See also: <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>
</p>
</li>
<li> <p><code>serializer_unboxed_json()</code>: JSON serializer with <code>auto_unbox</code> defaulting to <code>TRUE</code>. See also: <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>
</p>
</li>
<li> <p><code>serializer_geojson()</code>: GeoJSON serializer. See also <code><a href="geojsonsf.html#topic+sf_geojson">geojsonsf::sf_geojson()</a></code> and [<code><a href="geojsonsf.html#topic+sfc_geojson">geojsonsf::sfc_geojson()</a></code>].
</p>
</li>
<li> <p><code>serializer_rds()</code>: RDS serializer. See also: <code><a href="base.html#topic+serialize">base::serialize()</a></code>
</p>
</li>
<li> <p><code>serializer_feather()</code>: feather serializer. See also: <code><a href="arrow.html#topic+write_feather">arrow::write_feather()</a></code>
</p>
</li>
<li> <p><code>serializer_parquet()</code>: parquet serializer. See also: <code><a href="arrow.html#topic+write_parquet">arrow::write_parquet()</a></code>
</p>
</li>
<li> <p><code>serializer_yaml()</code>: YAML serializer. See also: <code><a href="yaml.html#topic+as.yaml">yaml::as.yaml()</a></code>
</p>
</li>
<li> <p><code>serializer_text()</code>: Text serializer. See also: <code><a href="base.html#topic+as.character">as.character()</a></code>
</p>
</li>
<li> <p><code>serializer_format()</code>: Text serializer. See also: <code><a href="base.html#topic+format">format()</a></code>
</p>
</li>
<li> <p><code>serializer_print()</code>: Text serializer. Captures the output of <code><a href="base.html#topic+print">print()</a></code>
</p>
</li>
<li> <p><code>serializer_cat()</code>: Text serializer. Captures the output of <code><a href="base.html#topic+cat">cat()</a></code>
</p>
</li>
<li> <p><code>serializer_write_file()</code>: Write output to a temp file whose contents are read back as a serialized response. <code>serializer_write_file()</code> creates (and cleans up) a temp file, calls the serializer (which should write to the temp file), and then reads the contents back as the serialized value.  If the content <code>type</code> starts with <code>"text"</code>, the return result will be read into a character string, otherwise the result will be returned as a raw vector.
</p>
</li>
<li> <p><code>serializer_htmlwidget()</code>: htmlwidget serializer. See also: <code><a href="htmlwidgets.html#topic+saveWidget">htmlwidgets::saveWidget()</a></code>
</p>
</li>
<li> <p><code>serializer_device()</code>: Helper method to create graphics device serializers, such as <code><a href="#topic+serializer_png">serializer_png()</a></code>. See also: <code><a href="#topic+endpoint_serializer">endpoint_serializer()</a></code>
</p>
</li>
<li> <p><code>serializer_jpeg()</code>: JPEG image serializer. See also: <code><a href="grDevices.html#topic+png">grDevices::jpeg()</a></code>
</p>
</li>
<li> <p><code>serializer_png()</code>: PNG image serializer. See also: <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>
</p>
</li>
<li> <p><code>serializer_svg()</code>: SVG image serializer. See also: <code><a href="grDevices.html#topic+cairo">grDevices::svg()</a></code>
</p>
</li>
<li> <p><code>serializer_bmp()</code>: BMP image serializer. See also: <code><a href="grDevices.html#topic+png">grDevices::bmp()</a></code>
</p>
</li>
<li> <p><code>serializer_tiff()</code>: TIFF image serializer. See also: <code><a href="grDevices.html#topic+png">grDevices::tiff()</a></code>
</p>
</li>
<li> <p><code>serializer_pdf()</code>: PDF image serializer. See also: <code><a href="grDevices.html#topic+pdf">grDevices::pdf()</a></code>
</p>
</li></ul>

<hr>
<h2 id='session_cookie'>Store session data in encrypted cookies.</h2><span id='topic+session_cookie'></span>

<h3>Description</h3>

<p><code>plumber</code> uses the crypto R package <code>sodium</code>, to encrypt/decrypt
<code>req$session</code> information for each server request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>session_cookie(
  key,
  name = "plumber",
  expiration = FALSE,
  http = TRUE,
  secure = FALSE,
  same_site = FALSE,
  path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="session_cookie_+3A_key">key</code></td>
<td>
<p>The secret key to use. This must be consistent across all R sessions
where you want to save/restore encrypted cookies. It should be produced using
<code><a href="#topic+random_cookie_key">random_cookie_key</a></code>. Please see the &quot;Storing secure keys&quot; section for more details
complex character string to bolster security.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_name">name</code></td>
<td>
<p>The name of the cookie in the user's browser.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_expiration">expiration</code></td>
<td>
<p>A number representing the number of seconds into the future
before the cookie expires or a <code>POSIXt</code> date object of when the cookie expires.
Defaults to the end of the user's browser session.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_http">http</code></td>
<td>
<p>Boolean that adds the <code>HttpOnly</code> cookie flag that tells the browser
to save the cookie and to NOT send it to client-side scripts. This mitigates <a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">cross-site scripting</a>.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_secure">secure</code></td>
<td>
<p>Boolean that adds the <code>Secure</code> cookie flag.  This should be set
when the route is eventually delivered over <a href="https://en.wikipedia.org/wiki/HTTPS">HTTPS</a>.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_same_site">same_site</code></td>
<td>
<p>A character specifying the SameSite policy to attach to the cookie.
If specified, one of the following values should be given: &quot;Strict&quot;, &quot;Lax&quot;, or &quot;None&quot;.
If &quot;None&quot; is specified, then the <code>secure</code> flag MUST also be set for the modern browsers to
accept the cookie. An error will be returned if <code>same_site = "None"</code> and <code>secure = FALSE</code>.
If not specified or a non-character is given, no SameSite policy is attached to the cookie.</p>
</td></tr>
<tr><td><code id="session_cookie_+3A_path">path</code></td>
<td>
<p>The URI path that the cookie will be available in future requests.
Defaults to the request URI. Set to <code>"/"</code> to make cookie available to
all requests at the host.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cookie's secret encryption <code>key</code> value must be consistent to maintain
<code>req$session</code> information between server restarts.
</p>


<h3>Storing secure keys</h3>

<p>While it is very quick to get started with user session cookies using
<code>plumber</code>, please exercise precaution when storing secure key information.
If a malicious person were to gain access to the secret <code>key</code>, they would
be able to eavesdrop on all <code>req$session</code> information and/or tamper with
<code>req$session</code> information being processed.
</p>
<p>Please: </p>

<ul>
<li><p> Do NOT store keys in source control.
</p>
</li>
<li><p> Do NOT store keys on disk with permissions that allow it to be accessed by everyone.
</p>
</li>
<li><p> Do NOT store keys in databases which can be queried by everyone.
</p>
</li></ul>

<p>Instead, please: </p>

<ul>
<li><p> Use a key management system, such as
<a href="https://github.com/r-lib/keyring">'keyring'</a> (preferred)
</p>
</li>
<li><p> Store the secret in a file on disk with appropriately secure permissions,
such as &quot;user read only&quot; (<code>Sys.chmod("myfile.txt", mode = "0600")</code>),
to prevent others from reading it.
</p>
</li></ul>
<p> Examples of both of these solutions are done in the Examples section.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="https://github.com/r-lib/sodium">'sodium'</a>: R bindings to 'libsodium'
</p>
</li>
<li> <p><a href="https://doc.libsodium.org/">'libsodium'</a>: A Modern and Easy-to-Use Crypto Library
</p>
</li>
<li> <p><a href="https://github.com/r-lib/keyring">'keyring'</a>: Access the system credential store from R
</p>
</li>
<li> <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives">Set-Cookie flags</a>: Descriptions of different flags for <code>Set-Cookie</code>
</p>
</li>
<li> <p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">Cross-site scripting</a>: A security exploit which allows an attacker to inject into a website malicious client-side code
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Set secret key using `keyring` (preferred method)
keyring::key_set_with_value("plumber_api", plumber::random_cookie_key())


# Load a plumber API
plumb_api("plumber", "01-append") %&gt;%
  # Add cookie support via `keyring`
  pr_cookie(
    keyring::key_get("plumber_api")
  ) %&gt;%
  pr_run()


#### -------------------------------- ###


## Save key to a local file
pswd_file &lt;- "normal_file.txt"
cat(plumber::random_cookie_key(), file = pswd_file)
# Make file read-only
Sys.chmod(pswd_file, mode = "0600")


# Load a plumber API
plumb_api("plumber", "01-append") %&gt;%
  # Add cookie support and retrieve secret key from file
  pr_cookie(
    readLines(pswd_file, warn = FALSE)
  ) %&gt;%
  pr_run()

## End(Not run)
</code></pre>

<hr>
<h2 id='validate_api_spec'>Validate OpenAPI Spec</h2><span id='topic+validate_api_spec'></span>

<h3>Description</h3>

<p>Validate an OpenAPI Spec using <a href="https://github.com/APIDevTools/swagger-cli">Swagger CLI</a> which calls <a href="https://github.com/APIDevTools/swagger-parser">Swagger Parser</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_api_spec(pr, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_api_spec_+3A_pr">pr</code></td>
<td>
<p>A Plumber API</p>
</td></tr>
<tr><td><code id="validate_api_spec_+3A_verbose">verbose</code></td>
<td>
<p>Logical that determines if a &quot;is valid&quot; statement is displayed. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the api is deemed invalid, an error will be thrown.
</p>
<p>This function is VERY <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> and may be altered, changed, or removed in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pr &lt;- plumb_api("plumber", "01-append")
validate_api_spec(pr)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
