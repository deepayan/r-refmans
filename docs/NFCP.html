<!DOCTYPE html><html lang="en"><head><title>Help for package NFCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NFCP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A_T'><p>Calculate <code class="reqn">A(T)</code></p></a></li>
<li><a href='#American_option_value'><p>N-factor model American options on futures contracts valuation</p></a></li>
<li><a href='#cov_func'><p>N-factor model covariance:</p></a></li>
<li><a href='#European_option_value'><p>N-factor model European options on futures contracts valuation</p></a></li>
<li><a href='#futures_price_forecast'><p>Forecast the futures prices of an N-factor model</p></a></li>
<li><a href='#futures_price_simulate'><p>Simulate futures prices of an N-factor model through Monte Carlo simulation</p></a></li>
<li><a href='#NFCP_domains'><p>N-Factor MLE search boundaries</p></a></li>
<li><a href='#NFCP_Kalman_filter'><p>Filter an N-factor commodity pricing model though the Kalman filter</p></a></li>
<li><a href='#NFCP_MLE'><p>N-factor model parameter estimation through the Kalman filter and maximum likelihood estimation</p></a></li>
<li><a href='#NFCP_parameters'><p>Specify the constant parameters of an N-factor model</p></a></li>
<li><a href='#spot_price_forecast'><p>Forecast spot prices of an N-factor model</p></a></li>
<li><a href='#spot_price_simulate'><p>Simulate spot prices of an N-factor model through Monte Carlo simulation</p></a></li>
<li><a href='#SS_oil'><p>Crude oil term structure futures data (1990 - 1995)</p></a></li>
<li><a href='#stitch_contracts'><p>Stitch futures contracts</p></a></li>
<li><a href='#TSfit_volatility'><p>Calculate the volatility term structure of futures returns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>N-Factor Commodity Pricing Through Term Structure Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Commodity pricing models are (systems of) stochastic differential equations that are utilized for the valuation and hedging of commodity contingent claims (i.e. derivative products on the commodity) and other commodity related investments. Commodity pricing models that capture market dynamics are of great importance to commodity market participants in order to exercise sound investment and risk-management strategies. Parameters of commodity pricing models are estimated through maximum likelihood estimation, using available term structure futures data of a commodity. 'NFCP' (n-factor commodity pricing) provides a framework for the modeling, parameter estimation, probabilistic forecasting, option valuation and simulation of commodity prices through state space and Monte Carlo methods, risk-neutral valuation and Kalman filtering. 'NFCP' allows the commodity pricing model to consist of n correlated factors, with both random walk and mean-reverting elements. The n-factor commodity pricing model framework was first presented in the work of Cortazar and Naranjo (2006) &lt;<a href="https://doi.org/10.1002%2Ffut.20198">doi:10.1002/fut.20198</a>&gt;. Examples presented in 'NFCP' replicate the two-factor crude oil commodity pricing model presented in the prolific work of Schwartz and Smith (2000) &lt;<a href="https://doi.org/10.1287%2Fmnsc.46.7.893.12034">doi:10.1287/mnsc.46.7.893.12034</a>&gt; with the approximate term structure futures data applied within this study provided in the 'NFCP' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>FKF.SP, LSMRealOptions, MASS, numDeriv, parallel, rgenoud,
stats, mathjaxr, Rdpack, curl</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-17 11:33:30 UTC; Thomas Aspinall</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Aspinall <a href="https://orcid.org/0000-0002-6968-1989"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Adrian Gepp <a href="https://orcid.org/0000-0003-1666-5501"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Geoff Harris <a href="https://orcid.org/0000-0003-4284-8619"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Simone Kelly <a href="https://orcid.org/0000-0002-6528-8557"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Colette Southam <a href="https://orcid.org/0000-0001-7263-2347"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bruce Vanstone <a href="https://orcid.org/0000-0002-3977-2468"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Aspinall &lt;tomaspinall2512@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-17 12:02:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='A_T'>Calculate <code class="reqn">A(T)</code></h2><span id='topic+A_T'></span>

<h3>Description</h3>

<p>Calculate the values of <code class="reqn">A(T)</code> for a given N-factor model parameters and observations. Primarily purpose is for application within other functions of the <code>NFCP</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_T(parameters, Tt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A_T_+3A_parameters">parameters</code></td>
<td>
<p>A named vector of parameters of an N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="A_T_+3A_tt">Tt</code></td>
<td>
<p>A vector or matrix of the time-to-maturity of observed futures prices</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Under the assumption that Factor 1 follows a Brownian Motion, <code class="reqn">A(T)</code> is given by:
\[A(T) = \mu^*T-\sum_{i=1}^N - \frac{1-e^{-\kappa_i T}\lambda_i}{\kappa_i}+\frac{1}{2}(\sigma_1^2T +
\sum_{i.j\neq 1} \sigma_i \sigma_j \rho_{i,j} \frac{1-e^{-(\kappa_i+\kappa_j)T}}{\kappa_i+\kappa_j})\]
</p>


<h3>Value</h3>

<p>A matrix of identical dimensions to <code class="reqn">T</code> providing the values of function <code class="reqn">A(T)</code> of a given N-factor model and observations.
</p>


<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Calculate time homogeneous values of A(T) for the
##Schwartz and Smith (2000) two-factor model:
SS_oil_A_T &lt;- A_T(SS_oil$two_factor, SS_oil$stitched_TTM)

</code></pre>

<hr>
<h2 id='American_option_value'>N-factor model American options on futures contracts valuation</h2><span id='topic+American_option_value'></span>

<h3>Description</h3>

<p>Value American options on futures contracts under the parameters of an N-factor model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>American_option_value(
  x_0,
  parameters,
  futures_maturity,
  option_maturity,
  K,
  r,
  call = FALSE,
  N_simulations,
  dt,
  orthogonal = "Power",
  degree = 2,
  verbose = FALSE,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="American_option_value_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_futures_maturity">futures_maturity</code></td>
<td>
<p><code>numeric</code>. Time, in years, when the underlying futures contract matures.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_option_maturity">option_maturity</code></td>
<td>
<p><code>numeric</code>. Time, in years,  when the American option expires.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_k">K</code></td>
<td>
<p><code>numeric</code>. Strike price of the American Option.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_r">r</code></td>
<td>
<p><code>numeric</code>. Annualized risk-free interest rate.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_call">call</code></td>
<td>
<p><code>logical</code>. Is the American option a call or put option?</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_n_simulations">N_simulations</code></td>
<td>
<p><code>numeric</code>. Total number of simulated price paths.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Discrete time step, in years, of the Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_orthogonal">orthogonal</code></td>
<td>
<p><code>character</code>. The orthogonal polynomial used to approximate the continuation value of the option in the LSM simulation method.
Orthogonal polynomial arguments available are: &quot;Power&quot;, &quot;Laguerre&quot;, &quot;Jacobi&quot;, &quot;Legendre&quot;, &quot;Chebyshev&quot;, &quot;Hermite&quot;.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_degree">degree</code></td>
<td>
<p><code>numeric</code>. The degree of polynomials used in the least squares fit.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should additional option value information be output? see <b>details</b>.</p>
</td></tr>
<tr><td><code id="American_option_value_+3A_debugging">debugging</code></td>
<td>
<p><code>logical</code> Should the simulated state variables and futures prices be output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>American_option_value</code> function calculates numerically the value of American options on futures contracts within the N-factor model. An American option on a commodity futures contract gives the holder
the right, but not the obligation, to buy (call) or sell (put) the underlying asset at any time before option maturity. If the American option is exercised, the option devolves into buying or selling of the underlying
futures asset at the exercise price.
</p>
<p>The 'American_option_value' function uses Monte Carlo simulation and the Least-Squares Monte Carlo (LSM) simulation approach to numerically calculate the value of American options on futures contracts under the N-factor model. LSM simulation is a method
that values options with early exercise opportunities, first presented by Longstaff and Schwartz (2001). LSM simulation uses discrete time steps to approximate the value of the American option and thus technically values Bermudan-style options,
converging to American option values as the size of the time step approaches zero. For more information on LSM simulation, see help('LSM_American_option') of the 'LSMRealOption' package or Longstaff and Schwartz (2001).
</p>
<p>For a provided N-factor model,the 'American_option_value' function simulates state variables under the N-factor framework through the 'spot_price_simulate' function, developing expected futures prices from
these simulated state variables. The function then uses
the 'LSM_American_option' of the 'LSMRealOption' package to calculate the value of the American option with early exercise opportunities.
</p>
<p>The number of simulations has a large influence on the standard error and accuracy of calculated option values at the cost of computational expense. Large numbers of simulations are suggested to converge upon appropriate values.
</p>
<p>Orthogonal polynomials are used in the LSM simulation method to approximate the value of continuing to hold the American option. In general, increasing the degree of orthogonal polynomials used should increase the accuracy of results, at the cost of increased computational expense.
</p>


<h3>Value</h3>

<p>The 'American_option_value' function by default returns a <code>numeric</code> object corresponding to the calculated value of the American option.
</p>
<p>When <code>verbose = T</code>, 6 objects related to the American option value are returned within a <code>list</code> class object. The objects returned are:
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>Value</code> </td><td style="text-align: left;"> The calculated option value. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Standard Error</code> </td><td style="text-align: left;"> The standard error of the calculated option value. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Expected Timing</code> </td><td style="text-align: left;"> The expected time of early exercise. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Expected Timing SE</code> </td><td style="text-align: left;"> The standard error of the expected time of early exercise. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Exercise Probability</code> </td><td style="text-align: left;"> The probability of early exercise of the option being exercised. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Cumulative Exercise Probability</code> </td><td style="text-align: left;"> <code>vector</code>. The cumulative probability of option exercise at each discrete observation point. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>debugging = T</code>, an additional 2 simulation objects are returned within the <code>list</code> class object. These objects can have high dimensions and thus memory usage, so caution should be applied. The objects returned are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Simulated State Variables</code> </td><td style="text-align: left;"> An array of simulated state variables. The three dimensions of the array correspond to a discrete time observation, simulated price path, and factor of the N-factor model, respectively. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Simulated Futures Prices</code> </td><td style="text-align: left;"> A matrix of simulated futures contract price paths. Each row represents one simulated discrete time observation and each column represents one simulated price path </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Longstaff, F.A., and E.S. Schwartz, (2001). Valuing American Options by Simulation: A Simple Least-Squares Approach. <em>The Review of Financial Studies.</em>, 14:113-147.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>
<p>Aspinall, T., A. Gepp, G. Harris, S. Kelly, C. Southam, and B. Vanstone, (2021). LSMRealOptions: Value
American and Real Options Through LSM Simulation. R package version 0.1.1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1 - An American put option on a futures contract following 'GBM'
American_option_value(x_0 = log(36),
                     parameters = c(mu_rn = 0.06, sigma_1 = 0.2),
                     N_simulations = 1e2,
                     futures_maturity = 1,
                     option_maturity = 1,
                     dt = 1/50,
                     K = 40,
                     r = 0.06,
                     verbose = FALSE,
                     orthogonal = "Laguerre",
                     degree = 3)

# Example 2 - An American put option under a two-factor crude oil model:

## Step 1 - Obtain current (i.e. most recent) state vector by filtering the
## two-factor oil model:
Schwartz_Smith_oil &lt;- NFCP_Kalman_filter(parameter_values = SS_oil$two_factor,
                                        parameter_names = names(SS_oil$two_factor),
                                        log_futures = log(SS_oil$stitched_futures),
                                        dt = SS_oil$dt,
                                        futures_TTM = SS_oil$stitched_TTM,
                                        verbose = TRUE)

##Step 2 - Calculate 'put' option price:
American_option_value(x_0 = Schwartz_Smith_oil$x_t,
                     parameters = SS_oil$two_factor,
                     futures_maturity = 2,
                     option_maturity = 1,
                     K = 20,
                     r = 0.05,
                     call = FALSE,
                     N_simulations = 1e2,
                     dt = 1/12,
                     verbose = TRUE,
                     orthogonal = "Power",
                     degree = 2)
</code></pre>

<hr>
<h2 id='cov_func'>N-factor model covariance:</h2><span id='topic+cov_func'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Calculate the covariance matrix of state variables for a given N-factor model parameters and discrete time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_func(parameters, dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_func_+3A_parameters">parameters</code></td>
<td>
<p>a named vector of parameters of an N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="cov_func_+3A_dt">dt</code></td>
<td>
<p>a discrete time step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary purpose of the <code>model_covariance</code> function is to be called within other functions of the <code>NFCP</code> package. The covariance of an N-factor model is given by:
</p>
\[cov_{1,1}(x_{1,t},x_{1,t}) = \sigma_1^2t\]
\[cov_{i,j}(x_{i,t},x_{j,t}) = \sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j}\]


<h3>Value</h3>

<p>A <code>matrix</code> object with dimensions \(N \times N\), where <i>N</i> is the number of factors of the specified N-factor model.
</p>


<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Calculate the covariance matrix of a two-factor model over one discrete (weekly) time step:
SS_oil.covariance &lt;- cov_func(SS_oil$two_factor, SS_oil$dt)

</code></pre>

<hr>
<h2 id='European_option_value'>N-factor model European options on futures contracts valuation</h2><span id='topic+European_option_value'></span>

<h3>Description</h3>

<p>Value European Option Put and Calls under the parameters of an N-factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>European_option_value(
  x_0,
  parameters,
  futures_maturity,
  option_maturity,
  K,
  r,
  call = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="European_option_value_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_futures_maturity">futures_maturity</code></td>
<td>
<p><code>numeric</code>. Time, in years, when the underlying futures contract matures.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_option_maturity">option_maturity</code></td>
<td>
<p><code>numeric</code>. Time, in years,  when the American option expires.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_k">K</code></td>
<td>
<p><code>numeric</code>. Strike price of the American Option.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_r">r</code></td>
<td>
<p><code>numeric</code>. Annualized risk-free interest rate.</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_call">call</code></td>
<td>
<p><code>logical</code>. Is the American option a call or put option?</p>
</td></tr>
<tr><td><code id="European_option_value_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should additional option value information be output? see <b>details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The <code>European_option_value</code> function calculates analytic expressions of the value of European call and put options on futures contracts within the N-factor model. A European option on a commodity futures contract gives the holder
the right, but not the obligation, to buy (call) or sell (put) the underlying asset at option maturity. If the European option is exercised, the option devolves into buying or selling of the underlying futures asset.
</p>
<p>State variables (i.e., the states of the factors of an N-factor model) are generally unobservable. Filtering the commodity pricing model using term structure data will provide the most recent optimal estimates of state variables, which can then be used to forecast and value European options.
</p>
<p>Under the assumption that future futures prices
are log-normally distributed under the risk-neutral process, there exist analytic expressions of the value of European call and put options on futures contracts. The value of a European option on a futures contract
is given by calculating the current expected futures price and the average instantaneous variance of the futures return innovations over the life of the option.
</p>
<p>Consider a European option with strike price \(K\) and a risk-free interest rate of \(r_f\). The option maturity is at time \(T_0\) and futures maturity at time \(T_1\).
The particular model features a state vector of length \(N\) (i.e., N-factors) \(x(t)\)
</p>
<p>The value of a European call option would thus be:
</p>
\[e^{-r T_0}  E^*[max(F(x(T_0),T_0,T_1) - K, 0)]\]
<p>The analytic solution to call and put options are given by:
</p>
<p>Call options:
\[e^{-r T_0}(F(x(0), 0, T_1)  N(d_1) - KN(d_2))\]
</p>
<p>Put options:
\[e^{-r T_0}(KN(-d_2) - F(x(0), 0, T_1)  N(-d_1))\]
</p>
<p>Where:
</p>
<p>Where:
\[d_1 = \frac{\ln(F/K) + \frac{1}{2} v^2}{v}\]
</p>
\[d_2 = d_1 - v\]
<p>Parameter \( N(d) \) indicates cumulative probabilities for the standard normal distribution (i.e. \(P(Z < d)\)).
</p>
<p>Finally, parameter \(v\), the annualized option volatility, is given by:
</p>
\[Var^*[\ln(F(x(T_0), T_0, T_1))] \equiv v^2 = \sum_{i.j=1} e^{(-\kappa_i + \kappa_j)(T_1 - T_0)}Cov^*(x_i(T_0), x_j(T_0))\]
<p>The annualized option volatility approaches \(\sigma_1^2 T_0\) as both \(T_0\) and \(T_1\) increase, as most uncertainty about spot prices at futures contract maturity and option expiration
are a result of uncertainty about spot prices, rather than the cost of carry (Schwartz and Smith, 2000).
</p>
<p>The presented option valuation formulas are analogous to the Black-Scholes formulas for valuing European options on stocks that do not pay dividends
</p>
<p>When <code>verbose = T</code>, the <code>European_option_value</code> function numerically calculates the sensitivity of option prices to underlying option and model parameters. Gradients are calculated numerically through the
<code>grad</code> function of the <code>numDeriv</code> package.
</p>


<h3>Value</h3>

<p>The <code>European_option_value</code> function returns a numeric value corresponding to the present value of an option when <code>verbose = F</code>.
When <code>verbose = T</code>, <code>European_option_value</code> returns a list with three objects:
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>option value</code> </td><td style="text-align: left;"> Present value of the option. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>annualized volatility</code> </td><td style="text-align: left;"> Annualized volatility of the option. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>parameter sensitivity</code> </td><td style="text-align: left;"> Sensitivity of option value to model parameters. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>greeks</code> </td><td style="text-align: left;"> Sensitivity of option value to option parameters. </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>
<p>Paul Gilbert and Ravi Varadhan (2016). numDeriv: Accurate Numerical Derivatives. R package version 2016.8-1. https://CRAN.R-project.org/package=numDeriv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example 1 - A European 'put' option on a futures contract following 'GBM'

European_option_value(x_0 = log(20), parameters = c(mu_rn = 0.06, sigma_1 = 0.2),
                     futures_maturity = 1, option_maturity = 1,
                     K = 20, r = 0.06, call = FALSE, verbose = TRUE)

##Example 2 - A European put option under a two-factor crude oil model:

##Step 1 - Obtain current (i.e. most recent) state vector by filtering the
##two-factor oil model:
Schwartz_Smith_oil &lt;- NFCP_Kalman_filter(parameter_values = SS_oil$two_factor,
                                        parameter_names = names(SS_oil$two_factor),
                                        log_futures = log(SS_oil$stitched_futures),
                                        dt = SS_oil$dt,
                                        futures_TTM = SS_oil$stitched_TTM,
                                        verbose = TRUE)

##Step 2 - Calculate 'call' option price:
European_option_value(x_0 = Schwartz_Smith_oil$x_t,
                     parameters = SS_oil$two_factor,
                     futures_maturity = 2,
                     option_maturity = 1,
                     K = 20,
                     r = 0.05,
                     call = FALSE,
                     verbose = FALSE)
</code></pre>

<hr>
<h2 id='futures_price_forecast'>Forecast the futures prices of an N-factor model</h2><span id='topic+futures_price_forecast'></span>

<h3>Description</h3>

<p>Analytically forecast future expected Futures prices under the risk-neutral version of a specified N-factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futures_price_forecast(
  x_0,
  parameters,
  t = 0,
  futures_TTM = 1:10,
  percentiles = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="futures_price_forecast_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="futures_price_forecast_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="futures_price_forecast_+3A_t">t</code></td>
<td>
<p><code>numeric</code>. The time point, in years, at which to forecast futures prices.</p>
</td></tr>
<tr><td><code id="futures_price_forecast_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p><code>vector</code>. the time-to-maturity, in years, of futures contracts to forecast.</p>
</td></tr>
<tr><td><code id="futures_price_forecast_+3A_percentiles">percentiles</code></td>
<td>
<p><code>vector</code>. Optional. Probabilistic forecasting percentile intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Under the assumption or risk-neutrality, futures prices are equal to the expected future spot price. Additionally, under deterministic interest rates, forward prices are equal to futures prices. Let \(F_{T,t}\)
denote the market price of a futures contract at time \(t\) with time \(T\) until maturity. let * denote the risk-neutral expectation and variance of futures prices.
The following equations assume that the first factor follows a Brownian Motion.
</p>
\[E^*[ln(F_{T,t})] = season(T) + \sum_{i=1}^Ne^{-\kappa_iT}x_{i}(0) + \mu^*t +  A(T-t)\]
<p>Where:
\[A(T-t) = \mu^*(T-t)-\sum_{i=1}^N - \frac{1-e^{-\kappa_i (T-t)}\lambda_i}{\kappa_i}+\frac{1}{2}(\sigma_1^2(T-t) + \sum_{i.j\neq 1} \sigma_i \sigma_j \rho_{i,j} \frac{1-e^{-(\kappa_i+\kappa_j)(T-t)}}{\kappa_i+\kappa_j})\]
The variance is given by:
\[Var^*[ln(F_{T,t})]= \sigma_1^2t + \sum_{i.j\neq1} e^{-(\kappa_i + \kappa_j)(T-t)}\sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j}\]
</p>


<h3>Value</h3>

<p><code>futures_price_forecast</code> returns a vector of expected Futures prices under a given N-factor model with specified time to maturities at time \(t\).  When <code>percentiles</code> are specified, the function returns a matrix with the corresponding confidence bands in each column of the matrix.
</p>


<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Forecast futures prices of the Schwartz and Smith (2000) two-factor oil model:
## Step 1 - Run the Kalman filter for the two-factor oil model:
SS_2F_filtered &lt;- NFCP_Kalman_filter(parameter_values = SS_oil$two_factor,
                                    parameter_names = names(SS_oil$two_factor),
                                    log_futures = log(SS_oil$stitched_futures),
                                    dt = SS_oil$dt,
                                    futures_TTM = SS_oil$stitched_TTM,
                                    verbose = TRUE)

## Step 2 - Probabilistic forecast of the risk-neutral two-factor
## stochastic differential equation (SDE):
futures_price_forecast(x_0 = SS_2F_filtered$x_t,
                      parameters = SS_oil$two_factor,
                      t = 0,
                      futures_TTM = seq(0,9,1/12),
                      percentiles = c(0.1, 0.9))
</code></pre>

<hr>
<h2 id='futures_price_simulate'>Simulate futures prices of an N-factor model through Monte Carlo simulation</h2><span id='topic+futures_price_simulate'></span>

<h3>Description</h3>

<p>Simulate Futures price data with dynamics that follow the parameters of an N-factor model through Monte Carlo simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futures_price_simulate(
  x_0,
  parameters,
  dt,
  N_obs,
  futures_TTM,
  ME_TTM = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="futures_price_simulate_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Discrete time step, in years, of the Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_n_obs">N_obs</code></td>
<td>
<p><code>numeric</code>. Number of discrete observations to simulate.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p><code>vector</code> or <code>matrix</code>.  The time-to-maturity of observed futures contracts, in years, at a given observation date. This time-to-maturity can either be constant (ie. class 'vector') or variable (ie. class 'matrix') across observations.
The number of rows of object 'futures_TTM' must be either 1 or equal to argument 'N_obs'. NA values are allowed.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_me_ttm">ME_TTM</code></td>
<td>
<p><code>vector</code>. the time-to-maturity groupings to consider for observed futures prices. The length of <code>ME_TTM</code> must be equal to the number of 'ME' parameters specified in object 'parameter_names'. The maximum of 'ME_TTM' must be greater than the maximum value of 'futures_TTM'.
When the number of 'ME' parameter values is equal to one or the number of columns of object 'log_futures', this argument is ignored.</p>
</td></tr>
<tr><td><code id="futures_price_simulate_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should simulated state variables be output?</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The <code>futures_price_simulate</code> function simulates futures price data using the Kalman filter algorithm, drawing from a normal
distribution for the shocks in the transition and measurement equations at each discrete time step. At each discrete time point,
an observation of the state vector is generated through the transition equation, drawing from a normal distribution with a covariance equal to \(Q_t\).
Following this, simulated futures prices are generated through the measurement equation, drawing from a normal distribution with covariance matrix equal to \(H\).
</p>
<p>Input <code>futures_TTM</code> can be either a matrix specifying the constant time to maturity of futures contracts to simulate, or it can be a matrix where <code>nrow(futures_TTM) == N_obs</code> for the time-varying time to maturity of the futures contracts to simulate. This allows for the simulation of both aggregate stitched data and individual futures contracts.
</p>


<h3>Value</h3>

<p><code>futures_price_simulate</code> returns a list with three objects when <code>verbose = T</code> and a matrix of simulated futures prices when <code>verbose = F</code>. The list objects returned are:
</p>
<p>#'</p>

<table>
<tr>
 <td style="text-align: left;">

<code>state_vector</code> </td><td style="text-align: left;">  A <code>matrix</code> of Simulated state variables at each discrete time point. The columns represent each factor of the N-factor model and the rows represent
the simulated values at each discrete simulated time point. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>futures_prices</code> </td><td style="text-align: left;">  A <code>matrix</code> of Simulated futures prices, with each column representing a simulated futures contract. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>spot_prices</code> </td><td style="text-align: left;"> A vector of simulated spot prices </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1 - Simulate Crude Oil with constant time-to-maturity:

simulated_futures &lt;- futures_price_simulate(x_0 = c(log(SS_oil$spot[1,1]), 0),
                                           parameters = SS_oil$two_factor,
                                           dt = SS_oil$dt,
                                           N_obs = nrow(SS_oil$stitched_futures),
                                           futures_TTM = SS_oil$stitched_TTM)

##Simulate Crude Oil Contracts with a rolling-window of measurement error:

simulated_futures_prices &lt;- futures_price_simulate(x_0 = c(log(SS_oil$spot[1,1]), 0),
                                                  parameters = SS_oil$two_factor,
                                                  dt = SS_oil$dt,
                                                  N_obs = nrow(SS_oil$contracts),
                                                  futures_TTM = SS_oil$contract_maturities,
                                                  ME_TTM = c(1/4, 1/2, 1, 2, 5))
</code></pre>

<hr>
<h2 id='NFCP_domains'>N-Factor MLE search boundaries</h2><span id='topic+NFCP_domains'></span>

<h3>Description</h3>

<p>Generate boundaries for the domain of parameters of the N-factor model for parameter estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NFCP_domains(
  parameters,
  kappa = NULL,
  lambda = NULL,
  sigma = NULL,
  mu = NULL,
  mu_rn = NULL,
  rho = NULL,
  season = NULL,
  ME = NULL,
  x_0 = NULL,
  E = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NFCP_domains_+3A_parameters">parameters</code></td>
<td>
<p>a vector of parameter names of an N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_kappa">kappa</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'kappa' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_lambda">lambda</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'lambda' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_sigma">sigma</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'sigma' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_mu">mu</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'mu' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_mu_rn">mu_rn</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'mu_rn' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_rho">rho</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'rho' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_season">season</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'season' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_me">ME</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'ME' (i.e., measurement error) parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_x_0">x_0</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'x_0' parameter</p>
</td></tr>
<tr><td><code id="NFCP_domains_+3A_e">E</code></td>
<td>
<p>A vector of length two specifying the lower and upper bounds for the 'E' parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>NFCP_domains</code> function generates lower and upper bounds for the parameter estimation procedure in the format required of the 'Domains' argument of the 'genoud' function. <code>NFCP_domains</code>
allows easy setting of custom boundaries for parameter estimation, whilst also providing default domains of parameters.
</p>


<h3>Value</h3>

<p>A matrix of defaulted domains for the given unknown parameters. The first column corresponds to the lower bound of the
allowable search space for the parameter, whilst the second column corresponds to the upper bound. These values were set to allow for the
'realistic' possible values of given parameters as well as restricting some parameters (such as variance and mean-reverting terms) from taking
negative values. The format of the returned matrix matches that required by the <code>Domains</code> argument of the <code>Genoud</code> function from the package <code>RGenoud</code>.
</p>


<h3>References</h3>

<p>Mebane, W. R., and J. S. Sekhon, (2011). Genetic Optimization Using Derivatives: The rgenoud Package for R.
<em>Journal of Statistical Software</em>, 42(11), 1-26. URL http://www.jstatsoft.org/v42/i11/.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Specify the Schwartz and Smith (2000) two-factor model
##with fixed measurement error:
parameters_2F &lt;- NFCP_parameters(N_factors = 2,
                                        GBM = TRUE,
                                        initial_states = TRUE,
                                        N_ME = 1)

###Generate the default 'domains' argument of 'NFCP_MLE' function:
NFCP_MLE_bounds &lt;- NFCP_domains(parameters_2F)

</code></pre>

<hr>
<h2 id='NFCP_Kalman_filter'>Filter an N-factor commodity pricing model though the Kalman filter</h2><span id='topic+NFCP_Kalman_filter'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given a set of parameters of the N-factor model, filter term structure data using the Kalman filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NFCP_Kalman_filter(
  parameter_values,
  parameter_names,
  log_futures,
  dt,
  futures_TTM,
  ME_TTM = NULL,
  verbose = FALSE,
  debugging = FALSE,
  seasonal_trend = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NFCP_Kalman_filter_+3A_parameter_values">parameter_values</code></td>
<td>
<p><code>vector</code>. Numeric parameter values of an N-factor model.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_parameter_names">parameter_names</code></td>
<td>
<p><code>vector</code>. Parameter names, where each element of <code>parameter_names</code> must correspond to its respective value
element in object <code>parameter_values</code>.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_log_futures">log_futures</code></td>
<td>
<p><code>matrix</code>. The natural logarithm of observed futures prices. Each row must correspond to quoted futures prices at a particular date and every column must correspond to a unique futures contract.
NA values are allowed.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Constant, discrete time step of observations, in years.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p><code>vector</code> or <code>matrix</code>.  The time-to-maturity of observed futures contracts, in years, at a given observation date. This time-to-maturity can either be constant (ie. class 'vector') or variable (ie. class 'matrix') across observations.
The number of columns of 'futures_TTM' must be identical to the number of columns of object 'log_futures'. The number of rows of object 'futures_TTM' must be either 1 or equal to the number of rows of object 'log_futures'.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_me_ttm">ME_TTM</code></td>
<td>
<p><code>vector</code>. the time-to-maturity groupings to consider for observed futures prices. The length of <code>ME_TTM</code> must be equal to the number of 'ME' parameters specified in object 'parameter_names'. The maximum of 'ME_TTM' must be greater than the maximum value of 'futures_TTM'.
When the number of 'ME' parameter values is equal to one or the number of columns of object 'log_futures', this argument is ignored.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should additional information be output? see <b>values</b>. When <code>verbose = F</code>, the <code>NFCP_Kalman_filter</code> function is significantly faster, see <b>details</b>.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_debugging">debugging</code></td>
<td>
<p><code>logical</code>. Should additional filtering information be output? see <b>values</b>.</p>
</td></tr>
<tr><td><code id="NFCP_Kalman_filter_+3A_seasonal_trend">seasonal_trend</code></td>
<td>
<p><code>numeric</code>. Optional parameter. This details the trend of the deterministic seasonal component (i.e., where in the season the first observation is located). When not listed, the Kalman filter assumes that observations are at the beginning of the seasonal component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NFCP_Kalman_filter</code> applies the Kalman filter algorithm for observable <code>log_futures</code> prices against the input parameters of an N-factor model
provided through the <code>parameter_values</code> and <code>parameter_names</code> input vectors.
</p>
<p>The <code>NFCP_Kalman_filter</code> function is
designed for subsequent input into optimization functions and is called within the N-factor parameter estimation function <code>NFCP_MLE</code>. The first input to the
<code>NFCP_Kalman_filter</code> function is a vector of parameters of an
N-factor model, with elements of this vector corresponding to the parameter names within the elements of input vector <code>parameter_names</code>.
When <code>logical</code> input <code>verbose = F</code>, the <code>NFCP_Kalman_filter</code> function calls the <code>fkf_SP</code> function of the <code>FKF_SP</code> package, which itself is a wrapper
of a routine of the Kalman filter written in C utilizing Sequential Processing for maximum computational efficiency (see <code>fkf_SP</code> for more details). When <code>verbose = T</code>,
the <code>NFCP_Kalman_filter</code> instead applies a Kalman filter algorithm written in base <code>R</code> and outputs several other <code>list objects</code>, including filtered values and
measures for model fit and robustness (see <b>Returns</b>)
</p>
<p><b>The N-factor model</b>
The N-factor framework was first presented in the work of Cortazar and Naranjo (2006, equations 1-3).
It is a risk-premium class of commodity pricing model, in which futures prices are given by discounted expected future spot prices,
where these spot prices are discounted at a given level of risk-premium, known as the cost-of-carry.
</p>
<p>The N-factor framework describes the spot price process of a commodity as the correlated sum of \(N\) state variables \(x_t\). The 'NFCP' package also allows for a deterministic,
cyclical seasonal function \(season(t)\) to be considered.
</p>
<p>When <code>GBM = TRUE</code>:
\[log(S_{t}) = season(t) + \sum_{i=1}^N x_{i,t}\]
When <code>GBM = FALSE</code>:
\[log(S_{t}) = E + season(t) + \sum_{i=1}^N x_{i,t}\]
</p>
<p>Where <code>GBM</code> determines whether the first factor follows a Brownian Motion or Ornstein-Uhlenbeck process to induce a unit root in the spot price process.
</p>
<p>When <code>GBM = TRUE</code>, the first factor corresponds to the spot price, and additional N-1 factors model the cost-of-carry.
</p>
<p>When <code>GBM = FALSE</code>, the commodity model assumes that there is a long-term equilibrium the commodity price will tend towards over time, with model volatility a decreasing function of time. This is not the standard approach made in the commodity pricing literature (Cortazar and Naranjo, 2006).
</p>
<p>State variables are thus assumed to follow the following processes:
</p>
<p>When <code>GBM = TRUE</code>:
\[dx_{1,t} = \mu^*dt + \sigma_{1} dw_{1}t\]
</p>
<p>When <code>GBM = FALSE</code>:
\[dx_{1,t} = - (\lambda_{1} + \kappa_{1}x_{1,t})dt + \sigma_{1} dw_{1}t\]
</p>
<p>And:
\[dx_{i,t} =_{i\neq1} - (\lambda_{i} + \kappa_{i}x_{i,t})dt + \sigma_{i} dw_{i}t\]
</p>
<p>where:
\[E(w_{i})E(w_{j}) = \rho_{i,j}\]
</p>
<p>Additionally, the deterministic seasonal function (if specified) is given by:
</p>
\[season(t) = \sum_{i=1} ( season_{i,1} cos(2i\pi) + season_{i,2} sin(2i\pi)\]
<p>The addition of deterministic, cyclical seasonality as a function of trigonometric variables was first suggested by Hannan, Terrell, and Tuckwell (1970) and first applied to model commodities by Sørensen (2002).
</p>
<p>The following constant parameters are defined as:
</p>
<p><code>var</code> \(\mu\):  long-term growth rate of the Brownian Motion process.
</p>
<p><code>var</code> \(E\): Constant equilibrium level.
</p>
<p><code>var</code> \(\mu^*=\mu-\lambda_1\): Long-term risk-neutral growth rate
</p>
<p><code>var</code> \(\lambda_{i}\): Risk premium of state variable \(i\).
</p>
<p><code>var</code> \(\kappa_{i}\): Reversion rate of state variable \(i\).
</p>
<p><code>var</code> \(\sigma_{i}\): Instantaneous volatility of state variable \(i\).
</p>
<p><code>var</code> \(\rho_{i,j} \in [-1,1]\): Instantaneous correlation between state variables \(i\) and \(j\).
</p>
<p>Including additional factors within the spot-price process allow for additional flexibility (and possibly fit) to the term structure of a commodity.
The N-factor model nests simpler models within its framework, allowing for the fit of different N-factor models (applied to the same term structure data),
represented by the log-likelihood, to be directly compared with statistical testing possible through a chi-squared test.
</p>
<p><b>Disturbances - Measurement Error</b>:
</p>
<p>The Kalman filtering algorithm assumes a given measure of measurement error or disturbance in the measurement equation (ie. matrix \(H\)). Measurement errors can be interpreted as error in the
model's fit to observed prices, or as errors in the reporting of prices (Schwartz and Smith, 2000). These disturbances are typically assumed independent.
</p>
<p><code>var</code> \(ME_i\) measurement error of contract \(i\).
</p>
<p>where the measurement error of futures contracts \(ME_i\) is equal to <code>'ME_'</code> [i] (i.e. <code>'ME_1'</code>, <code>'ME_2'</code>, ...) specified in arguments <code>parameter_values</code> and <code>parameter_names</code>.
</p>
<p>There are three particular cases on how the measurement error of observations can be treated in the <code>NFCP_Kalman_filter</code> function:
</p>
<p><b>Case 1:</b> Only one ME is specified. The Kalman filter assumes that the measurement error of observations are independent and identical.
</p>
<p><b>Case 2:</b> One ME is specified for every observed futures contract. The Kalman filter assumes that the measurement error of observations are independent and unique.
</p>
<p><b>Case 3:</b> A series of ME's are specified for a given grouping of maturities of futures contracts. The Kalman filter assumes that the measurement error of observations are independent and unique to their respective time-to-maturity.
</p>
<p>Grouping of maturities for case 3 is specified through the <code>ME_TTM</code> argument. This is a vector that specifies the maximum maturity to consider for each respective ME parameter argument.
</p>
<p>in other words, ME_1 is considered for observations with TTM less than ME_TTM[1], ME_2 is considered for observations with TTM less than ME_TTM[2], ..., etc.
</p>
<p>The first case is clearly the simplest to estimate, but can be a restrictive assumption. The second case is clearly the most difficult to estimate, but can be an infeasible assumption when considering all available futures contracts that make up the term structure of a commodity.
</p>
<p>Case 3 thus serves to ease the restriction of case 1, and allow the user to make the modeling of measurement error as simple or complex as desired for a given set of maturities.
</p>
<p><b>Kalman Filtering</b>
</p>
<p>The following section describes the Kalman filter equations used to filter the N-factor model.
</p>
<p>The Kalman filter iteration is characterised by a transition and measurement equation.
The transition equation develops the vector of state variables between discretised time steps (whilst considering a given level of covariance between state variables over time).
The measurement equation relates the unobservable state vector to a vector of observable measurements (whilst also considering a
given level of measurement error). The typical Kalman filter algorithm is a Gaussian process state space model.
</p>
<p>Transition Equation:
\[\hat x_{t|t-1} = c_t + G_t \hat x_{t-1} + Q_t \eta_t \]
Measurement Equation:
\[\hat y_t = d_t + Z_t \hat x_{t|t-1} + H_t \epsilon_t\]
</p>
\[t = 1, \cdots, n \]
<p>Where \(\eta_t\) and \(\epsilon_t\) are IID \(N(0,I(m))\) and iid \(N(0,I(d))\) respectively.
</p>
<p>The state vector follows a normal distribution, \(x_1 \sim N(a_1, P_1)\), with \(a_1\) and \(P_1\) as the mean vector and variance matrix of
the initial state vector \(x_1\), respectively.
</p>
<p>The Kalman filter can be used for parameter estimation through the maximization of the Log-Likelihood value. See <code>NFCP_MLE</code>.
</p>
<p><b>Filtering the N-factor model</b>
</p>
<p>let \(m\) represent the number of observations at time \(t\)
</p>
<p>let \(n\) represent the number of factors in the N-factor model
</p>
<p>observable futures prices: \(y_t = [ln(F(t,T_1)), ln(F(t,T_2)), \cdots, ln(F(t,T_m))]'\)
</p>
<p>State vector: \(x_t=[x_1t,x_2t,\cdots,x_nt ]'\)
</p>
<p>Measurement error: \(diag(H) = [ME_{1}^2, ME_{2}^2, \cdots, ME_{n}^2]\)
</p>
<p>When the number of specified ME terms is one, \(s_1 = s_2 = \cdots = s_n = \) \(ME_1^2\)
</p>
<p><code>var</code> \(Z\) is an \(m \times n\) matrix, where each element \([i,j]\) is equal to:
</p>
\[Z_{i,j} = e^{-\kappa_i T_j}\]
<p><code>var</code> \(d_t\) is an \(m \times 1\) vector:
</p>
\[d_t=[season(T_1) + A(T_1), season(T_2) + A(T_2), \cdots, season(T_m) + A(T_m)]'\]
<p>Under the assumption that Factor 1 follows a Brownian Motion, <i>A(T)</i> is given by:
\[A(T) = \mu^*T-\sum_{i=1}^N - \frac{1-e^{-\kappa_i T}\lambda_i}{\kappa_i}+\frac{1}{2}(\sigma_1^2T +
\sum_{i.j\neq 1} \sigma_i \sigma_j \rho_{i,j} \frac{1-e^{-(\kappa_i+\kappa_j)T}}{\kappa_i+\kappa_j})\]
</p>
<p><code>var</code> \(v_t\) is a \(n \times 1\) vector of serially uncorrelated Guassian disturbances with
\(E(V_t) = 0\)  and \(cov(v_t)=R^2\)
</p>
<p>Where:
</p>
<p>\(diag(G_t) = [e^{-\kappa_1 \tau}, e^{-\kappa_2 \tau}, \cdots, e^{-\kappa_n \tau}]\)
</p>
<p>Where \( \tau =T-t\)
</p>
<p><code>var</code> \(w_t\) is an \(n \times 1\) vector of serially uncorrelated Guassian disturbances where:
\[E(w_t) = 0\] and \(cov(w_t) = Q_t\)
</p>
<p><code>var</code> \(c_t=[\mu \Delta t,0,\cdots,0]'\) is an \(N \times 1\) vector of the intercept of the transition equation.
</p>
<p><code>var</code> \(Q_t\) is equal to the covariance function, given by:
</p>
\[Cov_{1,1}(x_{1,t},x_{1,t}) = \sigma_1^2t\]
\[Cov_{i,j}(x_{i,t},x_{j,t}) = \sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j}\]
<p>(see also <code>cov_func</code>)
</p>
<p><b>Penalising poorly specified models</b>
</p>
<p>The Kalman filter returns non-real log-likelihood scores when the prediction error variance matrix becomes singular or its determinant becomes negative. This generally occurs when a poorly specified parameter set is input, such as when measurement error is zero.
Non-real log-likelihood scores can break optimization and gradients algorithms and functions. To circumvent this, the <code>NFCP_Kalman_filter</code>
returns a heavily penalized log-likelihood score when <code>verbose = F</code>. Penalized log-likelihood scores are calculated by:
</p>
<p><code>stats::runif(1, -2e6, -1e6)</code>
</p>
<p><b>Diffuse Kalman filtering</b>
</p>
<p>If the initial values of the state vector are not supplied within the <code>parameter_names</code> and <code>parameter_values</code> vectors, a 'diffuse' assumption is used within the Kalman filtering algorithm.
Initial states of factors that follow an Ornstein-Uhlenbeck are assumed to equal zero.
The initial state of the first factor, given that it follows a Brownian motion, is assumed equal to the first element of <code>log_futures</code>. This is an
assumption that the initial estimate of the spot price is equal to the closest to maturity observed futures price.
</p>
<p>The initial states of factors that follow an Ornstein-Uhlenbeck have a transient effect on future observations. This makes the diffuse assumption reasonable and further means that initial states cannot generally be accurately estimated.
</p>


<h3>Value</h3>

<p><code>NFCP_Kalman_filter</code> returns a <code>numeric</code> object when <code>verbose = F</code>, which corresponds to the log-likelihood of observations.
When <code>verbose = T</code>, the <code>NFCP_Kalman_filter</code> function returns a <code>list</code> object of length seven with the following objects:
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>Log-Likelihood</code> </td><td style="text-align: left;"> Log-Likelihood of observations. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Information Criteria</code> </td><td style="text-align: left;"> <code>vector</code>. The Akaikie and Bayesian Information Criterion. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>X_t</code> </td><td style="text-align: left;"> <code>vector</code>. The final observation of the state vector. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>X</code> </td><td style="text-align: left;"> <code>matrix</code>. Optimal one-step-ahead state vector. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Y</code> </td><td style="text-align: left;"> <code>matrix</code>. Estimated futures prices. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>V</code> </td><td style="text-align: left;"> <code>matrix</code>. Estimation error. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Filtered Error</code> </td><td style="text-align: left;"> <code>matrix</code>. positive mean error (high bias), negative mean error (low bias),

mean error (bias) and root mean squared error (RMSE)

of the filtered values to observed futures prices.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Term Structure Fit</code> </td><td style="text-align: left;"> <code>matrix</code>. The mean error (Bias), mean absolute error, standard deviation of error

 and root mean squared error (RMSE) of each observed futures contract. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Term Structure Volatility Fit</code> </td><td style="text-align: left;"> <code>matrix</code>. Theoretical and empirical volatility of observed futures contract returns. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>debugging = T</code>, 9 objects are returned in addition to those returned when <code>verbose = T</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>P_t</code> </td><td style="text-align: left;"> <code>array</code>. Covariance matrix of state variables, with the third dimension indexing across time </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>F_t</code> </td><td style="text-align: left;"> <code>vector</code>. Prediction error variance matrix, with the third dimension indexing across time </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>K_t</code> </td><td style="text-align: left;"> <code>matrix</code>. Kalman Gain, with the third dimension indexing across time </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>d</code> </td><td style="text-align: left;"> <code>matrix</code>.  \(d_t\) (see <b>details</b>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Z</code> </td><td style="text-align: left;"> <code>matrix</code>.  \(Z_t\) (see <b>details</b>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>G_t</code> </td><td style="text-align: left;"> <code>matrix</code>.  \(G_t\) (see <b>details</b>)  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>c_t</code> </td><td style="text-align: left;"> <code>vector</code>.  \(C_t\) (see <b>details</b>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Q_t</code> </td><td style="text-align: left;"> <code>matrix</code>. \(Q_t\)  (see <b>details</b>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>H</code> </td><td style="text-align: left;"> <code>matrix</code>. \(H\)  (see <b>details</b>) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Hannan, E. J., et al. (1970). &quot;The seasonal adjustment of economic time series.&quot; <em>International economic review</em>, 11(1): 24-52.
</p>
<p>Anderson, B. D. O. and J. B. Moore, (1979). <em>Optimal filtering</em> Englewood Cliffs: Prentice-Hall.
</p>
<p>Fahrmeir, L. and G. tutz,(1994) <em>Multivariate Statistical Modelling Based on Generalized Linear Models.</em> Berlin: Springer.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Sørensen, C. (2002). &quot;Modeling seasonality in agricultural commodity futures.&quot; <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em> 22(5): 393-426.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>
<p>Durbin, J., and S. J. Koopman, (2012). <em>Time series analysis by state space methods.</em> Oxford university press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##Example 1 - complete, stitched data.
##Replicating the Schwartz and Smith (2000)
##Two-Factor commodity pricing model applied to crude oil:

SS_stitched_filtered &lt;- NFCP_Kalman_filter(
parameter_values = SS_oil$two_factor,
parameter_names = names(SS_oil$two_factor),
log_futures = log(SS_oil$stitched_futures),
futures_TTM = SS_oil$stitched_TTM,
## maturity groupings need not be considered here:
ME_TTM = NULL,
dt = SS_oil$dt,
verbose = FALSE)


##Example 2 - incomplete, contract data.
##Replicating the Schwartz and Smith (2000)
##Two-Factor commodity pricing model applied to all available
##crude oil contracts:

SS_2F &lt;- SS_oil$two_factor
##omit stitched contract white noise
SS_2F &lt;- SS_2F[!grepl("ME",
             names(SS_2F))]

# Evaluate two different measurement errors
SS_2F[c("ME_1", "ME_2")] &lt;- c(0.01, 0.04)

## Separate measurement error into two different maturity groupings
SS_ME_TTM &lt;- c(1,3)
## ME_1 is applied for observed contracts with less than one year
## maturity, whilst ME_2 considers contracts with maturity greater
## than one year, and less than three years

#Kalman filter
SS_contract_filtered &lt;- NFCP_Kalman_filter(
parameter_values = SS_2F,
parameter_names = names(SS_2F),
## All available contracts are considered
log_futures = log(SS_oil$contracts),
## Respective 'futures_TTM' of these contracts are input:
futures_TTM = SS_oil$contract_maturities,
ME_TTM = SS_ME_TTM,
dt = SS_oil$dt,
verbose = FALSE)
</code></pre>

<hr>
<h2 id='NFCP_MLE'>N-factor model parameter estimation through the Kalman filter and maximum likelihood estimation</h2><span id='topic+NFCP_MLE'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The <code>NFCP_MLE</code> function performs parameter estimation of commodity pricing models under the N-factor framework of Cortazar and Naranjo (2006). It uses term structure futures data and estimates unknown parameters through maximum likelihood estimation.
<code>NFCP_MLE</code> allows for missing observations, a variable number of state variables, deterministic seasonality and a variable number of measurement error terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NFCP_MLE(
  log_futures,
  dt,
  futures_TTM,
  N_factors,
  N_season = 0,
  N_ME = 1,
  ME_TTM = NULL,
  GBM = TRUE,
  estimate_initial_state = FALSE,
  Domains = NULL,
  cluster = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NFCP_MLE_+3A_log_futures">log_futures</code></td>
<td>
<p><code>matrix</code>. The natural logarithm of observed futures prices. Each row must correspond to quoted futures prices at a particular date and every column must correspond to a unique futures contract.
NA values are allowed.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Constant, discrete time step of observations, in years.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p><code>vector</code> or <code>matrix</code>.  The time-to-maturity of observed futures contracts, in years, at a given observation date. This time-to-maturity can either be constant (ie. class 'vector') or variable (ie. class 'matrix') across observations.
The number of columns of 'futures_TTM' must be identical to the number of columns of object 'log_futures'. The number of rows of object 'futures_TTM' must be either 1 or equal to the number of rows of object 'log_futures'.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_n_factors">N_factors</code></td>
<td>
<p><code>numeric</code>. Number of state variables in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_n_season">N_season</code></td>
<td>
<p><code>numeric</code>. The number of deterministic, cyclical seasonal factors to include in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_n_me">N_ME</code></td>
<td>
<p><code>numeric</code>. The number of independent measuring errors of observable futures contracts to consider in the Kalman filter.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_me_ttm">ME_TTM</code></td>
<td>
<p><code>vector</code>. the time-to-maturity groupings to consider for observed futures prices. The length of <code>ME_TTM</code> must be equal to the number of 'ME' parameters specified in object 'parameter_names'. The maximum of 'ME_TTM' must be greater than the maximum value of 'futures_TTM'.
When the number of 'ME' parameter values is equal to one or the number of columns of object 'log_futures', this argument is ignored.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_gbm">GBM</code></td>
<td>
<p><code>logical</code>. When <code>TRUE</code>, factor 1 of the model is assumed to follow a Brownian Motion, inducing a unit-root in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_estimate_initial_state">estimate_initial_state</code></td>
<td>
<p><code>logical</code>. Should the initial state vector be specified as unknown parameters of the commodity pricing model? These are generally estimated with low precision (see <b>details</b>).</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_domains">Domains</code></td>
<td>
<p><code>matrix</code>. An option matrix of two columns specifying the lower and upper bounds for parameter estimation. The 'NFCP_domains' function is recommended. When not specified, the default parameter bounds returned by the 'NFCP_domains' function are used.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_cluster">cluster</code></td>
<td>
<p><code>cluster</code>.    An optional object returned by one of the makeCluster commands in the <code>parallel</code> package to allow for parameter estimation
to be performed across multiple cluster nodes.</p>
</td></tr>
<tr><td><code id="NFCP_MLE_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed into the <code>genoud</code> genetic algorithm numeric optimization. These can highly influence the maximum likelihood estimation procedure. See <code>help(genoud)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>NFCP_MLE</code> function facilitates parameter estimation of commodity pricing models under the N-factor framework through the Kalman filter and maximum likelihood estimation. <code>NFCP_MLE</code>
uses genetic algorithms through the <code>genoud</code> function of the <code>rgenoud</code> package to numerically optimize the log-likelihood score returned from the <code>NFCP_Kalman_filter</code> function.
</p>
<p>Parameter estimation of commodity pricing models can involve a large number of observations, state variables and unknown parameters. It also features an objective log-likelihood function that is nonlinear and
discontinuous with respect to model parameters. <code>NFCP_MLE</code> is designed to perform parameter estimation as efficiently as possible, maximizing the likelihood of attaining a global optimum.
</p>
<p>Arguments passed to the <code>genoud</code> function can greatly influence estimated parameters as well as computation time and must be considered when performing parameter estimation. All arguments of the <code>genoud</code> function
may be passed through the <code>NFCP_MLE</code> function.
</p>
<p>When <code>grad</code> is not specified, the <code>grad</code> function from the <code>numDeriv</code> package is called to
approximate the gradient within the <code>genoud</code> optimization algorithm through Richardsons extrapolation.
</p>
<p>Richardsons extrapolation is regarded for its ability to improve the approximation of estimation methods,
which may improve the likelihood of obtained a global maxmimum estimate of the log-likelihood.
</p>
<p>The population size can highly influence parameter estimates at the expense of increased computation time. For commodity pricing models with a large number of unknown parameters, large population sizes may be necessary to maximize the estimation process.
</p>
<p><code>NFCP_MLE</code> by default performs boundary constrained optimization of log-likelihood scores and does not allow does not allow for out-of-bounds evaluations within
the <code>genoud</code> optimization process, preventing candidates from straying beyond the bounds provided by argument <code>Domains</code>.
</p>
<p>When <code>Domains</code> is not specified, the default bounds specified by the <code>NFCP_domains</code> function are used. The size of the search domains of unknown parameters can highly
influence the computation time of the <code>NFCP_MLE</code> function, however setting domains that are too restrictive may result in estimated parameters returned at the upper or lower bounds. Custom search domains can be used
through the <code>NFCP_domains</code> function and subsequently the <code>Domains</code> argument of this function.
</p>
<p>Finally, the maximum likelihood estimation process of parameters provides no in-built guarantee that the estimated parameters of commodity models are financially sensible results. When the commodity model has been over-parameterized
(i.e., the number of factors N specified is too high) or the optimization algorithm has failed to attain a global maximum likelihood estimate, estimated parameters may be irrational.
</p>
<p>Evidence of irrational parameter estimates include correlation coefficients that are extremely large (e.g., &gt; 0.95 or &lt; -0.95), risk-premiums or drift terms that are unrealistic, filtered state variables that are unrealistic and extremely large/small mean-reverting terms with associated large standard errors.
</p>
<p>Irrational parameter estimates may indicate that the number of stochastic factors (i.e., <code>N_factors</code>) of the model or number of seasonal factors (i.e., <code>N_season</code>) are too high.
</p>
<p><b>The N-factor model</b>
The N-factor framework was first presented in the work of Cortazar and Naranjo (2006, equations 1-3).
It is a risk-premium class of commodity pricing model, in which futures prices are given by discounted expected future spot prices,
where these spot prices are discounted at a given level of risk-premium, known as the cost-of-carry.
</p>
<p>The N-factor framework describes the spot price process of a commodity as the correlated sum of \(N\) state variables \(x_t\). The 'NFCP' package also allows for a deterministic,
cyclical seasonal function \(season(t)\) to be considered.
</p>
<p>When <code>GBM = TRUE</code>:
\[log(S_{t}) = season(t) + \sum_{i=1}^N x_{i,t}\]
When <code>GBM = FALSE</code>:
\[log(S_{t}) = E + season(t) + \sum_{i=1}^N x_{i,t}\]
</p>
<p>Where <code>GBM</code> determines whether the first factor follows a Brownian Motion or Ornstein-Uhlenbeck process to induce a unit root in the spot price process.
</p>
<p>When <code>GBM = TRUE</code>, the first factor corresponds to the spot price, and additional N-1 factors model the cost-of-carry.
</p>
<p>When <code>GBM = FALSE</code>, the commodity model assumes that there is a long-term equilibrium the commodity price will tend towards over time, with model volatility a decreasing function of time. This is not the standard approach made in the commodity pricing literature (Cortazar and Naranjo, 2006).
</p>
<p>State variables are thus assumed to follow the following processes:
</p>
<p>When <code>GBM = TRUE</code>:
\[dx_{1,t} = \mu^*dt + \sigma_{1} dw_{1}t\]
</p>
<p>When <code>GBM = FALSE</code>:
\[dx_{1,t} = - (\lambda_{1} + \kappa_{1}x_{1,t})dt + \sigma_{1} dw_{1}t\]
</p>
<p>And:
\[dx_{i,t} =_{i\neq 1} - (\lambda_{i} + \kappa_{i}x_{i,t})dt + \sigma_{i} dw_{i}t\]
</p>
<p>where:
\[E(w_{i})E(w_{j}) = \rho_{i,j}\]
</p>
<p>Additionally, the deterministic seasonal function (if specified) is given by:
</p>
\[season(t) = \sum_{i=1} ( season_{i,1} cos(2i\pi) + season_{i,2} sin(2i\pi)\]
<p>The addition of deterministic, cyclical seasonality as a function of trigonometric variables was first suggested by Hannan, Terrell, and Tuckwell (1970) and first applied to model commodities by Sørensen (2002).
</p>
<p>The following constant parameters are defined as:
</p>
<p><code>var</code> \(\mu\):  long-term growth rate of the Brownian Motion process.
</p>
<p><code>var</code> \(E\): Constant equilibrium level.
</p>
<p><code>var</code> \(\mu^*=\mu-\lambda_1\): Long-term risk-neutral growth rate
</p>
<p><code>var</code> \(\lambda_{i}\): Risk premium of state variable \(i\).
</p>
<p><code>var</code> \(\kappa_{i}\): Reversion rate of state variable \(i\).
</p>
<p><code>var</code> \(\sigma_{i}\): Instantaneous volatility of state variable \(i\).
</p>
<p><code>var</code> \(\rho_{i,j} \in [-1,1]\): Instantaneous correlation between state variables \(i\) and \(j\).
</p>
<p>Including additional factors within the spot-price process allow for additional flexibility (and possibly fit) to the term structure of a commodity.
The N-factor model nests simpler models within its framework, allowing for the fit of different N-factor models (applied to the same term structure data),
represented by the log-likelihood, to be directly compared with statistical testing possible through a chi-squared test. The AIC or BIC can also be used to compare models.
</p>
<p><b>Disturbances - Measurement Error</b>:
</p>
<p>The Kalman filtering algorithm assumes a given measure of measurement error or disturbance in the measurement equation (ie. matrix \(H\)). Measurement errors can be interpreted as error in the
model's fit to observed prices, or as errors in the reporting of prices (Schwartz and Smith, 2000). These disturbances are typically assumed independent.
</p>
<p><code>var</code> \(ME_i\) measurement error of contract \(i\).
</p>
<p>where the measurement error of futures contracts \(ME_i\) is equal to <code>'ME_'</code> [i] (i.e. <code>'ME_1'</code>, <code>'ME_2'</code>, ...) specified in arguments <code>parameter_values</code> and <code>parameter_names</code>.
</p>
<p>There are three particular cases on how the measurement error of observations can be treated in the <code>NFCP_Kalman_filter</code> function:
</p>
<p><b>Case 1:</b> Only one ME is specified. The Kalman filter assumes that the measurement error of observations are independent and identical.
</p>
<p><b>Case 2:</b> One ME is specified for every observed futures contract. The Kalman filter assumes that the measurement error of observations are independent and unique.
</p>
<p><b>Case 3:</b> A series of ME's are specified for a given grouping of maturities of futures contracts. The Kalman filter assumes that the measurement error of observations are independent and unique to their respective time-to-maturity.
</p>
<p>Grouping of maturities for case 3 is specified through the <code>ME_TTM</code> argument. This is a vector that specifies the maximum maturity to consider for each respective ME parameter argument.
</p>
<p>in other words, ME_1 is considered for observations with TTM less than ME_TTM[1], ME_2 is considered for observations with TTM less than ME_TTM[2], ..., etc.
</p>
<p>The first case is clearly the simplest to estimate, but can be a restrictive assumption. The second case is clearly the most difficult to estimate, but can be an infeasible assumption when considering all available futures contracts that make up the term structure of a commodity.
</p>
<p>Case 3 thus serves to ease the restriction of case 1, and allow the user to make the modeling of measurement error as simple or complex as desired for a given set of maturities.
</p>
<p><b>Diffuse Kalman filtering</b>
</p>
<p>If the initial values of the state vector are not supplied within the <code>parameter_names</code> and <code>parameter_values</code> vectors, a 'diffuse' assumption is used within the Kalman filtering algorithm.
Initial states of factors that follow an Ornstein-Uhlenbeck are assumed to equal zero.
The initial state of the first factor, given that it follows a Brownian motion, is assumed equal to the first element of <code>log_futures</code>. This is an
assumption that the initial estimate of the spot price is equal to the closest to maturity observed futures price.
</p>
<p>The initial states of factors that follow an Ornstein-Uhlenbeck have a transient effect on future observations. This makes the diffuse assumption reasonable and further means that initial states cannot generally be accurately estimated.
</p>


<h3>Value</h3>

<p><code>NFCP_MLE</code> returns a <code>list</code> with 10 objects. 9 objects are returned when the user has specified not to calculate the hessian matrix at solution.
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>MLE</code> </td><td style="text-align: left;"> <code>numeric</code> The Maximum-Likelihood-Estimate of the solution. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>estimated_parameters</code> </td><td style="text-align: left;"> <code>vector</code>. Estimated parameters. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>standard_errors</code> </td><td style="text-align: left;"> <code>vector</code>. Standard error of the estimated parameters. Returned only when <code>hessian = T</code> is specified.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Information Criteria</code> </td><td style="text-align: left;"> <code>vector</code>. The Akaikie and Bayesian Information Criterion. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>x_t</code> </td><td style="text-align: left;"> <code>vector</code>. The final observation of the state vector.

When deterministic seasonality is considered, it also returns the observation point

along the deterministic curve. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>X</code> </td><td style="text-align: left;"> <code>matrix</code>. Optimal one-step-ahead state vector.

When deterministic seasonality is considered, it also returns the observation point

along the deterministic curve. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Y</code> </td><td style="text-align: left;"> <code>matrix</code>. Estimated futures prices. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>V</code> </td><td style="text-align: left;"> <code>matrix</code>. Estimation error. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Filtered Error</code> </td><td style="text-align: left;"> <code>matrix</code>. positive mean error (high bias), negative mean error (low bias),

mean error (bias) and root mean squared error (RMSE)

of the filtered values to observed futures prices.  </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Term Structure Fit</code> </td><td style="text-align: left;"> <code>matrix</code>. The mean error (Bias), mean absolute error, standard deviation of error

 and root mean squared error (RMSE) of each observed futures contract. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Term Structure Volatility Fit</code> </td><td style="text-align: left;"> <code>matrix</code>. Theoretical and empirical volatility of observed futures contract returns </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>proc_time</code> </td><td style="text-align: left;"> <code>list</code>. The real and CPU time (in seconds) the <code>NFCP_MLE</code> function has taken. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>genoud_value</code> </td><td style="text-align: left;"> <code>list</code>. Outputs of <code>genoud</code>.

</td>
</tr>

</table>



<h3>References</h3>

<p>Hannan, E. J., et al. (1970). &quot;The seasonal adjustment of economic time series.&quot; <em>International economic review</em>, 11(1): 24-52.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Sørensen, C. (2002). &quot;Modeling seasonality in agricultural commodity futures.&quot; <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em> 22(5): 393-426.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>
<p>Mebane, W. R., and J. S. Sekhon, (2011). Genetic Optimization Using Derivatives: The rgenoud Package for R.
<em>Journal of Statistical Software</em>, 42(11), 1-26. URL http://www.jstatsoft.org/v42/i11/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate a 'one-factor' geometric Brownian motion model:
Oil_1F_estimated_model &lt;- NFCP_MLE(
## Arguments
log_futures = log(SS_oil$contracts)[1:20,1:5],
dt = SS_oil$dt,
futures_TTM= SS_oil$contract_maturities[1:20,1:5],
N_factors = 1, N_ME = 1,
## Genoud arguments:
pop.size = 4, print.level = 0, gr = NULL,
max.generations = 0)
</code></pre>

<hr>
<h2 id='NFCP_parameters'>Specify the constant parameters of an N-factor model</h2><span id='topic+NFCP_parameters'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>the <code>NFCP_parameters</code> function specifies the parameters of
a commodity pricing model under the N-factor framework first described by Cortazar and Naranjo (2006).
This function is a recommended starting position for the application of N-factor models within the <code>NFCP</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NFCP_parameters(
  N_factors,
  GBM,
  initial_states,
  N_ME,
  N_season = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NFCP_parameters_+3A_n_factors">N_factors</code></td>
<td>
<p><code>numeric</code>. Number of state variables in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_parameters_+3A_gbm">GBM</code></td>
<td>
<p><code>logical</code>. If <code>GBM = T</code>, factor 1 of the model is assumed to follow a Brownian Motion, inducing a unit-root in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_parameters_+3A_initial_states">initial_states</code></td>
<td>
<p><code>logical</code>. If <code>initial_states = T</code>, the initial state vector is specified as unknown parameters of the commodity pricing model.</p>
</td></tr>
<tr><td><code id="NFCP_parameters_+3A_n_me">N_ME</code></td>
<td>
<p><code>numeric</code>. The number of independent measuring errors of observable futures contracts to consider in the Kalman filter.</p>
</td></tr>
<tr><td><code id="NFCP_parameters_+3A_n_season">N_season</code></td>
<td>
<p><code>numeric</code>. The number of deterministic, cyclical seasonal factors to include in the spot price process.</p>
</td></tr>
<tr><td><code id="NFCP_parameters_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. If <code>verbose = T</code>, the stochastic differential equation of the spot price process is printed when the function is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The N-factor model</b>
The N-factor framework was first presented in the work of Cortazar and Naranjo (2006, equations 1-3).
It is a risk-premium class of commodity pricing model, in which futures prices are given by discounted expected future spot prices,
where these spot prices are discounted at a given level of risk-premium, known as the cost-of-carry.
</p>
<p>The N-factor framework describes the spot price process of a commodity as the correlated sum of \(N\) state variables \(x_t\). The 'NFCP' package also allows for a deterministic,
cyclical seasonal function \(season(t)\) to be considered.
</p>
<p>When <code>GBM = TRUE</code>:
\[log(S_{t}) = season(t) + \sum_{i=1}^N x_{i,t}\]
When <code>GBM = FALSE</code>:
\[log(S_{t}) = E + season(t) + \sum_{i=1}^N x_{i,t}\]
</p>
<p>Where <code>GBM</code> determines whether the first factor follows a Brownian Motion or Ornstein-Uhlenbeck process to induce a unit root in the spot price process.
</p>
<p>When <code>GBM = TRUE</code>, the first factor corresponds to the spot price, and additional N-1 factors model the cost-of-carry.
</p>
<p>When <code>GBM = FALSE</code>, the commodity model assumes that there is a long-term equilibrium the commodity price will tend towards over time, with model volatility a decreasing function of time. This is not the standard approach made in the commodity pricing literature (Cortazar and Naranjo, 2006).
</p>
<p>State variables are thus assumed to follow the following processes:
</p>
<p>When <code>GBM = TRUE</code>:
\[dx_{1,t} = \mu^*dt + \sigma_{1} dw_{1}t\]
</p>
<p>When <code>GBM = FALSE</code>:
\[dx_{1,t} = - (\lambda_{1} + \kappa_{1}x_{1,t})dt + \sigma_{1} dw_{1}t\]
</p>
<p>And:
\[dx_{i,t} =_{i\neq 1} - (\lambda_{i} + \kappa_{i}x_{i,t})dt + \sigma_{i} dw_{i}t\]
</p>
<p>where:
\[E(w_{i})E(w_{j}) = \rho_{i,j}\]
</p>
<p>Additionally, the deterministic seasonal function (if specified) is given by:
</p>
\[season(t) = \sum_{i=1} ( season_{i,1} cos(2i\pi) + season_{i,2} sin(2i\pi)\]
<p>The addition of deterministic, cyclical seasonality as a function of trigonometric variables was first suggested by Hannan, Terrell, and Tuckwell (1970) and first applied to model commodities by Sørensen (2002).
</p>
<p>The following constant parameters are defined as:
</p>
<p><code>var</code> \(\mu\):  long-term growth rate of the Brownian Motion process.
</p>
<p><code>var</code> \(E\): Constant equilibrium level.
</p>
<p><code>var</code> \(\mu^*=\mu-\lambda_1\): Long-term risk-neutral growth rate
</p>
<p><code>var</code> \(\lambda_{i}\): Risk premium of state variable \(i\).
</p>
<p><code>var</code> \(\kappa_{i}\): Reversion rate of state variable \(i\).
</p>
<p><code>var</code> \(\sigma_{i}\): Instantaneous volatility of state variable \(i\).
</p>
<p><code>var</code> \(\rho_{i,j} \in [-1,1]\): Instantaneous correlation between state variables \(i\) and \(j\).
</p>
<p>Including additional factors within the spot-price process allow for additional flexibility (and possibly fit) to the term structure of a commodity.
The N-factor model nests simpler models within its framework, allowing for the fit of different N-factor models (applied to the same term structure data),
represented by the log-likelihood, to be directly compared with statistical testing possible through a chi-squared test.
</p>
<p><b>Disturbances - Measurement Error</b>:
</p>
<p>The Kalman filtering algorithm assumes a given measure of measurement error or disturbance in the measurement equation (ie. matrix \(H\)). Measurement errors can be interpreted as error in the
model's fit to observed prices, or as errors in the reporting of prices (Schwartz and Smith, 2000). These disturbances are typically assumed independent by the commodity pricing literature.
</p>
<p><code>var</code> \(ME_i\) measurement error of contract \(i\).
</p>
<p>where the measurement error of futures contracts \(ME_i\) is equal to <code>'ME_'</code> [i] (i.e. <code>'ME_1'</code>, <code>'ME_2'</code>, ...) specified in arguments <code>parameter_values</code> and <code>parameter_names</code>.
</p>
<p>There are three particular cases on how the measurement error of observations can be treated in the <code>NFCP_Kalman_filter</code> function:
</p>
<p><b>Case 1:</b> Only one ME is specified. The Kalman filter assumes that the measurement error of observations are independent and identical.
</p>
<p><b>Case 2:</b> One ME is specified for every observed futures contract. The Kalman filter assumes that the measurement error of observations are independent and unique.
</p>
<p><b>Case 3:</b> A series of ME's are specified for a given grouping of maturities of futures contracts. The Kalman filter assumes that the measurement error of observations are independent and unique to their respective time-to-maturity.
</p>
<p>Grouping of maturities for case 3 is specified through the <code>ME_TTM</code> argument. This is a vector that specifies the maximum maturity to consider for each respective ME parameter argument.
</p>
<p>in other words, ME_1 is considered for observations with TTM less than ME_TTM[1], ME_2 is considered for observations with TTM less than ME_TTM[2], ..., etc.
</p>
<p>The first case is clearly the simplest to estimate, but can be a restrictive assumption. The second case is clearly the most difficult to estimate, but can be an infeasible assumption when considering all available futures contracts that make up the term structure of a commodity.
</p>
<p>Case 3 thus serves to ease the restriction of case 1, and allow the user to make the modeling of measurement error as simple or complex as desired for a given set of maturities.
</p>


<h3>Value</h3>

<p>A vector of parameter names for a specified N-factor spot price process. This vector is ideal for application within many other functions within the <code>NFCP</code> package
</p>


<h3>References</h3>

<p>Hannan, E. J., et al. (1970). &quot;The seasonal adjustment of economic time series.&quot; <em>International economic review</em> 11(1): 24-52.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Sørensen, C. (2002). &quot;Modeling seasonality in agricultural commodity futures.&quot; <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em> 22(5): 393-426.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate parameter of a Two-factor model Crude Oil model
##as first presented by Schwartz and Smith (2000):
two_factor_parameters &lt;- NFCP_parameters(N_factors = 2,
                                        GBM = TRUE,
                                        initial_states = FALSE,
                                        N_ME = 5)
print(two_factor_parameters)
</code></pre>

<hr>
<h2 id='spot_price_forecast'>Forecast spot prices of an N-factor model</h2><span id='topic+spot_price_forecast'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Analytically forecast expected spot prices following the &quot;true&quot; process of a given n-factor stochastic model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_price_forecast(x_0, parameters, t, percentiles = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spot_price_forecast_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="spot_price_forecast_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="spot_price_forecast_+3A_t">t</code></td>
<td>
<p><code>vector</code>. Discrete time points, in years, to forecast spot prices</p>
</td></tr>
<tr><td><code id="spot_price_forecast_+3A_percentiles">percentiles</code></td>
<td>
<p><code>vector</code>. Optional. Probabilistic forecasting percentile intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Future expected spot prices under the N-factor model can be forecasted through the analytic expression of expected future prices under the &quot;true&quot; N-factor process.
</p>
<p>Given that the log of the spot price is equal to the sum of the state variables (equation 1), the spot price is log-normally distributed with the expected prices given by:
</p>
\[E[S_t] = exp(E[ln(S_t)] + \frac{1}{2}Var[ln(S_t)])\]
<p>Where:
\[E[ln(S_t)] = season(t) + \sum_{i=1}^Ne^{-(\kappa_it)}x_i(0) + \mu t\]
</p>
<p>Where \(\kappa_i = 0\) when <code>GBM=T</code> and \(\mu = 0\) when <code>GBM = F</code>
</p>
\[Var[ln(S_t)] =  \sigma_1^2t + \sum_{i.j\neq1}\sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j}\]
<p>and thus:
</p>
\[E[S_t] = exp(season(t) + \sum_{i=1}^N e^{-\kappa_it}x_i(0) + (\mu + \frac{1}{2}\sigma_1^2)t + \frac{1}{2}\sum_{i.j\neq1} \sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j})\]
<p>Under the assumption that the first factor follows a Brownian Motion, in the long-run expected spot prices grow over time at a constant rate of \(\mu + \frac{1}{2}\sigma_1^2\) as the \(e^{-\kappa_it}\) and \(e^{-(\kappa_i + \kappa_j)t}\) terms approach zero.
</p>
<p>An important consideration when forecasting spot prices using parameters estimated through maximum likelihood estimation is that the parameter estimation process takes the assumption of risk-neutrality and thus the
true process growth rate \(\mu\) is not estimated with a high level of precision. This can be shown from the higher standard error for \(\mu\) than other estimated parameters,
such as the risk-neutral growth rate \(\mu^*\). See Schwartz and Smith (2000) for more details.
</p>


<h3>Value</h3>

<p><code>spot_price_forecast</code> returns a vector of expected future spot prices under a given N-factor model at specified discrete future time points. When <code>percentiles</code> are specified, the function returns a matrix with the corresponding confidence bands in each column of the matrix.
</p>


<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Forecast the Schwartz and Smith (2000) two-factor oil model:

##Step 1 - Kalman filter of the two-factor oil model:
SS_2F_filtered &lt;- NFCP_Kalman_filter(SS_oil$two_factor,
                                    names(SS_oil$two_factor),
                                    log(SS_oil$stitched_futures),
                                    SS_oil$dt,
                                    SS_oil$stitched_TTM,
                                    verbose = TRUE)

##Step 2 - Probabilistic forecast of N-factor stochastic differential equation (SDE):
spot_price_forecast(x_0 = SS_2F_filtered$x_t,
                   parameters = SS_oil$two_factor,
                   t = seq(0,9,1/12),
                   percentiles = c(0.1, 0.9))

</code></pre>

<hr>
<h2 id='spot_price_simulate'>Simulate spot prices of an N-factor model through Monte Carlo simulation</h2><span id='topic+spot_price_simulate'></span>

<h3>Description</h3>

<p>Simulate risk-neutral price paths of an an N-factor commodity pricing model through Monte Carlo Simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_price_simulate(
  x_0,
  parameters,
  t = 1,
  dt = 1,
  N_simulations = 2,
  antithetic = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spot_price_simulate_+3A_x_0">x_0</code></td>
<td>
<p><code>vector</code>. Initial values of the state variables, where the length must correspond to the number of factors specified in the parameters.</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameter values of a specified N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_t">t</code></td>
<td>
<p><code>numeric</code>. Number of years to simulate.</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Discrete time step, in years, of the Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_n_simulations">N_simulations</code></td>
<td>
<p><code>numeric</code>. The total number of Monte Carlo simulations.</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_antithetic">antithetic</code></td>
<td>
<p><code>logical</code>. Should antithetic price paths be simulated?</p>
</td></tr>
<tr><td><code id="spot_price_simulate_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should simulated state variables be output?</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The <code>spot_price_simulate</code> function is able to quickly and efficiently simulate a large number of state variables and risk-neutral price paths of a commodity following the N-factor model.
Simulating risk-neutral price paths of a commodity under an N-factor model through Monte Carlo simulations allows for the
valuation of commodity related investments and derivatives, such as American options and real Options through dynamic programming methods.
The <code>spot_price_simulate</code> function quickly and efficiently simulates an N-factor model over a specified number of years, simulating antithetic price paths as a simple variance reduction technique.
The <code>spot_price_simulate</code> function uses the <code>mvrnorm</code> function from the <code>MASS</code> package to draw from a multivariate normal distribution for the correlated simulation shocks of state variables.
</p>
<p>The N-factor model stochastic differential equation is given by:
</p>
<p>Brownian Motion processes (ie. factor one when <code>GBM = T</code>) are simulated using the following solution:
</p>
\[x_{1,t+1} = x_{1,t} + \mu^*\Delta t + \sigma_1 \Delta t Z_{t+1}\]
<p>Where \(\Delta t\) is the discrete time step, \(\mu^*\) is the risk-neutral growth rate and \(\sigma_1\) is the instantaneous volatility. \(Z_t\) represents the
independent standard normal at time \(t\).
</p>
<p>Ornstein-Uhlenbeck Processes are simulated using the following solution:
</p>
\[x_{i,t} = x_{i,0}e^{-\kappa_it}-\frac{\lambda_i}{\kappa_i}(1-e^{-\kappa_it})+\int_0^t\sigma_ie^{\kappa_is}dW_s\]
<p>Where a numerical solution is obtained by numerically discretising and approximating the integral term using the Euler-Maruyama integration scheme:
\[\int_0^t\sigma_ie^{\kappa_is}dW_s = \sum_{j=0}^t \sigma_ie^{\kappa_ij}dW_s\]
</p>
<p>Finally, deterministic seasonality is considered within the spot prices of simulated price paths.
</p>


<h3>Value</h3>

<p><code>spot_price_simulate</code> returns a list when <code>verbose = T</code> and a matrix of simulated price paths when <code>verbose = F</code>. The returned objects in the list are:
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>State_Variables</code> </td><td style="text-align: left;"> A matrix of simulated state variables for each factor is returned when <code>verbose = T</code>. The number of factors returned corresponds to the number of factors in the specified N-factor model. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>Prices</code> </td><td style="text-align: left;"> A matrix of simulated price paths. Each column represents one simulated price path and each row represents one simulated observation. </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1
## Simulate a geometric Brownian motion (GBM) process:
simulated_spot_prices &lt;- spot_price_simulate(
 x_0 = log(20),
 parameters = c(mu_rn = (0.05 - (1/2) * 0.2^2), sigma_1 = 0.2),
 t = 1,
 dt = 1/12,
 N_simulations = 1e3)

# Example 2
## Simulate the Short-Term/Long-Term model:

### Step 1 - Obtain contemporary state variable estimates through the Kalman Filter:
SS_2F_filtered &lt;- NFCP_Kalman_filter(parameter_values = SS_oil$two_factor,
                                    parameter_names = names(SS_oil$two_factor),
                                    log_futures = log(SS_oil$stitched_futures),
                                    dt = SS_oil$dt,
                                    futures_TTM = SS_oil$stitched_TTM,
                                    verbose = TRUE)

### Step 2 - Use these state variable estimates to simulate futures spot prices:
simulated_spot_prices &lt;- spot_price_simulate(
 x_0 = SS_2F_filtered$x_t,
 parameters = SS_oil$two_factor,
 t = 1,
 dt = 1/12,
 N_simulations = 1e3,
 antithetic = TRUE,
 verbose = TRUE)
</code></pre>

<hr>
<h2 id='SS_oil'>Crude oil term structure futures data (1990 - 1995)</h2><span id='topic+SS_oil'></span>

<h3>Description</h3>

<p>The <code>SS_oil</code> <code>list</code> object features the approximate weekly observations of Crude Oil (WTI) futures contracts used to develop a two-factor
commodity pricing model within the prominent work of Schwartz and Smith (2000) titled: &quot;Short-Term Variations and long-Term Dynamics in Commodity Prices&quot;.
The two-factor commodity pricing model presented within this study is also included. The <code>SS_oil</code> list object is used extensively within the
<code>NFCP</code> package to provide working examples and showcase the features of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SS_oil)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> Containing eight objects:
</p>

<dl>
<dt>contracts</dt><dd><p>A data frame with 268 rows and 82 columns. Each column represents a Crude Oil futures contract, and each row represents a closing
weekly price for that futures contract. Observation dates of the contract object are weekly in frequency from
<code>1990-02-06</code> to <code>1995-02-14</code>. Contracts without observations on a particular date are represented as <code>NA</code>.</p>
</dd>
<dt>stitched_futures</dt><dd><p>Schwartz and Smith (2000) applied stitched contract observation data to estimate commodity pricing models, which
are approximated within this object. The <code>stitched_futures</code> object was developed using the <code>stitch_contracts</code> function (see <code>stitch_contracts</code> examples for more details). Contracts were
stitched according to the contract numbers
specified within the object <code>stitched_TTM</code>. <code>stitched_futures</code> is
identical to the futures data made available within the MATLAB program &quot;SchwartzSmithModel&quot; developed by Goodwin (2013).</p>
</dd>
<dt>spot</dt><dd><p>A <code>data.frame</code> of spot prices of Crude Oil. weekly in frequency from
<code>1990-02-06</code> to <code>1995-02-14</code>.</p>
</dd>
<dt>final_trading_days</dt><dd><p>Named vector listing the final trading days of each observed futures contract within the <code>contracts</code> object. Each element of
<code>final_trading_days</code> corresponds to a column of the <code>contracts</code> object. The final
trading day of a futures contract is used to calculate the number of business
days from a given observation to the maturity of the contract (ie. a contract time to maturity).</p>
</dd>
<dt>contract_maturities</dt><dd><p>A data frame with identical dimensions to the <code>contracts</code> data frame. This data frame
lists the time to maturity of a given futures contract in years at each observation point.
This is identical to the number of business days (in years) between the observed date and the final trading day of a particular futures contract.
The maturity matrix assumes 262 trading days a year. If the contract is not yet available or has expired, the <code>contract_maturities</code> element is <code>NA</code>.</p>
</dd>
<dt>stitched_TTM</dt><dd><p>A vector corresponding to the constant time to maturities that was
assumed within the original study of Schwartz and Smith (2000).</p>
</dd>
<dt>dt</dt><dd><p>The discrete time step used to estimate parameters with this data. The time step is 5/262, which represents a
weekly frequency of observations where each weekday is a business day (ie. there are no business days on weekends).</p>
</dd>
<dt>two_factor</dt><dd><p>The crude oil two-factor commodity pricing model parameters presented within the work of Schwartz and Smith (2000).
These parameter estimates are prolific, benchmarked within several subsequent publications.</p>
</dd>
</dl>



<h3>References</h3>

<p>Dominice Goodwin (2013). Schwartz-Smith 2-factor model - Parameter estimation (https://www.mathworks.com/matlabcentral/fileexchange/43352-schwartz-smith-2-factor-model-parameter-estimation),
MATLAB Central File Exchange. Retrieved November 21, 2020.
</p>
<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>

<hr>
<h2 id='stitch_contracts'>Stitch futures contracts</h2><span id='topic+stitch_contracts'></span>

<h3>Description</h3>

<p>Aggregate futures contract price data by stitching according to either approximate maturities and rollover frequency or contract number from closest maturity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch_contracts(
  futures,
  futures_TTM = NULL,
  maturity_matrix = NULL,
  rollover_frequency = NULL,
  contract_numbers = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stitch_contracts_+3A_futures">futures</code></td>
<td>
<p>Contract futures price data. Each row of <code>Futures</code> should represent one observation of futures prices and each column should represent one quoted futures contract. NA's in <code>Futures</code> are allowed, representing missing observations.</p>
</td></tr>
<tr><td><code id="stitch_contracts_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p>A <code>vector</code> of contract maturities to stitch</p>
</td></tr>
<tr><td><code id="stitch_contracts_+3A_maturity_matrix">maturity_matrix</code></td>
<td>
<p>The time-to-maturity (in years) for each contract at each given observation point. The dimensions of <code>maturity_matrix</code> should match those of <code>Futures</code></p>
</td></tr>
<tr><td><code id="stitch_contracts_+3A_rollover_frequency">rollover_frequency</code></td>
<td>
<p>the frequency (in years) at which contracts should be rolled over</p>
</td></tr>
<tr><td><code id="stitch_contracts_+3A_contract_numbers">contract_numbers</code></td>
<td>
<p>A <code>vector</code> of contract numbers offset from the closest-to-maturity contract at which to stitch contracts.</p>
</td></tr>
<tr><td><code id="stitch_contracts_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should additional information be output? see <b>details</b></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aggregates a set of futures contract data by stitching contract data over an observation period, resulting in a
set of futures observations that is 'complete' (ie. Does not feature missing observations). Aggregated futures
data benefit from several computational efficiencies compared to raw contract data, but results in the loss of futures price information.
</p>
<p>There are two methods of the <code>stitch_contracts</code> function that can be utilized the stitch contracts:
</p>
<p><b>Method 1</b>
</p>
<p><code>stitch_contracts(futures, contract_numbers, verbose = T)</code>
Futures data may be aggregated by stitching prices according to maturity matching. This method requires the inputs <code>futures_TTM</code>, <code>maturity_matrix</code> and <code>rollover_frequency</code>.
This method stitched contracts by matching the observation prices according to which contract has the closest time-to-maturity of the desired maturity specified
in <code>futures_TTM</code>. Contracts are rolled over at the frequency specified in <code>rollover_frequency</code>.
</p>
<p><b>Method 2</b>
</p>
<p><code>stitch_contracts(futures, futures_TTM, maturity_matrix, rollover_frequency, verbose = T)</code>
Futures data may be stitched according to the contract numbers offset from the closest-to-maturity contract. This method requires only the
input <code>contract_numbers</code> specifying which contracts should be included. This method is most appropriate when the maturity of available
contracts are consistent (ie. contracts expire every month or three months).
</p>


<h3>Value</h3>

<p><code>stitch_contracts</code> returns a matrix of stitched futures prices if <code>verbose = T</code> and a list with two or three objects otherwise (see below).
</p>

<table>
<tr>
 <td style="text-align: left;">

<code>prices</code> </td><td style="text-align: left;"> A data frame of Stitched futures prices. Each row represents an observation of the specified contracts. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>maturities</code> </td><td style="text-align: left;"> A data frame of the time-to-maturity of observed futures prices. Each row represents an observation of the
specified contracts. Returned only when <b>Method 1</b> is used (see <b>Details</b>)  and <code>verbose = T</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>tickers</code> </td><td style="text-align: left;">  A data frame of the named columns of observed futures prices (e.g. contract tickers). Returned only when <code>Futures</code> or <code>maturity_matrix</code> have named columns and <code>verbose = T</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##These examples approximately replicate the Crude Oil data utilized within the
##prominent work of Schwartz and Smith (2000):

###Method 1 - Stitch crude oil contracts according to maturity matching:
SS_stitched_M1 &lt;- stitch_contracts(futures = SS_oil$contracts,
                                  futures_TTM = c(1, 5, 9, 13, 17)/12,
                                  maturity_matrix = SS_oil$contract_maturities,
                                  rollover_frequency = 1/12, verbose = TRUE)

###Method 2 - Stitch crude oil contracts according to nearest contract numbers:
SS_stitched_M2 &lt;- stitch_contracts(futures = SS_oil$contracts,
                                  contract_numbers = c(1, 5, 9, 13, 17), verbose = TRUE)

</code></pre>

<hr>
<h2 id='TSfit_volatility'>Calculate the volatility term structure of futures returns</h2><span id='topic+TSfit_volatility'></span>

<h3>Description</h3>

<p>Estimate the theoretical and empirical volatility term structure of futures returns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSfit_volatility(parameters, futures, futures_TTM, dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TSfit_volatility_+3A_parameters">parameters</code></td>
<td>
<p><code>vector</code>. A named vector of parameters of an N-factor model. Function <code>NFCP_parameters</code> is recommended.</p>
</td></tr>
<tr><td><code id="TSfit_volatility_+3A_futures">futures</code></td>
<td>
<p><code>matrix</code>. Historical observes futures price data. Each column must correspond to a listed futures contract and each row must correspond to a discrete observation of futures contracts. NA's are permitted.</p>
</td></tr>
<tr><td><code id="TSfit_volatility_+3A_futures_ttm">futures_TTM</code></td>
<td>
<p><code>vector</code>. Each element of 'futures_TTM' must correspond to the time-to-maturity from the current observation point of futures contracts listed in object 'futures'.</p>
</td></tr>
<tr><td><code id="TSfit_volatility_+3A_dt">dt</code></td>
<td>
<p><code>numeric</code>. Constant, discrete time step of observations, in years.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The fit of an N-factor models theoretical volatility term structure of futures returns to those obtained directly from observed futures prices can be used as a measure of robustness for
the models ability to explain the behaviour of a commodities term structure.
</p>
<p>The theoretical model volatility term structure of futures returns is given by the following equation:
</p>
\[\sigma_F(\tau) = \sum_{i=1}^N \sum_{j=1}^N \sigma_i \sigma_j \rho_{i,j} e^{-(\kappa_i + \kappa_j)\tau}\]
<p>Under the case that \(\kappa_1 = 0\), the model volatility term structure converges to \(\sigma_1^2\) as \(\tau\) grows large.
</p>
<p>The empirical volatility term structure of futures returns is given by:
</p>
\[\hat\sigma_F^2(\tau) = \frac{1}{\Delta t}\sum_{i=1}^N(log(F(t_i,\tau)/F(t_i-\Delta t,\tau)) - \bar\mu)^2\]
<p>According to Cortazar and Naranjo (2006): &quot;A larger number of factors gives more flexibility to adjust first and second moments simultaneously, hence explaining why (a) four-factor (may) outperform (a) three-factor one in fitting the volatility term structure.&quot;
</p>


<h3>Value</h3>

<p><code>TSfit_volatility</code> returns a matrix with the theoretical and empirical volatility term structure of futures returns, with the number of columns of this matrix coinciding with the number of input futures contracts.
</p>


<h3>References</h3>

<p>Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. <em>Manage. Sci.</em>, 46, 893-911.
</p>
<p>Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. <em>Journal of Futures Markets: Futures, Options, and Other Derivative Products</em>, 26(3), 243-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test the volatility term structure fit of the Schwartz-Smith two-factor model on crude oil:
V_TSFit &lt;- TSfit_volatility(
parameters = SS_oil$two_factor,
futures = SS_oil$stitched_futures,
futures_TTM = SS_oil$stitched_TTM,
dt = SS_oil$dt)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
