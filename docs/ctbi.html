<!DOCTYPE html><html><head><title>Help for package ctbi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctbi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ctbi'><p>ctbi</p></a></li>
<li><a href='#ctbi.cycle'><p>ctbi.cycle</p></a></li>
<li><a href='#ctbi.long.term'><p>ctbi.long.term</p></a></li>
<li><a href='#ctbi.outlier'><p>ctbi.outlier</p></a></li>
<li><a href='#ctbi.plot'><p>ctbi.plot</p></a></li>
<li><a href='#ctbi.timeseries'><p>ctbi.timeseries</p></a></li>
<li><a href='#hidd.check.bin.period'><p>hidd.check.bin.period</p></a></li>
<li><a href='#hidd.count.NA'><p>hidd.count.NA</p></a></li>
<li><a href='#hidd.count.noNA'><p>hidd.count.noNA</p></a></li>
<li><a href='#hidd.mad'><p>hidd.mad</p></a></li>
<li><a href='#hidd.mean'><p>hidd.mean</p></a></li>
<li><a href='#hidd.median'><p>hidd.median</p></a></li>
<li><a href='#hidd.rel.time'><p>hidd.rel.time</p></a></li>
<li><a href='#hidd.replace'><p>hidd.replace</p></a></li>
<li><a href='#hidd.sd'><p>hidd.sd</p></a></li>
<li><a href='#hidd.seq'><p>hidd.seq</p></a></li>
<li><a href='#hidd.sum'><p>hidd.sum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Procedure to Clean, Decompose and Aggregate Timeseries</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Clean, decompose and aggregate univariate time series following the procedure "Cyclic/trend decomposition using bin interpolation" and the Logbox method for flagging outliers, both detailed in Ritter, F.: Technical note: A procedure to clean, decompose, and aggregate time series, Hydrol. Earth Syst. Sci., 27, 349–361, &lt;<a href="https://doi.org/10.5194%2Fhess-27-349-2023">doi:10.5194/hess-27-349-2023</a>&gt;, 2023.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fritte2/ctbi">https://github.com/fritte2/ctbi</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.14.2), stats (&ge; 4.1.0), utils (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-20 11:28:44 UTC; fritter</td>
</tr>
<tr>
<td>Author:</td>
<td>Francois Ritter <a href="https://orcid.org/0000-0001-6123-2145"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francois Ritter &lt;ritter.francois@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-20 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ctbi'>ctbi</h2><span id='topic+ctbi'></span>

<h3>Description</h3>

<p><b>Please cite</b> the following companion paper if you're using the <code>ctbi</code> package: Ritter, F.: Technical note: A procedure to clean, decompose, and aggregate time series, Hydrol. Earth Syst. Sci., 27, 349–361, https://doi.org/10.5194/hess-27-349-2023, 2023.
</p>
<p>The goal of <code>ctbi</code> is to <b>clean</b>, <b>decompose</b>, <b>impute</b> and <b>aggregate</b> univariate time series. <code>ctbi</code> stands for <em>Cyclic/Trend decomposition using Bin Interpolation</em>: the time series is divided into a sequence of non-overlapping bins (inputs: <code>bin.side</code> or <code>bin.center</code>, and <code>bin.period</code>). Bins with enough data (input: <code>bin.max.f.NA</code>) are <em>accepted</em>, and otherwise <em>rejected</em> (their values are set to <code>NA</code>). The <b>long-term trend</b> is a linear interpolation of the mean values between successive bins. The <b>cyclic component</b> is the mean stack of detrended data within all accepted bins.
</p>
<p>Outliers present in the residuals are flagged using an enhanced box plot rule (called <b>Logbox</b>, input: <code>coeff.outlier</code>) that is adapted to non-Gaussian data and keeps the type I error at <code class="reqn">\frac{0.1}{\sqrt{n}}</code> % (percentage of erroneously flagged outliers). <b>Logbox</b> replaces the original <code class="reqn">\alpha = 1.5</code> constant of the box plot rule with <code class="reqn">\alpha = A \times \log(n)+B+\frac{C}{n}</code>. The variable <code class="reqn">n \geq 9</code> is the sample size, <code class="reqn">C = 36</code> corrects biases emerging in small samples, and <code class="reqn">A</code> and <code class="reqn">B</code> are automatically calculated on a predictor of the maximum tail weight (<code class="reqn">m_{*}</code>).
</p>
<p>The strength of the <b>cyclic pattern</b> within each bin is quantified by a new metric, the <b>Stacked Cycles Index</b> defined as <code class="reqn">SCI = 1 - \frac{SS_{res}}{SS_{tot}} - \frac{1}{N_{bin}}</code>. The variable <code class="reqn">SS_{tot}</code> is the sum of the squared detrended data, <code class="reqn">SS_{res}</code> is the sum of the squared detrended &amp; deseasonalized data, and <code class="reqn">N_{bin}</code> is the number of accepted bins. A value of <code class="reqn">SCI \leq 0</code> is associated  with no cyclicity, while <code class="reqn">SCI = 1</code> is associated with a perfectly cyclic signal. Data can be imputed if <code class="reqn">SCI_{min} \leq SCI</code> (input: <code>SCI.min</code>). Finally, data are aggregated in each bin (input: <code>bin.FUN</code>).
</p>
<p>Important functions of the package: <code>ctbi</code>, <code>ctbi.outlier</code> (flag outliers in univariate datasets with the <b>Logbox</b> method) and <code>ctbi.plot</code> (plot the time series).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi(
  data.input,
  bin.side,
  bin.period,
  bin.center = NULL,
  bin.FUN = "mean",
  bin.max.f.NA = 0.2,
  SCI.min = 0.6,
  coeff.outlier = "auto",
  ylim = c(-Inf, +Inf)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi_+3A_data.input">data.input</code></td>
<td>
<p>two columns data.frame (or data.table) with the first column being the time component (POSIXct, Date or numeric) and the second column the value (numeric)</p>
</td></tr>
<tr><td><code id="ctbi_+3A_bin.side">bin.side</code></td>
<td>
<p>one side of any bin (same class as the time component)</p>
</td></tr>
<tr><td><code id="ctbi_+3A_bin.period">bin.period</code></td>
<td>
<p>time interval between two sides of a bin. If the time component x.t of data.input is numeric, <code>bin.period</code> is numeric. If x.t is POSIXct or Date, <code>bin.period</code> = 'k units', with k an integer and units = (seconds, minutes, hours, days, weeks, half-months, months, years, decades, centuries, millenaries)</p>
</td></tr>
<tr><td><code id="ctbi_+3A_bin.center">bin.center</code></td>
<td>
<p>if <code>bin.side</code> is not specified, one center of a bin (same class as the time component)</p>
</td></tr>
<tr><td><code id="ctbi_+3A_bin.fun">bin.FUN</code></td>
<td>
<p>character ('mean', 'median' or 'sum') that defines the aggregating operator</p>
</td></tr>
<tr><td><code id="ctbi_+3A_bin.max.f.na">bin.max.f.NA</code></td>
<td>
<p>numeric between 0 and 1 that specifies the maximum fraction of missing values for a bin to be accepted. The minimum number of non-NA points for a bin to be accepted is bin.size.min.accepted = bin.size*(1-<code>bin.max.f.NA</code>) with bin.size the number of points per bin</p>
</td></tr>
<tr><td><code id="ctbi_+3A_sci.min">SCI.min</code></td>
<td>
<p>numeric between 0 and 1 that is compared to the Stacked Cycles Index (SCI). If SCI &gt; <code>SCI.min</code>, missing values are imputed in accepted bins with the sum of the long-term and cyclic components. If <code>SCI.min</code> = <code>NA</code>, no values are imputed</p>
</td></tr>
<tr><td><code id="ctbi_+3A_coeff.outlier">coeff.outlier</code></td>
<td>
<p>one of <code>coeff.outlier</code> = 'auto' (default value), <code>coeff.outlier</code> = 'gaussian', <code>coeff.outlier</code> = c(A,B,C) or <code>coeff.outlier</code> = <code>NA</code>. If <code>coeff.outlier</code> = 'auto', C = 36 and the coefficients A and B are calculated on <code class="reqn">m_{*}</code>. If <code>coeff.outlier</code> = 'gaussian', <code>coeff.outlier</code> = c(0.08,2,36), adapted to the Gaussian distribution. If <code>coeff.outlier</code> = <code>NA</code>, no outliers are flagged</p>
</td></tr>
<tr><td><code id="ctbi_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of length 2 that defines the range of possible values. Values strictly below ylim[1] or strictly above ylim[2] are set to NA. Values equal to ylim[1] or ylim[2] are discarded from the residuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>
<p><b>data0</b>, the raw dataset (same class as <code>data.input</code>), with 9 columns: (i) time; (ii) outlier-free and imputed data; (iii) index.bin: index of the bins associated with each data points (the index is negative if the bin is rejected); (iv) long.term: long-term trend; (v) cycle: cyclic component; (vi) residuals: residuals including the outliers; (vii) outliers: quarantined outliers; (viii) imputed: value of the imputed data points; (ix) time.bin: relative position of the data points in their bins, between 0 and 1
</p>
<p><b>data1</b>, the aggregated dataset (same class as <code>data.input</code>), with 10 columns: (i) aggregated time (center of the bins); (ii) aggregated data; (iii) index.bin: index of the bin (negative value if the bin is rejected); (iv) bin.start: start of the bin; (v) bin.end: end of the bin; (vi) n.points: number of points per bin (including <code>NA</code> values); (vii) n.NA: number of NA values per bin, originally; (viii) n.outliers: number of outliers per bin; (ix) n.imputed: number of imputed points per bin; (x) variability associated with the aggregation (standard deviation for the mean, MAD for the median and nothing for the sum)
</p>
<p><b>mean.cycle</b>, a dataset (same class as <code>data.input</code>) with bin.size rows and 4 columns: (i) generic.time.bin1: time of the first bin; (ii) mean: the mean stack of detrended data; (iii) sd: the standard deviation on the mean; (iv) time.bin: relative position of the data points in the bin, between 0 and 1
</p>
<p><b>summary.bin</b>, a vector that contains bin.size (median number of points in non-empty bins), bin.size.min.accepted (minimum number of points for a bin to be accepted) and SCI
</p>
<p><b>summary.outlier</b>, a vector that contains A, B, C, <code class="reqn">m_{*}</code>, the size of the residuals (n), and the lower and upper outlier threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example of the contaminated sunspot data
example1 &lt;- data.frame(year = 1700:1988,sunspot = as.numeric(sunspot.year))
example1[sample(1:289,30),'sunspot'] &lt;- NA # contaminate data with missing values
example1[c(5,30,50),'sunspot'] &lt;- c(-50,300,400) # contaminate data with outliers
example1 &lt;- example1[-(70:100),] # create gap in the data
bin.period &lt;- 11 # aggregation performed every 11 years (the year is numeric here)
bin.side &lt;- 1989 # give one side of a bin
bin.FUN &lt;- 'mean'
bin.max.f.NA &lt;- 0.2 # maximum of 20% of missing data per bin
ylim &lt;- c(0,Inf) # negative values are impossible

list.main &lt;- ctbi(example1,bin.period=bin.period,
                       bin.side=bin.side,bin.FUN=bin.FUN,
                       ylim=ylim,bin.max.f.NA=bin.max.f.NA)
data0.example1 &lt;- list.main$data0 # cleaned raw dataset
data1.example1 &lt;- list.main$data1 # aggregated dataset.
mean.cycle.example1 &lt;- list.main$mean.cycle # this data set shows a moderate seasonality
summary.bin.example1 &lt;- list.main$summary.bin # confirmed with SCI = 0.50
summary.outlier.example1 &lt;- list.main$summary.outlier

plot(mean.cycle.example1[,'generic.time.bin1'],
     mean.cycle.example1[,'mean'],type='l',ylim=c(-80,80),
     ylab='sunspot cycle',
     xlab='11 years window')
lines(mean.cycle.example1[,'generic.time.bin1'],
      mean.cycle.example1[,'mean']+mean.cycle.example1[,'sd'],type='l',lty=2)
lines(mean.cycle.example1[,'generic.time.bin1'],
      mean.cycle.example1[,'mean']-mean.cycle.example1[,'sd'],type='l',lty=2)
title(paste0('mean cycle (moderate cyclicity: SCI = ',summary.bin.example1['SCI'],')'))
# plot tool:
ctbi.plot(list.main,show.n.bin=10)

# example of the beaver data
temp.beaver &lt;- beaver1[,'temp']
t.char &lt;- as.character(beaver1[,'time'])
minutes &lt;- substr(t.char,nchar(t.char)-1,nchar(t.char))
hours &lt;- substr(t.char,nchar(t.char)-3,nchar(t.char)-2)
hours[hours==""] &lt;- '0'
days &lt;- c(rep(12,91),rep(13,23))
time.beaver &lt;- as.POSIXct(paste0('2000-12-',days,' ',hours,':',minutes,':00'),tz='UTC')
example2 &lt;- data.frame(time=time.beaver,temp=temp.beaver)

bin.period &lt;- '1 hour' # aggregation performed every hour
bin.side &lt;- as.POSIXct('2000-12-12 00:00:00',tz='UTC') # give one side of a bin
bin.FUN &lt;- 'mean' # aggregation operator
bin.max.f.NA &lt;- 0.2 # maximum of 20% of missing data per bin
ylim &lt;- c(-Inf,Inf)
list.main &lt;- ctbi(example2,bin.period=bin.period,
                 bin.side=bin.side,bin.FUN=bin.FUN,
                 ylim=ylim,bin.max.f.NA=bin.max.f.NA)
data0.example2 &lt;- list.main$data0 # cleaned raw dataset
data1.example2 &lt;- list.main$data1 # aggregated dataset.
lower.threshold &lt;- list.main$summary.outlier['lower.outlier.threshold']
upper.threshold &lt;- list.main$summary.outlier['upper.outlier.threshold']
hist(data0.example2[,'residuals'],xlim=c(-0.5,0.5),30,main='beaver residuals')
abline(v=c(lower.threshold,upper.threshold),col='red',lwd=2) # show the histogram of the residuals
</code></pre>

<hr>
<h2 id='ctbi.cycle'>ctbi.cycle</h2><span id='topic+ctbi.cycle'></span>

<h3>Description</h3>

<p>Calculate the mean (or median) stack of the detrended data for all bins, and add the cyclic component column to data0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi.cycle(data0, bin.size, outliers.checked)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi.cycle_+3A_data0">data0</code></td>
<td>
<p>data.table with the columns x (time series), y (values), time.bin (position of x between 0 and 1 with respect to the bin boundaries), cycle.index (index between 1 and bin.size attached to time.bin), and long.term (the long-term trend)</p>
</td></tr>
<tr><td><code id="ctbi.cycle_+3A_bin.size">bin.size</code></td>
<td>
<p>median number of points within all non-empty bins</p>
</td></tr>
<tr><td><code id="ctbi.cycle_+3A_outliers.checked">outliers.checked</code></td>
<td>
<p>boolean to indicate if the median (outliers.checked = FALSE) or the mean (outliers.checked = TRUE) should be used to calculate the stack</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains data0 (data0.l) and a data.table that contains the mean (or median) stack of all accepted bins (FUN.cycle.l)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x &lt;- seq(from=as.Date('2001-01-01'),to=as.Date('2010-12-01'),by='1 month')
y &lt;- 3*cos(2*pi*(0:(length(x)-1))/12)+runif(length(x))
bin.size &lt;- 12
outliers.checked &lt;- TRUE
time.bin &lt;- rep(((1:bin.size)/bin.size)-(1/(2*bin.size)),10)
cycle.index &lt;- findInterval(time.bin,(1:(bin.size-1))/bin.size)+1
long.term &lt;- rep(0,length(x))
data0 &lt;- data.table(x=x,y=y,cycle.index=cycle.index,long.term=long.term,time.bin=time.bin)
list.cycle &lt;- ctbi.cycle(data0,bin.size,outliers.checked)
data0.with.cyclic.component &lt;- list.cycle$data0.l
mean.cycle &lt;- list.cycle$FUN.cycle.l
</code></pre>

<hr>
<h2 id='ctbi.long.term'>ctbi.long.term</h2><span id='topic+ctbi.long.term'></span>

<h3>Description</h3>

<p>Calculate the long-term trend with a linear interpolation between the mean (or median) of bins defined between two consecutive centers. Bins defined between two consecutive sides are calculated as well to complete for missing values if they have neighbors. Bins without sufficient data are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi.long.term(data0, n.bin.min, seq.bin.side, outliers.checked)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi.long.term_+3A_data0">data0</code></td>
<td>
<p>data.table with the columns x (time series), y (values), side.index (index associated with each bin defined between two consecutive centers) and index.bin (index associated with each bin defined between two consecutive sides)</p>
</td></tr>
<tr><td><code id="ctbi.long.term_+3A_n.bin.min">n.bin.min</code></td>
<td>
<p>minimum number of points for a bin to be accepted</p>
</td></tr>
<tr><td><code id="ctbi.long.term_+3A_seq.bin.side">seq.bin.side</code></td>
<td>
<p>sequence of the sides of the bins</p>
</td></tr>
<tr><td><code id="ctbi.long.term_+3A_outliers.checked">outliers.checked</code></td>
<td>
<p>boolean to indicate if the median (outliers.checked = FALSE) or the mean (outliers.checked = TRUE) should be used to calculate the long-term trend</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data0 with the long-term trend added (column long.term)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
x &lt;- seq(from=as.Date('2001-01-01'),to=as.Date('2010-12-01'),by='1 month')
y &lt;- 3*cos(2*pi*(0:(length(x)-1))/12)+runif(length(x))
outliers.checked &lt;- TRUE
seq.bin.side &lt;- seq(from=as.Date('2001-01-01'),to=as.Date('2011-01-01'),by='1 year')
seq.bin.center &lt;- seq(from=as.Date('2001-06-01'),to=as.Date('2010-06-01'),by='1 year')
index.bin &lt;- findInterval(x,seq.bin.side)
side.index &lt;- findInterval(x,seq.bin.center)+0.5
n.bin.min &lt;- 10 # minimum of 10 months of data for a bin to be accepted
data0 &lt;- data.table(x=x,y=y,index.bin=index.bin,side.index=side.index)
data0.with.long.term &lt;- ctbi.long.term(data0,n.bin.min,seq.bin.side,outliers.checked)
</code></pre>

<hr>
<h2 id='ctbi.outlier'>ctbi.outlier</h2><span id='topic+ctbi.outlier'></span>

<h3>Description</h3>

<p><b>Please cite</b> the following companion paper if you're using the <code>ctbi</code> package: Ritter, F.: Technical note: A procedure to clean, decompose, and aggregate time series, Hydrol. Earth Syst. Sci., 27, 349–361, https://doi.org/10.5194/hess-27-349-2023, 2023.
</p>
<p>Outliers in an univariate dataset <code>y</code> are flagged using an enhanced box plot rule (called <b>Logbox</b>, input: <code>coeff.outlier</code>) that is adapted to non-Gaussian data and keeps the type I error at <code class="reqn">\frac{0.1}{\sqrt{n}}</code> % (percentage of erroneously flagged outliers).
</p>
<p>The box plot rule flags data points as outliers if they are below <code class="reqn">L</code> or above <code class="reqn">U</code> using the sample quantile <code class="reqn">q</code>:
</p>
<p><code class="reqn">L = q(0.25)-\alpha \times (q(0.75)- q(0.25))</code>
</p>
<p><code class="reqn">U = q(0.75)+\alpha \times (q(0.75)- q(0.25))</code>
</p>
<p><b>Logbox</b> replaces the original <code class="reqn">\alpha = 1.5</code> constant of the box plot rule with <code class="reqn">\alpha = A \times \log(n)+B+\frac{C}{n}</code>. The variable <code class="reqn">n \geq 9</code> is the sample size, <code class="reqn">C = 36</code> corrects biases emerging in small samples, and <code class="reqn">A</code> and <code class="reqn">B</code> are automatically calculated on a predictor of the maximum tail weight defined as <code class="reqn">m_{*} = \max(m_{-},m_{+})-0.6165</code>.
</p>
<p>The two functions (<code class="reqn">m_{-}</code>,<code class="reqn">m_{+}</code>) are defined as:
</p>
<p><code class="reqn">m_{-} = \frac{q(0.875)- q(0.625)}{q(0.75)- q(0.25)}</code>
</p>
<p><code class="reqn">m_{+} = \frac{q(0.375)- q(0.125)}{q(0.75)- q(0.25)}</code>
</p>
<p>And finally, <code class="reqn">A = f_{A}(</code><code class="reqn">m_{*}</code><code class="reqn">)</code> and <code class="reqn">B = f_{B}(</code><code class="reqn">m_{*}</code><code class="reqn">)</code> with <code class="reqn">m_{*}</code> restricted to [0,2]. The functions <code class="reqn">(f_{A},f_{B})</code> are defined as:
</p>
<p><code class="reqn">f_{A}(x) = 0.2294\exp(2.9416x-0.0512x^{2}-0.0684x^{3})</code>
</p>
<p><code class="reqn">f_{B}(x) = 1.0585+15.6960x-17.3618x^{2}+28.3511x^{3}-11.4726x^{4}</code>
</p>
<p>Both functions have been calibrated on the Generalized Extreme Value and Pearson families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi.outlier(y, coeff.outlier = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi.outlier_+3A_y">y</code></td>
<td>
<p>univariate data (numeric vector)</p>
</td></tr>
<tr><td><code id="ctbi.outlier_+3A_coeff.outlier">coeff.outlier</code></td>
<td>
<p>one of <code>coeff.outlier</code> = 'auto' (default value), <code>coeff.outlier</code> = 'gaussian', <code>coeff.outlier</code> = c(A,B,C) or <code>coeff.outlier</code> = <code>NA</code>. If <code>coeff.outlier</code> = 'auto', C = 36 and the coefficients A and B are calculated on <code class="reqn">m_{*}</code>. If <code>coeff.outlier</code> = 'gaussian', <code>coeff.outlier</code> = c(0.08,2,36), adapted to the Gaussian distribution. If <code>coeff.outlier</code> = <code>NA</code>, no outliers are flagged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>
<p><b>xy</b>, a two columns data frame that contains the clean data (first column) and the outliers (second column)
</p>
<p><b>summary.outlier</b>, a vector that contains A, B, C, <code class="reqn">m_{*}</code>, the size of the residuals (n), and the lower and upper outlier threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(30)
x[c(5,10,20)] &lt;- c(-10,15,30)
example1 &lt;- ctbi.outlier(x)
</code></pre>

<hr>
<h2 id='ctbi.plot'>ctbi.plot</h2><span id='topic+ctbi.plot'></span>

<h3>Description</h3>

<p>Plot the raw data with the bins, long-term trend and cyclic component shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi.plot(list.main, show.outliers = TRUE, show.n.bin = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi.plot_+3A_list.main">list.main</code></td>
<td>
<p>the list output from the function ctbi</p>
</td></tr>
<tr><td><code id="ctbi.plot_+3A_show.outliers">show.outliers</code></td>
<td>
<p>boolean to show or hide flagged outliers</p>
</td></tr>
<tr><td><code id="ctbi.plot_+3A_show.n.bin">show.n.bin</code></td>
<td>
<p>number of bins shown within one graphic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='ctbi.timeseries'>ctbi.timeseries</h2><span id='topic+ctbi.timeseries'></span>

<h3>Description</h3>

<p>Calculate the sequence of bin sides that encompasses the original time series based on a bin period and a bin side (or a bin center). The sequence of bin centers is calculated as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctbi.timeseries(x.t, bin.period, bin.side, bin.center = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctbi.timeseries_+3A_x.t">x.t</code></td>
<td>
<p>original time series (date, POSIXct or numeric)</p>
</td></tr>
<tr><td><code id="ctbi.timeseries_+3A_bin.period">bin.period</code></td>
<td>
<p>time interval between two sides of a bin. If x.t is numeric, bin.period is numeric. If x.t is POSIXct or Date, bin.period = 'k units', with k an integer and units = (seconds, minutes, hours, days, weeks, half-months, months, years, decades, centuries, millenaries)</p>
</td></tr>
<tr><td><code id="ctbi.timeseries_+3A_bin.side">bin.side</code></td>
<td>
<p>one side of a bin (same class as x.t)</p>
</td></tr>
<tr><td><code id="ctbi.timeseries_+3A_bin.center">bin.center</code></td>
<td>
<p>if bin.side is not specified, one center of a bin (same class as x.t)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>
<p>seq.bin.side, the sequence of bin sides (same class as bin.side)
</p>
<p>seq.bin.center, the sequence of bin centers (same class as bin.side)
</p>
<p>time.step.median, the median time step (numeric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x.t &lt;- seq(from=as.Date('2001-01-01'),to=as.Date('2010-12-01'),by='1 month')
bin.side &lt;- as.Date('2003-10-01')
bin.period &lt;- '4 months'
list.ts &lt;- ctbi.timeseries(x.t,bin.period,bin.side)
seq.bin.side.Date &lt;- list.ts$seq.bin.side
seq.bin.center.Date &lt;- list.ts$seq.bin.center

x.t &lt;- seq(from=as.POSIXct('2001-01-01 12:45:23'),to=as.POSIXct('2001-01-01 13:34:21'),by='18 s')
bin.side &lt;- as.POSIXct('2001-01-01 13:00:00')
bin.period &lt;- '1 minute' # '60 s', '60 sec', '60 seconds', '1 min' are also possible
list.ts &lt;- ctbi.timeseries(x.t,bin.period,bin.side)
seq.bin.side.POSIXct &lt;- list.ts$seq.bin.side
seq.bin.center.POSIXct &lt;- list.ts$seq.bin.center

x.t &lt;- seq(from= - 50000,to= 2000 ,by=1000)
bin.side &lt;- 0
bin.period &lt;- 10000
list.ts &lt;- ctbi.timeseries(x.t,bin.period,bin.side)
seq.bin.side.numeric &lt;- list.ts$seq.bin.side
seq.bin.center.numeric &lt;- list.ts$seq.bin.center
</code></pre>

<hr>
<h2 id='hidd.check.bin.period'>hidd.check.bin.period</h2><span id='topic+hidd.check.bin.period'></span>

<h3>Description</h3>

<p>interpret the string character bin.period used in ctbi.timeseries or ctbi.main
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.check.bin.period(bin.period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.check.bin.period_+3A_bin.period">bin.period</code></td>
<td>
<p>a character string or a numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>
<p>number, a numeric that indicates the value of bin.period
</p>
<p>units, a character that indicates the unit of bin.period
</p>
<p>bin.period.value.seconds, a numeric that indicates the value in seconds of bin.period
</p>
<p>bin.period.value.days, a numeric that indicates the value in days of bin.period
</p>

<hr>
<h2 id='hidd.count.NA'>hidd.count.NA</h2><span id='topic+hidd.count.NA'></span>

<h3>Description</h3>

<p>Calculate the number of NA values in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.count.NA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.count.NA_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of NA values in a vector
</p>

<hr>
<h2 id='hidd.count.noNA'>hidd.count.noNA</h2><span id='topic+hidd.count.noNA'></span>

<h3>Description</h3>

<p>Calculate the number of non-NA values in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.count.noNA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.count.noNA_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of non-NA values in a vector
</p>

<hr>
<h2 id='hidd.mad'>hidd.mad</h2><span id='topic+hidd.mad'></span>

<h3>Description</h3>

<p>Calculate the mean absolute deviation (MAD) of a vector if the number of its non-NA values is above a threshold. Otherwise, return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.mad(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.mad_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.mad_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric (either NA or the MAD of x)
</p>

<hr>
<h2 id='hidd.mean'>hidd.mean</h2><span id='topic+hidd.mean'></span>

<h3>Description</h3>

<p>Calculate the mean of a vector if the number of its non-NA values is above a threshold. Otherwise, return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.mean(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.mean_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.mean_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y a numeric (either NA or the mean of x)
</p>

<hr>
<h2 id='hidd.median'>hidd.median</h2><span id='topic+hidd.median'></span>

<h3>Description</h3>

<p>Calculate the median of a vector if the number of its non-NA values is above a threshold. Otherwise, return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.median(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.median_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.median_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric (either NA or the median of x)
</p>

<hr>
<h2 id='hidd.rel.time'>hidd.rel.time</h2><span id='topic+hidd.rel.time'></span>

<h3>Description</h3>

<p>calculate the relative position of each timestep of a vector with respect to the bin boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.rel.time(x, seq.bin.side)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.rel.time_+3A_x">x</code></td>
<td>
<p>a vector (numeric, POSIXct or Date)</p>
</td></tr>
<tr><td><code id="hidd.rel.time_+3A_seq.bin.side">seq.bin.side</code></td>
<td>
<p>the sequence of bin sides</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the relative position of each value of x with respect to the bins in seq.bin.side (between 0 and 1)
</p>

<hr>
<h2 id='hidd.replace'>hidd.replace</h2><span id='topic+hidd.replace'></span>

<h3>Description</h3>

<p>Replace all values within a vector with NA values if the sum of its non-NA values is below a threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.replace(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.replace_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.replace_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector x
</p>

<hr>
<h2 id='hidd.sd'>hidd.sd</h2><span id='topic+hidd.sd'></span>

<h3>Description</h3>

<p>Calculate the standard deviation of a vector if the number of its non-NA values is above a threshold. Otherwise, return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.sd(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.sd_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.sd_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric (either NA or the standard deviation of x)
</p>

<hr>
<h2 id='hidd.seq'>hidd.seq</h2><span id='topic+hidd.seq'></span>

<h3>Description</h3>

<p>similar to seq, except that when 'from' starts the 29, 30 or 31 of a month, seq2 adds 5 days to 'from', run seq, and then subtracts 5 days to the output. This is done because the function seq is not consistent when time series start at the end of the months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.seq(
  from = 1,
  to = 1,
  by = ((to - from)/(length.out - 1)),
  length.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.seq_+3A_from">from</code>, <code id="hidd.seq_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end values of the sequence. Of length 1 unless just from is supplied as an unnamed argument.</p>
</td></tr>
<tr><td><code id="hidd.seq_+3A_by">by</code></td>
<td>
<p>number: increment of the sequence.</p>
</td></tr>
<tr><td><code id="hidd.seq_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence. A non-negative number, which for seq and seq.int will be rounded up if fractional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of same class than from
</p>

<hr>
<h2 id='hidd.sum'>hidd.sum</h2><span id='topic+hidd.sum'></span>

<h3>Description</h3>

<p>Calculate the sum of a vector if the number of its non-NA values is above a threshold. Otherwise, return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidd.sum(x, N.min.NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidd.sum_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="hidd.sum_+3A_n.min.na">N.min.NA</code></td>
<td>
<p>a numeric threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric (either NA or the sum of x)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
