<!DOCTYPE html><html><head><title>Help for package inferCSN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inferCSN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inferCSN-package'><p>inferCSN: Inferring Cell-Specific Gene Regulatory Network</p></a></li>
<li><a href='#acc.calculate'><p>ACC calculate</p></a></li>
<li><a href='#as_matrix'><p>Attempts to turn a dgCMatrix into a dense matrix</p></a></li>
<li><a href='#auc.calculate'><p>AUC value calculate</p></a></li>
<li><a href='#calculate.gene.rank'><p>Calculate and rank TFs in network</p></a></li>
<li><a href='#check.parameters'><p>Check input parameters</p></a></li>
<li><a href='#coef.SRM_fit'><p>Extracts a specific solution in the regularization path</p></a></li>
<li><a href='#example_ground_truth'><p>Example ground truth data</p></a></li>
<li><a href='#example_matrix'><p>Example matrix data</p></a></li>
<li><a href='#example_meta_data'><p>Example meta data</p></a></li>
<li><a href='#filter_sort_matrix'><p>Filter and sort matrix</p></a></li>
<li><a href='#inferCSN'><p>Inferring Cell-Specific Gene Regulatory Network</p></a></li>
<li><a href='#model.fit'><p>Fit a sparse regression model</p></a></li>
<li><a href='#network_format'><p>Format weight table</p></a></li>
<li><a href='#network_sift'><p>network_sift</p></a></li>
<li><a href='#network.heatmap'><p>The heatmap of network</p></a></li>
<li><a href='#normalization'><p>normalization</p></a></li>
<li><a href='#parallelize_fun'><p>Apply function over a List or Vector</p></a></li>
<li><a href='#plot_contrast_networks'><p>plot_contrast_networks</p></a></li>
<li><a href='#plot_dynamic_networks'><p>plot_dynamic_networks</p></a></li>
<li><a href='#plot_scatter'><p>plot_scatter</p></a></li>
<li><a href='#plot_static_networks'><p>Plot of dynamic networks</p></a></li>
<li><a href='#predict.SRM_fit'><p>Predict Response</p></a></li>
<li><a href='#prepare.performance.data'><p>prepare.performance.data</p></a></li>
<li><a href='#print.SRM_fit'><p>Prints a summary of model.fit</p></a></li>
<li><a href='#r_square'><p><code class="reqn">R^2</code> (coefficient of determination)</p></a></li>
<li><a href='#rse'><p>Relative Squared Error</p></a></li>
<li><a href='#single.network'><p>Construct network for single gene</p></a></li>
<li><a href='#sparse.regression'><p>Sparse regression model</p></a></li>
<li><a href='#sse'><p>Sum of Squared Errors</p></a></li>
<li><a href='#table.to.matrix'><p>Switch weight table to matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferring Cell-Specific Gene Regulatory Network</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-6-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Meng Xu &lt;mengxu98@qq.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for inferring cell-specific gene regulatory network from single-cell sequencing data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mengxu98.github.io/inferCSN/">https://mengxu98.github.io/inferCSN/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mengxu98/inferCSN/issues">https://github.com/mengxu98/inferCSN/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ComplexHeatmap, doParallel, dplyr, foreach, ggnetwork,
ggplot2, ggraph, Matrix, methods, parallel, patchwork, pbapply,
purrr, Rcpp, RcppArmadillo, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>circlize, gtools, gganimate, ggExtra, ggpointdensity, ggpubr,
igraph, network, plotly, precrec, pROC, testthat (&ge; 3.0.0),
tidygraph, RColorBrewer, RTransferEntropy, viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>mengxu98/mxtemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-26 11:31:04 UTC; mx</td>
</tr>
<tr>
<td>Author:</td>
<td>Meng Xu <a href="https://orcid.org/0000-0002-8300-1054"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-26 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='inferCSN-package'>inferCSN: Inferring Cell-Specific Gene Regulatory Network</h2><span id='topic+inferCSN-package'></span>

<h3>Description</h3>

<p>A method for inferring cell-specific gene regulatory network from single-cell sequencing data.
</p>


<h3>Author(s)</h3>

<p>Meng xu (Maintainer), <a href="mailto:mengxu98@qq.com">mengxu98@qq.com</a>
</p>


<h3>Source</h3>

<p><a href="https://github.com/mengxu98/inferCSN">https://github.com/mengxu98/inferCSN</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mengxu98.github.io/inferCSN/">https://mengxu98.github.io/inferCSN/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mengxu98/inferCSN/issues">https://github.com/mengxu98/inferCSN/issues</a>
</p>
</li></ul>


<hr>
<h2 id='acc.calculate'>ACC calculate</h2><span id='topic+acc.calculate'></span>

<h3>Description</h3>

<p>ACC calculate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc.calculate(network_table, ground_truth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acc.calculate_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network</p>
</td></tr>
<tr><td><code id="acc.calculate_+3A_ground_truth">ground_truth</code></td>
<td>
<p>Ground truth for calculate AUC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ACC value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
acc.calculate(network_table, example_ground_truth)
</code></pre>

<hr>
<h2 id='as_matrix'>Attempts to turn a dgCMatrix into a dense matrix</h2><span id='topic+as_matrix'></span>

<h3>Description</h3>

<p>Attempts to turn a dgCMatrix into a dense matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_matrix_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sparse_matrix &lt;- Matrix::sparseMatrix(
  i = sample(1:200, 50),
  j = sample(1:200, 50),
  x = rnorm(50),
  dims = c(200, 200),
  dimnames = list(
    paste0("a", rep(1:200)),
    paste0("b", rep(1:200))
  )
)

identical(
  as.matrix(sparse_matrix),
  as_matrix(sparse_matrix)
)
</code></pre>

<hr>
<h2 id='auc.calculate'>AUC value calculate</h2><span id='topic+auc.calculate'></span>

<h3>Description</h3>

<p>AUC value calculate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc.calculate(
  network_table,
  ground_truth,
  plot = FALSE,
  line_color = "#1563cc",
  line_width = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc.calculate_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network</p>
</td></tr>
<tr><td><code id="auc.calculate_+3A_ground_truth">ground_truth</code></td>
<td>
<p>Ground truth for calculate AUC</p>
</td></tr>
<tr><td><code id="auc.calculate_+3A_plot">plot</code></td>
<td>
<p>If true, draw and print figure of AUC</p>
</td></tr>
<tr><td><code id="auc.calculate_+3A_line_color">line_color</code></td>
<td>
<p>The color of line in the figure</p>
</td></tr>
<tr><td><code id="auc.calculate_+3A_line_width">line_width</code></td>
<td>
<p>The width of line in the figure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AUC values and figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
auc.calculate(network_table, example_ground_truth, plot = TRUE)
</code></pre>

<hr>
<h2 id='calculate.gene.rank'>Calculate and rank TFs in network</h2><span id='topic+calculate.gene.rank'></span>

<h3>Description</h3>

<p>Calculate and rank TFs in network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.gene.rank(
  network_table,
  regulators = NULL,
  targets = NULL,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.gene.rank_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="calculate.gene.rank_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="calculate.gene.rank_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="calculate.gene.rank_+3A_directed">directed</code></td>
<td>
<p>If network is directed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with three columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
head(calculate.gene.rank(network_table))
head(calculate.gene.rank(network_table, regulators = "g1"))
</code></pre>

<hr>
<h2 id='check.parameters'>Check input parameters</h2><span id='topic+check.parameters'></span>

<h3>Description</h3>

<p>Check input parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.parameters(
  matrix,
  penalty,
  algorithm,
  cross_validation,
  seed,
  n_folds,
  percent_samples,
  r_threshold,
  regulators,
  targets,
  regulators_num,
  verbose,
  cores,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.parameters_+3A_matrix">matrix</code></td>
<td>
<p>An expression matrix, cells by genes</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization.
This can take either one of the following choices: <code>L0</code> and <code>L0L2</code>.
For high-dimensional and sparse data, such as single-cell sequencing data, <code>L0L2</code> is more effective.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function.
Currently <code>CD</code> and <code>CDPSI</code> are supported.
The <code>CDPSI</code> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Check whether cross validation is used.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_seed">seed</code></td>
<td>
<p>The seed used in randomly shuffling the data for cross-validation.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse.regression">sparse.regression</a></code>. Default set to 1.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_regulators">regulators</code></td>
<td>
<p>A character vector with the regulators to consider for CSN inference.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_targets">targets</code></td>
<td>
<p>A character vector with the targets to consider for CSN inference.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_verbose">verbose</code></td>
<td>
<p>Print detailed information.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores used. Setting to parallelize the computation with <code><a href="foreach.html#topic+foreach">foreach</a></code>.</p>
</td></tr>
<tr><td><code id="check.parameters_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Not return value, called for check input parameters
</p>

<hr>
<h2 id='coef.SRM_fit'>Extracts a specific solution in the regularization path</h2><span id='topic+coef.SRM_fit'></span><span id='topic+coef.SRM_fit_CV'></span>

<h3>Description</h3>

<p>Extracts a specific solution in the regularization path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SRM_fit'
coef(object, lambda = NULL, gamma = NULL, supportSize = NULL, ...)

## S3 method for class 'SRM_fit_CV'
coef(object, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.SRM_fit_+3A_object">object</code></td>
<td>
<p>The output of model.fit or inferCSN.cvfit</p>
</td></tr>
<tr><td><code id="coef.SRM_fit_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda at which to extract the solution</p>
</td></tr>
<tr><td><code id="coef.SRM_fit_+3A_gamma">gamma</code></td>
<td>
<p>The value of gamma at which to extract the solution</p>
</td></tr>
<tr><td><code id="coef.SRM_fit_+3A_supportsize">supportSize</code></td>
<td>
<p>The number of non-zeros each solution extracted will contain</p>
</td></tr>
<tr><td><code id="coef.SRM_fit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the specific solution
</p>
<p>Return the specific solution
</p>

<hr>
<h2 id='example_ground_truth'>Example ground truth data</h2><span id='topic+example_ground_truth'></span>

<h3>Description</h3>

<p>The data used for calculate the evaluating indicator.
</p>

<hr>
<h2 id='example_matrix'>Example matrix data</h2><span id='topic+example_matrix'></span>

<h3>Description</h3>

<p>The matrix used for reconstruct gene regulatory network.
</p>

<hr>
<h2 id='example_meta_data'>Example meta data</h2><span id='topic+example_meta_data'></span>

<h3>Description</h3>

<p>The data contains cells and pseudotime information.
</p>

<hr>
<h2 id='filter_sort_matrix'>Filter and sort matrix</h2><span id='topic+filter_sort_matrix'></span>

<h3>Description</h3>

<p>Filter and sort matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_sort_matrix(weight_matrix, regulators = NULL, targets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_sort_matrix_+3A_weight_matrix">weight_matrix</code></td>
<td>
<p>The matrix of network weight.</p>
</td></tr>
<tr><td><code id="filter_sort_matrix_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="filter_sort_matrix_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered and sorted matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(inferCSN)
data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
weight_matrix &lt;- table.to.matrix(network_table)
filter_sort_matrix(weight_matrix)[1:6, 1:6]

filter_sort_matrix(
  weight_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
</code></pre>

<hr>
<h2 id='inferCSN'>Inferring Cell-Specific Gene Regulatory Network</h2><span id='topic+inferCSN'></span><span id='topic+inferCSN+2Cmatrix-method'></span><span id='topic+inferCSN+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Inferring Cell-Specific Gene Regulatory Network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = FALSE,
  ...
)

## S4 method for signature 'matrix'
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = FALSE,
  ...
)

## S4 method for signature 'data.frame'
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferCSN_+3A_object">object</code></td>
<td>
<p>The input data for <code>inferCSN</code>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization.
This can take either one of the following choices: <code>L0</code> and <code>L0L2</code>.
For high-dimensional and sparse data, such as single-cell sequencing data, <code>L0L2</code> is more effective.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function.
Currently <code>CD</code> and <code>CDPSI</code> are supported.
The <code>CDPSI</code> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Check whether cross validation is used.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_seed">seed</code></td>
<td>
<p>The seed used in randomly shuffling the data for cross-validation.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse.regression">sparse.regression</a></code>. Default set to 1.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_regulators">regulators</code></td>
<td>
<p>A character vector with the regulators to consider for CSN inference.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_targets">targets</code></td>
<td>
<p>A character vector with the targets to consider for CSN inference.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores used. Setting to parallelize the computation with <code><a href="foreach.html#topic+foreach">foreach</a></code>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_verbose">verbose</code></td>
<td>
<p>Print detailed information.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table of gene-gene regulatory relationship
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix, verbose = TRUE)
head(network_table)

network_table &lt;- inferCSN(example_matrix, cores = 2)
head(network_table)
</code></pre>

<hr>
<h2 id='model.fit'>Fit a sparse regression model</h2><span id='topic+model.fit'></span>

<h3>Description</h3>

<p>Computes the regularization path for the specified loss function and penalty function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.fit(
  x,
  y,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = NULL,
  cross_validation = FALSE,
  n_folds = 10,
  seed = 1,
  loss = "SquaredError",
  nLambda = 100,
  nGamma = 5,
  gammaMax = 10,
  gammaMin = 1e-04,
  partialSort = TRUE,
  maxIters = 200,
  rtol = 1e-06,
  atol = 1e-09,
  activeSet = TRUE,
  activeSetNum = 3,
  maxSwaps = 100,
  scaleDownFactor = 0.8,
  screenSize = 1000,
  autoLambda = NULL,
  lambdaGrid = list(),
  excludeFirstK = 0,
  intercept = TRUE,
  lows = -Inf,
  highs = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.fit_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="model.fit_+3A_y">y</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="model.fit_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization.
This can take either one of the following choices: <code>L0</code> and <code>L0L2</code>.
For high-dimensional and sparse data, such as single-cell sequencing data, <code>L0L2</code> is more effective.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function.
Currently <code>CD</code> and <code>CDPSI</code> are supported.
The <code>CDPSI</code> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Check whether cross validation is used.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_seed">seed</code></td>
<td>
<p>The seed used in randomly shuffling the data for cross-validation.</p>
</td></tr>
<tr><td><code id="model.fit_+3A_loss">loss</code></td>
<td>
<p>The loss function</p>
</td></tr>
<tr><td><code id="model.fit_+3A_nlambda">nLambda</code></td>
<td>
<p>The number of Lambda values to select</p>
</td></tr>
<tr><td><code id="model.fit_+3A_ngamma">nGamma</code></td>
<td>
<p>The number of Gamma values to select</p>
</td></tr>
<tr><td><code id="model.fit_+3A_gammamax">gammaMax</code></td>
<td>
<p>The maximum value of Gamma when using the L0L2 penalty</p>
</td></tr>
<tr><td><code id="model.fit_+3A_gammamin">gammaMin</code></td>
<td>
<p>The minimum value of Gamma when using the L0L2 penalty</p>
</td></tr>
<tr><td><code id="model.fit_+3A_partialsort">partialSort</code></td>
<td>
<p>If TRUE, partial sorting will be used for sorting the coordinates to do greedy cycling. Otherwise, full sorting is used</p>
</td></tr>
<tr><td><code id="model.fit_+3A_maxiters">maxIters</code></td>
<td>
<p>The maximum number of iterations (full cycles) for CD per grid point</p>
</td></tr>
<tr><td><code id="model.fit_+3A_rtol">rtol</code></td>
<td>
<p>The relative tolerance which decides when to terminate optimization (based on the relative change in the objective between iterations)</p>
</td></tr>
<tr><td><code id="model.fit_+3A_atol">atol</code></td>
<td>
<p>The absolute tolerance which decides when to terminate optimization (based on the absolute L2 norm of the residuals)</p>
</td></tr>
<tr><td><code id="model.fit_+3A_activeset">activeSet</code></td>
<td>
<p>If TRUE, performs active set updates</p>
</td></tr>
<tr><td><code id="model.fit_+3A_activesetnum">activeSetNum</code></td>
<td>
<p>The number of consecutive times a support should appear before declaring support stabilization</p>
</td></tr>
<tr><td><code id="model.fit_+3A_maxswaps">maxSwaps</code></td>
<td>
<p>The maximum number of swaps used by CDPSI for each grid point</p>
</td></tr>
<tr><td><code id="model.fit_+3A_scaledownfactor">scaleDownFactor</code></td>
<td>
<p>This parameter decides how close the selected Lambda values are</p>
</td></tr>
<tr><td><code id="model.fit_+3A_screensize">screenSize</code></td>
<td>
<p>The number of coordinates to cycle over when performing initial correlation screening</p>
</td></tr>
<tr><td><code id="model.fit_+3A_autolambda">autoLambda</code></td>
<td>
<p>Ignored parameter. Kept for backwards compatibility</p>
</td></tr>
<tr><td><code id="model.fit_+3A_lambdagrid">lambdaGrid</code></td>
<td>
<p>A grid of Lambda values to use in computing the regularization path</p>
</td></tr>
<tr><td><code id="model.fit_+3A_excludefirstk">excludeFirstK</code></td>
<td>
<p>This parameter takes non-negative integers</p>
</td></tr>
<tr><td><code id="model.fit_+3A_intercept">intercept</code></td>
<td>
<p>If FALSE, no intercept term is included in the model</p>
</td></tr>
<tr><td><code id="model.fit_+3A_lows">lows</code></td>
<td>
<p>Lower bounds for coefficients</p>
</td></tr>
<tr><td><code id="model.fit_+3A_highs">highs</code></td>
<td>
<p>Upper bounds for coefficients</p>
</td></tr>
<tr><td><code id="model.fit_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object describing the regularization path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
fit &lt;- model.fit(
example_matrix[, -1],
example_matrix[, 1]
)
head(coef(fit))
</code></pre>

<hr>
<h2 id='network_format'>Format weight table</h2><span id='topic+network_format'></span>

<h3>Description</h3>

<p>Format weight table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_format(
  network_table,
  regulators = NULL,
  targets = NULL,
  abs_weight = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_format_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="network_format_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="network_format_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="network_format_+3A_abs_weight">abs_weight</code></td>
<td>
<p>Logical value, whether to perform absolute value on weights,
default set to 'TRUE', and when set 'abs_weight' to 'TRUE',
the output of weight table will create a new column named 'Interaction'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Format weight table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)

network_format(
  network_table,
  regulators = c("g1")
)

network_format(
  network_table,
  regulators = c("g1"),
  abs_weight = FALSE
)

network_format(
  network_table,
  targets = c("g3")
)

network_format(
  network_table,
  regulators = c("g1", "g3"),
  targets = c("g3", "g5")
)
</code></pre>

<hr>
<h2 id='network_sift'>network_sift</h2><span id='topic+network_sift'></span>

<h3>Description</h3>

<p>network_sift
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_sift(
  network_table,
  matrix = NULL,
  meta_data = NULL,
  pseudotime_column = NULL,
  method = c("entropy", "max"),
  entropy_method = c("Shannon", "Renyi"),
  effective_entropy = FALSE,
  shuffles = 100,
  entropy_nboot = 300,
  history_length = 1,
  entropy_p_value = 0.05,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_sift_+3A_network_table">network_table</code></td>
<td>
<p>network_table</p>
</td></tr>
<tr><td><code id="network_sift_+3A_matrix">matrix</code></td>
<td>
<p>The expression matrix.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_meta_data">meta_data</code></td>
<td>
<p>The meta data for cells or samples.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_pseudotime_column">pseudotime_column</code></td>
<td>
<p>The column of pseudotime.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_method">method</code></td>
<td>
<p>method The method used for filter edges. Could be choose <code>"entropy"</code> or <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_method">entropy_method</code></td>
<td>
<p>If setting <code>'method'</code> to <code>'entropy'</code>,
could be choose <code>"Shannon"</code> or <code>"Renyi"</code> to compute entropy.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_effective_entropy">effective_entropy</code></td>
<td>
<p>Logical value, using effective entropy to filter weights or not.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_shuffles">shuffles</code></td>
<td>
<p>The number of shuffles used to calculate the effective transfer entropy. Default is <code>'shuffles'</code> = 100.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_nboot">entropy_nboot</code></td>
<td>
<p>entropy_nboot</p>
</td></tr>
<tr><td><code id="network_sift_+3A_history_length">history_length</code></td>
<td>
<p>history_length</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_p_value">entropy_p_value</code></td>
<td>
<p>P value.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores used. Setting to parallelize the computation with <code><a href="foreach.html#topic+foreach">foreach</a></code>.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_verbose">verbose</code></td>
<td>
<p>Print detailed information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered network table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
network_table_filtered &lt;- network_sift(network_table)
data("example_meta_data")
network_table_filtered_entropy &lt;- network_sift(
  network_table,
  matrix = example_matrix,
  meta_data = example_meta_data,
  pseudotime_column = "pseudotime",
  history_length = 2,
  shuffles = 0,
  entropy_nboot = 0
)

network.heatmap(
  example_ground_truth[, 1:3],
  heatmap_title = "Ground truth",
  show_names = TRUE,
  rect_color = "gray70"
)
network.heatmap(
  network_table,
  heatmap_title = "Raw",
  show_names = TRUE,
  rect_color = "gray70"
)
network.heatmap(
  network_table_filtered,
  heatmap_title = "Filtered",
  show_names = TRUE,
  rect_color = "gray70"
)
network.heatmap(
  network_table_filtered_entropy,
  heatmap_title = "Filtered by entropy",
  show_names = TRUE,
  rect_color = "gray70"
)

auc.calculate(
  network_table,
  example_ground_truth,
  plot = TRUE
)
auc.calculate(
  network_table_filtered,
  example_ground_truth,
  plot = TRUE
)
auc.calculate(
  network_table_filtered_entropy,
  example_ground_truth,
  plot = TRUE
)
</code></pre>

<hr>
<h2 id='network.heatmap'>The heatmap of network</h2><span id='topic+network.heatmap'></span>

<h3>Description</h3>

<p>The heatmap of network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.heatmap(
  network_table,
  regulators = NULL,
  targets = NULL,
  switch_matrix = TRUE,
  show_names = FALSE,
  heatmap_size_lock = TRUE,
  heatmap_size = 5,
  heatmap_height = NULL,
  heatmap_width = NULL,
  heatmap_title = NULL,
  heatmap_color = c("#1966ad", "white", "#bb141a"),
  border_color = "gray",
  rect_color = NA,
  anno_width = 1,
  anno_height = 1,
  row_anno_type = NULL,
  column_anno_type = NULL,
  legend_name = "Weight",
  row_title = "Regulators"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.heatmap_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_switch_matrix">switch_matrix</code></td>
<td>
<p>Logical value, default set to 'TRUE', whether to weight data table to matrix.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_show_names">show_names</code></td>
<td>
<p>Logical value, default set to 'FALSE', whether to show names of row and column.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_size_lock">heatmap_size_lock</code></td>
<td>
<p>Lock the size of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_size">heatmap_size</code></td>
<td>
<p>Default set to 5. The size of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_height">heatmap_height</code></td>
<td>
<p>The height of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_width">heatmap_width</code></td>
<td>
<p>The width of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_title">heatmap_title</code></td>
<td>
<p>The title of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_heatmap_color">heatmap_color</code></td>
<td>
<p>Colors of heatmap.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_border_color">border_color</code></td>
<td>
<p>Default set to 'gray'. Color of heatmap border.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_rect_color">rect_color</code></td>
<td>
<p>Default set to 'NA'. Color of heatmap rect.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_anno_width">anno_width</code></td>
<td>
<p>Width of annotation.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_anno_height">anno_height</code></td>
<td>
<p>Height of annotation.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_row_anno_type">row_anno_type</code></td>
<td>
<p>Default set to 'NULL'. c(&quot;boxplot&quot;, &quot;barplot&quot;, &quot;histogram&quot;, &quot;density&quot;, &quot;lines&quot;, &quot;points&quot;, &quot;horizon&quot;)</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_column_anno_type">column_anno_type</code></td>
<td>
<p>Default set to 'NULL'. c(&quot;boxplot&quot;, &quot;barplot&quot;, &quot;histogram&quot;, &quot;density&quot;, &quot;lines&quot;, &quot;points&quot;)</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_legend_name">legend_name</code></td>
<td>
<p>The name of legend.</p>
</td></tr>
<tr><td><code id="network.heatmap_+3A_row_title">row_title</code></td>
<td>
<p>The title of row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a heatmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)

p1 &lt;- network.heatmap(
  example_ground_truth[, 1:3],
  heatmap_title = "Ground truth",
  legend_name = "Ground truth"
)
p2 &lt;- network.heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "inferCSN"
)
ComplexHeatmap::draw(p1 + p2)

p3 &lt;- network.heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "Weight1",
  heatmap_color = c("#20a485", "#410054", "#fee81f")
)
p4 &lt;- network.heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "Weight2",
  heatmap_color = c("#20a485", "white", "#fee81f")
)
ComplexHeatmap::draw(p3 + p4)

network.heatmap(
  network_table,
  show_names = TRUE,
  rect_color = "gray90",
  row_anno_type = "density",
  column_anno_type = "barplot"
)

network.heatmap(
  network_table,
  regulators = c("g1", "g2"),
  show_names = TRUE
)

network.heatmap(
  network_table,
  targets = c("g1", "g2"),
  row_anno_type = "boxplot",
  column_anno_type = "histogram",
  show_names = TRUE
)

network.heatmap(
  network_table,
  regulators = c("g1", "g3", "g5"),
  targets = c("g3", "g6", "g9"),
  show_names = TRUE
)
</code></pre>

<hr>
<h2 id='normalization'>normalization</h2><span id='topic+normalization'></span>

<h3>Description</h3>

<p>normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalization(x, method = "max_min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalization_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="normalization_+3A_method">method</code></td>
<td>
<p>Method for normalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized vector
</p>

<hr>
<h2 id='parallelize_fun'>Apply function over a List or Vector</h2><span id='topic+parallelize_fun'></span>

<h3>Description</h3>

<p>Apply function over a List or Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelize_fun(x, fun, cores = 1, export_fun = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallelize_fun_+3A_x">x</code></td>
<td>
<p>A vector or list to apply over.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_fun">fun</code></td>
<td>
<p>The function to be applied to each element.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_cores">cores</code></td>
<td>
<p>cores.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_export_fun">export_fun</code></td>
<td>
<p>export_fun.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to print progress bar.
Only works in sequential mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

<hr>
<h2 id='plot_contrast_networks'>plot_contrast_networks</h2><span id='topic+plot_contrast_networks'></span>

<h3>Description</h3>

<p>plot_contrast_networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_contrast_networks(
  network_table,
  degree_value = 0,
  weight_value = 0,
  legend_position = "bottom"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_contrast_networks_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_degree_value">degree_value</code></td>
<td>
<p>degree_value</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_weight_value">weight_value</code></td>
<td>
<p>weight_value</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
plot_contrast_networks(network_table[1:50, ])
</code></pre>

<hr>
<h2 id='plot_dynamic_networks'>plot_dynamic_networks</h2><span id='topic+plot_dynamic_networks'></span>

<h3>Description</h3>

<p>plot_dynamic_networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dynamic_networks(
  network_table,
  celltypes_order,
  ntop = 10,
  width = 6,
  height = 6,
  seed = 2024,
  theme_type = "theme_void",
  plot_type = "ggplot",
  layout = "fruchtermanreingold",
  nrow = 2,
  title = NULL,
  figure_save = FALSE,
  figure_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dynamic_networks_+3A_network_table">network_table</code></td>
<td>
<p>network_table</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_celltypes_order">celltypes_order</code></td>
<td>
<p>celltypes_order</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_ntop">ntop</code></td>
<td>
<p>ntop</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_width">width</code></td>
<td>
<p>width</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_height">height</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_seed">seed</code></td>
<td>
<p>seed</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_theme_type">theme_type</code></td>
<td>
<p>theme_type</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_plot_type">plot_type</code></td>
<td>
<p>plot_type</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_layout">layout</code></td>
<td>
<p>layout</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_nrow">nrow</code></td>
<td>
<p>nrow</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_title">title</code></td>
<td>
<p>The title of figure.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_save">figure_save</code></td>
<td>
<p>figure_save</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_name">figure_name</code></td>
<td>
<p>figure_name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network &lt;- inferCSN(example_matrix)[1:100, ]
network$celltype &lt;- c(
  rep("cluster5", 20),
  rep("cluster1", 20),
  rep("cluster3", 20),
  rep("cluster2", 20),
  rep("cluster6", 20)
)

celltypes_order &lt;- c(
  "cluster5", "cluster3",
  "cluster2", "cluster1",
  "cluster6"
)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order
)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order[1:3]
)

## Not run: 
# If setting `plot_type = "animate"` to plot and save `gif` figure,
# please install `gifski` package first.
plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order,
  plot_type = "animate"
)

## End(Not run)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order,
  plot_type = "ggplotly"
)
</code></pre>

<hr>
<h2 id='plot_scatter'>plot_scatter</h2><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>plot_scatter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scatter(
  data,
  smoothing_method = "lm",
  group_colors = RColorBrewer::brewer.pal(9, "Set1"),
  title_color = "black",
  title = NULL,
  col_title = NULL,
  row_title = NULL,
  legend_title = NULL,
  legend_position = "bottom",
  margins = "both",
  marginal_type = NULL,
  margins_size = 10,
  compute_correlation = TRUE,
  compute_correlation_method = "pearson",
  keep_aspect_ratio = FALSE,
  facet = FALSE,
  se = FALSE,
  pointdensity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scatter_+3A_data">data</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_smoothing_method">smoothing_method</code></td>
<td>
<p>Method for smoothing curve, &quot;lm&quot; or &quot;loess&quot;.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_group_colors">group_colors</code></td>
<td>
<p>Colors for different groups.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_title_color">title_color</code></td>
<td>
<p>Color for the title.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_title">title</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_col_title">col_title</code></td>
<td>
<p>Title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_row_title">row_title</code></td>
<td>
<p>Title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_legend_title">legend_title</code></td>
<td>
<p>Title for the legend.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_margins">margins</code></td>
<td>
<p>The position of marginal figure (&quot;both&quot;, &quot;x&quot;, &quot;y&quot;).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_marginal_type">marginal_type</code></td>
<td>
<p>The type of marginal figure (&quot;density&quot;, &quot;histogram&quot;, &quot;boxplot&quot;, &quot;violin&quot;, &quot;densigram&quot;).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_margins_size">margins_size</code></td>
<td>
<p>The size of marginal figure, note the bigger size the smaller figure.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_compute_correlation">compute_correlation</code></td>
<td>
<p>Whether to compute and print correlation on the figure.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_compute_correlation_method">compute_correlation_method</code></td>
<td>
<p>Method to compute correlation (&quot;pearson&quot; or &quot;spearman&quot;).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>Logical value, whether to set aspect ratio to 1:1.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_facet">facet</code></td>
<td>
<p>Faceting variable. If setting TRUE, all settings about margins will be inalidation.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_se">se</code></td>
<td>
<p>Display confidence interval around smooth.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_pointdensity">pointdensity</code></td>
<td>
<p>Plot point density when only provide 1 cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
test_data &lt;- data.frame(
  example_matrix[1:200, c(1, 7)],
  c = c(
    rep("c1", 40),
    rep("c2", 40),
    rep("c3", 40),
    rep("c4", 40),
    rep("c5", 40)
  )
)

p1 &lt;- plot_scatter(
  test_data,
  keep_aspect_ratio = TRUE
)
p2 &lt;- plot_scatter(
  test_data,
  marginal_type = "boxplot",
  keep_aspect_ratio = TRUE
)
p1 + p2

p3 &lt;- plot_scatter(
  test_data,
  facet = TRUE,
  keep_aspect_ratio = TRUE
)
p3

p4 &lt;- plot_scatter(
  test_data[, 1:2],
  marginal_type = "histogram",
  keep_aspect_ratio = TRUE
)
p4
</code></pre>

<hr>
<h2 id='plot_static_networks'>Plot of dynamic networks</h2><span id='topic+plot_static_networks'></span>

<h3>Description</h3>

<p>Plot of dynamic networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_static_networks(
  network_table,
  regulators = NULL,
  targets = NULL,
  legend_position = "right"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_static_networks_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot2 objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
plot_static_networks(
  network_table,
  regulators = network_table[1, 1]
)
plot_static_networks(
  network_table,
  targets = network_table[1, 1]
)
plot_static_networks(
  network_table,
  regulators = network_table[1, 1],
  targets = network_table[1, 2]
)
</code></pre>

<hr>
<h2 id='predict.SRM_fit'>Predict Response</h2><span id='topic+predict.SRM_fit'></span><span id='topic+predict.SRM_fit_CV'></span>

<h3>Description</h3>

<p>Predicts response for a given sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SRM_fit'
predict(object, newx, lambda = NULL, gamma = NULL, ...)

## S3 method for class 'SRM_fit_CV'
predict(object, newx, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SRM_fit_+3A_object">object</code></td>
<td>
<p>The output of model.fit</p>
</td></tr>
<tr><td><code id="predict.SRM_fit_+3A_newx">newx</code></td>
<td>
<p>A matrix on which predictions are made. The matrix should have p columns</p>
</td></tr>
<tr><td><code id="predict.SRM_fit_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda to use for prediction.
A summary of the lambdas in the regularization path can be obtained using <code>print(fit)</code></p>
</td></tr>
<tr><td><code id="predict.SRM_fit_+3A_gamma">gamma</code></td>
<td>
<p>The value of gamma to use for prediction.
A summary of the gammas in the regularization path can be obtained using <code>print(fit)</code></p>
</td></tr>
<tr><td><code id="predict.SRM_fit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both lambda and gamma are not supplied, then a matrix of predictions for all the solutions in the regularization path is returned.
If lambda is supplied but gamma is not, the smallest value of gamma is used.
In case of logistic regression, probability values are returned
</p>


<h3>Value</h3>

<p>Return predict value
</p>
<p>Return the predict value
</p>

<hr>
<h2 id='prepare.performance.data'>prepare.performance.data</h2><span id='topic+prepare.performance.data'></span>

<h3>Description</h3>

<p>prepare.performance.data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.performance.data(network_table, ground_truth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.performance.data_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network</p>
</td></tr>
<tr><td><code id="prepare.performance.data_+3A_ground_truth">ground_truth</code></td>
<td>
<p>Ground truth for calculate AUC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formated data
</p>

<hr>
<h2 id='print.SRM_fit'>Prints a summary of model.fit</h2><span id='topic+print.SRM_fit'></span><span id='topic+print.SRM_fit_CV'></span>

<h3>Description</h3>

<p>Prints a summary of model.fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SRM_fit'
print(x, ...)

## S3 method for class 'SRM_fit_CV'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SRM_fit_+3A_x">x</code></td>
<td>
<p>The output of model.fit or inferCSN.cvfit</p>
</td></tr>
<tr><td><code id="print.SRM_fit_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return information of model.fit
</p>
<p>Return information of model.fit
</p>

<hr>
<h2 id='r_square'><code class="reqn">R^2</code> (coefficient of determination)</h2><span id='topic+r_square'></span>

<h3>Description</h3>

<p><code class="reqn">R^2</code> (coefficient of determination)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_square(y_true, y_pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_square_+3A_y_true">y_true</code></td>
<td>
<p>A numeric vector with ground truth values.</p>
</td></tr>
<tr><td><code id="r_square_+3A_y_pred">y_pred</code></td>
<td>
<p>A numeric vector with predicted values.</p>
</td></tr>
</table>

<hr>
<h2 id='rse'>Relative Squared Error</h2><span id='topic+rse'></span>

<h3>Description</h3>

<p>Relative Squared Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rse(y_true, y_pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rse_+3A_y_true">y_true</code></td>
<td>
<p>A numeric vector with ground truth values.</p>
</td></tr>
<tr><td><code id="rse_+3A_y_pred">y_pred</code></td>
<td>
<p>A numeric vector with predicted values.</p>
</td></tr>
</table>

<hr>
<h2 id='single.network'>Construct network for single gene</h2><span id='topic+single.network'></span>

<h3>Description</h3>

<p>Construct network for single gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.network(
  matrix,
  regulators,
  target,
  cross_validation = FALSE,
  seed = 1,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = (ncol(matrix) - 1),
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single.network_+3A_matrix">matrix</code></td>
<td>
<p>An expression matrix, cells by genes.</p>
</td></tr>
<tr><td><code id="single.network_+3A_regulators">regulators</code></td>
<td>
<p>A character vector with the regulators to consider for CSN inference.</p>
</td></tr>
<tr><td><code id="single.network_+3A_target">target</code></td>
<td>
<p>Target gene.</p>
</td></tr>
<tr><td><code id="single.network_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Check whether cross validation is used.</p>
</td></tr>
<tr><td><code id="single.network_+3A_seed">seed</code></td>
<td>
<p>The seed used in randomly shuffling the data for cross-validation.</p>
</td></tr>
<tr><td><code id="single.network_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization.
This can take either one of the following choices: <code>L0</code> and <code>L0L2</code>.
For high-dimensional and sparse data, such as single-cell sequencing data, <code>L0L2</code> is more effective.</p>
</td></tr>
<tr><td><code id="single.network_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function.
Currently <code>CD</code> and <code>CDPSI</code> are supported.
The <code>CDPSI</code> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="single.network_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="single.network_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="single.network_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse.regression">sparse.regression</a></code>. Default set to 1.</p>
</td></tr>
<tr><td><code id="single.network_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient.</p>
</td></tr>
<tr><td><code id="single.network_+3A_verbose">verbose</code></td>
<td>
<p>Print detailed information.</p>
</td></tr>
<tr><td><code id="single.network_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weight data table of sub-network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
single_network &lt;- single.network(
  example_matrix,
  regulators = colnames(example_matrix),
  target = "g1"
)
head(single_network)

single.network(
  example_matrix,
  regulators = "g1",
  target = "g2"
)
</code></pre>

<hr>
<h2 id='sparse.regression'>Sparse regression model</h2><span id='topic+sparse.regression'></span>

<h3>Description</h3>

<p>Sparse regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.regression(
  x,
  y,
  cross_validation = FALSE,
  seed = 1,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = ncol(x),
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  computation_method = "cor",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.regression_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_y">y</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Check whether cross validation is used.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_seed">seed</code></td>
<td>
<p>The seed used in randomly shuffling the data for cross-validation.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization.
This can take either one of the following choices: <code>L0</code> and <code>L0L2</code>.
For high-dimensional and sparse data, such as single-cell sequencing data, <code>L0L2</code> is more effective.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function.
Currently <code>CD</code> and <code>CDPSI</code> are supported.
The <code>CDPSI</code> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse.regression">sparse.regression</a></code>. Default set to 1.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_computation_method">computation_method</code></td>
<td>
<p>The method used to compute <code>r</code>.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_verbose">verbose</code></td>
<td>
<p>Print detailed information.</p>
</td></tr>
<tr><td><code id="sparse.regression_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
sparse.regression(
  example_matrix[, -1],
  example_matrix[, 1]
)
</code></pre>

<hr>
<h2 id='sse'>Sum of Squared Errors</h2><span id='topic+sse'></span>

<h3>Description</h3>

<p>Sum of Squared Errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse(y_true, y_pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sse_+3A_y_true">y_true</code></td>
<td>
<p>A numeric vector with ground truth values.</p>
</td></tr>
<tr><td><code id="sse_+3A_y_pred">y_pred</code></td>
<td>
<p>A numeric vector with predicted values.</p>
</td></tr>
</table>

<hr>
<h2 id='table.to.matrix'>Switch weight table to matrix</h2><span id='topic+table.to.matrix'></span>

<h3>Description</h3>

<p>Switch weight table to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.to.matrix(network_table, regulators = NULL, targets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.to.matrix_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="table.to.matrix_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="table.to.matrix_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weight matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
head(network_table)

table.to.matrix(network_table)[1:6, 1:6]

table.to.matrix(
  network_table,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
