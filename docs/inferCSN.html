<!DOCTYPE html><html lang="en-US"><head><title>Help for package inferCSN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inferCSN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inferCSN-package'><p><em><strong>inferCSN</strong></em>: <strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork</p></a></li>
<li><a href='#as_matrix'><p>Convert dgCMatrix into a dense matrix</p></a></li>
<li><a href='#calculate_acc'><p>Calculate accuracy value</p></a></li>
<li><a href='#calculate_auc'><p>Calculate AUPRC and AUROC values</p></a></li>
<li><a href='#calculate_gene_rank'><p>Rank TFs and genes in network</p></a></li>
<li><a href='#check_sparsity'><p>Check sparsity of matrix</p></a></li>
<li><a href='#coef.srm'><p>Extracts a specific solution in the regularization path</p></a></li>
<li><a href='#example_ground_truth'><p>Example ground truth data</p></a></li>
<li><a href='#example_matrix'><p>Example matrix data</p></a></li>
<li><a href='#example_meta_data'><p>Example meta data</p></a></li>
<li><a href='#filter_sort_matrix'><p>Filter and sort matrix</p></a></li>
<li><a href='#fit_sparse_regression'><p>Fit a sparse regression model</p></a></li>
<li><a href='#inferCSN'><p><strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork</p></a></li>
<li><a href='#log_message'><p>Print diagnostic message</p></a></li>
<li><a href='#network_format'><p>Format network table</p></a></li>
<li><a href='#network_sift'><p>Sifting network</p></a></li>
<li><a href='#normalization'><p>Normalize numeric vector</p></a></li>
<li><a href='#parallelize_fun'><p>Parallelize a function</p></a></li>
<li><a href='#plot_contrast_networks'><p>Plot contrast networks</p></a></li>
<li><a href='#plot_dynamic_networks'><p>Plot dynamic networks</p></a></li>
<li><a href='#plot_embedding'><p>Plot embedding</p></a></li>
<li><a href='#plot_network_heatmap'><p>Plot network heatmap</p></a></li>
<li><a href='#plot_scatter'><p>Plot expression data in a scatter plot</p></a></li>
<li><a href='#plot_static_networks'><p>Plot dynamic networks</p></a></li>
<li><a href='#plot_weight_distribution'><p>Plot weight distribution</p></a></li>
<li><a href='#predict.srm'><p>Predicts response for a given sample</p></a></li>
<li><a href='#print.srm'><p>Prints a summary of <code>fit_sparse_regression</code></p></a></li>
<li><a href='#r_square'><p><code class="reqn">R^2</code> (coefficient of determination)</p></a></li>
<li><a href='#single_network'><p>Construct network for single target gene</p></a></li>
<li><a href='#sparse_regression'><p>Sparse regression model</p></a></li>
<li><a href='#table_to_matrix'><p>Switch network table to matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferring Cell-Specific Gene Regulatory Network</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-8-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Meng Xu &lt;mengxu98@qq.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R package for inferring cell-type specific gene regulatory network from single-cell RNA data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mengxu98.github.io/inferCSN/">https://mengxu98.github.io/inferCSN/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mengxu98/inferCSN/issues">https://github.com/mengxu98/inferCSN/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, doParallel, foreach, ggnetwork, ggplot2, ggraph,
Matrix, methods, parallel, patchwork, pbapply, purrr, Rcpp,
RcppArmadillo, RcppParallel, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ComplexHeatmap, circlize, gtools, gganimate, ggExtra,
ggpointdensity, ggpubr, igraph, network, plotly, precrec, pROC,
testthat (&ge; 3.0.0), tidygraph, RColorBrewer, Rtsne,
RTransferEntropy, uwot, viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>mengxu98/mxtemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-24 04:17:08 UTC; mx</td>
</tr>
<tr>
<td>Author:</td>
<td>Meng Xu <a href="https://orcid.org/0000-0002-8300-1054"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-24 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='inferCSN-package'><em><strong>inferCSN</strong></em>: <strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork</h2><span id='topic+inferCSN-package'></span>

<h3>Description</h3>

<p>An R package for <strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork from single-cell RNA data
</p>


<h3>Author(s)</h3>

<p>Meng xu (Maintainer), <a href="mailto:mengxu98@qq.com">mengxu98@qq.com</a>
</p>


<h3>Source</h3>

<p><a href="https://github.com/mengxu98/inferCSN">https://github.com/mengxu98/inferCSN</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mengxu98.github.io/inferCSN/">https://mengxu98.github.io/inferCSN/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mengxu98/inferCSN/issues">https://github.com/mengxu98/inferCSN/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_matrix'>Convert dgCMatrix into a dense matrix</h2><span id='topic+as_matrix'></span>

<h3>Description</h3>

<p>Convert dgCMatrix into a dense matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_matrix(x, parallel = FALSE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_matrix_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="as_matrix_+3A_parallel">parallel</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>.
Setting to parallelize the computation with <code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>.</p>
</td></tr>
<tr><td><code id="as_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to output a sparse matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dims_i &lt;- 2000
dims_j &lt;- 2000
sparse_matrix &lt;- Matrix::sparseMatrix(
  i = sample(1:dims_i, 500),
  j = sample(1:dims_j, 500),
  x = rnorm(500),
  dims = c(dims_i, dims_j),
  dimnames = list(
    paste0("a", rep(1:dims_i)),
    paste0("b", rep(1:dims_j))
  )
)

system.time(as.matrix(sparse_matrix))
system.time(as_matrix(sparse_matrix))
system.time(as_matrix(sparse_matrix, parallel = TRUE))

identical(
  as.matrix(sparse_matrix),
  as_matrix(sparse_matrix)
)

identical(
  as.matrix(sparse_matrix),
  as_matrix(sparse_matrix, parallel = TRUE)
)

identical(
  sparse_matrix,
  as_matrix(as.matrix(sparse_matrix), sparse = TRUE)
)

## Not run: 
network_table_1 &lt;- inferCSN(
  as_matrix(example_matrix, sparse = TRUE)
)
network_table_2 &lt;- inferCSN(
  as(example_matrix, "sparseMatrix")
)

plot_scatter(
  data.frame(
    network_table_1$weight,
    network_table_2$weight
  ),
  legend_position = "none"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='calculate_acc'>Calculate accuracy value</h2><span id='topic+calculate_acc'></span>

<h3>Description</h3>

<p>Calculate accuracy value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_acc(network_table, ground_truth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_acc_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network</p>
</td></tr>
<tr><td><code id="calculate_acc_+3A_ground_truth">ground_truth</code></td>
<td>
<p>Ground truth for calculate AUC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ACC value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
calculate_acc(network_table, example_ground_truth)
</code></pre>

<hr>
<h2 id='calculate_auc'>Calculate AUPRC and AUROC values</h2><span id='topic+calculate_auc'></span>

<h3>Description</h3>

<p>Calculate AUPRC and AUROC values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_auc(
  network_table,
  ground_truth,
  plot = FALSE,
  line_color = "#1563cc",
  line_width = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_auc_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network</p>
</td></tr>
<tr><td><code id="calculate_auc_+3A_ground_truth">ground_truth</code></td>
<td>
<p>Ground truth for calculate AUC</p>
</td></tr>
<tr><td><code id="calculate_auc_+3A_plot">plot</code></td>
<td>
<p>If true, draw and print figure of AUC</p>
</td></tr>
<tr><td><code id="calculate_auc_+3A_line_color">line_color</code></td>
<td>
<p>The color of line in the figure</p>
</td></tr>
<tr><td><code id="calculate_auc_+3A_line_width">line_width</code></td>
<td>
<p>The width of line in the figure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AUC values and figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
calculate_auc(network_table, example_ground_truth, plot = TRUE)
</code></pre>

<hr>
<h2 id='calculate_gene_rank'>Rank TFs and genes in network</h2><span id='topic+calculate_gene_rank'></span>

<h3>Description</h3>

<p>Rank TFs and genes in network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_gene_rank(
  network_table,
  regulators = NULL,
  targets = NULL,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_gene_rank_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="calculate_gene_rank_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="calculate_gene_rank_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="calculate_gene_rank_+3A_directed">directed</code></td>
<td>
<p>Whether the network is directed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of gene rank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
head(calculate_gene_rank(network_table))
head(calculate_gene_rank(network_table, regulators = "g1"))
head(calculate_gene_rank(network_table, targets = "g1"))
</code></pre>

<hr>
<h2 id='check_sparsity'>Check sparsity of matrix</h2><span id='topic+check_sparsity'></span>

<h3>Description</h3>

<p>Check sparsity of matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sparsity(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sparsity_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparsity of matrix
</p>

<hr>
<h2 id='coef.srm'>Extracts a specific solution in the regularization path</h2><span id='topic+coef.srm'></span><span id='topic+coef.srm_cv'></span>

<h3>Description</h3>

<p>Extracts a specific solution in the regularization path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srm'
coef(object, lambda = NULL, gamma = NULL, regulators_num = NULL, ...)

## S3 method for class 'srm_cv'
coef(object, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.srm_+3A_object">object</code></td>
<td>
<p>The output of <code><a href="#topic+fit_sparse_regression">fit_sparse_regression</a></code>.</p>
</td></tr>
<tr><td><code id="coef.srm_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda at which to extract the solution.</p>
</td></tr>
<tr><td><code id="coef.srm_+3A_gamma">gamma</code></td>
<td>
<p>The value of gamma at which to extract the solution.</p>
</td></tr>
<tr><td><code id="coef.srm_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="coef.srm_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the specific solution
</p>

<hr>
<h2 id='example_ground_truth'>Example ground truth data</h2><span id='topic+example_ground_truth'></span>

<h3>Description</h3>

<p>The data used for calculate the evaluating indicator.
</p>

<hr>
<h2 id='example_matrix'>Example matrix data</h2><span id='topic+example_matrix'></span>

<h3>Description</h3>

<p>The matrix used for reconstruct gene regulatory network.
</p>

<hr>
<h2 id='example_meta_data'>Example meta data</h2><span id='topic+example_meta_data'></span>

<h3>Description</h3>

<p>The data contains cells and pseudotime information.
</p>

<hr>
<h2 id='filter_sort_matrix'>Filter and sort matrix</h2><span id='topic+filter_sort_matrix'></span>

<h3>Description</h3>

<p>Filter and sort matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_sort_matrix(network_matrix, regulators = NULL, targets = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_sort_matrix_+3A_network_matrix">network_matrix</code></td>
<td>
<p>The matrix of network weight.</p>
</td></tr>
<tr><td><code id="filter_sort_matrix_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="filter_sort_matrix_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered and sorted matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
network_matrix &lt;- table_to_matrix(network_table)
filter_sort_matrix(network_matrix)[1:6, 1:6]

filter_sort_matrix(
  network_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
</code></pre>

<hr>
<h2 id='fit_sparse_regression'>Fit a sparse regression model</h2><span id='topic+fit_sparse_regression'></span>

<h3>Description</h3>

<p>Computes the regularization path for the specified loss function and penalty function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sparse_regression(
  x,
  y,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = ncol(x),
  cross_validation = FALSE,
  n_folds = 10,
  seed = 1,
  loss = "SquaredError",
  nLambda = 100,
  nGamma = 5,
  gammaMax = 10,
  gammaMin = 1e-04,
  partialSort = TRUE,
  maxIters = 200,
  rtol = 1e-06,
  atol = 1e-09,
  activeSet = TRUE,
  activeSetNum = 3,
  maxSwaps = 100,
  scaleDownFactor = 0.8,
  screenSize = 1000,
  autoLambda = NULL,
  lambdaGrid = list(),
  excludeFirstK = 0,
  intercept = TRUE,
  lows = -Inf,
  highs = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_sparse_regression_+3A_x">x</code></td>
<td>
<p>The matrix of regulators.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_y">y</code></td>
<td>
<p>The vector of target.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization, default is <em><code>L0</code></em>.
This can take either one of the following choices: <em><code>L0</code></em>, <em><code>L0L1</code></em>, and <em><code>L0L2</code></em>.
For high-dimensional and sparse data, <em><code>L0L2</code></em> is more effective.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function, default is <em><code>CD</code></em>.
Currently <em><code>CD</code></em> and <em><code>CDPSI</code></em> are supported.
The <em><code>CDPSI</code></em> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to use cross-validation.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation, default is <em><code>10</code></em>.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_seed">seed</code></td>
<td>
<p>The random seed for cross-validation, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_loss">loss</code></td>
<td>
<p>The loss function.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_nlambda">nLambda</code></td>
<td>
<p>The number of Lambda values to select.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_ngamma">nGamma</code></td>
<td>
<p>The number of Gamma values to select.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_gammamax">gammaMax</code></td>
<td>
<p>The maximum value of Gamma when using the <code>L0L2</code> penalty.
For the <code>L0L1</code> penalty this is automatically selected.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_gammamin">gammaMin</code></td>
<td>
<p>The minimum value of Gamma when using the <code>L0L2</code> penalty.
For the <code>L0L1</code> penalty, the minimum value of gamma in the grid is set to gammaMin * gammaMax.
Note that this should be a strictly positive quantity.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_partialsort">partialSort</code></td>
<td>
<p>If <code>TRUE</code>, partial sorting will be used for sorting the coordinates to do greedy cycling.
Otherwise, full sorting is used.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_maxiters">maxIters</code></td>
<td>
<p>The maximum number of iterations (full cycles) for <code>CD</code> per grid point.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_rtol">rtol</code></td>
<td>
<p>The relative tolerance which decides when to terminate optimization,
based on the relative change in the objective between iterations.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_atol">atol</code></td>
<td>
<p>The absolute tolerance which decides when to terminate optimization,
based on the absolute L2 norm of the residuals.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_activeset">activeSet</code></td>
<td>
<p>If <code>TRUE</code>, performs active set updates.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_activesetnum">activeSetNum</code></td>
<td>
<p>The number of consecutive times a support should appear before declaring support stabilization.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_maxswaps">maxSwaps</code></td>
<td>
<p>The maximum number of swaps used by <code>CDPSI</code> for each grid point.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_scaledownfactor">scaleDownFactor</code></td>
<td>
<p>This parameter decides how close the selected Lambda values are.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_screensize">screenSize</code></td>
<td>
<p>The number of coordinates to cycle over when performing initial correlation screening.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_autolambda">autoLambda</code></td>
<td>
<p>Ignored parameter. Kept for backwards compatibility.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_lambdagrid">lambdaGrid</code></td>
<td>
<p>A grid of Lambda values to use in computing the regularization path.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_excludefirstk">excludeFirstK</code></td>
<td>
<p>This parameter takes non-negative integers.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_intercept">intercept</code></td>
<td>
<p>If <code>FALSE</code>, no intercept term is included in the model.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_lows">lows</code></td>
<td>
<p>Lower bounds for coefficients.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_highs">highs</code></td>
<td>
<p>Upper bounds for coefficients.</p>
</td></tr>
<tr><td><code id="fit_sparse_regression_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object describing the regularization path
</p>


<h3>References</h3>

<p>Hazimeh, Hussein et al.
“L0Learn: A Scalable Package for Sparse Learning using L0 Regularization.”
J. Mach. Learn. Res. 24 (2022): 205:1-205:8.
</p>
<p>Hazimeh, Hussein and Rahul Mazumder.
“Fast Best Subset Selection: Coordinate Descent and Local Combinatorial Optimization Algorithms.”
Oper. Res. 68 (2018): 1517-1537.
</p>
<p>https://github.com/hazimehh/L0Learn/blob/master/R/fit.R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
fit &lt;- fit_sparse_regression(
  example_matrix[, -1],
  example_matrix[, 1]
)
head(coef(fit))
</code></pre>

<hr>
<h2 id='inferCSN'><strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork</h2><span id='topic+inferCSN'></span><span id='topic+inferCSN+2Cmatrix-method'></span><span id='topic+inferCSN+2CsparseMatrix-method'></span><span id='topic+inferCSN+2Cdata.frame-method'></span>

<h3>Description</h3>

<p><strong>infer</strong>ring <strong>C</strong>ell-<strong>S</strong>pecific gene regulatory <strong>N</strong>etwork
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

## S4 method for signature 'matrix'
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

## S4 method for signature 'sparseMatrix'
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)

## S4 method for signature 'data.frame'
inferCSN(
  object,
  penalty = "L0",
  algorithm = "CD",
  cross_validation = FALSE,
  seed = 1,
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  regulators = NULL,
  targets = NULL,
  regulators_num = NULL,
  cores = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferCSN_+3A_object">object</code></td>
<td>
<p>The input data for <em><code>inferCSN</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization, default is <em><code>L0</code></em>.
This can take either one of the following choices: <em><code>L0</code></em>, <em><code>L0L1</code></em>, and <em><code>L0L2</code></em>.
For high-dimensional and sparse data, <em><code>L0L2</code></em> is more effective.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function, default is <em><code>CD</code></em>.
Currently <em><code>CD</code></em> and <em><code>CDPSI</code></em> are supported.
The <em><code>CDPSI</code></em> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to use cross-validation.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_seed">seed</code></td>
<td>
<p>The random seed for cross-validation, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation, default is <em><code>10</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse_regression">sparse_regression</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient, default is <em><code>0</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_regulators">regulators</code></td>
<td>
<p>The regulator genes for which to infer the regulatory network.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_targets">targets</code></td>
<td>
<p>The target genes for which to infer the regulatory network.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallelization with <code><a href="foreach.html#topic+foreach">foreach</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to print progress messages.</p>
</td></tr>
<tr><td><code id="inferCSN_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table of regulator-target regulatory relationships
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table_1 &lt;- inferCSN(
  example_matrix
)
head(network_table_1)

network_table_2 &lt;- inferCSN(
  example_matrix,
  cores = 2
)

identical(
  network_table_1,
  network_table_2
)

inferCSN(
  example_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
inferCSN(
  example_matrix,
  regulators = c("g1", "g2"),
  targets = c("g3", "g0")
)
inferCSN(
  example_matrix,
  regulators = c("g1", "g0"),
  targets = c("g2", "g3")
)
inferCSN(
  example_matrix,
  regulators = c("g1"),
  targets = c("g2")
)
## Not run: 
data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
head(network_table)

network_table_sparse_1 &lt;- inferCSN(
  as(example_matrix, "sparseMatrix")
)
head(network_table_sparse_1)

network_table_sparse_2 &lt;- inferCSN(
  as(example_matrix, "sparseMatrix"),
  cores = 2
)
identical(
  network_table,
  network_table_sparse_1
)

identical(
  network_table_sparse_1,
  network_table_sparse_2
)

plot_scatter(
  data.frame(
    network_table$weight,
    network_table_sparse_1$weight
  ),
  legend_position = "none"
)

plot_weight_distribution(
  network_table
) + plot_weight_distribution(
  network_table_sparse_1
)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_message'>Print diagnostic message</h2><span id='topic+log_message'></span>

<h3>Description</h3>

<p>Print diagnostic message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_message(..., verbose = TRUE, message_type = "info", cli_model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_message_+3A_...">...</code></td>
<td>
<p>Text to print.</p>
</td></tr>
<tr><td><code id="log_message_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>.
Whether to print the message.</p>
</td></tr>
<tr><td><code id="log_message_+3A_message_type">message_type</code></td>
<td>
<p>Type of message, default is <em><code>info</code></em>.
Could be choose one of <em><code>info</code></em>, <em><code>warning</code></em>, and <em><code>error</code></em>.</p>
</td></tr>
<tr><td><code id="log_message_+3A_cli_model">cli_model</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>.
Whether to use the <code>cli</code> package to print the message.
Add because the message is printed by <code><a href="base.html#topic+message">message</a></code>,
the message could be suppressed by <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>log_message("Hello, ", "world!")
suppressMessages(log_message("Hello, ", "world!"))
log_message("Hello, world!", verbose = FALSE)
log_message("Hello, world!", verbose = TRUE, message_type = "warning")
</code></pre>

<hr>
<h2 id='network_format'>Format network table</h2><span id='topic+network_format'></span>

<h3>Description</h3>

<p>Format network table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_format(
  network_table,
  regulators = NULL,
  targets = NULL,
  abs_weight = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network_format_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="network_format_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="network_format_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="network_format_+3A_abs_weight">abs_weight</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to perform absolute value on weights,
and when set <code>abs_weight</code> to <em><code>TRUE</code></em>,
the output of weight table will create a new column named <code>Interaction</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formated network table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)

network_format(
  network_table,
  regulators = c("g1")
)

network_format(
  network_table,
  regulators = c("g1"),
  abs_weight = FALSE
)

network_format(
  network_table,
  targets = c("g3")
)

network_format(
  network_table,
  regulators = c("g1", "g3"),
  targets = c("g3", "g5")
)
</code></pre>

<hr>
<h2 id='network_sift'>Sifting network</h2><span id='topic+network_sift'></span>

<h3>Description</h3>

<p>Sifting network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_sift(
  network_table,
  matrix = NULL,
  meta_data = NULL,
  pseudotime_column = NULL,
  method = c("entropy", "max"),
  entropy_method = c("Shannon", "Renyi"),
  effective_entropy = FALSE,
  shuffles = 100,
  entropy_nboot = 300,
  lag_value = 1,
  entropy_p_value = 0.05,
  cores = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network_sift_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_matrix">matrix</code></td>
<td>
<p>The expression matrix.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_meta_data">meta_data</code></td>
<td>
<p>The meta data for cells or samples.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_pseudotime_column">pseudotime_column</code></td>
<td>
<p>The column of pseudotime.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_method">method</code></td>
<td>
<p>The method used for filter edges.
Could be choose <code>entropy</code> or <code>max</code>.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_method">entropy_method</code></td>
<td>
<p>If setting <code>method</code> to <code>entropy</code>,
could be choose <code>Shannon</code> or <code>Renyi</code> to compute entropy.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_effective_entropy">effective_entropy</code></td>
<td>
<p>Default is <code>FALSE</code>.
Logical value, using effective entropy to filter weights or not.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_shuffles">shuffles</code></td>
<td>
<p>Default is <code>100</code>.
The number of shuffles used to calculate the effective transfer entropy.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_nboot">entropy_nboot</code></td>
<td>
<p>Default is <code>300</code>.
The number of bootstrap replications for each direction of the estimated transfer entropy.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_lag_value">lag_value</code></td>
<td>
<p>Default is <code>1</code>.
Markov order of gene expression values,
i.e. the number of lagged values affecting the current value of gene expression values.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_entropy_p_value">entropy_p_value</code></td>
<td>
<p>P value used to filter edges by entropy.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallelization with <code><a href="foreach.html#topic+foreach">foreach</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="network_sift_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to print progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sifted network table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("example_matrix")
data("example_meta_data")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)
network_table_sifted &lt;- network_sift(network_table)
network_table_sifted_entropy &lt;- network_sift(
  network_table,
  matrix = example_matrix,
  meta_data = example_meta_data,
  pseudotime_column = "pseudotime",
  lag_value = 2,
  shuffles = 0,
  entropy_nboot = 0
)

plot_network_heatmap(
  example_ground_truth[, 1:3],
  heatmap_title = "Ground truth",
  show_names = TRUE,
  rect_color = "gray70"
)
plot_network_heatmap(
  network_table,
  heatmap_title = "Raw",
  show_names = TRUE,
  rect_color = "gray70"
)
plot_network_heatmap(
  network_table_sifted,
  heatmap_title = "Filtered",
  show_names = TRUE,
  rect_color = "gray70"
)
plot_network_heatmap(
  network_table_sifted_entropy,
  heatmap_title = "Filtered by entropy",
  show_names = TRUE,
  rect_color = "gray70"
)

calculate_auc(
  network_table,
  example_ground_truth,
  plot = TRUE
)
calculate_auc(
  network_table_sifted,
  example_ground_truth,
  plot = TRUE
)
calculate_auc(
  network_table_sifted_entropy,
  example_ground_truth,
  plot = TRUE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='normalization'>Normalize numeric vector</h2><span id='topic+normalization'></span>

<h3>Description</h3>

<p>Normalize numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalization(x, method = "max_min", na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalization_+3A_x">x</code></td>
<td>
<p>Input numeric vector.</p>
</td></tr>
<tr><td><code id="normalization_+3A_method">method</code></td>
<td>
<p>Method used for normalization.</p>
</td></tr>
<tr><td><code id="normalization_+3A_na_rm">na_rm</code></td>
<td>
<p>Whether to remove <code>NA</code> values,
and if setting TRUE, using <code>0</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nums &lt;- c(runif(2), NA, -runif(2))
nums
normalization(nums, method = "max_min")
normalization(nums, method = "maximum")
normalization(nums, method = "sum")
normalization(nums, method = "softmax")
normalization(nums, method = "z_score")
normalization(nums, method = "mad")
normalization(nums, method = "unit_vector")
normalization(nums, method = "unit_vector", na_rm = FALSE)
</code></pre>

<hr>
<h2 id='parallelize_fun'>Parallelize a function</h2><span id='topic+parallelize_fun'></span>

<h3>Description</h3>

<p>Parallelize a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelize_fun(x, fun, cores = 1, export_fun = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallelize_fun_+3A_x">x</code></td>
<td>
<p>A vector or list to apply over.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_fun">fun</code></td>
<td>
<p>The function to be applied to each element.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallelization with <code><a href="foreach.html#topic+foreach">foreach</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_export_fun">export_fun</code></td>
<td>
<p>The functions to export the function to workers.</p>
</td></tr>
<tr><td><code id="parallelize_fun_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to print progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of computed results
</p>

<hr>
<h2 id='plot_contrast_networks'>Plot contrast networks</h2><span id='topic+plot_contrast_networks'></span>

<h3>Description</h3>

<p>Plot contrast networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_contrast_networks(
  network_table,
  degree_value = 0,
  weight_value = 0,
  legend_position = "bottom"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_contrast_networks_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_degree_value">degree_value</code></td>
<td>
<p>Degree value to filter nodes.</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_weight_value">weight_value</code></td>
<td>
<p>Weight value to filter edges.</p>
</td></tr>
<tr><td><code id="plot_contrast_networks_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
plot_contrast_networks(network_table[1:50, ])
</code></pre>

<hr>
<h2 id='plot_dynamic_networks'>Plot dynamic networks</h2><span id='topic+plot_dynamic_networks'></span>

<h3>Description</h3>

<p>Plot dynamic networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dynamic_networks(
  network_table,
  celltypes_order,
  ntop = 10,
  title = NULL,
  theme_type = "theme_void",
  plot_type = "ggplot",
  layout = "fruchtermanreingold",
  nrow = 2,
  figure_save = FALSE,
  figure_name = NULL,
  figure_width = 6,
  figure_height = 6,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dynamic_networks_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_celltypes_order">celltypes_order</code></td>
<td>
<p>The order of cell types.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_ntop">ntop</code></td>
<td>
<p>The number of top genes to plot.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_title">title</code></td>
<td>
<p>The title of figure.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_theme_type">theme_type</code></td>
<td>
<p>Default is <code>theme_void</code>, the theme of figure,
could be <code>theme_void</code>, <code>theme_blank</code> or <code>theme_facet</code>.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_plot_type">plot_type</code></td>
<td>
<p>Default is <code>"ggplot"</code>, the type of figure,
could be <code>ggplot</code>, <code>animate</code> or <code>ggplotly</code>.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_layout">layout</code></td>
<td>
<p>Default is <code>"fruchtermanreingold"</code>, the layout of figure,
could be <code>fruchtermanreingold</code> or <code>kamadakawai</code>.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows of figure.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_save">figure_save</code></td>
<td>
<p>Default is <code>FALSE</code>,
Logical value, whether to save the figure file.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_name">figure_name</code></td>
<td>
<p>The name of figure file.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_width">figure_width</code></td>
<td>
<p>The width of figure.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_figure_height">figure_height</code></td>
<td>
<p>The height of figure.</p>
</td></tr>
<tr><td><code id="plot_dynamic_networks_+3A_seed">seed</code></td>
<td>
<p>Default is <code>1</code>, the seed random use to plot network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dynamic figure object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network &lt;- inferCSN(example_matrix)[1:100, ]
network$celltype &lt;- c(
  rep("cluster1", 20),
  rep("cluster2", 20),
  rep("cluster3", 20),
  rep("cluster5", 20),
  rep("cluster6", 20)
)

celltypes_order &lt;- c(
  "cluster5", "cluster3",
  "cluster2", "cluster1",
  "cluster6"
)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order
)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order[1:3]
)

plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order,
  plot_type = "ggplotly"
)

## Not run: 
# If setting `plot_type = "animate"` to plot and save `gif` figure,
# please install `gifski` package first.
plot_dynamic_networks(
  network,
  celltypes_order = celltypes_order,
  plot_type = "animate"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_embedding'>Plot embedding</h2><span id='topic+plot_embedding'></span>

<h3>Description</h3>

<p>Plot embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_embedding(
  matrix,
  labels = NULL,
  method = "pca",
  colors = RColorBrewer::brewer.pal(length(unique(labels)), "Set1"),
  seed = 1,
  point_size = 1,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_embedding_+3A_matrix">matrix</code></td>
<td>
<p>Input matrix.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_labels">labels</code></td>
<td>
<p>Input labels.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_method">method</code></td>
<td>
<p>Method to use for dimensionality reduction.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_colors">colors</code></td>
<td>
<p>Colors to use for the plot.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_point_size">point_size</code></td>
<td>
<p>Size of the points.</p>
</td></tr>
<tr><td><code id="plot_embedding_+3A_cores">cores</code></td>
<td>
<p>Set the number of threads when setting <em><code>method</code></em> to <code><a href="uwot.html#topic+umap">umap</a></code> and <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An embedding plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
samples_use &lt;- 1:200
plot_data &lt;- example_matrix[samples_use, ]
labels &lt;- sample(
  c("A", "B", "C", "D", "E"),
  nrow(plot_data),
  replace = TRUE
)

plot_embedding(
  plot_data,
  labels,
  method = "pca",
  point_size = 2
)

plot_embedding(
  plot_data,
  labels,
  method = "tsne",
  point_size = 2
)
</code></pre>

<hr>
<h2 id='plot_network_heatmap'>Plot network heatmap</h2><span id='topic+plot_network_heatmap'></span>

<h3>Description</h3>

<p>Plot network heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network_heatmap(
  network_table,
  regulators = NULL,
  targets = NULL,
  switch_matrix = TRUE,
  show_names = FALSE,
  heatmap_size_lock = TRUE,
  heatmap_size = 5,
  heatmap_height = NULL,
  heatmap_width = NULL,
  heatmap_title = NULL,
  heatmap_color = c("#1966ad", "white", "#bb141a"),
  border_color = "gray",
  rect_color = NA,
  anno_width = 1,
  anno_height = 1,
  row_anno_type = NULL,
  column_anno_type = NULL,
  legend_name = "Weight",
  row_title = "Regulators"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_network_heatmap_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_switch_matrix">switch_matrix</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to weight data table to matrix.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_show_names">show_names</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to show names of row and column.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_size_lock">heatmap_size_lock</code></td>
<td>
<p>Lock the size of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_size">heatmap_size</code></td>
<td>
<p>Default is <em><code>5</code></em>. The size of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_height">heatmap_height</code></td>
<td>
<p>The height of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_width">heatmap_width</code></td>
<td>
<p>The width of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_title">heatmap_title</code></td>
<td>
<p>The title of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_heatmap_color">heatmap_color</code></td>
<td>
<p>Colors of heatmap.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_border_color">border_color</code></td>
<td>
<p>Default is <em><code>gray</code></em>. Color of heatmap border.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_rect_color">rect_color</code></td>
<td>
<p>Default is <em><code>NA</code></em>. Color of heatmap rect.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_anno_width">anno_width</code></td>
<td>
<p>Width of annotation.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_anno_height">anno_height</code></td>
<td>
<p>Height of annotation.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_row_anno_type">row_anno_type</code></td>
<td>
<p>Default is <em><code>NULL</code></em>,
could add a annotation plot to row,
choose one of <em><code>boxplot</code></em>, <em><code>barplot</code></em>, <em><code>histogram</code></em>, <em><code>density</code></em>, <em><code>lines</code></em>, <em><code>points</code></em>, and <em><code>horizon</code></em>.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_column_anno_type">column_anno_type</code></td>
<td>
<p>Default is <em><code>NULL</code></em>,
could add a annotation plot to column,
choose one of <em><code>boxplot</code></em>, <em><code>barplot</code></em>, <em><code>histogram</code></em>, <em><code>density</code></em>, <em><code>lines</code></em>, and <em><code>points</code></em>.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_legend_name">legend_name</code></td>
<td>
<p>The name of legend.</p>
</td></tr>
<tr><td><code id="plot_network_heatmap_+3A_row_title">row_title</code></td>
<td>
<p>The title of row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
data("example_ground_truth")
network_table &lt;- inferCSN(example_matrix)

p1 &lt;- plot_network_heatmap(
  example_ground_truth[, 1:3],
  heatmap_title = "Ground truth",
  legend_name = "Ground truth"
)
p2 &lt;- plot_network_heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "inferCSN"
)
ComplexHeatmap::draw(p1 + p2)

p3 &lt;- plot_network_heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "Weight1",
  heatmap_color = c("#20a485", "#410054", "#fee81f")
)
p4 &lt;- plot_network_heatmap(
  network_table,
  heatmap_title = "inferCSN",
  legend_name = "Weight2",
  heatmap_color = c("#20a485", "white", "#fee81f")
)
ComplexHeatmap::draw(p3 + p4)

plot_network_heatmap(
  network_table,
  show_names = TRUE,
  rect_color = "gray90",
  row_anno_type = "density",
  column_anno_type = "barplot"
)

plot_network_heatmap(
  network_table,
  regulators = c("g1", "g2"),
  show_names = TRUE
)

plot_network_heatmap(
  network_table,
  targets = c("g1", "g2"),
  row_anno_type = "boxplot",
  column_anno_type = "histogram",
  show_names = TRUE
)

plot_network_heatmap(
  network_table,
  regulators = c("g1", "g3", "g5"),
  targets = c("g3", "g6", "g9"),
  show_names = TRUE
)
</code></pre>

<hr>
<h2 id='plot_scatter'>Plot expression data in a scatter plot</h2><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>Plot expression data in a scatter plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scatter(
  data,
  smoothing_method = "lm",
  group_colors = RColorBrewer::brewer.pal(9, "Set1"),
  title_color = "black",
  title = NULL,
  col_title = NULL,
  row_title = NULL,
  legend_title = NULL,
  legend_position = "bottom",
  margins = "both",
  marginal_type = NULL,
  margins_size = 10,
  compute_correlation = TRUE,
  compute_correlation_method = "pearson",
  keep_aspect_ratio = TRUE,
  facet = FALSE,
  se = FALSE,
  pointdensity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scatter_+3A_data">data</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_smoothing_method">smoothing_method</code></td>
<td>
<p>Method for smoothing curve, <code>lm</code> or <code>loess</code>.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_group_colors">group_colors</code></td>
<td>
<p>Colors for different groups.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_title_color">title_color</code></td>
<td>
<p>Color for the title.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_title">title</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_col_title">col_title</code></td>
<td>
<p>Title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_row_title">row_title</code></td>
<td>
<p>Title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_legend_title">legend_title</code></td>
<td>
<p>Title for the legend.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_margins">margins</code></td>
<td>
<p>The position of marginal figure (&quot;both&quot;, &quot;x&quot;, &quot;y&quot;).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_marginal_type">marginal_type</code></td>
<td>
<p>The type of marginal figure (<code>density</code>, <code>histogram</code>, <code>boxplot</code>, <code>violin</code>, <code>densigram</code>).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_margins_size">margins_size</code></td>
<td>
<p>The size of marginal figure, note the bigger size the smaller figure.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_compute_correlation">compute_correlation</code></td>
<td>
<p>Whether to compute and print correlation on the figure.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_compute_correlation_method">compute_correlation_method</code></td>
<td>
<p>Method to compute correlation (<code>pearson</code> or <code>spearman</code>).</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_keep_aspect_ratio">keep_aspect_ratio</code></td>
<td>
<p>Logical value, whether to set aspect ratio to 1:1.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_facet">facet</code></td>
<td>
<p>Faceting variable. If setting TRUE, all settings about margins will be inalidation.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_se">se</code></td>
<td>
<p>Display confidence interval around smooth.</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_pointdensity">pointdensity</code></td>
<td>
<p>Plot point density when only provide 1 cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
test_data &lt;- data.frame(
  example_matrix[1:200, c(1, 7)],
  c = c(
    rep("c1", 40),
    rep("c2", 40),
    rep("c3", 40),
    rep("c4", 40),
    rep("c5", 40)
  )
)

p1 &lt;- plot_scatter(
  test_data
)
p2 &lt;- plot_scatter(
  test_data,
  marginal_type = "boxplot"
)
p1 + p2

p3 &lt;- plot_scatter(
  test_data,
  facet = TRUE
)
p3

p4 &lt;- plot_scatter(
  test_data[, 1:2],
  marginal_type = "histogram"
)
p4
</code></pre>

<hr>
<h2 id='plot_static_networks'>Plot dynamic networks</h2><span id='topic+plot_static_networks'></span>

<h3>Description</h3>

<p>Plot dynamic networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_static_networks(
  network_table,
  regulators = NULL,
  targets = NULL,
  legend_position = "right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_static_networks_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
<tr><td><code id="plot_static_networks_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
plot_static_networks(
  network_table,
  regulators = network_table[1, 1]
)
plot_static_networks(
  network_table,
  targets = network_table[1, 1]
)
plot_static_networks(
  network_table,
  regulators = network_table[1, 1],
  targets = network_table[1, 2]
)
</code></pre>

<hr>
<h2 id='plot_weight_distribution'>Plot weight distribution</h2><span id='topic+plot_weight_distribution'></span>

<h3>Description</h3>

<p>Plot weight distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_weight_distribution(
  network_table,
  binwidth = 0.01,
  show_border = FALSE,
  border_color = "black",
  alpha = 1,
  theme = "viridis",
  theme_begin = 0,
  theme_end = 0.5,
  theme_direction = -1,
  legend_position = "right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_weight_distribution_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_binwidth">binwidth</code></td>
<td>
<p>Width of the bins.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_show_border">show_border</code></td>
<td>
<p>Logical value, whether to show border of the bins.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_border_color">border_color</code></td>
<td>
<p>Color of the border.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_alpha">alpha</code></td>
<td>
<p>Alpha value of the bins.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_theme">theme</code></td>
<td>
<p>Theme of the bins.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_theme_begin">theme_begin</code></td>
<td>
<p>Begin value of the theme.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_theme_end">theme_end</code></td>
<td>
<p>End value of the theme.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_theme_direction">theme_direction</code></td>
<td>
<p>Direction of the theme.</p>
</td></tr>
<tr><td><code id="plot_weight_distribution_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
plot_weight_distribution(network_table)
</code></pre>

<hr>
<h2 id='predict.srm'>Predicts response for a given sample</h2><span id='topic+predict.srm'></span><span id='topic+predict.srm_cv'></span>

<h3>Description</h3>

<p>Predicts response for a given sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srm'
predict(object, newx, lambda = NULL, gamma = NULL, ...)

## S3 method for class 'srm_cv'
predict(object, newx, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.srm_+3A_object">object</code></td>
<td>
<p>The output of fit_sparse_regression.</p>
</td></tr>
<tr><td><code id="predict.srm_+3A_newx">newx</code></td>
<td>
<p>A matrix on which predictions are made. The matrix should have p columns</p>
</td></tr>
<tr><td><code id="predict.srm_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda to use for prediction.
A summary of the lambdas in the regularization path can be obtained using <code><a href="#topic+print.srm">print.srm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.srm_+3A_gamma">gamma</code></td>
<td>
<p>The value of gamma to use for prediction.
A summary of the gammas in the regularization path can be obtained using <code><a href="#topic+print.srm">print.srm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.srm_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both lambda and gamma are not supplied, then a matrix of predictions for all the solutions in the regularization path is returned.
If lambda is supplied but gamma is not, the smallest value of gamma is used.
In case of logistic regression, probability values are returned.
</p>


<h3>Value</h3>

<p>Return predict value
</p>

<hr>
<h2 id='print.srm'>Prints a summary of <code>fit_sparse_regression</code></h2><span id='topic+print.srm'></span><span id='topic+print.srm_cv'></span>

<h3>Description</h3>

<p>Prints a summary of <code>fit_sparse_regression</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'srm'
print(x, ...)

## S3 method for class 'srm_cv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.srm_+3A_x">x</code></td>
<td>
<p>The output of <code><a href="#topic+fit_sparse_regression">fit_sparse_regression</a></code>.</p>
</td></tr>
<tr><td><code id="print.srm_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return information of <code>fit_sparse_regression</code>
</p>

<hr>
<h2 id='r_square'><code class="reqn">R^2</code> (coefficient of determination)</h2><span id='topic+r_square'></span>

<h3>Description</h3>

<p><code class="reqn">R^2</code> (coefficient of determination)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_square(y_true, y_pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_square_+3A_y_true">y_true</code></td>
<td>
<p>A numeric vector with ground truth values.</p>
</td></tr>
<tr><td><code id="r_square_+3A_y_pred">y_pred</code></td>
<td>
<p>A numeric vector with predicted values.</p>
</td></tr>
</table>

<hr>
<h2 id='single_network'>Construct network for single target gene</h2><span id='topic+single_network'></span>

<h3>Description</h3>

<p>Construct network for single target gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_network(
  matrix,
  regulators,
  target,
  cross_validation = FALSE,
  seed = 1,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = (ncol(matrix) - 1),
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single_network_+3A_matrix">matrix</code></td>
<td>
<p>An expression matrix.</p>
</td></tr>
<tr><td><code id="single_network_+3A_regulators">regulators</code></td>
<td>
<p>The regulator genes for which to infer the regulatory network.</p>
</td></tr>
<tr><td><code id="single_network_+3A_target">target</code></td>
<td>
<p>The target gene.</p>
</td></tr>
<tr><td><code id="single_network_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to use cross-validation.</p>
</td></tr>
<tr><td><code id="single_network_+3A_seed">seed</code></td>
<td>
<p>The random seed for cross-validation, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="single_network_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization, default is <em><code>L0</code></em>.
This can take either one of the following choices: <em><code>L0</code></em>, <em><code>L0L1</code></em>, and <em><code>L0L2</code></em>.
For high-dimensional and sparse data, <em><code>L0L2</code></em> is more effective.</p>
</td></tr>
<tr><td><code id="single_network_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function, default is <em><code>CD</code></em>.
Currently <em><code>CD</code></em> and <em><code>CDPSI</code></em> are supported.
The <em><code>CDPSI</code></em> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="single_network_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="single_network_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation, default is <em><code>10</code></em>.</p>
</td></tr>
<tr><td><code id="single_network_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse_regression">sparse_regression</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="single_network_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient, default is <em><code>0</code></em>.</p>
</td></tr>
<tr><td><code id="single_network_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to print progress messages.</p>
</td></tr>
<tr><td><code id="single_network_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weight data table of sub-network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
head(
  single_network(
    example_matrix,
    regulators = colnames(example_matrix),
    target = "g1"
  )
)

single_network(
  example_matrix,
  regulators = "g1",
  target = "g2"
)
</code></pre>

<hr>
<h2 id='sparse_regression'>Sparse regression model</h2><span id='topic+sparse_regression'></span>

<h3>Description</h3>

<p>Sparse regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_regression(
  x,
  y,
  cross_validation = FALSE,
  seed = 1,
  penalty = "L0",
  algorithm = "CD",
  regulators_num = ncol(x),
  n_folds = 10,
  percent_samples = 1,
  r_threshold = 0,
  computation_method = "cor",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse_regression_+3A_x">x</code></td>
<td>
<p>The matrix of regulators.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_y">y</code></td>
<td>
<p>The vector of target.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_cross_validation">cross_validation</code></td>
<td>
<p>Logical value, default is <em><code>FALSE</code></em>, whether to use cross-validation.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_seed">seed</code></td>
<td>
<p>The random seed for cross-validation, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_penalty">penalty</code></td>
<td>
<p>The type of regularization, default is <em><code>L0</code></em>.
This can take either one of the following choices: <em><code>L0</code></em>, <em><code>L0L1</code></em>, and <em><code>L0L2</code></em>.
For high-dimensional and sparse data, <em><code>L0L2</code></em> is more effective.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_algorithm">algorithm</code></td>
<td>
<p>The type of algorithm used to minimize the objective function, default is <em><code>CD</code></em>.
Currently <em><code>CD</code></em> and <em><code>CDPSI</code></em> are supported.
The <em><code>CDPSI</code></em> algorithm may yield better results, but it also increases running time.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_regulators_num">regulators_num</code></td>
<td>
<p>The number of non-zore coefficients, this value will affect the final performance.
The maximum support size at which to terminate the regularization path.
Recommend setting this to a small fraction of min(n,p) (e.g. 0.05 * min(n,p)) as L0 regularization typically selects a small portion of non-zeros.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_n_folds">n_folds</code></td>
<td>
<p>The number of folds for cross-validation, default is <em><code>10</code></em>.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_percent_samples">percent_samples</code></td>
<td>
<p>The percent of all samples used for <code><a href="#topic+sparse_regression">sparse_regression</a></code>, default is <em><code>1</code></em>.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_r_threshold">r_threshold</code></td>
<td>
<p>Threshold of <code class="reqn">R^2</code> or correlation coefficient, default is <em><code>0</code></em>.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_computation_method">computation_method</code></td>
<td>
<p>The method used to compute <code>r</code>.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, default is <em><code>TRUE</code></em>, whether to print progress messages.</p>
</td></tr>
<tr><td><code id="sparse_regression_+3A_...">...</code></td>
<td>
<p>Parameters for other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
sparse_regression(
  example_matrix[, -1],
  example_matrix[, 1]
)
</code></pre>

<hr>
<h2 id='table_to_matrix'>Switch network table to matrix</h2><span id='topic+table_to_matrix'></span>

<h3>Description</h3>

<p>Switch network table to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_to_matrix(network_table, regulators = NULL, targets = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_to_matrix_+3A_network_table">network_table</code></td>
<td>
<p>The weight data table of network.</p>
</td></tr>
<tr><td><code id="table_to_matrix_+3A_regulators">regulators</code></td>
<td>
<p>Regulators list.</p>
</td></tr>
<tr><td><code id="table_to_matrix_+3A_targets">targets</code></td>
<td>
<p>Targets list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Weight matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_matrix")
network_table &lt;- inferCSN(example_matrix)
head(network_table)

table_to_matrix(network_table)[1:6, 1:6]

table_to_matrix(
  network_table,
  regulators = c("g1", "g2"),
  targets = c("g3", "g4")
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
