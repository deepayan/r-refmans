<!DOCTYPE html><html><head><title>Help for package misc3d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {misc3d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeContour3d'><p>Compute Isosurface, a Three Dimension Contour</p></a></li>
<li><a href='#contour3d'><p>Draw an Isosurface, a Three Dimension Contour Plot</p></a></li>
<li><a href='#drawScene'><p>Rendering of Triangular Mesh Surface Data</p></a></li>
<li><a href='#exportScene'><p>Writing Out Triangular Mesh Scenes</p></a></li>
<li><a href='#image3d'><p>Draw Points on a 3D Grid</p></a></li>
<li><a href='#kde3d'><p>Compute a Three Dimension Kernel Density Estimate</p></a></li>
<li><a href='#lighting'><p>Lighting Functions</p></a></li>
<li><a href='#linesTetrahedra'><p>Create a Set of Lines with Tetrahetra Centered at Points along</p>
the Lines</a></li>
<li><a href='#parametric3d'><p>Draw a 3D Parametric Plot</p></a></li>
<li><a href='#pointsTetrahedra'><p>Create a Set of Tetrahetra Centered at Data Points</p></a></li>
<li><a href='#slices3d'><p>Interactive Image Slices of 3D or 4D Volume Data</p></a></li>
<li><a href='#surfaceTriangles'><p>Create a Triangle Mesh Representing a Surface</p></a></li>
<li><a href='#teapot'><p>Utah Teapot</p></a></li>
<li><a href='#triangles'><p>Triangle Mesh Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Miscellaneous 3D Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dai Feng and Luke Tierney</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Tierney &lt;luke-tierney@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, tkrplot, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, tcltk</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of miscellaneous 3d plots, including
    isosurfaces.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/luke-tierney/misc3d">https://gitlab.com/luke-tierney/misc3d</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 19:24:30 UTC; luke</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeContour3d'>Compute Isosurface, a Three Dimension Contour</h2><span id='topic+computeContour3d'></span>

<h3>Description</h3>

<p>Computes a 3D contours or isosurface by the marching cubes algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeContour3d(vol, maxvol = max(vol), level,
                 x = 1:dim(vol)[1],
                 y = 1:dim(vol)[2],
                 z = 1:dim(vol)[3], mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeContour3d_+3A_vol">vol</code></td>
<td>
<p>a three dimensional array.</p>
</td></tr>
<tr><td><code id="computeContour3d_+3A_maxvol">maxvol</code></td>
<td>
<p>maximum of the <code>vol</code> array.</p>
</td></tr>
<tr><td><code id="computeContour3d_+3A_level">level</code></td>
<td>
<p>The level at which to construct the contour surface.</p>
</td></tr>
<tr><td><code id="computeContour3d_+3A_x">x</code>, <code id="computeContour3d_+3A_y">y</code>, <code id="computeContour3d_+3A_z">z</code></td>
<td>
<p>locations of grid planes at which values in <code>vol</code> are
measured.</p>
</td></tr>
<tr><td><code id="computeContour3d_+3A_mask">mask</code></td>
<td>
<p>a function of 3 arguments returning a logical array, a
three dimensional logical array, or <code>NULL</code>.  If not
<code>NULL</code>, only cells for which <code>mask</code> is true at all eight
vertices are used in forming the contour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the marching-cubes algorithm, with adjustments for dealing with
face and internal ambiguities, to compute an  isosurface.
See references for the details. The function
<code><a href="#topic+contour3d">contour3d</a></code> provides a higher-level interface.
</p>


<h3>Value</h3>

<p>A matrix of three columns representing the triangles making up the
contour surface. Each row represents a vertex and goups of three
rows represent a triangle.
</p>


<h3>References</h3>

<p>Chernyaev E. (1995)  
Marching Cubes 33: Construction of Topologically Correct Isosurfaces  
<em>Technical Report CN/95-17, CERN</em>
</p>
<p>Lorensen W. and Cline H. (1987)  
Marching Cubes: A High Resolution 3D Surface Reconstruction Algorithm  
<em>Computer Graphics</em> <b>vol. 21, no. 4</b>, 163-169
</p>
<p>Nielson G. and Hamann B. (1992)
The Asymptotic Decider: Resolving the Ambiguity in Marching Cubes  
<em>Proc. IEEE Visualization</em>  <b>92</b>, 83-91
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contour3d">contour3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(-2,2,len=50)
  g &lt;- expand.grid(x = x, y = x, z = x)
  v &lt;- array(g$x^4 + g$y^4 + g$z^4, rep(length(x),3))
  con &lt;- computeContour3d(v, max(v), 1)
  drawScene(makeTriangles(con))
</code></pre>

<hr>
<h2 id='contour3d'>Draw an Isosurface, a Three Dimension Contour Plot</h2><span id='topic+contour3d'></span>

<h3>Description</h3>

<p>Computes and renders 3D contours or isosurfaces computed by the
marching cubes algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   contour3d(f, level, x, y, z, mask = NULL, color = "white", color2 = NA,
             alpha = 1, fill = TRUE, col.mesh = if (fill) NA else color,
             material = "default", smooth = 0,
             add = FALSE, draw = TRUE, engine = "rgl", separate=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour3d_+3A_f">f</code></td>
<td>
<p>a function of 3 arguments or a three dimensional array.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_level">level</code></td>
<td>
<p>The level or levels at which to construct contour surfaces.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_x">x</code>, <code id="contour3d_+3A_y">y</code>, <code id="contour3d_+3A_z">z</code></td>
<td>
<p>locations of grid planes at which values in <code>f</code> are
measured or <code>f</code> is to be evaluated. Can be omitted if <code>f</code>
is an array.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_mask">mask</code></td>
<td>
<p>a function of 3 arguments returning a logical array, a
three dimensional logical array, or <code>NULL</code>.  If not
<code>NULL</code>, only cells for which <code>mask</code> is true at all eight
vertices are used in forming the contour.  Can also be a list of
functions the same length as <code>level</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_color">color</code></td>
<td>
<p>color to use for the contour surface. Recycled to the
length of <code>'levels'</code>. Can also be a function, or list of
functions, of three arguments.  These are called for each level with
three arguments, the coordinates of the midpoints of the triangles
making up the surface.  They should return a vector of colors to use
for the triangles.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_color2">color2</code></td>
<td>
<p>opposite face color. Recycled to the length of
<code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel level, a number between 0 and 1. Recycled to the
length of <code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, drawing should use filled
surfaces; otherwise a wire frame should be drawn. Recycled to the
length of <code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_col.mesh">col.mesh</code></td>
<td>
<p>color to use for the wire frame. Recycled to the
length of <code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_smooth">smooth</code></td>
<td>
<p>integer or logical specifying Phong shading level for
&quot;standard&quot; and &quot;grid&quot; engines or whether or not to use shading for
the &quot;rgl&quot; engine. Recycled to the length of <code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_material">material</code></td>
<td>
<p>material specification; currently only used by
&quot;standard&quot; and &quot;grid&quot; engines. Currently possible values are the
character strings &quot;dull&quot;, &quot;shiny&quot;, &quot;metal&quot;, and &quot;default&quot;.  Recycled
to the length of <code>'levels'</code>.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code>, add to current <code>rgl</code> graph.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_draw">draw</code></td>
<td>
<p>logical; if <code>TRUE</code>, draw the results; otherwise,
return contour triangles.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_engine">engine</code></td>
<td>
<p>character; currently &quot;rgl&quot;, &quot;standard&quot;, &quot;grid&quot; or &quot;none&quot;;
for &quot;none&quot; the computed triangles are returned.</p>
</td></tr>
<tr><td><code id="contour3d_+3A_separate">separate</code></td>
<td>
<p>logical and one for each <code>level</code>; if it is
<code>TRUE</code>, and either the <code>engine</code> is &quot;none&quot; or <code>draw</code>
is not true, the triangles from the corresponding <code>level</code>
are separated into disconnected chunks, namely that triangles from
different chunks have no vertex in common. The default is
<code>FALSE</code> for each level.
</p>
</td></tr>
<tr><td><code id="contour3d_+3A_...">...</code></td>
<td>
<p>additional rendering arguments, e.g. material and texture
properties for the &quot;rgl&quot; engine.  See documentation for
<code><a href="#topic+drawScene">drawScene</a></code> and <code><a href="#topic+drawScene.rgl">drawScene.rgl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the marching-cubes algorithm, with adjustments for dealing with
face and internal ambiguities, to draw isosurfaces.
See references for the details.
</p>


<h3>Value</h3>

<p>For the &quot;rgl&quot; engine the returned value is <code>NULL</code>. For the
&quot;standard&quot; and &quot;grid&quot; engines the returned value is the viewing
transformation as returned by <code>persp</code>.  For the engine &quot;none&quot;, or
when <code>draw</code> is not true, the returned value is a structure
representing the triangles making up the contour, or a list of such
structures for multiple contours.
</p>


<h3>Note</h3>

<p>The &quot;rgl&quot; engine now uses the standard rgl coordinates instead of
negating <code>y</code> and swapping <code>y</code> and <code>z</code>. If you need to
reproduce the previous behavior you can use
<code>options(old.misc3d.orientation=TRUE)</code>.
</p>
<p>Transparency only works properly in the &quot;rgl&quot; engine.  For standard or
grid graphics on pdf or quartz devices using alpha levels less than 1
does work but the triangle borders show as a less transparent mesh.
</p>


<h3>References</h3>

<p>Chernyaev E. (1995)  
Marching Cubes 33: Construction of Topologically Correct Isosurfaces  
<em>Technical Report CN/95-17, CERN</em>
</p>
<p>Daniel Adler, Oleg Nenadic and Walter Zucchini (2003)
RGL: A R-library for 3D visualization with OpenGL
</p>
<p>Lorensen W. and Cline H. (1987)  
Marching Cubes: A High Resolution 3D Surface Reconstruction Algorithm  
<em>Computer Graphics</em> <b>vol. 21, no. 4</b>, 163-169
</p>
<p>Nielson G. and Hamann B. (1992)
The Asymptotic Decider: Resolving the Ambiguity in Marching Cubes  
<em>Proc. IEEE Visualization</em>  <b>92</b>, 83-91
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+triangles3d">triangles3d</a></code>, <code><a href="rgl.html#topic+material3d">material3d</a></code>,
<code><a href="rgl.html#topic+surface3d">surface3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1: Draw a ball
  f &lt;- function(x, y, z)x^2+y^2+z^2
  x &lt;- seq(-2,2,len=20)
  contour3d(f,4,x,x,x)
  contour3d(f,4,x,x,x, engine = "standard")

  # ball with one corner removed.
  contour3d(f,4,x,x,x, mask = function(x,y,z) x &gt; 0 | y &gt; 0 | z &gt; 0)
  contour3d(f,4,x,x,x, mask = function(x,y,z) x &gt; 0 | y &gt; 0 | z &gt; 0,
            engine="standard", screen = list(x = 290, y = -20),
            color = "red", color2 = "white")

  # ball with computed colors
  w &lt;- function(x,y,z) {
      v &lt;- sin(x) + cos(2 * y) * sin(5 * z)
      r &lt;- range(v)
      n &lt;- 100
      i &lt;- pmax(pmin(ceiling(n * (v - r[1]) / (r[2] - r[1])), n), 1)
      terrain.colors(n)[i]
  }
  contour3d(f,4,x,x,x, color = w)

  #Example 2: Nested contours of mixture of three tri-variate normal densities
  nmix3 &lt;- function(x, y, z, m, s) {
      0.4 * dnorm(x, m, s) * dnorm(y, m, s) * dnorm(z, m, s) +
      0.3 * dnorm(x, -m, s) * dnorm(y, -m, s) * dnorm(z, -m, s) +
      0.3 * dnorm(x, m, s) * dnorm(y, -1.5 * m, s) * dnorm(z, m, s)
  }
  f &lt;- function(x,y,z) nmix3(x,y,z,.5,.5)
  g &lt;- function(n = 40, k = 5, alo = 0.1, ahi = 0.5, cmap = heat.colors) {
      th &lt;- seq(0.05, 0.2, len = k)
      col &lt;- rev(cmap(length(th)))
      al &lt;- seq(alo, ahi, len = length(th))
      x &lt;- seq(-2, 2, len=n)
      contour3d(f,th,x,x,x,color=col,alpha=al)
      rgl::bg3d(col="white")
  }
  g(40,5)
  gs &lt;- function(n = 40, k = 5, cmap = heat.colors, ...) {
      th &lt;- seq(0.05, 0.2, len = k)
      col &lt;- rev(cmap(length(th)))
      x &lt;- seq(-2, 2, len=n)
      m &lt;- function(x,y,z) x &gt; .25 | y &lt; -.3
      contour3d(f,th,x,x,x,color=col, mask = m, engine = "standard",
                scale = FALSE, ...)
      rgl::bg3d(col="white")
  }
  gs(40, 5, screen=list(z = 130, x = -80), color2 = "lightgray", cmap=rainbow)

## Not run: 
  #Example 3: Nested contours for FMRI data.
  library(AnalyzeFMRI)
  a &lt;- f.read.analyze.volume(system.file("example.img", package="AnalyzeFMRI"))
  a &lt;- a[,,,1]
  contour3d(a, 1:64, 1:64, 1.5*(1:21), lev=c(3000, 8000, 10000),
            alpha = c(0.2, 0.5, 1), color = c("white", "red", "green"))

  # alternative masking out a corner
  m &lt;- array(TRUE, dim(a))
  m[1:30,1:30,1:10] &lt;- FALSE
  contour3d(a, 1:64, 1:64, 1.5*(1:21), lev=c(3000, 8000, 10000),
            mask = m, color = c("white", "red", "green"))
  contour3d(a, 1:64, 1:64, 1.5*(1:21), lev=c(3000, 8000, 10000),
            color = c("white", "red", "green"),
            color2 = c("gray", "red", "green"),
            mask = m, engine="standard",
            scale = FALSE, screen=list(z = 60, x = -120))
  
## End(Not run)

  #Example 4: Separate the triangles from the contours of
  #           mixture of three tri-variate normal densities
  nmix3 &lt;- function(x, y, z, m, s) {
      0.3*dnorm(x, -m, s) * dnorm(y, -m, s) * dnorm(z, -m, s) +
      0.3*dnorm(x, -2*m, s) * dnorm(y, -2*m, s) * dnorm(z, -2*m, s) +
      0.4*dnorm(x, -3*m, s) * dnorm(y, -3 * m, s) * dnorm(z, -3*m, s) }
  f &lt;- function(x,y,z) nmix3(x,y,z,0.5,.1)
  n &lt;- 20
  x &lt;- y &lt;- z &lt;- seq(-2, 2, len=n)
  contour3dObj &lt;- contour3d(f, 0.35, x, y, z, draw=FALSE, separate=TRUE)
  for(i in 1:length(contour3dObj))
      contour3dObj[[i]]$color &lt;- rainbow(length(contour3dObj))[i]
  drawScene.rgl(contour3dObj)
</code></pre>

<hr>
<h2 id='drawScene'>Rendering of Triangular Mesh Surface Data</h2><span id='topic+drawScene'></span><span id='topic+drawScene.rgl'></span>

<h3>Description</h3>

<p>Draw scenes consisting of one or more surfaces described by triangular
mesh data structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawScene(scene, light = c(0, 0, 1),
          screen = list(z = 40, x = -60), scale = TRUE, R.mat = diag(4),
          perspective = FALSE, distance = if (perspective) 0.2 else 0, 
          fill = TRUE, xlim = NULL, ylim = NULL, zlim = NULL,
          aspect = c(1, 1), col.mesh = if (fill) NA else "black",
          polynum = 100, lighting = phongLighting, add = FALSE,
          engine = "standard", col.bg = "transparent", depth = 0,
          newpage = TRUE)
drawScene.rgl(scene, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawScene_+3A_scene">scene</code></td>
<td>
<p>a triangle mesh object of class <code>Triangles3D</code> or a
list of such objects representing the scene to be rendered.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_light">light</code></td>
<td>
<p>numeric vector of length 3 or 4.  The first three
elements represent the direction to the light in viewer coordinates;
the viewer is at <code>(0, 0, 1 / distance)</code> looking down along the
positive z-axis.  The fourth element, if present, represents light
intensity; the default is 1.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_screen">screen</code></td>
<td>
<p>as for <code><a href="lattice.html#topic+panel.3dwire">panel.3dwire</a></code>, a list
giving sequence of rotations to be applied to the scene before being
rendered. The initial position starts with the viewing point along
the positive z-axis, and the x and y axes in the usual
position. Each component of the list should be named one of &quot;x&quot;, &quot;y&quot;
or &quot;z&quot;; repetitions are allowed.  The values indicate the amount
of rotation about that axis in degrees.</p>
</td></tr> 
<tr><td><code id="drawScene_+3A_scale">scale</code></td>
<td>
<p>logical. Before viewing the x, y and z coordinates of the
scene defining the surface are transformed to the interval
[-0.5,0.5].  If <code>scale</code> is true the x, y and z coordinates are
transformed separately.  Otherwise, the coordinates are scaled so
that aspect ratios are retained. Ignored if <code>draw = TRUE</code></p>
</td></tr>
<tr><td><code id="drawScene_+3A_r.mat">R.mat</code></td>
<td>
<p>initial rotation matrix in homogeneous coordinates, to be
applied to the data before <code>screen</code> rotates the view further.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_perspective">perspective</code></td>
<td>
<p>logical, whether to render a perspective
view. Setting this to <code>FALSE</code> is equivalent to setting
<code>distance</code> to 0</p>
</td></tr>
<tr><td><code id="drawScene_+3A_distance">distance</code></td>
<td>
<p>numeric, between 0 and 1, controls amount of
perspective. The distance of the viewing point from the origin (in
the transformed coordinate system) is <code>1 / distance</code>. This is
described in a little more detail in the documentation for
<code><a href="lattice.html#topic+cloud">cloud</a></code>.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, drawing should use filled
surfaces or wire frames as indicated by the object properties.
Otherwise all objects in the scene should be rendered as wire
frames.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_xlim">xlim</code>, <code id="drawScene_+3A_ylim">ylim</code>, <code id="drawScene_+3A_zlim">zlim</code></td>
<td>
<p>x-, y-  and z-limits.  The scene is rendered so that
the rectangular volume defined by these limits is visible.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_aspect">aspect</code></td>
<td>
<p>vector of length 2. Gives the relative aspects of the
y-size/x-size and z-size/x-size of the enclosing cube.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_col.mesh">col.mesh</code></td>
<td>
<p>color to use for the wire frame if <code>frames</code> is
true.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_polynum">polynum</code></td>
<td>
<p>integer.  Number of triangles to pass in batches to
grid primitives for the &quot;grid&quot; engine.  The default should be
adequate.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_lighting">lighting</code></td>
<td>
<p>a lighting function.  Current options are
<code>phongLighting</code> and <code>perspLighting</code>.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code>, add to current graph.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_engine">engine</code></td>
<td>
<p>character; currently &quot;standard&quot; or &quot;grid&quot;.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_col.bg">col.bg</code></td>
<td>
<p>background dolor to use in color depth cuing.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_depth">depth</code></td>
<td>
<p>numeric, between 0 and 1.  Controls the amount of color
blending to <code>col.bg</code> for objects farther from the
viewer. <code>depth</code> equal to zero means no depth cuing.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_newpage">newpage</code></td>
<td>
<p>logical; if <code>TRUE</code>, and <code>add</code> is true, then
the &quot;grid&quot; engine will call <code>"grid.newpage"</code>; otherwise the
current page is used.</p>
</td></tr>
<tr><td><code id="drawScene_+3A_...">...</code></td>
<td>
<p>rgl material and texture properties; see documentation for
<code><a href="rgl.html#topic+rgl.material">rgl.material</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drawScene</code> renders a scene consisting of one or more triangle
mesh objects using standard or grid graphics.  Object-specific
rendering features such as smoothing and material are controlled by
setting in the objects.  Arguments to <code>drawScene</code> control global
factors such as viewer and light position.
</p>
<p><code>drawScene.rgl</code> renders the scene in an rgl window.
</p>
<p>If <code>add=TRUE</code> in standard or grid graphics then coordinates are
not further scaled after the transformations implied by <code>R.mat</code>,
and <code>distance</code> are applied.  For the grid engine drawing occurs
in the current viewport.
</p>


<h3>Value</h3>

<p><code>drawScene.rgl</code> returns <code>NULL</code>. The return value of
<code>drawScene</code> is the viewing transformation as returned by
<code>persp</code>.
</p>


<h3>Note</h3>

<p>The &quot;rgl&quot; engine now uses the standard rgl coordinates instead of
negating <code>y</code> and swapping <code>y</code> and <code>z</code>. If you need to
reproduce the previous behavior you can use
<code>options(old.misc3d.orientation=TRUE)</code>.
</p>
<p>Transparency only works properly in the &quot;rgl&quot; engine.  For standard or
grid graphics on devices that support transparency using alpha levels
less than 1 does work but the triangle borders show as a less
transparent mesh.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+rgl.material">rgl.material</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  vtri &lt;- local({
      z &lt;- 2 * volcano
      x &lt;- 10 * (1:nrow(z))
      y &lt;- 10 * (1:ncol(z))
      surfaceTriangles(x, y, z, color="green3")
  })
  drawScene(vtri, scale = FALSE)
  drawScene(vtri, screen=list(x=40, y=-40, z=-135), scale = FALSE)
  drawScene(vtri, screen=list(x=40, y=-40, z=-135), scale = FALSE,
            perspective = TRUE)
  drawScene(vtri, screen=list(x=40, y=-40, z=-135), scale = FALSE,
            perspective = TRUE, depth = 0.4)
</code></pre>

<hr>
<h2 id='exportScene'>Writing Out Triangular Mesh Scenes</h2><span id='topic+exportScene'></span>

<h3>Description</h3>

<p>Writing out scenes consisting of one or more surfaces represented by triangular
mesh data structures to textual files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportScene(scene, filename, format=c("OFF", "IDTF", "ASY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportScene_+3A_scene">scene</code></td>
<td>
<p>a triangle mesh object of class <code>Triangles3D</code> or a
list of such objects representing the scene to be exported.</p>
</td></tr>
<tr><td><code id="exportScene_+3A_filename">filename</code></td>
<td>
<p>the name of the exported textual file.</p>
</td></tr>
<tr><td><code id="exportScene_+3A_format">format</code></td>
<td>
<p>the format of the exported textual file.
It must be one of &quot;OFF&quot;, &quot;IDTF&quot;, or &quot;ASY&quot; and can be abbreviated.
The default is &quot;OFF&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exportScene</code> writes out scenes to textual files,
which can be used for other purposes, for example the
generation of U3d and PRC files for interactive 3D visualization in
a PDF.
</p>


<h3>Value</h3>

<p>Textual files representing triangular mesh scenes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nmix3 &lt;- function(x, y, z, m, s) {
      0.4 * dnorm(x, m, s) * dnorm(y, m, s) * dnorm(z, m, s) +
      0.3 * dnorm(x, -m, s) * dnorm(y, -m, s) * dnorm(z, -m, s) +
      0.3 * dnorm(x, m, s) * dnorm(y, -1.5 * m, s) * dnorm(z, m, s)
  }
 
  f &lt;- function(x,y,z) nmix3(x,y,z,.5,.5)
 
  gs1 &lt;- function(n = 40, k = 5, cmap = heat.colors, ...) {
      th &lt;- seq(0.05, 0.2, len = k)
      col &lt;- rev(cmap(length(th)))
      x &lt;- seq(-2, 2, len=n)
      m &lt;- function(x,y,z) x &gt; .25 | y &lt; -.3
      contour3d(f,th,x,x,x,color=col, mask = m, engine = "none",
               scale = FALSE, ...)
  }
 
  conts &lt;- gs1(40, 5, screen=list(z = 130, x = -80),
               color2 = "lightgray", cmap=rainbow)
  filename &lt;- file.path(tempdir(), "nmix")
  exportScene(conts, filename, "OFF")
</code></pre>

<hr>
<h2 id='image3d'>Draw Points on a 3D Grid</h2><span id='topic+image3d'></span>

<h3>Description</h3>

<p>Plots points on a three dimensional grid representing values in a
three dimensional array. Assumes high values are inside and uses alpha
blending to make outside points more transparent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  image3d(v, x = 1:dim(v)[1], y = 1:dim(v)[2], z = 1:dim(v)[3],
          vlim = quantile(v, c(.9, 1),na.rm=TRUE),
          col = heat.colors(256), alpha.power = 2,
          alpha = ((1:length(col))/ length(col))^alpha.power,
          breaks, sprites = TRUE, jitter = FALSE, 
          radius = min(diff(x), diff(y), diff(z)),
          add = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image3d_+3A_v">v</code></td>
<td>
<p>three dimensional data array.</p>
</td></tr>
<tr><td><code id="image3d_+3A_x">x</code>, <code id="image3d_+3A_y">y</code>, <code id="image3d_+3A_z">z</code></td>
<td>
<p>locations of grid planes at which values in <code>v</code> are
measured.</p>
</td></tr>
<tr><td><code id="image3d_+3A_vlim">vlim</code></td>
<td>
<p>minimum and maximum <code>v</code> values for which points are
to be drawn.</p>
</td></tr>
<tr><td><code id="image3d_+3A_col">col</code></td>
<td>
<p>vector of colors for the points as generated by
<code>heat.colors</code> or similar functions.</p>
</td></tr>
<tr><td><code id="image3d_+3A_alpha.power">alpha.power</code></td>
<td>
<p>used to calculate the alpha values. The larger the
power, the smaller the alpha, the more transparent the point. Only
used if <code>alpha</code> is not supplied.</p>
</td></tr> 
<tr><td><code id="image3d_+3A_alpha">alpha</code></td>
<td>
<p>vector of alpha values between 0 and 1.  The length of
the vector should be equal to the length of <code>col</code>.</p>
</td></tr>
<tr><td><code id="image3d_+3A_breaks">breaks</code></td>
<td>
<p>breakpoints for the colors; must give one more
breakpoint than colors.</p>
</td></tr>
<tr><td><code id="image3d_+3A_sprites">sprites</code></td>
<td>
<p>logical;  if <code>TRUE</code>, use <code>sprites3d</code> to
draw the points.</p>
</td></tr>
<tr><td><code id="image3d_+3A_radius">radius</code></td>
<td>
<p>radius used in <code>sprites3d</code>.</p>
</td></tr>
<tr><td><code id="image3d_+3A_jitter">jitter</code></td>
<td>
<p>logical;  if <code>TRUE</code>, add a small amount of noise to
the point locations.</p>
</td></tr>
<tr><td><code id="image3d_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code>, add to current <code>rgl</code> graph.</p>
</td></tr>
<tr><td><code id="image3d_+3A_...">...</code></td>
<td>
<p>material and texture properties. See <code>rgl.material</code>
for details.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Daniel Adler, Oleg Nenadic and Walter Zucchini (2003)
RGL: A R-library for 3D visualization with OpenGL
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="rgl.html#topic+sprites3d">sprites3d</a></code>,
<code><a href="rgl.html#topic+points3d">points3d</a></code>, <code><a href="base.html#topic+jitter">jitter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # view density of mixture of tri-variate normals
    nmix3 &lt;- function(x, y, z, m, s) {
      0.4 * dnorm(x, m, s) * dnorm(y, m, s) * dnorm(z, m, s) +
        0.3 * dnorm(x, -m, s) * dnorm(y, -m, s) * dnorm(z, -m, s) +
          0.3 * dnorm(x, m, s) * dnorm(y, -1.5 * m, s) * dnorm(z, m, s)
    }
    f &lt;- function(x,y,z) nmix3(x,y,z,.5,.5)
    x&lt;-seq(-2,2,len=50)
    g &lt;- expand.grid(x = x, y = x, z = x)
    v &lt;- array(f(g$x, g$y, g$z), c(length(x), length(x), length(x)))
    image3d(v)
    image3d(v, jitter = TRUE)
</code></pre>

<hr>
<h2 id='kde3d'>Compute a Three Dimension Kernel Density Estimate</h2><span id='topic+kde3d'></span>

<h3>Description</h3>

<p>Evaluates a three dimensional kernel density estimate using a Gaussian
kernel with diagonal covariance matrix on a regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   kde3d(x, y, z, h, n = 20, lims = c(range(x), range(y), range(z)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde3d_+3A_x">x</code>, <code id="kde3d_+3A_y">y</code>, <code id="kde3d_+3A_z">z</code></td>
<td>
<p><code>x</code>, <code>y</code>, and <code>z</code> coordinates of the data.</p>
</td></tr>
<tr><td><code id="kde3d_+3A_h">h</code></td>
<td>
<p>vector of three bandwidths for the density estimate;
recycled if length is less than three; default is based on the
normal reference bandwidth (see <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code>).</p>
</td></tr>
<tr><td><code id="kde3d_+3A_n">n</code></td>
<td>
<p>numbers of grid points to use for each dimension; recycled if
length is less than three.</p>
</td></tr>
<tr><td><code id="kde3d_+3A_lims">lims</code></td>
<td>
<p>lower and upper limits on the region for which the density
estimate is to be computed, provides as a vector of length 6,
corresponding to low and high values of <code>x</code>, <code>y</code>, and
<code>z</code>; recycled if only two values are supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four components, <code>x</code>, <code>y</code>, <code>z</code>, and
<code>d</code>. <code>x</code>, <code>y</code>, and <code>z</code> are the coordinates of the
grid points at which the density estimate has been evaluated, and
<code>d</code> is a three dimensional array of the estimated density values.
</p>


<h3>References</h3>

<p>Based on the function <code><a href="MASS.html#topic+kde2d">kde2d</a></code> in package
<span class="pkg">MASS</span>.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+kde2d">kde2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  with(quakes, {
      d &lt;- kde3d(long, lat, -depth, n = 40)
      contour3d(d$d, exp(-12), d$x/22, d$y/28, d$z/640,
                color = "green", color2 = "gray", scale=FALSE,
                engine = "standard")
  })
</code></pre>

<hr>
<h2 id='lighting'>Lighting Functions</h2><span id='topic+perspLighting'></span><span id='topic+phongLighting'></span>

<h3>Description</h3>

<p>Functions to compute colors modified for lighting effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phongLighting(normals, view, light, color, color2, alpha, material = "default")
perspLighting(normals, view, light, color, color2, alpha, material = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lighting_+3A_normals">normals</code></td>
<td>
<p>numeric matrix with three columns representing surface
normal vectors.</p>
</td></tr>
<tr><td><code id="lighting_+3A_view">view</code></td>
<td>
<p>numeric vector of length 3 representing the direction to
the viewer.</p>
</td></tr>
<tr><td><code id="lighting_+3A_light">light</code></td>
<td>
<p>numeric vector of length 3 or 4.  The first three
elements represent the direction to the light.  The fourth element,
if present, represents light intensity; the default is 1.</p>
</td></tr>
<tr><td><code id="lighting_+3A_color">color</code></td>
<td>
<p>colors to use for faces in the direction of the normal
vectors.</p>
</td></tr>
<tr><td><code id="lighting_+3A_color2">color2</code></td>
<td>
<p>opposite face color.</p>
</td></tr>
<tr><td><code id="lighting_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel level, a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="lighting_+3A_material">material</code></td>
<td>
<p>material specification. Currently possible values are
the character strings &quot;dull&quot;, &quot;shiny&quot;, &quot;metal&quot;, and &quot;default&quot;.</p>
</td></tr>  </table>


<h3>Details</h3>

<p><code>phongLighting</code> uses the Phong lighting model to compute colors
modified for view direction, light direction, and material properties.
<code>perspLighting</code> implements approximately the same lighting model
as the <code>persp</code> function.
</p>


<h3>Value</h3>

<p>Vector of color specifications.
</p>

<hr>
<h2 id='linesTetrahedra'>Create a Set of Lines with Tetrahetra Centered at Points along
the Lines</h2><span id='topic+linesTetrahedra'></span>

<h3>Description</h3>

<p>Creates a scene consisting of lines made up of small tetrahedra
centered at points along them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesTetrahedra(x, y, z, delta=c(min(x[,2]-x[,1])/10,
                                    min(y[,2]-y[,1])/10,
                                    min(z[,2]-z[,1])/10),
                lwd = 0.01, color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linesTetrahedra_+3A_x">x</code>, <code id="linesTetrahedra_+3A_y">y</code>, <code id="linesTetrahedra_+3A_z">z</code></td>
<td>
<p>numeric vectors of length two or matrices with two
columns representing coordinates of starting and ending points 
of line(s).</p>
</td></tr>
<tr><td><code id="linesTetrahedra_+3A_delta">delta</code></td>
<td>
<p>numeric; increase in each dimension used to locate points
along the lines; recycled to length 3.</p>
</td></tr>
<tr><td><code id="linesTetrahedra_+3A_lwd">lwd</code></td>
<td>
<p>numeric; used for the size of the tetrahedron in each
dimension; recycled to length 3.</p>
</td></tr>
<tr><td><code id="linesTetrahedra_+3A_color">color</code></td>
<td>
<p>color to use for the tetrahedra.</p>
</td></tr>
<tr><td><code id="linesTetrahedra_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to
<code>makeTriangles</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the Bresenham's line algorithm to locate points along
lines and then creates a triangle mesh scene representing tetrahedra
centered at those points.
</p>


<h3>Value</h3>

<p>Returns a triangle mesh scene representing the lines.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+lines3d">lines3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- pointsTetrahedra(x=c(100,100, 257, 257), 
                      y=c(100,100, 257, 257),
                      z=c(100,257, 257, 100), size=1)
l &lt;- linesTetrahedra(x=matrix(c(100,257,
                                100,257), nrow=2, byrow=TRUE),
                     y=matrix(c(100,257,
                                100,257), nrow=2, byrow=TRUE),
                     z=matrix(c(100,257,
                                257,100), nrow=2, byrow=TRUE),
                     lwd=0.4,
                     col="red")
drawScene.rgl(list(p, l))
</code></pre>

<hr>
<h2 id='parametric3d'>Draw a 3D Parametric Plot</h2><span id='topic+parametric3d'></span>

<h3>Description</h3>

<p>Plot a two-parameter surface in three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  parametric3d(fx, fy, fz, u, v, umin, umax, vmin, vmax, n = 100,
               color = "white", color2 = NA, alpha = 1,
               fill = TRUE, col.mesh = if (fill) NA else color,
               smooth = 0, material = "default", 
               add = FALSE, draw = TRUE, engine = "rgl", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametric3d_+3A_fx">fx</code>, <code id="parametric3d_+3A_fy">fy</code>, <code id="parametric3d_+3A_fz">fz</code></td>
<td>
<p>vectorized functions of u and v to compute the
<code>x</code>, <code>y</code>, and <code>z</code> coordinates.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_u">u</code></td>
<td>
<p>numeric vector of u values.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_v">v</code></td>
<td>
<p>numeric vector of v values.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_umin">umin</code></td>
<td>
<p>numeric; the minimum value of u. Ignored if <code>u</code> is
supplied.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_umax">umax</code></td>
<td>
<p>numeric; the maximum value of u. Ignored if <code>u</code> is
supplied.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_vmin">vmin</code></td>
<td>
<p>numeric; the minimum value of v. Ignored if <code>v</code> is
supplied.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_vmax">vmax</code></td>
<td>
<p>numeric; the maximum value of v. Ignored if <code>v</code> is
supplied.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_n">n</code></td>
<td>
<p>the number of equally spaced <code>u</code> and <code>v</code> values to
use.  Ignored if <code>u</code> and <code>v</code> are supplied.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_color">color</code></td>
<td>
<p>color to use for the surface. Can also be a function of
three arguments.  This is called with three arguments, the
coordinates of the midpoints of the triangles making up the surface.
The function should return a vector of colors to use for the
triangles.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_color2">color2</code></td>
<td>
<p>opposite face color.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel level, a number between 0 and 1..</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, drawing should use filled
surfaces; otherwise a wire frame should be drawn.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_col.mesh">col.mesh</code></td>
<td>
<p>color to use for the wire frame.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_smooth">smooth</code></td>
<td>
<p>integer or logical specifying Phong shading level for
&quot;standard&quot; and &quot;grid&quot; engines or whether or not to use shading for
the &quot;rgl&quot; engine.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_material">material</code></td>
<td>
<p>material specification; currently only used by
&quot;standard&quot; and &quot;grid&quot; engines.  Currently possible values are the
character strings &quot;dull&quot;, &quot;shiny&quot;, &quot;metal&quot;, and &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code>, add to current graph.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_draw">draw</code></td>
<td>
<p>logical; if <code>TRUE</code>, draw the results; otherwise,
return triangle mesh structure.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_engine">engine</code></td>
<td>
<p>character; currently &quot;rgl&quot;, &quot;standard&quot;, &quot;grid&quot; or &quot;none&quot;;
for &quot;none&quot; the computed triangles are returned.</p>
</td></tr>
<tr><td><code id="parametric3d_+3A_...">...</code></td>
<td>
<p>additional rendering arguments, e.g. material and texture
properties for the &quot;rgl&quot; engine.   See documentation for
<code><a href="#topic+drawScene">drawScene</a></code> and <code><a href="#topic+drawScene.rgl">drawScene.rgl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Analogous to Mathematica's <code>Param3D</code>.  Evaluates the
functions <code>fx</code>, <code>fy</code>, and <code>fz</code> specifying the
coordinates of the surface at a grid of values for the
parameters <code>u</code> and <code>v</code>.
</p>


<h3>Value</h3>

<p>For the &quot;rgl&quot; engine the returned value is <code>NULL</code>. For the
&quot;standard&quot; and &quot;grid&quot; engines the returned value is the viewing
transformation as returned by <code>persp</code>.  For the engine &quot;none&quot;, or
when <code>draw</code> is not true, the returned value is a structure
representing the triangles making up the surface.
</p>


<h3>Note</h3>

<p>The &quot;rgl&quot; engine now uses the standard rgl coordinates instead of
negating <code>y</code> and swapping <code>y</code> and <code>z</code>. If you need to
reproduce the previous behavior you can use
<code>options(old.misc3d.orientation=TRUE)</code>.
</p>
<p>Transparency only works properly in the &quot;rgl&quot; engine.  For standard or
grid graphics on pdf or quartz devices using alpha levels less than 1
does work but the triangle borders show as a less transparent mesh.
</p>


<h3>References</h3>

 
<p>Daniel Adler, Oleg Nenadic and Walter Zucchini (2003)
RGL: A R-library for 3D visualization with OpenGL
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+surface3d">surface3d</a></code>,
<code><a href="rgl.html#topic+material3d">material3d</a></code>,<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1: Ratio-of-Uniform sampling region of bivariate normal
  parametric3d(fx = function(u, v) u * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fy = function(u, v) v * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fz = function(u, v) exp(-0.5 * (u^2 + v^2 - 2 * 0.75 * u * 
                      v)/sqrt(1-.75^2))^(1/3),
               umin = -20, umax = 20, vmin = -20, vmax = 20, 
               n = 100)	
  parametric3d(fx = function(u, v) u * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fy = function(u, v) v * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fz = function(u, v) exp(-0.5 * (u^2 + v^2 - 2 * 0.75 * u * 
                      v)/sqrt(1-.75^2))^(1/3),
               u = qcauchy((1:100)/101), v = qcauchy((1:100)/101))	
  parametric3d(fx = function(u, v) u * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fy = function(u, v) v * exp(-0.5 * (u^2 + v^2 -
                      2 * 0.75 * u * v)/sqrt(1-.75^2))^(1/3),
               fz = function(u, v) exp(-0.5 * (u^2 + v^2 - 2 * 0.75 * u * 
                      v)/sqrt(1-.75^2))^(1/3),
               u = qcauchy((1:100)/101), v = qcauchy((1:100)/101),
               engine = "standard", scale = FALSE, screen = list(x=-90, y=20))

  #Example 2: Ratio-of-Uniform sampling region of Bivariate t      
  parametric3d(fx = function(u,v) u*(dt(u,2) * dt(v,2))^(1/3), 
               fy = function(u,v) v*(dt(u,2) * dt(v,2))^(1/3),
               fz = function(u,v) (dt(u,2) * dt(v,2))^(1/3), 
               umin = -20, umax = 20, vmin = -20, vmax = 20, 
               n = 100, color = "green")
  parametric3d(fx = function(u,v) u*(dt(u,2) * dt(v,2))^(1/3),
               fy = function(u,v) v*(dt(u,2) * dt(v,2))^(1/3),
               fz = function(u,v) (dt(u,2) * dt(v,2))^(1/3),
               u = qcauchy((1:100)/101), v = qcauchy((1:100)/101),
               color = "green")
  parametric3d(fx = function(u,v) u*(dt(u,2) * dt(v,2))^(1/3),
               fy = function(u,v) v*(dt(u,2) * dt(v,2))^(1/3),
               fz = function(u,v) (dt(u,2) * dt(v,2))^(1/3),
               u = qcauchy((1:100)/101), v = qcauchy((1:100)/101),
               color = "green", engine = "standard", scale = FALSE)


  #Example 3: Surface of revolution
  parametric3d(fx = function(u,v) u,
               fy = function(u,v) sin(v)*(u^3+2*u^2-2*u+2)/5,
               fz = function(u,v) cos(v)*(u^3+2*u^2-2*u+2)/5,
               umin = -2.3, umax = 1.3, vmin = 0, vmax = 2*pi)
  parametric3d(fx = function(u,v) u,
               fy = function(u,v) sin(v)*(u^3+2*u^2-2*u+2)/5,
               fz = function(u,v) cos(v)*(u^3+2*u^2-2*u+2)/5,
               umin = -2.3, umax = 1.3, vmin = 0, vmax = 2*pi,
               engine = "standard", scale = FALSE,
               color = "red", color2 = "blue", material = "shiny")

</code></pre>

<hr>
<h2 id='pointsTetrahedra'>Create a Set of Tetrahetra Centered at Data Points</h2><span id='topic+pointsTetrahedra'></span>

<h3>Description</h3>

<p>Creates a scene consisting of small tetrahedra centered at
specified data points in three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsTetrahedra(x, y, z, size = 0.01, color = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsTetrahedra_+3A_x">x</code>, <code id="pointsTetrahedra_+3A_y">y</code>, <code id="pointsTetrahedra_+3A_z">z</code></td>
<td>
<p>numeric vectors representing point coordinates.</p>
</td></tr>
<tr><td><code id="pointsTetrahedra_+3A_size">size</code></td>
<td>
<p>numeric; multiple of data range to use for the size of the
tetrahedron in each dimension; recycled to length 3.</p>
</td></tr>
<tr><td><code id="pointsTetrahedra_+3A_color">color</code></td>
<td>
<p>color to use for the tetrahedra.</p>
</td></tr>
<tr><td><code id="pointsTetrahedra_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to
<code>makeTriangles</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful, for example, for incorporating raw data along
with a density estimate surface in a scene rendered using standard or
grid graphics.  For <span class="pkg">rgl</span> rendering <code><a href="rgl.html#topic+points3d">points3d</a></code> is
an alternative.
</p>


<h3>Value</h3>

<p>Returns a triangle mesh scene representing the tetrahedra.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+points3d">points3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  with(quakes, {
      d &lt;- kde3d(long, lat, -depth, n = 40)
      v &lt;- contour3d(d$d, exp(-12),d$x/22, d$y/28, d$z/640,
                     color="green", color2="gray", draw=FALSE)
      p &lt;- pointsTetrahedra(long/22, lat/28, -depth/640,
                            size = 0.005)
      drawScene(list(v, p))
  })
</code></pre>

<hr>
<h2 id='slices3d'>Interactive Image Slices of 3D or 4D Volume Data</h2><span id='topic+slices3d'></span>

<h3>Description</h3>

<p>Uses <span class="pkg">tkrplot</span> to create an interactive slice view of three or four
dimensional volume data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slices3d(vol1, vol2=NULL, rlim1, rlim2, col1, col2, main,
         scale = 0.8, alpha=1, cross = TRUE,
         layout=c("counterclockwise", "clockwise"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slices3d_+3A_vol1">vol1</code></td>
<td>
<p>a three or four dimensional real array. If two images are
overlaid, then this is the one at bottom.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_vol2">vol2</code></td>
<td>
<p>a three or four dimensional real array. If two images are
overlaid, then this is the one on top. The default value is
<code>NULL</code>, when only <code>vol1</code> is drawn.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_rlim1">rlim1</code></td>
<td>
<p>the minimum and maximum <code>vol1</code> values for which
colors should be plotted, defaulting to the range of the values of
<code>vol1</code>.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_rlim2">rlim2</code></td>
<td>
<p>the minimum and maximum <code>vol2</code> values for which
colors should be plotted, defaulting to the range of the values of
<code>vol2</code>, if two images are overlaid.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_col1">col1</code></td>
<td>
<p>a list of colors for <code>vol1</code>.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_col2">col2</code></td>
<td>
<p>a list of colors for <code>vol2</code>.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_main">main</code></td>
<td>
<p>a character vector; main title for the plot.</p>
</td></tr> 
<tr><td><code id="slices3d_+3A_scale">scale</code></td>
<td>
<p>real value for scaling embedded plot size.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_alpha">alpha</code></td>
<td>
<p>real value for transparency level, if two images are
overlaid. The default value is 1.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_cross">cross</code></td>
<td>
<p>logical; if <code>TRUE</code>, show cross hairs of current
slices.</p>
</td></tr>
<tr><td><code id="slices3d_+3A_layout">layout</code></td>
<td>
<p>a character string specifying the layout. It must be
either &quot;counterclockwise&quot; or &quot;clockwise&quot;, and may be abbreviated.
The default is &quot;counterclockwise&quot;. Images corresponding to
the x-y planes are always displayed in the third quadrant.
If <code>layout</code> is counterclockwise, then the first quadrant
shows images from the y-z planes and the second quadrant the x-z
planes.	Otherwise, the images in the first and the second quadrant
are switched. The fourth quadrant is left for the slider used to
select the value of the fourth index (if any) of input array(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shows slices of 3D array along the axes as produced by <code>image</code>,
along with sliders for controlling which slices are shown.  For 4D
data an additional slider selects the value of the fourth index.
Two images can be overlaid. This is useful for viewing medical imaging
data (e.g. PET scans and fMRI data).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1: View of a mixture of three tri-variate normal densities
  nmix3 &lt;- function(x, y, z, m, s) {
      0.4 * dnorm(x, m, s) * dnorm(y, m, s) * dnorm(z, m, s) +
      0.3 * dnorm(x, -m, s) * dnorm(y, -m, s) * dnorm(z, -m, s) +
      0.3 * dnorm(x, m, s) * dnorm(y, -1.5 * m, s) * dnorm(z, m, s)
  }
  x&lt;-seq(-2, 2, len=40)
  g&lt;-expand.grid(x = x, y = x, z = x)
  v&lt;-array(nmix3(g$x,g$y,g$z, .5,.5), c(40,40,40))
  slices3d(vol1=v, main="View of a mixture of three tri-variate normals", col1=heat.colors(256))

## Not run: 
  #Example 2: Put a z-map from fMRI data on top of a structure
  #           image. The threshold value of the z-map is 2.
  library(AnalyzeFMRI)
  temp&lt;-f.read.analyze.volume("standard.img")
  z&lt;-f.read.analyze.volume("z-map.img")
  slices3d(vol1=temp, vol2=z[,,,1], rlim2=c(2,Inf),col2=heat.colors(20),
          main="Regions above threshold values.")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceTriangles'>Create a Triangle Mesh Representing a Surface</h2><span id='topic+surfaceTriangles'></span>

<h3>Description</h3>

<p>Creates a triangle mesh object representing a surface over a
rectangular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceTriangles(x, y, f, color = "red", color2 = NA, alpha = 1,
                 fill = TRUE, col.mesh = if (fill) NA else color,
                 smooth = 0, material = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceTriangles_+3A_x">x</code>, <code id="surfaceTriangles_+3A_y">y</code></td>
<td>
<p>numeric vectors.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_f">f</code></td>
<td>
<p>numeric matrix of dimension <code>length(x)</code> by
<code>length(y)</code> or vectorized function of two arguments.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_color">color</code></td>
<td>
<p>color to use for the surface. Can also be a function of
three arguments.  This is called with three arguments, the
coordinates of the midpoints of the triangles making up the surface.
The function should return a vector of colors to use for the
triangles.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_color2">color2</code></td>
<td>
<p>opposite face color.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel level, a number between 0 and 1..</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, drawing should use filled
surfaces; otherwise a wire frame should be drawn.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_col.mesh">col.mesh</code></td>
<td>
<p>color to use for the wire frame.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_smooth">smooth</code></td>
<td>
<p>integer or logical specifying Phong shading level for
&quot;standard&quot; and &quot;grid&quot; engines or whether or not to use shading for
the &quot;rgl&quot; engine.</p>
</td></tr>
<tr><td><code id="surfaceTriangles_+3A_material">material</code></td>
<td>
<p>material specification; currently only used by
&quot;standard&quot; and &quot;grid&quot; engines.  Currently possible values are the
character strings &quot;dull&quot;, &quot;shiny&quot;, &quot;metal&quot;, and &quot;default&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a triangle mesh object representing the surface.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="rgl.html#topic+rgl.surface">rgl.surface</a></code>,
<code><a href="rgl.html#topic+surface3d">surface3d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  drawScene(surfaceTriangles(seq(-1,1,len=30), seq(-1,1,len=30),
                             function(x, y) (x^2 + y^2), color2 = "green"))
  drawScene.rgl(surfaceTriangles(seq(-1,1,len=30), seq(-1,1,len=30),
                             function(x, y) (x^2 + y^2), color2 = "green"))
</code></pre>

<hr>
<h2 id='teapot'>Utah Teapot</h2><span id='topic+teapot'></span>

<h3>Description</h3>

<p>The Utah teapot is a classic computer graphics example.  This data set
contains a representation in terms of triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(teapot)
</code></pre>


<h3>Format</h3>

<p>A list with components <code>vertices</code> and
<code>edges</code>. <code>vertices</code> is a 3 by 1976 numeric matrix of the
coordinates of the vertices. <code>edges</code> is a 3 by 3751 integer matrix
of the  indices of the triangles.</p>


<h3>Source</h3>

<p>Converted from the netCDF file that was at one time made available by Dave Forrest at
<code style="white-space: pre;">&#8288;http://www.maplepark.com/~drf5n/extras/teapot.nc&#8288;</code>.
</p>

<hr>
<h2 id='triangles'>Triangle Mesh Functions</h2><span id='topic+makeTriangles'></span><span id='topic+updateTriangles'></span><span id='topic+scaleTriangles'></span><span id='topic+translateTriangles'></span><span id='topic+transformTriangles'></span>

<h3>Description</h3>

<p>Functions to create and modify triangle mesh objects representing 3D
surfaces..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTriangles(v1, v2, v3, color = "red", color2 = NA, alpha = 1,
              fill = TRUE, col.mesh = if (fill) NA else color,
              smooth = 0, material = "default")
updateTriangles(triangles, color, color2, alpha, fill, col.mesh,
                material, smooth)
translateTriangles(triangles, x = 0, y = 0, z = 0)
scaleTriangles(triangles, x = 1, y = x, z = x)
transformTriangles(triangles, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangles_+3A_v1">v1</code>, <code id="triangles_+3A_v2">v2</code>, <code id="triangles_+3A_v3">v3</code></td>
<td>
<p>specification of triangle coordinates. If all three
are provided then they should be matrices with three columns
representing coordinates of the first, second, and third vertices of
the triangles.  If only <code>v1</code> and <code>v2</code> are provided then
<code>v1</code> should be a numeric matrix with three rows specifying
coordinates of vertices, and <code>v2</code> should be an integer matrix
with three rows specifying the indexes of the vertices in the
triangles.  If only <code>v1</code> is provided then it should be a matrix
with three columns and number of rows divisible by three specifying
the vertices of the triangles in groups of three.</p>
</td></tr>
<tr><td><code id="triangles_+3A_triangles">triangles</code></td>
<td>
<p>triangle mesh object.</p>
</td></tr>
<tr><td><code id="triangles_+3A_x">x</code>, <code id="triangles_+3A_y">y</code>, <code id="triangles_+3A_z">z</code></td>
<td>
<p>numeric of length one. Amounts by which to translate or
scale corresponding coordinates.</p>
</td></tr>
<tr><td><code id="triangles_+3A_color">color</code></td>
<td>
<p>color to use for the surface. Can also be a function of
three arguments.  This is called with three arguments, the
coordinates of the midpoints of the triangles making up the surface.
The function should return a vector of colors to use for the
triangles.</p>
</td></tr>
<tr><td><code id="triangles_+3A_color2">color2</code></td>
<td>
<p>opposite face color.</p>
</td></tr>
<tr><td><code id="triangles_+3A_alpha">alpha</code></td>
<td>
<p>alpha channel level, a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="triangles_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, drawing should use filled
surfaces; otherwise a wire frame should be drawn.</p>
</td></tr>
<tr><td><code id="triangles_+3A_col.mesh">col.mesh</code></td>
<td>
<p>color to use for the wire frame.</p>
</td></tr>
<tr><td><code id="triangles_+3A_smooth">smooth</code></td>
<td>
<p>integer or logical specifying Phong shading level for
&quot;standard&quot; and &quot;grid&quot; engines or whether or not to use shading for
the &quot;rgl&quot; engine.</p>
</td></tr>
<tr><td><code id="triangles_+3A_material">material</code></td>
<td>
<p>material specification; currently only used by
&quot;standard&quot; and &quot;grid&quot; engines. Currently possible values are the
character strings &quot;dull&quot;, &quot;shiny&quot;, &quot;metal&quot;, and &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="triangles_+3A_r">R</code></td>
<td>
<p>4 by 4 homogeneous coordinate transformation matrix to apply.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeTriangles</code> creates a triangle mesh object.
<code>updateTriangles</code> modifies fields of such an object.  Both may
perform some consistency checks.
</p>
<p><code>translateTriangles</code> and <code>scaleTriangles</code> translate or scale
the vertex locations of triangle mesh objects by specified amounts.
</p>
<p><code>transformTriangles</code> applies a transformation specified by a 4 by
4 homogeneous transformation matrix.
</p>


<h3>Value</h3>

<p>A triangle mesh object of class <code>Triangles3D</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
