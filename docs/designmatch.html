<!DOCTYPE html><html><head><title>Help for package designmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {designmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#absstddif'>
<p>Absolute standardized differences in means.</p></a></li>
<li><a href='#bmatch'><p>Optimal bipartite matching in observational studies</p></a></li>
<li><a href='#cardmatch'><p>Optimal cardinality matching in observational studies</p></a></li>
<li><a href='#designmatch-package'>
<p>Optimal Matched Design of Randomized Experiments and Observational Studies</p></a></li>
<li><a href='#distmat'><p>Build a rank-based Mahalanobis distance matrix</p></a></li>
<li><a href='#distmatch'><p>Optimal distance matching in observational studies</p></a></li>
<li><a href='#ecdfplot'><p>Empirical cumulative distribution function plot for assessing covariate balance</p></a></li>
<li><a href='#finetab'><p>Tabulate the marginal distribution of a nominal covariate after matching</p></a></li>
<li><a href='#germancities'><p>Data from German cities before and after the Second World War</p></a></li>
<li><a href='#lalonde'><p>Lalonde data set</p></a></li>
<li><a href='#loveplot'><p>Love plot for assessing covariate balance</p></a></li>
<li><a href='#meantab'><p>Tabulate means of covariates after matching</p></a></li>
<li><a href='#nmatch'>
<p>Optimal nonbipartite matching in randomized experiments and observational studies</p></a></li>
<li><a href='#pairsplot'><p>Pairs plot for visualizing matched pairs</p></a></li>
<li><a href='#profmatch'><p>Optimal profile matching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matched Samples that are Balanced and Representative by Design</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;, Juan P. Vielma &lt;jvielma@mit.edu&gt;, Eric R. Cohn &lt;ericcohn@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2), lattice, MASS, slam, highs</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gurobi, Rcplex, Rglpk, Rmosek, Rsymphony</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Includes functions for the construction of matched samples that are balanced and representative by design.  Among others, these functions can be used for matching in observational studies with treated and control units, with cases and controls, in related settings with instrumental variables, and in discontinuity designs.  Also, they can be used for the design of randomized experiments, for example, for matching before randomization.  By default, 'designmatch' uses the 'highs' optimization solver, but its performance is greatly enhanced by the 'Gurobi' optimization solver and its associated R interface.  For their installation, please follow the instructions at <a href="https://www.gurobi.com/documentation/quickstart.html">https://www.gurobi.com/documentation/quickstart.html</a> and <a href="https://www.gurobi.com/documentation/7.0/refman/r_api_overview.html">https://www.gurobi.com/documentation/7.0/refman/r_api_overview.html</a>.  We have also included directions in the gurobi_installation file in the inst folder.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 15:47:00 UTC; eric</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 16:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='absstddif'>
Absolute standardized differences in means.  
</h2><span id='topic+absstddif'></span>

<h3>Description</h3>

<p>Function for calculating absolute differences in means between the covariates in the treatment and control groups in terms of the original units of the covariates.  Here, the absolute differences in means are normalized by the simple average of the treated and control standard deviations before matching (see Rosenbaum and Rubin 1985 for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	absstddif(X_mat, t_ind, std_dif)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absstddif_+3A_x_mat">X_mat</code></td>
<td>
<p>matrix of covariates: a matrix of covariates used to build the rank-based Mahalanobis distance matrix.</p>
</td></tr>
<tr><td><code id="absstddif_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).</p>
</td></tr>
<tr><td><code id="absstddif_+3A_std_dif">std_dif</code></td>
<td>
<p>standardized differences: a scalar determining the number of absolute standardized differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector that can be used with the <code>mom</code>, <code>near</code> and <code>far</code> options of <code>bmatch</code> and <code>nmatch</code>.
</p>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Rosenbaum, P. R., and Rubin, D. B. (1985), &quot;Constructing a Control Group by Multivariate Matched Sampling Methods that Incorporate the Propensity Score,&quot; <em>The American Statistician</em>, 39, 33-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and attach data
data(lalonde)
attach(lalonde)

# Treatment indicator
t_ind = treatment

# Constrain differences in means to be at most .05 standard deviations apart
mom_covs = cbind(age, education, black, hispanic, married, nodegree, re74, re75)
mom_tols = absstddif(mom_covs, t_ind, .05)
</code></pre>

<hr>
<h2 id='bmatch'>Optimal bipartite matching in observational studies</h2><span id='topic+bmatch'></span>

<h3>Description</h3>

<p>Function for optimal bipartite matching in observational studies that directly balances the observed covariates.  <code>bmatch</code> allows the user to enforce different forms of covariate balance in the matched samples such as moment balance (e.g., of means, variances and correlations), distributional balance (e.g., fine balance, near-fine balance, strength-<em>k</em> balancing) and exact matching.  In observational studies where an instrumental variable is available, <code>bmatch</code> can be used to handle weak instruments and strengthen them by means of the <code>far</code> options (see Yang et al. 2014 for an example). <code>bmatch</code> can also be used in discontinuity designs by matching units in a neighborhood of the discontinuity (see Keele et al. 2015 for details).  In any of these settings, <code>bmatch</code> either minimizes the total sum of covariate distances between matched units, maximizes the total number of matched units, or optimizes a combination of the two, subject to matching, covariate balancing, and representativeness constraints (see the examples below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	bmatch(t_ind, dist_mat = NULL, subset_weight = NULL, n_controls = 1,
	       total_groups = NULL, mom = NULL, ks = NULL, exact = NULL, 
	       near_exact = NULL, fine = NULL, near_fine = NULL, near = NULL, 
	       far = NULL, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmatch_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).  Please note that the data needs to be sorted in decreasing order according to this treatment indicator.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_dist_mat">dist_mat</code></td>
<td>
<p>distance matrix: a matrix of positive distances between treated units (rows) and controls (columns).  If <code>dist_mat = NULL</code> and <code>subset_weight = 1</code>, then bmatch will solve the cardinality matching problem in Zubizarreta et al. (2014).</p>
</td></tr>
<tr><td><code id="bmatch_+3A_subset_weight">subset_weight</code></td>
<td>
<p>subset matching weight: a scalar that regulates the trade-off between the total sum of distances between matched pairs and the total number of matched pairs.  The larger <code>subset_weight</code>, the more importance will be given to the the total number of matched pairs relative to the total sum of distances between matched pairs.  See Rosenbaum (2012) and Zubizarreta et al. (2013) for a discussion of this parameter. 
</p>
<p>If <code>subset_weight = NULL</code>, then <code>bmatch</code> will match all the treated observations, provided there exists a feasible solution.
</p>
<p>If <code>subset_weight = 1</code> and <code>dist_mat = NULL</code>, then <code>bmatch</code> will solve the cardinality matching problem in Zubizarreta et al. (2014).</p>
</td></tr>
<tr><td><code id="bmatch_+3A_n_controls">n_controls</code></td>
<td>
<p>number of controls: a scalar defining the number of controls to be matched with a fixed rate to each treated unit.  The default is <code>n_controls = 1</code>, i.e. pair matching.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_total_groups">total_groups</code></td>
<td>
<p>total number of matched pairs: a scalar specifying the number of matched pairs to be obtained.  If <code>total_groups = NULL</code>, then no specific number of matched pairs is required before matching.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_mom">mom</code></td>
<td>
<p>moment balance parameters: a list with three arguments, 
</p>
<p><code>mom = list(covs = mom_covs, tols = mom_tols, targets = mom_targets)</code>.
</p>
<p><code>mom_covs</code> is a matrix where each column is a covariate whose mean is to be balanced.  <code>mom_tols</code> is a vector of tolerances for the maximum difference in means for the covariates in <code>mom_covs</code>.  <code>mom_targets</code> is a vector of target moments (e.g., means) of a distribution to be approximated by matched sampling.  <code>mom_targets</code> is optional, but if <code>mom_covs</code> is specified then <code>mom_tols</code> needs to be specified too.  If <code>mom_targets</code> is <code>NULL</code>, then <code>bmatch</code> will match treated and control units so that covariates in <code>mom_covs</code> differ at most by <code>mom_tols</code>.  If <code>mom_targets</code> is specified, then <code>bmatch</code> will match treated and control units so that each matched group differs at most by <code>mom_tols</code> units from the respective moments in <code>mom_targets</code>.  As a result, the matched groups will differ at most <code>mom_tols * 2</code> from each other.  Under certain assumptions, <code>mom_targets</code> can be used for constructing a representative matched sample.  The lengths of <code>mom_tols</code> and <code>mom_target</code> have to be equal to the number of columns of <code>mom_covs</code>.  Note that the columns of <code>mom_covs</code> can be transformations of the original covariates to balance higher order single-dimensional moments like variances and skewness, and multidimensional moments such as correlations (Zubizarreta 2012).</p>
</td></tr>
<tr><td><code id="bmatch_+3A_ks">ks</code></td>
<td>
<p>Kolmogorov-Smirnov balance parameters: a list with three objects, 
</p>
<p><code>ks = list(covs = ks_covs, n_grid = ks_n_grid, tols = ks_tols)</code>.  
</p>
<p><code>ks_covs</code> is a matrix where each column is a covariate whose difference in a coarsened version of the Kolmogorov-Smirnov statistic between treated units and matched controls is to be constrained.  <code>ks_n_grid</code> is  scalar defining the number of equispaced grid points for calculating the Kolmogorov-Smirnov statistic between the distributions of the treated units and matched controls for the covariates in <code>ks_covs</code>.  The defaul is <code>ks_n_grid = 10</code> for the deciles of the empirical cumulative distribution functions of the treated units for the covariate in question.  <code>ks_tols</code> is a vector of tolerances for the maximum differences in means for the covariates defined in <code>ks_covs</code>.  Note that the length of <code>ks_tols</code> has to be equal to the number of columns of <code>ks_covs</code>.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_exact">exact</code></td>
<td>
<p>Exact matching parameters: a list with one argument, 
</p>
<p><code>exact = list(covs = exact_covs)</code>, 
</p>
<p>where <code>exact_covs</code> is a matrix where each column is a nominal covariate for exact matching.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_near_exact">near_exact</code></td>
<td>
<p>Near-exact matching parameters: a list with two objects, 
</p>
<p><code>near_exact = list(covs = near_exact_covs, devs = near_exact_devs)</code>. 
</p>
<p><code>near_exact_covs</code> are the near-exact matching covariates; specifically, a matrix where each column is a nominal covariate for near-exact matching.  <code>near_exact_devs</code> are the maximum deviations from near-exact matching: a vector of scalars defining the maximum deviation allowed from exact matching for the covariates defined in <code>near_exact_covs</code>.  Note that the length of <code>near_exact_devs</code> has to be equal to the number of columns of <code>near_exact_covs</code>.  For detailed expositions of near-exact matching, see section 9.2 of Rosenbaum (2010) and Zubizarreta et al. (2011).</p>
</td></tr>
<tr><td><code id="bmatch_+3A_fine">fine</code></td>
<td>
<p>Fine balance parameters: a list with one argument, 
</p>
<p><code>fine = list(covs = fine_covs)</code>, 
</p>
<p>where <code>fine_covs</code> is a matrix where each column is a nominal covariate for fine balance.  Fine balance enforces exact distributional balance on nominal covariates, but without constraining treated and control units to be matched within each category of each nominal covariate as in exact matching.  See chapter 10 of Rosenbaum (2010) for details.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_near_fine">near_fine</code></td>
<td>
<p>Near-fine balance parameters: a list with two objects, 
</p>
<p><code>near_fine = list(covs = near_fine_covs, devs = near_fine_devs)</code>.
</p>
<p><code>near_fine_covs</code> is a matrix where each column is a nominal covariate for near-fine matching. <code>near_fine_devs</code> is a vector of scalars defining the maximum deviation allowed from fine balance for the covariates in <code>near_fine_covs</code>.  Note that the length of <code>near_fine_devs</code> has to be equal to the number of columns of <code>near_fine_covs</code>.  See Yang et al. (2012) for a description of near-fine balance.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_near">near</code></td>
<td>
<p>Near matching parameters: a list with three objects, 
</p>
<p><code>near = list(covs = near_covs, pairs = near_pairs, groups = near_groups)</code>.
</p>
<p><code>near_covs</code> is a matrix where each column is a variable for near matching.  <code>near_pairs</code> is a vector determining the maximum distance between individual matched pairs for each variable in <code>near_covs</code>.  <code>near_groups</code> is a vector determining the maximum average distance between matched groups (in aggregate) for each covariate in <code>near_covs</code>.  If <code>near_covs</code> is specified, then either <code>near_pairs</code>, <code>near_covs</code> or both must be specified as well, and the length of <code>near_pairs</code> and/or <code>near_groups</code> has to be equal to the number of columns of <code>near_covs</code>.  The <code>near</code> options can be useful for matching within a window of a discontinuity (see Keele et al. 2015 for details).
</p>
</td></tr>
<tr><td><code id="bmatch_+3A_far">far</code></td>
<td>
<p>Far matching parameters: a list with three objects, 
</p>
<p><code>far = list(covs = far_covs, pairs = far_pairs, groups = far_groups)</code>.  
</p>
<p><code>far_covs</code> is a matrix where each column is a variable (a covariate or an instrumental variable) for far matching.  <code>far_pairs</code> is a vector determining the minimum distance between units in a matched pair for each variable in <code>far_covs</code>, and <code>far_groups</code> is a vector defining the minimum average (aggregate) distance between matched groups for each variable in <code>far_covs</code>.  If <code>far_covs</code> is specified, then either <code>far_pairs</code>, <code>far_covs</code>, or both, must be specified, and the length of <code>far_pairs</code> and/or <code>far_groups</code> has to be equal to the number of columns of <code>far_covs</code>.  See Yang et al. (2014) for strengthening an instrumental variable via far matching in a bipartite setting.</p>
</td></tr>
<tr><td><code id="bmatch_+3A_solver">solver</code></td>
<td>

<p>Optimization solver parameters: a list with four objects, 
</p>
<p><code>solver = list(name = name, t_max = t_max, approximate = 1, round_cplex = 0,</code><br />
<code>    trace_cplex = 0)</code>.
</p>
<p><code>solver</code> is a string that determines the optimization solver to be used.  The options are: <code>cplex</code>, <code>glpk</code>, <code>gurobi</code>, <code>highs</code>, and <code>symphony</code>.  The default solver is <code>highs</code> with <code>approximate = 1</code>, so that by default an approximate solution is found (see <code>approximate</code> below).  For an exact solution, we strongly recommend using <code>cplex</code> or <code>gurobi</code> as they are much faster than the other solvers, but they do require a license (free for academics, but not for people outside universities).  Between <code>cplex</code> and <code>gurobi</code>, note that installing the R interface for <code>gurobi</code> is much simpler.
</p>
<p><code>t_max</code> is a scalar with the maximum time limit for finding the matches.  This option is specific to <code>cplex</code> and <code>gurobi</code>.  If the optimal matches are not found within this time limit, a partial, suboptimal solution is given.  
</p>
<p><code>approximate</code> is a scalar that determines the method of solution.  If <code>approximate = 1</code> (the default), an approximate solution is found via a relaxation of the original integer program.  This method of solution is faster than <code>approximate = 0</code>, but some balancing constraints may be violated to some extent.  This option works only with <code>n_controls = 1</code>, i.e. pair matching.
</p>
<p><code>round_cplex</code> is binary specific to <code>cplex</code>.  <code>round_cplex = 1</code> ensures that the solution found is integral by rounding and all the constraints are exactly statisfied; <code>round_cplex = 0</code> (the default) encodes there is no rounding which may return slightly infeasible integer solutions.  
</p>
<p><code>trace</code> is a binary specific to <code>cplex</code> and <code>gurobi</code>. <code>trace = 1</code> turns the optimizer output on. The default is <code>trace = 0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal solution, with the following objects:
</p>
<table>
<tr><td><code>obj_total</code></td>
<td>
<p>value of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>obj_dist_mat</code></td>
<td>
<p>value of the total sum of distances term of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>t_id</code></td>
<td>
<p>indexes of the matched treated units at the optimum;</p>
</td></tr>
<tr><td><code>c_id</code></td>
<td>
<p>indexes of the matched controls at the optimum;</p>
</td></tr>
<tr><td><code>group_id</code></td>
<td>
<p>matched pairs or groups at the optimum;</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time elapsed to find the optimal solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Keele, L., Titiunik, R., and Zubizarreta, J. R., (2015), &quot;Enhancing a Geographic Regression Discontinuity Design Through Matching to Estimate the Effect of Ballot Initiatives on Voter Turnout,&quot; <em>Journal of the Royal Statistical Society: Series A</em>, 178, 223-239.
</p>
<p>Rosenbaum, P. R. (2010), <em>Design of Observational Studies</em>, Springer.
</p>
<p>Rosenbaum, P. R. (2012), &quot;Optimal Matching of an Optimally Chosen Subset in Observa-
tional studies,&quot; <em>Journal of Computational and Graphical Statistics</em>, 21, 57-71.
</p>
<p>Yang, D., Small, D., Silber, J. H., and Rosenbaum, P. R. (2012), &quot;Optimal Matching With Minimal Deviation From Fine Balance in a Study of Obesity and Surgical Outcomes,&quot; <em>Biometrics</em>, 68, 628-36. 
</p>
<p>Yang. F., Zubizarreta, J. R., Small, D. S., Lorch, S. A., and Rosenbaum, P. R. (2014), &quot;Dissonant Conclusions When Testing the Validity of an Instrumental Variable,&quot; <em>The American Statistician</em>, 68, 253-263.
</p>
<p>Zubizarreta, J. R., Reinke, C. E., Kelz, R. R., Silber, J. H., and Rosenbaum, P. R. (2011), &quot;Matching for Several Sparse Nominal Variables in a Case-Control Study of Readmission Following Surgery,&quot; <em>The American Statistician</em>, 65, 229-238.
</p>
<p>Zubizarreta, J. R. (2012), &quot;Using Mixed Integer Programming for Matching in an Observational Study of Kidney Failure after Surgery,&quot; <em>Journal of the American Statistical Association</em>, 107, 1360-1371.
</p>
<p>Zubizarreta, J. R., Paredes, R. D., and Rosenbaum, P. R. (2014), &quot;Matching for Balance, Pairing for Heterogeneity in an Observational Study of the Effectiveness of For-profit and Not-for-profit High Schools in Chile,&quot; <em>Annals of Applied Statistics</em>, 8, 204-231.
</p>


<h3>See Also</h3>

<p><span class="pkg">sensitivitymv</span>, <span class="pkg">sensitivitymw</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Uncomment the following examples
## Load, sort, and attach data
#data(lalonde)
#lalonde = lalonde[order(lalonde$treatment, decreasing = TRUE), ]
#attach(lalonde)

################################# 
## Example 1: cardinality matching
################################# 

## Cardinality matching finds the largest matched sample of pairs that meets balance 
## requirements.  Here the balance requirements are mean balance, fine balance and 
## exact matching for different covariates. The solver used is glpk with the 
## approximate option.

## Treatment indicator; note that the data needs to be sorted in decreasing order
## according to this treatment indicator
#t_ind = treatment
#t_ind 

## Distance matrix
#dist_mat = NULL 

## Subset matching weight
#subset_weight = 1

## Moment balance: constrain differences in means to be at most .05 standard deviations apart
#mom_covs = cbind(age, education, black, hispanic, married, nodegree, re74, re75)
#mom_tols = round(absstddif(mom_covs, t_ind, .05), 2)
#mom = list(covs = mom_covs, tols = mom_tols)

## Fine balance
#fine_covs = cbind(black, hispanic, married, nodegree)
#fine = list(covs = fine_covs)

## Exact matching
#exact_covs = cbind(black)
#exact = list(covs = exact_covs)

## Solver options
#t_max = 60*5
#solver = "glpk"
#approximate = 1
#solver = list(name = solver, t_max = t_max, approximate = approximate,
#round_cplex = 0, trace = 0)

## Match                   
#out = bmatch(t_ind = t_ind, dist_mat = dist_mat, subset_weight = subset_weight, 
#mom = mom, fine = fine, exact = exact, solver = solver)              
              
## Indices of the treated units and matched controls
#t_id = out$t_id  
#c_id = out$c_id	

## Time
#out$time/60

## Matched group identifier (who is matched to whom)
#out$group_id

## Assess mean balance
#meantab(mom_covs, t_ind, t_id, c_id)

## Assess fine balance (note here we are getting an approximate solution)
#for (i in 1:ncol(fine_covs)) {		
#  print(finetab(fine_covs[, i], t_id, c_id))
#}

## Assess exact matching balance
#table(exact_covs[t_id]==exact_covs[c_id])

################################## 
## Example 2: minimum distance matching
################################## 

## The goal here is to minimize the total of distances between matched pairs.  In 
## this example there are no covariate balance requirements.  Again, the solver 
## used is glpk with the approximate option

## Treatment indicator
#t_ind = treatment

## Matrix of covariates
#X_mat = cbind(age, education, black, hispanic, married, nodegree, re74, re75)

## Distance matrix
#dist_mat = distmat(t_ind, X_mat)

## Subset matching weight
#subset_weight = NULL

## Total pairs to be matched
#total_groups = sum(t_ind)

## Solver options
#t_max = 60*5
#solver = "glpk"
#approximate = 1
#solver = list(name = solver, t_max = t_max, approximate = approximate, 
#round_cplex = 0, trace_cplex = 0)

## Match                   
#out = bmatch(t_ind = t_ind, dist_mat = dist_mat, total_groups = total_groups, 
#solver = solver)              
              
## Indices of the treated units and matched controls
#t_id = out$t_id  
#c_id = out$c_id	

## Total of distances between matched pairs
#out$obj_total

## Assess mean balance
#meantab(X_mat, t_ind, t_id, c_id)

################################## 
## Example 3: optimal subset matching
################################## 

## Optimal subset matching pursues two competing goals at 
## the same time: to minimize the total sum of covariate distances  
## while matching as many observations as possible.  The trade-off 
## between these two goals is regulated by the parameter subset_weight 
## (see Rosenbaum 2012 and Zubizarreta et al. 2013 for a discussion).
## Here the balance requirements are mean balance, near-fine balance 
## and near-exact matching for different covariates.
## Again, the solver used is glpk with the approximate option.

## Treatment indicator
#t_ind = treatment

## Matrix of covariates
#X_mat = cbind(age, education, black, hispanic, married, nodegree, re74, re75)

## Distance matrix
#dist_mat = distmat(t_ind, X_mat)

## Subset matching weight
#subset_weight = median(dist_mat)

## Moment balance: constrain differences in means to be at most .05 standard deviations apart
#mom_covs = cbind(age, education, black, hispanic, married, nodegree, re74, re75)
#mom_tols = round(absstddif(mom_covs, t_ind, .05), 2)
#mom = list(covs = mom_covs, tols = mom_tols)

## Near-fine balance
#near_fine_covs = cbind(married, nodegree)
#near_fine_devs = rep(5, 2)
#near_fine = list(covs = near_fine_covs, devs = near_fine_devs)

## Near-exact matching
#near_exact_covs = cbind(black, hispanic)
#near_exact_devs = rep(5, 2)
#near_exact = list(covs = near_exact_covs, devs = near_exact_devs)

## Solver options
#t_max = 60*5
#solver = "glpk"
#approximate = 1
#solver = list(name = solver, t_max = t_max, approximate = approximate, 
#round_cplex = 0, trace_cplex = 0)

## Match                   
#out = bmatch(t_ind = t_ind, dist_mat = dist_mat, subset_weight = subset_weight, 
#mom = mom, near_fine = near_fine, near_exact = near_exact, solver = solver)              
              
## Indices of the treated units and matched controls
#t_id = out$t_id  
#c_id = out$c_id	

## Time
#out$time/60

## Matched group identifier (who is matched to whom)
#out$group_id

## Assess mean balance (note here we are getting an approximate solution)
#meantab(X_mat, t_ind, t_id, c_id)

## Assess fine balance
#for (i in 1:ncol(near_fine_covs)) {		
#	print(finetab(near_fine_covs[, i], t_id, c_id))
#}

## Assess exact matching balance
#for (i in 1:ncol(near_exact_covs)) {	
#	print(table(near_exact_covs[t_id, i]==near_exact_covs[c_id, i]))
#}
	
</code></pre>

<hr>
<h2 id='cardmatch'>Optimal cardinality matching in observational studies</h2><span id='topic+cardmatch'></span>

<h3>Description</h3>

<p>Function for optimal cardinality matching in observational studies.  <code>cardmatch</code> finds the largest matched sample that is balanced and representative by design.  The formulation of <code>cardmatch</code> has been simplified to handle larger data than <code>bmatch</code> or <code>nmatch</code>.  Similar to <code>bmatch</code> or <code>nmatch</code>, the performance of <code>cardmatch</code> is greatly enhanced by using the <code>solver</code> options <code>cplex</code> or <code>gurobi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	cardmatch(t_ind, mom = NULL, fine = NULL, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cardmatch_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).  Please note that the data needs to be sorted in decreasing order according to this treatment indicator.</p>
</td></tr>
<tr><td><code id="cardmatch_+3A_mom">mom</code></td>
<td>
<p>moment balance parameters: a list with three arguments, 
</p>
<p><code>mom = list(covs = mom_covs, tols = mom_tols, targets = mom_targets)</code>.
</p>
<p><code>mom_covs</code> is a matrix where each column is a covariate whose mean is to be balanced.  <code>mom_tols</code> is a vector of tolerances for the maximum difference in means for the covariates in <code>mom_covs</code>.  <code>mom_targets</code> is a vector of target moments (e.g., means) of a distribution to be approximated by matched sampling.  If <code>mom_targets</code> is specified, then <code>cardmatch</code> will select units from each treatment group so that each matched group differs at most by <code>mom_tols</code> units from the respective moments in <code>mom_targets</code>.  As a result, the matched groups will differ at most <code>mom_tols * 2</code> from each other.  Under certain assumptions, <code>mom_targets</code> can be used for constructing a representative matched sample.  The lengths of <code>mom_tols</code> and <code>mom_target</code> have to be equal to the number of columns of <code>mom_covs</code>.  Note that the columns of <code>mom_covs</code> can be transformations of the original covariates to balance higher order single-dimensional moments like variances and skewness, and multidimensional moments such as correlations (Zubizarreta 2012).</p>
</td></tr>
<tr><td><code id="cardmatch_+3A_fine">fine</code></td>
<td>
<p>Fine balance parameters: a list with one argument, 
</p>
<p><code>fine = list(covs = fine_covs)</code>, 
</p>
<p>where <code>fine_covs</code> is a matrix where each column is a nominal covariate for fine balance.  Fine balance enforces exact distributional balance on nominal covariates, but without constraining treated and control units to be matched within each category of each nominal covariate as in exact matching.  See chapter 10 of Rosenbaum (2010) for details.</p>
</td></tr>
<tr><td><code id="cardmatch_+3A_solver">solver</code></td>
<td>

<p>Optimization solver parameters: a list with four objects, 
</p>
<p><code>solver = list(name = name, t_max = t_max, approximate = 1, round_cplex = 0,</code><br />
<code>    trace_cplex = 0)</code>.
</p>
<p><code>solver</code> is a string that determines the optimization solver to be used.  The options are: <code>cplex</code>, <code>glpk</code>, <code>gurobi</code>, <code>highs</code>, and <code>symphony</code>.  The default solver is <code>highs</code> with <code>approximate = 1</code>. For an exact solution, we strongly recommend using <code>cplex</code> or <code>gurobi</code> as they are much faster than the other solvers, but they do require a license (free for academics, but not for people outside universities).  Between <code>cplex</code> and <code>gurobi</code>, note that installing the R interface for <code>gurobi</code> is much simpler.
</p>
<p><code>t_max</code> is a scalar with the maximum time limit for finding the matches.  This option is specific to <code>cplex</code>, <code>gurobi</code>, and <code>highs</code>.  If the optimal matches are not found within this time limit, a partial, suboptimal solution is given. 
</p>
<p><code>approximate</code> is a scalar that determines the method of solution.  If <code>approximate = 1</code> (the default), an approximate solution is found via a relaxation of the original integer program.  This method of solution is faster than <code>approximate = 0</code>, but some balancing constraints may be violated to some extent.  This option works only with <code>n_controls = 1</code>, i.e. pair matching.
</p>
<p><code>round_cplex</code> is binary specific to <code>cplex</code>.  <code>round_cplex = 1</code> ensures that the solution found is integral by rounding and all the constraints are exactly statisfied; <code>round_cplex = 0</code> (the default) encodes there is no rounding which may return slightly infeasible integer solutions.  
</p>
<p><code>trace</code> is a binary specific to <code>cplex</code> and <code>gurobi</code>. <code>trace = 1</code> turns the optimizer output on. The default is <code>trace = 0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal solution, with the following objects:
</p>
<table>
<tr><td><code>obj_total</code></td>
<td>
<p>value of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>obj_dist_mat</code></td>
<td>
<p>value of the total sum of distances term of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>t_id</code></td>
<td>
<p>indexes of the matched treated units at the optimum;</p>
</td></tr>
<tr><td><code>c_id</code></td>
<td>
<p>indexes of the matched controls at the optimum;</p>
</td></tr>
<tr><td><code>group_id</code></td>
<td>
<p>matched pairs or groups at the optimum;</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time elapsed to find the optimal solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;, Juan P. Vielma &lt;jvielma@mit.edu&gt;.
</p>


<h3>References</h3>

<p>Bennett, M., Vielma, J. P., and Zubizarreta, J. R. (2017), &quot;Building a Representative Matched Sample with Treatment Doses,&quot; working paper.	
</p>
<p>Visconti, G., and Zubizarreta, J. R. (2017), &quot;Finding the Largest Matched Sample that is Balanced by Design: A Case Study of the Effect of an Earthquake on Electoral Outcomes,&quot; working paper.	
</p>
<p>Zubizarreta, J. R. (2012), &quot;Using Mixed Integer Programming for Matching in an Observational Study of Kidney Failure after Surgery,&quot; <em>Journal of the American Statistical Association</em>, 107, 1360-1371.
</p>
<p>Zubizarreta, J. R., Paredes, R. D., and Rosenbaum, P. R. (2014), &quot;Matching for Balance, Pairing for Heterogeneity in an Observational Study of the Effectiveness of For-profit and Not-for-profit High Schools in Chile,&quot; <em>Annals of Applied Statistics</em>, 8, 204-231.
</p>


<h3>See Also</h3>

<p><span class="pkg">sensitivitymv</span>, <span class="pkg">sensitivitymw</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# Load, sort, and attach data
data(lalonde)
lalonde = lalonde[order(lalonde$treatment, decreasing = TRUE), ]
attach(lalonde)

################################# 
# Step 1: use cardinality matching to find the largest sample of matched pairs for which 
# all the covariates are finely balanced.
#################################

# Discretize covariates
quantiles = function(covar, n_q) {
	p_q = seq(0, 1, 1/n_q)
	val_q = quantile(covar, probs = p_q, na.rm = TRUE)
	covar_out = rep(NA, length(covar))
	for (i in 1:n_q) {
		if (i==1) {covar_out[covar&lt;val_q[i+1]] = i}
		if (i&gt;1 &amp; i&lt;n_q) {covar_out[covar&gt;=val_q[i] &amp; covar&lt;val_q[i+1]] = i}
		if (i==n_q) {covar_out[covar&gt;=val_q[i] &amp; covar&lt;=val_q[i+1]] = i}}
	covar_out
}
age_5 = quantiles(age, 5)
education_5 = quantiles(education, 5)
re74_5 = quantiles(re74, 5)
re75_5 = quantiles(re75, 5)

# Treatment indicator; note that the data needs to be sorted in decreasing order
# according to this treatment indicator
t_ind = treatment
t_ind 

# Fine balance
fine_covs = cbind(black, hispanic, married, nodegree, age_5, education_5, re74_5, re75_5)
fine = list(covs = fine_covs)

# Solver options
t_max = 60*5
solver = "highs"
approximate = 0
solver = list(name = solver, t_max = t_max, approximate = approximate,
round_cplex = 0, trace = 0)

# Match                   
out_1 = cardmatch(t_ind, fine = fine, solver = solver)

# Indices of the treated units and matched controls
t_id_1 = out_1$t_id  
c_id_1 = out_1$c_id	

# Mean balance
covs = cbind(age, education, black, hispanic, married, nodegree, re74, re75)
meantab(covs, t_ind, t_id_1, c_id_1)

# Fine balance (note here we are getting an approximate solution)
for (i in 1:ncol(fine_covs)) {		
	print(finetab(fine_covs[, i], t_id_1, c_id_1))
}

################################# 
# Step 2: use optimal matching (minimum distance matching) to find the (re)pairing of
# treated and control that minimizes the total sum of covariate distances between matched 
# pairs.  For this, use the function 'distmatch' which is a wrapper for 'bmatch'.  
#################################

# New treatment indicator
t_ind_2 = t_ind[c(t_id_1, c_id_1)]
table(t_ind_2)

# To build the distance matrix, the idea is to use strong predictors of the outcome
dist_mat_2 = abs(outer(re74[t_id_1], re74[c_id_1], "-"))
dim(dist_mat_2)

# Match
out_2 = distmatch(t_ind_2, dist_mat_2, solver)

# Indices of the treated units and matched controls
t_id_2 = t_id_1[out_2$t_id]  
c_id_2 = c_id_1[out_2$c_id-length(out_2$c_id)]	

# Covariate balance is preserved...
meantab(covs, t_ind, t_id_2, c_id_2)
for (i in 1:ncol(fine_covs)) {		
	print(finetab(fine_covs[, i], t_id_2, c_id_2))
}

# ... but covariate distances are reduced
distances_step_1 = sum(diag(dist_mat_2)) 
distances_step_2 = sum(diag(dist_mat_2[out_2$t_id, out_2$c_id-length(out_2$c_id)])) 
distances_step_1
distances_step_2

# The mean difference in outcomes is the same...
mean(re78[t_id_1]-re78[c_id_1])
mean(re78[t_id_2]-re78[c_id_2])

# ... but their standard deviation is reduced
sd(re78[t_id_1]-re78[c_id_1])
sd(re78[t_id_2]-re78[c_id_2])
	
</code></pre>

<hr>
<h2 id='designmatch-package'>
Optimal Matched Design of Randomized Experiments and Observational Studies
</h2><span id='topic+designmatch-package'></span><span id='topic+designmatch'></span>

<h3>Description</h3>

<p><code>designmatch</code> includes two functions for the construction of matched samples that are balanced and representative by design.  These two functions are <code>bmatch</code> and <code>nmatch</code> for bipartite and nonbipartite matching, respectively.  Both functions include options for directly balancing means, higher order moments, and distributions of the observed covariates.  In both <code>bmatch</code> and <code>nmatch</code>, an integer programming (IP) problem is solved.  This IP problem either minimizes the total sum of covariate distances between matched units, maximizes the total number of matched units, or optimizes a combination of the two, subject to matching and covariate balancing constraints.  In order to solve these problems, four different optimization solvers can be used: CPLEX, GLPK, Gurobi, HiGHS, and Symphony.  By default, both <code>bmatch</code> and <code>nmatch</code> solve a relaxation of these integer programs using HiGHS, which runs quickly but may violate to some extent some of the balancing constraints.  If the user wants to solve for an exact solution of the program, we strongly recommend using either CPLEX or Gurobi, which are much faster but require a license (free for academic users) and special installation (see the installation instructions).  Between the two, Gurobi is considerably easier to install.  Among others, <code>designmatch</code> can be used for matching in treatment-control as well as case-control observational studies; observational studies with instrumental variables and discontinuity designs; and for the design of randomized experiments, for example for matching before randomization.  The package also includes functions for assessing covariate balance in the matched samples.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> designmatch</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-29</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>
<p>Maintainer: Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Greevy, R., Lu, B., Silber, J. H., and Rosenbaum, P. R. (2004), &quot;Optimal Multivariate
Matching Before Randomization,&quot; <em>Biostatistics</em>, 5, 263-275.
</p>
<p>Hsu. J., Zubizarreta, J. R., Small, D. S., and Rosenbaum, P. R. (2015), &quot;Strong Control of the Family-Wise Error Rate in Observational Studies that Discover Effect Modification by Exploratory Methods,&quot; <em>Biometrika</em>, 102, 767-782.
</p>
<p>Keele, L., Titiunik, R., and Zubizarreta, J. R., (2015), &quot;Enhancing a Geographic Regression Discontinuity Design Through Matching to Estimate the Effect of Ballot Initiatives on Voter Turnout,&quot; <em>Journal of the Royal Statistical Society: Series A</em>, 178, 223-239.
</p>
<p>Kilcioglu, C., and Zubizarreta, J. R., (2016), &quot;Maximizing the Information Content of a Balanced Matched Sample in a Study of the Economic Performance of Green Buildings,&quot; working paper.
</p>
<p>Lu, B., Greevy, R., Xu, X., and Beck C. (2011), &quot;Optimal Nonbipartite Matching and its Statistical Applications,&quot; <em>The American Statistician</em>, 65, 21-30.
</p>
<p>Rosenbaum, P. R. (2010), <em>Design of Observational Studies</em>, Springer.
</p>
<p>Rosenbaum, P. R. (2012), &quot;Optimal Matching of an Optimally Chosen Subset in Observa-
tional studies,&quot; <em>Journal of Computational and Graphical Statistics</em>, 21, 57-71.
</p>
<p>Yang, D., Small, D., Silber, J. H., and Rosenbaum, P. R. (2012), &quot;Optimal Matching With Minimal Deviation From Fine Balance in a Study of Obesity and Surgical Outcomes,&quot; <em>Biometrics</em>, 68, 628-636. 
</p>
<p>Yang. F., Zubizarreta, J. R., Small, D. S., Lorch, S. A., and Rosenbaum, P. R. (2014), &quot;Dissonant Conclusions When Testing the Validity of an Instrumental Variable,&quot; <em>The American Statistician</em>, 68, 253-263.
</p>
<p>Zou, J., and Zubizarreta, J. R., (2015) &quot;Covariate Balanced Restricted Randomization: Optimal Designs, Exact Tests, and Asymptotic Results,&quot; working paper.
</p>
<p>Zubizarreta, J. R., Reinke, C. E., Kelz, R. R., Silber, J. H., and Rosenbaum, P. R. (2011), &quot;Matching for Several Sparse Nominal Variables in a Case-Control Study of Readmission Following Surgery,&quot; <em>The American Statistician</em>, 65, 229-238.
</p>
<p>Zubizarreta, J. R. (2012), &quot;Using Mixed Integer Programming for Matching in an Observational Study of Kidney Failure after Surgery,&quot; <em>Journal of the American Statistical Association</em>, 107, 1360-1371.
</p>
<p>Zubizarreta, J. R., Paredes, R. D., and Rosenbaum, P. R. (2014), &quot;Matching for Balance, Pairing for Heterogeneity in an Observational Study of the Effectiveness of For-profit and Not-for-profit High Schools in Chile,&quot; <em>Annals of Applied Statistics</em>, 8, 204-231.
</p>

<hr>
<h2 id='distmat'>Build a rank-based Mahalanobis distance matrix</h2><span id='topic+distmat'></span>

<h3>Description</h3>

<p>Function for building a normalized rank-based Mahalanobis distance matrix with a penalty for caliper violation.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	distmat(t_ind, X_mat, calip_cov = NULL, calip_size = NULL, calip_penalty = NULL,
	        near_exact_covs = NULL, near_exact_penalties = NULL, digits = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmat_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).</p>
</td></tr>
<tr><td><code id="distmat_+3A_x_mat">X_mat</code></td>
<td>
<p>matrix of covariates: a matrix of covariates used to build the based Mahalanobis distance matrix.</p>
</td></tr>
<tr><td><code id="distmat_+3A_calip_cov">calip_cov</code></td>
<td>
<p>caliper covariate: a covariate vector used to define the caliper.  In most applications this is the propensity score, but a covariate can be used as well.</p>
</td></tr>
<tr><td><code id="distmat_+3A_calip_size">calip_size</code></td>
<td>
<p>caliper size: a scalar that determines the size of the caliper for which there will be no penalty.  Most applications use <code>0.2*sd(calip_cov)</code>.</p>
</td></tr>
<tr><td><code id="distmat_+3A_calip_penalty">calip_penalty</code></td>
<td>
<p>a scalar used to multiply the magnitude of the violation of the caliper.</p>
</td></tr>
<tr><td><code id="distmat_+3A_near_exact_covs">near_exact_covs</code></td>
<td>
<p>a matrix of covariates used for near-exact matching.</p>
</td></tr>
<tr><td><code id="distmat_+3A_near_exact_penalties">near_exact_penalties</code></td>
<td>
<p>a vector of scalars used for near-exact matching.  The length of <code>near_exact_penalties</code> has to be equal to the number of columns of <code>near_exact_covs</code>.</p>
</td></tr>
<tr><td><code id="distmat_+3A_digits">digits</code></td>
<td>
<p>a scalar indicating the number of digits used to produce each entry of the distance matrix.  The default is 1 digit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distmat</code> is a function for building a normalized rank-based Mahalanobis distance matrix with a penalty for caliper violations on a covariate (say, the propensity score) and penalties for near-exact matching. 
</p>
<p>As explained in Rosenbaum (2010), the use of a rank-based Mahalanobis distance prevents an outlier from inflating the variance for a variable, and it thus decreases its importance in the matching.  
In the calculation of the matrix the variances are constrained to not decrease as ties become more common, so that it is not more important to match on a rare binary variable than on a common binary one.  
The penalty for caliper violations ensures good balance on the propensity score or the covariate used.
In this way the rank-based Mahalanobis distance with a penalty for caliper violations in the propensity score constitutes a robust distance for matching.
</p>
<p>As explained in Zubizarreta et al. (2011), the distance matrix can also be modified for near-exact matching. 
Penalties are added to the distance matrix every time that a treated and a control unit have a different value for the corresponding near-exact matching covariate.  
</p>


<h3>Value</h3>

<p>A matrix that can be used for optimal matching with the <code>bmatch</code> functions in the <code>designmatch</code> package.
</p>


<h3>References</h3>

	
<p>Rosenbaum, P. R. (2010), <em>Design of Observational Studies</em>, Springer.
</p>
<p>Zubizarreta, J. R., Reinke, C. E., Kelz, R. R., Silber, J. H., and Rosenbaum, P. R. (2011), &quot;Matching for Several Sparse Nominal Variables in a Case-Control Study of Readmission Following Surgery,&quot; <em>The American Statistician</em>, 65, 229-238.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Load data
	data(germancities)
	attach(germancities)

	# Treatment indicator
	t_ind = treat

	# Matrix of covariates
	X_mat = cbind(log2pop, popgrowth1939, popgrowth3339, emprate, indrate, rubble, 
	rubblemiss, flats, flatsmiss, refugees)

	# Distance matrix
	dist_mat = distmat(t_ind, X_mat)
</code></pre>

<hr>
<h2 id='distmatch'>Optimal distance matching in observational studies</h2><span id='topic+distmatch'></span>

<h3>Description</h3>

<p>Function for optimal distance matching in observational studies.  <code>distmatch</code> minimizes the total sum of covariate distances between matches.  <code>distmatch</code> is a wrapper to <code>bmatch</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	distmatch(t_ind, dist_mat = NULL, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmatch_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).  Please note that the data needs to be sorted in decreasing order according to this treatment indicator.</p>
</td></tr>
<tr><td><code id="distmatch_+3A_dist_mat">dist_mat</code></td>
<td>
<p>distance matrix: a matrix of positive distances between treated units (rows) and controls (columns).  If <code>dist_mat = NULL</code> and <code>subset_weight = 1</code>, then bmatch will solve the cardinality matching problem in Zubizarreta et al. (2014).</p>
</td></tr>
<tr><td><code id="distmatch_+3A_solver">solver</code></td>
<td>

<p>Optimization solver parameters: a list with four objects, 
</p>
<p><code>solver = list(name = name, t_max = t_max, approximate = 1, round_cplex = 0,</code><br />
<code>    trace_cplex = 0)</code>.
</p>
<p><code>solver</code> is a string that determines the optimization solver to be used.  The options are: <code>cplex</code>, <code>glpk</code>, <code>gurobi</code>, <code>highs</code>, and <code>symphony</code>.  The default solver is <code>highs</code> with <code>approximate = 1</code>, so that by default an approximate solution is found (see <code>approximate</code> below).  For an exact solution, we strongly recommend using <code>cplex</code> or <code>gurobi</code> as they are much faster than the other solvers, but they do require a license (free for academics, but not for people outside universities).  Between <code>cplex</code> and <code>gurobi</code>, note that installing the R interface for <code>gurobi</code> is much simpler.
</p>
<p><code>t_max</code> is a scalar with the maximum time limit for finding the matches.  This option is specific to <code>cplex</code> and <code>gurobi</code>.  If the optimal matches are not found within this time limit, a partial, suboptimal solution is given.  
</p>
<p><code>approximate</code> is a scalar that determines the method of solution.  If <code>approximate = 1</code> (the default), an approximate solution is found via a relaxation of the original integer program.  This method of solution is faster than <code>approximate = 0</code>, but some balancing constraints may be violated to some extent.  This option works only with <code>n_controls = 1</code>, i.e. pair matching.
</p>
<p><code>round_cplex</code> is binary specific to <code>cplex</code>.  <code>round_cplex = 1</code> ensures that the solution found is integral by rounding and all the constraints are exactly statisfied; <code>round_cplex = 0</code> (the default) encodes there is no rounding which may return slightly infeasible integer solutions.  
</p>
<p><code>trace</code> is a binary specific to <code>cplex</code> and <code>gurobi</code>. <code>trace = 1</code> turns the optimizer output on. The default is <code>trace = 0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal solution, with the following objects:
</p>
<table>
<tr><td><code>obj_total</code></td>
<td>
<p>value of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>obj_dist_mat</code></td>
<td>
<p>value of the total sum of distances term of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>t_id</code></td>
<td>
<p>indexes of the matched treated units at the optimum;</p>
</td></tr>
<tr><td><code>c_id</code></td>
<td>
<p>indexes of the matched controls at the optimum;</p>
</td></tr>
<tr><td><code>group_id</code></td>
<td>
<p>matched pairs or groups at the optimum;</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time elapsed to find the optimal solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Rosenbaum, P. R. (2010), <em>Design of Observational Studies</em>, Springer.
</p>


<h3>See Also</h3>

<p><span class="pkg">sensitivitymv</span>, <span class="pkg">sensitivitymw</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# Load, sort, and attach data
data(lalonde)
lalonde = lalonde[order(lalonde$treatment, decreasing = TRUE), ]
attach(lalonde)

################################# 
# Step 1: use cardinality matching to find the largest sample of matched pairs for which 
# all the covariates are finely balanced.
#################################

# Discretize covariates
quantiles = function(covar, n_q) {
	p_q = seq(0, 1, 1/n_q)
	val_q = quantile(covar, probs = p_q, na.rm = TRUE)
	covar_out = rep(NA, length(covar))
	for (i in 1:n_q) {
		if (i==1) {covar_out[covar&lt;val_q[i+1]] = i}
		if (i&gt;1 &amp; i&lt;n_q) {covar_out[covar&gt;=val_q[i] &amp; covar&lt;val_q[i+1]] = i}
		if (i==n_q) {covar_out[covar&gt;=val_q[i] &amp; covar&lt;=val_q[i+1]] = i}}
	covar_out
}
age_5 = quantiles(age, 5)
education_5 = quantiles(education, 5)
re74_5 = quantiles(re74, 5)
re75_5 = quantiles(re75, 5)

# Treatment indicator; note that the data needs to be sorted in decreasing order
# according to this treatment indicator
t_ind = treatment
t_ind 

# Fine balance
fine_covs = cbind(black, hispanic, married, nodegree, age_5, education_5, re74_5, re75_5)
fine = list(covs = fine_covs)

# Solver options
t_max = 60*5
solver = "highs"
approximate = 0
solver = list(name = solver, t_max = t_max, approximate = approximate,
round_cplex = 0, trace = 0)

# Match                   
out_1 = cardmatch(t_ind, fine = fine, solver = solver)

# Indices of the treated units and matched controls
t_id_1 = out_1$t_id  
c_id_1 = out_1$c_id	

# Mean balance
covs = cbind(age, education, black, hispanic, married, nodegree, re74, re75)
meantab(covs, t_ind, t_id_1, c_id_1)

# Fine balance (note here we are getting an approximate solution)
for (i in 1:ncol(fine_covs)) {		
	print(finetab(fine_covs[, i], t_id_1, c_id_1))
}

################################# 
# Step 2: use optimal matching (minimum distance matching) to find the (re)pairing of
# treated and control that minimizes the total sum of covariate distances between matched 
# pairs.  For this, use the function 'distmatch' which is a wrapper for 'bmatch'.  
#################################

# New treatment indicator
t_ind_2 = t_ind[c(t_id_1, c_id_1)]
table(t_ind_2)

# To build the distance matrix, the idea is to use strong predictors of the outcome
dist_mat_2 = abs(outer(re74[t_id_1], re74[c_id_1], "-"))
dim(dist_mat_2)

# Match
out_2 = distmatch(t_ind_2, dist_mat_2, solver)

# Indices of the treated units and matched controls
t_id_2 = t_id_1[out_2$t_id]  
c_id_2 = c_id_1[out_2$c_id-length(out_2$c_id)]	

# Covariate balance is preserved...
meantab(covs, t_ind, t_id_2, c_id_2)
for (i in 1:ncol(fine_covs)) {		
	print(finetab(fine_covs[, i], t_id_2, c_id_2))
}

# ... but covariate distances are reduced
distances_step_1 = sum(diag(dist_mat_2)) 
distances_step_2 = sum(diag(dist_mat_2[out_2$t_id, out_2$c_id-length(out_2$c_id)])) 
distances_step_1
distances_step_2

# The mean difference in outcomes is the same...
mean(re78[t_id_1]-re78[c_id_1])
mean(re78[t_id_2]-re78[c_id_2])

# ... but their standard deviation is reduced
sd(re78[t_id_1]-re78[c_id_1])
sd(re78[t_id_2]-re78[c_id_2])
	
</code></pre>

<hr>
<h2 id='ecdfplot'>Empirical cumulative distribution function plot for assessing covariate balance</h2><span id='topic+ecdfplot'></span>

<h3>Description</h3>

<p>Function that plots the empirical cumulative distribution function of a given covariate for treated units and matched controls.
<code>ecdfplot</code> can be used to visually inspect the balance of the entire empirical distribution function of the covariate in question.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	ecdfplot(x, t_id, c_id, main_title = "", legend_position = "right")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfplot_+3A_x">x</code></td>
<td>
<p>a covariate vector to be used to assess balance.</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_t_id">t_id</code></td>
<td>
<p>a vector of indexes of the treated units.</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_c_id">c_id</code></td>
<td>
<p>a vector of indexes of the matched controls.</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_main_title">main_title</code></td>
<td>
<p>a string defining the main title of the plot.</p>
</td></tr>
<tr><td><code id="ecdfplot_+3A_legend_position">legend_position</code></td>
<td>
<p>a string specifying the position of the legend.  
The default is <code>right</code>.  
Other options are: <code>topright</code>, <code>bottomright</code>, <code>bottom</code>, <code>bottomleft</code>, <code>left</code>, <code>topleft</code>, <code>top</code> and <code>center</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function that plots the empirical cumulative distribution function of a given covariate for treated units and matched controls.
<code>ecdfplot</code> can be used to visually inspect the balance of the entire empirical distribution function of the covariate in question.  
</p>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Load data
	data(germancities)

	# Sort and attach data
	germancities = germancities[order(germancities$treat, decreasing = TRUE), ]
	attach(germancities)

	# Treatment indicator
	t_ind = treat
	
	# Indexes of the treated units
	t_id = which(t_ind == 1)
		
	# Indexes of the controls before matching
	c_id_before = which(t_ind == 0)
	
	# Indixes of the matched controls (obtained using bmatch in designmatch)
	c_id_after = c(80, 82, 35, 59, 69, 68, 34, 62, 104, 61, 106, 120, 56, 119, 28, 
	113, 76, 118, 75, 71)
	
	# ecdfplot
	par(mfrow = c(2, 1))
	ecdfplot(rubble, t_id, c_id_before, "Before matching")
	ecdfplot(rubble, t_id, c_id_after, "After matching")
</code></pre>

<hr>
<h2 id='finetab'>Tabulate the marginal distribution of a nominal covariate after matching</h2><span id='topic+finetab'></span>

<h3>Description</h3>

<p>Function for tabulating the marginal distributions of a nominal covariate for the treated units and matched controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	finetab(nom_cov, t_id, c_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finetab_+3A_nom_cov">nom_cov</code></td>
<td>
<p>a nominal covariate vector used to assess balance.</p>
</td></tr>
<tr><td><code id="finetab_+3A_t_id">t_id</code></td>
<td>
<p>a vector of indexes of the treated units.</p>
</td></tr>
<tr><td><code id="finetab_+3A_c_id">c_id</code></td>
<td>
<p>a vector of indexes of the matched controls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>finetab</code> is a function for tabulating the marginal distributions of a nominal covariate for the treated units and matched controls.	
<code>finetab</code> is useful for assessing covariate balance after matching with after exact, near-exact matching, fine and near-balance with the <code>bmatch</code> or <code>nmatch</code> functions in the <code>designmatch</code> package. 	
</p>


<h3>Value</h3>

<p>A table with the counts for the treated units and matched controls for each category of a nominal covariate.
</p>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	# Load data
	data(germancities)

	# Sort and attach data
	germancities = germancities[order(germancities$treat, decreasing = TRUE), ]
	attach(germancities)

	# Treatment indicator
	t_ind = treat
	
	# Indexes of the treated units
	t_id = which(t_ind == 1)

	# Indixes of the matched controls (obtained using bmatch in designmatch)
	c_id = c(80, 82, 35, 59, 69, 68, 34, 62, 104, 61, 106, 120, 56, 119, 28, 
	113, 76, 118, 75, 71)
 
 	# finetab
	finetab(publicat, t_id, c_id)
	finetab(busiservcat, t_id, c_id)
</code></pre>

<hr>
<h2 id='germancities'>Data from German cities before and after the Second World War</h2><span id='topic+germancities'></span>

<h3>Description</h3>

<p>This is part of the data used by Redding and Sturm (2008) to study the impact of market access on economic development in West German cities after the division of Germany after the Second World War.
There are 119 rows corresponding to different cities and 21 columns that stand for different variables.
These variables are: one treatment indicator, 15 baseline covariates, and five outcomes.
Treated cities are those West German cities within 75 kilometers of the border between East and West Germany after the Second World War (see Redding and Sturm (2008) for details).
The complete dataset is available at <a href="http://www.aeaweb.org/articles.php?doi=10.1257/aer.98.5.1766">http://www.aeaweb.org/articles.php?doi=10.1257/aer.98.5.1766</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(germancities)</code></pre>


<h3>Format</h3>

<p>A data frame with 122 observations corresponding to 20 treated and 102 control cities.  
The treatment assignment indicator is the first column of the data frame: treat (1 = treated; 0 = control).
The next 15 columns are the covariates:
</p>

<ul>
<li><p> log2pop, logarithm base 2 of the population in each city in 1939;
</p>
</li>
<li><p> popgrowth1939, population growth in each city from 1919 to 1939;
</p>
</li>
<li><p> popgrowth3339, population growth in each city from 1919 to 1939;
</p>
</li>
<li><p> emprate, employment rates in each city in 1939;
</p>
</li>
<li><p> indrate, industry rates in each city in 1939;
</p>
</li>
<li><p> rubble, amount of rubble in cubic meters per capita in each city in 1939;
</p>
</li>
<li><p> rubblemiss, missing data indicator for rubble; the missing values were imputed with the mean;
</p>
</li>
<li><p> flats, number of destroyed dwellings in each city in 1939 as a percentage of the stock of dwelling; 
</p>
</li>
<li><p> flatsmiss, missing data indicator for flats; the missing values were imputed with the mean;
</p>
</li>
<li><p> refugees, proportion of each city's population that identified themselves as refugees in 1939;
</p>
</li>
<li><p> educat, categories for the employment rates in the educational sector in each city in 1939;
</p>
</li>
<li><p> publicat, categories for the employment rates in the public administration sector in each city in 1939;
</p>
</li>
<li><p> busiservcat, categories for the employment rates in the bussiness services sector in each city in 1939;
</p>
</li>
<li><p> mineralcat, categories for the employment rates in the minerals sector in each city in 1939;
</p>
</li>
<li><p> transcat, categories for the employment rates in the transport sector in each city in 1939.
</p>
</li></ul>

<p>The last five columns of the data frame are outcomes: pop50, pop60, pop70, pop80 and pop88, the populations in each city in 1950, 1960, 1970, 1980 and 1988, respectively.
</p>


<h3>Source</h3>

<p><a href="http://www.aeaweb.org/articles.php?doi=10.1257/aer.98.5.1766">http://www.aeaweb.org/articles.php?doi=10.1257/aer.98.5.1766</a></p>


<h3>References</h3>

<p>Redding, S. J., and Daniel M. S. (2008), &quot;The Costs of Remoteness: Evidence from German Division and Reunification,&quot; <em>American Economic Review</em>, 98, 1766-1797.
</p>

<hr>
<h2 id='lalonde'>Lalonde data set</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>This is one of the data sets from the National Supported Work Demonstration used by Dehejia and Wahba (1999) to evaluate propensity score matching methods.  This and other related data sets are available at <a href="https://users.nber.org/~rdehejia/nswdata2.html">https://users.nber.org/~rdehejia/nswdata2.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalonde)</code></pre>


<h3>Format</h3>

<p>A data frame with 445 observations, corresponding to 185 treated and 260 control subjects, and 10 variables.  
The treatment assignment indicator is the first variable of the data frame: <code>treatment</code> (1 = treated; 0 = control).
The next 7 columns are the covariates:
</p>

<ul>
<li> <p><code>age</code>, measured in years;
</p>
</li>
<li> <p><code>education</code>, measured in years;
</p>
</li>
<li> <p><code>black</code>, indicating race (1 if black, 0 otherwise);
</p>
</li>
<li> <p><code>hispanic</code>, indicating race (1 if Hispanic, 0 otherwise);
</p>
</li>
<li> <p><code>married</code>, indicating marital status (1 if married, 0 otherwise);
</p>
</li>
<li> <p><code>nodegree</code>, indicating high school diploma (1 if no degree, 0 otherwise);
</p>
</li>
<li> <p><code>re74</code>, real earnings in 1974;
</p>
</li>
<li> <p><code>re75</code>, real earnings in 1975.
</p>
</li></ul>
	
<p>The last variable of the data frame is <code>re78</code>, the real the earnings in 1978.
</p>


<h3>Source</h3>

<p><a href="https://users.nber.org/~rdehejia/nswdata2.html">https://users.nber.org/~rdehejia/nswdata2.html</a></p>


<h3>References</h3>

<p>Dehejia, R., and Wahba, S. (1999), &quot;Causal Effects in Nonexperimental Studies: Reevaluating the Evaluation of Training Programs,&quot; <em>Journal of the American Statistical Association</em>, 94, 1053-1062. 
</p>
<p>Lalonde, R. (1986), &quot;Evaluating the Econometric Evaluations of Training Programs,&quot; <em>American Economic Review</em>, 76, 604-620.
</p>

<hr>
<h2 id='loveplot'>Love plot for assessing covariate balance</h2><span id='topic+loveplot'></span>

<h3>Description</h3>

<p>Function that creates a Love plot for assessing covariate balance after matching.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	loveplot(X_mat, t_id, c_id, v_line, legend_position = "topright")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loveplot_+3A_x_mat">X_mat</code></td>
<td>
<p>matrix of covariates: a matrix of covariates used to assess balance.</p>
</td></tr>
<tr><td><code id="loveplot_+3A_t_id">t_id</code></td>
<td>
<p>a vector of indexes of the treated units.</p>
</td></tr>
<tr><td><code id="loveplot_+3A_c_id">c_id</code></td>
<td>
<p>a vector of indexes of the matched controls.</p>
</td></tr>
<tr><td><code id="loveplot_+3A_v_line">v_line</code></td>
<td>
<p>a scalar defining the location of the vertical line that denotes a satisfactory balance.</p>
</td></tr>
<tr><td><code id="loveplot_+3A_legend_position">legend_position</code></td>
<td>
<p>a string specifying the position of the legend.  
The default is <code>topright</code>.  
Other options are: <code>bottomright</code>, <code>bottom</code>, <code>bottomleft</code>, <code>left</code>, <code>topleft</code>, <code>top</code>, <code>topright</code>, <code>right</code> and <code>center</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the spirit of Love (2004), <code>loveplot</code> draws a love plot for assessing covariate balance after matching.
Specifically, <code>loveplot</code> plots the absolute standardized differences in means before and after matching for all the covariates specified in <code>X_mat</code>.
</p>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Love, T. (2004), &quot;Graphical Display of Covariate Balance,&quot; http://chrp.org/love/JSM2004RoundTableHandout.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Load data
	data(germancities)

	# Sort and attach data
	germancities = germancities[order(germancities$treat, decreasing = TRUE), ]
	attach(germancities)

	# Treatment indicator
	t_ind = treat
	
	# Indexes of the treated units
	t_id = which(t_ind == 1)

	# Matrix of covariates
	X_mat = cbind(log2pop, popgrowth1939, popgrowth3339, emprate, indrate, 
	rubble, rubblemiss, flats, flatsmiss, refugees)

	# Indices of the matched controls (obtained using bmatch in designmatch)
	c_id = c(67, 75, 39, 104, 38, 93, 79, 59, 64, 55, 106, 99, 97, 61, 82, 57, 76, 47, 46, 49)
 
	# Vertical line for satisfactory balance
	vline = 0.15
	
 	# loveplot
	loveplot(X_mat, t_id, c_id, vline) 
</code></pre>

<hr>
<h2 id='meantab'>Tabulate means of covariates after matching</h2><span id='topic+meantab'></span>

<h3>Description</h3>

<p>Function for tabulating the means and other basic statistics useful to assess covariate balance after matching.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	meantab(X_mat, t_ind, t_id, c_id, exact = NULL, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meantab_+3A_x_mat">X_mat</code></td>
<td>
<p>matrix of covariates: a matrix of covariates used to assess balance.</p>
</td></tr>
<tr><td><code id="meantab_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector of zeros and ones indicating treatment (1 = treated; 0 = control).</p>
</td></tr>
<tr><td><code id="meantab_+3A_t_id">t_id</code></td>
<td>
<p>a vector of indexes of the treated units.</p>
</td></tr>
<tr><td><code id="meantab_+3A_c_id">c_id</code></td>
<td>
<p>a vector of indexes of the matched controls.</p>
</td></tr>
<tr><td><code id="meantab_+3A_exact">exact</code></td>
<td>
<p>a vector of characters equal to &quot;f&quot; or &quot;w&quot; indicating whether Fisher's exact test or Wilcoxon rank-sum test should be used for binary (or categorical) and continous covariates, respectively.  Otherwise, if exact <code>exact = NULL</code>, simple t-tests are used.  The default is <code>exact = NULL</code>.  If <code>exact != NULL</code>, the length of <code>exact</code> has to be equal to the number of columns of <code>X_mat</code>.</p>
</td></tr>
<tr><td><code id="meantab_+3A_digits">digits</code></td>
<td>
<p>a scalar indicating the number of digits to display in the columns of the table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>meantab</code> is a function for tabulating the means and other basic statistics useful to assess covariate balance after matching. 		
</p>


<h3>Value</h3>

<p>A table with the following columns:
</p>
<table>
<tr><td><code>Mis</code></td>
<td>
<p>proportion of missing values for each covariate;</p>
</td></tr>
<tr><td><code>Min</code></td>
<td>
<p>minimum value for each covariate;</p>
</td></tr>
<tr><td><code>Max</code></td>
<td>
<p>maximum value for each covariate;</p>
</td></tr>
<tr><td><code>Mean T</code></td>
<td>
<p>mean of the treated units for each covariate;</p>
</td></tr>
<tr><td><code>Mean C</code></td>
<td>
<p>mean of the matched controls for each covariate;</p>
</td></tr>
<tr><td><code>Std Dif</code></td>
<td>
<p>standardized differences in means after matching for each covariate;</p>
</td></tr>
<tr><td><code>P-val</code></td>
<td>
<p>P-values for t-tests for differences in means between treated units and matched controls for each covariate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>	# Load data
	data(germancities)

	# Sort and attach data
	germancities = germancities[order(germancities$treat, decreasing = TRUE), ]
	attach(germancities)

	# Treatment indicator
	t_ind = treat
	
	# Indexes of the treated units
	t_id = which(t_ind == 1)

	# Matrix of covariates
	X_mat = cbind(log2pop, popgrowth1939, popgrowth3339, emprate, indrate, rubble, 
	rubblemiss, flats, flatsmiss, refugees)

	# Indices of the matched controls (obtained using bmatch in designmatch)
	c_id = c(67, 75, 39, 104, 38, 93, 79, 59, 64, 55, 106, 99, 97, 61, 82, 57, 
	76, 47, 46, 49)
 
 	# meantab
	meantab(X_mat, t_ind, t_id, c_id)
	
	# meantab
	meantab(X_mat, t_ind, t_id, c_id, exact = c(rep("w", 6), "f", "w", "f", "w"), digits = 3)
</code></pre>

<hr>
<h2 id='nmatch'>
Optimal nonbipartite matching in randomized experiments and observational studies
</h2><span id='topic+nmatch'></span>

<h3>Description</h3>

<p>Function for optimal nonbipartite matching in randomized experiments and observational studies that directly balances the observed covariates.  <code>nmatch</code> allows the user to enforce different forms of covariate balance in the matched samples, such as moment balance (e.g., of means, variances, and correlations), distributional balance (e.g., fine balance, near-fine balance, strength-<em>k</em> balancing), and exact matching.  Among others, <code>nmatch</code> can be used in the design of randomized experiments for matching before randomization (Greevy et al. 2004, Zou and Zubizarreta 2016), and in observational studies for matching with doses and strengthening an instrumental variable (Baiocchi et al. 2010, Lu et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	nmatch(dist_mat, subset_weight = NULL, total_pairs = NULL, mom = NULL,
	       exact = NULL, near_exact = NULL, fine = NULL, near_fine = NULL,
	       near = NULL, far = NULL, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmatch_+3A_dist_mat">dist_mat</code></td>
<td>
<p>distance matrix: a matrix of positive distances between units.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_subset_weight">subset_weight</code></td>
<td>
<p>subset matching weight: a scalar that regulates the trade-off between the total sum of distances between matched pairs and the total number of matched pairs.  The larger <code>subset_weight</code>, the more importance will be given to the the total number of matched pairs relative to the total sum of distances between matched pairs.  See Rosenbaum (2012) and Zubizarreta et al. (2013) for a discussion of this parameter.  If <code>subset_weight = NULL</code>, then <code>nmatch</code> will match all the available units, provided it exists a feasible solution exists.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_total_pairs">total_pairs</code></td>
<td>
<p>total number of matched pairs: a scalar specifying the number of matched pairs to be obtained.  If <code>total_pairs = NULL</code> then no specific number of matched pairs is required before matching.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_mom">mom</code></td>
<td>
<p>moment balance parameters: a list with three arguments, 
</p>
<p><code>mom = list(covs = mom_covs, tols = mom_tols, targets = mom_targets)</code>.
</p>
<p><code>mom_covs</code> is a matrix where each column is a covariate whose mean is to be balanced.  <code>mom_tols</code> is a vector of tolerances for the maximum difference in means for the covariates in <code>mom_covs</code>.  <code>mom_targets</code> is a vector of target moments (e.g., means) of a distribution to be approximated by matching.  <code>mom_targets</code> is optional, but if <code>mom_covs</code> is specified then <code>mom_tols</code> needs to be specified too.  If <code>mom_targets</code> is <code>NULL</code>, then <code>nmatch</code> will match treated and control units so that covariates in <code>mom_covs</code> differ at most by <code>mom_tols</code>.  If <code>mom_targets</code> is specified, then <code>nmatch</code> will match treated and control units so that each matched group differs at most by <code>mom_tols</code> units from the respective moments in <code>mom_targets</code>.  As a result, the matched groups will differ at most <code>mom_tols * 2</code> from each other.  Under certain assumptions, <code>mom_targets</code> can be used for constructing a representative matched sample.  The lengths of <code>mom_tols</code> and <code>mom_target</code> have to be equal to the number of columns of <code>mom_covs</code>.  Note that the columns of <code>mom_covs</code> can be transformations of the original covariates to balance higher order single-dimensional moments like variances and skewness, and multidimensional moments such as correlations (Zubizarreta 2012).</p>
</td></tr>
<tr><td><code id="nmatch_+3A_exact">exact</code></td>
<td>
<p>Exact matching parameters: a list with one argument, 
</p>
<p><code>exact = list(covs = exact_covs)</code>, 
</p>
<p>where <code>exact_covs</code> is a matrix where each column is a nominal covariate for exact matching.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_near_exact">near_exact</code></td>
<td>
<p>Near-exact matching parameters: a list with two arguments, 
</p>
<p><code>near_exact = list(covs = near_exact_covs, devs = near_exact_devs)</code>. 
</p>
<p><code>near_exact_covs</code> are the near-exact matching covariates; specifically, a matrix where each column is a nominal covariate for near-exact matching.  <code>near_exact_devs</code> are the maximum deviations from near-exact matching: a vector of scalars defining the maximum deviation allowed from exact matching for the covariates defined in <code>near_exact_covs</code>.  Note that the length of <code>near_exact_devs</code> has to be equal to the number of columns of <code>near_exact_covs</code>.  For detailed expositions of near-exact matching in the context of bipartite matching, see section 9.2 of Rosenbaum (2010) and Zubizarreta et al. (2011).</p>
</td></tr>
<tr><td><code id="nmatch_+3A_fine">fine</code></td>
<td>
<p>Fine balance parameters: a list with one argument, 
</p>
<p><code>fine = list(covs = fine_covs)</code>, 
</p>
<p>where <code>fine_covs</code> is a matrix where each column is a nominal covariate for fine balance.  Fine balance enforces exact distributional balance on nominal covariates, but without constraining treated and control units to be matched within each category of each nominal covariate as in exact matching.  See chapter 10 of Rosenbaum (2010) for details.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_near_fine">near_fine</code></td>
<td>
<p>Near-fine balance parameters: a list with two arguments, 
</p>
<p><code>near_fine = list(covs = near_fine_covs, devs = near_fine_devs)</code>.
</p>
<p><code>near_fine_covs</code> is a matrix where each column is a nominal covariate for near-fine matching.  <code>near_fine_devs</code> is a vector of scalars defining the maximum deviation allowed from fine balance for the covariates in <code>near_fine_covs</code>.  Note that the length of <code>near_fine_devs</code> has to be equal to the number of columns of <code>near_fine_covs</code>.  See Yang et al. (2012) for a description of near-fine balance.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_near">near</code></td>
<td>
<p>Near matching parameters: a list with three arguments, 
</p>
<p><code>near = list(covs = near_covs, pairs = near_pairs, groups = near_groups)</code>.
</p>
<p><code>near_covs</code> is a matrix where each column is a variable for near matching.  <code>near_pairs</code> is a vector determining the maximum distance between individual matched pairs for each variable in <code>near_covs</code>.  <code>near_groups</code> is a vector defining the maximum average distance (in aggregate) between matched groups for each covariate in <code>near_covs</code>.  If <code>near_covs</code> is specified, then either <code>near_pairs</code>, <code>near_covs</code>, or both must be specified as well, and the length of <code>near_pairs</code> and/or <code>near_groups</code> has to be equal to the number of columns of <code>near_covs</code>.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_far">far</code></td>
<td>
<p>Far matching parameters: a list with three arguments, 
</p>
<p><code>far = list(covs = far_covs, pairs = far_pairs, groups = far_groups)</code>.
</p>
<p><code>far_covs</code> is a matrix where each column is a variable (a covariate or an instrumental variable) for far matching.  <code>far_pairs</code> is a vector determining the minimum distance between units in a matched pair for each variable in <code>far_covs</code>, and <code>far_groups</code> is a vector defining the minimum average (aggregate) distance between matched groups for each variable in <code>far_covs</code>.  If <code>far_covs</code> is specified, then either <code>far_pairs</code>, <code>far_covs</code>, or both, must be specified, and the length of <code>far_pairs</code> and/or <code>far_groups</code> has to be equal to the number of columns of <code>far_covs</code>.  See Zubizarreta et al. (2013) for strengthening an instrumental variable with integer programming.</p>
</td></tr>
<tr><td><code id="nmatch_+3A_solver">solver</code></td>
<td>
<p>Optimization solver parameters: a list with four objects, 
</p>
<p><code>solver = list(name = name, t_max = t_max, approximate = 1, round_cplex = 0,</code><br />
<code>    trace_cplex = 0)</code>.
</p>
<p><code>solver</code> is a string that determines the optimization solver to be used.  The options are: <code>cplex</code>, <code>glpk</code>, <code>gurobi</code>, <code>highs</code>, and <code>symphony</code>.  The default solver is <code>highs</code> with <code>approximate = 1</code>, so that by default an approximate solution is found (see <code>approximate</code> below).  For an exact solution, we strongly recommend using <code>cplex</code> or <code>gurobi</code> as they are much faster than the other solvers, but they do require a license (free for academics, but not for people outside universities).  Between <code>cplex</code> and <code>gurobi</code>, note that the installation of the <code>gurobi</code> interface for R is much simpler.
</p>
<p><code>t_max</code> is a scalar with the maximum time limit for finding the matches.  This option is specific to <code>cplex</code> and <code>gurobi</code>.  If the optimal matches are not found within this time limit, a partial, suboptimal solution is given.  
</p>
<p><code>approximate</code> is a scalar that determines the method of solution.  If <code>approximate = 1</code> (the default), an approximate solution is found via a relaxation of the original integer program.  This method of solution is faster than <code>approximate = 0</code>, but some balancing constraints may be violated to some extent.
</p>
<p><code>round_cplex</code> is binary specific to <code>cplex</code>.  <code>round_cplex = 1</code> ensures that the solution found is integral by rounding and all the constraints are exactly statisfied; <code>round_cplex = 0</code> (the default) encodes there is no rounding which may return slightly infeasible integer solutions.  
</p>
<p><code>trace</code> is a binary specific to <code>cplex</code> and <code>gurobi</code>.  <code>trace = 1</code> turns the optimizer output on.  The default is <code>trace = 0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal solution, with the following objects:
</p>
<table>
<tr><td><code>obj_total</code></td>
<td>
<p>value of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>obj_dist_mat</code></td>
<td>
<p>value of the total sum of distances term of the objective function at the optimum;</p>
</td></tr>
<tr><td><code>id_1</code></td>
<td>
<p>indexes of the matched units in group 1 at the optimum;</p>
</td></tr>
<tr><td><code>id_2</code></td>
<td>
<p>indexes of the matched units in group 2 at the optimum;</p>
</td></tr>
<tr><td><code>group_id</code></td>
<td>
<p>matched pairs at the optimum;</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time elapsed to find the optimal solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Baiocchi, M., Small, D., Lorch, S. and Rosenbaum, P. R. (2010), &quot;Building a Stronger Instrument in an Observational Study of Perinatal Care for Premature Infants,&quot; <em>Journal of the American Statistical Association</em>, 105, 1285-1296.
</p>
<p>Greevy, R., Lu, B., Silber, J. H., and Rosenbaum, P. R. (2004), &quot;Optimal Multivariate
Matching Before Randomization,&quot; <em>Biostatistics</em>, 5, 263-275.
</p>
<p>Lu, B., Greevy, R., Xu, X., and Beck C. (2011), &quot;Optimal Nonbipartite Matching and its Statistical Applications,&quot; <em>The American Statistician</em>, 65, 21-30.
</p>
<p>Rosenbaum, P. R. (2010), <em>Design of Observational Studies</em>, Springer.
</p>
<p>Rosenbaum, P. R. (2012), &quot;Optimal Matching of an Optimally Chosen Subset in Observa-
tional studies,&quot; <em>Journal of Computational and Graphical Statistics</em>, 21, 57-71.
</p>
<p>Yang. F., Zubizarreta, J. R., Small, D. S., Lorch, S. A., and Rosenbaum, P. R. (2014), &quot;Dissonant Conclusions When Testing the Validity of an Instrumental Variable,&quot; <em>The American Statistician</em>, 68, 253-263.
</p>
<p>Zou, J., and Zubizarreta, J. R. (2016), &quot;Covariate Balanced Restricted Randomization: Optimal Designs, Exact Tests, and Asymptotic Results,&quot; working paper.
</p>
<p>Zubizarreta, J. R., Reinke, C. E., Kelz, R. R., Silber, J. H., and Rosenbaum, P. R. (2011), &quot;Matching for Several Sparse Nominal Variables in a Case-Control Study of Readmission Following Surgery,&quot; <em>The American Statistician</em>, 65, 229-238.
</p>
<p>Zubizarreta, J. R. (2012), &quot;Using Mixed Integer Programming for Matching in an Observational Study of Kidney Failure after Surgery,&quot; <em>Journal of the American Statistical Association</em>, 107, 1360-1371.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    

## Uncomment the following example
## Load and attach data
#data(lalonde)
#attach(lalonde)

################################# 
## Example: optimal subset matching
################################# 

## Optimal subset matching pursues two competing goals at 
## the same time: to minimize the total of distances while 
## matching as many observations as possible.  The trade-off 
## between these two is regulated by the parameter subset_weight 
## (see Rosenbaum 2012 and Zubizarreta et al. 2013 for a discussion).
## Here the balance requirements are mean and fine balance for 
## different covariates.  We require 50 pairs to be matched.
## Again, the solver used is HiGHS with the approximate option.

## Matrix of covariates
#X_mat = cbind(age, education, black, hispanic, married, nodegree, re74, re75)

## Distance matrix
#dist_mat_covs = round(dist(X_mat, diag = TRUE, upper = TRUE), 1)
#dist_mat = as.matrix(dist_mat_covs)

## Subset matching weight
#subset_weight = 1

## Total pairs to be matched
#total_pairs = 50

## Moment balance: constrain differences in means to be at most .1 standard deviations apart
#mom_covs = cbind(age, education)
#mom_tols = apply(mom_covs, 2, sd)*.1
#mom = list(covs = mom_covs, tols = mom_tols)

## Solver options
#t_max = 60*5
#solver = "highs"
#approximate = 1
#solver = list(name = solver, t_max = t_max, approximate = approximate, round_cplex = 0, 
#trace_cplex = 0)

## Match                  
#out = nmatch(dist_mat = dist_mat, subset_weight = subset_weight, total_pairs = total_pairs, 
#mom = mom, solver = solver)              
              
## Indices of the treated units and matched controls
#id_1 = out$id_1  
#id_2 = out$id_2	

## Assess mean balance
#a = apply(mom_covs[id_1, ], 2, mean)
#b = apply(mom_covs[id_2, ], 2, mean)
#tab = round(cbind(a, b, a-b, mom_tols), 2)
#colnames(tab) = c("Mean 1", "Mean 2", "Diffs", "Tols")
#tab

## Assess fine balance (note here we are getting an approximate solution)
#for (i in 1:ncol(fine_covs)) {		
#	print(finetab(fine_covs[, i], id_1, id_2))
#}
</code></pre>

<hr>
<h2 id='pairsplot'>Pairs plot for visualizing matched pairs</h2><span id='topic+pairsplot'></span>

<h3>Description</h3>

<p>Function for visualizing matched pairs in two dimensions.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	pairsplot(cov1, cov2, t_id, c_id, xlab, ylab, main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsplot_+3A_cov1">cov1</code></td>
<td>
<p>a vector for the covariate to be plotted on the x axis.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_cov2">cov2</code></td>
<td>
<p>a vector for the covariate to be plotted on the y axis.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_t_id">t_id</code></td>
<td>
<p>a vector of indexes of the treated units.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_c_id">c_id</code></td>
<td>
<p>a vector of indexes of the matched controls.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_xlab">xlab</code></td>
<td>
<p>a string specifying the label of the x axis.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_ylab">ylab</code></td>
<td>
<p>a string specifying the label of the y axis.</p>
</td></tr>
<tr><td><code id="pairsplot_+3A_main">main</code></td>
<td>
<p>a string specifying the main title of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pairsplot</code> is a function for visualizing matched pairs in two dimensions, usually defined by two of the matching covariates.
Matched pairs are connected by line segments.
Horizontal and vertical lines show the means of treated units and matched controls for each of the covariates.
Among others, <code>pairsplot</code> can be useful for visualizing near/far matches, e.g. when building a stronger instrumental variable (Baiocchi et al., 2010).
</p>


<h3>Author(s)</h3>

<p>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;.
</p>


<h3>References</h3>

<p>Baiocchi, M., Small, D., Lorch, S. and Rosenbaum, P. R. (2010), &quot;Building a Stronger Instrument in an Observational Study of Perinatal Care for Premature Infants,&quot; <em>Journal of the American Statistical Association</em>, 105, 1285-1296.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# Load data
	data(germancities)

	# Sort and attach data
	germancities = germancities[order(germancities$treat, decreasing = TRUE), ]
	attach(germancities)

	# Treatment indicator
	t_ind = treat
	
	# Indexes of the treated units
	t_id = which(t_ind == 1)
	
	# Indices of the matched controls (obtained using bmatch in designmatch)
	c_id = c(67, 75, 39, 104, 38, 93, 79, 59, 64, 55, 106, 99, 97, 61, 82, 
	57, 76, 47, 46, 49)
 
	# pairsplot	
	pairsplot(rubble, flats, t_id, c_id, "Rubble", "Flats", "")
</code></pre>

<hr>
<h2 id='profmatch'>Optimal profile matching</h2><span id='topic+profmatch'></span>

<h3>Description</h3>

<p>Function for optimal profile matching to construct matched samples that are balanced toward a user-specified covariate profile.  This covariate profile can represent a specific population or a target individual, facilitating the generalization and personalization of causal inferences (Cohn and Zubizarreta 2022).  For each treatment group reservoir, <code>profmatch</code> finds the largest sample that is balanced relative to the profile.  The formulation of <code>profmatch</code> has been simplified to handle larger data than <code>bmatch</code> or <code>nmatch</code>.  Similar to <code>bmatch</code> or <code>nmatch</code>, the performance of <code>profmatch</code> is greatly enhanced by using the <code>solver</code> options <code>cplex</code> or <code>gurobi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	profmatch(t_ind, mom, solver = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profmatch_+3A_t_ind">t_ind</code></td>
<td>
<p>treatment indicator: a vector indicating treatment group of each observation.</p>
</td></tr>
<tr><td><code id="profmatch_+3A_mom">mom</code></td>
<td>
<p>moment balance parameters: a list with three arguments, 
</p>
<p><code>mom = list(targets = mom_targets, covs = mom_covs, tols = mom_tols)</code>.
</p>
<p><code>mom_targets</code> is the profile, i.e. a vector of target moments (e.g., means) of a distribution or a vector of characteristics of an individual toward which to balance the treatment groups. <code>mom_covs</code> is a matrix where each column is a covariate whose mean is to be balanced toward <code>mom_targets</code>.  <code>mom_tols</code> is a vector of tolerances for the maximum difference in means between the covariates in <code>mom_covs</code> and the elements of <code>mom_targets</code>.  <code>profmatch</code> will select units from each treatment group so that each matched group differs at most by <code>mom_tols</code> from the respective elements of <code>mom_targets</code>.  As a result, the matched groups will differ at most <code>mom_tols * 2</code> from each other.  Under certain assumptions, <code>mom_targets</code> can be used for constructing a representative matched sample.  The lengths of <code>mom_tols</code> and <code>mom_target</code> have to be equal to the number of columns of <code>mom_covs</code>.  Note that the columns of <code>mom_covs</code> can be transformations of the original covariates to balance higher order single-dimensional moments like variances and skewness, and multidimensional moments such as correlations (Zubizarreta 2012).</p>
</td></tr>
<tr><td><code id="profmatch_+3A_solver">solver</code></td>
<td>

<p>Optimization solver parameters: a list with four objects, 
</p>
<p><code>solver = list(name = name, t_max = t_max, approximate = 1, round_cplex = 0,</code><br />
<code>    trace_cplex = 0)</code>.
</p>
<p><code>solver</code> is a string that determines the optimization solver to be used.  The options are: <code>cplex</code>, <code>glpk</code>, <code>gurobi</code>, <code>highs</code>, and <code>symphony</code>.  The default solver is <code>highs</code> with <code>approximate = 1</code>. For an exact solution, we strongly recommend using <code>cplex</code> or <code>gurobi</code> as they are much faster than the other solvers, but they do require a license (free for academics, but not for people outside universities).  Between <code>cplex</code> and <code>gurobi</code>, note that installing the R interface for <code>gurobi</code> is much simpler.
</p>
<p><code>t_max</code> is a scalar with the maximum time limit for finding the matches.  This option is specific to <code>cplex</code>, <code>gurobi</code>, and <code>highs</code>.  If the optimal matches are not found within this time limit, a partial, suboptimal solution is given.  
</p>
<p><code>approximate</code> is a scalar that determines the method of solution.  If <code>approximate = 1</code> (the default), an approximate solution is found via a relaxation of the original integer program.  This method of solution is faster than <code>approximate = 0</code>, but some balancing constraints may be violated to some extent.  This option works only with <code>n_controls = 1</code>, i.e. pair matching.
</p>
<p><code>round_cplex</code> is binary specific to <code>cplex</code>.  <code>round_cplex = 1</code> ensures that the solution found is integral by rounding and all the constraints are exactly statisfied; <code>round_cplex = 0</code> (the default) encodes there is no rounding which may return slightly infeasible integer solutions.  
</p>
<p><code>trace</code> is a binary specific to <code>cplex</code> and <code>gurobi</code>. <code>trace = 1</code> turns the optimizer output on. The default is <code>trace = 0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the optimal solution, with the following objects:
</p>
<table>
<tr><td><code>obj_totals</code></td>
<td>
<p>values of the objective functions at the optima (one value for each treatment group matching problem);</p>
</td></tr>
<tr><td><code>ids</code></td>
<td>
<p>indices of the matched units at the optima;</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>time elapsed to find the optimal solutions (one value for each treatment group matching problem).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric R. Cohn &lt;ericcohn@g.harvard.edu&gt;, Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;, Cinar Kilcioglu &lt;ckilcioglu16@gsb.columbia.edu&gt;, Juan P. Vielma &lt;jvielma@mit.edu&gt;.
</p>


<h3>References</h3>

<p>Zubizarreta, J. R. (2012), &quot;Using Mixed Integer Programming for Matching in an Observational Study of Kidney Failure after Surgery,&quot; <em>Journal of the American Statistical Association</em>, 107, 1360-1371.
</p>
<p>Cohn, E. R. and Zubizarreta, J. R. (2022) &quot;Profile Matching for the Generalization and Personalization of Causal Inferences,&quot; <em>Epidemiology</em>
</p>


<h3>See Also</h3>

<p><span class="pkg">sensitivitymv</span>, <span class="pkg">sensitivitymw</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
### Load, sort, and attach data
#data(lalonde)
#lalonde = lalonde[order(lalonde$treatment, decreasing = TRUE), ]
#attach(lalonde)

### Specify covariates
#covs = c("age", "education", "black", "hispanic", "married", "nodegree", "re74", "re75")

### Vector of treatment group indicators
#t_ind = lalonde$treatment

### Covariate matrix
#mom_covs = as.matrix(lalonde[, covs])

### Tolerances will be 0.05 * each covariate's standard deviation
#mom_sds = apply(lalonde[, covs], 2, sd)
#mom_tols = 0.05 * mom_sds

### Target moments will be the overall means in the sample
#mom_targets = colMeans(lalonde[, covs])

### Solver options
#t_max = 60*30
#solver = "gurobi"
#approximate = 0
#solver = list(name = solver, t_max = t_max, approximate = approximate, round_cplex = 0, trace = 0)

#mom = list(covs = mom_covs, tols = mom_tols, targets = mom_targets)
#pmatch_out = profmatch(t_ind, mom, solver)

### Selecting the matched units
#lalonde.matched = lalonde[pmatch_out$id,]

### Comparing TASMDs before and after matching
#TASMD.0.2 = abs(colMeans(lalonde.matched[which(lalonde.matched$treatment == 0), covs]) 
#                    - mom_targets) / mom_sds
#TASMD.1.2 = abs(colMeans(lalonde.matched[which(lalonde.matched$treatment == 1), covs]) 
#                    - mom_targets) / mom_sds

#TASMD.0.1 = abs(colMeans(lalonde[which(lalonde$treatment == 0), covs]) - mom_targets) / mom_sds
#TASMD.1.1 = abs(colMeans(lalonde[which(lalonde$treatment == 1), covs]) - mom_targets) / mom_sds

### For each treatment group, ASAMDs are reduced after matching (i.e., balance is achieved)
#cbind(TASMD.0.1, TASMD.0.2)
#cbind(TASMD.1.1, TASMD.1.2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
