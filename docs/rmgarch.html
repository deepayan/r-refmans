<!DOCTYPE html><html lang="en"><head><title>Help for package rmgarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmgarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rmgarch-package'><p>The rmgarch package</p></a></li>
<li><a href='#cGARCHfilter-class'><p>class: Copula Filter Class</p></a></li>
<li><a href='#cgarchfilter-methods'><p>function: Copula-GARCH Filter</p></a></li>
<li><a href='#cGARCHfit-class'><p>class: Copula Fit Class</p></a></li>
<li><a href='#cgarchfit-methods'><p>function: Copula-GARCH Fit</p></a></li>
<li><a href='#cGARCHsim-class'><p>class: Copula Simulation Class</p></a></li>
<li><a href='#cgarchsim-methods'><p>function: Copula-GARCH Simulation</p></a></li>
<li><a href='#cGARCHspec-class'><p>class: Copula Specification Class</p></a></li>
<li><a href='#cgarchspec-methods'><p>function: Copula-GARCH Specification</p></a></li>
<li><a href='#cordist'>
<p>A Correlation Distance Measure</p></a></li>
<li><a href='#DCCfilter-class'><p>class: DCC Filter Class</p></a></li>
<li><a href='#dccfilter-methods'><p>function: DCC-GARCH Filter</p></a></li>
<li><a href='#DCCfit-class'><p>class: DCC Fit Class</p></a></li>
<li><a href='#dccfit-methods'><p>function: DCC-GARCH Fit</p></a></li>
<li><a href='#DCCforecast-class'><p>class: DCC Forecast Class</p></a></li>
<li><a href='#dccforecast-methods'><p>function: DCC-GARCH Forecast</p></a></li>
<li><a href='#DCCroll-class'><p>class: DCC Roll Class</p></a></li>
<li><a href='#dccroll-methods'><p>function: DCC-GARCH Rolling Forecast</p></a></li>
<li><a href='#DCCsim-class'><p>class: DCC Forecast Class</p></a></li>
<li><a href='#dccsim-methods'><p>function: DCC-GARCH Simulation</p></a></li>
<li><a href='#DCCspec-class'><p>class: DCC Specification Class</p></a></li>
<li><a href='#dccspec-methods'><p>function: DCC-GARCH Specification</p></a></li>
<li><a href='#DCCtest'>
<p>Engle and Sheppard Test of Dynamic Correlation</p></a></li>
<li><a href='#dji30retw'><p>data: Dow Jones 30 Constituents Closing Value log Weekly Return</p></a></li>
<li><a href='#fastica'>
<p>Fast Fixed Point ICA</p></a></li>
<li><a href='#fMoments-class'><p>Class <code>"fMoments"</code></p></a></li>
<li><a href='#fmoments-methods'><p>Moment Based Forecast Generation</p></a></li>
<li><a href='#fScenario-class'><p>Class <code>"fScenario"</code></p></a></li>
<li><a href='#fscenario-methods'><p>Scenario Generation</p></a></li>
<li><a href='#goGARCHfft-class'><p>Class: GO-GARCH portfolio density</p></a></li>
<li><a href='#goGARCHfilter-class'><p>class: GO-GARCH Filter Class</p></a></li>
<li><a href='#gogarchfilter-methods'><p>function: GO-GARCH Filter</p></a></li>
<li><a href='#goGARCHfit-class'><p>class: GO-GARCH Fit Class</p></a></li>
<li><a href='#gogarchfit-methods'><p>function: GO-GARCH Filter</p></a></li>
<li><a href='#goGARCHforecast-class'><p>class: GO-GARCH Forecast Class</p></a></li>
<li><a href='#gogarchforecast-methods'><p>function: GO-GARCH Forecast</p></a></li>
<li><a href='#goGARCHroll-class'><p>class: GO-GARCH Roll Class</p></a></li>
<li><a href='#gogarchroll-methods'><p>function: GO-GARCH Rolling Estimation</p></a></li>
<li><a href='#goGARCHsim-class'><p>class: GO-GARCH Simultion Class</p></a></li>
<li><a href='#gogarchsim-methods'><p>function: GO-GARCH Simulation</p></a></li>
<li><a href='#goGARCHspec-class'><p>class: GO-GARCH Specification Class</p></a></li>
<li><a href='#gogarchspec-methods'><p>function: GO-GARCH Specification</p></a></li>
<li><a href='#goload-methods'><p>Load Scenario from File</p></a></li>
<li><a href='#last-methods'><p>First and Last methods for accessing objects</p></a></li>
<li><a href='#mGARCHfilter-class'><p>Class: Multivariate GARCH Filter Class</p></a></li>
<li><a href='#mGARCHfit-class'><p>Class: Multivariate GARCH Fit Class</p></a></li>
<li><a href='#mGARCHforecast-class'><p>Class: Multivariate GARCH Forecast Class</p></a></li>
<li><a href='#mGARCHroll-class'><p>Class: Multivariate GARCH Roll Class</p></a></li>
<li><a href='#mGARCHsim-class'><p>Class: Multivariate GARCH Simulation Class</p></a></li>
<li><a href='#mGARCHspec-class'><p>Class: Multivariate GARCH Specification</p></a></li>
<li><a href='#radical'>
<p>The Robust Accurate, Direct ICA aLgorithm (RADICAL).</p></a></li>
<li><a href='#varxfit'>
<p>VARX Fit/Filter/Forecast/Simulation Functions</p></a></li>
<li><a href='#wmargin'>
<p>Weighted Distribution Margin</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate GARCH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexios Galanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexios Galanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), methods, rugarch (&ge; 1.4-7), parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.6), RcppArmadillo (&ge; 0.2.34)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp, MASS, Matrix, zoo, xts, Bessel, ff, shape, pcaPP, spd,
Rcpp, utils, graphics, stats, grDevices, corpcor</td>
</tr>
<tr>
<td>Description:</td>
<td>Feasible multivariate GARCH models including DCC, GO-GARCH and Copula-GARCH.</td>
</tr>
<tr>
<td>Collate:</td>
<td>rmgarch-extrafun.R rmgarch-var.R rmgarch-functions.R
rmgarch-classes.R rmgarch-ica.R rmgarch-series.R
rmgarch-mmean.R gogarch-classes.R gogarch-distributions.R
gogarch-main.R gogarch-methods.R rdcc-classes.R rdcc-main.R
rdcc-likelihoods.R rdcc-plots.R fdcc-likelihoods.R fdcc-main.R
rdcc-methods.R rdcc-mdistributions.R rdcc-postestimation.R
rdcc-solver.R copula-classes.R copula-distributions.R
copula-likelihoods.R copula-solver.R copula-fn.R
copula-transformations.R copula-main.R copula-postestimation.R
copula-methods.R rmgarch-tests.R rmgarch-scenario.R zzz.R</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.unstarched.net">http://www.unstarched.net</a>, <a href="https://github.com/alexiosg/rmgarch">https://github.com/alexiosg/rmgarch</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-04 22:51:09 UTC; alexios</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-05 00:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='rmgarch-package'>The rmgarch package</h2><span id='topic+rmgarch-package'></span><span id='topic+rmgarch'></span>

<h3>Description</h3>

<p>The rmgarch provides a selection of multivariate GARCH models with methods for
fitting, filtering, forecasting and simulation with additional support functions
for working with the returned objects. At present, the Generalized Orthogonal
GARCH using Independent Components Analysis (<em>ICA</em>) and Dynamic Conditional
Correlation (with multivariate Normal, Laplace and Student distributions) models
are fully implemented, with methods for spec, fit, filter, forecast, simulation,
and rolling estimation and forecasting, as well as specialized functions to
calculate and work with the weighted portfolio conditional density.
The Copula-GARCH model is also implemented with the multivariate Normal
and Student distributions, with dynamic (DCC) and static estimation of
the correlation.<br />
</p>


<h3>Details</h3>

<p>The main package functionality, currently supports the <em>GO-GARCH</em> with ICA
method, and is available through the <code><a href="#topic+gogarchspec">gogarchspec</a></code>,
<code><a href="#topic+gogarchfit">gogarchfit</a></code>, <code><a href="#topic+gogarchfilter">gogarchfilter</a></code>, <code><a href="#topic+gogarchforecast">gogarchforecast</a></code>,
<code><a href="#topic+gogarchsim">gogarchsim</a></code> and <code><a href="#topic+gogarchroll">gogarchroll</a></code> functions. The <em>DCC</em>
with multivariate Normal, Laplace and Student distributions is also supported
with the main functionality in <code><a href="#topic+dccspec">dccspec</a></code>, <code><a href="#topic+dccfit">dccfit</a></code>,
<code><a href="#topic+dccfilter">dccfilter</a></code>, <code><a href="#topic+dccforecast">dccforecast</a></code>, <code><a href="#topic+dccsim">dccsim</a></code> and
<code><a href="#topic+dccroll">dccroll</a></code>. The Normal and Student Copula-GARCH, with dynamic or
static correlation, is implemented with the main functionality in
<code><a href="#topic+cgarchspec">cgarchspec</a></code>, <code><a href="#topic+cgarchfit">cgarchfit</a></code>, <code><a href="#topic+cgarchfilter">cgarchfilter</a></code>,
and <code><a href="#topic+cgarchsim">cgarchsim</a></code>. Usual extractor and support methods for the
multivariate GARCH models are documented in the class of the returned objects.<br />.
</p>


<h3>How to cite this package</h3>

<p>Whenever using this package, please cite as<br />
</p>
<pre>@Manual{Ghalanos_2014,
 author       = {Alexios Galanos},
 title        = {{rmgarch}: Multivariate GARCH models.},
 year         = {2019},
 note 	      = {R package version 1.3-6.}}</pre>


<h3>License</h3>

<p>The releases of this package is licensed under GPL version 3.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Bollerslev, T. 1990, Modelling the coherence in short-run nominal exchange
rates: a multivariate generalized ARCH model, <em>The Review of Economics and
Statistics</em>, <b>72(3)</b>, 498&ndash;505.<br />
Broda, S.A. and Paolella, M.S. 2009, CHICAGO: A Fast and Accurate Method for
Portfolio Risk Calculation, <em>Journal of Financial Econometrics</em> <b>7(4)</b>,
412&ndash;436 .<br />
Cappiello, L., Engle, R.F. and Sheppard, K. 2006, Asymmetric dynamics in the
correlations of global equity and bond returns, <em>Journal of Financial
Econometrics</em> <b>4</b>, 537&ndash;572.<br />
Croux, C. and Joossens, K. 2008, Robust estimation of the vector autoregressive
model by a least trimmed squares procedure, <em>COMPSTAT</em>, 489&ndash;501.<br />
Chen, Y., Hardle, W., and Spokoiny, V. 2010, GHICA - Risk analysis with GH
distributions and independent components, <em>Journal of Empirical Finance</em>,
<b>17(2)</b>, 255&ndash;269.<br />
de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br />
Engle, R.F. 2002, Dynamic conditional correlation, <em>Journal of Business and
Economic Statistics</em> <b>20</b>, 339&ndash;350.<br />
Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
Genest, C., Ghoudi, K. and Rivest, L. 1995, A semiparametric estimation
procedure of dependence parameters in multivariate families of distributions,
<em>Biometrika</em>, <b>82</b>, 543&ndash;552.<br />
Ghalanos, A., Rossi, E., and Urga, G. (2014). <em>Independent Factor
Autoregressive Conditional Density Model</em>, <b>Econometric Reviews</b>.<br />
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br />
Schmidt, R., Hrycej, T. and Stutzle 2006, Multivariate distribution models with
generalized hyperbolic margins, <em>Computational Statistics \&amp; Data Analysis</em>
<b>50(8)</b>, 2065&ndash;2096.<br />
</p>

<hr>
<h2 id='cGARCHfilter-class'>class: Copula Filter Class</h2><span id='topic+cGARCHfilter-class'></span><span id='topic+coef+2CcGARCHfilter-method'></span><span id='topic+fitted+2CcGARCHfilter-method'></span><span id='topic+likelihood+2CcGARCHfilter-method'></span><span id='topic+rcor+2CcGARCHfilter-method'></span><span id='topic+rcov+2CcGARCHfilter-method'></span><span id='topic+rskew+2CcGARCHfilter-method'></span><span id='topic+rshape+2CcGARCHfilter-method'></span><span id='topic+residuals+2CcGARCHfilter-method'></span><span id='topic+show+2CcGARCHfilter-method'></span><span id='topic+sigma+2CcGARCHfilter-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+cgarchfilter">cgarchfilter</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfilter</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate 
filter list. </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification 
list. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfilter-class">mGARCHfilter</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfilter-class">GARCHfilter</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The coefficient vector (see note). </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "cGARCHfilter")</code>:  
The conditional mean filtered data (xts object). </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The joint likelihood. </p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The conditional correlation array with third dimension labels the time index.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The conditional covariance array with third dimension labels the time index.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The model residuals (xts object).</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
Summary. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The model conditional sigma (xts object). </p>
</dd>
<dt>rshape</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "cGARCHfilter")</code>: 
The multivariate distribution skew parameter(s). </p>
</dd>
</dl>



<h3>Note</h3>

<p>The &lsquo;coef&rsquo; method takes additional argument &lsquo;type&rsquo; with valid 
values &lsquo;garch&rsquo; for the garch parameters, &lsquo;dcc&rsquo; for the second 
stage parameters and by default returns all the parameters in a named vector.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Joe, H. <em>Multivariate Models and Dependence Concepts</em>, 1997, 
Chapman \&amp; Hall, London.<br />
Genest, C., Ghoudi, K. and Rivest, L. <em>A semiparametric estimation 
procedure of dependence parameters in multivariate families of distributions</em>, 
1995, Biometrika, 82, 543-552.<br />
</p>

<hr>
<h2 id='cgarchfilter-methods'>function: Copula-GARCH Filter</h2><span id='topic+cgarchfilter'></span><span id='topic+cgarchfilter+2CANY-method'></span><span id='topic+cgarchfilter+2CcGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for creating a Copula-GARCH filter object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgarchfilter(spec, data, out.sample = 0, filter.control = list(n.old = NULL), 
spd.control = list(lower = 0.1, upper = 0.9, type = "pwm", kernel = "epanech"), 
cluster = NULL, varcoef = NULL, realizedVol = NULL, ...)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarchfilter-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+cGARCHspec-class">cGARCHspec</a></code> object created by 
calling <code><a href="#topic+cgarchspec">cgarchspec</a></code> with fixed parameters for the coeffficients.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_data">data</code></td>
<td>
<p> A multivariate xts data object or one which can be coerced to
such.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods 
before the last to keep for out of sample forecasting.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_filter.control">filter.control</code></td>
<td>
<p>Control arguments passed to the filtering routine (see
note below).</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_spd.control">spd.control</code></td>
<td>
<p> If the spd transformation was chosen in the 
specification, the spd.control passes its arguments to the 
<code>spdfit</code> routine of the <code>spd</code> package.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_varcoef">varcoef</code></td>
<td>
<p> If a VAR model was chosen, then this is the VAR coefficient 
matrix which must be supplied. No checks are done on its dimension or 
correctness so it is up to the user to perform the appropriate checks.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_realizedvol">realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td></tr>
<tr><td><code id="cgarchfilter-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+cGARCHfilter-class">cGARCHfilter</a></code> object containing details of the 
Copula-GARCH filter and sharing most of the methods of the 
<code><a href="#topic+cGARCHfit-class">cGARCHfit</a></code> class.
</p>


<h3>Note</h3>

<p>The &lsquo;n.old&rsquo; option in the <code>filter.control</code> argument is key in 
replicating conditions of the original fit. That is, if you want to filter a 
dataset consisting of an expanded dataset (versus the original used in fitting), 
but want to use the same assumptions as the original dataset then the &lsquo;n.old&rsquo; 
argument denoting the original number of data points passed to the 
<code><a href="#topic+cgarchfit">cgarchfit</a></code> function must be provided. This is then used to ensure 
that some calculations which make use of the full dataset (unconditional 
starting values for the garch filtering, the dcc model and the copula 
transformation methods) only use the first &lsquo;n.old&rsquo; points thus 
replicating the original conditions making filtering appropriate for rolling 
1-ahead forecasting.<br />
For extensive examples look in the &lsquo;rmgarch.tests&rsquo; folder.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='cGARCHfit-class'>class: Copula Fit Class</h2><span id='topic+cGARCHfit-class'></span><span id='topic+coef+2CcGARCHfit-method'></span><span id='topic+fitted+2CcGARCHfit-method'></span><span id='topic+likelihood+2CcGARCHfit-method'></span><span id='topic+rcor+2CcGARCHfit-method'></span><span id='topic+rcov+2CcGARCHfit-method'></span><span id='topic+rskew+2CcGARCHfit-method'></span><span id='topic+rshape+2CcGARCHfit-method'></span><span id='topic+residuals+2CcGARCHfit-method'></span><span id='topic+show+2CcGARCHfit-method'></span><span id='topic+sigma+2CcGARCHfit-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+cgarchfit">cgarchfit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfit</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate fit list. </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification list. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfit-class">mGARCHfit</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfit-class">GARCHfit</a>"</code>, by class &quot;mGARCHfit&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfit&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The coefficient vector (see note). </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The conditional mean fitted data (xts object). </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The joint likelihood. </p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The conditional correlation array with third dimension labels the time index.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The conditional covariance array with third dimension labels the time index.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rshape</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The multivariate distribution skew parameter(s). </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The model residuals (xts object).</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
Summary.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The model conditional sigma (xts object). </p>
</dd>
</dl>



<h3>Note</h3>

<p>The &lsquo;coef&rsquo; method takes additional argument &lsquo;type&rsquo; with valid
values &lsquo;garch&rsquo; for the garch parameters, &lsquo;dcc&rsquo; for the second
stage parameters and by default returns all the parameters in a named vector.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Joe, H. <em>Multivariate Models and Dependence Concepts</em>, 1997,
Chapman \&amp; Hall, London.<br />
Genest, C., Ghoudi, K. and Rivest, L. <em>A semiparametric estimation
procedure of dependence parameters in multivariate families of distributions</em>,
1995, Biometrika, 82, 543-552.<br />
</p>

<hr>
<h2 id='cgarchfit-methods'>function: Copula-GARCH Fit</h2><span id='topic+cgarchfit'></span><span id='topic+cgarchfit+2CANY-method'></span><span id='topic+cgarchfit+2CcGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for creating a Copula-GARCH fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgarchfit(spec, data, spd.control = list(lower = 0.1, upper = 0.9, type = "pwm", 
kernel = "epanech"), fit.control = list(eval.se = TRUE, stationarity = TRUE, 
scale = FALSE), solver = "solnp", solver.control = list(), out.sample = 0, 
cluster = NULL, fit = NULL, VAR.fit = NULL, realizedVol = NULL,...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarchfit-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+cGARCHspec-class">cGARCHspec</a></code> A <code><a href="#topic+cGARCHspec-class">cGARCHspec</a></code> 
object created by calling <code><a href="#topic+cgarchspec">cgarchspec</a></code>.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_data">data</code></td>
<td>
<p> A multivariate xts data object or one which can be coerced to
such.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods before 
the last to keep for out of sample forecasting.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_solver">solver</code></td>
<td>
<p> Either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;gosolnp&rdquo; or
&ldquo;lbfgs&rdquo;. It can also optionally be a vector of length 2 with the first
solver being used for the first stage univariate GARCH estimation (in which 
case the option of &ldquo;hybrid&rdquo; is also available).</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine. 
The &lsquo;eval.se&rsquo; option determines whether standard errors are calculated 
(see details below). The &lsquo;scale&rsquo; option is for the first stage 
univariate GARCH fitting routine.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_fit">fit</code></td>
<td>
<p> (optional) A previously estimated univariate 
<code><a href="rugarch.html#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> object (see details).</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_var.fit">VAR.fit</code></td>
<td>
<p> (optional) A previously estimated VAR list returned from 
calling the <code><a href="#topic+varxfit">varxfit</a></code> function.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_spd.control">spd.control</code></td>
<td>
<p> If the spd transformation was chosen in the 
specification, the spd.control passes its arguments to the 
<code>spdfit</code> routine of the <code>spd</code> package.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_realizedvol">realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td></tr>
<tr><td><code id="cgarchfit-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Copula-GARCH models implemented can either be time-varying of DCC variety 
else static. The multivariate Normal and Student distributions are used in the
construction of the copulas, and 3 transformation methods are available 
(parametric, semi-parametric, and empirical). For the semi-parametric case the 
&lsquo;spd&rsquo; package of the author is available to download from CRAN and fits a 
Gaussian kernel in the interior and gpd distribution for the tails (see that 
package for more details).<br />
The static copula allows for the estimation of the correlation matrix either by 
Maximum Likelihood or the Kendall method for the multivariate Student.<br />
Note that the &lsquo;cgarchfit&rsquo; method will assign to the global environment 
the <code><a href="rugarch.html#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> once that is estimated in order to allow 
the routine to be restarted should something go wrong (it should show up as 
&lsquo;.fitlist&rsquo;).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cGARCHfit-class">cGARCHfit</a></code> Object containing details of the Copula-GARCH 
fit.
</p>


<h3>Note</h3>

<p>There is no check on the VAR.fit list passed to the method so particular care 
should be exercised so that the same data used in the fitting routine is also 
used in the VAR fit routine. This must have been called with the option 
<code>postpad</code> &lsquo;constant&rsquo;. The ability to pass this list of the 
pre-calculated VAR model is particularly useful when comparing different models 
(such as DCC GARCH, GO GARCH etc) using the same dataset and VAR method (i.e. 
the same first stage conditional mean filtration). Though the classical VAR 
estimation is very fast and may not require this extra step, the robust method 
is slow and therefore benefits from calculating this only once.<br />
For extensive examples look in the &lsquo;rmgarch.tests&rsquo; folder.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='cGARCHsim-class'>class: Copula Simulation Class</h2><span id='topic+cGARCHsim-class'></span><span id='topic+fitted+2CcGARCHsim-method'></span><span id='topic+sigma+2CcGARCHsim-method'></span><span id='topic+rcor+2CcGARCHsim-method'></span><span id='topic+rcov+2CcGARCHsim-method'></span><span id='topic+show+2CcGARCHsim-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+cgarchsim">cgarchsim</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>msim</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate simulation list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification list. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHsim-class">mGARCHsim</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHsim-class">GARCHsim</a>"</code>, by class &quot;mGARCHsim&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHsim&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "cGARCHsim")</code>:
The simulated conditional returns matrix given. Takes optional argument
&ldquo;sim&rdquo; indicating the simulation run to return (from the m.sim option
of the <code><a href="#topic+cgarchsim">cgarchsim</a></code> method.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "cGARCHfit")</code>:
The simulated conditional sigma matrix given. Takes optional argument
&ldquo;sim&rdquo; indicating the simulation run to return (from the m.sim option
of the <code><a href="#topic+cgarchsim">cgarchsim</a></code> method.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "cGARCHsim")</code>:
The simulated conditional correlation array (for DCC type). Takes optional
argument &ldquo;sim&rdquo; indicating the simulation run to return (from the
m.sim option of the <code><a href="#topic+cgarchsim">cgarchsim</a></code> method. A further argument
&lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "cGARCHsim")</code>:
The simulated conditional covariance array. Takes optional argument
&ldquo;sim&rdquo; indicating the simulation run to return
(from the m.sim option of the <code><a href="#topic+cgarchsim">cgarchsim</a></code> method.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "cGARCHsim")</code>:
Summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Joe, H. <em>Multivariate Models and Dependence Concepts</em>, 1997,
Chapman \&amp; Hall, London.<br />
Genest, C., Ghoudi, K. and Rivest, L. <em>A semiparametric estimation
procedure of dependence parameters in multivariate families of distributions</em>,
1995, Biometrika, 82, 543-552.<br />
</p>

<hr>
<h2 id='cgarchsim-methods'>function: Copula-GARCH Simulation</h2><span id='topic+cgarchsim'></span><span id='topic+cgarchsim+2CANY-method'></span><span id='topic+cgarchsim+2CcGARCHfit-method'></span>

<h3>Description</h3>

<p>Method for creating a Copula-GARCH simulation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgarchsim(fit, n.sim = 1000, n.start = 0, m.sim = 1, 
startMethod = c("unconditional", "sample"), presigma = NULL, preresiduals = NULL, 
prereturns = NULL, preR = NULL, preQ = NULL, preZ = NULL, rseed = NULL, 
mexsimdata = NULL, vexsimdata = NULL, cluster = NULL, only.density = FALSE, 
prerealized = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarchsim-methods_+3A_fit">fit</code></td>
<td>
 
<p>A <code><a href="#topic+cGARCHfit-class">cGARCHfit</a></code> object created by calling <code><a href="#topic+cgarchfit">cgarchfit</a></code>.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_n.sim">n.sim</code></td>
<td>
<p> The simulation horizon.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_n.start">n.start</code></td>
<td>
<p> The burn-in sample.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_m.sim">m.sim</code></td>
<td>
<p> The number of simulations.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_startmethod">startMethod</code></td>
<td>
<p> Starting values for the simulation. Valid methods are 
&lsquo;unconditional&rsquo; for the expected values given the density, 
and &lsquo;sample&rsquo; for the ending values of the actual data from the fit 
object. This is mostly related to the univariate GARCH dynamics.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_presigma">presigma</code></td>
<td>
<p> Allows the starting sigma values to be provided by the user
for the univariate GARCH dynamics.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_prereturns">prereturns</code></td>
<td>
<p> Allows the starting return data to be provided by the 
user for the conditional mean simulation.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_preresiduals">preresiduals</code></td>
<td>
<p> Allows the starting residuals to be provided by the 
user and used in the GARCH dynamics simulation.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_prer">preR</code></td>
<td>
<p> Allows the starting correlation to be provided by the user and
mostly useful for the static copula.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_preq">preQ</code></td>
<td>
<p> Allows the starting &lsquo;DCC-Q&rsquo; value to be provided by the 
user and though unnecessary for the first 1-ahead simulation using the 
&ldquo;sample&rdquo; option in the <code>startMethod</code>, this is key to obtaining
a rolling n-ahead forecast type simulation (see details below).</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_prez">preZ</code></td>
<td>
<p> Allows the starting transformed standardized residuals (used in
the DCC model) to be provided by the user and though unnecessary for the 
first 1-ahead simulation using the &ldquo;sample&rdquo; option in the 
<code>startMethod</code>, this is key to obtaining a rolling n-ahead forecast type 
simulation (see details below).</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_rseed">rseed</code></td>
<td>
<p> Optional seeding value(s) for the random number generator. 
This should be of length equal to m.sim.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>
<p> A list (equal to the number of asset) of matrices of 
simulated external regressor-in-mean data with row length equal to 
n.sim + n.start. If the fit object contains external regressors in the mean 
equation, this must be provided else will be assumed to be zero.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>
<p> A list (equal to the number of asset) of matrices of 
simulated external regressor-in-variance data with row length equal to 
n.sim + n.start. If the fit object contains external regressors in the 
variance equation, this must be provided else will be assumed to be zero.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_only.density">only.density</code></td>
<td>
<p>Whether to return only the simulated returns (discrete
time approximation to the multivariate density). This is sometimes useful
in order to control memory management for large simulations not requiring
any other information.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_prerealized">prerealized</code></td>
<td>
<p>Allows the starting realized volatility values to be provided 
by the user for the univariate GARCH dynamics.</p>
</td></tr>
<tr><td><code id="cgarchsim-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since there is no explicit forecasting routine, the user should use this method 
for incrementally building up n-ahead forecasts by simulating 1-ahead, obtaining 
the means of the returns, sigma, Rho etc and feeding them to the next round of 
simulation as starting values. The  &lsquo;rmgarch.tests&rsquo; folder contains 
specific examples which illustrate this particular point.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cGARCHsim-class">cGARCHsim</a></code> object containing details of the Copula-GARCH 
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Joe, H. <em>Multivariate Models and Dependence Concepts</em>, 1997, 
Chapman \&amp; Hall, London.<br />
Genest, C., Ghoudi, K. and Rivest, L. <em>A semiparametric estimation 
procedure of dependence parameters in multivariate families of distributions</em>, 
1995, Biometrika, 82, 543-552.<br />
</p>

<hr>
<h2 id='cGARCHspec-class'>class: Copula Specification Class</h2><span id='topic+cGARCHspec-class'></span><span id='topic+show+2CcGARCHspec-method'></span><span id='topic+setfixed+3C-+2CcGARCHspec+2Cvector-method'></span><span id='topic+setstart+3C-+2CcGARCHspec+2Cvector-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+cgarchspec">cgarchspec</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> 
The multivariate model specification </p>
</dd>
<dt><code>umodel</code>:</dt><dd><p>Object of class <code>"uGARCHmultispec"</code> 
The univariate model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHspec-class">mGARCHspec</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHspec-class">GARCHspec</a>"</code>, by class &quot;mGARCHspec&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHspec&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "cGARCHspec")</code>: 
Summary.</p>
</dd>
<dt>setfixed&lt;-</dt><dd><p><code>signature(object = "cGARCHspec", value = "vector")</code>: 
Set fixed second stage parameters.</p>
</dd>
<dt>setstart&lt;-</dt><dd><p><code>signature(object = "cGARCHspec", value = "vector")</code>:
Set starting second stage parameters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Joe, H. <em>Multivariate Models and Dependence Concepts</em>, 1997, 
Chapman \&amp; Hall, London.<br />
Genest, C., Ghoudi, K. and Rivest, L. <em>A semiparametric estimation 
procedure of dependence parameters in multivariate families of distributions</em>, 
1995, Biometrika, 82, 543-552.<br />
</p>

<hr>
<h2 id='cgarchspec-methods'>function: Copula-GARCH Specification</h2><span id='topic+cgarchspec'></span><span id='topic+cgarchspec+2CANY-method'></span><span id='topic+cgarchspec+2CuGARCHmultispec-method'></span>

<h3>Description</h3>

<p>Method for creating a Copula-GARCH specification object prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgarchspec(uspec, VAR = FALSE, robust = FALSE, lag = 1, lag.max = NULL, 
lag.criterion = c("AIC", "HQ", "SC", "FPE"), external.regressors = NULL, 
robust.control = list(gamma = 0.25, delta = 0.01, nc = 10, ns = 500), 
dccOrder = c(1, 1), asymmetric = FALSE, 
distribution.model = list(copula = c("mvnorm", "mvt"), 
method = c("Kendall", "ML"), time.varying = FALSE, 
transformation = c("parametric", "empirical", "spd")), 
start.pars = list(), fixed.pars = list()) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgarchspec-methods_+3A_uspec">uspec</code></td>
<td>

<p>A <code><a href="rugarch.html#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> object created by calling 
<code><a href="rugarch.html#topic+multispec">multispec</a></code> on a list of univariate GARCH specifications.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_var">VAR</code></td>
<td>
<p> Whether to fit a VAR model for the conditional mean.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_robust">robust</code></td>
<td>
<p> Whether to use the robust version of VAR.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_lag">lag</code></td>
<td>
<p> The VAR lag.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_lag.max">lag.max</code></td>
<td>
<p> The maximum VAR lag to search for best fit.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_lag.criterion">lag.criterion</code></td>
<td>
<p> The criterion to use for choosing the best lag when
lag.max is not NULL.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_external.regressors">external.regressors</code></td>
<td>
<p> Allows for a matrix of common pre-lagged external 
regressors for the VAR option.
</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_robust.control">robust.control</code></td>
<td>
<p> The tuning parameters to the robust regression 
including the proportion to trim (&ldquo;gamma&rdquo;), the critical value for 
reweighted estimator (&ldquo;delta&rdquo;), the number of subsets (&ldquo;ns&rdquo;) and 
the number of C-steps (&ldquo;nc&rdquo;.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_dccorder">dccOrder</code></td>
<td>
<p> The DCC autoregressive order.</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_asymmetric">asymmetric</code></td>
<td>
<p> Whether to include an asymmetry term to the DCC model (thus
estimating the aDCC).</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_distribution.model">distribution.model</code></td>
<td>
<p> The Copula distribution model. Currently the 
multivariate Normal and Student Copula are supported. </p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_time.varying">time.varying</code></td>
<td>
<p> Whether to fit a dynamic DCC Copula. </p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_transformation">transformation</code></td>
<td>
<p> The type of transformation to apply to the marginal 
innovations of the GARCH fitted models. Supported methods are parametric 
(Inference Function of Margins), empirical (Pseudo ML), and Semi-Parametric 
using a kernel interior and GPD tails (via the &lsquo;spd&rsquo; package).</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_start.pars">start.pars</code></td>
<td>
<p> (optional) Starting values for the DCC parameters 
(starting values for the univariate garch specification should be passed 
directly via the &lsquo;uspec&rsquo; object).</p>
</td></tr>
<tr><td><code id="cgarchspec-methods_+3A_fixed.pars">fixed.pars</code></td>
<td>
<p> (optional) Fixed DCC parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformation method allows for parametric (Inference-Functions for Margins), 
empirical (Pseudo-Likelihood) and semi-parametric (via the spd package).<br />
When the Student Copula is jointly estimated with student margins having so that 
a common shape parameter is obtained, this results in the multivariate Student 
distribution. When estimating the Student Copula with disparate margins, a 
meta-student distribution is obtained. Additionally, the correlation parameter 
in the static Student Copula may be estimated either by Kendall's tau 
transformation or Maximum Likelihood.<br />
The <code>robust</code> option allows for a robust version of VAR based on the 
multivariate Least Trimmed Squares Estimator described in Croux and Joossens 
(2008).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cGARCHspec-class">cGARCHspec</a></code> object containing details of the Copula-GARCH 
specification.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='cordist'>
A Correlation Distance Measure
</h2><span id='topic+cordist'></span>

<h3>Description</h3>

<p>Given an array of correlation snapshots in time, returns a matrix of some rolling
distance measure on the correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cordist(R, distance = c("ma","ms","meda","meds","eigen", "cmd"), n = 25, 
plot = TRUE, dates = NULL, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cordist_+3A_r">R</code></td>
<td>

<p>An array of correlations.
</p>
</td></tr>
<tr><td><code id="cordist_+3A_distance">distance</code></td>
<td>

<p>The measure to use to capture the change between 2 correlation matrices 
(see details).
</p>
</td></tr>
<tr><td><code id="cordist_+3A_n">n</code></td>
<td>

<p>The distance between 2 correlation matrices.
</p>
</td></tr>
<tr><td><code id="cordist_+3A_plot">plot</code></td>
<td>

<p>Whether to create a heatmap plot of the result.
</p>
</td></tr>
<tr><td><code id="cordist_+3A_dates">dates</code></td>
<td>

<p>A <code>POSIXct</code> vector of dates to use for the heatmap (recommend to
supply).
</p>
</td></tr>
<tr><td><code id="cordist_+3A_title">title</code></td>
<td>

<p>Title for the heatmap plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides for a visualization of dynamic correlation distance 
between periods with a number of plausible measures including &ldquo;ma&rdquo; 
(mean absolute), &ldquo;ms&rdquo; (mean squared), &ldquo;meda&rdquo; (median absolute), 
&ldquo;meds&rdquo; (median squared) &ldquo;eigen&rdquo; (largest eigenvalue difference) and
&ldquo;cmd&rdquo; (correlation matrix distance). See the references for more details. 
</p>


<h3>Value</h3>

<p>A symmetric matrix of the rolling distance measure for each period.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Munnix, M. C., Shimada, T., Schafer, R., Leyvraz, F., Seligman, T. H., 
Guhr, T., &amp; Stanley, H. E. (2012). Identifying states of a financial market. 
<em>Scientific Reports 2</em>.<br />
Herdin, M., Czink, N., Ozcelik, H., &amp; Bonek, E. (2005). Correlation matrix 
distance, a meaningful measure for evaluation of non-stationary MIMO channels. 
<em>Vehicular Technology Conference, 2005, IEEE 61st</em>, <b>1</b>, 136&ndash;140.
</p>

<hr>
<h2 id='DCCfilter-class'>class: DCC Filter Class</h2><span id='topic+DCCfilter-class'></span><span id='topic+coef+2CDCCfilter-method'></span><span id='topic+fitted+2CDCCfilter-method'></span><span id='topic+sigma+2CDCCfilter-method'></span><span id='topic+likelihood+2CDCCfilter-method'></span><span id='topic+nisurface+2CDCCfilter-method'></span><span id='topic+plot+2CDCCfilter+2Cmissing-method'></span><span id='topic+rcor+2CDCCfilter-method'></span><span id='topic+rcov+2CDCCfilter-method'></span><span id='topic+residuals+2CDCCfilter-method'></span><span id='topic+rshape+2CDCCfilter-method'></span><span id='topic+rskew+2CDCCfilter-method'></span><span id='topic+show+2CDCCfilter-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccfilter">dccfilter</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfilter</code>:</dt><dd><p>Object of class <code>"vector"</code>. Multivariate filter
list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>. Model specification
list.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfilter-class">mGARCHfilter</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfilter-class">GARCHfilter</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "DCCfilter")</code>
The coefficient vector (see note). </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The joint likelihood. </p>
</dd>
<dt>rshape</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The multivariate distribution skew parameter(s). </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The filtered conditional mean xts object. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The filtered conditional sigma xts object. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The filtered conditional mean residuals xts object. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DCCfilter", y = "missing")</code>:
Plot method, given additional arguments &lsquo;series&rsquo; and &lsquo;which&rsquo;.</p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "DCCfilter")</code>:
Information criteria. </p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The filtered dynamic conditional correlation array given additional
argument &lsquo;type&rsquo; (either &ldquo;R&rdquo; for the
correlation else will return the &ldquo;Q&rdquo; matrix). The third dimension
label of the array gives the time index (from which it is then possible to
construct pairwise xts objects for example). A further argument &lsquo;output&rsquo;
allows to switch between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The filtered dynamic conditional covariance array. The third dimension
label of the array gives the time index (from which it is then possible to
construct pairwise xts objects for example). A further argument &lsquo;output&rsquo;
allows to switch between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCfilter")</code>:
Summary. </p>
</dd>
<dt>nisurface</dt><dd><p><code>signature(object = "DCCfilter")</code>:
The news impact surface plot given additional arguments &lsquo;type&rsquo; with
either &ldquo;cov&rdquo; or &ldquo;cor&rdquo; (for the covariance and correlation news
impact respectively), &lsquo;pair&rsquo; denoting the asset pair (defaults to
c(1,2)), &lsquo;plot&rsquo; (logical) and &lsquo;plot.type&rsquo; with a choice of
either &ldquo;surface&rdquo; or &ldquo;contour&rdquo;. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The &lsquo;coef&rsquo; method takes additional argument &lsquo;type&rsquo; with valid
values &lsquo;garch&rsquo; for the univariate garch parameters,  &lsquo;dcc&rsquo; for the
second stage dcc parameters and by default returns all the parameters in a named
vector.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccfilter-methods'>function: DCC-GARCH Filter</h2><span id='topic+dccfilter'></span><span id='topic+dccfilter+2CANY-method'></span><span id='topic+dccfilter+2CDCCspec-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH filter object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccfilter(spec, data, out.sample = 0, filter.control = list(n.old = NULL), 
cluster = NULL, varcoef = NULL, realizedVol = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccfilter-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+DCCspec-class">DCCspec</a></code> object created by calling 
<code><a href="#topic+dccspec">dccspec</a></code> with fixed parameters for the coefficients.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_data">data</code></td>
<td>
<p> A multivariate data object of class xts, or one which can be
coerced to such.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods 
before the last to keep for out of sample forecasting.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_filter.control">filter.control</code></td>
<td>
<p>Control arguments passed to the filtering routine (see
note.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_varcoef">varcoef</code></td>
<td>
<p> If a VAR model was chosen, then this is the VAR coefficient 
matrix which must be supplied. No checks are done on its dimension or 
correctness so it is up to the user to perform the appropriate checks.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_realizedvol">realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td></tr>
<tr><td><code id="dccfilter-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCfilter-class">DCCfilter</a></code> object containing details of the DCC-GARCH 
filter.
</p>


<h3>Note</h3>

<p>The &lsquo;n.old&rsquo; option in the <code>filter.control</code> argument is key in 
replicating conditions of the original fit. That is, if you want to filter a 
dataset consisting of an expanded dataset (versus the original used in fitting), 
but want to use the same assumptions as the original dataset then the &lsquo;n.old&rsquo; 
argument denoting the original number of data points passed to the 
<code><a href="#topic+dccfit">dccfit</a></code> function must be provided. This is then used to ensure 
that some calculations which make use of the full dataset (unconditional 
starting values for the garch filtering and the dcc model) only use the first 
&lsquo;n.old&rsquo; points thus replicating the original conditions making filtering 
appropriate for rolling 1-ahead forecasting.<br />
For extensive examples look in the &lsquo;rmgarch.tests&rsquo; folder.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='DCCfit-class'>class: DCC Fit Class</h2><span id='topic+DCCfit-class'></span><span id='topic+coef+2CDCCfit-method'></span><span id='topic+fitted+2CDCCfit-method'></span><span id='topic+sigma+2CDCCfit-method'></span><span id='topic+infocriteria+2CDCCfit-method'></span><span id='topic+likelihood+2CDCCfit-method'></span><span id='topic+nisurface+2CDCCfit-method'></span><span id='topic+plot+2CDCCfit+2Cmissing-method'></span><span id='topic+rcor+2CDCCfit-method'></span><span id='topic+rcov+2CDCCfit-method'></span><span id='topic+residuals+2CDCCfit-method'></span><span id='topic+rshape+2CDCCfit-method'></span><span id='topic+rshape'></span><span id='topic+rskew+2CDCCfit-method'></span><span id='topic+rskew'></span><span id='topic+show+2CDCCfit-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccfit">dccfit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfit</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate filter
list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>  Model specification
list. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfit-class">mGARCHfit</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfit-class">GARCHfit</a>"</code>, by class &quot;mGARCHfit&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfit&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "DCCfit")</code>
The coefficient vector (see note). </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "DCCfit")</code>:
The joint likelihood. </p>
</dd>
<dt>rshape</dt><dd><p><code>signature(object = "DCCfit")</code>:
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "DCCfit")</code>:
The multivariate distribution skew parameter(s). </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "DCCfit")</code>:
The fitted conditional mean xts object. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "DCCfit")</code>:
The fitted conditional GARCH sigma xts object. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "DCCfit")</code>:
The fitted conditional mean residuals xts object. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DCCfit", y = "missing")</code>:
Plot method, given additional arguments &lsquo;series&rsquo; and &lsquo;which&rsquo;.</p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "DCCfit")</code>:
Information criteria. </p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "DCCfit")</code>:
The fitted dynamic conditional correlation array given additional
arguments &lsquo;type&rsquo; (either &ldquo;R&rdquo; for the
correlation else will return the Q matrix). The third dimension label of the
array gives the time index (from which it is then possible to construct
pairwise xts objects for example). The argument &lsquo;output&rsquo; can be either
&ldquo;array&rdquo; (default) or &ldquo;matrix&rdquo; in which case the array is flattened
and the lower diagonal time varying values are returned (and if a date exists,
then the returned object is of class xts).
</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "DCCfit")</code>:
The fitted dynamic conditional covariance array. The third dimension label
of the array gives the time index (from which it is then possible to
construct pairwise xts objects for example). The argument &lsquo;output&rsquo; can be either
&ldquo;array&rdquo; (default) or &ldquo;matrix&rdquo; in which case the array is flattened
and the lower and main diagonal time varying values are returned (and if a date exists,
then the returned object is of class xts).
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCfit")</code>:
Summary. </p>
</dd>
<dt>nisurface</dt><dd><p><code>signature(object = "DCCfit")</code>:
The news impact surface plot given additional arguments &lsquo;type&rsquo; with
either &ldquo;cov&rdquo; or &ldquo;cor&rdquo; (for the covariance and correlation news
impact respectively), &lsquo;pair&rsquo; (defaults to c(1,2)), &lsquo;plot&rsquo;
(logical) and &lsquo;plot.type&rsquo; with a choice of either &ldquo;surface&rdquo; or
&ldquo;contour&rdquo;. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The &lsquo;coef&rsquo; method takes additional argument &lsquo;type&rsquo; with valid
values &lsquo;garch&rsquo; for the univariate garch parameters,  &lsquo;dcc&rsquo; for the
second stage dcc parameters and by default returns all the parameters in a named
vector.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccfit-methods'>function: DCC-GARCH Fit</h2><span id='topic+dccfit'></span><span id='topic+dccfit+2CANY-method'></span><span id='topic+dccfit+2CDCCspec-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccfit(spec, data, out.sample = 0, solver = "solnp", solver.control = list(), 
fit.control = list(eval.se = TRUE, stationarity = TRUE, scale = FALSE), 
cluster = NULL, fit = NULL, VAR.fit = NULL, realizedVol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccfit-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+DCCspec-class">DCCspec</a></code> object created by calling 
<code><a href="#topic+dccspec">dccspec</a></code>.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_data">data</code></td>
<td>
<p> A multivariate data object of class xts or one which can be 
coerced to such.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods 
before the last to keep for out of sample forecasting.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_solver">solver</code></td>
<td>
<p> Either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;gosolnp&rdquo; or
&ldquo;lbfgs&rdquo;. It can also optionally be a vector of length 2 with the first
solver being used for the first stage univariate GARCH estimation (in which 
case the option of &ldquo;hybrid&rdquo; is also available).</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine. 
The &lsquo;eval.se&rsquo; option determines whether standard errors are calculated 
(see details below). The &lsquo;stationarity&rsquo; option is for the univariate 
stage GARCH fitting routine, whilst for the second stage DCC this is 
imposed by design. The &lsquo;scale&rsquo; option is also for the first stage 
univariate GARCH fitting routine.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_fit">fit</code></td>
<td>
<p> (optional) A previously estimated univariate 
<code><a href="rugarch.html#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> object (see details).</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_var.fit">VAR.fit</code></td>
<td>
<p> (optional) A previously estimated VAR object returned from 
calling the <code><a href="#topic+varxfit">varxfit</a></code> function.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_realizedvol">realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td></tr>
<tr><td><code id="dccfit-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2-step DCC estimation fits a GARCH-Normal model to the univariate data and 
then proceeds to estimate the second step based on the chosen multivariate 
distribution. Because of this 2-step approach, standard errors are expensive to 
calculate and therefore the use of parallel functionality, built into both the 
fitting and standard error calculation routines is key. The switch to turn off 
the calculation of standard errors through the &lsquo;fit.control&rsquo; option could 
be quite useful in rolling estimation such as in the <code><a href="#topic+dccroll">dccroll</a></code> 
routine.<br />
The optional &lsquo;fit&rsquo; argument allows to pass your own <code><a href="rugarch.html#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> 
object instead of having the routine estimate it. This is very useful in cases 
of multiple use of the same fit and problems in convergence which might require 
a more hands on approach to the univariate fitting stage. However, it is up to 
the user to ensure consistency between the &lsquo;fit&rsquo; and supplied &lsquo;spec&rsquo;.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCfit-class">DCCfit</a></code> object containing details of the DCC-GARCH fit.
</p>


<h3>Note</h3>

<p>There is no check on the VAR.fit list passed to the method so particular care 
should be exercised so that the same data used in the fitting routine is also 
used in the VAR fit routine. This this must have been called with the option 
<code>postpad</code> &lsquo;constant&rsquo;. The ability to pass this list of the 
pre-calculated VAR model is particularly useful when comparing different models 
(such as copula-GARCH, GO-GARCH etc) using the same dataset and VAR method (i.e. 
the same first stage conditional mean filtration). Though the classical VAR 
estimation is very fast and may not require this extra step, the robust method 
is slow and therefore benefits from calculating this only once.<br />
For extensive examples look in the &lsquo;rmgarch.tests&rsquo; folder.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='DCCforecast-class'>class: DCC Forecast Class</h2><span id='topic+DCCforecast-class'></span><span id='topic+fitted+2CDCCforecast-method'></span><span id='topic+sigma+2CDCCforecast-method'></span><span id='topic+rcor+2CDCCforecast-method'></span><span id='topic+rcov+2CDCCforecast-method'></span><span id='topic+rshape+2CDCCforecast-method'></span><span id='topic+rskew+2CDCCforecast-method'></span><span id='topic+show+2CDCCforecast-method'></span><span id='topic+plot+2CDCCforecast+2Cmissing-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccforecast">dccforecast</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mforecast</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate
forecast list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification
list.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHforecast-class">mGARCHforecast</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHforecast-class">GARCHforecast</a>"</code>, by class &quot;mGARCHforecast&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHforecast&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>rshape</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The multivariate distribution skew parameter(s). </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The conditional mean forecast array of dimensions n.ahead x n.assets
by (n.roll+1). The thirds dimension of the array has the T+0 index label.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The conditional sigma forecast array of dimensions n.ahead x n.assets
by (n.roll+1). The thirds dimension of the array has the T+0 index label.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DCCforecast", y = "missing")</code>:
Plot method, given additional arguments &lsquo;series&rsquo; and &lsquo;which&rsquo;.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The forecast dynamic conditional correlation list of arrays of length
(n.roll+1), with each array of dimensions n.assets x n.assets x n.ahead.
The method takes on one additional argument &lsquo;type&rsquo; (either &ldquo;R&rdquo;
for the correlation else will return the DCC Q matrix). A further argument
&lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.
</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "DCCforecast")</code>:
The forecast dynamic conditional correlation list of arrays of length
(n.roll+1), with each array of dimensions n.assets x n.assets x n.ahead.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCforecast")</code>:
Summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccforecast-methods'>function: DCC-GARCH Forecast</h2><span id='topic+dccforecast'></span><span id='topic+dccforecast+2CANY-method'></span><span id='topic+dccforecast+2CDCCfit-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH forecast object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccforecast(fit, n.ahead = 1, n.roll = 0, 
external.forecasts = list(mregfor = NULL, vregfor = NULL), cluster = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccforecast-methods_+3A_fit">fit</code></td>
<td>
<p> A <code><a href="#topic+DCCfit-class">DCCfit</a></code> object created by calling 
<code><a href="#topic+dccfit">dccfit</a></code>.</p>
</td></tr>
<tr><td><code id="dccforecast-methods_+3A_n.ahead">n.ahead</code></td>
<td>
<p> The forecast horizon.</p>
</td></tr>
<tr><td><code id="dccforecast-methods_+3A_n.roll">n.roll</code></td>
<td>
<p> The no. of rolling forecasts to create beyond the first one 
(see details).</p>
</td></tr>
<tr><td><code id="dccforecast-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>
<p> A list with forecasts for the external regressors 
in the mean and/or variance equations if specified (see details).</p>
</td></tr>
<tr><td><code id="dccforecast-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="dccforecast-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code>n.roll</code>, it is assumed that <code><a href="#topic+dccfit">dccfit</a></code> was called 
with argument &lsquo;out.sample&rsquo; being large enough to cover n-rolling 
forecasts.<br /> 
When n.roll = 0, all forecasts are based on an unconditional n-ahead forecast 
routine based on the approximation method described in ENGLE and SHEPPARD (2001) 
paper (see reference below). If any external regressors are present, then the 
user must pass in their unconditional forecasts in the &lsquo;external.forecasts&rsquo; 
list, as matrices with dimensions equal to n.ahead x n.assets. This assumes
that the univariate GARCH specifications share common external regressors 
(this may change in the future).<br />
When n.roll&gt;0 and n.ahead = 1, then this is a pure rolling forecast based on the 
available out.sample data provided for in the call to the fit routine. It is 
also assumed that if any external regressors were passed to the fit routine that 
they contained enough values to cover the out.sample period so that they could 
be used in this forecast scenario.<br /> 
The case of n.roll &gt; 0 AND n.ahead &gt; 1 is not implemented.<br />
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCforecast-class">DCCforecast</a></code> object containing details of the DCC-GARCH 
forecast.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of 
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='DCCroll-class'>class: DCC Roll Class</h2><span id='topic+DCCroll-class'></span><span id='topic+coef+2CDCCroll-method'></span><span id='topic+fitted+2CDCCroll-method'></span><span id='topic+likelihood+2CDCCroll-method'></span><span id='topic+plot+2CDCCroll+2Cmissing-method'></span><span id='topic+rcor+2CDCCroll-method'></span><span id='topic+rcov+2CDCCroll-method'></span><span id='topic+rshape+2CDCCroll-method'></span><span id='topic+rskew+2CDCCroll-method'></span><span id='topic+show+2CDCCroll-method'></span><span id='topic+sigma+2CDCCroll-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccroll">dccroll</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mforecast</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate
forecast list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification
list.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHroll-class">mGARCHroll</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHroll-class">GARCHroll</a>"</code>, by class &quot;mGARCHroll&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHroll&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "DCCroll")</code>:
The coefficient array across the rolling estimations with a T+0
3rd dimension index label.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "DCCroll")</code>:
The conditional mean forecast xts object (with the actual T+i forecast
dates as index).</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "DCCroll")</code>:
The log-likelihood across rolling estimations.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "DCCroll", y = "missing")</code>:
Plot method, given additional arguments &lsquo;series&rsquo; and &lsquo;which&rsquo;.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "DCCroll")</code>:
The forecast dynamic conditional correlation array, with the T+i forecast
index in the 3rd dimension label. Optional argument &lsquo;type&rsquo;
determines whether to return &ldquo;R&rdquo; for the correlation else will
the DCC Q matrix. A further argument &lsquo;output&rsquo; allows to switch
between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "DCCroll")</code>:
The forecast dynamic conditional covariance array, with the T+i forecast
index in the 3rd dimension label. A further argument
&lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rshape</dt><dd><p><code>signature(object = "DCCroll")</code>:
The multivariate distribution shape parameter(s).</p>
</dd>
<dt>rskew</dt><dd><p><code>signature(object = "DCCroll")</code>:
The multivariate distribution skew parameter(s). </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCroll")</code>:
Summary. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "DCCroll")</code>:
The conditional sigma forecast xts object (with the actual T+i forecast
dates as index).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccroll-methods'>function: DCC-GARCH Rolling Forecast</h2><span id='topic+dccroll'></span><span id='topic+dccroll+2CANY-method'></span><span id='topic+dccroll+2CDCCspec-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH rolling forecast object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccroll(spec, data, n.ahead = 1, forecast.length = 50, refit.every = 25, 
n.start = NULL, refit.window = c("recursive", "moving"), window.size = NULL, 
solver = "solnp", solver.control = list(), 
fit.control = list(eval.se = TRUE, stationarity = TRUE, scale = FALSE), 
cluster = NULL, save.fit = FALSE, save.wdir = NULL, realizedVol = NULL, 
clusterOnAssets=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccroll-methods_+3A_spec">spec</code></td>
<td>
<p> A <code><a href="#topic+DCCspec-class">DCCspec</a></code> object with fixed parameters.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_data">data</code></td>
<td>
<p> A multivariate xts dataset or one which can be coerced to such.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_n.ahead">n.ahead</code></td>
<td>
<p> The number of periods to forecast. </p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_forecast.length">forecast.length</code></td>
<td>
<p> The length of the total forecast for which out of 
sample data from the dataset will be used for testing.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_n.start">n.start</code></td>
<td>
<p> Instead of forecast.length, this determines the starting 
point in the dataset from which to initialize the rolling forecast.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_refit.every">refit.every</code></td>
<td>
<p> Determines every how many periods the model is 
re-estimated.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_refit.window">refit.window</code></td>
<td>

<p>Whether the refit is done on an expanding window including all the previous 
data or a moving window where all previous data is used for the first estimation 
and then moved by a length equal to refit.every (unless the window.size option 
is used instead).</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_window.size">window.size</code></td>
<td>

<p>If not NULL, determines the size of the moving window in the rolling estimation,
which also determines the first point used.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_solver">solver</code></td>
<td>
<p> The solver to use.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_fit.control">fit.control</code></td>
<td>
<p> Control parameters parameters passed to the fitting 
function.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_solver.control">solver.control</code></td>
<td>
<p> Control parameters passed to the solver.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation of the refits (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_save.fit">save.fit</code></td>
<td>
<p> Whether to save the fitted objects of class 
<code><a href="#topic+DCCfit-class">DCCfit</a></code> during the estimation of each (&ldquo;refit.every&rdquo;). 
If true, the directory to save must be provided. The function will not save 
this by default for reasons of memory management, but can save it as an 
&ldquo;.rda&rdquo; file in the user's chosen directory for further analysis.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_save.wdir">save.wdir</code></td>
<td>
<p> If &ldquo;save.fit&rdquo; is true, the directory in which to 
save the <code><a href="#topic+DCCfit-class">DCCfit</a></code> objects (1 for each &ldquo;refit.every&rdquo;).</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_realizedvol">realizedVol</code></td>
<td>
<p> Required xts matrix for the realGARCH model.</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_clusteronassets">clusterOnAssets</code></td>
<td>
<p>If a cluster object is provided, use parallel resources on 
the univariate estimation (TRUE) else on the rolling windows (FALSE).</p>
</td></tr>
<tr><td><code id="dccroll-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCroll-class">DCCroll</a></code> object containing details of the DCC-GARCH 
rolling forecast.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='DCCsim-class'>class: DCC Forecast Class</h2><span id='topic+DCCsim-class'></span><span id='topic+fitted+2CDCCsim-method'></span><span id='topic+rcor+2CDCCsim-method'></span><span id='topic+rcov+2CDCCsim-method'></span><span id='topic+sigma+2CDCCsim-method'></span><span id='topic+show+2CDCCsim-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccsim">dccsim</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>msim</code>:</dt><dd><p>Object of class <code>"vector"</code> Multivariate
simulation list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> Model specification
list.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHsim-class">mGARCHsim</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHsim-class">GARCHsim</a>"</code>, by class &quot;mGARCHsim&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHsim&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "DCCsim")</code>:
The conditional mean simulated data matrix given additional argument
&lsquo;sim&rsquo; denoting the simulation run (<code>m.sim</code>) to return values
for.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object 	= "DCCsim")</code>:
The simulated dynamic conditional correlation array given additional
arguments &lsquo;sim&rsquo; denoting the simulation run (<code>m.sim</code>) to
return values for, and &lsquo;type&rsquo; (either &ldquo;R&rdquo; for the correlation
else will return the Q matrix). A further argument &lsquo;output&rsquo; allows to
switch between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object 	= "DCCsim")</code>:
The simulated dynamic conditional covariance array given additional argument
&lsquo;sim&rsquo; denoting the simulation run (<code>m.sim</code>) to return values
for. A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "DCCsim")</code>:
The univariate simulated conditional sigma matrix given additional argument
&lsquo;sim&rsquo; (<code>m.sim</code>) denoting the simulation run to return values
for.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCsim")</code>:
Summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccsim-methods'>function: DCC-GARCH Simulation</h2><span id='topic+dccsim'></span><span id='topic+dccsim+2CANY-method'></span><span id='topic+dccsim+2CDCCspec-method'></span><span id='topic+dccsim+2CDCCfit-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH simulation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccsim(fitORspec, n.sim = 1000, n.start = 0, m.sim = 1, 
startMethod = c("unconditional", "sample"), presigma = NULL, preresiduals = NULL, 
prereturns = NULL, preQ = NULL, preZ = NULL, Qbar = NULL, Nbar = NULL, 
rseed = NULL, mexsimdata = NULL, vexsimdata = NULL, cluster = NULL, 
VAR.fit = NULL, prerealized = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccsim-methods_+3A_fitorspec">fitORspec</code></td>
<td>
<p> A <code><a href="#topic+DCCspec-class">DCCspec</a></code> or <code><a href="#topic+DCCfit-class">DCCfit</a></code> 
object created by calling either <code><a href="#topic+dccspec">dccspec</a></code> with fixed parameters 
or <code><a href="#topic+dccfit">dccfit</a></code>.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_n.sim">n.sim</code></td>
<td>
<p> The simulation horizon.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_n.start">n.start</code></td>
<td>
<p> The burn-in sample.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_m.sim">m.sim</code></td>
<td>
<p> The number of simulations.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_startmethod">startMethod</code></td>
<td>
<p> Starting values for the simulation. Valid methods are 
&ldquo;unconditional&rdquo; for the expected values given the density, and 
&ldquo;sample&rdquo; for the ending values of the actual data from the fit 
object (for the dispatch method using a specification, &ldquo;sample&rdquo; is 
not relevant).</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_presigma">presigma</code></td>
<td>
<p> Allows the starting sigma values to be provided by the user
for the univariate GARCH dynamics.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_prereturns">prereturns</code></td>
<td>
<p> Allows the starting return data to be provided by the 
user for the conditional mean simulation.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_preresiduals">preresiduals</code></td>
<td>
<p> Allows the starting residuals to be provided by the 
user and used in the GARCH dynamics simulation.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_preq">preQ</code></td>
<td>
<p> Allows the starting &lsquo;DCC-Q&rsquo; value to be provided by the 
user and though unnecessary for the first 1-ahead simulation using the 
&ldquo;sample&rdquo; option in the <code>startMethod</code>, this is key to obtaining
a rolling n-ahead forecast type simulation (see details below).</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_prez">preZ</code></td>
<td>
<p> Allows the starting standardized residuals to be provided by 
the user and though unnecessary for the first 1-ahead simulation using 
the &ldquo;sample&rdquo; option in the <code>startMethod</code>, this is key to 
obtaining a rolling n-ahead forecast type simulation (see details below).</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_qbar">Qbar</code></td>
<td>
<p> The DCC dynamics unconditional Q matrix, required for the 
specification dispatch method.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_nbar">Nbar</code></td>
<td>
<p> The aDCC dynamics unconditional asymmetry matrix, required for 
the specification dispatch method.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_rseed">rseed</code></td>
<td>
<p> Optional seeding value(s) for the random number generator. 
For m.sim&gt;1, it is possible to provide either a single seed to initialize 
all values, or one seed per separate simulation (i.e. m.sim seeds). However, 
in the latter case this may result in some slight overhead depending on
how large m.sim is.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>
<p> A list (equal to the number of asset) of matrices of 
simulated external regressor-in-mean data with row length equal to 
n.sim + n.start. If the fit object contains external regressors in the mean 
equation, this must be provided else will be assumed to be zero.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>
<p> A list (equal to the number of asset) of matrices of 
simulated external regressor-in-variance data with row length equal to 
n.sim + n.start. If the fit object contains external regressors in the 
variance equation, this must be provided else will be assumed to be zero.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_var.fit">VAR.fit</code></td>
<td>
<p> An VAR.fit list returned from calling the 
<code><a href="#topic+varxfilter">varxfilter</a></code> or <code><a href="#topic+varxfit">varxfit</a></code> function with <code>postpad</code> 
set to &ldquo;constant&rdquo;. This is required for the specification dispatch
method.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_prerealized">prerealized</code></td>
<td>
<p>Allows the starting realized volatility values to be provided 
by the user for the univariate GARCH dynamics.</p>
</td></tr>
<tr><td><code id="dccsim-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to pass a correct specification to the filter routine, you must ensure 
that it contains the appropriate &lsquo;fixed.pars&rsquo; in both the multivariate 
DCC part of the specification as well as the multiple univariate specification 
part, for which the method <code><a href="rugarch.html#topic+setfixed+3C-">setfixed&lt;-</a></code> should be used.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCsim-class">DCCsim</a></code> object containing details of the DCC-GARCH 
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='DCCspec-class'>class: DCC Specification Class</h2><span id='topic+DCCspec-class'></span><span id='topic+show+2CDCCspec-method'></span><span id='topic+setfixed+3C-+2CDCCspec+2Cvector-method'></span><span id='topic+setstart+3C-+2CDCCspec+2Cvector-method'></span>

<h3>Description</h3>

<p>The class is returned by calling the function <code><a href="#topic+dccspec">dccspec</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> The multivariate model
specification list. </p>
</dd>
<dt><code>umodel</code>:</dt><dd><p>Object of class <code>"vector"</code> The univariate model
specification list.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHspec-class">mGARCHspec</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHspec-class">GARCHspec</a>"</code>, by class &quot;mGARCHspec&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHspec&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>setfixed&lt;-</dt><dd><p><code>signature(object = "DCCspec", value = "vector")</code>: 
Set fixed second stage parameters.</p>
</dd>
<dt>setstart&lt;-</dt><dd><p><code>signature(object = "DCCspec", value = "vector")</code>:
Set starting second stage parameters.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "DCCspec")</code>: 
Summary.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The &lsquo;umodel&rsquo; list is absorbed into the &lsquo;model&rsquo; list in all other
DCC classes.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Croux, C. and Joossens, K. 2008, Robust estimation of the vector autoregressive 
model by a least trimmed squares procedure, <em>COMPSTAT</em>, 489&ndash;501.<br />
Cappiello, L., Engle, R.F. and Sheppard, K. 2006, Asymmetric dynamics in the 
correlations of global equity and bond returns, <em>Journal of Financial 
Econometrics</em> <b>4</b>, 537&ndash;572.<br />
Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of 
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dccspec-methods'>function: DCC-GARCH Specification</h2><span id='topic+dccspec'></span><span id='topic+dccspec+2CANY-method'></span><span id='topic+dccspec+2CuGARCHmultispec-method'></span>

<h3>Description</h3>

<p>Method for creating a DCC-GARCH specification object prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccspec(uspec, VAR = FALSE, robust = FALSE, lag = 1, lag.max = NULL, 
lag.criterion = c("AIC", "HQ", "SC", "FPE"), external.regressors = NULL, 
robust.control = list("gamma" = 0.25, "delta" = 0.01, "nc" = 10, "ns" = 500), 
dccOrder = c(1,1), model = c("DCC", "aDCC", "FDCC"), groups = rep(1, length(uspec@spec)), 
distribution = c("mvnorm", "mvt", "mvlaplace"), start.pars = list(), fixed.pars = list()) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccspec-methods_+3A_uspec">uspec</code></td>
<td>

<p>A <code><a href="rugarch.html#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> object created by calling 
<code><a href="rugarch.html#topic+multispec">multispec</a></code> on a list of univariate GARCH specifications.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_var">VAR</code></td>
<td>
<p> Whether to fit a VAR model for the conditional mean.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_robust">robust</code></td>
<td>
<p> Whether to use the robust version of VAR.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_lag">lag</code></td>
<td>
<p> The VAR lag.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_lag.max">lag.max</code></td>
<td>
<p> The maximum VAR lag to search for best fit.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_lag.criterion">lag.criterion</code></td>
<td>
<p> The criterion to use for choosing the best lag when
lag.max is not NULL.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_external.regressors">external.regressors</code></td>
<td>
<p> Allows for a matrix of common pre-lagged external 
regressors for the VAR option.
</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_robust.control">robust.control</code></td>
<td>
<p> The tuning parameters to the robust regression 
including the proportion to trim (&ldquo;gamma&rdquo;), the critical value for 
re-weighted estimator (&ldquo;delta&rdquo;), the number of subsets (&ldquo;ns&rdquo;) 
and the number of C-steps (&ldquo;nc&rdquo;.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_dccorder">dccOrder</code></td>
<td>
<p> The DCC autoregressive order.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_model">model</code></td>
<td>
<p> The DCC model to use, with a choice of the symmetric DCC, 
asymmetric (aDCC) and the Flexible DCC (FDCC). See notes for more details.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_groups">groups</code></td>
<td>
<p> The groups corresponding to each asset in the FDCC model, where
these are assumed and checked to be contiguous and increasing (unless only 1 group).</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_distribution">distribution</code></td>
<td>
<p> The multivariate distribution. Currently the multivariate 
Normal, Student and Laplace are implemented, and only the Normal for the FDCC model.</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_start.pars">start.pars</code></td>
<td>
<p> (optional) Starting values for the DCC parameters (starting 
values for the univariate garch specification should be passed directly 
via the &lsquo;uspec&rsquo; object).</p>
</td></tr>
<tr><td><code id="dccspec-methods_+3A_fixed.pars">fixed.pars</code></td>
<td>
<p> (optional) Fixed DCC parameters. This is required in the 
<code><a href="#topic+dccfilter">dccfilter</a></code>, <code><a href="#topic+dccforecast">dccforecast</a></code>, <code><a href="#topic+dccsim">dccsim</a></code> with 
spec, and  <code><a href="#topic+dccroll">dccroll</a></code> 
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>robust</code> option allows for a robust version of VAR based on the 
multivariate Least Trimmed Squares Estimator described in Croux and Joossens 
(2008).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DCCspec-class">DCCspec</a></code> object containing details of the DCC-GARCH 
specification.
</p>


<h3>Note</h3>

<p>The FDCC model of Billio, Caporin and Gobbo (2006) allows different DCC 
parameters to govern the dynamics of the correlation of distinct groups. The 
drawback is a somewhat larger parameter set, and no correlation targeting. 
Still, it remains a feasible model for not too large a number of groups, and
avoids the unrealistic assumption, particularly for large datasets, of one 
parameter governing all the dynamics, as in the DCC model. Note that the group
indices must be increasing (unless all 1), which means that you should arrange
your dataset so that the assets are ordered by their groups.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Billio, M., Caporin, M., &amp; Gobbo, M. 2006, Flexible dynamic conditional 
correlation multivariate GARCH models for asset allocation, <em>Applied 
Financial Economics Letters</em>, <b>2(02)</b>, 123&ndash;130.<br />
Croux, C. and Joossens, K. 2008, Robust estimation of the vector autoregressive 
model by a least trimmed squares procedure, <em>COMPSTAT</em>, 489&ndash;501.<br />
Cappiello, L., Engle, R.F. and Sheppard, K. 2006, Asymmetric dynamics in the 
correlations of global equity and bond returns, <em>Journal of Financial 
Econometrics</em> <b>4</b>, 537&ndash;572.<br />
Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of 
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='DCCtest'>
Engle and Sheppard Test of Dynamic Correlation
</h2><span id='topic+DCCtest'></span>

<h3>Description</h3>

<p>A test of non-constant correlation based on Engle and Sheppard (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCCtest(Data, garchOrder = c(1,1), n.lags = 1, solver = "solnp", 
solver.control = list(), cluster = NULL, Z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCCtest_+3A_data">Data</code></td>
<td>

<p>A multivariate data matrix.
</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_garchorder">garchOrder</code></td>
<td>

<p>The first stage common GARCH order.
</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_n.lags">n.lags</code></td>
<td>

<p>The number of lags to test for the presence of non-constant correlation.
</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_solver">solver</code></td>
<td>
<p> Either &ldquo;solnp&rdquo; or &ldquo;nlminb&rdquo; .</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="DCCtest_+3A_z">Z</code></td>
<td>

<p>(Optional) The standardized residuals from a constant correlation model. If 
supplied the model is not estimated since this is the only input the test
requires.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test effectively equates to estimating a multivariate dataset using the
Constant Conditional Correlation (CCC) model of Bollerslev (1990) and after 
which the standardized residuals (standardized by the symmetric square root 
decomposition of the estimated constant correlation matrix) should be i.i.d. 
with covariance the identity matrix. Testing for this can be done using a 
series of artificial regressions on the outer and lagged product of these 
residuals and a constant. In the rmgarch package, the CCC model is calculated
using a static GARCH copula (Normal) model.
</p>


<h3>Value</h3>

<p>A list with the proposed Null hypothesis (H0), the test statistic and its 
p-value.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Bollerslev, T. 1990, Modelling the coherence in short-run nominal exchange 
rates: a multivariate generalized ARCH model, <em>The Review of Economics and 
Statistics</em>, <b>72(3)</b>, 498&ndash;505.<br />
Engle, R.F. and Sheppard, K. 2001, Theoretical and empirical properties of 
dynamic conditional correlation multivariate GARCH, <em>NBER Working Paper</em>.<br />
</p>

<hr>
<h2 id='dji30retw'>data: Dow Jones 30 Constituents Closing Value log Weekly Return</h2><span id='topic+dji30retw'></span>

<h3>Description</h3>

<p>Dow Jones 30 Constituents closing value weekly (Friday) log returns from 
1987-03-16 to 2009-02-03 from Yahoo Finance. Note that AIG was replaced by KFT 
(Kraft Foods) on September 22, 2008. This is not reflected in this data set as 
that would bring the starting date of the data to 2001. When data was not 
available for a Friday, the closest previous close for which data was available 
was used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dji30retw)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 30x1141 observations.</p>


<h3>Source</h3>

<p>Yahoo Finance</p>

<hr>
<h2 id='fastica'>
Fast Fixed Point ICA
</h2><span id='topic+fastica'></span>

<h3>Description</h3>

<p>The fast fixed point algorithm for independent component analysis and projection 
pursuit based on the direct translation to R of the FastICA program of the 
original authors at the Helsinki University of Technology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastica(X, approach = c("symmetric", "deflation"), n.comp = dim(X)[2], demean = TRUE, 
pca.cov = c("ML", "LW", "ROB", "EWMA"), gfun = c("pow3", "tanh", "gauss", "skew"), 
finetune = c("none", "pow3", "tanh", "gauss", "skew"), tanh.par = 1, gauss.par = 1, 
step.size = 1, stabilization = FALSE, epsilon = 1e-4, maxiter1 = 1000, maxiter2 = 5, 
A.init = NULL, pct.sample = 1, firstEig = NULL, lastEig = NULL, 
pcaE = NULL, pcaD = NULL, whiteSig = NULL, whiteMat = NULL, dewhiteMat = NULL, 
rseed = NULL, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastica_+3A_x">X</code></td>
<td>
<p> The multidimensional signal matrix, where each column of matrix 
represents one observed signal.</p>
</td></tr>
<tr><td><code id="fastica_+3A_approach">approach</code></td>
<td>
<p> The decorrelation approach to use, with &ldquo;symmetric&rdquo; 
estimating the components in parallel while &ldquo;deflation&rdquo; estimating 
one-by-one as in projection pursuit.
</p>
</td></tr>
<tr><td><code id="fastica_+3A_n.comp">n.comp</code></td>
<td>
<p> Number of independent components to estimate, defaults to the 
dimension of the data (rows). Is overwritten by <code>firstEig</code> and <code>lastEig</code>.</p>
</td></tr>
<tr><td><code id="fastica_+3A_demean">demean</code></td>
<td>
<p> (Logical) Whether the data should be centered.</p>
</td></tr>
<tr><td><code id="fastica_+3A_pca.cov">pca.cov</code></td>
<td>
<p> The method to use for the calculation of the covariance matrix 
during the PCA whitening phase. &ldquo;ML&rdquo; is the standard maximum likelihood 
method, &ldquo;LW&rdquo; is the Ledoit and Wolf method, &ldquo;ROB&rdquo; is the robust method 
from the MASS package and &ldquo;EWMA&rdquo; an exponentially weighted moving average
estimator. Optional parameters passed via the (...) argument.
</p>
</td></tr>
<tr><td><code id="fastica_+3A_gfun">gfun</code></td>
<td>
<p> The nonlinearity algorithm to use in the fixed-point algorithm.</p>
</td></tr>
<tr><td><code id="fastica_+3A_finetune">finetune</code></td>
<td>
<p> The nonlinearity algorithm for fine-tuning.</p>
</td></tr>
<tr><td><code id="fastica_+3A_tanh.par">tanh.par</code></td>
<td>
<p> Control parameter used when nonlinearity algorithm 
equals &ldquo;tanh&rdquo;.</p>
</td></tr>
<tr><td><code id="fastica_+3A_gauss.par">gauss.par</code></td>
<td>
<p> Control parameter used when nonlinearity algorithm equals 
&ldquo;gauss&rdquo;.</p>
</td></tr>
<tr><td><code id="fastica_+3A_step.size">step.size</code></td>
<td>
<p> Step size. If this is anything other than 1, the program will 
use the stabilized version of the algorithm.</p>
</td></tr>
<tr><td><code id="fastica_+3A_stabilization">stabilization</code></td>
<td>
<p> Controls whether the program uses the stabilized version 
of the algorithm. If the stabilization is on, then the value of <code>step.size</code> 
can momentarily be halved if the program estimates that the algorithm is stuck 
between two points (this is called a stroke). Also if there is no convergence 
before half of the maximum number of iterations has been reached then the 
<code>step.size</code> will be halved for the rest of the rounds.
</p>
</td></tr>
<tr><td><code id="fastica_+3A_epsilon">epsilon</code></td>
<td>
<p> Stopping criterion. Default is 0.0001.</p>
</td></tr>
<tr><td><code id="fastica_+3A_maxiter1">maxiter1</code></td>
<td>
<p> Maximum number of iterations for <code>gfun</code> algorithm.</p>
</td></tr>
<tr><td><code id="fastica_+3A_maxiter2">maxiter2</code></td>
<td>
<p> Maximum number of iterations for <code>finetune</code> algorithm.</p>
</td></tr>
<tr><td><code id="fastica_+3A_a.init">A.init</code></td>
<td>
<p> Initial guess for the mixing matrix A. Defaults to a random 
(standard normal) filled matrix (no.signals by no.factors).</p>
</td></tr>
<tr><td><code id="fastica_+3A_pct.sample">pct.sample</code></td>
<td>
<p> Percentage [0-1] of samples used in one iteration. Samples are 
chosen at random.</p>
</td></tr>
<tr><td><code id="fastica_+3A_firsteig">firstEig</code></td>
<td>
<p> This and <code>lastEig</code> specify the range for eigenvalues 
that are retained, <code>firstEig</code> is the index of largest eigenvalue to be 
retained. Making use of this option overwrites <code>n.comp</code>.
</p>
</td></tr>
<tr><td><code id="fastica_+3A_lasteig">lastEig</code></td>
<td>
<p> This is the index of the last (smallest) eigenvalue to be 
retained and overwrites <code>n.comp</code> argument.</p>
</td></tr>
<tr><td><code id="fastica_+3A_pcae">pcaE</code></td>
<td>
<p> Optionally provided eigenvector (must also supply <code>pcaD</code>).</p>
</td></tr>
<tr><td><code id="fastica_+3A_pcad">pcaD</code></td>
<td>
<p> Optionally provided eigenvalues (must also supply <code>pcaE</code>).</p>
</td></tr>
<tr><td><code id="fastica_+3A_whitesig">whiteSig</code></td>
<td>
<p>Optionally provided Whitened signal.</p>
</td></tr>
<tr><td><code id="fastica_+3A_whitemat">whiteMat</code></td>
<td>
<p> Optionally provided Whitening matrix (no.factors by no.signals).</p>
</td></tr>
<tr><td><code id="fastica_+3A_dewhitemat">dewhiteMat</code></td>
<td>
<p>Optionally provided dewhitening matrix (no.signals by no.factors).</p>
</td></tr>
<tr><td><code id="fastica_+3A_rseed">rseed</code></td>
<td>
<p> Optionally provided seed to initialize the mixing matrix A 
(when <code>A.init</code> not provided).</p>
</td></tr>
<tr><td><code id="fastica_+3A_trace">trace</code></td>
<td>
<p>To report progress in the console, set this to &lsquo;TRUE&rsquo;.</p>
</td></tr>
<tr><td><code id="fastica_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the pca.cov methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fastica program is a direct translation into R of the FastICA Matlab program 
of Gaevert, Hurri, Saerelae, and Hyvaerinen with some extra features. All 
computations are currently implemented in R so for very large dimensional sets
alternative implementations may be faster. Porting part of the code to C++ may be
implemented in a future version.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>Estimated Mixing Matrix (no.signals by no.factors).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Estimated UnMixing Matrix (no.factors by no.signals). </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Estimated rotation Matrix (no.factors by no.factors). </p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The column vectors of estimated independent components (no.obs by no.factors).</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Estimated Covariance Matrix (no.signals by no.signals).</p>
</td></tr>
<tr><td><code>whiteningMatrix</code></td>
<td>
<p>The Whitening matrix (no.factors by no.signals).</p>
</td></tr>
<tr><td><code>dewhiteningMatrix</code></td>
<td>
<p>The de-Whitening matrix  (no.signals by no.factors).</p>
</td></tr>
<tr><td><code>rseed</code></td>
<td>
<p>The random seed used (if any) for initializing the mixing matrix A.</p>
</td></tr>
<tr><td><code>elapsed</code></td>
<td>
<p>The elapsed time.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Since version 1.0-3 the multidimensional signal matrix is now the usual row by 
column matrix, where the rows represent observations and columns the signals. 
Before this version, the reverse was true in keeping with the original version 
of the program.<br />
Dimensionality reduction can be achieved in the PCA stage by use of either 
<code>n.comp</code> in which case the n.comp largest eigenvalues are chosen, else by
selection of <code>firstEig</code> and <code>lastEig</code> which overwrites the choice of
<code>n.comp</code>.
</p>


<h3>Author(s)</h3>

<p>Hugo Gaevert, Jarmo Hurri, Jaakko Saerelae, and Aapo Hyvaerinen for the original 
FastICA package for matlab.<br /> 
Alexios Galanos for this R-port.
</p>


<h3>References</h3>

<p>Hyvaerinen, A. and Oja,.E , 1997, A fast fixed-point algorithm for independent 
component analysis, <em>Neural Computation</em>, <b>9(7)</b>, 1483-1492. Reprinted in 
<em>Unsupervised Learning</em>, G. Hinton and T. J. Sejnowski, 1999, MIT Press.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create a set of independent signals S, glued together by a mixing matrix A
# (note the notation and matrix multiplication direction as we are dealing with
# row rather than column vectors)
set.seed(100)
S &lt;- matrix(runif(10000), 5000, 2)
A &lt;- matrix(c(1, 1, -1, 2), 2, 2, byrow = TRUE)
# the mixed signal X
X = S %*% t(A)
# The function centers and whitens (by the eigenvalue decomposition of the 
# unconditional covariance matrix)  the data before applying the theICA algorithm.
IC &lt;- fastica(X, n.comp = 2, approach = "symmetric", gfun = "tanh", trace  = TRUE, 
A.init = diag(2))

# demeaned data:
X_bar = scale(X, scale = FALSE)

# whitened data:
X_white = X_bar %*% t(IC$whiteningMatrix)

# check whitening:
# check correlations are zero
cor(X_white)
# check diagonals are 1 in covariance
cov(X_white)

# check that the estimated signals(S) multiplied by the
# estimated mxing matrix (A) are the same as the original dataset (X)
round(head(IC$S %*% t(IC$A)), 12) == round(head(X), 12)

# do some plots:
par(mfrow = c(1, 3))
plot(IC$S %*% t(IC$A), main = "Pre-processed data")
plot(X_white, main = "Whitened and Centered components")
plot(IC$S, main = "ICA components")

## End(Not run)</code></pre>

<hr>
<h2 id='fMoments-class'>Class <code>"fMoments"</code></h2><span id='topic+fMoments-class'></span><span id='topic+show+2CfMoments-method'></span><span id='topic+fitted+2CfMoments-method'></span><span id='topic+rcov+2CfMoments-method'></span><span id='topic+rcoskew+2CfMoments-method'></span><span id='topic+rcokurt+2CfMoments-method'></span>

<h3>Description</h3>

<p>Object returned from calling <code><a href="#topic+fmoments">fmoments</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fMoments", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>moments</code>:</dt><dd><p>Object of class <code>"vector"</code> A list with the
(roll+1) n-ahead forecast moment matrices.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> A list with details of 
data generating process.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fMoments")</code>: Summary method. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "fMoments")</code>: Conditional mean 
forecast matrix. </p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "fMoments")</code>: Conditional covariance
forecast array.</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "fMoments")</code>: Conditional third 
co-moment array. </p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "fMoments")</code>: Conditional fourth
co-moment array. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("fMoments")
</code></pre>

<hr>
<h2 id='fmoments-methods'>Moment Based Forecast Generation</h2><span id='topic+fmoments'></span><span id='topic+fmoments-methods'></span><span id='topic+fmoments+2CANY-method'></span>

<h3>Description</h3>

<p>Generates n-ahead forecast moment matrices given a choice of data generating 
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmoments(spec, Data, n.ahead = 1, roll  = 0, solver = "solnp", 
solver.control = list(), fit.control = list(eval.se = FALSE), 
cluster = NULL, save.output = FALSE, save.dir = getwd(), 
save.name = paste("M", sample(1:1000, 1), sep = ""), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmoments-methods_+3A_data">Data</code></td>
<td>
<p> An n-by-m data matrix or data.frame.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_spec">spec</code></td>
<td>
<p> Either a DCCspec or GOGARCHspec.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_n.ahead">n.ahead</code></td>
<td>
<p> The n.ahead forecasts (n.ahead&gt;1 is unconditional).</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_roll">roll</code></td>
<td>
<p> Whether to fit the data using (n - roll) periods and then
return a (roll+1) n-ahead rolling forecast moments.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_solver">solver</code></td>
<td>
<p> The choice of solver to use for all models but &ldquo;var&rdquo;,
and includes &lsquo;solnp&rsquo;, &lsquo;nlminb&rsquo; and &lsquo;nloptr&rsquo;.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_solver.control">solver.control</code></td>
<td>
<p> Optional control options passed to the appropriate solver
chosen.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation of the refits (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_save.output">save.output</code></td>
<td>
<p> Whether output should be saved to file instead of being 
returned to the workspace.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_save.dir">save.dir</code></td>
<td>
<p> The directory to save output if save.output is TRUE.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_save.name">save.name</code></td>
<td>
<p> The name of the file to save the output list.</p>
</td></tr>
<tr><td><code id="fmoments-methods_+3A_...">...</code></td>
<td>
<p> Additional parameters passed to the model fitting routines. In 
particular, for the &lsquo;gogarch&rsquo; model additional parameters are passed to
the ICA routines, whereas for the &lsquo;dcc&rsquo; and &lsquo;cgarch&rsquo; models 
this would include the &lsquo;realizedVol&rsquo; xts matrix for the realGARCH model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to generate forecast covariance matrices for use in the
QP based EV model, and also for the &ldquo;gogarch&rdquo; model higher co-moment 
matrices for use in the Utility maximization model implemented separately.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+fMoments-class">fMoments</a></code> object containing the forecast moments 
(list of length roll+1) and the model details (list).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='fScenario-class'>Class <code>"fScenario"</code></h2><span id='topic+fScenario-class'></span><span id='topic+show+2CfScenario-method'></span><span id='topic+goget+2CfScenario-method'></span><span id='topic+goget+2CANY-method'></span><span id='topic+goget'></span><span id='topic+fitted+2CfScenario-method'></span>

<h3>Description</h3>

<p>Object returned from calling <code><a href="#topic+fscenario">fscenario</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("fScenario", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>scenario</code>:</dt><dd><p>Object of class <code>"vector"</code> A list with the
(roll+1) scenario matrices.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> A list with details of 
data generating process.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "fScenario")</code>: Summary method. </p>
</dd>
<dt>goget</dt><dd><p><code>signature(object = "fScenario")</code>:  Get a specified 
&lsquo;arg&rsquo; from the object (only &lsquo;scenario&rsquo; used).</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "fScenario")</code>: Returns an array
of the simulated scenario returns, of dimensions n.sim by n.assets 
by (roll+1), with third dimension labels the actual forecast time index,
and second dimension labels the asset names. The last forecast scenario
will always be completely out of sample so the time index label for that 
is generated using the <code>generatefwd</code> function in the rugarch package.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='fscenario-methods'>Scenario Generation</h2><span id='topic+fscenario'></span><span id='topic+fscenario-methods'></span><span id='topic+fscenario+2CANY-method'></span>

<h3>Description</h3>

<p>Generates a 1-ahead forecast scenario given a choice of data generating 
processes (for use in stochastic programming or risk management).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fscenario(Data, sim = 1000, roll = 0, 
	model = c("gogarch", "dcc", "cgarch", "var", "mdist"), 
	spec = NULL, 
	var.model = list(lag = 1, lag.max = NULL, 
				lag.criterion = c("AIC", "HQ", "SC", "FPE"), 
				robust = FALSE, robust.control = list("gamma" = 0.25, 
				"delta" = 0.01, "nc" = 10, "ns" = 500)),
	mdist.model = list(distribution = c("mvn", "mvt", "manig"), 
				AR = TRUE, lag = 1),
	spd.control = list(lower = 0.1, upper = 0.9, type = "pwm", 
				kernel = "epanech"),
	cov.method = c("ML", "LW", "EWMA", "MVE", "MCD", "MVT", "BS"),
	cov.options = list(shrinkage=-1, lambda = 0.96),
	solver = "solnp", solver.control = list(), 
	fit.control = list(eval.se = FALSE), 
	cluster = NULL, save.output = FALSE, save.dir = getwd(),
	save.name = paste("S", sample(1:1000, 1), sep = ""), rseed  = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fscenario-methods_+3A_data">Data</code></td>
<td>
<p> An n-by-m data matrix or data.frame.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_sim">sim</code></td>
<td>
<p> The size of the simulated 1-ahead forecast.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_roll">roll</code></td>
<td>
<p> Whether to fit the data using (n - roll) periods and then
return a (roll+1) 1-ahead rolling simulated scenarios.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_model">model</code></td>
<td>
<p> A choice of 5 models for generating scenarios.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_spec">spec</code></td>
<td>
<p> Required if choosing &lsquo;gogarch&rsquo;, &lsquo;dcc&rsquo; or &lsquo;cgarch&rsquo;, 
in which case this represents a specification object (see rmgarch package) .</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_var.model">var.model</code></td>
<td>
<p> Required if model is var.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_mdist.model">mdist.model</code></td>
<td>
<p> Required if model is mdist, and provides details for the model 
estimation (not yet implemented).</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_spd.control">spd.control</code></td>
<td>
<p> Required if model is &ldquo;cgarch&rdquo; and transformation is spd.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_cov.method">cov.method</code></td>
<td>
<p> For model &ldquo;var&rdquo; this represents the choice of 
covariance matrix to use to generate random deviates.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_cov.options">cov.options</code></td>
<td>
<p> For model &ldquo;var&rdquo; this provides the optional parameters
to certain types of covariance estimation methods.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_solver">solver</code></td>
<td>
<p> The choice of solver to use for all models but &ldquo;var&rdquo;,
and includes &lsquo;solnp&rsquo;, &lsquo;nlminb&rsquo; and &lsquo;nloptr&rsquo;.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_solver.control">solver.control</code></td>
<td>
<p> Optional control options passed to the appropriate solver
chosen.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation of the refits (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_save.output">save.output</code></td>
<td>
<p> Whether output should be saved to file instead of being 
returned to the workspace.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_save.dir">save.dir</code></td>
<td>
<p> The directory to save output if save.output is TRUE.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_save.name">save.name</code></td>
<td>
<p> The name of the file to save the output list.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_rseed">rseed</code></td>
<td>
<p> A vector of length sim to initiate the random number generator.</p>
</td></tr>
<tr><td><code id="fscenario-methods_+3A_...">...</code></td>
<td>
<p> Additional parameters passed to the model fitting routines. In 
particular, for the &lsquo;gogarch&rsquo; model additional parameters are passed to
the ICA routines, whereas for the &lsquo;dcc&rsquo; and &lsquo;cgarch&rsquo; models 
this would include the &lsquo;realizedVol&rsquo; xts matrix for the realGARCH model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functionality here provides some wrapper functions, to create 1-ahead (and 
optionally rolling, useful for backtesting) scenarios for use in portfolio 
optimization using stochastic programming methods. The nature of these
data generating processes (as implemented here) and resulting optimization 
problems results in the so called anticipative class of stochastic programming 
models. If save.output is chosen, and given a save.dir, the scenario is saved 
(using save.name) and an object is returned containing an empty list for the 
scenario but with a model details list and the seed values. This can then be 
passed on to the <code>goload</code> function which can read from the directory and 
return a complete object with the scenario.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+fScenario-class">fScenario</a></code> object containing the scenario and the model 
details (list). The scenario list contains a list of the
(roll+1) simulated forecast scenarios, the list of (roll+1) simulated forecast 
residuals, the forecast conditional mean, the forecast covariance and the list 
of random generator seed values used for replication. In addition, for the 
gogarch model the ICA whitening (K) and rotation matrices are also returned 
and required for replication of results (these may be entered in the 
&lsquo;gogarchspec&rsquo; function). Use the <code>fitted</code> method on the object to
extract the simulated returns forecast.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='goGARCHfft-class'>Class: GO-GARCH portfolio density</h2><span id='topic+goGARCHfft-class'></span><span id='topic+dfft+2CgoGARCHfft-method'></span><span id='topic+dfft'></span><span id='topic+pfft+2CgoGARCHfft-method'></span><span id='topic+pfft'></span><span id='topic+qfft+2CgoGARCHfft-method'></span><span id='topic+qfft'></span><span id='topic+nportmoments+2CgoGARCHfft-method'></span><span id='topic+nportmoments'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH portfolio density</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+convolution">convolution</a></code>  on 
objects of class <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code>, <code><a href="#topic+goGARCHfilter-class">goGARCHfilter</a></code>, 
<code><a href="#topic+goGARCHforecast-class">goGARCHforecast</a></code>, <code><a href="#topic+goGARCHsim-class">goGARCHsim</a></code> and
<code><a href="#topic+goGARCHroll-class">goGARCHroll</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>dist</code>:</dt><dd><p> A list with the portfolio density and other details.</p>
</dd>
<dt><code>model</code>:</dt><dd><p> A list with the model details carried across objects.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>dfft</dt><dd><p><code>signature(object = "goGARCHfft")</code>:
The takes additional argument &ldquo;index&rdquo; to indicate the particular time 
point, and returns an interpolated density function which may be called like 
any other &ldquo;d&rdquo; type density function.
</p>
</dd>
<dt>pfft</dt><dd><p><code>signature(object = "goGARCHfft")</code>
The takes additional argument &ldquo;index&rdquo; to indicate the particular time 
point, and returns an interpolated distribution function which may be called 
like any other &ldquo;p&rdquo; type distribution function.</p>
</dd>
<dt>qfft</dt><dd><p><code>signature(object = "goGARCHfft")</code> 
This takes additional argument &ldquo;index&rdquo; to indicate the particular time 
point, and returns an interpolated quantile function which may be called like 
any other &ldquo;q&rdquo; type quantile function. This may also be used to generate 
pseudo-random variables from the distribution by using random standard uniform 
numbers as inputs.</p>
</dd>
<dt>nportmoments</dt><dd><p><code>signature(object = "goGARCHfft")</code>:
Calculate and returns a matrix of the first 4 standardized moments by evaluation 
of the portfolio density using quadrature based method (i.e. calling R's 
&ldquo;integrate&rdquo; function on the portfolio FFT based density). Depending on
the GOGARCH class the density was based (e.g. goGARCHfit vs goGARCHforecast), 
the format of the output will be different, and generally follow the 
format &lsquo;rules&rsquo; of that class.</p>
</dd>
</dl>



<h3>notes</h3>

<p>In the case that <code>convolution</code> was called on a <code><a href="#topic+goGARCHforecast-class">goGARCHforecast</a></code>
or <code><a href="#topic+goGARCHroll-class">goGARCHroll</a></code> object, the <code>dist</code> slot will contain the max 
of n.ahead or n.roll. There should be no confusion here since the multivariate 
forecast methods in rmgarch only allow either n.ahead&gt;1 with n.roll = 0 
(pure unconditional), or n.ahead = 1 with n.roll&gt;=0 (pure rolling), and only the
latter in the case of a <code><a href="#topic+gogarchroll">gogarchroll</a></code>. While the <code>nportmoments</code> 
method reconstitutes the forecasts into a more familiar form (n.ahead x n.moments x 
(n.roll+1)), this does not make sense for the distribution methods (d*, p*, 
and q*), and it is understood that when the user calls for example 
<code>dfft(object, index=5)</code> on an object created from a forecast with 
n.ahead=10 and n.roll=0, the index is meant to indicate the unconditional 
density forecast at time T+5. Similarly, when calling 
codedfft(object, index=0) on an object created from a forecast with 
n.ahead=1 and n.roll = 1 (remember that n.roll is zero based), the index is 
meant to indicate the first (of two, since rolls = 0:1) rolling forecast 
density.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='goGARCHfilter-class'>class: GO-GARCH Filter Class</h2><span id='topic+goGARCHfilter-class'></span><span id='topic+as.matrix+2CgoGARCHfilter-method'></span><span id='topic+coef+2CgoGARCHfilter-method'></span><span id='topic+likelihood+2CgoGARCHfilter-method'></span><span id='topic+fitted+2CgoGARCHfilter-method'></span><span id='topic+residuals+2CgoGARCHfilter-method'></span><span id='topic+convolution+2CgoGARCHfilter-method'></span><span id='topic+gportmoments+2CgoGARCHfilter-method'></span><span id='topic+nisurface+2CgoGARCHfilter-method'></span><span id='topic+rcor+2CgoGARCHfilter-method'></span><span id='topic+rcoskew+2CgoGARCHfilter-method'></span><span id='topic+rcokurt+2CgoGARCHfilter-method'></span><span id='topic+rcov+2CgoGARCHfilter-method'></span><span id='topic+betacovar+2CgoGARCHfilter-method'></span><span id='topic+betacoskew+2CgoGARCHfilter-method'></span><span id='topic+betacokurt+2CgoGARCHfilter-method'></span><span id='topic+show+2CgoGARCHfilter-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH filtered object.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+gogarchfilter">gogarchfilter</a></code> and is
mainly called by <code><a href="#topic+gogarchfit">gogarchfit</a></code> when the &ldquo;out.sample&rdquo; option is
used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfilter</code>:</dt><dd><p>Multivariate filter object.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> containing details of
the GOGARCH model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfilter-class">mGARCHfilter</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfilter-class">GARCHfilter</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfilter&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>as.matrix</dt><dd><p><code>signature(x = "goGARCHfilter")</code>:<br />
function:<br />
<b>as.matrix(x, which = &quot;A&quot;)</b><br />
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are &ldquo;A&rdquo;
for the mixing matrix, &ldquo;W&rdquo; for the unmixing matrix, &ldquo;U&rdquo; for the
rotational matrix and &ldquo;K&rdquo; for the whitening matrix, &ldquo;Kinv&rdquo; for
the de-whitening matrix.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
The quasi log-likelihood of the model, which being an independent factor model
is the sum of the univariate GARCH log-likelihoods plus a term for the mixing
matrix. For a dimensionality reduced system, this is NA.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
Extraction of independent factor GARCH model coefficients.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
Extracts the conditional mean equation filtered values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
Extracts the conditional mean equation residuals.</p>
</dd>
<dt>convolution</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:<br />
function:<br />
<b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c(&quot;user&quot;, &quot;adaptive&quot;), use.ff = TRUE,
cluster = NULL, trace = 0,...)</b><br />
The convolution method takes a goGARCHfit object and a weights vector or
matrix and calculates the weighted density. If a vector is given, it must be
the same length as the number of assets, otherwise a matrix with row
dimension equal to the row dimension of the filtered dataset (i.e. less any
lags). In the case of the multivariate normal distribution, this simply
returns the linear and quadratic transformation of the mean and covariance
matrix, while in the multivariate affine NIG distribution this is based on
the numerical inversion by FFT of the characteristic function. In that case,
the &ldquo;fft.step&rdquo; option determines the stepsize for tuning the
characteristic function inversion, &ldquo;fft.by&rdquo; determines the resolution
for the equally spaced support given by &ldquo;fft.support&rdquo;, while the use
of the &ldquo;ff&rdquo; package is recommended to avoid memory problems on some
systems and is turned on via the &ldquo;use.ff&rdquo; option.
The &ldquo;support.method&rdquo; option allows either a fixed support range to be
given (option &lsquo;user&rsquo;), else an adaptive method is used based on the
min and max of the assets at each point in time at the 0.00001 and 1-0.00001
quantiles. The range is equally spaced subject to the &ldquo;fft.by&rdquo; value
but the returned object no longer makes of the &ldquo;ff&rdquo; package returning
instead a list. Finally, the option for parallel computation is available via
the use of a cluster object as elsewhere in this package.</p>
</dd>
<dt>nisurface</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:<br />
function:<br />
<b>nisurface(object, type = &quot;cov&quot;, pair = c(1, 2), factor = c(1,2),
plot = TRUE)</b><br />
Creates the covariance or correlation (determined by &ldquo;type&rdquo; being
either &ldquo;cov&rdquo; or &ldquo;cor&rdquo;) news impact surface for a pair of
assets and factors. Since the shocks impact the factors independently,
the news impact surface is a combination of the independent news impact
curves of the factors which when combined via the mixing matrix A, create
the dynamics for the underlying asset-factor surface function
</p>
</dd>
<dt>portmoments</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:<br />
function:<br />
<b>gportmoments(object, weights)</b><br />
Calculates the first 4 portfolio moments using the geometric properties of
the model, given a vector or matrix of asset weights. If a matrix is given
it must have row dimension equal to the row dimension of the filtered
dataset (i.e. less any lags), else if a vector is given it will be
replicated for all time points.</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "goGARCHfilter")</code>
function:<br />
<b>rcoskew(object, standardize = TRUE, from = 1, to = 1)</b><br />
Returns the 'time-varying'  NxN^2 coskewness tensor in array format.
The &ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for
which to return the arrays. Because of memory issues, this is limited to
100 indices per call.</p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "goGARCHfilter")</code>
function:<br />
<b>rcokurt(object, standardize = TRUE, from = 1, to = 1)</b><br />
Returns the 'time-varying'  NxN^3 cokurtosis tensor in array format. The
&ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to models
with less than 100 assets.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
Returns the time-varying NxN covariance matrix in array format.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
Returns the time-varying NxN correlation matrix in array format.
A further argument &lsquo;output&rsquo; allows to switch between &ldquo;array&rdquo;
and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>betacovar</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
function:<br />
<b>betacovar(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the covariance beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacoskew</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
function:<br />
<b>betacoskew(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the coskewness beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacokurt</dt><dd><p><code>signature(object = "goGARCHfilter")</code>:
function:<br />
<b>betacokurt(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the cokurtosis beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "goGARCHfilter")</code>: Summary method. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The reference by Paolella (2007) contains more details on the algorithm for the
characteristic function inversion via FFT. The application of this method in a
related model can be found in Chen (2007). The de Athayde and Flores (2002)
paper is the basis for the geometric properties of the higher moment tensors in
finance.<br />
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br />
Broda, S.A. and Paolella, M.S. 2009, CHICAGO: A Fast and Accurate Method for
Portfolio Risk Calculation, <em>Journal of Financial Econometrics</em> <b>7(4)</b>,
412&ndash;436 .<br />
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br />
Schmidt, R., Hrycej, T. and Stutzle 2006, Multivariate distribution models with
generalized hyperbolic margins, <em>Computational Statistics \&amp; Data Analysis</em>
<b>50(8)</b>, 2065-2096.<br />
</p>

<hr>
<h2 id='gogarchfilter-methods'>function: GO-GARCH Filter</h2><span id='topic+gogarchfilter'></span><span id='topic+gogarchfilter+2CANY-method'></span><span id='topic+gogarchfilter+2CgoGARCHfit-method'></span>

<h3>Description</h3>

<p>Method for filtering the GO-GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchfilter(fit, data, out.sample = 0, n.old = NULL, cluster = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchfilter-methods_+3A_fit">fit</code></td>
<td>

<p>A GO-GARCH fit object of class <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code>.</p>
</td></tr>
<tr><td><code id="gogarchfilter-methods_+3A_data">data</code></td>
<td>

<p>A multivariate data object. Can be a matrix or data.frame or timeSeries.</p>
</td></tr>
<tr><td><code id="gogarchfilter-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for 
out of sample forecasting.</p>
</td></tr>
<tr><td><code id="gogarchfilter-methods_+3A_n.old">n.old</code></td>
<td>

<p>For comparison with goGARCHfit models using the out.sample argument, this is the 
length of the original dataset.</p>
</td></tr>
<tr><td><code id="gogarchfilter-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="gogarchfilter-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+goGARCHfilter-class">goGARCHfilter</a></code> object containing details of the GO-GARCH 
filter.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = gogarchspec()
fit = gogarchfit(spec = spec, data = dji30ret[,1:4], gfun = "tanh")
filter = gogarchfilter(fit, data = dji30ret[,1:4])

## End(Not run)</code></pre>

<hr>
<h2 id='goGARCHfit-class'>class: GO-GARCH Fit Class</h2><span id='topic+goGARCHfit-class'></span><span id='topic+as.matrix+2CgoGARCHfit-method'></span><span id='topic+coef+2CgoGARCHfit-method'></span><span id='topic+convolution+2CgoGARCHfit-method'></span><span id='topic+convolution'></span><span id='topic+fitted+2CgoGARCHfit-method'></span><span id='topic+residuals+2CgoGARCHfit-method'></span><span id='topic+likelihood+2CgoGARCHfit-method'></span><span id='topic+nisurface+2CgoGARCHfit-method'></span><span id='topic+nisurface'></span><span id='topic+gportmoments+2CgoGARCHfit-method'></span><span id='topic+gportmoments'></span><span id='topic+rcor+2CgoGARCHfit-method'></span><span id='topic+rcor'></span><span id='topic+rcoskew+2CgoGARCHfit-method'></span><span id='topic+rcoskew'></span><span id='topic+rcokurt+2CgoGARCHfit-method'></span><span id='topic+rcokurt'></span><span id='topic+rcov+2CgoGARCHfit-method'></span><span id='topic+rcov'></span><span id='topic+betacovar'></span><span id='topic+betacovar+2CgoGARCHfit-method'></span><span id='topic+betacoskew'></span><span id='topic+betacoskew+2CgoGARCHfit-method'></span><span id='topic+betacokurt'></span><span id='topic+betacokurt+2CgoGARCHfit-method'></span><span id='topic+show+2CgoGARCHfit-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH fitted object.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+gogarchfit">gogarchfit</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mfit</code>:</dt><dd><p>Multivariate fit object.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> containing details of the
GO-GARCH model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHfit-class">mGARCHfit</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHfit-class">GARCHfit</a>"</code>, by class &quot;mGARCHfit&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHfit&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>as.matrix</dt><dd><p><code>signature(x = "goGARCHfit")</code>:
function:<br />
<b>as.matrix(x, which = &quot;A&quot;)</b><br />
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are &ldquo;A&rdquo;
for the mixing matrix, &ldquo;W&rdquo; for the unmixing matrix, &ldquo;U&rdquo; for the
rotational matrix and &ldquo;K&rdquo; for the whitening matrix, &ldquo;Kinv&rdquo; for
the de-whitening matrix.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "goGARCHfit")</code>:  extraction of independent
factor GARCH model coefficients.</p>
</dd>
<dt>convolution</dt><dd><p><code>signature(object = "goGARCHfit")</code>:<br />
function:<br />
<b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c(&quot;user&quot;, &quot;adaptive&quot;), use.ff = TRUE,
cluster = NULL, trace = 0,...)</b><br />
The convolution method takes a goGARCHfit object and a weights vector or
matrix and calculates the weighted density. If a vector is given, it must be
the same length as the number of assets, otherwise a matrix with row
dimension equal to the row dimension of the filtered dataset (i.e. less any
lags). In the case of the multivariate normal distribution, this simply
returns the linear and quadratic transformation of the mean and covariance
matrix, while in the multivariate affine NIG distribution this is based on
the numerical inversion by FFT of the characteristic function. In that case,
the &ldquo;fft.step&rdquo; option determines the stepsize for tuning the
characteristic function inversion, &ldquo;fft.by&rdquo; determines the resolution
for the equally spaced support given by &ldquo;fft.support&rdquo;, while the use
of the &ldquo;ff&rdquo; package is recommended to avoid memory problems on some
systems and is turned on via the &ldquo;use.ff&rdquo; option.
The &ldquo;support.method&rdquo; option allows either a fixed support range to be
given (option &lsquo;user&rsquo;), else an adaptive method is used based on the
min and max of the assets at each point in time at the 0.00001 and 1-0.00001
quantiles. The range is equally spaced subject to the &ldquo;fft.by&rdquo; value
but the returned object no longer makes of the &ldquo;ff&rdquo; package returning
instead a list. Finally, the option for parallel computation is available via
the use of a cluster object as elsewhere in this package.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
Extracts the conditional mean equation fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
Extracts the conditional mean equation residuals.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
The quasi log-likelihood of the model, which being an independent factor model
is the sum of the univariate GARCH log-likelihoods plus a term for the mixing
matrix. For a dimensionality reduced system, this is NA.</p>
</dd>
<dt>nisurface</dt><dd><p><code>signature(object = "goGARCHfit")</code>:<br />
function:<br />
<b>nisurface(object, type = &quot;cov&quot;, pair = c(1, 2), factor = c(1,2),
plot = TRUE)</b><br />
Creates the covariance or correlation (determined by &ldquo;type&rdquo; being
either &ldquo;cov&rdquo; or &ldquo;cor&rdquo;) news impact surface for a pair of
assets and factors. Since the shocks impact the factors independently,
the news impact surface is a combination of the independent news impact
curves of the factors which when combined via the mixing matrix A, create
the dynamics for the underlying asset-factor surface function.</p>
</dd>
<dt>gportmoments</dt><dd><p><code>signature(object = "goGARCHfit")</code>:<br />
function:<br />
<b>gportmoments(object, weights)</b><br />
Calculates the first 4 portfolio moments using the geometric properties of
the model, given a vector or matrix of asset weights. If a matrix is given
it must have row dimension equal to the row dimension of the filtered
dataset (i.e. less any lags), else if a vector is given it will be replicated
for all time points.</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "goGARCHfit")</code>
function:<br />
<b>rcoskew(object, standardize = TRUE, from = 1, to = 1)</b><br />
Returns the 'time-varying'  NxN^2 coskewness tensor in array format. The
&ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to 100
indices per call.</p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "goGARCHfit")</code>
function:<br />
<b>rcokurt(object, standardize = TRUE, from = 1, to = 1)</b><br />
Returns the 'time-varying'  NxN^3 cokurtosis tensor in array format. The
&ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to models
with less than 100 assets.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
Returns the time-varying NxN covariance matrix in array format unless
&lsquo;output&rsquo; is set to &ldquo;matrix&rdquo; in which case the array
is flattened and the lower and main diagonal time varying values are
returned (and if a date exists, then the returned object is of class xts).
</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
Returns the time-varying NxN correlation matrix in array format unless
&lsquo;output&rsquo; is set to &ldquo;matrix&rdquo; in which case the array
is flattened and the lower and main diagonal time varying values are
returned (and if a date exists, then the returned object is of class xts).
</p>
</dd>
<dt>betacovar</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
function:<br />
<b>betacovar(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the covariance beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacoskew</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
function:<br />
<b>betacoskew(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the coskewness beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>betacokurt</dt><dd><p><code>signature(object = "goGARCHfit")</code>:
function:<br />
<b>betacokurt(object, weights, asset = 1, cluster = NULL)</b><br />
Returns the cokurtosis beta given a matrix (of length equal to the number of
rows of the original data, or vector which is then recycled to the number
of rows of the original data) of benchmark weights and the asset number.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "goGARCHfit")</code>: Summary method.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The reference by Paolella (2007) contains more details on the algorithm for the
characteristic function inversion via FFT. The application of this method in a
related model can be found in Chen (2007). The de Athayde and Flores (2002)
paper is the basis for the geometric properties of the higher moment tensors in
finance.<br />
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br />
Broda, S.A. and Paolella, M.S. 2009, CHICAGO: A Fast and Accurate Method for
Portfolio Risk Calculation, <em>Journal of Financial Econometrics</em> <b>7(4)</b>,
412&ndash;436 .<br />
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br />
Schmidt, R., Hrycej, T. and Stutzle 2006, Multivariate distribution models with
generalized hyperbolic margins, <em>Computational Statistics \&amp; Data Analysis</em>
<b>50(8)</b>, 2065-2096.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = gogarchspec(mean.model = list(demean = "constant"),
variance.model = list(model = "sGARCH", garchOrder = c(1,1), submodel = NULL),
distribution.model = list(distribution = "manig"), ica = "fastica")
fit = gogarchfit(spec = spec, data  = dji30ret[,1:4, drop = FALSE],
out.sample = 50, gfun = "tanh")
# The likelihood of the model
likelihood(fit)
# the GARCH coefficients of the independent factors
coef(fit)
# a news-impact surface plot
#ni = nisurface(fit, type = "cov", pair = c(1, 2), factor = c(1,2), plot = TRUE)
# the time varying correlation array
mc = rcor(fit)
# plot(mc[1,2,], type = "l")
# The moments of an equally weighted portfolio (subtract the out.sample from dimension)
gm = gportmoments(fit, weights = matrix(1/4, ncol = 4,
nrow = dim(dji30ret)[1]-50), debug = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='gogarchfit-methods'>function: GO-GARCH Filter</h2><span id='topic+gogarchfit'></span><span id='topic+gogarchfit+2CANY-method'></span><span id='topic+gogarchfit+2CgoGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for filtering the GO-GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchfit(spec, data, out.sample = 0, solver = "solnp", 
fit.control = list(stationarity = 1), solver.control = list(), cluster = NULL, 
VAR.fit = NULL, ARcoef = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchfit-methods_+3A_spec">spec</code></td>
<td>

<p>A GO-GARCH spec object of class <code><a href="#topic+goGARCHspec-class">goGARCHspec</a></code>.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_data">data</code></td>
<td>

<p>A multivariate data object. Can be a matrix or data.frame or timeSeries.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for 
out of sample forecasting.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_solver">solver</code></td>
<td>

<p>One of either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo; or &ldquo;gosolnp&rdquo;. </p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control arguments passed to the fitting routine. Stationarity explicitly imposes 
the variance stationarity constraint during optimization.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_var.fit">VAR.fit</code></td>
<td>

<p>(optional) A previously estimated VAR list returned from calling the 
<code><a href="#topic+varxfilter">varxfilter</a></code> function.</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_arcoef">ARcoef</code></td>
<td>

<p>An optional named matrix of the fitted AR parameters obtained from calling the 
<code>arfimafit</code> function on each series and then extracting the coefficients 
(the normal distribution should be used for the AR estimation). The number of  
columns should be equal to the number of series, and the rows should include the 
AR coefficients (common lag for all series), &lsquo;sigma&rsquo;, and if included the 
mean (&lsquo;mu&rsquo;). The option to pass the coefficients directly rather than 
letting the function estimate them may be useful for example when there are
convergence problems in the arfima routine and user control of each series 
estimation is desirable.
</p>
</td></tr>
<tr><td><code id="gogarchfit-methods_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the ICA functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code> object containing details of the GO-GARCH fit.
</p>


<h3>Note</h3>

<p>There is no check on the VAR.fit list passed to the method so particular care 
should be exercised so that the same data used in the fitting routine is also 
used in the VAR filter routine. The ability to pass this list of the 
pre-calculated VAR model is particularly useful when comparing different models 
(such as copula GARCH, DCC GARCH etc) using the same dataset and VAR method. 
Though the classical VAR estimation is very fast and may not require this extra 
step, the robust method is slow and therefore benefits from calculating this 
only once.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = gogarchspec(mean.model = list(demean = "constant"), 
variance.model = list(model = "sGARCH", garchOrder = c(1,1), submodel = NULL), 
distribution.model = list(distribution = "manig"),ica = "fastica")

fit = gogarchfit(spec = spec, data  = dji30ret[,1:4, drop = FALSE], 
out.sample = 50, gfun = "tanh")
fit

## End(Not run)</code></pre>

<hr>
<h2 id='goGARCHforecast-class'>class: GO-GARCH Forecast Class</h2><span id='topic+goGARCHforecast-class'></span><span id='topic+coef+2CgoGARCHforecast-method'></span><span id='topic+fitted+2CgoGARCHforecast-method'></span><span id='topic+sigma+2CgoGARCHforecast-method'></span><span id='topic+as.matrix+2CgoGARCHforecast-method'></span><span id='topic+convolution+2CgoGARCHforecast-method'></span><span id='topic+gportmoments+2CgoGARCHforecast-method'></span><span id='topic+rcokurt+2CgoGARCHforecast-method'></span><span id='topic+rcor+2CgoGARCHforecast-method'></span><span id='topic+rcoskew+2CgoGARCHforecast-method'></span><span id='topic+rcov+2CgoGARCHforecast-method'></span><span id='topic+betacovar+2CgoGARCHforecast-method'></span><span id='topic+betacoskew+2CgoGARCHforecast-method'></span><span id='topic+betacokurt+2CgoGARCHforecast-method'></span><span id='topic+show+2CgoGARCHforecast-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH forecast.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+gogarchforecast">gogarchforecast</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mforecast</code>:</dt><dd><p>Multivariate forecast object.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> containing details of the
GOGARCH model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHforecast-class">mGARCHforecast</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHforecast-class">GARCHforecast</a>"</code>, by class &quot;mGARCHforecast&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHforecast&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>convolution</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:<br />
function:<br />
<b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c(&quot;user&quot;, &quot;adaptive&quot;),
use.ff = TRUE, cluster = NULL, trace = 0,...)</b><br />
The convolution method takes a goGARCHforecast object and a weights vector
or matrix and calculates the weighted density. If a vector is given, it must
be the same length as the number of assets, otherwise a matrix with
row dimension equal to the total forecast horizon.
In the case of the multivariate normal distribution, this simply returns the
linear and quadratic transformation of the mean and covariance matrix,
while in the multivariate affine NIG distribution this is based on the
numerical inversion by FFT of the characteristic function. In that case,
the &ldquo;fft.step&rdquo; option determines the stepsize for tuning the
characteristic function inversion, &ldquo;fft.by&rdquo; determines the resolution
for the equally spaced support given by &ldquo;fft.support&rdquo;, while the use
of the &ldquo;ff&rdquo; package is recommended to avoid memory problems on some
systems and is turned on via the &ldquo;use.ff&rdquo; option. The &ldquo;support.method&rdquo;
option allows either a fixed support range to be given (option &lsquo;user&rsquo;),
else an adaptive method is used based on the min and max of the assets at
each point in time at the 0.00001 and 1-0.00001 quantiles. The range is
equally spaced subject to the &ldquo;fft.by&rdquo; value but the returned object
no longer makes of the &ldquo;ff&rdquo; package returning instead a list.
The option for parallel computation is available via the use of a
cluster object as elsewhere in this package. There is no special treatment of
the forecast type here (unconditional or rolling), since either n.ahead with
no roll or rolling with 1-ahead only choices are available for the
<code>gogarchforecast</code> method. This means that the stored object does not
distringuish between an unconditional or rolling forecast, calculating the
density for all points (see note).
</p>
</dd>
<dt>gportmoments</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:<br />
function:<br />
<b>gportmoments(object, weights)</b><br />
Calculates the first 4 standardized portfolio moments using the geometric
properties of the model, given a matrix of asset weights with row dimension
equal to the forecast n.ahead or n.roll horizon. Returns an array of
dimensions n.ahead x 4 (moments) x n.roll, with the third array dimension
labelled with the T+0 index times. If the number of assets &gt; 100, then the
kurtosis is not returned (see cokurtosis restrictions below).</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:<br />
function:<br />
<b>rcoskew(object, standardize = TRUE, from = 1, to = 1, roll = 0)</b><br />
Returns the 'time-varying'  NxN^2 (coskewness tensor) x (to:from|roll) in
array format. The &ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time
indices for which to return the array and &ldquo;roll&rdquo; the rolling index
(base=0). The third dimension array label denotes the T+i (i=from:to)
forecast horizon given the T+0 roll index which is returned as an attribute
(attr(,&ldquo;T+0&rdquo;)) of the array. The &ldquo;standardize&rdquo; option
indicates whether the coskewness should be standardized by the
conditional sigma (see equations in vignette). It is also possible to set
roll to the character &lsquo;all&rsquo; in which case all the rolling 1-ahead
forecasts are returned in an n by n^2 by (n.roll+1) array with 3rd
dimension label the T+0 dates (instead of being an attribute).</p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:<br />
function:<br />
<b>rcokurt(object, standardize = TRUE, from = 1, to = 1, roll = 0)</b><br />
Returns the 'time-varying'  NxN^3 (cokurtosis tensor) x (to:from|roll) in
array format. The &ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time
indices for which to return the array and &ldquo;roll&rdquo; the rolling index
(base=0).  Because of memory issues, this is only returned when the number
of assets are less than 100. The third dimension array label denotes the
T+i (i=from:to) forecast horizon given the T+0 roll index which is returned
as an attribute (attr(,&ldquo;T+0&rdquo;)) of the array. The &ldquo;standardize&rdquo;
option indicates whether the cokurtosis should be standardized by the
conditional sigma (see equations in vignette). It is also possible to set
roll to the character &lsquo;all&rsquo; in which case all the rolling 1-ahead
forecasts are returned in an n by n^3 by (n.roll+1) array with 3rd
dimension label the T+0 dates (instead of being an attribute.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
Returns the conditional covariances, in a list of length (n.roll+1), with
names the T+0 index, and each list slot having an array of dimensions
n.asset x n.asset x n.ahead, with the third array dimension labelled
as T+i (i&gt;0). A further argument &lsquo;output&rsquo; allows to switch
between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
Returns the conditional correlations, in a list of length (n.roll+1), with
names the T+0 index, and each list slot having an array of dimensions
n.asset x n.asset x n.ahead, with the third array dimension labelled
as T+i (i&gt;0). A further argument &lsquo;output&rsquo; allows to switch
between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
Extraction of independent factor GARCH model coefficients saved from the
goGARCHfit object.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
Extracts the conditional mean forecast values. Returns an n.ahead
x n.assets x (n.roll+1) array where the third dimension array labels are the
T+0 index times.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
Extracts the conditional sigma forecast values. Returns an n.ahead
x n.assets x (n.roll+1) array where the third dimension array labels are the
T+0 index times. Takes optional argument &ldquo;factors&rdquo; (default TRUE)
denoting whether to return the factor conditional sigma or the transformed
sigma for the assets.</p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "goGARCHforecast")</code>:<br />
function:<br />
<b>as.matrix(x, which = &quot;A&quot;)</b><br />
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are &ldquo;A&rdquo;
for the mixing matrix, &ldquo;W&rdquo; for the unmixing matrix, &ldquo;U&rdquo; for the
rotational matrix and &ldquo;K&rdquo; for the whitening matrix, &ldquo;Kinv&rdquo; for
the de-whitening matrix.</p>
</dd>
<dt>betacovar</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
function:<br />
<b>betacovar(object, weights, asset = 1)</b><br />
Returns the covariance beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>betacoskew</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
function:<br />
<b>betacoskew(object, weights, asset = 1)</b><br />
Returns the coskewness beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>betacokurt</dt><dd><p><code>signature(object = "goGARCHforecast")</code>:
function:<br />
<b>betacokurt(object, weights, asset = 1)</b><br />
Returns the cokurtosis beta given a matrix (of length equal to the number of
rows of the forecast horizon, or vector which is then recycled to the number
of rows of the forecast horizon) of benchmark weights and the asset number.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "goGARCHforecast")</code>: Summary method. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The reference by Chen et al (2010) and Paolella (2007) contains more details on
the algorithm for the characteristic function inversion via FFT. The de Athayde
and Flores (2002) paper is the basis for some of the geometric properties of
the higher moment tensors. The paper by Ghalanos et al (2013) contains more
specific details.<br />
Forecasts are carried out on the time varying parameters of the factor
distributions, and then scaled and transformed to those of the assets after
adding back the mean forecast (which is either a constant or the AR/VAR mean
forecast).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Chen, Y., Hardle, W., and Spokoiny, V. 2010, GHICA-Risk analysis with GH
distributions and independent components, <em>Journal of Empirical Finance</em>,
<b>17(2)</b>, 255&ndash;269.<br />
de Athayde, G.M. and Flores Jr, R.G. 2002, On Certain Geometric Aspects of
Portfolio Optimisation with Higher Moments, <em>mimeo</em>.<br />
Ghalanos, A., Rossi, E., and Urga, G. (2013). <em>Independent Factor
Autoregressive Conditional Density Model</em>, <b>forthcoming</b>.<br />
Paolella, M.S. 2007, Intermediate Probability - A Computational Approach,
<em>Wiley-Interscience</em>.<br />
</p>

<hr>
<h2 id='gogarchforecast-methods'>function: GO-GARCH Forecast</h2><span id='topic+gogarchforecast'></span><span id='topic+gogarchforecast-methods'></span><span id='topic+gogarchforecast+2CANY-method'></span><span id='topic+gogarchforecast+2CgoGARCHfit-method'></span>

<h3>Description</h3>

<p>Method for forecasting from the GO-GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchforecast(fit, n.ahead = 10, n.roll = 0, 
external.forecasts = list(mregfor = NULL), cluster = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchforecast-methods_+3A_fit">fit</code></td>
<td>

<p>A GO-GARCH fit object of class <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code>.</p>
</td></tr>
<tr><td><code id="gogarchforecast-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon.</p>
</td></tr>
<tr><td><code id="gogarchforecast-methods_+3A_n.roll">n.roll</code></td>
<td>

<p>The no. of rolling forecasts to create beyond the first one.</p>
</td></tr>
<tr><td><code id="gogarchforecast-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>

<p>A list with a matrix object of the external lagged forecasts (if used). These 
must contain (n.roll+1) x n.ahead forecasts. </p>
</td></tr>
<tr><td><code id="gogarchforecast-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="gogarchforecast-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+goGARCHforecast-class">goGARCHforecast</a></code> object containing details of the GO-GARCH 
forecast.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = gogarchspec()
fit = gogarchfit(spec = spec, data = dji30ret[,1:4], out.sample = 10, 
gfun = "tanh")
forecast = gogarchforecast(fit, n.ahead = 1, n.roll = 9)

## End(Not run)</code></pre>

<hr>
<h2 id='goGARCHroll-class'>class: GO-GARCH Roll Class</h2><span id='topic+goGARCHroll-class'></span><span id='topic+fitted+2CgoGARCHroll-method'></span><span id='topic+sigma+2CgoGARCHroll-method'></span><span id='topic+rcor+2CgoGARCHroll-method'></span><span id='topic+rcov+2CgoGARCHroll-method'></span><span id='topic+rcoskew+2CgoGARCHroll-method'></span><span id='topic+rcokurt+2CgoGARCHroll-method'></span><span id='topic+convolution+2CgoGARCHroll-method'></span><span id='topic+gportmoments+2CgoGARCHroll-method'></span><span id='topic+coef+2CgoGARCHroll-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH Roll.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+gogarchroll">gogarchroll</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>forecast</code>:</dt><dd><p>Object of class <code>"vector"</code> which contains the
rolling forecasts of the distributional parameters for each factor.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> containing details of the
GOGARCH model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHroll-class">mGARCHroll</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHroll-class">GARCHroll</a>"</code>, by class &quot;mGARCHroll&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHroll&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Extraction of independent factor GARCH model coefficients saved from the
goGARCHfit objects(returns a list).</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Extracts the conditional fitted forecast values (returns an xts object with
index the actual forecast T+1 times).</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Extracts the conditional sigma forecast values (returns an xts object with
index the actual forecast T+1 times). Takes optional argument &ldquo;factors&rdquo;
(default TRUE) denoting whether to return the factor conditional sigma or
the transformed sigma for the assets.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset x (n.roll+1) covariance matrix in
array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). A further argument &lsquo;output&rsquo; allows
to switch between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset x (n.roll+1) correlation matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). A further argument &lsquo;output&rsquo;
allows to switch between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset^2 x (n.roll+1) coskewness matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). There is a &ldquo;standardize&rdquo;
option which indicates whether the coskewness should be standardized by the
conditional sigma (see equations in vignette).</p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "goGARCHroll")</code>:
Returns the time-varying n.asset x n.asset^3 x (n.roll+1) cokurtosis matrix
in array format, where the third dimension labels are now the actual rolling
n.ahead=1 forecast time indices (T+1). There is a &ldquo;standardize&rdquo;
option which indicates whether the cokurtosis should be standardized by the
conditional sigma (see equations in vignette).</p>
</dd>
<dt>gportmoments</dt><dd><p><code>signature(object = "goGARCHroll")</code>:<br />
function:<br />
<b>gportmoments(object, weights)</b><br />
Calculates the first 4 standardized portfolio moments using the geometric
properties of the model, given a matrix of asset weights with row dimension
equal to the total rolling forecast horizon. Returns an xts object of
dimensions (total rolling forecast) x 4 (moments), with the index denoting
the T+1 actual forecast time. If the number of assets &gt; 100, then the
kurtosis is not returned (see cokurtosis restrictions below).</p>
</dd>
<dt>convolution</dt><dd><p><code>signature(object = "goGARCHroll")</code>:<br />
function:<br />
<b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c(&quot;user&quot;, &quot;adaptive&quot;),
use.ff = TRUE, cluster = NULL, trace = 0,...)</b><br />
The convolution method takes a goGARCHroll object and a weights vector or
matrix and calculates the weighted density. If a vector is given, it must be
the same length as the number of assets, otherwise a matrix with
row dimension equal to the row dimension of total forecast horizon.
In the case of the multivariate normal distribution, this simply returns the
linear and quadratic transformation of the mean and covariance matrix, while
in the multivariate affine NIG distribution this is based on the numerical
inversion by FFT of the characteristic function. In that case, the
&ldquo;fft.step&rdquo; option determines the stepsize for tuning the
characteristic function inversion, &ldquo;fft.by&rdquo; determines the resolution
for the equally spaced support given by &ldquo;fft.support&rdquo;, while the use
of the &ldquo;ff&rdquo; package is recommended to avoid memory problems on some
systems and is turned on via the &ldquo;use.ff&rdquo; option.
The &ldquo;support.method&rdquo; option allows either a fixed support range to be
given (option &lsquo;user&rsquo;), else an adaptive method is used based on the
min and max of the assets at each point in time at the 0.00001 and 1-0.00001
quantiles. The range is equally spaced subject to the &ldquo;fft.by&rdquo; value
but the returned object no longer makes of the &ldquo;ff&rdquo; package returning
instead a list. The option for parallel computation is available
via the use of a cluster object as elsewhere in this package. Passing this
object to the distribution methods (e.g. qfft) follows the same rules as
the goGARCHforecast object, namely that the index is zero based.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "goGARCHroll")</code>: Summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='gogarchroll-methods'>function: GO-GARCH Rolling Estimation</h2><span id='topic+gogarchroll'></span><span id='topic+gogarchroll+2CANY-method'></span><span id='topic+gogarchroll+2CgoGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for performing rolling estimation of the GO-GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchroll(spec, data, n.ahead = 1, forecast.length = 50, n.start = NULL, 
refit.every = 25, refit.window = c("recursive", "moving"), window.size = NULL, 
solver = "solnp", solver.control = list(), fit.control = list(), rseed = NULL,  
cluster = NULL, save.fit = FALSE, save.wdir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchroll-methods_+3A_spec">spec</code></td>
<td>

<p>A GO-GARCH spec object of class <code><a href="#topic+goGARCHspec-class">goGARCHspec</a></code>.</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_data">data</code></td>
<td>

<p>A multivariate data object. Can be a matrix or data.frame or timeSeries. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon (only 1-ahead supported for rolling forecasts). </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_forecast.length">forecast.length</code></td>
<td>

<p>The length of the total forecast for which out of sample data from the dataset 
will be excluded for testing. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_n.start">n.start</code></td>
<td>
<p> Instead of forecast.length, this determines the starting 
point in the dataset from which to initialize the rolling forecast.</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_refit.every">refit.every</code></td>
<td>

<p>Determines every how many periods the model is re-estimated. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_refit.window">refit.window</code></td>
<td>

<p>Whether the refit is done on an expanding window including all the previous data 
or a moving window where all previous data is used for the first estimation 
and then moved by a length equal to refit.every (unless the window.size option 
is used instead).
</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_window.size">window.size</code></td>
<td>

<p>If not NULL, determines the size of the moving window in the rolling estimation,
which also determines the first point used.
</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_solver">solver</code></td>
<td>

<p>The solver to use. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control parameters parameters passed to the fitting function. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control parameters passed to the solver. </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_rseed">rseed</code></td>
<td>

<p>Initialization seed for first ICA fit. The rest of the ICA fits are initialized 
with the previous mixing matrix (using A.init). </p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_save.fit">save.fit</code></td>
<td>

<p>Whether to save the fitted objects of class <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code> 
during the estimation of each (&ldquo;refit.every&rdquo;). If true, the directory to 
save must be provided (see below). The function will not save this by default 
for reasons of memory management, but can save it as an &ldquo;.rda&rdquo; file in 
the user's chosen directory for further analysis.</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_save.wdir">save.wdir</code></td>
<td>

<p>If &ldquo;save.fit&rdquo; is true, the directory in which to save the 
<code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code> objects (1 for each &ldquo;refit.every&rdquo;).</p>
</td></tr>
<tr><td><code id="gogarchroll-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+goGARCHroll-class">goGARCHroll</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='goGARCHsim-class'>class: GO-GARCH Simultion Class</h2><span id='topic+goGARCHsim-class'></span><span id='topic+convolution+2CgoGARCHsim-method'></span><span id='topic+gportmoments+2CgoGARCHsim-method'></span><span id='topic+rcor+2CgoGARCHsim-method'></span><span id='topic+rcoskew+2CgoGARCHsim-method'></span><span id='topic+rcokurt+2CgoGARCHsim-method'></span><span id='topic+rcov+2CgoGARCHsim-method'></span><span id='topic+as.matrix+2CgoGARCHsim-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH Simulation.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+gogarchsim">gogarchsim</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>msim</code>:</dt><dd><p>Object of class <code>"vector"</code> The multivariate
simulation list.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> containing details of the
GOGARCH model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHsim-class">mGARCHsim</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHsim-class">GARCHsim</a>"</code>, by class &quot;mGARCHsim&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHsim&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>convolution</dt><dd><p><code>signature(object = "goGARCHsim")</code>:<br />
function:<br />
<b>convolution(object, weights, fft.step = 0.001, fft.by = 0.0001,
fft.support = c(-1, 1), support.method = c(&quot;user&quot;, &quot;adaptive&quot;),
use.ff = TRUE, sim = 1, cluster = NULL, trace = 0,...)</b><br />
The convolution method takes a goGARCHsim object and a weights vector and
calculates the weighted density. The vector must be the same length as the
number of assets.
The &ldquo;sim&rdquo; option indicates the simulation index to  use, given
the &ldquo;m.sim&rdquo; option chosen in the call to the simulation function.
In the case of the multivariate normal distribution, this simply returns the
linear and quadratic transformation of the mean and covariance matrix,
while in the multivariate affine NIG distribution this is based on the
numerical inversion by FFT of the characteristic function. In that case,
the &ldquo;fft.step&rdquo; option determines the stepsize for tuning the
characteristic function inversion, &ldquo;fft.by&rdquo; determines the resolution
for the equally spaced support given by &ldquo;fft.support&rdquo;, while the use
of the &ldquo;ff&rdquo; package is recommended to avoid memory problems on some
systems and is turned on via the &ldquo;use.ff&rdquo; option. The &ldquo;support.method&rdquo;
option allows either a fixed support range to be given (option &lsquo;user&rsquo;),
else an adaptive method is used based on the min and max of the assets at
each point in time at the 0.00001 and 1-0.00001 quantiles. The range is
equally spaced subject to the &ldquo;fft.by&rdquo; value but the returned object no
longer makes use of the &ldquo;ff&rdquo; package returning instead a list.
Finally, the option for parallel computation is available via the use of a
cluster object as elsewhere in this package.</p>
</dd>
<dt>gportmoments</dt><dd><p><code>signature(object = "goGARCHsim")</code>:<br />
function:<br />
<b>gportmoments(object, weights, sim = 1)</b><br />
Calculates the first 3 portfolio moments using the geometric properties of
the model, given a matrix of asset weights with row dimension equal to the
row dimension of the filtered dataset (i.e. less any lags).
The &ldquo;sim&rdquo; option indicates the simulation index to use,
given the &ldquo;m.sim&rdquo; option chosen in the call to the simulation function.
</p>
</dd>
<dt>rcoskew</dt><dd><p><code>signature(object = "goGARCHsim")</code>:<br />
function:<br />
<b>rcoskew(object, from = 1, to = 1, sim = 1)</b><br />
Returns the 'time-varying'  NxN^2 coskewness tensor in array format.
The &ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for
which to return the arrays. Because of memory issues, this is limited to 100
indices.  The &ldquo;sim&rdquo; option indicates the simulation index to use,
given the &ldquo;m.sim&rdquo; option chosen in the call to the simulation
function.</p>
</dd>
<dt>rcokurt</dt><dd><p><code>signature(object = "goGARCHsim")</code>:<br />
function:<br />
<b>rcokurt(object, standardize = TRUE, from = 1, to = 1)</b><br />
Returns the 'time-varying'  NxN^3 cokurtosis tensor in array format. The
&ldquo;from&rdquo; and &ldquo;to&rdquo; options indicate the time indices for which
to return the arrays. Because of memory issues, this is limited to models
with less than 20 assets.</p>
</dd>
<dt>rcov</dt><dd><p><code>signature(object = "goGARCHsim")</code>:
Returns the time-varying NxN covariance matrix in array format.  There is an
additional &ldquo;sim&rdquo; option which indicates the simulation index to
use, given the &ldquo;m.sim&rdquo; option chosen in the call to the simulation
function. A further argument &lsquo;output&rsquo; allows to switch between
&ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>rcor</dt><dd><p><code>signature(object = "goGARCHsim")</code>:
Returns the time-varying NxN correlation matrix in array format.
There is an additional &ldquo;sim&rdquo; option which indicates the simulation
index to use, given the &ldquo;m.sim&rdquo; option chosen in the call to the
simulation function. A further argument &lsquo;output&rsquo; allows to switch
between &ldquo;array&rdquo; and &ldquo;matrix&rdquo; returned object.</p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "goGARCHsim")</code>:<br />
function:<br />
<b>as.matrix(x, which = &quot;A&quot;)</b><br />
This returns four types of matrices relating to the estimation of the
independent components in the GO-GARCH model. Valid choices are &ldquo;A&rdquo;
for the mixing matrix, &ldquo;W&rdquo; for the unmixing matrix, &ldquo;U&rdquo; for the
rotational matrix and &ldquo;K&rdquo; for the whitening matrix, &ldquo;Kinv&rdquo; for
the de-whitening matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='gogarchsim-methods'>function: GO-GARCH Simulation</h2><span id='topic+gogarchsim'></span><span id='topic+gogarchsim+2CANY-method'></span><span id='topic+gogarchsim+2CgoGARCHfit-method'></span><span id='topic+gogarchsim+2CgoGARCHfilter-method'></span>

<h3>Description</h3>

<p>Method for simulation from a fitted GO-GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchsim(object, n.sim = 1, n.start = 0, m.sim = 1,
startMethod = c("unconditional", "sample"), prereturns = NA, preresiduals = NA,
presigma = NA, mexsimdata = NULL, rseed = NULL, cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchsim-methods_+3A_object">object</code></td>
<td>

<p>A GO-GARCH fit object of class <code><a href="#topic+goGARCHfit-class">goGARCHfit</a></code> or <code><a href="#topic+goGARCHfilter-class">goGARCHfilter</a></code>.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_n.sim">n.sim</code></td>
<td>

<p>The simulation horizon.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_n.start">n.start</code></td>
<td>

<p>The burn-in sample.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_m.sim">m.sim</code></td>
<td>

<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_startmethod">startMethod</code></td>
<td>

<p>Starting values for the simulation. Valid methods are &ldquo;unconditional&rdquo;
for the  expected values given the density, and &ldquo;sample&rdquo; for the
ending values of the actual data from the fit object.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_prereturns">prereturns</code></td>
<td>

<p>Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_preresiduals">preresiduals</code></td>
<td>

<p>Allows the starting factor residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_presigma">presigma</code></td>
<td>

<p>Allows the starting conditional factor sigma to be provided by the user.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>A list of matrices with the simulated lagged external variables (if any). The
list should be of size m.sim and the matrices each have n.sim + n.start rows.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_rseed">rseed</code></td>
<td>

<p>Optional seeding value(s) for the random number generator.</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from
the parallel package. If it is not NULL, then this will be used for parallel
estimation (remember to stop the cluster on completion).</p>
</td></tr>
<tr><td><code id="gogarchsim-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+goGARCHsim-class">goGARCHsim</a></code> object containing details of the GO-GARCH
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='goGARCHspec-class'>class: GO-GARCH Specification Class</h2><span id='topic+goGARCHspec-class'></span><span id='topic+show+2CgoGARCHspec-method'></span>

<h3>Description</h3>

<p>Class for the GO-GARCH specification.</p>


<h3>Objects from the Class</h3>

<p>The class is returned by calling the function <code><a href="#topic+goGARCHspec-class">goGARCHspec</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p> Multivariate model specification.</p>
</dd>
<dt><code>umodel</code>:</dt><dd><p> Univariate model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mGARCHspec-class">mGARCHspec</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+GARCHspec-class">GARCHspec</a>"</code>, by class &quot;mGARCHspec&quot;, distance 2.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;mGARCHspec&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "goGARCHspec")</code>: Summary method. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The mixing matrix in the GO-GARCH model implemented in the rmgarch package is 
based on non-parametric independent component analysis (ICA) methodology. 
The estimation is a 2-stage methodology described in Broda and Paolella (2009) 
and Zhang and Chan (2009). The extension to the use of the full multivariate
affine GH distribution is detailed in Ghalanos et al (2011).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>van der Weide, R. 2002, GO-GARCH: a multivariate generalized orthogonal GARCH 
model, <em>Journal of Applied Econometrics</em>,  549&ndash;564.<br />
Zhang, K. and Chan, L. 2009, Efficient factor GARCH models and factor-DCC models, 
<em>Quantitative Finance</em>, 71&ndash;91.<br />
Broda, S.A. and Paolella, M.S. 2009, CHICAGO: A Fast and Accurate Method for 
Portfolio Risk Calculation, <em>Journal of Financial Econometrics</em>, 412&ndash;436.<br />
Ghalanos, A. and Rossi, E. and Urga, G. 2011, Independent Factor Autoregressive 
Conditional Density Model, <em>Pending&ndash;submitted</em>.
</p>

<hr>
<h2 id='gogarchspec-methods'>function: GO-GARCH Specification</h2><span id='topic+gogarchspec'></span><span id='topic+gogarchspec-methods'></span><span id='topic+gogarchspec+2CANY-method'></span>

<h3>Description</h3>

<p>Method for creating a GO-GARCH specification object prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gogarchspec(mean.model = list(model = c("constant", "AR", "VAR"), robust = FALSE, 
lag = 1, lag.max = NULL, lag.criterion = c("AIC", "HQ", "SC", "FPE"), 
external.regressors = NULL, 
robust.control = list("gamma" = 0.25, "delta" = 0.01, "nc" = 10, "ns" = 500)), 
variance.model = list(model = "sGARCH", garchOrder = c(1,1), submodel = NULL, 
variance.targeting = FALSE), distribution.model = c("mvnorm", "manig", "magh"), 
ica = c("fastica", "radical"), 
ica.fix = list(A = NULL, K = NULL), ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gogarchspec-methods_+3A_mean.model">mean.model</code></td>
<td>

<p>The mean specification. Allows for either a constant filtration of the return 
series, a univariate AR for each series with common lag (via the &ldquo;lag&rdquo; 
argument) else a classical or robust Vector Autoregressive Model (VAR). The 
&lsquo;robust&rsquo; option allows for a robust version of  VAR based on the 
multivariate Least Trimmed Squares Estimator  described in Croux and 
Joossens (2008). The &lsquo;robust.control&rsquo; includes additional tuning 
parameters to the robust regression including the proportion to 
trim (&ldquo;gamma&rdquo;), the critical value for Reweighted estimator (&ldquo;delta&rdquo;), 
the number of subsets (&ldquo;ns&rdquo;) and the number of C-steps (&ldquo;nc&rdquo;).
The  external.regressors argument allows for a matrix of common external 
regressors in the constant, AR or VAR formulations.
</p>
</td></tr>
<tr><td><code id="gogarchspec-methods_+3A_variance.model">variance.model</code></td>
<td>

<p>The univariate variance specification for the independent factors of the 
GO-GARCH model.
</p>
</td></tr>
<tr><td><code id="gogarchspec-methods_+3A_distribution.model">distribution.model</code></td>
<td>

<p>The distributions supported are the multivariate normal (&ldquo;mvnorm&rdquo;) and 
the multivariate affine NIG (&ldquo;manig&rdquo;) and GHYP (&ldquo;magh&rdquo;) 
distributions of Schmidt et al (see references).
</p>
</td></tr>
<tr><td><code id="gogarchspec-methods_+3A_ica">ica</code></td>
<td>

<p>The algorithm to use for extracting the independent components. 
The <code><a href="#topic+fastica">fastica</a></code> and <code><a href="#topic+radical">radical</a></code> algorithms are the only
ICA algorithms currently allowed and locally implemented. See their 
documentation for a list of additional arguments possible, which may be passed
in the <code><a href="#topic+gogarchfit">gogarchfit</a></code> method.
</p>
</td></tr>
<tr><td><code id="gogarchspec-methods_+3A_ica.fix">ica.fix</code></td>
<td>

<p>This allows the option of supplying the mixing matrix (A) and optionally the 
whitening Matrix (K). This is likely to be use when comparing different models 
(with the same mean filtration and dataset but different variance models) and 
you wish to use the same independent factors.
</p>
</td></tr>
<tr><td><code id="gogarchspec-methods_+3A_...">...</code></td>
<td>
<p>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+goGARCHspec-class">goGARCHspec</a></code> object containing details of the GO-GARCH 
specification.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='goload-methods'>Load Scenario from File</h2><span id='topic+goload'></span><span id='topic+goload-methods'></span><span id='topic+goload+2CANY-method'></span><span id='topic+goload+2CfScenario-method'></span><span id='topic+goload+2CfMoments-method'></span>

<h3>Description</h3>

<p>Loads a previously saved fScenario from file and returns
a <code><a href="#topic+fScenario-class">fScenario</a></code> or <code><a href="#topic+fMoments-class">fMoments</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goload(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="goload-methods_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+fScenario-class">fScenario</a></code> or <code><a href="#topic+fMoments-class">fMoments</a></code> 
object which was created with save.output set to TRUE.</p>
</td></tr>
<tr><td><code id="goload-methods_+3A_...">...</code></td>
<td>
<p> not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are times when it is more efficient to save large scenarios to file 
(particularly when creating them in parallel), rather than returning them to the
user workspace. The save.output option in the <code><a href="#topic+fscenario">fscenario</a></code> and 
<code><a href="#topic+fmoments">fmoments</a></code> allows to do just that, returning instead a lighter 
object with an empty scenario slot, but with the model slot included, containing 
the details of the location and name of the saved scenario (or moments list). 
The goload function then takes this object, reads the location and name and 
loads the scenario (or moments) into its slot in the object and returns 
this to the user's workspace.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+fScenario-class">fScenario</a></code> or <code><a href="#topic+fMoments-class">fMoments</a></code> object with 
the scenario or moments slot now filled with the saved data from file.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='last-methods'>First and Last methods for accessing objects</h2><span id='topic+last-methods'></span><span id='topic+last+2CANY-method'></span><span id='topic+last+2Carray-method'></span><span id='topic+first-methods'></span><span id='topic+first+2CANY-method'></span><span id='topic+first+2Carray-method'></span><span id='topic+first'></span><span id='topic+last'></span>

<h3>Description</h3>

<p>Functions for accessing first-n and last-n values of an object 
(similar to head and tail).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last(x, index = 1, ...)
first(x, index = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="last-methods_+3A_x">x</code></td>
<td>
<p> Currently only arrays supported.</p>
</td></tr>
<tr><td><code id="last-methods_+3A_index">index</code></td>
<td>
<p> First or Last n-indices to return values for.</p>
</td></tr>
<tr><td><code id="last-methods_+3A_...">...</code></td>
<td>
<p> For expansion to other classes.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "array")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHfilter-class'>Class: Multivariate GARCH Filter Class</h2><span id='topic+mGARCHfilter-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH filter class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHfilter-class">GARCHfilter</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHfilter&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHfilter&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHfit-class'>Class: Multivariate GARCH Fit Class</h2><span id='topic+mGARCHfit-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH fit class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHfit-class">GARCHfit</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHfit&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHfit&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHforecast-class'>Class: Multivariate GARCH Forecast Class</h2><span id='topic+mGARCHforecast-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH forecast class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHforecast-class">GARCHforecast</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHforecast&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHforecast&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHroll-class'>Class: Multivariate GARCH Roll Class</h2><span id='topic+mGARCHroll-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH roll class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHroll-class">GARCHroll</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHroll&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHroll&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHsim-class'>Class: Multivariate GARCH Simulation Class</h2><span id='topic+mGARCHsim-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH simulation class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHsim-class">GARCHsim</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHsim&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHsim&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='mGARCHspec-class'>Class: Multivariate GARCH Specification</h2><span id='topic+mGARCHspec-class'></span>

<h3>Description</h3>

<p>High Level multivariate GARCH specification class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from 
it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="rugarch.html#topic+GARCHspec-class">GARCHspec</a>"</code>, directly.
Class <code>"<a href="rugarch.html#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHspec&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;mGARCHspec&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

<hr>
<h2 id='radical'>
The Robust Accurate, Direct ICA aLgorithm (RADICAL).
</h2><span id='topic+radical'></span>

<h3>Description</h3>

<p>An ICA algorithm based on an efficient entropy estimator (due to Vasicek) which 
is robust to outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radical(X, n.comp = dim(X)[2], demean = TRUE, pca.cov = c("ML", "LW", "ROB", "EWMA"), 
k = 150, augment = FALSE, replications = 30, sd = 0.175, firstEig = 1, 
lastEig = dim(X)[1], pcaE = NULL, pcaD = NULL, whiteSig = NULL, whiteMat = NULL, 
dewhiteMat = NULL, rseed = NULL, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="radical_+3A_x">X</code></td>
<td>
<p> The multidimensional signal matrix, where each column of matrix represents 
one observed signal.</p>
</td></tr>
<tr><td><code id="radical_+3A_n.comp">n.comp</code></td>
<td>
<p> Number of independent components to estimate, defaults to the 
dimension of the data (rows). Is overwritten by <code>firstEig</code> and <code>lastEig</code>.</p>
</td></tr>
<tr><td><code id="radical_+3A_demean">demean</code></td>
<td>
<p> (Logical) Whether the data should be centered.</p>
</td></tr>
<tr><td><code id="radical_+3A_pca.cov">pca.cov</code></td>
<td>

<p>The method to use for the calculation of the covariance matrix during the
PCA whitening phase. &ldquo;ML&rdquo; is the standard maximum likelihood method,
&ldquo;LW&rdquo; is the Ledoit-Wolf method, &ldquo;ROB&rdquo; is the robust method from
the MASS package and &ldquo;EWMA&rdquo; an exponentially weighted moving average
estimator. Optional parameters passed via the ... argument.
</p>
</td></tr>
<tr><td><code id="radical_+3A_k">k</code></td>
<td>
<p> The number of angles at which to evaluate the contrast function. The 
ICA contrast function will be evaluated at K evenly spaced rotations from -Pi/4 
to Pi/4
</p>
</td></tr>
<tr><td><code id="radical_+3A_augment">augment</code></td>
<td>
<p> Whether to augment the data (as explained in paper). For large 
datasets of &gt;10,000 points this should be set to FALSE.</p>
</td></tr>
<tr><td><code id="radical_+3A_replications">replications</code></td>
<td>
<p> This is the number of replicated points for each original 
point. The default value is 30. The larger the number of points in the data set, 
the smaller this value can be. For data sets of 10,000 points or more, point 
replication should be de-activated by setting augment to FALSE.</p>
</td></tr>
<tr><td><code id="radical_+3A_sd">sd</code></td>
<td>
<p>This is the standard deviation (noise) of the replicated points when 
using the augmentation option.</p>
</td></tr>
<tr><td><code id="radical_+3A_firsteig">firstEig</code></td>
<td>
<p> This and <code>lastEig</code> specify the range for eigenvalues 
that are retained, <code>firstEig</code> is the index of largest eigenvalue to be 
retained. Making use of this option overwrites <code>n.comp</code>.
</p>
</td></tr>
<tr><td><code id="radical_+3A_lasteig">lastEig</code></td>
<td>
<p> This is the index of the last (smallest) eigenvalue to be 
retained and overwrites <code>n.comp</code> argument.</p>
</td></tr>
<tr><td><code id="radical_+3A_pcae">pcaE</code></td>
<td>
<p> Optionally provided eigenvector (must also supply <code>pcaD</code>).</p>
</td></tr>
<tr><td><code id="radical_+3A_pcad">pcaD</code></td>
<td>
<p> Optionally provided eigenvalues (must also supply <code>pcaE</code>).</p>
</td></tr>
<tr><td><code id="radical_+3A_whitesig">whiteSig</code></td>
<td>
<p>Optionally provided Whitened signal.</p>
</td></tr>
<tr><td><code id="radical_+3A_whitemat">whiteMat</code></td>
<td>
<p> Optionally provided Whitening matrix (no.factors by no.signals).</p>
</td></tr>
<tr><td><code id="radical_+3A_dewhitemat">dewhiteMat</code></td>
<td>
<p>Optionally provided dewhitening matrix (no.signals by no.factors).</p>
</td></tr>
<tr><td><code id="radical_+3A_rseed">rseed</code></td>
<td>
<p>Optionally provided seed to initialize the augmented data matrix.</p>
</td></tr>
<tr><td><code id="radical_+3A_trace">trace</code></td>
<td>
<p>To report progress in the console, set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="radical_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the pca.cov methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interested reader should consult the paper in the references section for 
details on the properties of the algorithm.<br />
The algorithm is quite slow, despite partial implementation in C++, and should 
only be used on small to medium sized sets.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>Estimated Mixing Matrix (no.signals by no.factors).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Estimated UnMixing Matrix (no.factors by no.signals). </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Estimated rotation Matrix (no.factors by no.factors). </p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The column vectors of estimated independent components (no.obs by no.factors).</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Estimated Covariance Matrix (no.signals by no.signals).</p>
</td></tr>
<tr><td><code>whiteningMatrix</code></td>
<td>
<p>The Whitening matrix (no.factors by no.signals).</p>
</td></tr>
<tr><td><code>dewhiteningMatrix</code></td>
<td>
<p>The de-Whitening matrix  (no.signals by no.factors).</p>
</td></tr>
<tr><td><code>rseed</code></td>
<td>
<p>The random seed used (if any) for initializing the mixing matrix A.</p>
</td></tr>
<tr><td><code>elapsed</code></td>
<td>
<p>The elapsed time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Erik G. Learned-Miller for the Radical algorithm and Matlab package.<br />
Alexios Galanos for this R-port.
</p>


<h3>References</h3>

<p>Learned-Miller, A.G and Fisher III, J.W., 2003, ICA Using Spacings Estimates of 
Entropy, <em>Journal of Machine Learning Research</em>, <b>4</b>, 1271-1295.
<a href="http://www.cs.umass.edu/~elm/ICA/">http://www.cs.umass.edu/~elm/ICA/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create a set of independent signals S, glued together by a mixing matrix A
# (note the notation and matrix multiplication direction as we are dealing with
# row rather than column vectors)
set.seed(100)
S &lt;- matrix(runif(10000), 5000, 2)
A &lt;- matrix(c(1, 1, -1, 2), 2, 2, byrow = TRUE)
# the mixed signal X
X = S %*% t(A)
# The function centers and whitens (by the eigenvalue decomposition of the 
# unconditional covariance matrix) the data before applying the theICA algorithm.
IC &lt;- radical(X, n.comp = 2)

# demeaned data:
X_bar = scale(X, scale = FALSE)

# whitened data:
X_white = X_bar %*% t(IC$whiteningMatrix)

# check whitening:
# check correlations are zero
cor(X_white)
# check diagonals are 1 in covariance
cov(X_white)

# check that the estimated signals(S) multiplied by the
# estimated mxing matrix (A) are the same as the original dataset (X)
round(head(IC$S %*% t(IC$A)), 12) == round(head(X), 12)

# do some plots:
par(mfrow = c(1, 3))
plot(IC$S %*% t(IC$A), main = "Pre-processed data")
plot(X_white, main = "Whitened and Centered components")
plot(IC$S, main = "ICA components")

## End(Not run)</code></pre>

<hr>
<h2 id='varxfit'>
VARX Fit/Filter/Forecast/Simulation Functions
</h2><span id='topic+varxfilter'></span><span id='topic+varxfit'></span><span id='topic+varxforecast'></span><span id='topic+varxsim'></span>

<h3>Description</h3>

<p>Vector Autoregressive (VAR) with Constant and Optional Exogenous Regressors (X)
Fit, Filter, Forecast and Simulation functions for use with multivariate GARCH 
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varxfit(X, p, constant = TRUE, exogen = NULL, robust = FALSE, gamma = 0.25, 
delta = 0.01, nc = 10, ns = 500, postpad = c("none", "constant", "zero", "NA"), 
cluster = NULL)
varxfilter(X, p, Bcoef, exogen = NULL, postpad = c("none", "constant", "zero", "NA"))
varxforecast(X, Bcoef, p, out.sample, n.ahead, n.roll, mregfor)
varxsim (X, Bcoef, p, n.sim, n.start, prereturns, resids, mexsimdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varxfit_+3A_x">X</code></td>
<td>

<p>A multivariate data matrix.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_p">p</code></td>
<td>

<p>The number of autoregressive lags.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_constant">constant</code></td>
<td>

<p>Whether to include a constant.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_exogen">exogen</code></td>
<td>

<p>An optional matrix of exogenous regressors with as many rows as X, and 
appropriately lagged.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_bcoef">Bcoef</code></td>
<td>

<p>A matrix of coefficients for the varxfilter function.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_robust">robust</code></td>
<td>

<p>Whether to use the robust version of VAR based on the multivariate Least 
Trimmed Squares Estimator described in Croux and Joossens (2008).
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_gamma">gamma</code></td>
<td>

<p>Proportion to trim in the robust method.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_delta">delta</code></td>
<td>

<p>The critical value for Reweighted estimator for the robust method.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_ns">ns</code></td>
<td>

<p>The number of subsets to use for the robust method.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_nc">nc</code></td>
<td>

<p>The number of C-steps to use for the robust method.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_postpad">postpad</code></td>
<td>

<p>(defaults to &lsquo;none&rsquo;) Whether to postpad the fitted/filtered values 
(and hence calculation of residuals) with the estimated constant, zeros or NA's, 
thus returning matrices of the same size as the input data (rather than input 
data size less the number of lags).
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_cluster">cluster</code></td>
<td>
<p> A cluster object created by calling <code>makeCluster</code> from 
the parallel package. If it is not NULL, then this will be used for parallel 
estimation in the case of the robust VAR version (remember to stop the cluster 
on completion).</p>
</td></tr>
<tr><td><code id="varxfit_+3A_out.sample">out.sample</code></td>
<td>

<p>The number of points kept for out of sample rolling forecast.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_n.roll">n.roll</code></td>
<td>

<p>In combination with <code>out.sample</code>, determines the number of times to roll
forward the n.ahead forecast using data left out of sample.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_mregfor">mregfor</code></td>
<td>

<p>Matrix of external regressor forecasts (with appropriate lag structure).
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_n.sim">n.sim</code></td>
<td>

<p>Simulation horizon.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_n.start">n.start</code></td>
<td>

<p>Simulation burn-in sample.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_prereturns">prereturns</code></td>
<td>

<p>Optionally supplied pre-return matrix with &ldquo;p&rdquo; lags to initialize 
simulation.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_resids">resids</code></td>
<td>

<p>Matrix of randomly generated residuals of size n.sim+n.start.
</p>
</td></tr>
<tr><td><code id="varxfit_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>Matrix of external regressor pre-generated random values to use in the
simulation (if NULL then assumed zero).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This are convenience functions to be optionally used when using the multivariate 
GARCH methods.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table role = "presentation">
<tr><td><code>Bcoef</code></td>
<td>
<p>[varxfit, varxfilter]<br />
The coefficient matrix with rows equal to number of assets, and columns equal to
number of assets x number of lags plus 1 (constant) plus number of exogenous 
regressors.</p>
</td></tr>
<tr><td><code>xfitted</code></td>
<td>
<p>[varxfit, varxfilter]<br />
The fitted/filtered series (conditional mean series).</p>
</td></tr>
<tr><td><code>xresiduals</code></td>
<td>
<p>[varxfit, varxfilter]<br />
The residuals.</p>
</td></tr>
<tr><td><code>Bcov</code></td>
<td>
<p>[varxfit]<br />
The covariance matrix of the coefficients.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>[varxfit]<br />
The standard error of the coefficients.</p>
</td></tr> 
<tr><td><code>tstat</code></td>
<td>
<p>[varxfit]<br />
The t-stat of the s.e.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>[varxfit]<br />
The p-values of the s.e.</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>[varxfit, varxfilter]<br />
The number of autoregressive lags.</p>
</td></tr>
<tr><td><code>mxn</code></td>
<td>
<p>[varxfit]<br />
The number of exogenous regressors .</p>
</td></tr>
<tr><td><code>meansim</code></td>
<td>
<p>[varxsim]<br />
The simulated conditional mean.</p>
</td></tr></table>
<p><br />
The varxsim returns an n.sim x n.asset matrix of the simulated conditional
means, while the varxforecast returns an n.ahead x n.assets x (n.roll+1) array 
of the forecast conditional means.
</p>


<h3>Note</h3>

<p>Part of the varxfit functionality and structure is inspired from the 'vars' 
package, but the estimation method is implemented in a very quick way without 
calling 'lm'. The robust method is based on the matlab program of Christophe 
Croux available from his website and the option of using parallel computation is
implemented for this particular choice.The <code>postpad</code> option is used when the
returned data needs to be of the same size as the inputed data for easier
manipulation/comparison (since padding is done post-estimation, there is no bias 
introduced during estimation).
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>


<h3>References</h3>

<p>Lutkepohl, H. 2005, New introduction to multiple time series analysis, 
<em>Springer</em>.<br />
Croux, C. and Joossens, K. 2008, Robust estimation of the vector autoregressive 
model by a least trimmed squares procedure, <em>COMPSTAT</em>, 489&ndash;501.<br />
</p>

<hr>
<h2 id='wmargin'>
Weighted Distribution Margin
</h2><span id='topic+wmargin'></span>

<h3>Description</h3>

<p>Return the weighted margin of one of 3 elliptical distributions given a matrix 
of weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmargin(distribution = "mvnorm", weights, mean, Sigma, shape = NA, skew = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wmargin_+3A_distribution">distribution</code></td>
<td>

<p>One of &lsquo;mvnorm&rsquo;, &lsquo;mvlaplace&rsquo; or &lsquo;mvt&rsquo;.
</p>
</td></tr>
<tr><td><code id="wmargin_+3A_weights">weights</code></td>
<td>

<p>Either a vector or matrix of weights, in the latter case must be of the same 
row dimension as the covariance array.
</p>
</td></tr>
<tr><td><code id="wmargin_+3A_mean">mean</code></td>
<td>

<p>Wither a vector or matrix of conditional distribution means, in the latter
case must be of the same row dimension as the covariance array.
</p>
</td></tr>
<tr><td><code id="wmargin_+3A_sigma">Sigma</code></td>
<td>

<p>An array of covariances, usually returned by calling the &lsquo;rcov&rsquo; method
on one of the multivariate GARCH fitted objects.
</p>
</td></tr>
<tr><td><code id="wmargin_+3A_shape">shape</code></td>
<td>

<p>The shape (d.o.f.) parameter of the multivariate student distribution.
</p>
</td></tr>
<tr><td><code id="wmargin_+3A_skew">skew</code></td>
<td>

<p>Not currently required for the 3 distributions used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a convenience function to return the weighted variance and mean of
the three elliptical distributions given a set of weights.
</p>


<h3>Value</h3>

<p>A matrix with each row representing the conditional weighted marginal density 
with corresponding parameters.
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
