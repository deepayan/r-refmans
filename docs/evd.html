<!DOCTYPE html><html><head><title>Help for package evd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abvevd'><p>Parametric Dependence Functions of Bivariate Extreme</p>
Value Models</a></li>
<li><a href='#abvnonpar'><p>Non-parametric Estimates for Dependence Functions of the</p>
Bivariate Extreme Value Distribution</a></li>
<li><a href='#amvevd'><p>Parametric Dependence Functions of Multivariate Extreme</p>
Value Models</a></li>
<li><a href='#amvnonpar'><p>Non-parametric Estimates for Dependence Functions of the</p>
Multivariate Extreme Value Distribution</a></li>
<li><a href='#anova.evd'><p>Compare Nested EVD Objects</p></a></li>
<li><a href='#bvevd'><p>Parametric Bivariate Extreme Value Distributions</p></a></li>
<li><a href='#bvtcplot'><p>Bivariate Threshold Choice Plot</p></a></li>
<li><a href='#ccbvevd'><p>Calculate Conditional Copulas for Parametric Bivariate Extreme</p>
Value Distributions</a></li>
<li><a href='#chiplot'><p>Dependence Measure Plots</p></a></li>
<li><a href='#clusters'><p>Identify Clusters of Exceedences</p></a></li>
<li><a href='#confint.evd'><p>Calculate Confidence Intervals</p></a></li>
<li><a href='#evd-internal'><p>Internal Functions</p></a></li>
<li><a href='#evind.test'><p>Perform Hypothesis Test Of Independence</p></a></li>
<li><a href='#evmc'><p>Simulate Markov Chains With Extreme Value</p>
Dependence Structures</a></li>
<li><a href='#exi'><p>Estimates of the Extremal Index</p></a></li>
<li><a href='#exiplot'><p>Plot Estimates of the Extremal Index</p></a></li>
<li><a href='#extreme'><p>Distributions of Maxima and Minima</p></a></li>
<li><a href='#failure'><p>Failure Times</p></a></li>
<li><a href='#fbvevd'><p>Maximum-likelihood Fitting of Bivariate Extreme Value Distributions</p></a></li>
<li><a href='#fbvpot'><p>Maximum-likelihood Fitting of Bivariate Extreme Value</p>
Distributions to Threshold Exceedances</a></li>
<li><a href='#fextreme'><p>Maximum-likelihood Fitting of Maxima and Minima</p></a></li>
<li><a href='#fgev'><p>Maximum-likelihood Fitting of the Generalized Extreme Value</p>
Distribution</a></li>
<li><a href='#fgumbelx'><p>Maximum-likelihood Fitting of the Maximum of Two Gumbel</p>
Distributions</a></li>
<li><a href='#forder'><p>Maximum-likelihood Fitting of Order Statistics</p></a></li>
<li><a href='#fox'><p>Maximum Annual Flood Discharges of the Fox River</p></a></li>
<li><a href='#fpot'><p>Peaks Over Threshold Modelling using the Generalized Pareto</p>
or Point Process Representation</a></li>
<li><a href='#frechet'><p>The Frechet Distribution</p></a></li>
<li><a href='#gev'><p>The Generalized Extreme Value Distribution</p></a></li>
<li><a href='#gpd'><p>The Generalized Pareto Distribution</p></a></li>
<li><a href='#gumbel'><p>The Gumbel Distribution</p></a></li>
<li><a href='#gumbelx'><p>Maxima of Two Gumbel Distributions</p></a></li>
<li><a href='#hbvevd'><p>Parametric Spectral Density Functions of Bivariate Extreme</p>
Value Models</a></li>
<li><a href='#lisbon'><p>Annual Maximum Wind Speeds at Lisbon</p></a></li>
<li><a href='#lossalae'><p>General Liability Claims</p></a></li>
<li><a href='#marma'><p>Simulate MARMA(p,q) Processes</p></a></li>
<li><a href='#mrlplot'><p>Empirical Mean Residual Life Plot</p></a></li>
<li><a href='#mtransform'><p>GEV Transformations</p></a></li>
<li><a href='#mvevd'><p>Parametric Multivariate Extreme Value Distributions</p></a></li>
<li><a href='#ocmulgee'><p>Maximum Annual Flood Discharges of the Ocmulgee River</p></a></li>
<li><a href='#oldage'><p>Oldest Ages for Swedish Males and Females</p></a></li>
<li><a href='#order'><p>Distributions of Order Statistics</p></a></li>
<li><a href='#oxford'><p>Annual Maximum Temperatures at Oxford</p></a></li>
<li><a href='#plot.bvevd'><p>Plot Diagnostics for a Bivariate EVD Object</p></a></li>
<li><a href='#plot.bvpot'><p>Plot Diagnostics for a Bivariate POT EVD Object</p></a></li>
<li><a href='#plot.profile.evd'><p>Plot Profile Log-likelihoods</p></a></li>
<li><a href='#plot.profile2d.evd'><p>Plot Joint Profile Log-likelihoods</p></a></li>
<li><a href='#plot.uvevd'><p>Plot Diagnostics for a Univariate EVD Object</p></a></li>
<li><a href='#portpirie'><p>Annual Maximum Sea Levels at Port Pirie</p></a></li>
<li><a href='#profile.evd'><p>Method for Profiling EVD Objects</p></a></li>
<li><a href='#profile2d.evd'><p>Method for Profiling EVD Objects</p></a></li>
<li><a href='#qcbvnonpar'><p>Non-parametric Estimates for Bivariate Quantile Curves</p></a></li>
<li><a href='#rweibull'><p>The Reverse Weibull Distribution</p></a></li>
<li><a href='#sask'><p>Maximum Annual Flood Discharges of the North Saskachevan River</p></a></li>
<li><a href='#sealevel'><p>Annual Sea Level Maxima at Dover and Harwich</p></a></li>
<li><a href='#sealevel2'><p>Annual Sea Level Maxima at Dover and Harwich with Indicator</p></a></li>
<li><a href='#tcplot'><p>Threshold Choice Plot</p></a></li>
<li><a href='#uccle'><p>Rainfall Maxima at Uccle, Belgium</p></a></li>
<li><a href='#venice'><p>Largest Sea Levels in Venice</p></a></li>
<li><a href='#venice2'><p>Largest Sea Levels in Venice</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.3-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Extreme Value Distributions</td>
</tr>
<tr>
<td>Author:</td>
<td>Alec Stephenson. Function fbvpot by Chris Ferro.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alec Stephenson &lt;alec_stephenson@hotmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>interp</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends simulation, distribution, quantile and density
        functions to univariate and multivariate parametric extreme
        value distributions, and provides fitting functions which
        calculate maximum likelihood estimates for univariate and
        bivariate maxima models, and for univariate and bivariate
        threshold models.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-23 06:55:43 UTC; ste6an</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-23 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abvevd'>Parametric Dependence Functions of Bivariate Extreme
Value Models</h2><span id='topic+abvevd'></span>

<h3>Description</h3>

<p>Calculate or plot the dependence function <code class="reqn">A</code> for
nine parametric bivariate extreme value models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abvevd(x = 0.5, dep, asy = c(1,1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
     rev = FALSE, plot = FALSE, add = FALSE, lty = 1, lwd = 1, col = 1,
     blty = 3, blwd = 1, xlim = c(0,1), ylim = c(0.5,1), xlab = "t",
     ylab = "A(t)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abvevd_+3A_x">x</code></td>
<td>
<p>A vector of values at which the dependence function is
evaluated (ignored if plot or add is <code>TRUE</code>). <code class="reqn">A(1/2)</code>
is returned by default since it is often a useful summary of
dependence.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_dep">dep</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, Husler-Reiss, negative logistic and asymmetric
negative logistic models.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_asy">asy</code></td>
<td>
<p>A vector of length two, containing the two asymmetry
parameters for the asymmetric logistic and asymmetric negative
logistic models.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_alpha">alpha</code>, <code id="abvevd_+3A_beta">beta</code></td>
<td>
<p>Alpha and beta parameters for the bilogistic,
negative bilogistic, Coles-Tawn and asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric
mixed models respectively. The definition of each model is given
in <code><a href="#topic+rbvevd">rbvevd</a></code>. If parameter arguments are given that do
not correspond to the specified model those arguments are
ignored, with a warning.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_rev">rev</code></td>
<td>
<p>Logical; reverse the dependence function? This is
equivalent to evaluating the function at <code>1-x</code>.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function is plotted. The
x and y values used to create the plot are returned invisibly.
If <code>plot</code> and <code>add</code> are <code>FALSE</code> (the default),
the arguments following <code>add</code> are ignored.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_add">add</code></td>
<td>
<p>Logical; add to an existing plot? The existing plot
should have been created using either <code>abvevd</code> or
<code><a href="#topic+abvnonpar">abvnonpar</a></code>, the latter of which plots (or calculates)
a non-parametric estimate of the dependence function.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_lty">lty</code>, <code id="abvevd_+3A_blty">blty</code></td>
<td>
<p>Function and border line types. Set <code>blty</code>
to zero to omit the border.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_lwd">lwd</code>, <code id="abvevd_+3A_blwd">blwd</code></td>
<td>
<p>Function an border line widths.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_col">col</code></td>
<td>
<p>Line colour.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_xlim">xlim</code>, <code id="abvevd_+3A_ylim">ylim</code></td>
<td>
<p>x and y-axis limits.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_xlab">xlab</code>, <code id="abvevd_+3A_ylab">ylab</code></td>
<td>
<p>x and y-axis labels.</p>
</td></tr>
<tr><td><code id="abvevd_+3A_...">...</code></td>
<td>
<p>Other high-level graphics parameters to be passed to
<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any bivariate extreme value distribution can be written as
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left[-(y_1+y_2)A\left(
    \frac{y_1}{y_1+y_2}\right)\right]</code>
</p>

<p>for some function <code class="reqn">A(\cdot)</code> defined on <code class="reqn">[0,1]</code>, where    
</p>
<p style="text-align: center;"><code class="reqn">y_i = \{1+s_i(z_i-a_i)/b_i\}^{-1/s_i}</code>
</p>

<p>for <code class="reqn">1+s_i(z_i-a_i)/b_i &gt; 0</code> and
<code class="reqn">i = 1,2</code>, with the (generalized extreme value) marginal
parameters given by <code class="reqn">(a_i,b_i,s_i)</code>,
<code class="reqn">b_i &gt; 0</code>.
If <code class="reqn">s_i = 0</code> then <code class="reqn">y_i</code> is defined by
continuity.
</p>
<p><code class="reqn">A(\cdot)</code> is called (by some authors) the dependence
function.
It follows that <code class="reqn">A(0)=A(1)=1</code>, and that <code class="reqn">A(\cdot)</code> is
a convex function with <code class="reqn">\max(x,1-x) \leq A(x)\leq 1</code> for all <code class="reqn">0\leq x\leq1</code>.
The lower and upper limits of <code class="reqn">A</code> are obtained under complete
dependence and independence respectively.
<code class="reqn">A(\cdot)</code> does not depend on the marginal parameters.
</p>
<p>Some authors take B(x) = A(1-x) as the dependence function. If the
argument <code>rev = TRUE</code>, then B(x) is plotted/evaluated.
</p>


<h3>Value</h3>

<p><code>abvevd</code> calculates or plots the dependence function
for one of nine parametric bivariate extreme value models,
at specified parameter values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvnonpar">abvnonpar</a></code>, <code><a href="#topic+fbvevd">fbvevd</a></code>,
<code><a href="#topic+rbvevd">rbvevd</a></code>, <code><a href="#topic+amvevd">amvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>abvevd(dep = 2.7, model = "hr")
abvevd(seq(0,1,0.25), dep = 0.3, asy = c(.7,.9), model = "alog")
abvevd(alpha = 0.3, beta = 1.2, model = "negbi", plot = TRUE)

bvdata &lt;- rbvevd(100, dep = 0.7, model = "log")
M1 &lt;- fitted(fbvevd(bvdata, model = "log"))
abvevd(dep = M1["dep"], model = "log", plot = TRUE)
abvnonpar(data = bvdata, add = TRUE, lty = 2)
</code></pre>

<hr>
<h2 id='abvnonpar'>Non-parametric Estimates for Dependence Functions of the
Bivariate Extreme Value Distribution</h2><span id='topic+abvnonpar'></span>

<h3>Description</h3>

<p>Calculate or plot non-parametric estimates for the dependence function
<code class="reqn">A</code> of the bivariate extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abvnonpar(x = 0.5, data, epmar = FALSE, nsloc1 = NULL,
    nsloc2 = NULL, method = c("cfg", "pickands", "tdo", "pot"),
     k = nrow(data)/4, convex = FALSE, rev = FALSE, madj = 0,
    kmar = NULL, plot = FALSE, add = FALSE, lty = 1, lwd = 1,
    col = 1, blty = 3, blwd = 1, xlim = c(0, 1), ylim = c(0.5, 1),
    xlab = "t", ylab = "A(t)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abvnonpar_+3A_x">x</code></td>
<td>
<p>A vector of values at which the dependence function is
evaluated (ignored if plot or add is <code>TRUE</code>). <code class="reqn">A(1/2)</code>
is returned by default since it is often a useful summary of
dependence.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_data">data</code></td>
<td>
<p>A matrix or data frame with two columns, which may contain
missing values.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_epmar">epmar</code></td>
<td>
<p>If <code>TRUE</code>, an empirical transformation of the
marginals is performed in preference to marginal parametric
GEV estimation, and the <code>nsloc</code> arguments are ignored.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_nsloc1">nsloc1</code>, <code id="abvnonpar_+3A_nsloc2">nsloc2</code></td>
<td>
<p>A data frame with the same number of rows as
<code>data</code>, for linear modelling of the location parameter on the
first/second margin. The data frames are treated as covariate
matrices, excluding the intercept. A numeric vector can be given
as an alternative to a single column data frame.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_method">method</code></td>
<td>
<p>The estimation method (see <b>Details</b>). Typically
either <code>"cfg"</code> (the default) or <code>"pickands"</code>. The method
<code>"tdo"</code> performs poorly and is not recommended. The method 
<code>"pot"</code> is for peaks over threshold modelling where only 
large data values are used for estimation.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_k">k</code></td>
<td>
<p>An integer parameter for the <code>"pot"</code> method. Only the 
largest <code>k</code> values are used, as described in
<code><a href="#topic+bvtcplot">bvtcplot</a></code>.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_convex">convex</code></td>
<td>
<p>Logical; take the convex minorant?</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_rev">rev</code></td>
<td>
<p>Logical; reverse the dependence function? This is
equivalent to evaluating the function at <code>1-x</code>.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_madj">madj</code></td>
<td>
<p>Performs marginal adjustments for the <code>"pickands"</code>
method (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_kmar">kmar</code></td>
<td>
<p>In the rare case that the marginal distributions are known,
specifies the GEV parameters to be used instead of maximum likelihood
estimates.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function is plotted. The
x and y values used to create the plot are returned invisibly.
If <code>plot</code> and <code>add</code> are <code>FALSE</code> (the default),
the arguments following <code>add</code> are ignored.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_add">add</code></td>
<td>
<p>Logical; add to an existing plot? The existing plot
should have been created using either <code>abvnonpar</code> or
<code><a href="#topic+abvevd">abvevd</a></code>, the latter of which plots (or calculates)
the dependence function for a number of parametric models.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_lty">lty</code>, <code id="abvnonpar_+3A_blty">blty</code></td>
<td>
<p>Function and border line types. Set <code>blty</code>
to zero to omit the border.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_lwd">lwd</code>, <code id="abvnonpar_+3A_blwd">blwd</code></td>
<td>
<p>Function and border line widths.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_col">col</code></td>
<td>
<p>Line colour.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_xlim">xlim</code>, <code id="abvnonpar_+3A_ylim">ylim</code></td>
<td>
<p>x and y-axis limits.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_xlab">xlab</code>, <code id="abvnonpar_+3A_ylab">ylab</code></td>
<td>
<p>x and y-axis labels.</p>
</td></tr>
<tr><td><code id="abvnonpar_+3A_...">...</code></td>
<td>
<p>Other high-level graphics parameters to be passed to
<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence function  <code class="reqn">A(\cdot)</code> of the bivariate
extreme value distribution is defined in <code><a href="#topic+abvevd">abvevd</a></code>.
Non-parametric estimates are constructed as follows.
Suppose <code class="reqn">(z_{i1},z_{i2})</code> for <code class="reqn">i=1,\ldots,n</code> are <code class="reqn">n</code>
bivariate observations that are passed using the <code>data</code>
argument.
If <code>epmar</code> is <code>FALSE</code> (the default), then
the marginal parameters of the GEV margins are estimated
(under the assumption of independence) and the data is
transformed using
</p>
<p style="text-align: center;"><code class="reqn">y_{i1} = \{1+\hat{s}_1(z_{i1}-\hat{a}_1)/
    \hat{b}_1\}_{+}^{-1/\hat{s}_1}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">y_{i2} = \{1+\hat{s}_2(z_{i2}-\hat{a}_2)/
    \hat{b}_2\}_{+}^{-1/\hat{s}_2}</code>
</p>

<p>for <code class="reqn">i = 1,\ldots,n</code>, where
<code class="reqn">(\hat{a}_1,\hat{b}_1,\hat{s}_1)</code> and
<code class="reqn">(\hat{a}_2,\hat{b}_2,\hat{s}_2)</code>
are the maximum likelihood estimates for the location, scale
and shape parameters on the first and second margins.
If <code>nsloc1</code> or <code>nsloc2</code> are given, the location
parameters may depend on <code class="reqn">i</code> (see <code><a href="#topic+fgev">fgev</a></code>).
</p>
<p>Two different estimators of the dependence function can be
implemented.
They are defined (on <code class="reqn">0 \leq w \leq 1</code>) as
follows.
</p>
<p><code>method = "cfg"</code> (Caperaa, Fougeres and Genest, 1997)
</p>
<p style="text-align: center;"><code class="reqn">\log(A_c(w)) = \frac{1}{n} \left\{ \sum_{i=1}^n \log(\max[(1-w)y_{i1},
    wy_{i1}]) - (1-w)\sum_{i=1}^n y_{i1} - w \sum_{i=1}^n y_{i2}
    \right\}</code>
</p>

<p><code>method = "pickands"</code> (Pickands, 1981)
</p>
<p style="text-align: center;"><code class="reqn">A_p(w) = n\left\{\sum_{i=1}^n \min\left(\frac{y_{i1}}{w},
    \frac{y_{i2}}{1-w}\right)\right\}^{-1}</code>
</p>

<p>Two variations on the estimator <code class="reqn">A_p(\cdot)</code> are
also implemented. If the argument <code>madj = 1</code>, an adjustment
given in Deheuvels (1991) is applied. If the argument
<code>madj = 2</code>, an adjustment given in Hall and Tajvidi (2000)
is applied. These are marginal adjustments; they are only
useful when empirical marginal estimation is used.
</p>
<p>Let <code class="reqn">A_n(\cdot)</code> be any estimator of <code class="reqn">A(\cdot)</code>.
None of the estimators satisfy
<code class="reqn">\max(w,1-w) \leq A_n(w) \leq 1</code>
for all <code class="reqn">0\leq w \leq1</code>. An obvious modification is
</p>
<p style="text-align: center;"><code class="reqn">A_n^{'}(w) = \min(1, \max\{A_n(w), w, 1-w\}).</code>
</p>

<p>This modification is always implemented.
</p>
<p>Convex estimators can be derived by taking the convex minorant,
which can be achieved by setting <code>convex</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p><code>abvnonpar</code> calculates or plots a non-parametric estimate of
the dependence function of the bivariate extreme value distribution.
</p>


<h3>Note</h3>

<p>I have been asked to point out that Hall and Tajvidi (2000)
suggest putting a constrained smoothing spline on their
modified Pickands estimator, but this is not done here.
</p>


<h3>References</h3>

<p>Caperaa, P. Fougeres, A.-L. and Genest, C. (1997)
A non-parametric estimation procedure for bivariate
extreme value copulas.
<em>Biometrika</em>, <b>84</b>, 567&ndash;577.
</p>
<p>Pickands, J. (1981)
Multivariate extreme value distributions.
<em>Proc. 43rd Sess. Int. Statist. Inst.</em>, <b>49</b>, 859&ndash;878.
</p>
<p>Deheuvels, P. (1991)
On the limiting behaviour of the Pickands estimator 
for bivariate extreme-value distributions.
<em>Statist. Probab. Letters</em>, <b>12</b>, 429&ndash;439.
</p>
<p>Hall, P. and Tajvidi, N. (2000)
Distribution and dependence-function estimation for
bivariate extreme-value distributions.
<em>Bernoulli</em>, <b>6</b>, 835&ndash;844.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvevd">abvevd</a></code>, <code><a href="#topic+amvnonpar">amvnonpar</a></code>,
<code><a href="#topic+bvtcplot">bvtcplot</a></code>, <code><a href="#topic+fgev">fgev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(100, dep = 0.7, model = "log")
abvnonpar(seq(0, 1, length = 10), data = bvdata, convex = TRUE)
abvnonpar(data = bvdata, method = "pick", plot = TRUE)

M1 &lt;- fitted(fbvevd(bvdata, model = "log"))
abvevd(dep = M1["dep"], model = "log", plot = TRUE)
abvnonpar(data = bvdata, add = TRUE, lty = 2)
</code></pre>

<hr>
<h2 id='amvevd'>Parametric Dependence Functions of Multivariate Extreme
Value Models</h2><span id='topic+amvevd'></span>

<h3>Description</h3>

<p>Calculate the dependence function <code class="reqn">A</code> for the multivariate
logistic and multivariate asymmetric logistic models; plot the
estimated function in the trivariate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amvevd(x = rep(1/d,d), dep, asy, model = c("log", "alog"), d = 3, plot =
    FALSE, col = heat.colors(12), blty = 0, grid = if(blty) 150 else 50,
    lower = 1/3, ord = 1:3, lab = as.character(1:3), lcex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amvevd_+3A_x">x</code></td>
<td>
<p>A vector of length <code>d</code> or a matrix with <code>d</code>
columns, in which case the dependence function is evaluated
across the rows (ignored if plot is <code>TRUE</code>). The
elements/rows of the vector/matrix should be positive and should
sum to one, or else they should have a positive sum, in which
case the rows are rescaled and a warning is given.
<code class="reqn">A(1/d,\dots,1/d)</code> is returned by default since it is often
a useful summary of dependence.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_dep">dep</code></td>
<td>
<p>The dependence parameter(s). For the logistic model,
should be a single value. For the asymmetric logistic model,
should be a vector of length <code class="reqn">2^d-d-1</code>, or a single value,
in which case the value is used for each of the <code class="reqn">2^d-d-1</code>
parameters (see <code><a href="#topic+rmvevd">rmvevd</a></code>).</p>
</td></tr>
<tr><td><code id="amvevd_+3A_asy">asy</code></td>
<td>
<p>The asymmetry parameters for the asymmetric logistic
model. Should be a list with <code class="reqn">2^d-1</code> vector elements
containing the asymmetry parameters for each separate component
(see <code><a href="#topic+rmvevd">rmvevd</a></code> and <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="amvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default) or <code>"alog"</code> (or any unique
partial match), for the logistic and asymmetric logistic models
respectively. The definition of each model is given in
<code><a href="#topic+rmvevd">rmvevd</a></code>.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_d">d</code></td>
<td>
<p>The dimension; an integer greater than or equal to two.
The trivariate case <code>d = 3</code> is the default.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code>, and the dimension <code>d</code> is
three (the default dimension), the dependence function of a
trivariate model is plotted. For plotting in the bivariate case,
use <code><a href="#topic+abvevd">abvevd</a></code>. If <code>FALSE</code> (the default), the
following arguments are ignored.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_col">col</code></td>
<td>
<p>A list of colours (see <code><a href="graphics.html#topic+image">image</a></code>). The first
colours in the list represent smaller values, and hence
stronger dependence. Each colour represents an equally spaced
interval between <code>lower</code> and one.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_blty">blty</code></td>
<td>
<p>The border line type, for the border that surrounds
the triangular image. By default <code>blty</code> is zero, so no
border is plotted. Plotting a border leads to (by default) an
increase in <code>grid</code> (and hence computation time), to ensure
that the image fits within it.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_grid">grid</code></td>
<td>
<p>For plotting, the function is evaluated at <code>grid^2</code>
points.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_lower">lower</code></td>
<td>
<p>The minimum value for which colours are plotted. By
defualt <code class="reqn">\code{lower} = 1/3</code> as this is the theoretical
minimum of the dependence function of the trivariate extreme
value distribution.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_ord">ord</code></td>
<td>
<p>A vector of length three, which should be a permutation
of the set <code class="reqn">\{1,2,3\}</code>. The points
<code class="reqn">(1,0,0)</code>, <code class="reqn">(0,1,0)</code> and <code class="reqn">(0,0,1)</code> (the vertices of
the simplex) are depicted clockwise from the top in
the order defined by <code>ord</code>.The argument alters the way in
which the function is plotted; it does not change the function
definition.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_lab">lab</code></td>
<td>
<p>A character vector of length three, in which case the
<code>i</code>th margin is labelled using the <code>i</code>th component,
or <code>NULL</code>, in which case no labels are given. The actual
location of the margins, and hence the labels, is defined by
<code>ord</code>.</p>
</td></tr>
<tr><td><code id="amvevd_+3A_lcex">lcex</code></td>
<td>
<p>A numerical value giving the amount by which the
labels should be scaled relative to the default. Ignored
if <code>lab</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">z = (z_1,\dots,z_d)</code> and
<code class="reqn">w = (w_1,\dots,w_d)</code>.
Any multivariate extreme value distribution can be written as
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left\{- \left\{\sum\nolimits_{j=1}^{d} y_j
    \right\} A\left(\frac{y_1}{\sum\nolimits_{j=1}^{d} y_j}, \dots,
    \frac{y_d}{\sum\nolimits_{j=1}^{d} y_j}\right)\right\}</code>
</p>

<p>for some function <code class="reqn">A</code> defined on the simplex
<code class="reqn">S_d = \{w \in R^d_+ : \sum\nolimits_{j=1}^{d}
    w_j = 1\}</code>,
where </p>
<p style="text-align: center;"><code class="reqn">y_i = \{1+s_i(z_i-a_i)/b_i\}^{-1/s_i}</code>
</p>

<p>for <code class="reqn">1+s_i(z_i-a_i)/b_i &gt; 0</code> and
<code class="reqn">i = 1,\dots,d</code>, and where the (generalized extreme value)
marginal parameters are given by
<code class="reqn">(a_i,b_i,s_i)</code>, <code class="reqn">b_i &gt; 0</code>.
If <code class="reqn">s_i = 0</code> then <code class="reqn">y_i</code> is defined by
continuity.
</p>
<p><code class="reqn">A</code> is called (by some authors) the dependence function.
It follows that <code class="reqn">A(w) = 1</code> when <code class="reqn">w</code> is one of the <code class="reqn">d</code>
vertices of <code class="reqn">S_d</code>, and that <code class="reqn">A</code> is a convex function with
<code class="reqn">\max(w_1,\dots,w_d) \leq A(w)\leq 1</code> for
all <code class="reqn">w</code> in <code class="reqn">S_d</code>.
The lower and upper limits of <code class="reqn">A</code> are obtained under complete
dependence and mutual independence respectively.
<code class="reqn">A</code> does not depend on the marginal parameters.
</p>


<h3>Value</h3>

<p>A numeric vector of values. If plotting, the smallest evaluated
function value is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amvnonpar">amvnonpar</a></code>, <code><a href="#topic+abvevd">abvevd</a></code>,
<code><a href="#topic+rmvevd">rmvevd</a></code>, <code><a href="graphics.html#topic+image">image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>amvevd(dep = 0.5, model = "log")
s3pts &lt;- matrix(rexp(30), nrow = 10, ncol = 3)
s3pts &lt;- s3pts/rowSums(s3pts)
amvevd(s3pts, dep = 0.5, model = "log")
## Not run: amvevd(dep = 0.05, model = "log", plot = TRUE, blty = 1)
amvevd(dep = 0.95, model = "log", plot = TRUE, lower = 0.94)

asy &lt;- list(.4, .1, .6, c(.3,.2), c(.1,.1), c(.4,.1), c(.2,.3,.2))
amvevd(s3pts, dep = 0.15, asy = asy, model = "alog")
amvevd(dep = 0.15, asy = asy, model = "al", plot = TRUE, lower = 0.7)
</code></pre>

<hr>
<h2 id='amvnonpar'>Non-parametric Estimates for Dependence Functions of the
Multivariate Extreme Value Distribution</h2><span id='topic+amvnonpar'></span>

<h3>Description</h3>

<p>Calculate non-parametric estimates for the dependence function
<code class="reqn">A</code> of the multivariate extreme value distribution and plot
the estimated function in the trivariate case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amvnonpar(x = rep(1/d,d), data, d = 3, epmar = FALSE, nsloc = NULL,
    madj = 0, kmar = NULL, plot = FALSE, col = heat.colors(12),
    blty = 0, grid = if(blty) 150 else 50, lower = 1/3, ord = 1:3,
    lab = as.character(1:3), lcex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amvnonpar_+3A_x">x</code></td>
<td>
<p>A vector of length <code>d</code> or a matrix with <code>d</code>
columns, in which case the dependence function is evaluated
across the rows (ignored if plot is <code>TRUE</code>). The
elements/rows of the vector/matrix should be positive and should
sum to one, or else they should have a positive sum, in which
case the rows are rescaled and a warning is given.
<code class="reqn">A(1/d,\dots,1/d)</code> is returned by default since it is often
a useful summary of dependence.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_data">data</code></td>
<td>
<p>A matrix or data frame with <code>d</code> columns, which may
contain missing values.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_d">d</code></td>
<td>
<p>The dimension; an integer greater than or equal to two.
The trivariate case <code>d = 3</code> is the default.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_epmar">epmar</code></td>
<td>
<p>If <code>TRUE</code>, an empirical transformation of the
marginals is performed in preference to marginal parametric
GEV estimation, and the <code>nsloc</code> argument is ignored.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_nsloc">nsloc</code></td>
<td>
<p>A data frame with the same number of rows as <code>data</code>,
or a list containing <code>d</code> elements of this type, for linear
modelling of the marginal location parameters. In the former case,
the argument is applied to all margins. The data frames are treated
as covariate matrices, excluding the intercept. Numeric vectors can
be given as alternatives to single column data frames. A list can
contain <code>NULL</code> elements for stationary modelling of selected
margins.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_madj">madj</code></td>
<td>
<p>Performs marginal adjustments. See
<code><a href="#topic+abvnonpar">abvnonpar</a></code>.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_kmar">kmar</code></td>
<td>
<p>In the rare case that the marginal distributions are known,
specifies the GEV parameters to be used instead of maximum likelihood
estimates.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code>, and the dimension <code>d</code> is
three (the default dimension), the dependence function of a
trivariate extreme value distribution is plotted. For plotting in
the bivariate case, use <code><a href="#topic+abvnonpar">abvnonpar</a></code>. If <code>FALSE</code>
(the default), the following arguments are ignored.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_col">col</code></td>
<td>
<p>A list of colours (see <code><a href="graphics.html#topic+image">image</a></code>). The first
colours in the list represent smaller values, and hence
stronger dependence. Each colour represents an equally spaced
interval between <code>lower</code> and one.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_blty">blty</code></td>
<td>
<p>The border line type, for the border that surrounds
the triangular image. By default <code>blty</code> is zero, so no
border is plotted. Plotting a border leads to (by default) an
increase in <code>grid</code> (and hence computation time), to ensure
that the image fits within it.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_grid">grid</code></td>
<td>
<p>For plotting, the function is evaluated at <code>grid^2</code>
points.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_lower">lower</code></td>
<td>
<p>The minimum value for which colours are plotted. By
default <code class="reqn">\code{lower} = 1/3</code> as this is the theoretical
minimum of the dependence function of the trivariate extreme
value distribution.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_ord">ord</code></td>
<td>
<p>A vector of length three, which should be a permutation
of the set <code class="reqn">\{1,2,3\}</code>. The points <code class="reqn">(1,0,0)</code>,
<code class="reqn">(0,1,0)</code> and <code class="reqn">(0,0,1)</code> (the vertices of the simplex)
are depicted clockwise from the top in the order defined by
<code>ord</code>. The argument alters the way in which the function
is plotted; it does not change the function definition.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_lab">lab</code></td>
<td>
<p>A character vector of length three, in which case the
<code>i</code>th margin is labelled using the <code>i</code>th component,
or <code>NULL</code>, in which case no labels are given. By default,
<code>lab</code> is <code>as.character(1:3)</code>. The actual location of
the margins, and hence the labels, is defined by <code>ord</code>.</p>
</td></tr>
<tr><td><code id="amvnonpar_+3A_lcex">lcex</code></td>
<td>
<p>A numerical value giving the amount by which the
labels should be scaled relative to the default. Ignored
if <code>lab</code> is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of estimates. If plotting, the smallest evaluated
estimate is returned invisibly.
</p>


<h3>Note</h3>

<p>The rows of <code>data</code> that contain missing values are not used
in the estimation of the dependence structure, but every non-missing
value is used in estimating the margins.
</p>
<p>The dependence function of the multivariate extreme value
distribution is defined in <code><a href="#topic+amvevd">amvevd</a></code>.
The function <code><a href="#topic+amvevd">amvevd</a></code> calculates and plots dependence
functions of multivariate logistic and multivariate asymmetric
logistic models.
</p>
<p>The estimator plotted or calculated is a multivariate extension of
the bivariate Pickands estimator defined in <code><a href="#topic+abvnonpar">abvnonpar</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amvevd">amvevd</a></code>, <code><a href="#topic+abvnonpar">abvnonpar</a></code>,
<code><a href="#topic+fgev">fgev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s5pts &lt;- matrix(rexp(50), nrow = 10, ncol = 5)
s5pts &lt;- s5pts/rowSums(s5pts)
sdat &lt;- rmvevd(100, dep = 0.6, model = "log", d = 5)
amvnonpar(s5pts, sdat, d = 5)

## Not run: amvnonpar(data = sdat, plot = TRUE)
## Not run: amvnonpar(data = sdat, plot = TRUE, ord = c(2,3,1), lab = LETTERS[1:3])
## Not run: amvevd(dep = 0.6, model = "log", plot = TRUE)
## Not run: amvevd(dep = 0.6, model = "log", plot = TRUE, blty = 1)
</code></pre>

<hr>
<h2 id='anova.evd'>Compare Nested EVD Objects</h2><span id='topic+anova.evd'></span>

<h3>Description</h3>

<p>Compute an analysis of deviance table for two or more nested
evd objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evd'
anova(object, object2, ..., half = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.evd_+3A_object">object</code></td>
<td>
<p>An object of class <code>"evd"</code>.</p>
</td></tr>
<tr><td><code id="anova.evd_+3A_object2">object2</code></td>
<td>
<p>An object of class <code>"evd"</code> that
represents a model nested within <code>object</code>.</p>
</td></tr>
<tr><td><code id="anova.evd_+3A_...">...</code></td>
<td>
<p>Further successively nested objects.</p>
</td></tr>
<tr><td><code id="anova.evd_+3A_half">half</code></td>
<td>
<p>For some non-regular tesing problems the deviance
difference is known to be one half of a chi-squared random
variable. Set <code>half</code> to <code>TRUE</code> in these cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("anova", "data.frame")</code>, with one
row for each model, and the following five columns
</p>
<table>
<tr><td><code>M.Df</code></td>
<td>
<p>The number of parameters.</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>
<p>The deviance.</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>The number of parameters of the model in the previous row
minus the number of parameters.</p>
</td></tr>
<tr><td><code>Chisq</code></td>
<td>
<p>The deviance minus the deviance of the model
in the previous row (or twice this if <code>half</code> is
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code>Pr(&gt;chisq)</code></td>
<td>
<p>The p-value calculated by comparing the quantile
<code>Chisq</code> with a chi-squared distribution on <code>Df</code> degrees
of freedom.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Circumstances may arise such that the asymptotic distribution of the
test statistic is not chi-squared. In particular, this occurs when
the smaller model is constrained at the edge of the parameter space.
It is up to the user recognize this, and to interpret the output
correctly.
</p>
<p>In some cases the asymptotic distribution is known to be
one half of a chi-squared; you can set <code>half = TRUE</code> in
these cases.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbvevd">fbvevd</a></code>, <code><a href="#topic+fextreme">fextreme</a></code>,
<code><a href="#topic+fgev">fgev</a></code>, <code><a href="#topic+forder">forder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
trend &lt;- (-49:50)/100
M1 &lt;- fgev(uvdata, nsloc = trend)
M2 &lt;- fgev(uvdata)
M3 &lt;- fgev(uvdata, shape = 0)
anova(M1, M2, M3)

bvdata &lt;- rbvevd(100, dep = 0.75, model = "log")
M1 &lt;- fbvevd(bvdata, model = "log")
M2 &lt;- fbvevd(bvdata, model = "log", dep = 0.75)
M3 &lt;- fbvevd(bvdata, model = "log", dep = 1)
anova(M1, M2)
anova(M1, M3, half = TRUE)
</code></pre>

<hr>
<h2 id='bvevd'>Parametric Bivariate Extreme Value Distributions</h2><span id='topic+dbvevd'></span><span id='topic+pbvevd'></span><span id='topic+rbvevd'></span>

<h3>Description</h3>

<p>Density function, distribution function and random generation
for nine parametric bivariate extreme value models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbvevd(x, dep, asy = c(1, 1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
    mar1 = c(0, 1, 0), mar2 = mar1, log = FALSE) 
pbvevd(q, dep, asy = c(1, 1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
    mar1 = c(0, 1, 0), mar2 = mar1, lower.tail = TRUE) 
rbvevd(n, dep, asy = c(1, 1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
    mar1 = c(0, 1, 0), mar2 = mar1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvevd_+3A_x">x</code>, <code id="bvevd_+3A_q">q</code></td>
<td>
<p>A vector of length two or a matrix with two columns,
in which case the density/distribution is evaluated across
the rows.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_dep">dep</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, Husler-Reiss, negative logistic and asymmetric
negative logistic models.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_asy">asy</code></td>
<td>
<p>A vector of length two, containing the two asymmetry
parameters for the asymmetric logistic and asymmetric negative
logistic models.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_alpha">alpha</code>, <code id="bvevd_+3A_beta">beta</code></td>
<td>
<p>Alpha and beta parameters for the bilogistic,
negative bilogistic, Coles-Tawn and asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric
mixed models respectively. If parameter arguments are given
that do not correspond to the specified model those arguments
are ignored, with a warning.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_mar1">mar1</code>, <code id="bvevd_+3A_mar2">mar2</code></td>
<td>
<p>Vectors of length three containing marginal
parameters, or matrices with three columns where each
column represents a vector of values to be passed to the
corresponding marginal parameter.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="bvevd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), the
distribution function is returned; the survivor function
is returned otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">y_i = y_i(z_i) = \{1+s_i(z_i-a_i)/b_i\}^{-1/s_i}</code>
</p>

<p>for <code class="reqn">1+s_i(z_i-a_i)/b_i &gt; 0</code> and
<code class="reqn">i = 1,2</code>, where the marginal parameters are given by
<code class="reqn">\code{mari} = (a_i,b_i,s_i)</code>,
<code class="reqn">b_i &gt; 0</code>.
If <code class="reqn">s_i = 0</code> then <code class="reqn">y_i</code> is defined by
continuity.
</p>
<p>In each of the bivariate distributions functions
<code class="reqn">G(z_1,z_2)</code> given below, the univariate margins
are generalized extreme value, so that
<code class="reqn">G(z_i) = \exp(-y_i)</code> for <code class="reqn">i = 1,2</code>.
If <code class="reqn">1+s_i(z_i-a_i)/b_i \leq 0</code> for some
<code class="reqn">i = 1,2</code>, the value <code class="reqn">z_i</code> is either greater than the
upper end point (if <code class="reqn">s_i &lt; 0</code>), or less than the lower
end point (if <code class="reqn">s_i &gt; 0</code>), of the <code class="reqn">i</code>th univariate
marginal distribution.
</p>
<p><code>model = "log"</code> (Gumbel, 1960)
</p>
<p>The bivariate logistic distribution function with
parameter <code class="reqn">\code{dep} = r</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left[-(y_1^{1/r}+y_2^{1/r})^r\right]</code>
</p>

<p>where <code class="reqn">0 &lt; r \leq 1</code>.
This is a special case of the bivariate asymmetric logistic
model.
Complete dependence is obtained in the limit as
<code class="reqn">r</code> approaches zero.
Independence is obtained when <code class="reqn">r = 1</code>.
</p>
<p><code>model = "alog"</code> (Tawn, 1988)
</p>
<p>The bivariate asymmetric logistic distribution function with
parameters <code class="reqn">\code{dep} = r</code> and
<code class="reqn">\code{asy} = (t_1,t_2)</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left\{-(1-t_1)y_1-(1-t_2)y_2-
    [(t_1y_1)^{1/r}+(t_2y_2)^{1/r}]^r\right\}</code>
</p>

<p>where <code class="reqn">0 &lt; r \leq 1</code> and
<code class="reqn">0 \leq t_1,t_2 \leq 1</code>.
When <code class="reqn">t_1 = t_2 = 1</code> the asymmetric logistic
model is equivalent to the logistic model.
Independence is obtained when either <code class="reqn">r = 1</code>,
<code class="reqn">t_1 = 0</code> or <code class="reqn">t_2 = 0</code>.
Complete dependence is obtained in the limit when
<code class="reqn">t_1 = t_2 = 1</code> and <code class="reqn">r</code>
approaches zero.
Different limits occur when <code class="reqn">t_1</code> and <code class="reqn">t_2</code>
are fixed and <code class="reqn">r</code> approaches zero.
</p>
<p><code>model = "hr"</code> (Husler and Reiss, 1989)
</p>
<p>The Husler-Reiss distribution function with parameter
<code class="reqn">\code{dep} = r</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left(-y_1\Phi\{r^{-1}+{\textstyle\frac{1}{2}}
    r[\log(y_1/y_2)]\} - y_2\Phi\{r^{-1}+{\textstyle\frac{1}{2}}r
    [\log(y_2/y_1)]\}\right)</code>
</p>

<p>where <code class="reqn">\Phi(\cdot)</code> is the standard normal distribution
function and <code class="reqn">r &gt; 0</code>.
Independence is obtained in the limit as <code class="reqn">r</code> approaches zero.
Complete dependence is obtained as <code class="reqn">r</code> tends to infinity.
</p>
<p><code>model = "neglog"</code> (Galambos, 1975)
</p>
<p>The bivariate negative logistic distribution function
with parameter <code class="reqn">\code{dep} = r</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left\{-y_1-y_2+
    [y_1^{-r}+y_2^{-r}]^{-1/r}\right\}</code>
</p>

<p>where <code class="reqn">r &gt; 0</code>.
This is a special case of the bivariate asymmetric negative
logistic model.
Independence is obtained in the limit as <code class="reqn">r</code> approaches zero.
Complete dependence is obtained as <code class="reqn">r</code> tends to infinity.
The earliest reference to this model appears to be
Galambos (1975, Section 4).
</p>
<p><code>model = "aneglog"</code> (Joe, 1990)
</p>
<p>The bivariate asymmetric negative logistic distribution function
with parameters parameters <code class="reqn">\code{dep} = r</code> and
<code class="reqn">\code{asy} = (t_1,t_2)</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left\{-y_1-y_2+
    [(t_1y_1)^{-r}+(t_2y_2)^{-r}]^{-1/r}\right\}</code>
</p>

<p>where <code class="reqn">r &gt; 0</code> and <code class="reqn">0 &lt; t_1,t_2 \leq 1</code>.
When <code class="reqn">t_1 = t_2 = 1</code> the asymmetric negative
logistic model is equivalent to the negative logistic model.
Independence is obtained in the limit as either <code class="reqn">r</code>,
<code class="reqn">t_1</code> or <code class="reqn">t_2</code> approaches zero.
Complete dependence is obtained in the limit when
<code class="reqn">t_1 = t_2 = 1</code> and <code class="reqn">r</code>
tends to infinity.
Different limits occur when <code class="reqn">t_1</code> and <code class="reqn">t_2</code>
are fixed and <code class="reqn">r</code> tends to infinity.
The earliest reference to this model appears to be Joe (1990),
who introduces a multivariate extreme value distribution which
reduces to <code class="reqn">G(z_1,z_2)</code> in the bivariate case.
</p>
<p><code>model = "bilog"</code> (Smith, 1990)
</p>
<p>The bilogistic distribution function with
parameters <code class="reqn">\code{alpha} = \alpha</code>
and <code class="reqn">\code{beta} = \beta</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left\{-y_1 q^{1-\alpha} -
    y_2 (1-q)^{1-\beta}\right\}</code>
</p>

<p>where
<code class="reqn">q = q(y_1,y_2;\alpha,\beta)</code>
is the root of the equation
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha) y_1 (1-q)^\beta - (1-\beta) y_2 q^\alpha = 0,</code>
</p>

<p><code class="reqn">0 &lt; \alpha,\beta &lt; 1</code>.
When <code class="reqn">\alpha = \beta</code> the bilogistic model
is equivalent to the logistic model with dependence parameter
<code class="reqn">\code{dep} = \alpha = \beta</code>.
Complete dependence is obtained in the limit as
<code class="reqn">\alpha = \beta</code> approaches zero.
Independence is obtained as
<code class="reqn">\alpha = \beta</code> approaches one, and when
one of <code class="reqn">\alpha,\beta</code> is fixed and the other
approaches one.
Different limits occur when one of
<code class="reqn">\alpha,\beta</code> is fixed and the other
approaches zero.
A bilogistic model is fitted in Smith (1990), where it appears
to have been first introduced.
</p>
<p><code>model = "negbilog"</code> (Coles and Tawn, 1994)
</p>
<p>The negative bilogistic distribution function with
parameters <code class="reqn">\code{alpha} = \alpha</code>
and <code class="reqn">\code{beta} = \beta</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left\{- y_1 - y_2 + y_1 q^{1+\alpha} +
    y_2 (1-q)^{1+\beta}\right\}</code>
</p>

<p>where
<code class="reqn">q = q(y_1,y_2;\alpha,\beta)</code>
is the root of the equation
</p>
<p style="text-align: center;"><code class="reqn">(1+\alpha) y_1 q^\alpha - (1+\beta) y_2 (1-q)^\beta = 0,</code>
</p>

<p><code class="reqn">\alpha &gt; 0</code> and <code class="reqn">\beta &gt; 0</code>.
When <code class="reqn">\alpha = \beta</code> the negative bilogistic
model is equivalent to the negative logistic model with dependence
parameter
<code class="reqn">\code{dep} = 1/\alpha = 1/\beta</code>.
Complete dependence is obtained in the limit as
<code class="reqn">\alpha = \beta</code> approaches zero.
Independence is obtained as
<code class="reqn">\alpha = \beta</code> tends to infinity, and when
one of <code class="reqn">\alpha,\beta</code> is fixed and the other
tends to infinity.
Different limits occur when one of
<code class="reqn">\alpha,\beta</code> is fixed and the other
approaches zero.
</p>
<p><code>model = "ct"</code> (Coles and Tawn, 1991)
</p>
<p>The Coles-Tawn distribution function with
parameters <code class="reqn">\code{alpha} = \alpha &gt; 0</code>
and <code class="reqn">\code{beta} = \beta &gt; 0</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) =
    \exp\left\{-y_1 [1 - \mbox{Be}(q;\alpha+1,\beta)] -
    y_2 \mbox{Be}(q;\alpha,\beta+1) \right\}</code>
</p>

<p>where
<code class="reqn">q = \alpha y_2 / (\alpha y_2 + \beta y_1)</code> and
<code class="reqn">\mbox{Be}(q;\alpha,\beta)</code> is the beta
distribution function evaluated at <code class="reqn">q</code> with
<code class="reqn">\code{shape1} = \alpha</code> and
<code class="reqn">\code{shape2} = \beta</code>.
Complete dependence is obtained in the limit as
<code class="reqn">\alpha = \beta</code> tends to infinity.
Independence is obtained as
<code class="reqn">\alpha = \beta</code> approaches zero, and when
one of <code class="reqn">\alpha,\beta</code> is fixed and the other
approaches zero.
Different limits occur when one of
<code class="reqn">\alpha,\beta</code> is fixed and the other
tends to infinity.
</p>
<p><code>model = "amix"</code> (Tawn, 1988)
</p>
<p>The asymmetric mixed distribution function with
parameters <code class="reqn">\code{alpha} = \alpha</code>
and <code class="reqn">\code{beta} = \beta</code> has
a dependence function with the following cubic polynomial
form.
</p>
<p style="text-align: center;"><code class="reqn">A(t) = 1 - (\alpha +\beta)t + \alpha t^2 + \beta t^3</code>
</p>

<p>where <code class="reqn">\alpha</code> and <code class="reqn">\alpha + 3\beta</code>
are non-negative, and where <code class="reqn">\alpha + \beta</code>
and <code class="reqn">\alpha + 2\beta</code> are less than or equal
to one.
These constraints imply that beta lies in the interval [-0.5,0.5]
and that alpha lies in the interval [0,1.5], though alpha can
only be greater than one if beta is negative. The strength
of dependence increases for increasing alpha (for fixed beta).
Complete dependence cannot be obtained.
Independence is obtained when both parameters are zero.
For the definition of a dependence function, see
<code><a href="#topic+abvevd">abvevd</a></code>.
</p>


<h3>Value</h3>

<p><code>dbvevd</code> gives the density function, <code>pbvevd</code> gives the
distribution function and <code>rbvevd</code> generates random deviates,
for one of nine parametric bivariate extreme value models.
</p>


<h3>Note</h3>

<p>The logistic and asymmetric logistic models respectively are
simulated using bivariate versions of Algorithms 1.1 and 1.2 in
Stephenson(2003).
All other models are simulated using a root finding algorithm
to simulate from the conditional distributions.
</p>
<p>The simulation of the bilogistic and negative bilogistic models
requires a root finding algorithm to evaluate <code class="reqn">q</code>
within the root finding algorithm used to simulate from the
conditional distributions.
The generation of bilogistic and negative bilogistic random
deviates is therefore relatively slow (about 2.8 seconds per
1000 random vectors on a 450MHz PIII, 512Mb RAM).
</p>
<p>The bilogistic and negative bilogistic models can be represented
under a single model, using the integral of the maximum of two
beta distributions (Joe, 1997).
</p>
<p>The Coles-Tawn model is called the Dirichelet model in Coles
and Tawn (1991).
</p>


<h3>References</h3>

<p>Coles, S. G. and Tawn, J. A. (1991)
Modelling extreme multivariate events.
<em>J. Roy. Statist. Soc., B</em>, <b>53</b>, 377&ndash;392.
</p>
<p>Coles, S. G. and Tawn, J. A. (1994)
Statistical methods for multivariate extremes: an application to
structural design (with discussion).
<em>Appl. Statist.</em>, <b>43</b>, 1&ndash;48.
</p>
<p>Galambos, J. (1975)
Order statistics of samples from multivariate distributions.
<em>J. Amer. Statist. Assoc.</em>, <b>70</b>, 674&ndash;680.
</p>
<p>Gumbel, E. J. (1960)
Distributions des valeurs extremes en plusieurs dimensions.
<em>Publ. Inst. Statist. Univ. Paris</em>, <b>9</b>, 171&ndash;173.
</p>
<p>Husler, J. and Reiss, R.-D. (1989)
Maxima of normal random vectors: between independence 
and complete dependence.
<em>Statist. Probab. Letters</em>, <b>7</b>, 283&ndash;286.
</p>
<p>Joe, H. (1990)
Families of min-stable multivariate exponential and multivariate
extreme value distributions.
<em>Statist. Probab. Letters</em>, <b>9</b>, 75&ndash;81.
</p>
<p>Joe, H. (1997)
<em>Multivariate Models and Dependence Concepts</em>,
London: Chapman &amp; Hall.
</p>
<p>Smith, R. L. (1990)
Extreme value theory. In
<em>Handbook of Applicable Mathematics</em> (ed. W. Ledermann),
vol. 7. Chichester: John Wiley, pp. 437&ndash;471.
</p>
<p>Stephenson, A. G. (2003)
Simulating multivariate extreme value distributions of logistic type.
<em>Extremes</em>, <b>6</b>(1), 49&ndash;60.
</p>
<p>Tawn, J. A. (1988)
Bivariate extreme value theory: models and estimation.
<em>Biometrika</em>, <b>75</b>, 397&ndash;415.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvevd">abvevd</a></code>, <code><a href="#topic+rgev">rgev</a></code>, <code><a href="#topic+rmvevd">rmvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pbvevd(matrix(rep(0:4,2), ncol=2), dep = 0.7, model = "log")
pbvevd(c(2,2), dep = 0.7, asy = c(0.6,0.8), model = "alog")
pbvevd(c(1,1), dep = 1.7, model = "hr")

margins &lt;- cbind(0, 1, seq(-0.5,0.5,0.1))
rbvevd(11, dep = 1.7, model = "hr", mar1 = margins)
rbvevd(10, dep = 1.2, model = "neglog", mar1 = c(10, 1, 1))
rbvevd(10, alpha = 0.7, beta = 0.52, model = "bilog")

dbvevd(c(0,0), dep = 1.2, asy = c(0.5,0.9), model = "aneglog")
dbvevd(c(0,0), alpha = 0.75, beta = 0.5, model = "ct", log = TRUE)
dbvevd(c(0,0), alpha = 0.7, beta = 1.52, model = "negbilog")
</code></pre>

<hr>
<h2 id='bvtcplot'>Bivariate Threshold Choice Plot</h2><span id='topic+bvtcplot'></span>

<h3>Description</h3>

<p>Produces a diagnostic plot to assist with threshold choice for
bivariate data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvtcplot(x, spectral = FALSE, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvtcplot_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, ordinarily with two columns,
which may contain missing values.</p>
</td></tr>
<tr><td><code id="bvtcplot_+3A_spectral">spectral</code></td>
<td>
<p>If <code>TRUE</code>, an estimate of the spectral measure is
plotted instead of the diagnostic plot.</p>
</td></tr>
<tr><td><code id="bvtcplot_+3A_ylab">ylab</code>, <code id="bvtcplot_+3A_xlab">xlab</code></td>
<td>
<p>Graphics parameters.</p>
</td></tr>
<tr><td><code id="bvtcplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the plotting
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>spectral</code> is <code>FALSE</code> (the default), produces a threshold
choice plot as illustrated in Beirlant et al. (2004). With <code class="reqn">n</code> 
non-missing bivariate observations, the integers
<code class="reqn">k = 1,\dots,n-1</code> are plotted against the values
<code class="reqn">(k/n)r_{(n-k)}</code>, where <code class="reqn">r_{(n-k)}</code>
is the <code class="reqn">(n-k)</code>th order statistic of the sum of the margins
following empirical transformation to standard Frechet.	
</p>
<p>A vertical line is drawn at <code>k0</code>, where <code>k0</code> is the largest
integer for which the y-axis is above the value two. If <code>spectral</code> 
is <code>FALSE</code>, the largest <code>k0</code> data points are used to plot an
estimate of the spectal measure <code class="reqn">H([0, w])</code> versus <code class="reqn">w</code>.
</p>


<h3>Value</h3>

<p>A list is invisibly returned giving <code>k0</code> and the values used to
produce the plot.
</p>


<h3>References</h3>

<p>Beirlant, J., Goegebeur, Y., Segers, J. and Teugels, J. L. (2004)
<em>Statistics of Extremes: Theory and Applications.</em>,
Chichester, England: John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbvpot">fbvpot</a></code>, <code><a href="#topic+tcplot">tcplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: bvtcplot(lossalae)
## Not run: bvtcplot(lossalae, spectral = TRUE)
</code></pre>

<hr>
<h2 id='ccbvevd'>Calculate Conditional Copulas for Parametric Bivariate Extreme
Value Distributions</h2><span id='topic+ccbvevd'></span>

<h3>Description</h3>

<p>Conditional copula functions, conditioning on either margin,
for nine parametric bivariate extreme value models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccbvevd(x, mar = 2, dep, asy = c(1, 1), alpha, beta, model = c("log", 
    "alog", "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", 
    "amix"), lower.tail = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccbvevd_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, ordinarily with two columns,
which may contain missing values. A data frame may also
contain a third column of mode <code>logical</code>, which
itself may contain missing values (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_mar">mar</code></td>
<td>
<p>One or two; conditions on this margin.</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_dep">dep</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, Husler-Reiss, negative logistic and asymmetric
negative logistic models.</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_asy">asy</code></td>
<td>
<p>A vector of length two, containing the two asymmetry
parameters for the asymmetric logistic and asymmetric negative
logistic models.</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_alpha">alpha</code>, <code id="ccbvevd_+3A_beta">beta</code></td>
<td>
<p>Alpha and beta parameters for the bilogistic,
negative bilogistic, Coles-Tawn and asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric
mixed models respectively.  If parameter arguments are given
that do not correspond to the specified model those arguments
are ignored, with a warning.</p>
</td></tr>
<tr><td><code id="ccbvevd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), the
conditional distribution function is returned; the conditional
survivor function is returned otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates <code class="reqn">P(U_1 &lt; x_1|U_2 = x_2)</code>, where <code class="reqn">(U_1,U_2)</code> is a random 
vector with Uniform(0,1) margins and with a dependence structure 
given by the specified parametric model. By default, the values 
of <code class="reqn">x_1</code> and <code class="reqn">x_1</code> are given by the first and second 
columns of the argument <code>x</code>. If <code>mar = 1</code> then this is 
reversed.
</p>
<p>If <code>x</code> has a third column <code class="reqn">x_3</code> of mode logical, then
the function returns <code class="reqn">P(U_1 &lt; x_1|U_2 = x_2,I = x_3)</code>, according to inference proceedures derived 
by Stephenson and Tawn (2004).
See <code><a href="#topic+fbvevd">fbvevd</a></code>. This requires numerical integration,
and hence will be slower.
</p>
<p>This function is mainly for internal use. It is used by
<code><a href="#topic+plot.bvevd">plot.bvevd</a></code> to calculate the conditional P-P
plotting diagnostics.
</p>


<h3>Value</h3>

<p>A numeric vector of probabilities.
</p>


<h3>References</h3>

<p>Stephenson, A. G. and Tawn, J. A. (2004)
Exploiting Occurence Times in Likelihood Inference for
Componentwise Maxima.
<em>Biometrika</em> <b>92</b>(1), 213&ndash;217.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbvevd">rbvevd</a></code>, <code><a href="#topic+fbvevd">fbvevd</a></code>,
<code><a href="#topic+plot.bvevd">plot.bvevd</a></code></p>

<hr>
<h2 id='chiplot'>Dependence Measure Plots</h2><span id='topic+chiplot'></span>

<h3>Description</h3>

<p>Plots of estimates of the dependence measures chi and chi-bar
for bivariate data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiplot(data, nq = 100, qlim = NULL, which = 1:2, conf = 0.95, trunc =
    TRUE, spcases = FALSE, lty = 1, cilty = 2, col = 1, cicol = 1,
    xlim = c(0,1), ylim1 = c(-1,1), ylim2 = c(-1,1), main1 = "Chi Plot",
    main2 = "Chi Bar Plot", xlab = "Quantile", ylab1 = "Chi", ylab2 =
    "Chi Bar", ask = nb.fig &lt; length(which) &amp;&amp; dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chiplot_+3A_data">data</code></td>
<td>
<p>A matrix or data frame with two columns. Rows
(observations) with missing values are stripped from
the data before any computations are performed.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_nq">nq</code></td>
<td>
<p>The number of quantiles at which the measures
are evaluated.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_qlim">qlim</code></td>
<td>
<p>The limits of the quantiles at which the measures
are evaluated (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="chiplot_+3A_which">which</code></td>
<td>
<p>If only one plot is required, specify <code>1</code>
for chi and <code>2</code> for chi-bar.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_conf">conf</code></td>
<td>
<p>The confidence coefficient of the plotted confidence
intervals.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_trunc">trunc</code></td>
<td>
<p>Logical; truncate the estimates at their theoretical
upper and lower bounds?</p>
</td></tr>
<tr><td><code id="chiplot_+3A_spcases">spcases</code></td>
<td>
<p>If <code>TRUE</code>, plots greyed lines corresponding
to the special cases of perfect positive/negative dependence
and exact independence.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_lty">lty</code>, <code id="chiplot_+3A_cilty">cilty</code></td>
<td>
<p>Line types for the estimates of the measures and
for the confidence intervals respectively. Use zero to supress.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_col">col</code>, <code id="chiplot_+3A_cicol">cicol</code></td>
<td>
<p>Colour types for the estimates of the measures
and for the confidence intervals respectively.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_xlim">xlim</code>, <code id="chiplot_+3A_xlab">xlab</code></td>
<td>
<p>Limits and labels for the x-axis; they apply
to both plots.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_ylim1">ylim1</code></td>
<td>
<p>Limits for the y-axis of the chi plot. If this
is <code>NULL</code> (the default) the upper limit is one, and the
lower limit is the minimum of zero and the smallest plotted
value.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_ylim2">ylim2</code></td>
<td>
<p>Limits for the y-axis of the chi-bar plot.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_main1">main1</code>, <code id="chiplot_+3A_main2">main2</code></td>
<td>
<p>The plot titles for the chi and chi-bar plots
respectively.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_ylab1">ylab1</code>, <code id="chiplot_+3A_ylab2">ylab2</code></td>
<td>
<p>The y-axis labels for the chi and chi-bar plots
respectively.</p>
</td></tr> 
<tr><td><code id="chiplot_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="chiplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>matplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These measures are explained in full detail in Coles, Heffernan
and Tawn (1999). A brief treatment is also given in Section
8.4 of Coles(2001).
A short summary is given as follows.
We assume that the data are <em>iid</em> random vectors with common
bivariate distribution function <code class="reqn">G</code>, and we define the random
vector <code class="reqn">(X,Y)</code> to be distributed according to <code class="reqn">G</code>.
</p>
<p>The chi plot is a plot of <code class="reqn">q</code> against empirical estimates of
</p>
<p style="text-align: center;"><code class="reqn">\chi(q) = 2 - \log(\Pr(F_X(X) &lt; q, F_Y(Y) &lt; q)) / \log(q)</code>
</p>

<p>where <code class="reqn">F_X</code> and <code class="reqn">F_Y</code> are the marginal distribution
functions, and where <code class="reqn">q</code> is in the interval (0,1).
The quantity <code class="reqn">\chi(q)</code> is bounded by
</p>
<p style="text-align: center;"><code class="reqn">2 - \log(2u - 1)/\log(u) \leq \chi(q) \leq 1</code>
</p>

<p>where the lower bound is interpreted as <code>-Inf</code> for
<code class="reqn">q \leq 1/2</code> and zero for <code class="reqn">q = 1</code>.
These bounds are reflected in the corresponding estimates.
</p>
<p>The chi bar plot is a plot of <code class="reqn">q</code> against empirical estimates of
</p>
<p style="text-align: center;"><code class="reqn">\bar{\chi}(q) = 2\log(1-q)/\log(\Pr(F_X(X) &gt; q, F_Y(Y) &gt; q)) - 1</code>
</p>

<p>where <code class="reqn">F_X</code> and <code class="reqn">F_Y</code> are the marginal distribution
functions, and where <code class="reqn">q</code> is in the interval (0,1).
The quantity <code class="reqn">\bar{\chi}(q)</code> is bounded by
<code class="reqn">-1 \leq \bar{\chi}(q) \leq 1</code>
and these bounds are reflected in the corresponding estimates.
</p>
<p>Note that the empirical estimators for <code class="reqn">\chi(q)</code> and
<code class="reqn">\bar{\chi}(q)</code> are undefined near <code class="reqn">q=0</code> and <code class="reqn">q=1</code>. By
default the function takes the limits of <code class="reqn">q</code> so that the plots
depicts all values at which the estimators are defined. This can be
overridden by the argument <code>qlim</code>, which must represent a subset
of the default values (and these can be determined using the
component <code>quantile</code> of the invisibly returned list; see
<b>Value</b>).
</p>
<p>The confidence intervals within the plot assume that observations are
independent, and that the marginal distributions are estimated exactly.
The intervals are constructed using the delta method; this may
lead to poor interval estimates near <code class="reqn">q=0</code> and <code class="reqn">q=1</code>.
</p>
<p>The function <code class="reqn">\chi(q)</code> can be interpreted as a quantile
dependent measure of dependence. In particular, the sign of
<code class="reqn">\chi(q)</code> determines whether the variables are positively
or negatively associated at quantile level <code class="reqn">q</code>.
By definition, variables are said to be asymptotically independent
when <code class="reqn">\chi(1)</code> (defined in the limit) is zero.
For independent variables, <code class="reqn">\chi(q) = 0</code> for all
<code class="reqn">q</code> in (0,1).
For perfectly dependent variables, <code class="reqn">\chi(q) = 1</code>
for all <code class="reqn">q</code> in (0,1).
For bivariate extreme value distributions, <code class="reqn">\chi(q) =
    2(1-A(1/2))</code>
for all <code class="reqn">q</code> in (0,1), where <code class="reqn">A</code> is the dependence function,
as defined in <code><a href="#topic+abvevd">abvevd</a></code>. If a bivariate threshold model
is to be fitted (using <code><a href="#topic+fbvpot">fbvpot</a></code>), this plot can therefore
act as a threshold identification plot, since e.g. the use of 95%
marginal quantiles as threshold values implies that <code class="reqn">\chi(q)</code>
should be approximately constant above <code class="reqn">q = 0.95</code>.
</p>
<p>The function <code class="reqn">\bar{\chi}(q)</code> can again be interpreted
as a quantile dependent measure of dependence; it is most useful
within the class of asymptotically independent variables.
For asymptotically dependent variables (i.e. those for which
<code class="reqn">\chi(1) &lt; 1</code>), we have <code class="reqn">\bar{\chi}(1) = 1</code>, where
<code class="reqn">\bar{\chi}(1)</code> is again defined in the limit.
For asymptotically independent variables, <code class="reqn">\bar{\chi}(1)</code> provides a measure that increases with dependence strength.
For independent variables <code class="reqn">\bar{\chi}(q) = 0</code> for
all <code class="reqn">q</code> in (0,1), and hence <code class="reqn">\bar{\chi}(1) = 0</code>.
</p>


<h3>Value</h3>

<p>A list with components <code>quantile</code>, <code>chi</code> (if <code>1</code> is in
<code>which</code>) and <code>chibar</code> (if <code>2</code> is in <code>which</code>)
is invisibly returned.
The components <code>quantile</code> and <code>chi</code> contain those objects
that were passed to the formal arguments <code>x</code> and <code>y</code> of
<code>matplot</code> in order to create the chi plot.
The components <code>quantile</code> and <code>chibar</code> contain those objects
that were passed to the formal arguments <code>x</code> and <code>y</code> of
<code>matplot</code> in order to create the chi-bar plot.
</p>


<h3>Author(s)</h3>

<p>Jan Heffernan and Alec Stephenson</p>


<h3>References</h3>

<p>Coles, S. G., Heffernan, J. and Tawn, J. A. (1999)
Dependence measures for extreme value analyses.
<em>Extremes</em>, <b>2</b>, 339&ndash;365.
</p>
<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of Extreme Values</em>,
London: Springer&ndash;Verlag.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbvevd">fbvevd</a></code>, <code><a href="#topic+fbvpot">fbvpot</a></code>,
<code><a href="graphics.html#topic+matplot">matplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow = c(1,2))
smdat1 &lt;- rbvevd(1000, dep = 0.6, model = "log")
smdat2 &lt;- rbvevd(1000, dep = 1, model = "log")
chiplot(smdat1)
chiplot(smdat2)
</code></pre>

<hr>
<h2 id='clusters'>Identify Clusters of Exceedences</h2><span id='topic+clusters'></span>

<h3>Description</h3>

<p>Identify clusters of exceedences. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters(data, u, r = 1, ulow = -Inf, rlow = 1, cmax = FALSE, keep.names
    = TRUE, plot = FALSE, xdata = seq(along = data), lvals = TRUE, lty =
    1, lwd = 1, pch = par("pch"), col = if(n &gt; 250) NULL else "grey",
    xlab = "Index", ylab = "Data", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_+3A_data">data</code></td>
<td>
<p>A numeric vector, which may contain missing values.</p>
</td></tr>
<tr><td><code id="clusters_+3A_u">u</code></td>
<td>
<p>A single value giving the threshold, unless a time varying
threshold is used, in which case <code>u</code> should be a vector of
thresholds, typically with the same length as <code>data</code> (or else
the usual recycling rules are applied).</p>
</td></tr>
<tr><td><code id="clusters_+3A_r">r</code></td>
<td>
<p>A postive integer denoting the clustering interval
length. By default the interval length is one.</p>
</td></tr>
<tr><td><code id="clusters_+3A_ulow">ulow</code></td>
<td>
<p>A single value giving the lower threshold, unless a time
varying lower threshold is used, in which case <code>ulow</code> should
be a vector of lower thresholds, typically with the same length as
<code>data</code> (or else the usual recycling rules are applied).
By default there is no lower threshold (or equivalently, the
lower threshold is <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="clusters_+3A_rlow">rlow</code></td>
<td>
<p>A postive integer denoting the lower clustering interval
length. By default the interval length is one.</p>
</td></tr>
<tr><td><code id="clusters_+3A_cmax">cmax</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default), a list
containing the clusters of exceedences is returned. If
<code>TRUE</code> a numeric vector containing the cluster maxima
is returned.</p>
</td></tr>
<tr><td><code id="clusters_+3A_keep.names">keep.names</code></td>
<td>
<p>Logical; if <code>FALSE</code>, the function makes
no attempt to retain the names/indices of the observations
within the returned object. If <code>data</code> contains a large
number of observations, this can make the function run much
faster. The argument is mainly designed for internal use.</p>
</td></tr>
<tr><td><code id="clusters_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code> a plot is given that depicts
the identified clusters, and the clusters (if <code>cmax</code> is
<code>FALSE</code>) or cluster maxima (if <code>cmax</code> is <code>TRUE</code>)
are returned invisibly. If <code>FALSE</code> (the default), the
following arguments are ignored.</p>
</td></tr>
<tr><td><code id="clusters_+3A_xdata">xdata</code></td>
<td>
<p>A numeric vector with the same length as <code>data</code>,
giving the values to be plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="clusters_+3A_lvals">lvals</code></td>
<td>
<p>Logical; should the values below the threshold and
the line depicting the lower threshold be plotted?</p>
</td></tr>
<tr><td><code id="clusters_+3A_lty">lty</code>, <code id="clusters_+3A_lwd">lwd</code></td>
<td>
<p>Line type and width for the lines depicting the
threshold and the lower threshold.</p>
</td></tr>
<tr><td><code id="clusters_+3A_pch">pch</code></td>
<td>
<p>Plotting character.</p>
</td></tr>
<tr><td><code id="clusters_+3A_col">col</code></td>
<td>
<p>Strips of colour <code>col</code> are used to identify the
clusters. An observation is contained in the cluster if the 
centre of the corresponding plotting character is contained
in the coloured strip. If <code>col</code> is <code>NULL</code> the strips
are omitted. By default the strips are coloured <code>"grey"</code>,
but are omitted whenever <code>data</code> contains more than 250
observations.</p>
</td></tr>
<tr><td><code id="clusters_+3A_xlab">xlab</code>, <code id="clusters_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the x and y axis.</p>
</td></tr>
<tr><td><code id="clusters_+3A_...">...</code></td>
<td>
<p>Other graphics parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clusters of exceedences are identified as follows.
The first exceedence of the threshold initiates the first cluster.
The first cluster then remains active until either <code>r</code>
consecutive values fall below (or are equal to) the threshold,
or until <code>rlow</code> consecutive values fall below (or are equal
to) the lower threshold.
The next exceedence of the threshold (if it exists) then initiates
the second cluster, and so on.
Missing values are allowed, in which case they are treated as
falling below (or equal to) the threshold, but falling above the
lower threshold.
</p>


<h3>Value</h3>

<p>If <code>cmax</code> is <code>FALSE</code> (the default), a list with one
component for each identified cluster.
If <code>cmax</code> is <code>TRUE</code>, a numeric vector containing the
cluster maxima.
In any case, the returned object has an attribute <code>acs</code>,
giving the average cluster size (where the cluster size is
defined as the number of exceedences within a cluster), which
will be <code>NaN</code> if there are no values above the threshold
(and hence no clusters).
</p>
<p>If <code>plot</code> is <code>TRUE</code>, the list of clusters, or vector
of cluster maxima, is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exi">exi</a></code>, <code><a href="#topic+exiplot">exiplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters(portpirie, 4.2, 3)
clusters(portpirie, 4.2, 3, cmax = TRUE)
clusters(portpirie, 4.2, 3, 3.8, plot = TRUE)
clusters(portpirie, 4.2, 3, 3.8, plot = TRUE, lvals = FALSE)
tvu &lt;- c(rep(4.2, 20), rep(4.1, 25), rep(4.2, 20))
clusters(portpirie, tvu, 3, plot = TRUE)
</code></pre>

<hr>
<h2 id='confint.evd'>Calculate Confidence Intervals</h2><span id='topic+confint.evd'></span><span id='topic+confint.profile.evd'></span>

<h3>Description</h3>

<p>Calculate profile and Wald confidence intervals of parameters
in fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evd'
confint(object, parm, level = 0.95, ...)
## S3 method for class 'profile.evd'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.evd_+3A_object">object</code></td>
<td>
<p>Either a fitted model object (of class <code>evd</code>)
for Wald confidence intervals, or a profile trace (of class
<code>profile.evd</code>) for profile likelihood confidence intervals.</p>
</td></tr> 
<tr><td><code id="confint.evd_+3A_parm">parm</code></td>
<td>
<p>A character vector of parameters; a confidence
interval is calculated for each parameter. If missing, then
intervals are returned for all parameters in the fitted model
or profile trace.</p>
</td></tr>
<tr><td><code id="confint.evd_+3A_level">level</code></td>
<td>
<p>A single number giving the confidence level.</p>
</td></tr>
<tr><td><code id="confint.evd_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns giving lower and upper confidence
limits.
</p>
<p>For profile confidence intervals, this function assumes that the 
profile trace is unimodal. If the profile trace is not unimodal then
the function will give spurious results.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.evd">profile.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- fgev(portpirie)
confint(m1)
## Not run: pm1 &lt;- profile(m1)
## Not run: plot(pm1)
## Not run: confint(pm1)
</code></pre>

<hr>
<h2 id='evd-internal'>Internal Functions</h2><span id='topic+abvalog'></span><span id='topic+abvaneglog'></span><span id='topic+abvhr'></span><span id='topic+abvlog'></span><span id='topic+abvneglog'></span><span id='topic+abvbilog'></span><span id='topic+abvnegbilog'></span><span id='topic+abvct'></span><span id='topic+abvamix'></span><span id='topic+hbvalog'></span><span id='topic+hbvaneglog'></span><span id='topic+hbvhr'></span><span id='topic+hbvlog'></span><span id='topic+hbvneglog'></span><span id='topic+hbvbilog'></span><span id='topic+hbvnegbilog'></span><span id='topic+hbvct'></span><span id='topic+hbvamix'></span><span id='topic+rbvlog'></span><span id='topic+rbvalog'></span><span id='topic+rbvhr'></span><span id='topic+rbvneglog'></span><span id='topic+rbvaneglog'></span><span id='topic+rbvbilog'></span><span id='topic+rbvnegbilog'></span><span id='topic+rbvct'></span><span id='topic+rbvamix'></span><span id='topic+dbvlog'></span><span id='topic+dbvalog'></span><span id='topic+dbvhr'></span><span id='topic+dbvneglog'></span><span id='topic+dbvaneglog'></span><span id='topic+dbvbilog'></span><span id='topic+dbvnegbilog'></span><span id='topic+dbvct'></span><span id='topic+dbvamix'></span><span id='topic+pbvlog'></span><span id='topic+pbvalog'></span><span id='topic+pbvhr'></span><span id='topic+pbvneglog'></span><span id='topic+pbvaneglog'></span><span id='topic+pbvbilog'></span><span id='topic+pbvnegbilog'></span><span id='topic+pbvct'></span><span id='topic+pbvamix'></span><span id='topic+amvalog'></span><span id='topic+amvlog'></span><span id='topic+rmvlog'></span><span id='topic+rmvalog'></span><span id='topic+pmvlog'></span><span id='topic+pmvalog'></span><span id='topic+dmvlog'></span><span id='topic+dmvalog'></span><span id='topic+tvdepfn'></span><span id='topic+mvalog.check'></span><span id='topic+subsets'></span><span id='topic+fgev.quantile'></span><span id='topic+fgev.norm'></span><span id='topic+fpot.quantile'></span><span id='topic+fpot.norm'></span><span id='topic+fbvlog'></span><span id='topic+fbvalog'></span><span id='topic+fbvhr'></span><span id='topic+fbvneglog'></span><span id='topic+fbvaneglog'></span><span id='topic+fbvbilog'></span><span id='topic+fbvnegbilog'></span><span id='topic+fbvct'></span><span id='topic+fbvamix'></span><span id='topic+fbvcpot'></span><span id='topic+fbvclog'></span><span id='topic+fbvcalog'></span><span id='topic+fbvcaneglog'></span><span id='topic+fbvcbilog'></span><span id='topic+fbvcct'></span><span id='topic+fbvcnegbilog'></span><span id='topic+fbvcneglog'></span><span id='topic+fbvchr'></span><span id='topic+fbvcamix'></span><span id='topic+fbvppot'></span><span id='topic+fbvplog'></span><span id='topic+fbvpbilog'></span><span id='topic+fbvpct'></span><span id='topic+fbvpnegbilog'></span><span id='topic+fbvpneglog'></span><span id='topic+fbvphr'></span><span id='topic+bvpost.optim'></span><span id='topic+bvstart.vals'></span><span id='topic+sep.bvdata'></span><span id='topic+dens'></span><span id='topic+pp'></span><span id='topic+qq'></span><span id='topic+rl'></span><span id='topic+dens.gev'></span><span id='topic+pp.gev'></span><span id='topic+qq.gev'></span><span id='topic+rl.gev'></span><span id='topic+dens.pot'></span><span id='topic+pp.pot'></span><span id='topic+qq.pot'></span><span id='topic+rl.pot'></span><span id='topic+dens.gumbelx'></span><span id='topic+pp.gumbelx'></span><span id='topic+qq.gumbelx'></span><span id='topic+rl.gumbelx'></span><span id='topic+bvcpp'></span><span id='topic+bvdens'></span><span id='topic+bvdp'></span><span id='topic+bvqc'></span><span id='topic+bvh'></span><span id='topic+bvcpp.bvevd'></span><span id='topic+bvdens.bvevd'></span><span id='topic+bvdp.bvevd'></span><span id='topic+bvqc.bvevd'></span><span id='topic+bvh.bvevd'></span><span id='topic+bvdens.bvpot'></span><span id='topic+bvdp.bvpot'></span><span id='topic+bvqc.bvpot'></span><span id='topic+bvh.bvpot'></span>

<h3>Description</h3>

<p>The evd package contains many internal functions that are not
designed to be called by the user.
</p>
<p>Plotting: The generic functions <code>dens</code>, <code>pp</code>, <code>qq</code>
and <code>rl</code> create the diagnostic plots generated by
<code>plot.uvevd</code>. Similarly, <code>bvdens</code>, <code>bvcpp</code>,
<code>bvdp</code>, <code>bvqc</code> and <code>bvh</code> create the diagnostic
plots generated by <code>plot.bvevd</code> and <code>plot.bvpot</code>.
</p>
<p>Distribution: There are internal, simulation, distribution,
density, dependence and spectral density functions for separate
bivariate and multivariate parametric models, which are called from
functions such as <code>abvevd</code> and <code>pmvevd</code>.
Additionally, the three functions <code>mvalog.check</code> (checks and
transforms asymmetry parameters), <code>subsets</code> (generates all
subsets of a set) and <code>tvdepfn</code> (plots trivariate dependence
functions) are called from functions associated with multivariate
distributions.
</p>
<p>Univariate Fitting: The fitting function <code>fgev</code> calls the
internal functions <code>fgev.quantile</code> and <code>fgev.norm</code> for
fits under different parameterizations. The fitting function
<code>fpot</code> calls the internal functions <code>fpot.norm</code> and
<code>fpot.quantile</code>.
</p>
<p>Bivariate Fitting: For fitting bivariate distributions, internal
functions exist for each model. For fitting bivariate threshold
models, internal functions exist for the censored and
(undocumented) point process likelihoods, and each of these calls
a further internal function corresponding to the specified model.
The functions <code>bvpost.optim</code> (post-optimisation processing),
<code>bvstart.vals</code> (starting values) and <code>sep.bvdata</code>
(separation of data) are additionally used in the fitting of
bivariate distributions and bivariate threshold models.
</p>

<hr>
<h2 id='evind.test'>Perform Hypothesis Test Of Independence</h2><span id='topic+evind.test'></span>

<h3>Description</h3>

<p>Perform score and likelihood ratio tests of independence for
bivariate data, assuming a logistic dependence model as the
alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evind.test(x, method = c("ratio", "score"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evind.test_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, ordinarily with two columns,
which may contain missing values.</p>
</td></tr>
<tr><td><code id="evind.test_+3A_method">method</code></td>
<td>
<p>The test methodology; either <code>"ratio"</code> for
the likelihood ratio test or <code>"score"</code> for the score test.</p>
</td></tr>
<tr><td><code id="evind.test_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, shows estimates of the marginal 
parameters in addition to the dependence parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple function fits a stationary bivariate logistic model to the
data and performs a hypothesis test of <code class="reqn">\code{dep} = 1</code> versus
<code class="reqn">\code{dep} &lt; 1</code> using the methodology in Tawn (1988). The null 
distributions for the printed test statistics are chi-squared on one
df for the likelihood ratio test, and standard normal for the score 
test.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code>.
</p>


<h3>References</h3>

<p>Tawn, J. A. (1988)
Bivariate extreme value theory: models and estimation.
<em>Biometrika</em>, <b>75</b>, 397&ndash;415.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbvevd">fbvevd</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>evind.test(sealevel)
evind.test(sealevel, method = "score")
</code></pre>

<hr>
<h2 id='evmc'>Simulate Markov Chains With Extreme Value
Dependence Structures</h2><span id='topic+evmc'></span>

<h3>Description</h3>

<p>Simulation of first order Markov chains, such that each pair
of consecutive values has the dependence structure of one of
nine parametric bivariate extreme value distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evmc(n, dep, asy = c(1,1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
    margins = c("uniform","rweibull","frechet","gumbel"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evmc_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="evmc_+3A_dep">dep</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, Husler-Reiss, negative logistic and asymmetric
negative logistic models.</p>
</td></tr>
<tr><td><code id="evmc_+3A_asy">asy</code></td>
<td>
<p>A vector of length two, containing the two asymmetry
parameters for the asymmetric logistic and asymmetric negative
logistic models.</p>
</td></tr>
<tr><td><code id="evmc_+3A_alpha">alpha</code>, <code id="evmc_+3A_beta">beta</code></td>
<td>
<p>Alpha and beta parameters for the bilogistic,
negative bilogistic, Coles-Tawn and asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="evmc_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric mixed
models respectively. The definition of each model is given in
<code><a href="#topic+rbvevd">rbvevd</a></code>. If parameter arguments are given that do
not correspond to the specified model those arguments are
ignored, with a warning.</p>
</td></tr>
<tr><td><code id="evmc_+3A_margins">margins</code></td>
<td>
<p>The marginal distribution of each value; a
character string. Must be either <code>"uniform"</code> (the
default), <code>"rweibull"</code>, <code>"frechet"</code> or
<code>"gumbel"</code> (or any unique partial match), for the uniform,
standard reverse Weibull, standard Gumbel and standard Frechet
distributions respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marma">marma</a></code>, <code><a href="#topic+rbvevd">rbvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>evmc(100, alpha = 0.1, beta = 0.1, model = "bilog")
evmc(100, dep = 10, model = "hr", margins = "gum")
</code></pre>

<hr>
<h2 id='exi'>Estimates of the Extremal Index</h2><span id='topic+exi'></span>

<h3>Description</h3>

<p>Estimates of the extremal index. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exi(data, u, r = 1, ulow = -Inf, rlow = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exi_+3A_data">data</code></td>
<td>
<p>A numeric vector, which may contain missing values.</p>
</td></tr>
<tr><td><code id="exi_+3A_u">u</code></td>
<td>
<p>A single value giving the threshold, unless a time varying
threshold is used, in which case <code>u</code> should be a vector of
thresholds, typically with the same length as <code>data</code> (or else
the usual recycling rules are applied).</p>
</td></tr>
<tr><td><code id="exi_+3A_r">r</code></td>
<td>
<p>Either a postive integer denoting the clustering interval
length, or zero, in which case the intervals estimator of
Ferro and Segers (2003) is used and following arguments are
ignored. By default the interval length is one.</p>
</td></tr>
<tr><td><code id="exi_+3A_ulow">ulow</code></td>
<td>
<p>A single value giving the lower threshold, unless a time
varying lower threshold is used, in which case <code>ulow</code> should
be a vector of lower thresholds, typically with the same length as
<code>data</code> (or else the usual recycling rules are applied).
By default there is no lower threshold (or equivalently, the
lower threshold is <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="exi_+3A_rlow">rlow</code></td>
<td>
<p>A postive integer denoting the lower clustering interval
length. By default the interval length is one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>r</code> is a positive integer the extremal index is estimated
using the inverse of the average cluster size, using the clusters
of exceedences derived from <code><a href="#topic+clusters">clusters</a></code>. If <code>r</code> is
zero, an estimate based on inter-exceedance times is used (Ferro
and Segers, 2003).
</p>
<p>If there are no exceedances of the threshold, the estimate is
<code>NaN</code>. If there is only one exceedance, the estimate is
one.
</p>


<h3>Value</h3>

<p>A single value estimating the extremal index.
</p>


<h3>References</h3>

<p>Ferro, C. A. T. and Segers, J. (2003)
Inference for clusters of extreme values.
<em>JRSS B</em>, <b>65</b>, 545&ndash;556.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusters">clusters</a></code>, <code><a href="#topic+exiplot">exiplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>exi(portpirie, 4.2, r = 3, ulow = 3.8)
tvu &lt;- c(rep(4.2, 20), rep(4.1, 25), rep(4.2, 20))
exi(portpirie, tvu, r = 1)
exi(portpirie, tvu, r = 0)
</code></pre>

<hr>
<h2 id='exiplot'>Plot Estimates of the Extremal Index</h2><span id='topic+exiplot'></span>

<h3>Description</h3>

<p>Plots estimates of the extremal index. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exiplot(data, tlim, r = 1, ulow = -Inf, rlow = 1, add = FALSE, 
    nt = 100, lty = 1, xlab = "Threshold", ylab = "Ext. Index",
    ylim = c(0,1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exiplot_+3A_data">data</code></td>
<td>
<p>A numeric vector, which may contain missing values.</p>
</td></tr>
<tr><td><code id="exiplot_+3A_tlim">tlim</code></td>
<td>
<p>A numeric vector of length two, giving the limits for
the (time invariant) thresholds at which the estimates are
evaluated.</p>
</td></tr>
<tr><td><code id="exiplot_+3A_r">r</code>, <code id="exiplot_+3A_ulow">ulow</code>, <code id="exiplot_+3A_rlow">rlow</code></td>
<td>
<p>The estimation method. See <code><a href="#topic+exi">exi</a></code>.</p>
</td></tr>
<tr><td><code id="exiplot_+3A_add">add</code></td>
<td>
<p>Add to an existing plot?</p>
</td></tr>
<tr><td><code id="exiplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the estimates are
evaluated.</p>
</td></tr>
<tr><td><code id="exiplot_+3A_lty">lty</code></td>
<td>
<p>Line type.</p>
</td></tr>     
<tr><td><code id="exiplot_+3A_xlab">xlab</code>, <code id="exiplot_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels.</p>
</td></tr>
<tr><td><code id="exiplot_+3A_ylim">ylim</code></td>
<td>
<p>y axis limits.</p>
</td></tr> 
<tr><td><code id="exiplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>plot</code> or
<code>lines</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates are calculated using the function <code><a href="#topic+exi">exi</a></code>.
</p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code> is invisibly returned.
The first component contains the thresholds, the second contains the
estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusters">clusters</a></code>, <code><a href="#topic+exi">exi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sdat &lt;- mar(100, psi = 0.5)
tlim &lt;- quantile(sdat, probs = c(0.4,0.9))
exiplot(sdat, tlim)
exiplot(sdat, tlim, r = 4, add = TRUE, lty = 2)
exiplot(sdat, tlim, r = 0, add = TRUE, lty = 4)
</code></pre>

<hr>
<h2 id='extreme'>Distributions of Maxima and Minima</h2><span id='topic+dextreme'></span><span id='topic+pextreme'></span><span id='topic+qextreme'></span><span id='topic+rextreme'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the maximum/minimum of a given number of
independent variables from a specified distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dextreme(x, densfun, distnfun, ..., distn, mlen = 1, largest = TRUE,
    log = FALSE)
pextreme(q, distnfun, ..., distn, mlen = 1, largest = TRUE,
    lower.tail = TRUE) 
qextreme(p, quantfun, ..., distn, mlen = 1, largest = TRUE,
    lower.tail = TRUE) 
rextreme(n, quantfun, ..., distn, mlen = 1, largest = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme_+3A_x">x</code>, <code id="extreme_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="extreme_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="extreme_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="extreme_+3A_densfun">densfun</code>, <code id="extreme_+3A_distnfun">distnfun</code>, <code id="extreme_+3A_quantfun">quantfun</code></td>
<td>
<p>Density, distribution and
quantile function of the specified distribution. The density
function must have a <code>log</code> argument (a simple wrapper
can always be constructed to achieve this).</p>
</td></tr>
<tr><td><code id="extreme_+3A_...">...</code></td>
<td>
<p>Parameters of the specified distribution.</p>
</td></tr>
<tr><td><code id="extreme_+3A_distn">distn</code></td>
<td>
<p>A character string, optionally given as an
alternative to <code>densfun</code>, <code>distnfun</code> and <code>quantfun</code>
such that the density, distribution and quantile functions are
formed upon the addition of the prefixes <code>d</code>, <code>p</code> and
<code>q</code> respectively.</p>
</td></tr>
<tr><td><code id="extreme_+3A_mlen">mlen</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="extreme_+3A_largest">largest</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) use maxima,
otherwise minima.</p>
</td></tr>
<tr><td><code id="extreme_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="extreme_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) probabilities
are P[X &lt;= x], otherwise  P[X &gt; x].</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dextreme</code> gives the density function, <code>pextreme</code> gives the
distribution function and <code>qextreme</code> gives the quantile function
of the maximum/minimum of <code>mlen</code> independent variables from
a specified distibution. <code>rextreme</code> generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgev">rgev</a></code>, <code><a href="#topic+rorder">rorder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dextreme(2:4, dnorm, pnorm, mean = 0.5, sd = 1.2, mlen = 5)
dextreme(2:4, distn = "norm", mean = 0.5, sd = 1.2, mlen = 5)
dextreme(2:4, distn = "exp", mlen = 2, largest = FALSE)
pextreme(2:4, distn = "exp", rate = 1.2, mlen = 2)
qextreme(seq(0.9, 0.6, -0.1), distn = "exp", rate = 1.2, mlen = 2)
rextreme(5, qgamma, shape = 1, mlen = 10)
p &lt;- (1:9)/10
pexp(qextreme(p, distn = "exp", rate = 1.2, mlen = 1), rate = 1.2)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='failure'>Failure Times</h2><span id='topic+failure'></span>

<h3>Description</h3>

<p>Failure times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>failure</code></pre>


<h3>Format</h3>

<p>A vector containing 24 observations.</p>


<h3>Source</h3>

<p>van Montfort, M. A. J. and Otten, A. (1978)
On testing a shape parameter in the presence of a scale
parameter.
<em>Math. Operations Forsch. Statist., Ser. Statistics</em>,
<b>9</b>, 91&ndash;104.
</p>

<hr>
<h2 id='fbvevd'>Maximum-likelihood Fitting of Bivariate Extreme Value Distributions</h2><span id='topic+fbvevd'></span><span id='topic+print.bvevd'></span>

<h3>Description</h3>

<p>Fit models for one of nine parametric bivariate extreme value
distributions, including linear modelling of the marginal
location parameters, and allowing any of the parameters to be held
fixed if desired. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbvevd(x, model = c("log", "alog", "hr", "neglog", "aneglog", "bilog",
    "negbilog", "ct", "amix"), start, ..., sym = FALSE,
    nsloc1 = NULL, nsloc2 = NULL, cshape = cscale, cscale = cloc,
    cloc = FALSE, std.err = TRUE, corr = FALSE, method = "BFGS",
    warn.inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbvevd_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, ordinarily with two columns,
which may contain missing values. A data frame may also
contain a third column of mode <code>logical</code>, which
itself may contain missing values (see <b>More Details</b>).</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric
mixed models respectively. The definition of each model is
given in <code><a href="#topic+rbvevd">rbvevd</a></code>.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.
If <code>start</code> is omitted the routine attempts to find good
starting values using marginal maximum likelihood estimators.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the bivariate extreme
value model or for the optimization function <code>optim</code>. If
parameters of the model are included they will be held fixed at
the values given (see <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_sym">sym</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the dependence structure
of the models <code>"alog"</code>, <code>"aneglog"</code> or <code>"ct"</code> are
constrained to be symmetric (see <b>Details</b>). For all other
models, the argument is ignored (and a warning is given).</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_nsloc1">nsloc1</code>, <code id="fbvevd_+3A_nsloc2">nsloc2</code></td>
<td>
<p>A data frame with the same number of rows as
<code>x</code>, for linear modelling of the location parameter on the
first/second margin (see <b>Details</b>).
The data frames are treated as covariate matrices, excluding the
intercept. A numeric vector can be given as an alternative to a
single column data frame.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_cshape">cshape</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a common shape parameter is
fitted to each margin.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_cscale">cscale</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a common scale parameter is
fitted to each margin, and the default value of <code>cshape</code>
is then <code>TRUE</code>, so that under this default common scale
and shape parameters are fitted.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_cloc">cloc</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a common location parameter is
fitted to each margin, and the default values of <code>cshape</code>
and <code>cscale</code> are then <code>TRUE</code>, so that under these
defaults common marginal parameters are fitted.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="fbvevd_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), a warning is
given if the negative log-likelihood is infinite when evaluated at
the starting values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence parameter names are one or more of <code>dep</code>,
<code>asy1</code>, <code>asy2</code>, <code>alpha</code> and <code>beta</code>, depending on
the model selected (see <code><a href="#topic+rbvevd">rbvevd</a></code>).  The marginal parameter
names are <code>loc1</code>, <code>scale1</code> and <code>shape1</code> for the first
margin, and <code>loc2</code>, <code>scale2</code> and <code>shape2</code> for the
second margin.
If <code>nsloc1</code> is not <code>NULL</code>, so that a linear model is
implemented for the first marginal location parameter, the parameter
names for the first margin are <code>loc1</code>, <code>loc1</code><em>x1</em>,
..., <code>loc1</code><em>xn</em>, <code>scale</code> and <code>shape</code>, where
<em>x1</em>, ..., <em>xn</em> are the column names of <code>nsloc1</code>,
so that <code>loc1</code> is the intercept of the linear model, and
<code>loc1</code><em>x1</em>, ..., <code>loc1</code><em>xn</em> are the
<code>ncol(nsloc1)</code> coefficients.
When <code>nsloc2</code> is not <code>NULL</code>, the parameter names for the
second margin are constructed similarly.
</p>
<p>It is recommended that the covariates within the linear models for
the location parameters are (at least approximately) centered and
scaled (i.e. that the columns of <code>nsloc1</code> and <code>nsloc2</code>
are centered and scaled), particularly if automatic starting values
are used, since the starting values for the associated parameters are
then zero. If <code>cloc</code> is <code>TRUE</code>, both <code>nsloc1</code> and
<code>nsloc2</code> must be identical, since a common linear model is
then implemented on both margins.
</p>
<p>If <code>cshape</code> is true, the models are constrained so that
<code>shape2 = shape1</code>. The parameter <code>shape2</code> is then
taken to be specified, so that e.g. the common shape
parameter can only be fixed at zero using <code>shape1 = 0</code>,
since using <code>shape2 = 0</code> gives an error. Similar
comments apply for <code>cscale</code> and <code>cloc</code>.
</p>
<p>If <code>sym</code> is <code>TRUE</code>, the asymmetric logistic and
asymmetric negative logistic models are constrained so that
<code>asy2 = asy1</code>, and the Coles-Tawn model is constrained
so that <code>beta = alpha</code>. The parameter <code>asy2</code> or
<code>beta</code> is then taken to be specified, so that e.g.
the parameters <code>asy1</code> and <code>asy2</code> can only
be fixed at <code>0.8</code> using <code>asy1 = 0.8</code>, since
using <code>asy2 = 0.8</code> gives an error.
</p>
<p>Bilogistic and negative bilogistic models constrained to
symmetry are logistic and negative logistic models
respectively. The (symmetric) mixed model (e.g. Tawn, 1998)
can be obtained as a special case of the asymmetric
logistic or asymmetric mixed models (see <b>Examples</b>).
</p>
<p>The value <code>Dependence</code> given in the printed output
is <code class="reqn">2(1-A(1/2))</code>, where <code class="reqn">A</code> is the estimated dependence
function (see <code><a href="#topic+abvevd">abvevd</a></code>). It measures the strength of
dependence, and lies in the interval [0,1]; at independence and
complete dependence it is zero and one respectively (Coles,
Heffernan and Tawn, 1999). See <code><a href="#topic+chiplot">chiplot</a></code> for
further information.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("bvevd","evd")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
</p>
<p>The functions <code>profile</code> and <code>profile2d</code> can be
used to obtain deviance profiles.
The function <code>anova</code> compares nested models, and the
function <code>AIC</code> compares non-nested models.
The function <code>plot</code> produces diagnostic plots.
</p>
<p>An object of class <code>c("bvevd","evd")</code> is a list containing
the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters that have been fixed
at specific values within the optimization.</p>
</td></tr>
<tr><td><code>fixed2</code></td>
<td>
<p>A vector containing the parameters that have been set
to be equal to other model parameters.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (those optimized,
those fixed to specific values, and those set to be
equal to other model parameters).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>dep.summary</code></td>
<td>
<p>The estimate of <code class="reqn">2(1-A(1/2))</code>.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>tdata</code></td>
<td>
<p>The data, transformed to stationarity (for non-stationary
models).</p>
</td></tr>
<tr><td><code>nsloc1</code>, <code>nsloc2</code></td>
<td>
<p>The arguments <code>nsloc1</code> and <code>nsloc2</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code>sym</code></td>
<td>
<p>The argument <code>sym</code>.</p>
</td></tr>
<tr><td><code>cmar</code></td>
<td>
<p>The vector <code>c(cloc, cscale, cshape)</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The argument <code>model</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
</table>


<h3>More Details</h3>

<p>If <code>x</code> is a data frame with a third column of mode
<code>logical</code>, then the model is fitted using the likelihood
derived by Stephenson and Tawn (2004). This is appropriate
when each bivariate data point comprises componentwise maxima
from some underlying bivariate process, and where the
corresponding logical value denotes whether or not the maxima
were caused by the same event within that process.
</p>
<p>Under this scheme the diagnostic plots that are produced
using <code>plot</code> are somewhat different to those described
in <code><a href="#topic+plot.bvevd">plot.bvevd</a></code>: the density, dependence function
and quantile curves plots contain fitted functions for
observations where the logical case is unknown, and the
conditional P-P plots condition on both the logical case and
the given margin (which requires numerical integration at each
data point).
</p>


<h3>Artificial Constraints</h3>

<p>For numerical reasons parameters are subject to artificial
constraints. Specifically, these constraints are: marginal
scale parameters not less than 0.01; <code>dep</code> not less
than [0.1] [0.2] [0.05] in [logistic] [Husler-Reiss]
[negative logistic] models; <code>dep</code> not greater
than [10] [5] in [Husler-Reiss] [negative logistic] models;
<code>asy1</code> and <code>asy2</code> not less than 0.001;
<code>alpha</code> and <code>beta</code> not less than [0.1] [0.1]
[0.001] in [bilogistic] [negative bilogistic] [Coles-Tawn]
models; <code>alpha</code> and <code>beta</code> not greater than [0.999]
[20] [30] in [bilogistic] [negative bilogistic] [Coles-Tawn]
models.
</p>


<h3>Warning</h3>

<p>The standard errors and the correlation matrix in the returned
object are taken from the observed information, calculated by a
numerical approximation.
They must be interpreted with caution when either of the
marginal shape parameters are less than <code class="reqn">-0.5</code>, because
the usual asymptotic properties of maximum likelihood estimators
do not then hold (Smith, 1985).
</p>


<h3>References</h3>

<p>Coles, S. G., Heffernan, J. and Tawn, J. A. (1999)
Dependence measures for extreme value analyses.
<em>Extremes</em>, <b>2</b>, 339&ndash;365.
</p>
<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>
<p>Stephenson, A. G. and Tawn, J. A. (2004)
Exploiting Occurence Times in Likelihood Inference for
Componentwise Maxima.
<em>Biometrika</em> <b>92</b>(1), 213&ndash;217.
</p>
<p>Tawn, J. A. (1988)
Bivariate extreme value theory: models and estimation.
<em>Biometrika</em>, <b>75</b>, 397&ndash;415.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.evd">anova.evd</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+plot.bvevd">plot.bvevd</a></code>, <code><a href="#topic+profile.evd">profile.evd</a></code>,
<code><a href="#topic+profile2d.evd">profile2d.evd</a></code>, <code><a href="#topic+rbvevd">rbvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(100, dep = 0.6, model = "log", mar1 = c(1.2,1.4,0.4))
M1 &lt;- fbvevd(bvdata, model = "log")
M2 &lt;- fbvevd(bvdata, model = "log", dep = 0.75)
anova(M1, M2)
par(mfrow = c(2,2))
plot(M1)
plot(M1, mar = 1)
plot(M1, mar = 2)
## Not run: par(mfrow = c(1,1))
## Not run: M1P &lt;- profile(M1, which = "dep")
## Not run: plot(M1P)

trend &lt;- (-49:50)/100
rnd &lt;- runif(100, min = -.5, max = .5)
fbvevd(bvdata, model = "log", nsloc1 = trend)
fbvevd(bvdata, model = "log", nsloc1 = trend, nsloc2 = data.frame(trend
= trend,  random = rnd))
fbvevd(bvdata, model = "log", nsloc1 = trend, nsloc2 = data.frame(trend
= trend, random = rnd), loc2random = 0)

bvdata &lt;- rbvevd(100, dep = 1, asy = c(0.5,0.5), model = "anegl")
anlog &lt;- fbvevd(bvdata, model = "anegl")
mixed &lt;- fbvevd(bvdata, model = "anegl", dep = 1, sym = TRUE)
anova(anlog, mixed)
amixed &lt;- fbvevd(bvdata, model = "amix")
mixed &lt;- fbvevd(bvdata, model = "amix", beta = 0)
anova(amixed, mixed)
</code></pre>

<hr>
<h2 id='fbvpot'>Maximum-likelihood Fitting of Bivariate Extreme Value
Distributions to Threshold Exceedances</h2><span id='topic+fbvpot'></span><span id='topic+print.bvpot'></span>

<h3>Description</h3>

<p>Fit models for one of nine parametric bivariate extreme-value
distributions using threshold exceedances, allowing any of the
parameters to be held fixed if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbvpot(x, threshold, model = c("log", "bilog", "alog", "neglog",
    "negbilog", "aneglog", "ct", "hr", "amix"), likelihood =
    c("censored", "poisson"), start, ..., sym = FALSE, cshape =
    cscale, cscale = FALSE, std.err = TRUE, corr = FALSE, method =
    "BFGS", warn.inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbvpot_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with two columns. If this
contains missing values, those values are treated as if
they fell below the corresponding marginal threshold.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_threshold">threshold</code></td>
<td>
<p>A vector of two thresholds.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric mixed
models respectively. The definition of each model is given in
<code><a href="#topic+rbvevd">rbvevd</a></code>.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood model; either <code>"censored"</code>
(the default) or <code>"poisson"</code>. The <code>"poisson"</code> method 
is not recommended. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for all of the
parameters in the model. If <code>start</code> is omitted the routine
attempts to find good starting values using marginal maximum
likelihood estimators.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the bivariate extreme
value model or for the optimization function <code>optim</code>. If
parameters of the model are included they will be held fixed at
the values given (see <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_sym">sym</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the dependence structure
of the models <code>"alog"</code>, <code>"aneglog"</code> or <code>"ct"</code> are
constrained to be symmetric (see <b>Details</b>). For all other
models, the argument is ignored (and a warning is given).</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_cshape">cshape</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a common shape parameter is
fitted to each margin.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_cscale">cscale</code></td>
<td>
<p>Logical; if <code>TRUE</code>, a common scale parameter is
fitted to each margin, and the default value of <code>cshape</code>
is then <code>TRUE</code>, so that under this default common marginal
parameters are fitted.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="fbvpot_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), a warning is
given if the negative log-likelihood is infinite when evaluated at
the starting values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>"censored"</code> method bivariate peaks over threshold models 
are fitted by maximizing the censored likelihood as given in e.g. Section
8.3.1 of Coles(2001). For the <code>"poisson"</code> method models are fitted
using Equation 5.4 of Coles and Tawn (1991), see also Joe, Smith and
Weissman (1992). This method is only available for models whose spectral 
measure does not contain point masses (see <a href="#topic+hbvevd">hbvevd</a>). It is not
recommended as in practice it can produce poor estimates.
</p>
<p>For either likelihood the margins are modelled using a generalized Pareto 
distribution for points above the threshold and an empirical model for 
those below. For the <code>"poisson"</code> method data lying below both thresholds 
is not used. For the <code>"censored"</code> method the number of points lying
below both thresholds is used, but the locations of the those points are 
not.
</p>
<p>The dependence parameter names are one or more of <code>dep</code>,
<code>asy1</code>, <code>asy2</code>, <code>alpha</code> and <code>beta</code>, depending on
the model selected (see <code><a href="#topic+rbvevd">rbvevd</a></code>). 
The marginal parameter names are <code>scale1</code> and <code>shape1</code>
for the first margin, and <code>scale2</code> and <code>shape2</code> for the
second margin.
</p>
<p>If <code>cshape</code> is true, the models are constrained so that
<code>shape2 = shape1</code>. The parameter <code>shape2</code> is then
taken to be specified, so that e.g. the common shape
parameter can only be fixed at zero using <code>shape1 = 0</code>,
since using <code>shape2 = 0</code> gives an error. Similar
comments apply for <code>cscale</code>.
</p>
<p>If <code>sym</code> is <code>TRUE</code>, the asymmetric logistic and
asymmetric negative logistic models are constrained so that
<code>asy2 = asy1</code>, and the Coles-Tawn model is constrained
so that <code>beta = alpha</code>. The parameter <code>asy2</code> or
<code>beta</code> is then taken to be specified, so that e.g.
the parameters <code>asy1</code> and <code>asy2</code> can only
be fixed at <code>0.8</code> using <code>asy1 = 0.8</code>, since
using <code>asy2 = 0.8</code> gives an error.
</p>
<p>Bilogistic and negative bilogistic models constrained to
symmetry are logistic and negative logistic models
respectively. The (symmetric) mixed model (e.g. Tawn, 1998)
can be obtained as a special case of the asymmetric
logistic or asymmetric mixed models (see <b>fbvevd</b>).
</p>
<p>For numerical reasons the parameters of each model are subject the
artificial constraints given in <code><a href="#topic+fbvevd">fbvevd</a></code>.  
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("bvpot","evd")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
</p>
<p>The functions <code>profile</code> and <code>profile2d</code> can be
used to obtain deviance profiles.
The function <code>anova</code> compares nested models, and the
function <code>AIC</code> compares non-nested models.
There is currently no plot method available.
</p>
<p>An object of class <code>c("bvpot","evd")</code> is a list containing
the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters that have been fixed
at specific values within the optimization.</p>
</td></tr>
<tr><td><code>fixed2</code></td>
<td>
<p>A vector containing the parameters that have been set
to be equal to other model parameters.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (those optimized,
those fixed to specific values, and those set to be
equal to other model parameters).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>dep.summary</code></td>
<td>
<p>A value summarizing the strength of
dependence in the fitted model (see <b>fbvevd</b>).</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The argument <code>threshold</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code>nat</code></td>
<td>
<p>The vector of length three containing the number of
exceedances on the first, second and both margins respectively.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>The argument <code>likelihood</code>.</p>
</td></tr>
<tr><td><code>sym</code></td>
<td>
<p>The argument <code>sym</code>.</p>
</td></tr>
<tr><td><code>cmar</code></td>
<td>
<p>The vector <code>c(cscale, cshape)</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The argument <code>model</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The standard errors and the correlation matrix in the returned
object are taken from the observed information, calculated by a
numerical approximation.
They must be interpreted with caution when either of the
marginal shape parameters are less than <code class="reqn">-0.5</code>, because
the usual asymptotic properties of maximum likelihood estimators
do not then hold (Smith, 1985).
</p>


<h3>Author(s)</h3>

<p>Chris Ferro and Alec Stephenson</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of Extreme
Values</em>, London: Springer&ndash;Verlag.
</p>
<p>Coles, S. G. and Tawn, J. A. (1991)
Modelling multivariate extreme events.
<em>J. R. Statist. Soc. B</em>, <b>53</b>, 377&ndash;392.
</p>
<p>Joe, H., Smith, R. L. and Weissman, I. (1992)
Bivariate threshold methods for extremes.
<em>J. R. Statist. Soc. B</em>, <b>54</b>, 171&ndash;183.
</p>
<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvevd">abvevd</a></code>, <code><a href="#topic+anova.evd">anova.evd</a></code>,
<code><a href="#topic+fbvevd">fbvevd</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+rbvevd">rbvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(1000, dep = 0.5, model = "log")
u &lt;- apply(bvdata, 2,  quantile, probs = 0.9)
M1 &lt;- fbvpot(bvdata, u, model = "log")
M2 &lt;- fbvpot(bvdata, u, "log", dep = 0.5)
anova(M1, M2)
</code></pre>

<hr>
<h2 id='fextreme'>Maximum-likelihood Fitting of Maxima and Minima</h2><span id='topic+fextreme'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the distribution of the
maximum/minimum of a given number of independent variables from
a specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fextreme(x, start, densfun, distnfun, ..., distn, mlen = 1, largest =
    TRUE, std.err = TRUE, corr = FALSE, method = "Nelder-Mead")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fextreme_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_densfun">densfun</code>, <code id="fextreme_+3A_distnfun">distnfun</code></td>
<td>
<p>Density and distribution function of the
specified distribution.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the specified
distribution or for the optimization function <code>optim</code>.
If parameters of the distribution are included they will be
held fixed at the values given (see <b>Examples</b>). If
parameters of the distribution are not included either here
or as a named component in <code>start</code> they will be held
fixed at the default values specified in the corresponding
density and distribution functions (assuming they exist; an
error will be generated otherwise).</p>
</td></tr>
<tr><td><code id="fextreme_+3A_distn">distn</code></td>
<td>
<p>A character string, optionally specified as an alternative
to <code>densfun</code> and <code>distnfun</code> such that the density and
distribution functions are formed upon the addition of the
prefixes <code>d</code> and <code>p</code> respectively.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_mlen">mlen</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_largest">largest</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) use maxima,
otherwise minima.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fextreme_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximization of the log-likelihood is performed.
The estimated standard errors are taken from the observed information,
calculated by a numerical approximation. 
</p>
<p>If the density and distribution functions are user defined, the order
of the arguments must mimic those in R base (i.e. data first,
parameters second).
Density functions must have <code>log</code> arguments.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("extreme","evd")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
The function <code>anova</code> compares nested models.
</p>
<p>An object of class <code>c("extreme","evd")</code> is a list containing
at most the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+anova.evd">anova.evd</a></code>, <code><a href="#topic+forder">forder</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rextreme(100, qnorm, mean = 0.56, mlen = 365)
fextreme(uvdata, list(mean = 0, sd = 1), distn = "norm", mlen = 365)
fextreme(uvdata, list(rate = 1), distn = "exp", mlen = 365, 
  method = "Brent", lower=0.01, upper=10)
fextreme(uvdata, list(scale = 1), shape = 1, distn = "gamma", mlen = 365,
  method = "Brent", lower=0.01, upper=10)
fextreme(uvdata, list(shape = 1, scale = 1), distn = "gamma", mlen = 365)
</code></pre>

<hr>
<h2 id='fgev'>Maximum-likelihood Fitting of the Generalized Extreme Value
Distribution</h2><span id='topic+fgev'></span><span id='topic+fgumbel'></span><span id='topic+fitted.evd'></span><span id='topic+std.errors'></span><span id='topic+std.errors.evd'></span><span id='topic+vcov.evd'></span><span id='topic+print.evd'></span><span id='topic+logLik.evd'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the generalized extreme value distribution,
including linear modelling of the location parameter, and allowing any
of the parameters to be held fixed if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgev(x, start, ..., nsloc = NULL, prob = NULL, std.err = TRUE,
    corr = FALSE, method = "BFGS", warn.inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgev_+3A_x">x</code></td>
<td>
<p>A numeric vector, which may contain missing values.</p>
</td></tr>
<tr><td><code id="fgev_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.
If <code>start</code> is omitted the routine attempts to find good
starting values using moment estimators.</p>
</td></tr>
<tr><td><code id="fgev_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the GEV model
or for the optimization function <code>optim</code>. If parameters
of the model are included they will be held fixed at the
values given (see <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="fgev_+3A_nsloc">nsloc</code></td>
<td>
<p>A data frame with the same number of rows as the
length of <code>x</code>, for linear modelling of the location
parameter.
The data frame is treated as a covariate matrix (excluding the
intercept).
A numeric vector can be given as an alternative to a single column
data frame.</p>
</td></tr>
<tr><td><code id="fgev_+3A_prob">prob</code></td>
<td>
<p>Controls the parameterization of the model (see
<b>Details</b>). Should be either <code>NULL</code> (the default),
or a probability in the closed interval [0,1].</p>
</td></tr>
<tr><td><code id="fgev_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fgev_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fgev_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="fgev_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), a warning is
given if the negative log-likelihood is infinite when evaluated at
the starting values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>prob</code> is <code>NULL</code> (the default):
</p>
<p>For stationary models the parameter names are <code>loc</code>, <code>scale</code>
and <code>shape</code>, for the location, scale and shape parameters
respectively.
For non-stationary models, the parameter names are <code>loc</code>,
<code>loc</code><em>x1</em>, ..., <code>loc</code><em>xn</em>, <code>scale</code> and
<code>shape</code>, where <em>x1</em>, ..., <em>xn</em> are the column names
of <code>nsloc</code>, so that <code>loc</code> is the intercept of the
linear model, and <code>loc</code><em>x1</em>, ..., <code>loc</code><em>xn</em>
are the <code>ncol(nsloc)</code> coefficients.
If <code>nsloc</code> is a vector it is converted into a single column
data frame with column name <code>trend</code>, and hence the associated
trend parameter is named <code>loctrend</code>.
</p>
<p>If <code class="reqn">\code{prob} = p</code> is a probability:
</p>
<p>The fit is performed using a different parameterization.
Let <code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">s</code> denote the location, scale
and shape parameters of the GEV distribution.
For stationary models, the distribution is parameterized
using <code class="reqn">(z_p,b,s)</code>, where
</p>
<p style="text-align: center;"><code class="reqn">z_p = a - b/s (1 - (-\log(1 - p))^s)</code>
</p>

<p>is such that <code class="reqn">G(z_p) = 1 - p</code>, where <code class="reqn">G</code> is the
GEV distribution function.
<code class="reqn">\code{prob} = p</code> is therefore the probability in the upper
tail corresponding to the quantile <code class="reqn">z_p</code>.
If <code>prob</code> is zero, then <code class="reqn">z_p</code> is the upper end point
<code class="reqn">a - b/s</code>, and <code class="reqn">s</code> is restricted to the negative
(Weibull) axis.
If <code>prob</code> is one, then <code class="reqn">z_p</code> is the lower end point
<code class="reqn">a - b/s</code>, and <code class="reqn">s</code> is restricted to the positive
(Frechet) axis.
The parameter names are <code>quantile</code>, <code>scale</code>
and <code>shape</code>, for <code class="reqn">z_p</code>, <code class="reqn">b</code> and <code class="reqn">s</code>
respectively.
</p>
<p>For non-stationary models the parameter <code class="reqn">z_p</code> is again given by
the equation above, but <code class="reqn">a</code> becomes the intercept of the linear
model for the location parameter, so that <code>quantile</code> replaces
(the intercept) <code>loc</code>, and hence the parameter names are
<code>quantile</code>, <code>loc</code><em>x1</em>, ..., <code>loc</code><em>xn</em>,
<code>scale</code> and <code>shape</code>, where <em>x1</em>, ..., <em>xn</em> are
the column names of <code>nsloc</code>.
</p>
<p>In either case:
</p>
<p>For non-stationary fitting it is recommended that the covariates
within the linear model for the location parameter are (at least
approximately) centered and scaled (i.e.\ that the columns of
<code>nsloc</code> are centered and scaled), particularly if automatic
starting values are used, since the starting values for the
associated parameters are then zero.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("gev","uvevd","evd")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
</p>
<p>The functions <code>profile</code> and <code>profile2d</code> are
used to obtain deviance profiles for the model parameters.
In particular, profiles of the quantile <code class="reqn">z_p</code> can be
calculated and plotted when <code class="reqn">\code{prob} = p</code>.
The function <code>anova</code> compares nested models.
The function <code>plot</code> produces diagnostic plots.
</p>
<p>An object of class <code>c("gev","uvevd","evd")</code> is a list
containing at most the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimized and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>tdata</code></td>
<td>
<p>The data, transformed to stationarity (for non-stationary
models).</p>
</td></tr>
<tr><td><code>nsloc</code></td>
<td>
<p>The argument <code>nsloc</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of <code>x</code>.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>The argument <code>prob</code>.</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>The location parameter. If <code>prob</code> is <code>NULL</code>
(the default), this will also be an element of <code>param</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The standard errors and the correlation matrix in the returned
object are taken from the observed information, calculated by a
numerical approximation.
They must be interpreted with caution when the shape parameter
is less than <code class="reqn">-0.5</code>, because the usual asymptotic
properties of maximum likelihood estimators do not then
hold (Smith, 1985).
</p>


<h3>References</h3>

<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.evd">anova.evd</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+plot.uvevd">plot.uvevd</a></code>, <code><a href="#topic+profile.evd">profile.evd</a></code>,
<code><a href="#topic+profile2d.evd">profile2d.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
trend &lt;- (-49:50)/100
M1 &lt;- fgev(uvdata, nsloc = trend, control = list(trace = 1))
M2 &lt;- fgev(uvdata)
M3 &lt;- fgev(uvdata, shape = 0)
M4 &lt;- fgev(uvdata, scale = 1, shape = 0)
anova(M1, M2, M3, M4)
par(mfrow = c(2,2))
plot(M2)
## Not run: M2P &lt;- profile(M2)
## Not run: plot(M2P)

rnd &lt;- runif(100, min = -.5, max = .5)
fgev(uvdata, nsloc = data.frame(trend = trend, random = rnd))
fgev(uvdata, nsloc = data.frame(trend = trend, random = rnd), locrandom = 0)

uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata, prob = 0.1)
M2 &lt;- fgev(uvdata, prob = 0.01)
## Not run: M1P &lt;- profile(M1, which = "quantile")
## Not run: M2P &lt;- profile(M2, which = "quantile")
## Not run: plot(M1P)
## Not run: plot(M2P)
</code></pre>

<hr>
<h2 id='fgumbelx'>Maximum-likelihood Fitting of the Maximum of Two Gumbel 
Distributions</h2><span id='topic+fgumbelx'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the maximum of two gumbel distributions,
allowing any of the parameters to be held fixed if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgumbelx(x, start, ..., nsloc1 = NULL, nsloc2 = NULL, std.err = TRUE, 
    corr = FALSE, method = "BFGS", warn.inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgumbelx_+3A_x">x</code></td>
<td>
<p>A numeric vector, which may contain missing values.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.
If <code>start</code> is omitted the routine attempts to find good
starting values using moment estimators.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the fitted model
or for the optimization function <code>optim</code>. If parameters
of the model are included they will be held fixed at the
values given (see <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_nsloc1">nsloc1</code></td>
<td>
<p>A data frame with the same number of rows as the
length of <code>x</code>, for linear modelling of the location
parameter of the first Gumbel distribution. This is not 
recommended as the model is already complex.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_nsloc2">nsloc2</code></td>
<td>
<p>A data frame with the same number of rows as the
length of <code>x</code>, for linear modelling of the location
parameter of the second Gumbel distribution. This is not 
recommended as the model is already complex.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="fgumbelx_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), a warning is
given if the negative log-likelihood is infinite when evaluated at
the starting values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For stationary models the parameter names are <code>loc1</code>, <code>scale1</code>,
<code>loc2</code> and <code>scale2</code> for the location and scale parameters of
two Gumbel distributions, where <code>loc2</code> must be greater or equal to 
<code>loc1</code>. 
</p>
<p>The likelihood may have multiple local optima and therefore may be 
difficult to fit properly; the default starting values use a moment 
based approach, however it is recommended that the user specify multiple 
different starting values and experiment with different optimization 
methods. 
</p>
<p>Using non-stationary models with nsloc1 and nsloc2 is not 
recommended due to the model complexity; the data also cannot be 
transformed back to stationarity so diagnostic plots will be misleading
in this case.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("gumbelx","evd")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
</p>
<p>The functions <code>profile</code> and <code>profile2d</code> are
used to obtain deviance profiles for the model parameters.
The function <code>anova</code> compares nested models.
The function <code>plot</code> produces diagnostic plots.
</p>
<p>An object of class <code>c("gumbelx","evd")</code> is a list
containing at most the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimized and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>nsloc1</code></td>
<td>
<p>The argument <code>nsloc1</code>.</p>
</td></tr>
<tr><td><code>nsloc2</code></td>
<td>
<p>The argument <code>nsloc2</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of <code>x</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This function is experimental and involves optimizing over a potentially
complex surface.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fgev">fgev</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+rgumbelx">rgumbelx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgumbelx(100, loc1 = 0, scale1 = 1, loc2 = 1, scale2 = 1)
fgumbelx(uvdata, loc1 = 0, scale1 = 1)
</code></pre>

<hr>
<h2 id='forder'>Maximum-likelihood Fitting of Order Statistics</h2><span id='topic+forder'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the distribution of a selected order
statistic of a given number of independent variables from a
specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forder(x, start, densfun, distnfun, ..., distn, mlen = 1, j = 1, 
    largest = TRUE, std.err = TRUE, corr = FALSE, method = "Nelder-Mead")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forder_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="forder_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.</p>
</td></tr>
<tr><td><code id="forder_+3A_densfun">densfun</code>, <code id="forder_+3A_distnfun">distnfun</code></td>
<td>
<p>Density and distribution function of the
specified distribution.</p>
</td></tr>
<tr><td><code id="forder_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the specified
distribution or for the optimization function <code>optim</code>.
If parameters of the distribution are included they will be
held fixed at the values given (see <b>Examples</b>). If
parameters of the distribution are not included either here
or as a named component in <code>start</code> they will be held
fixed at the default values specified in the corresponding
density and distribution functions (assuming they exist; an
error will be generated otherwise).</p>
</td></tr>
<tr><td><code id="forder_+3A_distn">distn</code></td>
<td>
<p>A character string, optionally specified as an alternative
to <code>densfun</code> and <code>distnfun</code> such that the density and
distribution and functions are formed upon the addition of the
prefixes <code>d</code> and <code>p</code> respectively.</p>
</td></tr>
<tr><td><code id="forder_+3A_mlen">mlen</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="forder_+3A_j">j</code></td>
<td>
<p>The order statistic, taken as the <code>j</code>th largest
(default) or smallest of <code>mlen</code>, according to the value of
<code>largest</code>.</p>
</td></tr>
<tr><td><code id="forder_+3A_largest">largest</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) use the <code>j</code>th
largest order statistic, otherwise use the <code>j</code>th smallest.</p>
</td></tr>
<tr><td><code id="forder_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="forder_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="forder_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximization of the log-likelihood is performed.
The estimated standard errors are taken from the observed information,
calculated by a numerical approximation.
</p>
<p>If the density and distribution functions are user defined, the order
of the arguments must mimic those in R base (i.e. data first,
parameters second).
Density functions must have <code>log</code> arguments.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("extreme","evd")</code>.
This class is defined in <code><a href="#topic+fextreme">fextreme</a></code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
The function <code>anova</code> compares nested models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.evd">anova.evd</a></code>, <code><a href="#topic+fextreme">fextreme</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvd &lt;- rorder(100, qnorm, mean = 0.56, mlen = 365, j = 2)
forder(uvd, list(mean = 0, sd = 1), distn = "norm", mlen = 365, j = 2)
forder(uvd, list(rate = 1), distn = "exp", mlen = 365, j = 2,
  method = "Brent", lower=0.01, upper=10)
forder(uvd, list(scale = 1), shape = 1, distn = "gamma", mlen = 365, j = 2,
  method = "Brent", lower=0.01, upper=10)
forder(uvd, list(shape = 1, scale = 1), distn = "gamma", mlen = 365, j = 2)
</code></pre>

<hr>
<h2 id='fox'>Maximum Annual Flood Discharges of the Fox River</h2><span id='topic+fox'></span>

<h3>Description</h3>

<p>The <code>fox</code> data frame has 33 rows and 2 columns.
The columns contain maximum annual flood discharges, in units
of 1000 cubed feet per second, from the Fox River in Wisconsin,
USA at Berlin (upstream) and Wrightstown (downstream), for the
years 1918 to 1950.
The row names give the years of observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fox</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>berlin</dt><dd><p>A numeric vector containing maximum annual flood
discharges at Berlin (upstream).</p>
</dd>
<dt>wright</dt><dd><p>A numeric vector containing maximum annual flood
discharges at Wrightstown (downstream).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Gumbel, E. J. and Mustafi, C. K. (1967)
Some analytical properties of bivariate extremal distributions.
<em>J. Amer. Statist. Assoc.</em>, <b>62</b>, 569&ndash;588.
</p>

<hr>
<h2 id='fpot'>Peaks Over Threshold Modelling using the Generalized Pareto
or Point Process Representation</h2><span id='topic+fpot'></span><span id='topic+print.pot'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for peaks over threshold modelling,
using the Generalized Pareto or Point Process representation,
allowing any of the parameters to be held fixed if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpot(x, threshold, model = c("gpd", "pp"), start, npp = length(x),
    cmax = FALSE, r = 1, ulow = -Inf, rlow = 1, mper = NULL, ...,
    std.err = TRUE, corr = FALSE, method = "BFGS", warn.inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpot_+3A_x">x</code></td>
<td>
<p>A numeric vector. If this contains missing values,
those values are treated as if they fell below the
threshold.</p>
</td></tr>
<tr><td><code id="fpot_+3A_threshold">threshold</code></td>
<td>
<p>The threshold.</p>
</td></tr>
<tr><td><code id="fpot_+3A_model">model</code></td>
<td>
<p>The model; either <code>"gpd"</code> (the default) or
<code>"pp"</code>, for the Generalized Pareto or Point Process
representations respectively.</p>
</td></tr>
<tr><td><code id="fpot_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the likelihood is to be maximized.
If <code>start</code> is omitted the routine attempts to find good
starting values using moment estimators.</p>
</td></tr>
<tr><td><code id="fpot_+3A_npp">npp</code></td>
<td>
<p>The data should contain <code>npp</code> observations per
&ldquo;period&rdquo;, where the return level plot produced by
<code>plot.pot</code> will represent return periods in units of
&ldquo;periods&rdquo;. By default <code>npp = length(x)</code>, so that the
&ldquo;period&rdquo; is the period of time over which the entire
data set is collected. It may often be useful to change
this default so that more sensible units are used.
For example, if yearly periodic units are required, use
<code>npp = 365.25</code> for daily data and <code>npp = 52.18</code>
for weekly data. The argument only makes a difference to
the actual fit if <code>mper</code> is not <code>NULL</code> or if
<code>model = "pp"</code> (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="fpot_+3A_cmax">cmax</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default), the model
is fitted using all exceedences over the threshold. If
<code>TRUE</code>, the model is fitted using cluster maxima, using
clusters of exceedences derived from <code>clusters</code>.</p>
</td></tr>
<tr><td><code id="fpot_+3A_r">r</code>, <code id="fpot_+3A_ulow">ulow</code>, <code id="fpot_+3A_rlow">rlow</code></td>
<td>
<p>Arguments used for the identification of
clusters of exceedences (see <code><a href="#topic+clusters">clusters</a></code>).
Ignored if <code>cmax</code> is <code>FALSE</code> (the default).</p>
</td></tr>
<tr><td><code id="fpot_+3A_mper">mper</code></td>
<td>
<p>Controls the parameterization of the generalized
Pareto model. Should be either <code>NULL</code> (the default),
or a positive number (see <b>Details</b>).
If <code>mper</code> is not <code>NULL</code> and <code>model = "pp"</code>,
an error is returned.</p>
</td></tr>
<tr><td><code id="fpot_+3A_...">...</code></td>
<td>
<p>Additional parameters, either for the model
or for the optimization function <code>optim</code>. If parameters
of the model are included they will be held fixed at the
values given (see <b>Examples</b>).</p>
</td></tr>
<tr><td><code id="fpot_+3A_std.err">std.err</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), the standard
errors are returned.</p>
</td></tr>
<tr><td><code id="fpot_+3A_corr">corr</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the correlation matrix is
returned.</p>
</td></tr>
<tr><td><code id="fpot_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="fpot_+3A_warn.inf">warn.inf</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), a warning is
given if the negative log-likelihood is infinite when evaluated at
the starting values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exeedances over the threshold <code>threshold</code> (if <code>cmax</code> is
<code>FALSE</code>) or the maxima of the clusters of exeedances (if
<code>cmax</code> is <code>TRUE</code>) are (if <code>model = "gpd"</code>) fitted to a
generalized Pareto distribution (GPD) with location <code>threshold</code>.
If <code>model = "pp"</code> the exceedances are fitted to a
non-homogeneous Poisson process (Coles, 2001).
</p>
<p>If <code>mper</code> is <code>NULL</code> (the default), the parameters of
the model (if <code>model = "gpd"</code>) are <code>scale</code> and
<code>shape</code>, for the scale and shape parameters of the GPD.
If <code>model = "pp"</code> the parameters are <code>loc</code>, <code>scale</code>
and <code>shape</code>. Under <code>model = "pp"</code> the parameters can be
interpreted as parameters of the Generalized Extreme Value
distribution, fitted to the maxima of <code>npp</code> random variables.
In this case, the value of <code>npp</code> should be reasonably large.
</p>
<p>For both characterizations, the shape parameters are
equivalent. The scale parameter under the generalized Pareto
characterization is equal to <code class="reqn">b + s(u - a)</code>, where <code class="reqn">a</code>,
<code class="reqn">b</code> and <code class="reqn">s</code> are the location, scale and shape parameters
under the Point Process characterization, and where <code class="reqn">u</code> is
the threshold.
</p>
<p>If <code class="reqn">\code{mper} = m</code> is a positive value, then
the generalized Pareto model is reparameterized so that the
parameters are <code>rlevel</code> and <code>shape</code>, where
<code>rlevel</code> is the <code class="reqn">m</code> &ldquo;period&rdquo; return level, where
&ldquo;period&rdquo; is defined via the argument <code>npp</code>.
</p>
<p>The <code class="reqn">m</code> &ldquo;period&rdquo; return level is defined as follows.
Let <code class="reqn">G</code> be the fitted generalized Pareto distribution
function, with location <code class="reqn">\code{threshold} = u</code>, so that
<code class="reqn">1 - G(z)</code> is the fitted probability of an exceedance
over <code class="reqn">z &gt; u</code> given an exceedance over <code class="reqn">u</code>.
The fitted probability of an exceedance over <code class="reqn">z &gt; u</code> is
therefore <code class="reqn">p(1 - G(z))</code>, where <code class="reqn">p</code> is the estimated
probabilty of exceeding <code class="reqn">u</code>, which is given by the empirical
proportion of exceedances.
The <code class="reqn">m</code> &ldquo;period&rdquo; return level <code class="reqn">z_m</code> satisfies
<code class="reqn">p(1 - G(z_m)) = 1/(mN)</code>, where <code class="reqn">N</code> is the number
of points per period (multiplied by the estimate of the
extremal index, if cluster maxima are fitted).
In other words, <code class="reqn">z_m</code> is the quantile of the fitted model
that corresponds to the upper tail probability <code class="reqn">1/(mN)</code>.
If <code>mper</code> is infinite, then <code class="reqn">z_m</code> is the upper end point,
given by <code>threshold</code> minus <code class="reqn">\code{scale}/\code{shape}</code>,
and the shape parameter is then restricted to be negative.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("pot","uvevd","pot")</code>.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+fitted">fitted</a></code> (or
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>), <code><a href="#topic+std.errors">std.errors</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code> and
<code><a href="stats.html#topic+AIC">AIC</a></code> extract various features of the
returned object.
</p>
<p>The function <code>profile</code> can be
used to obtain deviance profiles for the model parameters.
In particular, profiles of the <code class="reqn">m</code> <code>period</code>
return level <code class="reqn">z_m</code> can be calculated and plotted when
<code class="reqn">\code{mper} = m</code>.
The function <code>anova</code> compares nested models.
The function <code>plot</code> produces diagnostic plots.
</p>
<p>An object of class <code>c("pot","uvevd","evd")</code> is a list containing
the following components
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimized and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The deviance at the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The variance covariance matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>threshold</code>, <code>r</code>, <code>ulow</code>, <code>rlow</code>, <code>npp</code></td>
<td>
<p>The arguments of the same
name.</p>
</td></tr>
<tr><td><code>nhigh</code></td>
<td>
<p>The number of exceedences (if <code>cmax</code> is
<code>FALSE</code>) or the number of clusters of exceedences (if
<code>cmax</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code>nat</code>, <code>pat</code></td>
<td>
<p>The number and proportion of exceedences.</p>
</td></tr>
<tr><td><code>extind</code></td>
<td>
<p>The estimate of the extremal index (i.e.
<code>nhigh</code> divided by <code>nat</code>). If <code>cmax</code> is
<code>FALSE</code>, this is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data passed to the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>exceedances</code></td>
<td>
<p>The exceedences, or the maxima of the clusters
of exceedences.</p>
</td></tr>
<tr><td><code>mper</code></td>
<td>
<p>The argument <code>mper</code>.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The scale parameter for the fitted generalized Pareto
distribution. If <code>mper</code> is <code>NULL</code> and <code>model = "gpd"</code>
(the defaults), this will also be an element of <code>param</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the current function.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The standard errors and the correlation matrix in the returned
object are taken from the observed information, calculated by a
numerical approximation.
They must be interpreted with caution when the shape parameter
is less than <code class="reqn">-0.5</code>, because the usual asymptotic
properties of maximum likelihood estimators do not then
hold (Smith, 1985).
</p>


<h3>References</h3>

<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.evd">anova.evd</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+plot.uvevd">plot.uvevd</a></code>, <code><a href="#topic+profile.evd">profile.evd</a></code>,
<code><a href="#topic+profile2d.evd">profile2d.evd</a></code>, <code><a href="#topic+mrlplot">mrlplot</a></code>,
<code><a href="#topic+tcplot">tcplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgpd(100, loc = 0, scale = 1.1, shape = 0.2)
M1 &lt;- fpot(uvdata, 1)
M2 &lt;- fpot(uvdata, 1, shape = 0)
anova(M1, M2)
par(mfrow = c(2,2))
plot(M1)
## Not run: M1P &lt;- profile(M1)
## Not run: plot(M1P)

M1 &lt;- fpot(uvdata, 1, mper = 10)
M2 &lt;- fpot(uvdata, 1, mper = 100)
## Not run: M1P &lt;- profile(M1, which = "rlevel", conf=0.975, mesh=0.1)
## Not run: M2P &lt;- profile(M2, which = "rlevel", conf=0.975, mesh=0.1)
## Not run: plot(M1P)
## Not run: plot(M2P)
</code></pre>

<hr>
<h2 id='frechet'>The Frechet Distribution</h2><span id='topic+dfrechet'></span><span id='topic+pfrechet'></span><span id='topic+qfrechet'></span><span id='topic+rfrechet'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function
and random generation for the Frechet distribution with
location, scale and shape parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrechet(x, loc=0, scale=1, shape=1, log = FALSE) 
pfrechet(q, loc=0, scale=1, shape=1, lower.tail = TRUE) 
qfrechet(p, loc=0, scale=1, shape=1, lower.tail = TRUE)
rfrechet(n, loc=0, scale=1, shape=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechet_+3A_x">x</code>, <code id="frechet_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="frechet_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="frechet_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="frechet_+3A_loc">loc</code>, <code id="frechet_+3A_scale">scale</code>, <code id="frechet_+3A_shape">shape</code></td>
<td>
<p>Location, scale and shape parameters (can be
given as vectors).</p>
</td></tr>
<tr><td><code id="frechet_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="frechet_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frechet distribution function with parameters
<code class="reqn">\code{loc} = a</code>, <code class="reqn">\code{scale} = b</code> and
<code class="reqn">\code{shape} = s</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left\{-\left(\frac{z-a}{b}\right)^{-s}
  \right\}</code>
</p>

<p>for <code class="reqn">z &gt; a</code> and zero otherwise, where <code class="reqn">b &gt; 0</code> and
<code class="reqn">s &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>dfrechet</code> gives the density function, <code>pfrechet</code> gives
the distribution function, <code>qfrechet</code> gives the quantile
function, and <code>rfrechet</code> generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgev">rgev</a></code>, <code><a href="#topic+rgumbel">rgumbel</a></code>, <code><a href="#topic+rrweibull">rrweibull</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dfrechet(2:4, 1, 0.5, 0.8)
pfrechet(2:4, 1, 0.5, 0.8)
qfrechet(seq(0.9, 0.6, -0.1), 2, 0.5, 0.8)
rfrechet(6, 1, 0.5, 0.8)
p &lt;- (1:9)/10
pfrechet(qfrechet(p, 1, 2, 0.8), 1, 2, 0.8)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='gev'>The Generalized Extreme Value Distribution</h2><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the generalized extreme value (GEV)
distribution with location, scale and shape parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, loc=0, scale=1, shape=0, log = FALSE) 
pgev(q, loc=0, scale=1, shape=0, lower.tail = TRUE) 
qgev(p, loc=0, scale=1, shape=0, lower.tail = TRUE)
rgev(n, loc=0, scale=1, shape=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_+3A_x">x</code>, <code id="gev_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="gev_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="gev_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="gev_+3A_loc">loc</code>, <code id="gev_+3A_scale">scale</code>, <code id="gev_+3A_shape">shape</code></td>
<td>
<p>Location, scale and shape parameters; the 
<code>shape</code> argument cannot be a vector (must have length one).</p>
</td></tr>
<tr><td><code id="gev_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="gev_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GEV distribution function with parameters
<code class="reqn">\code{loc} = a</code>, <code class="reqn">\code{scale} = b</code> and
<code class="reqn">\code{shape} = s</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left[-\{1+s(z-a)/b\}^{-1/s}\right]</code>
</p>

<p>for <code class="reqn">1+s(z-a)/b &gt; 0</code>, where <code class="reqn">b &gt; 0</code>.
If <code class="reqn">s = 0</code> the distribution is defined by continuity.
If <code class="reqn">1+s(z-a)/b \leq 0</code>, the value <code class="reqn">z</code> is
either greater than the upper end point (if <code class="reqn">s &lt; 0</code>), or less
than the lower end point (if <code class="reqn">s &gt; 0</code>).
</p>
<p>The parametric form of the GEV encompasses that of the Gumbel,
Frechet and reverse Weibull distributions, which are obtained
for <code class="reqn">s = 0</code>, <code class="reqn">s &gt; 0</code> and <code class="reqn">s &lt; 0</code> respectively.
It was first introduced by Jenkinson (1955).
</p>


<h3>Value</h3>

<p><code>dgev</code> gives the density function, <code>pgev</code> gives the
distribution function, <code>qgev</code> gives the quantile function,
and <code>rgev</code> generates random deviates.
</p>


<h3>References</h3>

 
<p>Jenkinson, A. F. (1955)
The frequency distribution of the annual maximum (or minimum) of
meteorological elements.
<em>Quart. J. R. Met. Soc.</em>, <b>81</b>, 158&ndash;171.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fgev">fgev</a></code>, <code><a href="#topic+rfrechet">rfrechet</a></code>,
<code><a href="#topic+rgumbel">rgumbel</a></code>, <code><a href="#topic+rrweibull">rrweibull</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dgev(2:4, 1, 0.5, 0.8)
pgev(2:4, 1, 0.5, 0.8)
qgev(seq(0.9, 0.6, -0.1), 2, 0.5, 0.8)
rgev(6, 1, 0.5, 0.8)
p &lt;- (1:9)/10
pgev(qgev(p, 1, 2, 0.8), 1, 2, 0.8)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='gpd'>The Generalized Pareto Distribution</h2><span id='topic+dgpd'></span><span id='topic+pgpd'></span><span id='topic+qgpd'></span><span id='topic+rgpd'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the generalized Pareto distribution (GPD)
with location, scale and shape parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgpd(x, loc=0, scale=1, shape=0, log = FALSE) 
pgpd(q, loc=0, scale=1, shape=0, lower.tail = TRUE) 
qgpd(p, loc=0, scale=1, shape=0, lower.tail = TRUE)
rgpd(n, loc=0, scale=1, shape=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd_+3A_x">x</code>, <code id="gpd_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="gpd_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="gpd_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="gpd_+3A_loc">loc</code>, <code id="gpd_+3A_scale">scale</code>, <code id="gpd_+3A_shape">shape</code></td>
<td>
<p>Location, scale and shape parameters; the 
<code>shape</code> argument cannot be a vector (must have length one).</p>
</td></tr>
<tr><td><code id="gpd_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="gpd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized Pareto distribution function (Pickands, 1975) with
parameters <code class="reqn">\code{loc} = a</code>, <code class="reqn">\code{scale} = b</code> and
<code class="reqn">\code{shape} = s</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = 1 - \{1+s(z-a)/b\}^{-1/s}</code>
</p>

<p>for <code class="reqn">1+s(z-a)/b &gt; 0</code> and <code class="reqn">z &gt; a</code>, where <code class="reqn">b &gt; 0</code>.
If <code class="reqn">s = 0</code> the distribution is defined by continuity.
</p>


<h3>Value</h3>

<p><code>dgpd</code> gives the density function, <code>pgpd</code> gives the
distribution function, <code>qgpd</code> gives the quantile function,
and <code>rgpd</code> generates random deviates.
</p>


<h3>References</h3>

 
<p>Pickands, J. (1975)
Statistical inference using extreme order statistics.
<em>Annals of Statistics</em>, <b>3</b>, 119&ndash;131.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpot">fpot</a></code>, <code><a href="#topic+rgev">rgev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dgpd(2:4, 1, 0.5, 0.8)
pgpd(2:4, 1, 0.5, 0.8)
qgpd(seq(0.9, 0.6, -0.1), 2, 0.5, 0.8)
rgpd(6, 1, 0.5, 0.8)
p &lt;- (1:9)/10
pgpd(qgpd(p, 1, 2, 0.8), 1, 2, 0.8)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='gumbel'>The Gumbel Distribution</h2><span id='topic+dgumbel'></span><span id='topic+pgumbel'></span><span id='topic+qgumbel'></span><span id='topic+rgumbel'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the Gumbel distribution with location and
scale parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, loc=0, scale=1, log = FALSE) 
pgumbel(q, loc=0, scale=1, lower.tail = TRUE) 
qgumbel(p, loc=0, scale=1, lower.tail = TRUE)
rgumbel(n, loc=0, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gumbel_+3A_x">x</code>, <code id="gumbel_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_loc">loc</code>, <code id="gumbel_+3A_scale">scale</code></td>
<td>
<p>Location and scale parameters (can be given
as vectors).</p>
</td></tr>
<tr><td><code id="gumbel_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="gumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gumbel distribution function with parameters
<code class="reqn">\code{loc} = a</code> and <code class="reqn">\code{scale} = b</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left\{-\exp\left[-\left(\frac{z-a}{b}\right)
    \right]\right\}</code>
</p>

<p>for all real <code class="reqn">z</code>, where <code class="reqn">b &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>dgumbel</code> gives the density function, <code>pgumbel</code> gives
the distribution function, <code>qgumbel</code> gives the quantile
function, and <code>rgumbel</code> generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfrechet">rfrechet</a></code>, <code><a href="#topic+rgev">rgev</a></code>, <code><a href="#topic+rrweibull">rrweibull</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dgumbel(-1:2, -1, 0.5)
pgumbel(-1:2, -1, 0.5)
qgumbel(seq(0.9, 0.6, -0.1), 2, 0.5)
rgumbel(6, -1, 0.5)
p &lt;- (1:9)/10
pgumbel(qgumbel(p, -1, 2), -1, 2)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='gumbelx'>Maxima of Two Gumbel Distributions</h2><span id='topic+dgumbelx'></span><span id='topic+pgumbelx'></span><span id='topic+qgumbelx'></span><span id='topic+rgumbelx'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the maxima of two Gumbel distributions,
each with different location and scale parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbelx(x, loc1=0, scale1=1, loc2=0, scale2=1, log = FALSE) 
pgumbelx(q, loc1=0, scale1=1, loc2=0, scale2=1, lower.tail = TRUE) 
qgumbelx(p, interval, loc1=0, scale1=1, loc2=0, scale2=1, lower.tail = TRUE, ...)
rgumbelx(n, loc1=0, scale1=1, loc2=0, scale2=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gumbelx_+3A_x">x</code>, <code id="gumbelx_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_interval">interval</code></td>
<td>
<p>A length two vector containing the end-points of the interval 
to be searched for the quantiles, passed to the uniroot function.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_loc1">loc1</code>, <code id="gumbelx_+3A_scale1">scale1</code>, <code id="gumbelx_+3A_loc2">loc2</code>, <code id="gumbelx_+3A_scale2">scale2</code></td>
<td>
<p>Location and scale parameters of the two 
Gumbel distributions. The second location parameter must be greater than or
equal to the first location parameter.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
<tr><td><code id="gumbelx_+3A_...">...</code></td>
<td>
<p>Other arguments passed to uniroot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dgumbelx</code> gives the density function, <code>pgumbelx</code> gives the
distribution function, <code>qgumbelx</code> gives the quantile function,
and <code>rgumbelx</code> generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fgev">fgev</a></code>, <code><a href="#topic+rfrechet">rfrechet</a></code>,
<code><a href="#topic+rgumbel">rgumbel</a></code>, <code><a href="#topic+rrweibull">rrweibull</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dgumbelx(2:4, 0, 1.1, 1, 0.5)
pgumbelx(2:4, 0, 1.1, 1, 0.5)
qgumbelx(seq(0.9, 0.6, -0.1), interval = c(0,10), 0, 1.2, 2, 0.5)
rgumbelx(6, 0, 1.1, 1, 0.5)
p &lt;- (1:9)/10
pgumbelx(qgumbelx(p, interval = c(0,10), 0, 0.5, 1, 2), 0, 0.5, 1, 2)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='hbvevd'>Parametric Spectral Density Functions of Bivariate Extreme
Value Models</h2><span id='topic+hbvevd'></span>

<h3>Description</h3>

<p>Calculate or plot the density <code class="reqn">h</code> of the spectral measure
<code class="reqn">H</code> on the interval <code class="reqn">(0,1)</code>, for nine parametric
bivariate extreme value models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbvevd(x = 0.5, dep, asy = c(1,1), alpha, beta, model = c("log", "alog",
    "hr", "neglog", "aneglog", "bilog", "negbilog", "ct", "amix"),
     half = FALSE, plot = FALSE, add = FALSE, lty = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hbvevd_+3A_x">x</code></td>
<td>
<p>A vector of values at which the function is evaluated
(ignored if plot or add is <code>TRUE</code>). <code class="reqn">h(1/2)</code> is
returned by default.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_dep">dep</code></td>
<td>
<p>Dependence parameter for the logistic, asymmetric
logistic, Husler-Reiss, negative logistic and asymmetric
negative logistic models.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_asy">asy</code></td>
<td>
<p>A vector of length two, containing the two asymmetry
parameters for the asymmetric logistic and asymmetric negative
logistic models.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_alpha">alpha</code>, <code id="hbvevd_+3A_beta">beta</code></td>
<td>
<p>Alpha and beta parameters for the bilogistic,
negative bilogistic, Coles-Tawn and asymmetric mixed models.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be
either <code>"log"</code> (the default), <code>"alog"</code>, <code>"hr"</code>,
<code>"neglog"</code>, <code>"aneglog"</code>, <code>"bilog"</code>,
<code>"negbilog"</code>, <code>"ct"</code> or <code>"amix"</code> (or any unique
partial match), for the logistic, asymmetric logistic,
Husler-Reiss, negative logistic, asymmetric negative logistic,
bilogistic, negative bilogistic, Coles-Tawn and asymmetric
mixed models respectively. The definition of each model is given
in <code><a href="#topic+rbvevd">rbvevd</a></code>. If parameter arguments are given that do
not correspond to the specified model those arguments are
ignored, with a warning.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_half">half</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function is divided by two,
corresponding to a spectral measure with total mass one rather
than two.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code> the function is plotted. The
x and y values used to create the plot are returned invisibly.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_add">add</code></td>
<td>
<p>Logical; add to an existing plot?</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_lty">lty</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="hbvevd_+3A_...">...</code></td>
<td>
<p>Other high-level graphics parameters to be passed to
<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any bivariate extreme value distribution can be written as
</p>
<p style="text-align: center;"><code class="reqn">G(z_1,z_2) = \exp\left[-\int_0^1 \max\{wy_1, (1-w)y_2\}
    H(dw)\right]</code>
</p>

<p>for some function <code class="reqn">H(\cdot)</code> defined on <code class="reqn">[0,1]</code>,
satisfying
</p>
<p style="text-align: center;"><code class="reqn">\int_0^1 w H(dw) = \int_0^1 (1-w) H(dw) = 1</code>
</p>

<p>In particular, the total mass of H is two.
The functions <code class="reqn">y_1</code> and <code class="reqn">y_2</code> are as defined in
<code><a href="#topic+abvevd">abvevd</a></code>.
</p>
<p>H is called the spectral measure, with density <code class="reqn">h</code> on 
the interval <code class="reqn">(0,1)</code>.
</p>


<h3>Value</h3>

<p><code>hbvevd</code> calculates or plots the spectral density function
<code class="reqn">h</code> for one of nine parametric bivariate extreme value models,
at specified parameter values.
</p>


<h3>Point Masses</h3>

<p>For differentiable models H may have up to two point masses:
at zero and one. Assuming that the model parameters are in the
interior of the parameter space, we have the following. For the
asymmetric logistic and asymmetric negative logistic models the
point masses are of size <code>1-asy1</code> and <code>1-asy2</code>
respectively. For the asymmetric mixed model they are of size
<code>1-alpha-beta</code> and <code>1-alpha-2*beta</code> respectively. For
all other models the point masses are zero.
</p>
<p>At independence, H has point masses of size one at both
zero and one. At complete dependence [a non-differentiable
model] H has a single point mass of size two at <code class="reqn">1/2</code>.
In either case, <code class="reqn">h</code> is zero everywhere.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvevd">abvevd</a></code>, <code><a href="#topic+fbvevd">fbvevd</a></code>,
<code><a href="#topic+rbvevd">rbvevd</a></code>, <code><a href="#topic+plot.bvevd">plot.bvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hbvevd(dep = 2.7, model = "hr")
hbvevd(seq(0.25,0.5,0.75), dep = 0.3, asy = c(.7,.9), model = "alog")
hbvevd(alpha = 0.3, beta = 1.2, model = "negbi", plot = TRUE)

bvdata &lt;- rbvevd(100, dep = 0.7, model = "log")
M1 &lt;- fitted(fbvevd(bvdata, model = "log"))
hbvevd(dep = M1["dep"], model = "log", plot = TRUE)
</code></pre>

<hr>
<h2 id='lisbon'>Annual Maximum Wind Speeds at Lisbon</h2><span id='topic+lisbon'></span>

<h3>Description</h3>

<p>A numeric vector containing annual maximum wind speeds, in
kilometers per hour, from 1941 to 1970 at Lisbon, Portugal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisbon</code></pre>


<h3>Format</h3>

<p>A vector containing 30 observations.</p>


<h3>Source</h3>

<p>Tiago de Oliveira, J. (1997)
<em>Statistical Analysis of Extremes.</em>
Pendor.
</p>

<hr>
<h2 id='lossalae'>General Liability Claims</h2><span id='topic+lossalae'></span>

<h3>Description</h3>

<p>The <code>lossalae</code> data frame has 1500 rows and 2 columns.
The columns contain the indemnity payment (loss), and
the allocated loss adjustment expense (alae), both in USD.
The latter is the additional expenses associated with the
settlement of the claim (e.g. claims investigation expenses
and legal fees).
</p>
<p>The dataset also has an attribute called <code>capped</code>, which
gives the row names of the indemnity payments that were capped
at their policy limit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lossalae</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Loss</dt><dd><p>A numeric vector containing the indemnity
payments.</p>
</dd>
<dt>ALAE</dt><dd><p>A numeric vector containing the allocated
loss adjustment expenses.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Frees, E. W. and Valdez, E. A. (1998)
Understanding relationships using copulas.
<em>North American Actuarial Journal</em>, <b>2</b>, 1&ndash;15.
</p>


<h3>References</h3>

<p>Klugman, S. A. and Parsa, R. (1999)
Fitting bivariate loss distributions with copulas.
<em>Insurance: Mathematics and Economics</em>, <b>24</b>, 139&ndash;148.
</p>
<p>Beirlant, J., Goegebeur, Y., Segers, J. and Teugels, J. L. (2004)
<em>Statistics of Extremes: Theory and Applications.</em>,
Chichester, England: John Wiley and Sons.
</p>

<hr>
<h2 id='marma'>Simulate MARMA(p,q) Processes</h2><span id='topic+marma'></span><span id='topic+mar'></span><span id='topic+mma'></span>

<h3>Description</h3>

<p>Simulation of MARMA(p,q) processes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marma(n, p = 0, q = 0, psi, theta, init = rep(0, p), n.start = p,
    rand.gen = rfrechet, ...)
mar(n, p = 1, psi, init = rep(0, p), n.start = p, rand.gen =
    rfrechet, ...)
mma(n, q = 1, theta, rand.gen = rfrechet, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marma_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="marma_+3A_p">p</code></td>
<td>
<p>The AR order of the MARMA process.</p>
</td></tr>
<tr><td><code id="marma_+3A_q">q</code></td>
<td>
<p>The MA order of the MARMA process.</p>
</td></tr>
<tr><td><code id="marma_+3A_psi">psi</code></td>
<td>
<p>A vector of non-negative parameters, of length
<code>p</code>. Can be omitted if <code>p</code> is zero.</p>
</td></tr>
<tr><td><code id="marma_+3A_theta">theta</code></td>
<td>
<p>A vector of non-negative parameters, of length
<code>q</code>. Can be omitted if <code>q</code> is zero.</p>
</td></tr>
<tr><td><code id="marma_+3A_init">init</code></td>
<td>
<p>A vector of non-negative starting values, of
length <code>p</code>.</p>
</td></tr>
<tr><td><code id="marma_+3A_n.start">n.start</code></td>
<td>
<p>A non-negative value denoting the length of the
burn-in period. If <code>n.start</code> is less than <code>p</code>, then
<code>p</code> minus <code>n.start</code> starting values will be included
in the output series.</p>
</td></tr>
<tr><td><code id="marma_+3A_rand.gen">rand.gen</code></td>
<td>
<p>A simulation function to generate the
innovations.</p>
</td></tr>
<tr><td><code id="marma_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>rand.gen</code>.  Most
usefully, the scale and shape parameters of the innovations
generated by <code>rfrechet</code> can be specified by <code>scale</code>
and <code>shape</code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A max autoregressive moving average process <code class="reqn">\{X_k\}</code>,
denoted by MARMA(p,q), is defined in Davis and Resnick (1989) as
satisfying
</p>
<p style="text-align: center;"><code class="reqn">X_k = \max\{\phi_1 X_{k-1}, \ldots, \phi_p X_{k-p}, \epsilon_k,
    \theta_1 \epsilon_{k-1}, \ldots, \theta_q \epsilon_{k-q}\}</code>
</p>

<p>where <code class="reqn">\code{phi} = (\phi_1, \ldots, \phi_p)</code>
and <code class="reqn">\code{theta} = (\theta_1, \ldots, \theta_q)</code>
are non-negative vectors of parameters, and where
<code class="reqn">\{\epsilon_k\}</code> is a series of <em>iid</em>
random variables with a common distribution defined by
<code>rand.gen</code>.
</p>
<p>The functions <code>mar</code> and <code>mma</code> generate MAR(p) and
MMA(q) processes respectively.
A MAR(p) process <code class="reqn">\{X_k\}</code> is equivalent to a
MARMA(p, 0) process, so that
</p>
<p style="text-align: center;"><code class="reqn">X_k = \max\{\phi_1 X_{k-1}, \ldots, \phi_p X_{k-p},
    \epsilon_k\}.</code>
</p>

<p>A MMA(q) process <code class="reqn">\{X_k\}</code> is equivalent to a
MARMA(0, q) process, so that
</p>
<p style="text-align: center;"><code class="reqn">X_k = \max\{\epsilon_k, \theta_1 \epsilon_{k-1}, \ldots,
    \theta_q \epsilon_{k-q}\}.</code>
</p>



<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>References</h3>

<p>Davis, R. A. and Resnick, S. I. (1989)
Basic properties and prediction of max-arma processes.
<em>Adv. Appl. Prob.</em>, <b>21</b>, 781&ndash;803.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evmc">evmc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>marma(100, p = 1, q = 1, psi = 0.75, theta = 0.65)
mar(100, psi = 0.85, n.start = 20)
mma(100, q = 2, theta = c(0.75, 0.8))
</code></pre>

<hr>
<h2 id='mrlplot'>Empirical Mean Residual Life Plot</h2><span id='topic+mrlplot'></span>

<h3>Description</h3>

<p>The empirical mean residual life plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrlplot(data, tlim, pscale = FALSE, nt = max(100, length(data)), lty =
    c(2,1,2), col = 1, conf = 0.95, main = "Mean Residual Life Plot",
    xlab = "Threshold", ylab = "Mean Excess", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrlplot_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_tlim">tlim</code></td>
<td>
<p>A numeric vector of length two, giving the limits for
the thresholds at which the mean residual life plot is
evaluated. If <code>tlim</code> is not given, sensible defaults
are used.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_pscale">pscale</code></td>
<td>
<p>If <code>TRUE</code>, then the x-axis gives the threshold
exceedance probability rather than the threshold itself.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the mean residual life
plot is evaluated.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_lty">lty</code>, <code id="mrlplot_+3A_col">col</code></td>
<td>
<p>Arguments passed to <code>matplot</code>. The first
and last elements of <code>lty</code> correspond to the lower and
upper confidence limits respectively. Use zero to supress.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_conf">conf</code></td>
<td>
<p>The (pointwise) confidence coefficient for the
plotted confidence intervals.</p>
</td></tr> 
<tr><td><code id="mrlplot_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>     
<tr><td><code id="mrlplot_+3A_xlab">xlab</code>, <code id="mrlplot_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels.</p>
</td></tr>
<tr><td><code id="mrlplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>matplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical mean residual life plot is the locus of points
</p>
<p style="text-align: center;"><code class="reqn">\left(u,\frac{1}{n_u} \sum\nolimits_{i=1}^{n_u}
    (x_{(i)} - u) \right)</code>
</p>

<p>where <code class="reqn">x_{(1)}, \dots, x_{(n_u)}</code> are
the <code class="reqn">n_u</code> observations that exceed the threshold <code class="reqn">u</code>.
If the exceedances of a threshold <code class="reqn">u_0</code>
are generalized Pareto, the empirical mean residual life plot
should be approximately linear for <code class="reqn">u &gt; u_0</code>.
</p>
<p>The confidence intervals within the plot are symmetric intervals
based on the approximate normality of sample means.
</p>


<h3>Value</h3>

<p>A list with components <code>x</code> and <code>y</code> is invisibly returned.
The components contain those objects that were passed to the formal
arguments <code>x</code> and <code>y</code> of <code>matplot</code> in order to create
the mean residual life plot.
</p>


<h3>Author(s)</h3>

<p>Stuart Coles and Alec Stephenson</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpot">fpot</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>,
<code><a href="#topic+tcplot">tcplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mrlplot(portpirie)
</code></pre>

<hr>
<h2 id='mtransform'>GEV Transformations</h2><span id='topic+mtransform'></span>

<h3>Description</h3>

<p>Transforms to exponential margins under the GEV model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtransform(x, p, inv = FALSE, drp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtransform_+3A_x">x</code></td>
<td>
<p>A matrix with n rows and d columns, or a vector. In
the latter case, if <code>p</code> is a list with the same length
as the vector, it is treated as a matrix with one row. If
<code>p</code> is not a list, it is treated as a matrix with one
column.</p>
</td></tr>
<tr><td><code id="mtransform_+3A_p">p</code></td>
<td>
<p>A vector of length three or a matrix with n rows and
three columns. It can also be a list of length d, in which
case each element must be a vector of length three or a matrix
with n rows and three columns.</p>
</td></tr>
<tr><td><code id="mtransform_+3A_inv">inv</code></td>
<td>
<p>Logical; use the inverse transformation?</p>
</td></tr>
<tr><td><code id="mtransform_+3A_drp">drp</code></td>
<td>
<p>Logical; return a vector rather than a single row
matrix?. Note that a single column matrix is always returned
as a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">x_i</code> denote a vector of observations for
<code class="reqn">i = 1,\ldots,n</code>.
This function implements the transformation
</p>
<p style="text-align: center;"><code class="reqn">y_{i} = \{1+s_i(x_{i}-a_i)/b_i\}_{+}^{-1/s_i}</code>
</p>

<p>to each column of the matrix <code>x</code>.
</p>
<p>The values <code class="reqn">(a_i,b_i,s_i)</code> are contained in the ith
row of the n by 3 matrix <code>p</code>. If <code>p</code> is a vector
of length three, the parameters are the same for every
<code class="reqn">i = 1,\ldots,n</code>. Alternatively, <code>p</code> can be a list
with d elements, in which case the jth element is used to
transform the jth column of <code>x</code>.
</p>
<p>This function is mainly for internal use. It is used by
bivariate and multivariate routines to calculate marginal
transformations.
</p>


<h3>Value</h3>

<p>A numeric matrix or vector.
</p>

<hr>
<h2 id='mvevd'>Parametric Multivariate Extreme Value Distributions</h2><span id='topic+pmvevd'></span><span id='topic+rmvevd'></span><span id='topic+dmvevd'></span>

<h3>Description</h3>

<p>Density function, distribution function and random generation
for the multivariate logistic and multivariate asymmetric
logistic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvevd(q, dep, asy, model = c("log", "alog"), d = 2, mar = c(0,1,0),
    lower.tail = TRUE)
rmvevd(n, dep, asy, model = c("log", "alog"), d = 2, mar = c(0,1,0))
dmvevd(x, dep, asy, model = c("log", "alog"), d = 2, mar = c(0,1,0),
    log = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvevd_+3A_x">x</code>, <code id="mvevd_+3A_q">q</code></td>
<td>
<p>A vector of length <code>d</code> or a matrix with <code>d</code>
columns, in which case the density/distribution is evaluated
across the rows.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_dep">dep</code></td>
<td>
<p>The dependence parameter(s). For the logistic model,
should be a single value. For the asymmetric logistic model,
should be a vector of length <code class="reqn">2^d-d-1</code>, or a single value,
in which case the value is used for each of the <code class="reqn">2^d-d-1</code>
parameters (see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="mvevd_+3A_asy">asy</code></td>
<td>
<p>The asymmetry parameters for the asymmetric logistic
model. Should be a list with <code class="reqn">2^d-1</code> vector elements
containing the asymmetry parameters for each separate component
(see <b>Details</b>).</p>
</td></tr>
<tr><td><code id="mvevd_+3A_model">model</code></td>
<td>
<p>The specified model; a character string. Must be either
<code>"log"</code> (the default) or <code>"alog"</code> (or any unique partial
match), for the logistic and asymmetric logistic models respectively.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_d">d</code></td>
<td>
<p>The dimension.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_mar">mar</code></td>
<td>
<p>A vector of length three containing marginal parameters
for every univariate margin, or a matrix with three columns where
each column represents a vector of values to be passed to the
corresponding marginal parameter. It can also be a list with
<code>d</code> elements, such that each element is either a vector of
length three or a matrix with three columns, in which case the
<code class="reqn">i</code>th element represents the marginal parameters on the
<code class="reqn">i</code>th margin.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="mvevd_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), the
distribution function is returned; the survivor function
is returned otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Define
</p>
<p style="text-align: center;"><code class="reqn">y_i = y_i(z_i) = \{1+s_i(z_i-a_i)/b_i\}^{-1/s_i}</code>
</p>

<p>for <code class="reqn">1+s_i(z_i-a_i)/b_i &gt; 0</code> and
<code class="reqn">i = 1,\ldots,d</code>, where the marginal
parameters are given by
<code class="reqn">(a_i,b_i,s_i)</code>, <code class="reqn">b_i &gt; 0</code>.
If <code class="reqn">s_i = 0</code> then <code class="reqn">y_i</code> is defined by
continuity.
Let <code class="reqn">z = (z_1,z_2,\ldots,z_d)</code>.
In each of the multivariate distributions functions
<code class="reqn">G(z)</code> given below, the
univariate margins are generalized extreme value, so that
<code class="reqn">G(z_i) = \exp(-y_i)</code> for
<code class="reqn">i = 1,\ldots,d</code>.
If <code class="reqn">1+s_i(z_i-a_i)/b_i \leq 0</code> for some
<code class="reqn">i = 1,\ldots,d</code>, the value <code class="reqn">z_i</code> is
either greater than the upper end point (if <code class="reqn">s_i &lt; 0</code>),
or less than the lower end point (if <code class="reqn">s_i &gt; 0</code>), of the
<code class="reqn">i</code>th univariate marginal distribution.
</p>
<p><code>model = "log"</code> (Gumbel, 1960)
</p>
<p>The <code>d</code> dimensional multivariate logistic distribution
function with parameter <code class="reqn">\code{dep} = r</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left\{-\left(\sum\nolimits_{i = 1}^{d}
    y_i^{1/r}\right)^r\right\}</code>
</p>

<p>where <code class="reqn">0 &lt; r \leq 1</code>.
This is a special case of the multivariate asymmetric logistic
model.
</p>
<p><code>model = "alog"</code> (Tawn, 1990)
</p>
<p>Let <code class="reqn">B</code> be the set of all non-empty subsets of
<code class="reqn">\{1,\ldots,d\}</code>, let
<code class="reqn">B_1=\{b \in B:|b|=1\}</code>, where <code class="reqn">|b|</code>
denotes the number of elements in the set <code class="reqn">b</code>, and let
<code class="reqn">B_{(i)}=\{b \in B:i \in b\}</code>.
The <code>d</code> dimensional multivariate asymmetric logistic distribution
function is
</p>
<p style="text-align: center;"><code class="reqn">G(z)=\exp\left\{-\sum\nolimits_{b \in B} \left[\sum\nolimits_
    {i\in b}(t_{i,b}y_i)^{1/r_b}\right]^{r_b}\right\},</code>
</p>

<p>where the dependence parameters <code class="reqn">r_b\in(0,1]</code> for
all <code class="reqn">b\in B \setminus B_1</code>, and the asymmetry parameters
<code class="reqn">t_{i,b}\in[0,1]</code> for all <code class="reqn">b\in B</code>
and <code class="reqn">i\in b</code>.
The constraints
<code class="reqn">\sum_{b \in B_{(i)}}t_{i,b}=1</code> for
<code class="reqn">i = 1,\ldots,d</code>
ensure that the marginal distributions are generalized extreme value.
Further constraints arise from the possible redundancy of asymmetry
parameters in the expansion of the distribution form.
Let <code class="reqn">b_{-i_0} = \{i \in b:i \neq i_0\}</code>.
If <code class="reqn">r_b = 1</code> for some
<code class="reqn">b\in B \setminus B_1</code> then
<code class="reqn">t_{i,b} = 0</code> for all <code class="reqn">i\in b</code>.
Furthermore, if for some
<code class="reqn">b\in B \setminus B_1</code>,
<code class="reqn">t_{i,b} = 0</code> for all
<code class="reqn">i\in b_{-i_0}</code>, then
<code class="reqn">t_{i_0,b} = 0</code>.
</p>
<p><code>dep</code> should be a vector of length <code class="reqn">2^d-d-1</code> which contains
<code class="reqn">\{r_b:b\in B \setminus B_1\}</code>, with
the order defined by the natural set ordering on the index.
For example, for the trivariate model,
<code class="reqn">\code{dep} = (r_{12},r_{13},r_{23},r_{123})</code>.
<code>asy</code> should be a list with <code class="reqn">2^d-1</code> elements.
Each element is a vector which corresponds to a set
<code class="reqn">b\in B</code>, containing <code class="reqn">t_{i,b}</code> for
every integer <code class="reqn">i\in b</code>.
The elements should be given using the natural set ordering on the
<code class="reqn">b\in B</code>, so that the first <code class="reqn">d</code> elements are vectors
of length one corresponding to the sets
<code class="reqn">\{1\},\ldots,\{d\}</code>, and the last element is a
a vector of length <code class="reqn">d</code>, corresponding to the set
<code class="reqn">\{1,\ldots,d\}</code>.
<code>asy</code> must be constructed to ensure that all constraints are
satisfied or an error will occur.
</p>


<h3>Value</h3>

<p><code>pmvevd</code> gives the distribution function, <code>dmvevd</code> gives
the density function and <code>rmvevd</code> generates random deviates, for
the multivariate logistic or multivariate asymmetric logistic model.
</p>


<h3>Note</h3>

<p>Multivariate extensions of other bivariate models are more complex.
A multivariate extension of the Husler-Reiss model exists, involving
a multidimensional integral and one parameter for each bivariate
margin.
Multivariate extensions for the negative logistic model can be derived
but are considerably more complex and appear to be less flexible.
The &ldquo;multivariate negative logistic model&rdquo; often presented in the
literature (e.g. Kotz <em>et al</em>, 2000) is not a valid distribution
function and should not be used.
</p>
<p>The logistic and asymmetric logistic models respectively are
simulated using Algorithms 2.1 and 2.2 in Stephenson(2003b).
</p>
<p>The density function of the logistic model is evaluated using
the representation of Shi(1995).
The density function of the asymmetric logistic model is evaluated
using the representation given in Stephenson(2003a).
</p>


<h3>References</h3>

<p>Gumbel, E. J. (1960)
Distributions des valeurs extremes en plusieurs dimensions.
<em>Publ. Inst. Statist. Univ. Paris</em>, <b>9</b>, 171&ndash;173.
</p>
<p>Kotz, S. and Balakrishnan, N. and Johnson, N. L. (2000)
<em>Continuous Multivariate Distributions</em>, vol. 1.
New York: John Wiley &amp; Sons, 2nd edn.
</p>
<p>Shi, D. (1995)
Fisher information for a multivariate extreme value distribution.
<em>Biometrika</em>, <b>82</b>(3), 644&ndash;649.
</p>
<p>Stephenson, A. G. (2003a)
<em>Extreme Value Distributions and their Application</em>.
Ph.D. Thesis, Lancaster University, Lancaster, UK.
</p>
<p>Stephenson, A. G. (2003b)
Simulating multivariate extreme value distributions of logistic type.
<em>Extremes</em>, <b>6</b>(1), 49&ndash;60.
</p>
<p>Tawn, J. A. (1990)
Modelling multivariate extreme value distributions.
<em>Biometrika</em>, <b>77</b>, 245&ndash;253.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbvevd">rbvevd</a></code>, <code><a href="#topic+rgev">rgev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pmvevd(matrix(rep(0:4,5), ncol=5), dep = .7, model = "log", d = 5)
pmvevd(rep(4,5), dep = .7, model = "log", d = 5)
rmvevd(10, dep = .7, model = "log", d = 5)
dmvevd(rep(-1,20), dep = .7, model = "log", d = 20, log = TRUE)

asy &lt;- list(.4, .1, .6, c(.3,.2), c(.1,.1), c(.4,.1), c(.2,.3,.2))
pmvevd(rep(2,3), dep = c(.6,.5,.8,.3), asy = asy, model = "alog", d = 3)
asy &lt;- list(.4, .0, .6, c(.3,.2), c(.1,.1), c(.4,.1), c(.2,.4,.2))
rmvevd(10, dep = c(.6,.5,.8,.3), asy = asy, model = "alog", d = 3)
dmvevd(rep(0,3), dep = c(.6,.5,.8,.3), asy = asy, model = "alog", d = 3)

asy &lt;- list(0, 0, 0, 0, c(0,0), c(0,0), c(0,0), c(0,0), c(0,0), c(0,0),
  c(.2,.1,.2), c(.1,.1,.2), c(.3,.4,.1), c(.2,.2,.2), c(.4,.6,.2,.5))
rmvevd(10, dep = .7, asy = asy, model = "alog", d = 4)
rmvevd(10, dep = c(rep(1,6), rep(.7,5)), asy = asy, model = "alog", d = 4)
</code></pre>

<hr>
<h2 id='ocmulgee'>Maximum Annual Flood Discharges of the Ocmulgee River</h2><span id='topic+ocmulgee'></span>

<h3>Description</h3>

<p>The <code>ocmulgee</code> data frame has 40 rows and 2 columns.
The columns contain maximum annual flood discharges, in units
of 1000 cubed feet per second, from the Ocmulgee River in
Georgia, USA at Hawkinsville (upstream) and Macon (downstream),
for the years 1910 to 1949.
The row names give the years of observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocmulgee</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>hawk</dt><dd><p>A numeric vector containing maximum annual flood
discharges at Hawkinsville (upstream).</p>
</dd>
<dt>macon</dt><dd><p>A numeric vector containing maximum annual flood
discharges at Macon (downstream).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Gumbel, E. J. and Goldstein, N. (1964)
Analysis of empirical bivariate extremal distributions.
<em>J. Amer. Statist. Assoc.</em>, <b>59</b>, 794&ndash;816.
</p>

<hr>
<h2 id='oldage'>Oldest Ages for Swedish Males and Females</h2><span id='topic+oldage'></span>

<h3>Description</h3>

<p>The <code>oldage</code> data frame has 66 rows and 2 columns.
The columns contain the oldest ages at death for men and women in
Sweden, for the period 1905&ndash;1970.
The row names give the years of observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oldage</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>men</dt><dd><p>A numeric vector containing the oldest ages at death
for men.</p>
</dd>
<dt>women</dt><dd><p>A numeric vector containing the oldest ages at death
for women.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Fransen, A. and Tiago de Oliveira, J. (1984)
Statistical choice of univariate extreme models, part II, in
<em>Statistical Extremes and Applications</em>,
J. Tiago de Oliveira ed., 373&ndash;394, D. Reidel, Dordrect.
</p>

<hr>
<h2 id='order'>Distributions of Order Statistics</h2><span id='topic+dorder'></span><span id='topic+porder'></span><span id='topic+rorder'></span>

<h3>Description</h3>

<p>Density function, distribution function and random generation for
a selected order statistic of a given number of independent variables
from a specified distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dorder(x, densfun, distnfun, ..., distn, mlen = 1, j = 1,
      largest = TRUE, log = FALSE)
porder(q, distnfun, ..., distn, mlen = 1, j = 1, largest = TRUE,
      lower.tail = TRUE)  
rorder(n, quantfun, ..., distn, mlen = 1, j = 1, largest = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_+3A_x">x</code>, <code id="order_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="order_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="order_+3A_densfun">densfun</code>, <code id="order_+3A_distnfun">distnfun</code>, <code id="order_+3A_quantfun">quantfun</code></td>
<td>
<p>Density, distribution and
quantile function of the specified distribution. The density
function must have a <code>log</code> argument (a simple wrapper
can always be constructed to achieve this).</p>
</td></tr>
<tr><td><code id="order_+3A_...">...</code></td>
<td>
<p>Parameters of the specified distribution.</p>
</td></tr>
<tr><td><code id="order_+3A_distn">distn</code></td>
<td>
<p>A character string, optionally specified as an
alternative to <code>densfun</code>, <code>distnfun</code> and <code>quantfun</code>
such that the density, distribution and quantile functions are
formed upon the addition of the prefixes <code>d</code>, <code>p</code> and
<code>q</code> respectively.</p>
</td></tr>
<tr><td><code id="order_+3A_mlen">mlen</code></td>
<td>
<p>The number of independent variables.</p>
</td></tr>
<tr><td><code id="order_+3A_j">j</code></td>
<td>
<p>The order statistic, taken as the <code>j</code>th largest
(default) or smallest of <code>mlen</code>, according to the value of
<code>largest</code>.</p>
</td></tr>
<tr><td><code id="order_+3A_largest">largest</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) use the <code>j</code>th
largest order statistic, otherwise use the <code>j</code>th smallest.</p>
</td></tr>
<tr><td><code id="order_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="order_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default) probabilities
are P[X &lt;= x], otherwise  P[X &gt; x].</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dorder</code> gives the density function, <code>porder</code> gives the
distribution function and <code>qorder</code> gives the quantile function
of a selected order statistic from a sample of size <code>mlen</code>,
from a specified distibution. <code>rorder</code> generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rextreme">rextreme</a></code>, <code><a href="#topic+rgev">rgev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dorder(2:4, dnorm, pnorm, mean = 0.5, sd = 1.2, mlen = 5, j = 2)
dorder(2:4, distn = "norm", mean = 0.5, sd = 1.2, mlen = 5, j = 2)
dorder(2:4, distn = "exp", mlen = 2, j = 2)
porder(2:4, distn = "exp", rate = 1.2, mlen = 2, j = 2)
rorder(5, qgamma, shape = 1, mlen = 10, j = 2)
</code></pre>

<hr>
<h2 id='oxford'>Annual Maximum Temperatures at Oxford</h2><span id='topic+oxford'></span>

<h3>Description</h3>

<p>A numeric vector containing annual maximum temperatures, in degrees
Fahrenheit, from 1901 to 1980 at Oxford, England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxford</code></pre>


<h3>Format</h3>

<p>A vector containing 80 observations.</p>


<h3>Source</h3>

<p>Tabony, R. C. (1983)
Extreme value analysis in meteorology.
<em>The Meteorological Magazine</em> <b>112</b>, 77&ndash;98.
</p>

<hr>
<h2 id='plot.bvevd'>Plot Diagnostics for a Bivariate EVD Object</h2><span id='topic+plot.bvevd'></span>

<h3>Description</h3>

<p>Six plots (selectable by <code>which</code>) are currently provided:
two conditional P-P plots (1,2), conditioning on each margin, a
density plot (3), a dependence function plot (4), a quantile
curves plot (5) and a spectral density plot (6).
Plot diagnostics for the generalized extreme value margins
(selectable by <code>mar</code> and <code>which</code>) are also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvevd'
plot(x, mar = 0, which = 1:6, main, ask = nb.fig &lt;
    length(which) &amp;&amp; dev.interactive(), ci = TRUE, cilwd = 1,
    a = 0, grid = 50, legend = TRUE, nplty = 2, blty = 3, method = "cfg",
    convex = FALSE, rev = FALSE, p = seq(0.75, 0.95, 0.05),
    mint = 1, half = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bvevd_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bvevd"</code>.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_mar">mar</code></td>
<td>
<p>If <code>mar = 1</code> or <code>mar = 2</code> diagnostics
are given for the first or second genereralized extreme
value margin respectively.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_which">which</code></td>
<td>
<p>A subset of the numbers <code>1:6</code> selecting
the plots to be shown. By default all are plotted.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_main">main</code></td>
<td>
<p>Title of each plot. If given, should be a
character vector with the same length as <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_ci">ci</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), plot simulated
95% confidence intervals for the conditional P-P plots.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_cilwd">cilwd</code></td>
<td>
<p>Line width for confidence interval lines.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_a">a</code></td>
<td>
<p>Passed through to <code>ppoints</code> for empirical estimation.
Larger values give less probability for extreme events.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_grid">grid</code></td>
<td>
<p>Argument for the density plot. The (possibly
transformed) data is plotted with a contour plot of the
bivariate density of the fitted model. The density is evaluated
at <code>grid^2</code> points.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_legend">legend</code></td>
<td>
<p>If <code>legend</code> is <code>TRUE</code> and if the
fitted data contained a third column of mode <code>logical</code>,
then a legend is included in the density and quantile curve
plots.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_method">method</code>, <code id="plot.bvevd_+3A_convex">convex</code>, <code id="plot.bvevd_+3A_rev">rev</code></td>
<td>
<p>Arguments to the dependence function
plot. The dependence function for the fitted model is plotted and
(optionally) compared to a non-parameteric estimate. See
<code><a href="#topic+abvnonpar">abvnonpar</a></code> for a description of the arguments.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_nplty">nplty</code>, <code id="plot.bvevd_+3A_blty">blty</code></td>
<td>
<p>Line types for the dependence function plot.
<code>nplty</code> is the line type of the non-parametric estimate.
To omit the non-parametric estimate set <code>nplty</code> to zero.
<code>blty</code> is the line type of the triangular border. To omit
the border estimate set <code>blty</code> to zero.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_p">p</code>, <code id="plot.bvevd_+3A_mint">mint</code></td>
<td>
<p>Arguments to the quantile curves plot. See
<code><a href="#topic+qcbvnonpar">qcbvnonpar</a></code> for a description of the plot and
the arguments.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_half">half</code></td>
<td>
<p>Argument to the spectral density plot. See
<code><a href="#topic+hbvevd">hbvevd</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvevd_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In all plots we assume that the fitted model is
stationary. For non-stationary models the data are transformed
to stationarity. The plot then corresponds to the distribution
obtained when all covariates are zero. In particular, the
density and quanitle curves plots will not plot the original
data for non-stationary models.
</p>
<p>A conditional P-P plot is a P-P plot for the condition
distribution function of a bivariate evd object.
Let <code class="reqn">G(.|.)</code> be the conditional distribution of
the first margin given the second, under the fitted model.
Let <code class="reqn">z_1,\ldots,z_m</code> be the data used in the fitted model,
where <code class="reqn">z_j = (z_{1j}, z_{2j})</code> for <code class="reqn">j = 1,\ldots,m</code>.
The plot that (by default) is labelled Conditional Plot Two,
conditioning on the second margin, consists of the points
</p>
<p style="text-align: center;"><code class="reqn">\{(p_i, c_i), i = 1,\ldots,m\}</code>
</p>

<p>where <code class="reqn">p_1,\ldots,p_m</code> are plotting points defined by
<code><a href="stats.html#topic+ppoints">ppoints</a></code> and <code class="reqn">c_i</code> is the <code class="reqn">i</code>th largest
value from the sample
<code class="reqn">\{G(z_{j1}|z_{j2}), j = 1,\ldots,m\}.</code>
The margins are reversed for Conditional Plot One, so that
<code class="reqn">G(.|.)</code> is the conditional distribution of the second
margin given the first. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.uvevd">plot.uvevd</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="base.html#topic+jitter">jitter</a></code>, <code><a href="#topic+abvnonpar">abvnonpar</a></code>,
<code><a href="#topic+qcbvnonpar">qcbvnonpar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(100, dep = 0.6, model = "log")
M1 &lt;- fbvevd(bvdata, model = "log")
## Not run: par(mfrow = c(2,2))
## Not run: plot(M1, which = 1:5)
## Not run: plot(M1, mar = 1)
## Not run: plot(M1, mar = 2)
</code></pre>

<hr>
<h2 id='plot.bvpot'>Plot Diagnostics for a Bivariate POT EVD Object</h2><span id='topic+plot.bvpot'></span>

<h3>Description</h3>

<p>Four plots (selectable by <code>which</code>) are currently provided:
a density plot (1), a dependence function plot (2), a quantile
curves plot (3) and a spectral density plot (4).
Plot diagnostics for the generalized Pareto peaks-over-threshold
margins (selectable by <code>mar</code> and <code>which</code>) are also
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bvpot'
plot(x, mar = 0, which = 1:4, main, ask = nb.fig &lt;
    length(which) &amp;&amp; dev.interactive(), grid = 50, above = FALSE,
    levels = NULL, tlty = 1, blty = 3, rev = FALSE, p = seq(0.75,
    0.95, 0.05), half = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bvpot_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bvpot"</code>.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_mar">mar</code></td>
<td>
<p>If <code>mar = 1</code> or <code>mar = 2</code> diagnostics
are given for the first or second generalized Pareto
margin respectively.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_which">which</code></td>
<td>
<p>A subset of the numbers <code>1:4</code> selecting
the plots to be shown. By default all are plotted.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_main">main</code></td>
<td>
<p>Title of each plot. If given, should be a
character vector with the same length as <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_grid">grid</code>, <code id="plot.bvpot_+3A_levels">levels</code></td>
<td>
<p>Arguments for the density plot. The
data is plotted with a contour plot of the bivariate density
of the fitted model in the tail region. The density is evaluated
at <code>grid^2</code> points, and contours are plotted at the values
given in the numeric vector <code>levels</code>. If <code>levels</code> is
<code>NULL</code> (the default), the routine attempts to find sensible
values.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_above">above</code></td>
<td>
<p>Logical; if <code>TRUE</code>, only data points above
both marginal thresholds are plotted.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_tlty">tlty</code></td>
<td>
<p>Line type for the lines identifying the thresholds.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_rev">rev</code>, <code id="plot.bvpot_+3A_blty">blty</code></td>
<td>
<p>Arguments to the dependence function
plot. See <code><a href="#topic+abvevd">abvevd</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_p">p</code></td>
<td>
<p>Lower tail probabilities for the quantile curves plot.
The plot is of the same type as given by the function
<code><a href="#topic+qcbvnonpar">qcbvnonpar</a></code>, but applied to the parametric
bivariate threshold model.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_half">half</code></td>
<td>
<p>Argument to the spectral density plot. See
<code><a href="#topic+hbvevd">hbvevd</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bvpot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bvevd">plot.bvevd</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="#topic+abvnonpar">abvnonpar</a></code>, <code><a href="#topic+qcbvnonpar">qcbvnonpar</a></code>, <code><a href="#topic+hbvevd">hbvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(500, dep = 0.6, model = "log")
M1 &lt;- fbvpot(bvdata, threshold = c(0,0), model = "log")
## Not run: plot(M1)
## Not run: plot(M1, mar = 1)
## Not run: plot(M1, mar = 2)
</code></pre>

<hr>
<h2 id='plot.profile.evd'>Plot Profile Log-likelihoods</h2><span id='topic+plot.profile.evd'></span>

<h3>Description</h3>

<p>Displays profile log-likelihoods from a model profiled with
<code><a href="#topic+profile.evd">profile.evd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.evd'
plot(x, which = names(x), main = NULL,
    ask = nb.fig &lt; length(which) &amp;&amp; dev.interactive(), ci = 0.95,
    clty = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile.evd_+3A_x">x</code></td>
<td>
<p>An object of class <code>"profile.evd"</code>.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_which">which</code></td>
<td>
<p>A character vector giving the parameters for which
the profile deviance is plotted, and for which profile confidence
intervals are calculated. By default all profiled parameters in
<code>x</code> are used.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_main">main</code></td>
<td>
<p>Title of each plot; a character vector, the
same length as <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_ci">ci</code></td>
<td>
<p>A numeric vector. For each parameter in <code>which</code>
profile confidence intervals are calculated, for each confidence
coefficient in <code>ci</code> (but see <b>Warning</b>).
The intervals are returned invisibly as a list of
vectors/matrices. Each plot then (by default) includes
horizonal lines that represent each interval.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_clty">clty</code></td>
<td>
<p>The line type of the horizontal lines that represent
the profile confidence intervals. To omit the lines set
<code>clty</code> to zero.</p>
</td></tr>
<tr><td><code id="plot.profile.evd_+3A_...">...</code></td>
<td>
<p>Other graphics parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Profile devainces are plotted for each parameter in
<code>which</code>. For calculation of profile confidence intervals,
use the <code><a href="#topic+confint.profile.evd">confint.profile.evd</a></code> function.
</p>


<h3>Warning</h3>

<p>The profile confidence intervals may not have confidence coefficient
<code>ci</code>, because the usual asymptotic properties of maximum
likelihood estimators may not hold.
For the GEV model, the usual asymptotic properties hold when the
shape parameter is greater than <code class="reqn">-0.5</code> (Smith, 1985).
</p>


<h3>References</h3>

<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.profile.evd">confint.profile.evd</a></code>, <code><a href="#topic+plot.profile2d.evd">plot.profile2d.evd</a></code>, 
<code><a href="#topic+profile.evd">profile.evd</a></code>, <code><a href="#topic+profile2d.evd">profile2d.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata)
## Not run: M1P &lt;- profile(M1)
## Not run: par(mfrow = c(2,2))
## Not run: cint &lt;- plot(M1P, ci = c(0.95, 0.99))
## Not run: cint
</code></pre>

<hr>
<h2 id='plot.profile2d.evd'>Plot Joint Profile Log-likelihoods</h2><span id='topic+plot.profile2d.evd'></span>

<h3>Description</h3>

<p>Displays an image plot of the joint profile log-likelihood
from a model profiled with <code><a href="#topic+profile.evd">profile.evd</a></code> and
<code><a href="#topic+profile2d.evd">profile2d.evd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile2d.evd'
plot(x, main = NULL,
    ci = c(0.5, 0.8, 0.9, 0.95, 0.975, 0.99, 0.995),
    col = heat.colors(8), intpts = 75, xaxs = "r", yaxs = "r", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile2d.evd_+3A_x">x</code></td>
<td>
<p>An object of class <code>"profile2d.evd"</code>.</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_main">main</code></td>
<td>
<p>Title of plot; a character string.</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_ci">ci</code></td>
<td>
<p>A numeric vector whose length is one less than the
length of <code>col</code>. The colours of the image plot,
excluding the background colour, represent confidence sets
with confidence coefficients <code>ci</code> (but see <b>Warning</b>).</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_col">col</code></td>
<td>
<p>A list of colors such as that generated by
<code>rainbow</code>, <code>heat.colors</code>, <code>topo.colors</code>,
<code>terrain.colors</code> or similar functions.</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_intpts">intpts</code></td>
<td>
<p>If the package <a href="https://CRAN.R-project.org/package=interp"><span class="pkg">interp</span></a> is available,
interpolation is performed using <code>intpts</code> points
for each parameter. The function is interpolated at
<code>intpts^2</code> points in total.</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_xaxs">xaxs</code>, <code id="plot.profile2d.evd_+3A_yaxs">yaxs</code></td>
<td>
<p>Graphics parameters (see <code><a href="graphics.html#topic+par">par</a></code>).
The default, <code>"r"</code>, overrides the default set by
<code>image</code>.</p>
</td></tr>
<tr><td><code id="plot.profile2d.evd_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to <code>image</code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The sets represented by different colours may not be
confidence sets with confidence coefficients <code>ci</code>, because
the usual asymptotic properties of maximum likelihood estimators
may not hold.
For the GEV model, the usual asymptotic properties hold when the
shape parameter is greater than <code class="reqn">-0.5</code> (Smith, 1985).
</p>


<h3>References</h3>

<p>Smith, R. L. (1985)
Maximum likelihood estimation in a class of non-regular cases.
<em>Biometrika</em>, <b>72</b>, 67&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.profile.evd">plot.profile.evd</a></code>, <code><a href="#topic+profile.evd">profile.evd</a></code>,
<code><a href="#topic+profile2d.evd">profile2d.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata)
## Not run: M1P &lt;- profile(M1)
## Not run: M1JP &lt;- profile2d(M1, M1P, which = c("scale", "shape"))
## Not run: plot(M1JP)
</code></pre>

<hr>
<h2 id='plot.uvevd'>Plot Diagnostics for a Univariate EVD Object</h2><span id='topic+plot.uvevd'></span><span id='topic+plot.gumbelx'></span>

<h3>Description</h3>

<p>Four plots (selectable by <code>which</code>) are currently provided:
a P-P plot, a Q-Q plot, a density plot and a return level plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uvevd'
plot(x, which = 1:4, main, ask = nb.fig &lt;
    length(which) &amp;&amp; dev.interactive(), ci = TRUE, cilwd = 1,
    a = 0, adjust = 1, jitter = FALSE, nplty = 2, ...)
## S3 method for class 'gumbelx'
plot(x, interval, which = 1:4, main, ask = nb.fig &lt;
    length(which) &amp;&amp; dev.interactive(), ci = TRUE, cilwd = 1,
    a = 0, adjust = 1, jitter = FALSE, nplty = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uvevd_+3A_x">x</code></td>
<td>
<p>An object that inherits from class <code>"uvevd"</code>.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a
subset of the numbers <code>1:4</code>.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_main">main</code></td>
<td>
<p>Title of each plot. If given, must be a character
vector with the same length as <code>which</code>.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_ci">ci</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), plot simulated
95% confidence intervals for the P-P, Q-Q and return level
plots.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_cilwd">cilwd</code></td>
<td>
<p>Line width for confidence interval lines.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_a">a</code></td>
<td>
<p>Passed through to <code>ppoints</code> for empirical estimation.
Larger values give less probability for extreme events.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_adjust">adjust</code>, <code id="plot.uvevd_+3A_jitter">jitter</code>, <code id="plot.uvevd_+3A_nplty">nplty</code></td>
<td>
<p>Arguments to the density plot.
The density of the fitted model is plotted with a rug plot and
(optionally) a non-parameteric estimate. The argument
<code>adjust</code> controls the smoothing bandwidth for the
non-parametric estimate (see <code><a href="stats.html#topic+density">density</a></code>).
<code>jitter</code> is logical; if <code>TRUE</code>, the (possibly
transformed) data are jittered to produce the rug plot.
This need only be used if the data contains repeated
values. <code>nplty</code> is the line type of the non-parametric
estimate. To omit the non-parametric estimate set <code>nplty</code>
to zero.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_interval">interval</code></td>
<td>
<p>A vector of length two, for the gumbelx (maximum 
of two Gumbels) model. This is passed to the uniroot function to
calculate quantiles for the Q-Q and return level plots. The interval
should be large enough to contain all plotted quantiles or an error
from uniroot will occur.</p>
</td></tr>
<tr><td><code id="plot.uvevd_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed through to plotting
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following discussion assumes that the fitted model is
stationary. For non-stationary generalized extreme value
models the data are transformed to stationarity. The plot
then corresponds to the distribution obtained when all
covariates are zero.
</p>
<p>The P-P plot consists of the points
</p>
<p style="text-align: center;"><code class="reqn">\{(G_n(z_i), G(z_i)), i = 1,\ldots,m\}</code>
</p>

<p>where <code class="reqn">G_n</code> is the empirical distribution function
(defined using <code><a href="stats.html#topic+ppoints">ppoints</a></code>), G is the model based
estimate of the distribution (generalized extreme value
or generalized Pareto), and <code class="reqn">z_1,\ldots,z_m</code> are the data
used in the fitted model, sorted into ascending order.
</p>
<p>The Q-Q plot consists of the points
</p>
<p style="text-align: center;"><code class="reqn">\{(G^{-1}(p_i), z_i), i = 1,\ldots,m\}</code>
</p>

<p>where <code class="reqn">G^{-1}</code> is the model based estimate of the quantile
function (generalized extreme value or generalized Pareto),
<code class="reqn">p_1,\ldots,p_m</code> are plotting points defined by
<code><a href="stats.html#topic+ppoints">ppoints</a></code>, and <code class="reqn">z_1,\ldots,z_m</code> are the data
used in the fitted model, sorted into ascending order.
</p>
<p>The return level plot for generalized extreme value models
is defined as follows.
</p>
<p>Let <code class="reqn">G</code> be the generalized extreme value distribution
function, with location, scale and shape parameters <code class="reqn">a</code>,
<code class="reqn">b</code> and <code class="reqn">s</code> respectively.
Let <code class="reqn">z_t</code> be defined by <code class="reqn">G(z_t) = 1 - 1/t</code>.
In common terminology, <code class="reqn">z_t</code> is the return level
associated with the return period <code class="reqn">t</code>.
</p>
<p>Let <code class="reqn">y_t = -1/\log(1 - 1/t)</code>.
It follows that
</p>
<p style="text-align: center;"><code class="reqn">z_t = a + b(y_t^s - 1)/s.</code>
</p>

<p>When <code class="reqn">s = 0</code>, <code class="reqn">z_t</code> is defined by continuity, so that
</p>
<p style="text-align: center;"><code class="reqn">z_t = a + b\log(y_t).</code>
</p>

<p>The curve within the return level plot is <code class="reqn">z_t</code> plotted
against <code class="reqn">y_t</code> on a logarithmic scale, using maximum likelihood
estimates of <code class="reqn">(a,b,s)</code>. If the estimate of <code class="reqn">s</code> is zero, the
curve will be linear.
For large values of <code class="reqn">t</code>, <code class="reqn">y_t</code> is approximately equal
to the return period <code class="reqn">t</code>. It is usual practice to label the
x-axis as the return period.  
</p>
<p>The points on the plot are  
</p>
<p style="text-align: center;"><code class="reqn">\{(-1/\log(p_i), z_i), i = 1,\ldots,m\}</code>
</p>

<p>where <code class="reqn">p_1,\ldots,p_m</code> are plotting points defined by
<code><a href="stats.html#topic+ppoints">ppoints</a></code>, and <code class="reqn">z_1,\ldots,z_m</code> are the data
used in the fitted model, sorted into ascending order.
For a good fit the points should lie &ldquo;close&rdquo; to the curve.
</p>
<p>The return level plot for peaks over threshold models is
defined as follows.
</p>
<p>Let <code class="reqn">G</code> be the generalized Pareto distribution function,
with location, scale and shape parameters <code class="reqn">u</code>, <code class="reqn">b</code>
and <code class="reqn">s</code> respectively, where <code class="reqn">u</code> is the model threshold.
Let <code class="reqn">z_m</code> denote the <code class="reqn">m</code> period return level
(see <code><a href="#topic+fpot">fpot</a></code> and the notation therein).
It follows that 
</p>
<p style="text-align: center;"><code class="reqn">z_m = u + b((pmN)^s - 1)/s.</code>
</p>

<p>When <code class="reqn">s = 0</code>, <code class="reqn">z_m</code> is defined by continuity, so that
</p>
<p style="text-align: center;"><code class="reqn">z_m = u + b\log(pmN).</code>
</p>

<p>The curve within the return level plot is <code class="reqn">z_m</code> plotted
against <code class="reqn">m</code> on a logarithmic scale, using maximum likelihood
estimates of <code class="reqn">(b,s,p)</code>. If the estimate of <code class="reqn">s</code> is zero,
the curve will be linear.  
</p>
<p>The points on the plot are  
</p>
<p style="text-align: center;"><code class="reqn">\{(1/(pN(1-p_i)), z_i), i = 1,\ldots,m\}</code>
</p>

<p>where <code class="reqn">p_1,\ldots,p_m</code> are plotting points defined by
<code><a href="stats.html#topic+ppoints">ppoints</a></code>, and <code class="reqn">z_1,\ldots,z_m</code> are the data
used in the fitted model, sorted into ascending order.
For a good fit the points should lie &ldquo;close&rdquo; to the curve.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bvevd">plot.bvevd</a></code>, <code><a href="stats.html#topic+density">density</a></code>,
<code><a href="base.html#topic+jitter">jitter</a></code>, <code><a href="graphics.html#topic+rug">rug</a></code>, <code><a href="stats.html#topic+ppoints">ppoints</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata)
## Not run: par(mfrow = c(2,2))
## Not run: plot(M1)

uvdata &lt;- rgpd(100, loc = 0, scale = 1.1, shape = 0.2)
M1 &lt;- fpot(uvdata, 1)
## Not run: par(mfrow = c(2,2))
## Not run: plot(M1)
</code></pre>

<hr>
<h2 id='portpirie'>Annual Maximum Sea Levels at Port Pirie</h2><span id='topic+portpirie'></span>

<h3>Description</h3>

<p>A numeric vector containing annual maximum sea levels, in metres,
from 1923 to 1987 at Port Pirie, South Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portpirie</code></pre>


<h3>Format</h3>

<p>A vector containing 65 observations.</p>


<h3>Source</h3>

<p>Tawn, J. A. (1993)
Extreme sea-levels, in <em>Statistics in the Environment</em>,
243&ndash;263, eds. V. Barnett and F. Turkman, Wiley.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modeling of Extreme Values</em>.
London: Springer-Verlag.
</p>

<hr>
<h2 id='profile.evd'>Method for Profiling EVD Objects</h2><span id='topic+profile.evd'></span>

<h3>Description</h3>

<p>Calculate profile traces for fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evd'
profile(fitted, which = names(fitted$estimate), conf = 0.999,
    mesh = fitted$std.err[which]/4, xmin = rep(-Inf, length(which)),
    xmax = rep(Inf, length(which)), convergence = FALSE, method = "BFGS",
    control = list(maxit = 500), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.evd_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>"evd"</code>.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_which">which</code></td>
<td>
<p>A character vector giving the model parameters that
are to be profiled. By default, all parameters are profiled.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_conf">conf</code></td>
<td>
<p>Controls the range over which the parameters are profiled.
The profile trace is constructed so that (assuming the usual
asymptotic properties hold) profile confidence intervals with
confidence coefficients <code>conf</code> or less can be derived from it.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_mesh">mesh</code></td>
<td>
<p>A numeric vector containing one value for each
parameter in <code>which</code>. The values represent the
distance between the points profiled. By default <code>mesh</code> is
one quarter of the standard errors. If the fitted object does not
contain standard errors the argument must be specified.
The argument should also be specified when an estimator is
on or close to a parameter boundary, since the approximated
&ldquo;standard error&rdquo; will then be close to zero.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_xmin">xmin</code>, <code id="profile.evd_+3A_xmax">xmax</code></td>
<td>
<p>Numeric vectors containing one value for each
parameter in <code>which</code>. Each value represents the theoretical
lower/upper bound of the corresponding parameter.
The arguments are needed only when a parameter has a
lower/upper bound at which the likelihood is non-zero. Do not
use these arguments to specify plotting ranges in a subsequent
plot (as they are used in the calculation of profile confidence
intervals); to do this use <code>xlim</code> in the call to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_convergence">convergence</code></td>
<td>
<p>Logical; print convergence code after each
optimization? (A warning is given for each non-zero convergence
code, irrespective of the value of <code>convergence</code>.)</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_method">method</code></td>
<td>
<p>The optimization method.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_control">control</code></td>
<td>
<p>Passed to <code>optim</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for
details.</p>
</td></tr>
<tr><td><code id="profile.evd_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"profile.evd"</code>, which is a list with an
element for each parameter being profiled. The elements are
matrices. The first column contains the values of the profiled
parameter. The second column contains profile deviances. The
remaining columns contain the constrained maximum likelihood
estimates for the remaining model parameters. For calculation of 
profile confidence intervals, use the <code><a href="#topic+confint.profile.evd">confint.profile.evd</a></code> 
function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.profile.evd">confint.profile.evd</a></code>, <code><a href="#topic+profile2d.evd">profile2d.evd</a></code>, 
<code><a href="#topic+plot.profile.evd">plot.profile.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata)
## Not run: M1P &lt;- profile(M1)
## Not run: par(mfrow = c(2,2))
## Not run: cint &lt;- plot(M1P)
## Not run: cint
</code></pre>

<hr>
<h2 id='profile2d.evd'>Method for Profiling EVD Objects</h2><span id='topic+profile2d'></span><span id='topic+profile2d.evd'></span>

<h3>Description</h3>

<p>Calculate joint profile traces for fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evd'
profile2d(fitted, prof, which, pts = 20, convergence =
    FALSE, method = "Nelder-Mead", control = list(maxit = 5000), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile2d.evd_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>"evd"</code>.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_prof">prof</code></td>
<td>
<p>An object of class <code>"profile.evd"</code>, created using
<code><a href="#topic+profile.evd">profile.evd</a></code> with argument <code>fitted</code>.
The object must contain the (marginal) profile traces for the two
parameters specified in <code>which</code>.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_which">which</code></td>
<td>
<p>A character vector of length two containing the original 
model parameters that are to be jointly profiled.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_pts">pts</code></td>
<td>
<p>The number of distinct values used for each profiled
parameter in <code>which</code>.
There are <code>pts^2</code> optimizations performed in total.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_convergence">convergence</code></td>
<td>
<p>Logical; print convergence code after each
optimization? (A warning is given for each non-zero convergence
code, irrespective of the value of <code>convergence</code>.)</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_method">method</code></td>
<td>
<p>The optimization method.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_control">control</code></td>
<td>
<p>Passed to <code>optim</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for
details.</p>
</td></tr>
<tr><td><code id="profile2d.evd_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"profile2d.evd"</code>, which is a list with three
elements.
The first element, a matrix named <code>trace</code>, has the same structure
as the elements of an object of class <code>"profile.evd"</code>.
The last two elements give the distinct values used for each profiled
parameter in <code>which</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile.evd">profile.evd</a></code>, <code><a href="#topic+plot.profile2d.evd">plot.profile2d.evd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>uvdata &lt;- rgev(100, loc = 0.13, scale = 1.1, shape = 0.2)
M1 &lt;- fgev(uvdata)
## Not run: M1P &lt;- profile(M1)
## Not run: M1JP &lt;- profile2d(M1, M1P, which = c("scale", "shape"))
## Not run: plot(M1JP)
</code></pre>

<hr>
<h2 id='qcbvnonpar'>Non-parametric Estimates for Bivariate Quantile Curves</h2><span id='topic+qcbvnonpar'></span>

<h3>Description</h3>

<p>Calculate or plot non-parametric estimates for quantile curves
of bivariate extreme value distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcbvnonpar(p = seq(0.75, 0.95, 0.05), data, epmar = FALSE, nsloc1 =
    NULL, nsloc2 = NULL, mint = 1, method = c("cfg", "pickands",
    "tdo"), convex = FALSE, madj = 0, kmar = NULL, plot = FALSE,
    add = FALSE, lty = 1, lwd = 1, col = 1, xlim = range(data[,1],
    na.rm = TRUE), ylim = range(data[,2], na.rm = TRUE), xlab =
    colnames(data)[1], ylab = colnames(data)[2], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qcbvnonpar_+3A_p">p</code></td>
<td>
<p>A vector of lower tail probabilities. One quantile curve is
calculated or plotted for each probability.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_data">data</code></td>
<td>
<p>A matrix or data frame with two columns, which may contain
missing values.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_epmar">epmar</code></td>
<td>
<p>If <code>TRUE</code>, an empirical transformation of the
marginals is performed in preference to marginal parametric
GEV estimation, and the <code>nsloc</code> arguments are ignored.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_nsloc1">nsloc1</code>, <code id="qcbvnonpar_+3A_nsloc2">nsloc2</code></td>
<td>
<p>A data frame with the same number of rows as
<code>data</code>, for linear modelling of the location parameter on the
first/second margin. The data frames are treated as covariate
matrices, excluding the intercept. A numeric vector can be given
as an alternative to a single column data frame.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_mint">mint</code></td>
<td>
<p>An integer <code class="reqn">m</code>. Quantile curves are plotted or
calculated using the lower tail probabilities <code class="reqn">p^m</code>.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_method">method</code>, <code id="qcbvnonpar_+3A_kmar">kmar</code></td>
<td>
<p>Arguments for the non-parametric estimate of the
dependence function. See <code><a href="#topic+abvnonpar">abvnonpar</a></code>.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_convex">convex</code>, <code id="qcbvnonpar_+3A_madj">madj</code></td>
<td>
<p>Other arguments for the non-parametric
estimate of the dependence function.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_plot">plot</code></td>
<td>
<p>Logical; if <code>TRUE</code> the data is plotted along
with the quantile curves. If <code>plot</code> and <code>add</code> are
<code>FALSE</code> (the default), the arguments following <code>add</code>
are ignored.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_add">add</code></td>
<td>
<p>Logical; add quantile curves to an existing data plot?
The existing plot should have been created using either
<code>qcbvnonpar</code> or <code><a href="#topic+plot.bvevd">plot.bvevd</a></code>, the latter of
which can plot quantile curves for parametric fits.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_lty">lty</code>, <code id="qcbvnonpar_+3A_lwd">lwd</code></td>
<td>
<p>Line types and widths.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_col">col</code></td>
<td>
<p>Line colour.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_xlim">xlim</code>, <code id="qcbvnonpar_+3A_ylim">ylim</code></td>
<td>
<p>x and y-axis limits.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_xlab">xlab</code>, <code id="qcbvnonpar_+3A_ylab">ylab</code></td>
<td>
<p>x and y-axis labels.</p>
</td></tr>
<tr><td><code id="qcbvnonpar_+3A_...">...</code></td>
<td>
<p>Other high-level graphics parameters to be passed to
<code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let G be a fitted bivariate distribution function with
margins <code class="reqn">G_1</code> and <code class="reqn">G_2</code>. A quantile curve for a fitted
distribution function G at lower tail probability p is defined
by
</p>
<p style="text-align: center;"><code class="reqn">Q(G, p) = \{(y_1,y_1):G(y_1,y_2) = p\}.</code>
</p>

<p>For bivariate extreme value distributions, it consists
of the points
</p>
<p style="text-align: center;"><code class="reqn">\left\{G_1^{-1}(p_1),G_2^{-1}(p_2))\right\}</code>
</p>

<p>where <code class="reqn">p_1 = p^{t/A(t)}</code> and <code class="reqn">p_2 = p^{(1-t)/A(t)}</code>,
with <code class="reqn">A</code> being the estimated dependence function defined
in <code><a href="#topic+abvevd">abvevd</a></code>, and where <code class="reqn">t</code> lies in the interval
<code class="reqn">[0,1]</code>.
</p>
<p>By default the margins <code class="reqn">G_1</code> and <code class="reqn">G_2</code> are modelled using
estimated generalized extreme value distributions.
For non-stationary generalized extreme value margins the plotted
data are transformed to stationarity, and the plot corresponds
to the distribution obtained when all covariates are zero.
</p>
<p>If <code>epmar</code> is <code>TRUE</code>, empirical transformations
are used in preference to generalized extreme value models.
Note that the marginal empirical quantile functions are
evaluated using <code><a href="stats.html#topic+quantile">quantile</a></code>, which linearly
interpolates between data points, hence the curve will not
be a step function.
</p>
<p>The idea behind the argument <code class="reqn">\code{mint} = m</code> is that if
G is fitted to a dataset of componentwise maxima, and the
underlying observations are <em>iid</em> distributed according
to F, then if <code class="reqn">m</code> is the size of the blocks over which the
maxima were taken, approximately <code class="reqn">F^m = G</code>, leading
to <code class="reqn">Q(F, p) = Q(G, p^m)</code>.
</p>


<h3>Value</h3>

<p><code>qcbvnonpar</code> calculates or plots non-parametric quantile
curve estimates for bivariate extreme value distributions.
If <code>p</code> has length one it returns a two column matrix
giving points on the curve, else it returns a list of
such matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+abvevd">abvevd</a></code>, <code><a href="#topic+abvnonpar">abvnonpar</a></code>,
<code><a href="#topic+plot.bvevd">plot.bvevd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>bvdata &lt;- rbvevd(100, dep = 0.7, model = "log")
qcbvnonpar(c(0.9,0.95), data = bvdata, plot = TRUE)
qcbvnonpar(c(0.9,0.95), data = bvdata, epmar = TRUE, plot = TRUE)
</code></pre>

<hr>
<h2 id='rweibull'>The Reverse Weibull Distribution</h2><span id='topic+drweibull'></span><span id='topic+prweibull'></span><span id='topic+qrweibull'></span><span id='topic+rrweibull'></span><span id='topic+dnweibull'></span><span id='topic+pnweibull'></span><span id='topic+qnweibull'></span><span id='topic+rnweibull'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the reverse (or negative) Weibull 
distribution with location, scale and shape parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drweibull(x, loc=0, scale=1, shape=1, log = FALSE) 
prweibull(q, loc=0, scale=1, shape=1, lower.tail = TRUE) 
qrweibull(p, loc=0, scale=1, shape=1, lower.tail = TRUE)
rrweibull(n, loc=0, scale=1, shape=1)

dnweibull(x, loc=0, scale=1, shape=1, log = FALSE) 
pnweibull(q, loc=0, scale=1, shape=1, lower.tail = TRUE) 
qnweibull(p, loc=0, scale=1, shape=1, lower.tail = TRUE)
rnweibull(n, loc=0, scale=1, shape=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rweibull_+3A_x">x</code>, <code id="rweibull_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="rweibull_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="rweibull_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="rweibull_+3A_loc">loc</code>, <code id="rweibull_+3A_scale">scale</code>, <code id="rweibull_+3A_shape">shape</code></td>
<td>
<p>Location, scale and shape parameters (can be
given as vectors).</p>
</td></tr>
<tr><td><code id="rweibull_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the log density is returned.</p>
</td></tr>
<tr><td><code id="rweibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), probabilities
are P[X &lt;= x], otherwise, P[X &gt; x]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reverse (or negative) Weibull distribution function with parameters
<code class="reqn">\code{loc} = a</code>, <code class="reqn">\code{scale} = b</code> and
<code class="reqn">\code{shape} = s</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left\{-\left[-\left(\frac{z-a}{b}\right)
    \right]^s\right\}</code>
</p>

<p>for <code class="reqn">z &lt; a</code> and one otherwise, where <code class="reqn">b &gt; 0</code> and
<code class="reqn">s &gt; 0</code>.
</p>


<h3>Value</h3>

<p><code>drweibull</code> and <code>dnweibull</code> give the density function, 
<code>prweibull</code> and <code>pnweibull</code> give the distribution function, 
<code>qrweibull</code> and <code>qnweibull</code> give the quantile function, 
<code>rrweibull</code> and <code>rnweibull</code> generate random deviates.
</p>


<h3>Note</h3>

<p>Within extreme value theory the reverse Weibull distibution (also
known as the negative Weibull distribution) is often referred to 
as the Weibull distribution.
We make a distinction to avoid confusion with the three-parameter
distribution used in survival analysis, which is related by a
change of sign to the distribution given above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfrechet">rfrechet</a></code>, <code><a href="#topic+rgev">rgev</a></code>, <code><a href="#topic+rgumbel">rgumbel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>drweibull(-5:-3, -1, 0.5, 0.8)
prweibull(-5:-3, -1, 0.5, 0.8)
qrweibull(seq(0.9, 0.6, -0.1), 2, 0.5, 0.8)
rrweibull(6, -1, 0.5, 0.8)
p &lt;- (1:9)/10
prweibull(qrweibull(p, -1, 2, 0.8), -1, 2, 0.8)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
</code></pre>

<hr>
<h2 id='sask'>Maximum Annual Flood Discharges of the North Saskachevan River</h2><span id='topic+sask'></span>

<h3>Description</h3>

<p>A numeric vector containing maximum annual flood discharges, in
units of 1000 cubic feet per second, of the North Saskachevan
River at Edmonton, over a period of 47 years. Unfortunately,
the data are ordered from largest to smallest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sask</code></pre>


<h3>Format</h3>

<p>A vector containing 47 observations.</p>


<h3>Source</h3>

<p>van Montfort, M. A. J. (1970)
On testing that the distribution is of type I when type II
is the alternative.
<em>J. Hydrology</em>, <b>11</b>, 421&ndash;427.
</p>

<hr>
<h2 id='sealevel'>Annual Sea Level Maxima at Dover and Harwich</h2><span id='topic+sealevel'></span>

<h3>Description</h3>

<p>The <code>sealevel</code> data frame has 81 rows and 2 columns.
The columns contain annual sea level maxima from 1912 to 1992 at
Dover and Harwich respectively, two sites on the coast of Britain.
The row names give the years of observation.
There are 39 missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sealevel</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>dover</dt><dd><p>A numeric vector containing annual sea level maxima
at Dover, including 9 missing values.</p>
</dd>
<dt>harwich</dt><dd><p>A numeric vector containing sea annual level maxima
at Harwich, including 30 missing values.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. and Tawn, J. A. (1990)
Statistics of coastal flood prevention.
<em>Phil. Trans. R. Soc. Lond., A</em> <b>332</b>, 457&ndash;476.
</p>

<hr>
<h2 id='sealevel2'>Annual Sea Level Maxima at Dover and Harwich with Indicator</h2><span id='topic+sealevel2'></span>

<h3>Description</h3>

<p>The <code>sealevel2</code> data frame has 81 rows and 3 columns.
The first two columns contain annual sea level maxima from 1912
to 1992 at Dover and Harwich respectively, two sites on the coast
of Britain.
The third column is a logical vector denoting whether or not the
maxima in a given year are assumed to have derived from the
same storm event; this assumption is made if the times of
obsevation of the maxima are at most 48 hours apart.
The row names give the years of observation.
There are 39 missing data values.
There are only nine non-missing logical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sealevel2</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>dover</dt><dd><p>A numeric vector containing annual sea level maxima
at Dover, including 9 missing values.</p>
</dd>
<dt>harwich</dt><dd><p>A numeric vector containing sea annual level maxima
at Harwich, including 30 missing values.</p>
</dd>
<dt>case</dt><dd><p>A logical vector denoting whether or not the maxima
are assumed to have derived from the same storm event.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. and Tawn, J. A. (1990)
Statistics of coastal flood prevention.
<em>Phil. Trans. R. Soc. Lond., A</em> <b>332</b>, 457&ndash;476.
</p>

<hr>
<h2 id='tcplot'>Threshold Choice Plot</h2><span id='topic+tcplot'></span>

<h3>Description</h3>

<p>Plots of parameter estimates at various thresholds for peaks
over threshold modelling, using the Generalized Pareto or Point
Process representation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplot(data, tlim, model = c("gpd","pp"), pscale = FALSE, cmax =
    FALSE, r = 1, ulow = -Inf, rlow = 1, nt = 25, which = 1:npar,
    conf = 0.95, lty = 1, lwd = 1, type = "b", cilty = 1, vci =
    TRUE, xlab, xlim, ylabs, ylims, ask = nb.fig &lt; length(which) &amp;&amp;
    dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplot_+3A_data">data</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_tlim">tlim</code></td>
<td>
<p>A numeric vector of length two, giving the limits for
the thresholds at which the model is fitted.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_model">model</code></td>
<td>
<p>The model; either <code>"gpd"</code> (the default) or
<code>"pp"</code>, for the Generalized Pareto or Point Process
representations respectively.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_pscale">pscale</code></td>
<td>
<p>If <code>TRUE</code>, then the x-axis gives the threshold
exceedance probability rather than the threshold itself.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_cmax">cmax</code></td>
<td>
<p>Logical; if <code>FALSE</code> (the default), the models
are fitted using all exceedences over the thresholds. If
<code>TRUE</code>, the models are fitted using cluster maxima, using
clusters of exceedences derived from <code>clusters</code>.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_r">r</code>, <code id="tcplot_+3A_ulow">ulow</code>, <code id="tcplot_+3A_rlow">rlow</code></td>
<td>
<p>Arguments used for the identification of
clusters of exceedences (see <code><a href="#topic+clusters">clusters</a></code>).
Ignored if <code>cmax</code> is <code>FALSE</code> (the default).</p>
</td></tr>
<tr><td><code id="tcplot_+3A_nt">nt</code></td>
<td>
<p>The number of thresholds at which the model is fitted.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a
subset of the numbers <code>1:npar</code>, where <code>npar</code> is
the number of parameters, so that <code>npar = 2</code> when
<code>model = "gpd"</code> (the default) and <code>npar = 3</code>
when <code>model = "pp"</code>.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_conf">conf</code></td>
<td>
<p>The (pointwise) confidence coefficient for the
plotted confidence intervals. Use zero to suppress.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_lty">lty</code>, <code id="tcplot_+3A_lwd">lwd</code></td>
<td>
<p>The line type and width of the line connecting
the parameter estimates.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_type">type</code></td>
<td>
<p>The form taken by the line connecting the parameter
estimates and the points denoting these estimates. Possible
values include <code>"b"</code> (the default) for points joined by
lines, <code>"o"</code> for overplotted points and lines, and
<code>"l"</code> for an unbroken line with no points.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_cilty">cilty</code></td>
<td>
<p>The line type of the lines depicting the
confidence intervals.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_vci">vci</code></td>
<td>
<p>If <code>TRUE</code> (the default), confidence intervals
are plotted using vertical lines.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_xlab">xlab</code>, <code id="tcplot_+3A_xlim">xlim</code></td>
<td>
<p>Label and limits for the x-axis; if given,
these arguments apply to every plot.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_ylabs">ylabs</code>, <code id="tcplot_+3A_ylims">ylims</code></td>
<td>
<p>A vector of y-axis labels and a matrix of
y-axis limits. If given, <code>ylabs</code> should have the same
length as <code>which</code>, and <code>ylims</code> should have two
columns and <code>length(which)</code> rows. If the length of
<code>which</code> is one, then <code>ylims</code> can be a vector of
length two.</p>
</td></tr> 
<tr><td><code id="tcplot_+3A_ask">ask</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the user is asked before
each plot.</p>
</td></tr>
<tr><td><code id="tcplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the model fit
function <code>fpot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the <code>nt</code> thresholds a peaks over threshold model
is fitted using the function <code>fpot</code>. When <code>model = "gpd"</code>
(the default), the maximum likelihood estimates for the shape and the
modified scale parameter (modified by subtracting the shape multiplied
by the threshold) are plotted against the thresholds.
When <code>model = "pp"</code> the maximum likelihood estimates for the
location, scale and shape parameters are plotted against the
thresholds. (The modified scale parameter in the <code>"gpd"</code> case
is equivalent to the scale parameter in the <code>"pp"</code> case.)
If the threshold <code>u</code> is a valid threshold to be used for peaks
over threshold modelling, the parameter estimates depicted should
be approximately constant above <code>u</code>.
</p>


<h3>Value</h3>

<p>A list is invisibly returned. Each component is a matrix with
three columns giving parameter estimates and confidence limits.
</p>


<h3>Author(s)</h3>

<p>Stuart Coles and Alec Stephenson</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpot">fpot</a></code>, <code><a href="#topic+mrlplot">mrlplot</a></code>,
<code><a href="#topic+clusters">clusters</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tlim &lt;- c(3.6, 4.2)
## Not run: tcplot(portpirie, tlim)
## Not run: tcplot(portpirie, tlim, nt = 100, lwd = 3, type = "l")
## Not run: tcplot(portpirie, tlim, model = "pp")
</code></pre>

<hr>
<h2 id='uccle'>Rainfall Maxima at Uccle, Belgium</h2><span id='topic+uccle'></span>

<h3>Description</h3>

<p>The <code>uccle</code> data frame has 35 rows and 4 columns.
The columns contain annual rainfall maxima (in millimetres) from
1938 to 1972 at Uccle, Belgium, over the durations of one day,
one hour, ten minutes and one minute.
The row names give the years of observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uccle</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>day</dt><dd><p>Annual daily rainfall maxima.</p>
</dd>
<dt>hour</dt><dd><p>Annual hourly rainfall maxima.</p>
</dd>
<dt>tmin</dt><dd><p>Annual rainfall maxima over ten minute durations.</p>
</dd>
<dt>min</dt><dd><p>Annual rainfall maxima over one minute durations.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sneyers, R. (1977)
L'intensite maximale des precipitations en Belgique.
<em>Inst. Royal Meteor. Belgique, B</em> <b>86</b>.
</p>

<hr>
<h2 id='venice'>Largest Sea Levels in Venice</h2><span id='topic+venice'></span>

<h3>Description</h3>

<p>The <code>venice</code> data frame has 51 rows and 10 columns.
The jth column contains the jth largest sea levels in Venice,
for the years 1931&ndash;1981.
Only the largest six measurements are available for the year 1935;
the corresponding row contains four missing values.
The years for each set of measurements are given as row names.
A larger version of this data is available in the dataset 
<code>venice2</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venice</code></pre>


<h3>Format</h3>

<p>A data frame with 51 rows and 10 columns.</p>


<h3>Source</h3>

<p>Smith, R. L. (1986)
Extreme value theory based on the <code class="reqn">r</code> largest annual events.
<em>Journal of Hydrology</em>, <b>86</b>, 27&ndash;43.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modeling of Extreme Values</em>.
London: Springer-Verlag.
</p>

<hr>
<h2 id='venice2'>Largest Sea Levels in Venice</h2><span id='topic+venice2'></span>

<h3>Description</h3>

<p>The <code>venice2</code> data frame has 125 rows and 10 columns.
The data was kindly provided by Anthony Davison.
The jth column contains the jth largest sea levels in Venice,
for the years 1887&ndash;2011.
This is a larger version of the dataset <code>venice</code>.
Only the largest six measurements are available for the year 1935,
and only the largest is available for 1922; the corresponding rows 
contain missing values.
The years for each set of measurements are given as row names. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venice2</code></pre>


<h3>Format</h3>

<p>A data frame with 125 rows and 10 columns.</p>


<h3>Source</h3>

<p>Smith, R. L. (1986)
Extreme value theory based on the <code class="reqn">r</code> largest annual events.
<em>Journal of Hydrology</em>, <b>86</b>, 27&ndash;43.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modeling of Extreme Values</em>.
London: Springer-Verlag.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
