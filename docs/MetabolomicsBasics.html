<!DOCTYPE html><html lang="en-US"><head><title>Help for package MetabolomicsBasics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MetabolomicsBasics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdjustSymbols'><p>AdjustSymbols.</p></a></li>
<li><a href='#CheckForOutliers'><p>CheckForOutliers.</p></a></li>
<li><a href='#ClassificationCV'><p>ClassificationCV.</p></a></li>
<li><a href='#ClassificationHistogram'><p>ClassificationHistogram.</p></a></li>
<li><a href='#ClassificationWrapper'><p>ClassificationWrapper.</p></a></li>
<li><a href='#find_boundaries'><p>find_boundaries.</p></a></li>
<li><a href='#MBoxplot'><p>MBoxplot.</p></a></li>
<li><a href='#met'><p>Metabolite table</p></a></li>
<li><a href='#MetaboliteANOVA'><p>MetaboliteANOVA.</p></a></li>
<li><a href='#msconvert'><p>msconvert.</p></a></li>
<li><a href='#PlotMetabolitePCA'><p>PlotMetabolitePCA.</p></a></li>
<li><a href='#PlotPValueHist'><p>PlotPValueHist.</p></a></li>
<li><a href='#PolarCoordHeterPlot'><p>PolarCoordHeterPlot.</p></a></li>
<li><a href='#raw'><p>Metabolomics data set</p></a></li>
<li><a href='#RemoveFactorsByANOVA'><p>RemoveFactorsByANOVA.</p></a></li>
<li><a href='#ReplaceMissingValues'><p>ReplaceMissingValues.</p></a></li>
<li><a href='#RestrictedPCA'><p>RestrictedPCA.</p></a></li>
<li><a href='#sam'><p>Sample table</p></a></li>
<li><a href='#spectra_format_converter'><p>spectra_format_converter.</p></a></li>
<li><a href='#sumformula_from_CAS'><p>sumformula_from_CAS.</p></a></li>
<li><a href='#unique_labels'><p>unique_labels.</p></a></li>
<li><a href='#unique_subformula_masses'><p>unique_subformula_masses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Functions to Investigate Metabolomics Data Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Lisec &lt;jan.lisec@bam.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to investigate raw data from (metabol)omics experiments intended to be used on a raw data matrix, i.e. following peak picking and signal deconvolution. Functions can be used to normalize data, detect biomarkers and perform sample classification. A detailed description of best practice usage may be found in the publication &lt;<a href="https://doi.org/10.1007%2F978-1-4939-7819-9_20">doi:10.1007/978-1-4939-7819-9_20</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/janlisec/MetabolomicsBasics">https://github.com/janlisec/MetabolomicsBasics</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>C50, caret, e1071, InterpretMSSpectrum, pcaMethods, plyr,
rpart, rlang, webchem</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mixOmics, ropls, xcms</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 13:21:51 UTC; jlisec</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Lisec <a href="https://orcid.org/0000-0003-1220-2286"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdjustSymbols'>AdjustSymbols.</h2><span id='topic+AdjustSymbols'></span>

<h3>Description</h3>

<p><code>AdjustSymbols</code> will generate plotting character and color vectors based
on experimental factors.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdjustSymbols(cols = NULL, pchs = NULL, colorset = NULL, symbolset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AdjustSymbols_+3A_cols">cols</code></td>
<td>
<p>Factor (color output) or numeric (grey-scale output) vector or NULL (omitted).</p>
</td></tr>
<tr><td><code id="AdjustSymbols_+3A_pchs">pchs</code></td>
<td>
<p>Factor vector or NULL (omitted).</p>
</td></tr>
<tr><td><code id="AdjustSymbols_+3A_colorset">colorset</code></td>
<td>
<p>Color definitions for the factor levels of 'cols' (can be omitted to use default values).</p>
</td></tr>
<tr><td><code id="AdjustSymbols_+3A_symbolset">symbolset</code></td>
<td>
<p>Plotting character definitions for the factor levels of 'pchs' (can be omitted to use default values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a fixed color and symbol scheme indicating samples from different groups
throughout all figures of a analysis workflow is a reasonable decision. This function
allows to specify both and attach it to a sample table for further use.
</p>


<h3>Value</h3>

<p>Either a vector (if one parameter of 'cols' and 'pchs' remains NULL), a data frame
with columns 'cols' and 'pchs' (if both are provided and of equal length) or a list of
length 2 (if both are provided and of different length). Will be used by several plotting
functions of the package internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return color vector
x &lt;- gl(6, 3)
y &lt;- as.numeric(x)
plot(y, bg = AdjustSymbols(cols = x), pch = 21, cex = 2)
plot(y, bg = AdjustSymbols(cols = y), pch = 21, cex = 2)
plot(y, bg = AdjustSymbols(cols = x, colorset = 1:6), pch = 21, cex = 2)
plot(y, pch = AdjustSymbols(pchs = x), cex = 2)
plot(y, bg = 2, pch = AdjustSymbols(pchs = x, symbolset = 1:6), cex = 2)

# load data and plot using provided color scheme
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam
head(sam)
plot(y = raw[, 1], x = as.numeric(sam$GT), pch = sam$pchs, bg = sam$cols)

# change colors to greyscale
head(AdjustSymbols(cols = sam$GT, pchs = sam$Origin))
tmp.set &lt;- grDevices::rainbow(length(levels(sam$GT)))
head(AdjustSymbols(cols = sam$GT, pchs = sam$Batch, colorset = tmp.set))
plot(raw[, 1] ~ sam$GT, col = unique_labels(sam = sam, g = "GT")[, "cols"])
sam$cols &lt;- AdjustSymbols(cols = as.numeric(sam$GT))
plot(raw[, 1] ~ sam$GT, col = unique_labels(sam = sam, g = "GT")[, "cols"]) #'
</code></pre>

<hr>
<h2 id='CheckForOutliers'>CheckForOutliers.</h2><span id='topic+CheckForOutliers'></span>

<h3>Description</h3>

<p><code>CheckForOutliers</code> will evaluate a numeric vector and check
if outliers within groups based on group <code class="reqn">mean \pm n \times sd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckForOutliers(
  x = NULL,
  group = NULL,
  n_sd = 3,
  method = c("idx", "logical", "dist")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckForOutliers_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="CheckForOutliers_+3A_group">group</code></td>
<td>
<p>Factor vector of length(x).</p>
</td></tr>
<tr><td><code id="CheckForOutliers_+3A_n_sd">n_sd</code></td>
<td>
<p>Cutoff for outliers in E being mean(group)+-n_sd*sd(group) where
group values are calculated without the outlier candidate.</p>
</td></tr>
<tr><td><code id="CheckForOutliers_+3A_method">method</code></td>
<td>
<p>Different variants of the result value. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numeric will be split by groups and each value will be evaluated
with respect to its distance to the group mean (calculated out of the other
values in the group). Distance here means the number of standard deviations
the value is off the group mean. With different choices of <code>method</code>
the output can be switched from the calculated fold-distances to a boolean
of length(x) or and Index vector giving the outliers directly (see examples).
</p>


<h3>Value</h3>

<p>Depending on the selected method. See details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
x &lt;- runif(10)
x[1] &lt;- 2
group &lt;- gl(2, 5)
CheckForOutliers(x, group, method = "dist")
CheckForOutliers(x, group, method = "logical")
CheckForOutliers(x, group, method = "idx")
graphics::par(mfrow = c(1, 2))
bg &lt;- c(3, 2)[1 + CheckForOutliers(x, group, method = "logical")]
graphics::plot(x = as.numeric(group), y = x, pch = 21, cex = 3,
  bg = bg, main = "n_sd=3", las = 1, xlim = c(0.5, 2.5))
bg &lt;- c(3, 2)[1 + CheckForOutliers(x, group, n_sd = 4, method = "logical")]
graphics::plot(x = as.numeric(group), y = x, pch = 21, cex = 3,
  bg = bg, main = "n_sd=4", las = 1, xlim = c(0.5, 2.5))
graphics::par(mfrow = c(1, 1))

# load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam

# no missing data in this matrix
all(is.finite(raw))

# check for outliers (computing n-fold sd distance from group mean)
tmp &lt;- apply(raw, 2, CheckForOutliers, group = sam$GT, method = "dist")
# plot a histogram of the observed distances
graphics::hist(tmp, breaks = seq(0, ceiling(max(tmp))), main = "n*SD from mean", xlab = "n")

# Calculate the amount of values exceeding five-sigma and compare with a standard gaussian
table(tmp &gt; 5)
round(100 * sum(tmp &gt; 5) / length(tmp), 2)

gauss &lt;- CheckForOutliers(x = rnorm(prod(dim(raw))), method = "dist")
sapply(1:5, function(i) {
  data.frame("obs" = sum(tmp &gt; i), "gauss" = sum(gauss &gt; i))
})

# compare a PCA w/wo outliers
RestrictedPCA(
  dat = raw, sam = sam, use.sam = sam$GT %in% c("Mo17", "B73"), group.col = "GT",
  fmod = "GT+Batch+Order", P = 1, sign.col = "GT", legend.x = NULL, text.col = "Batch", medsd = TRUE
)
raw_filt &lt;- raw
raw_filt[tmp &gt; 3] &lt;- NA
RestrictedPCA(
  dat = raw_filt, sam = sam, use.sam = sam$GT %in% c("Mo17", "B73"), group.col = "GT",
  fmod = "GT+Batch+Order", P = 1, sign.col = "GT", legend.x = NULL, text.col = "Batch", medsd = TRUE
)

</code></pre>

<hr>
<h2 id='ClassificationCV'>ClassificationCV.</h2><span id='topic+ClassificationCV'></span>

<h3>Description</h3>

<p><code>ClassificationCV</code> will perform a classification using SVM's
and/or Decision Trees including cross validation on a data set according to
a provided grouping vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassificationCV(
  d = NULL,
  g = NULL,
  n = 1,
  k = 1,
  rand = F,
  method = c("svm", "C50", "rpart", "ropls"),
  method.control = list(),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClassificationCV_+3A_d">d</code></td>
<td>
<p>Data matrix or data.frame with named rows (samples) and columns (traits).</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_g">g</code></td>
<td>
<p>Group-vector, factor.</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_n">n</code></td>
<td>
<p>Replicates of classifications.</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_k">k</code></td>
<td>
<p>Number of folds per replicate.</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_rand">rand</code></td>
<td>
<p>Randomize Group-vector (and apply according n and k to this randomization).</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_method">method</code></td>
<td>
<p>Currently <code>svm</code>, <code>ropls</code> and decision tree methods <code>C50</code> and <code>rpart</code> are supported.</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_method.control">method.control</code></td>
<td>
<p>A list of parameters, forwarded to the respective classification function.</p>
</td></tr>
<tr><td><code id="ClassificationCV_+3A_silent">silent</code></td>
<td>
<p>Logical. Set TRUE to suppress progress bar and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to demonstrate the functionality of different
classification tools with respect to building classifiers for metabolomics data.
Check the examples in <code><a href="#topic+ClassificationWrapper">ClassificationWrapper</a></code> for automatic
multi-fold analysis.
</p>


<h3>Value</h3>

<p>A list of classification results which can be analyzed for accuracy,
miss-classified samples and more.
</p>

<hr>
<h2 id='ClassificationHistogram'>ClassificationHistogram.</h2><span id='topic+ClassificationHistogram'></span>

<h3>Description</h3>

<p><code>ClassificationHistogram</code> will plot the results of <a href="#topic+ClassificationWrapper">ClassificationWrapper</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassificationHistogram(out_classific = NULL, breaks = seq(0, 1, 0.05), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClassificationHistogram_+3A_out_classific">out_classific</code></td>
<td>
<p>Output of <a href="#topic+ClassificationWrapper">ClassificationWrapper</a>.</p>
</td></tr>
<tr><td><code id="ClassificationHistogram_+3A_breaks">breaks</code></td>
<td>
<p>Breaks for histogram.</p>
</td></tr>
<tr><td><code id="ClassificationHistogram_+3A_...">...</code></td>
<td>
<p>Passed on to <code>par</code>. Useful to adjust <code>cex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No further details.
</p>


<h3>Value</h3>

<p>Returns NULL invisibly.
</p>

<hr>
<h2 id='ClassificationWrapper'>ClassificationWrapper.</h2><span id='topic+ClassificationWrapper'></span>

<h3>Description</h3>

<p><code>ClassificationWrapper</code> will do classification using SVM's and/or
Decision Trees including cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassificationWrapper(
  d = NULL,
  g = NULL,
  n = 100,
  n_rand = 1,
  k = 5,
  method = c("C50", "svm", "rpart", "ropls"),
  train = NULL,
  method.control = list(),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClassificationWrapper_+3A_d">d</code></td>
<td>
<p>data, matrix or data.frame !! needs row/col-names.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_g">g</code></td>
<td>
<p>Group-vector, factor.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_n">n</code></td>
<td>
<p>replicates of classifications, i.e. number of different split into folds.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_n_rand">n_rand</code></td>
<td>
<p>different number of randomizations, see Details.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_k">k</code></td>
<td>
<p>Fold cross validation.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_method">method</code></td>
<td>
<p>Currently <code>svm</code>, <code>ropls</code> and decision tree methods (<code>C50</code> and <code>rpart</code>) are supported.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_train">train</code></td>
<td>
<p>Either NULL (random permutations) or an index vector for a training subset out of <code>g</code>.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_method.control">method.control</code></td>
<td>
<p>A list of parameters, forwarded to the selected methods function.</p>
</td></tr>
<tr><td><code id="ClassificationWrapper_+3A_silent">silent</code></td>
<td>
<p>Logical. Set TRUE to suppress progress bar and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter 'n_rand' will influence how permutation testing for robustness
is conducted. If n_rand=1 than samples will be permuted exactly one time and
subjected to n replications (with respect to fold splitting). If n_rand&gt;1, samples
will be permuted this many times but number of replications will be lowered to limit
processing time. A good compromise is to balance both, using less replications than
for observed data but on several randomizations.
</p>


<h3>Value</h3>

<p>#' Classification results as list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam
gr &lt;- sam$Origin
# establish a basic rpart model and render a fancy plot including the accuracy

class_res &lt;- ClassificationWrapper(d = raw, g = gr, method = c("rpart", "svm"), n = 3, k = 3)
ClassificationHistogram(class_res)

</code></pre>

<hr>
<h2 id='find_boundaries'>find_boundaries.</h2><span id='topic+find_boundaries'></span>

<h3>Description</h3>

<p><code>find_boundaries</code> will determine peak boundaries within a BPC or mass trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_boundaries(
  int = NULL,
  rt = NULL,
  p = which.max(int),
  k = 3,
  bl = min(int),
  local_min = int[p]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_boundaries_+3A_int">int</code></td>
<td>
<p>The measured intensity of the ion mass (obviously ordered according to consecutive RTs).</p>
</td></tr>
<tr><td><code id="find_boundaries_+3A_rt">rt</code></td>
<td>
<p>The respective retention times (can be omitted as currently not used).</p>
</td></tr>
<tr><td><code id="find_boundaries_+3A_p">p</code></td>
<td>
<p>The anticipated peak position (as index of int) if several peaks are within the mass trace.</p>
</td></tr>
<tr><td><code id="find_boundaries_+3A_k">k</code></td>
<td>
<p>The smoothing window parameter (provided to runmed).</p>
</td></tr>
<tr><td><code id="find_boundaries_+3A_bl">bl</code></td>
<td>
<p>The baseline value. Can be provided explicitly if automatic determination is insufficient.</p>
</td></tr>
<tr><td><code id="find_boundaries_+3A_local_min">local_min</code></td>
<td>
<p>This is practically the upper end of the baseline. It can be set to avoid boundary detection at local minima (e.g. for peaks suffering ion suppression).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is yet another peak finder or, more precisely, it is a function
to identify two RT values which flank a intensity maximum which is required
if one would like to integrate the peak area.
</p>


<h3>Value</h3>

<p>Numeric vector of length=2 specifying the start and end index of the peak.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int &lt;- sin(seq(-0.75 * pi, 1.75 * pi, by = 0.1))
plot(int)
abline(v = find_boundaries(int = int))
</code></pre>

<hr>
<h2 id='MBoxplot'>MBoxplot.</h2><span id='topic+MBoxplot'></span>

<h3>Description</h3>

<p><code>MBoxplot</code> will generate an annotated boxplot. A unifying
function for MS-data Boxplots based on \'raw\' and \'sam\'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBoxplot(
  pk = pk,
  raw = NULL,
  sam = NULL,
  met = NULL,
  g = NULL,
  flt = NULL,
  an = NULL,
  plot_sample_n = FALSE,
  txt = NULL,
  cex.txt = 0.5,
  plot_rel_axis = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MBoxplot_+3A_pk">pk</code></td>
<td>
<p>Colname of raw to plot if <code>pk</code> is character OR the colnum number if <code>pk</code> is numeric.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_raw">raw</code></td>
<td>
<p>Plotting data as samples (rows) x metabolites (cols).</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_sam">sam</code></td>
<td>
<p>Sample table.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_met">met</code></td>
<td>
<p>Containing at minimum columns for annotation (see parameter <code>an</code>) and <code>nrow(met)</code> should be <code>ncol(raw)</code>.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_g">g</code></td>
<td>
<p>Grouping vector if <code>Group</code> not contained in <code>sam</code>.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_flt">flt</code></td>
<td>
<p>Filter to exclude certain samples (T/F) vector.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_an">an</code></td>
<td>
<p>Switch to include annotation (from met) in the boxplot providing a character vector of colnames from <code>met</code>.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_plot_sample_n">plot_sample_n</code></td>
<td>
<p>Amend each box with the number of finite values which were a basis for plotting this group.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_txt">txt</code></td>
<td>
<p>Character vector with information per sample to be plotted on top of the box as text.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_cex.txt">cex.txt</code></td>
<td>
<p>Specify size of annotation text.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_plot_rel_axis">plot_rel_axis</code></td>
<td>
<p>Specify one level of <code>g</code> (or <code>sam$Group</code>) which to express the data relative against.</p>
</td></tr>
<tr><td><code id="MBoxplot_+3A_...">...</code></td>
<td>
<p>Further options parsed to <code>boxplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually metabolomics experiments are conducted on multiple replicates
of a sample group. Boxplots allow to quickly access potential differences
between measurement values of several groups. <code>MBoxplot</code> can be nicely
used to generate QC plots for all metabolites prior and after normalization,
in absolute or relative scale and sorted according to significance.
</p>


<h3>Value</h3>

<p>Nothing. Will produce a plot (or file if specified).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame("y" = runif(36), "GT" = gl(3, 12), "TP" = factor(rep(rep(1:3, each = 4), 3)))
x &lt;- cbind(x, AdjustSymbols(cols = x$GT, pchs = x$TP))
MBoxplot(
  pk = "y", raw = x, sam = x, met = data.frame("Peak" = "y", "Test" = I("info")),
  g = interaction(x$GT, x$TP), an = "Test", plot_n_samples = TRUE, txt = rownames(x)
)
</code></pre>

<hr>
<h2 id='met'>Metabolite table</h2><span id='topic+met'></span>

<h3>Description</h3>

<p>This data frame contains the metabolite definition of 112 metabolites according to the cols of <a href="#topic+raw">raw</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>met
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 112 rows and 2 columns.
</p>


<h3>Author(s)</h3>

<p>Jan Lisec <a href="mailto:jan.lisec@bam.de">jan.lisec@bam.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://onlinelibrary.wiley.com/doi/10.1111/j.1365-313X.2011.04689.x&gt;
</p>

<hr>
<h2 id='MetaboliteANOVA'>MetaboliteANOVA.</h2><span id='topic+MetaboliteANOVA'></span>

<h3>Description</h3>

<p><code>MetaboliteANOVA</code> will perform an ANOVA on columns
of a data matrix according to a specified model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaboliteANOVA(
  dat = NULL,
  sam = NULL,
  model = NULL,
  method = "none",
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MetaboliteANOVA_+3A_dat">dat</code></td>
<td>
<p>Data  matrix (e.g. of metabolite).</p>
</td></tr>
<tr><td><code id="MetaboliteANOVA_+3A_sam">sam</code></td>
<td>
<p>Sample table (same number of row as 'dat' and containing all columns specified in 'model'.</p>
</td></tr>
<tr><td><code id="MetaboliteANOVA_+3A_model">model</code></td>
<td>
<p>ANOVA model. May include +, * and : together with column names of sam (cf. Examples).</p>
</td></tr>
<tr><td><code id="MetaboliteANOVA_+3A_method">method</code></td>
<td>
<p>The method to be used in column wise multiple testing adjustment, see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="MetaboliteANOVA_+3A_silent">silent</code></td>
<td>
<p>Logical. Shall the function print warnings to the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for <code>lm</code> including some sanity checks.
It will accept a data matrix (traits in columns), sample information (data.frame)
and a potential model as input, compute an ANOVA per column and return
the respective P-values in a named matrix for further plotting or export.
</p>


<h3>Value</h3>

<p>A named matrix of P-values (rows=metabolites/traits; cols=ANOVA factors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam
# compute P-values according to specified ANOVA model (simple and complex)
head(m1 &lt;- MetaboliteANOVA(dat = raw, sam = sam, model = "GT"))
head(m2 &lt;- MetaboliteANOVA(dat = raw, sam = sam, model = "GT+Batch+Order+MP"))
# compare P-values for one factor determined in both models
hist(log10(m2[, "GT"]) - log10(m1[, "GT"]), main = "")
</code></pre>

<hr>
<h2 id='msconvert'>msconvert.</h2><span id='topic+msconvert'></span>

<h3>Description</h3>

<p><code>msconvert</code> is calling ProteoWizards MSConvert as a command line tool on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msconvert(
  files = NULL,
  msc_exe =
    "C:\\Program Files\\ProteoWizard\\ProteoWizard 3.0.11856\\msconvert.exe",
  args = c("--filter \"peakPicking cwt snr=0.01 peakSpace=0.1 msLevel=1\"",
    "--filter \"scanTime [0,3600]\"", "--filter \"metadataFixer\"", "--mzML", "--32",
    "--zlib")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msconvert_+3A_files">files</code></td>
<td>
<p>A character vector of MS data files (wiff, raw, d, ...).</p>
</td></tr>
<tr><td><code id="msconvert_+3A_msc_exe">msc_exe</code></td>
<td>
<p>The path to the installed 'msconvert.exe'.</p>
</td></tr>
<tr><td><code id="msconvert_+3A_args">args</code></td>
<td>
<p>The arguments passed to msconvert on the command line (see details for documentation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a quick and dodgy function to show how to convert vendor MS data
into an open format (mzML). You will have to download/install MSConvert prior
to usage, and probably adjust the arguments according to your needs. Arguments
are documented here <a href="https://proteowizard.sourceforge.io/tools/msconvert.html">https://proteowizard.sourceforge.io/tools/msconvert.html</a>.
If you don't know where the msconvert.exe is installed you can check for the correct
path using <code>list.files(path="C:/", pattern="^msconvert.exe$", recursive = TRUE)</code>.
</p>


<h3>Value</h3>

<p>Only some informative outputs printed to the console. The specified MS data
files will be converted to mzML within the same folder.
</p>

<hr>
<h2 id='PlotMetabolitePCA'>PlotMetabolitePCA.</h2><span id='topic+PlotMetabolitePCA'></span>

<h3>Description</h3>

<p><code>PlotMetabolitePCA</code> will show PC1 and PC2 of a pcaMethods
object and generate a flexible plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotMetabolitePCA(
  pca_res = NULL,
  sam = NULL,
  g = NULL,
  medsd = FALSE,
  text.col = "ID",
  legend.x = "bottomleft",
  comm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotMetabolitePCA_+3A_pca_res">pca_res</code></td>
<td>
<p>A pcaRes object from the pcaMethods package.</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_sam">sam</code></td>
<td>
<p>Sample table including columns 'cols', 'pchs' (for data point color and shape) and 'ID' (to label data points) 'Group' (to split cols for legend) 'MP' (to adjust point size).</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_g">g</code></td>
<td>
<p>Can be a factor vector of length=nrow(sam) and will influence legend and 'medsd'.</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_medsd">medsd</code></td>
<td>
<p>Calculate mean and sd for groups and overlay PCA plot with this information.</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_text.col">text.col</code></td>
<td>
<p>Data points may be overlaid by textual information, e.g. sample ID and 'text.col' specifies the column name of 'sam' to use for this purpose.</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_legend.x">legend.x</code></td>
<td>
<p>Position of a legend or NULL to omit it.</p>
</td></tr>
<tr><td><code id="PlotMetabolitePCA_+3A_comm">comm</code></td>
<td>
<p>Will print commentary text to the bottom right of the plot (can be a character vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>A vector fo similar length as input but with various name components removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam

# calculate pca Result using pcaMethods and plot
pca_res &lt;- pcaMethods::pca(raw, method = "rnipals", scale = c("none", "pareto", "uv")[2])
PlotMetabolitePCA(pca_res = pca_res, sam = sam, g = sam$GT)
# plot without legend and Group means instead
PlotMetabolitePCA(
  pca_res = pca_res, sam = sam, g = sam$GT, legend.x = NULL, text.col = NULL,
  medsd = TRUE, comm = LETTERS[1:4]
)

# readjust symbols before plotting
sam$Group &lt;- interaction(sam$Origin, sam$Class, sep = "_")
sam[, c("cols", "pchs")] &lt;- AdjustSymbols(cols = sam$Group, pchs = sam$Group)
PlotMetabolitePCA(pca_res = pca_res, sam = sam, g = sam$Group)
</code></pre>

<hr>
<h2 id='PlotPValueHist'>PlotPValueHist.</h2><span id='topic+PlotPValueHist'></span>

<h3>Description</h3>

<p><code>PlotPValueHist</code> will take a named matrix of P-values
(i.e. numeric between 0..1) and plot histograms for each column. In
the easiest case this matrix is generated by <a href="#topic+MetaboliteANOVA">MetaboliteANOVA</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPValueHist(
  out = NULL,
  method = "BH",
  xl = "ANOVA P-values",
  yl = "Number of metabolites",
  frac.col = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotPValueHist_+3A_out">out</code></td>
<td>
<p>matrix/data.frame; P-value table from 'MetaboliteANOVA.R' with factors in named columns and trait P-values in rows.</p>
</td></tr>
<tr><td><code id="PlotPValueHist_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method applied, piped to <code>p.adjust()</code>.</p>
</td></tr>
<tr><td><code id="PlotPValueHist_+3A_xl">xl</code></td>
<td>
<p>xlab.</p>
</td></tr>
<tr><td><code id="PlotPValueHist_+3A_yl">yl</code></td>
<td>
<p>ylab.</p>
</td></tr>
<tr><td><code id="PlotPValueHist_+3A_frac.col">frac.col</code></td>
<td>
<p>Render histogram bars in stacked colors according to provided color vector (should be a vector of valid color names of length=nrow(out)).</p>
</td></tr>
<tr><td><code id="PlotPValueHist_+3A_...">...</code></td>
<td>
<p>Passed on to <code>par</code>. Useful to adjust <code>cex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>NULL. Will generate a P-value histogram plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam

# compute P-values according to specified ANOVA model (simple and complex)
head(pvals &lt;- MetaboliteANOVA(dat = raw, sam = sam, model = "GT+Batch+Order"))
PlotPValueHist(out = pvals)

# adjust multiple testing correction method and y lable
PlotPValueHist(out = pvals, method = "none", yl = "Number of Genes")

# color bars (by chance or according to a metabolite group)
PlotPValueHist(out = pvals, frac.col = rep(2:3, length.out = nrow(pvals)))
met &lt;- MetabolomicsBasics::met
met$Name[grep("ine$", met$Name)]
PlotPValueHist(out = pvals, frac.col = 2 + 1:nrow(pvals) %in% grep("ine$", met$Name))
</code></pre>

<hr>
<h2 id='PolarCoordHeterPlot'>PolarCoordHeterPlot.</h2><span id='topic+PolarCoordHeterPlot'></span>

<h3>Description</h3>

<p><code>PolarCoordHeterPlot</code> will draw a plot in polar coordinates
visualizing heterosis effects according to a layout by Swanson-Wagner,
where plot radius represents log2 of fold change between lowest and highest
genotype and plot angle represents the ratio between lowest, intermediate
and highest genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolarCoordHeterPlot(
  x,
  gt = c("P1", "P1xP2", "P2"),
  rev_log = NULL,
  exp_fac = 1,
  thr = 1,
  plot_lab = c("none", "text", "graph"),
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PolarCoordHeterPlot_+3A_x">x</code></td>
<td>
<p>Data matrix with measurement values (traits in rows and genotypes in columns).</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_gt">gt</code></td>
<td>
<p>Character vector of length=3 indicating P1, F and P2. These are used to  filter by column name from x.</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_rev_log">rev_log</code></td>
<td>
<p>If you've log transformed your data, you might want to revert the log transformation.</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_exp_fac">exp_fac</code></td>
<td>
<p>Expansion factor to increase figure size.</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_thr">thr</code></td>
<td>
<p>Alpha level used in ANOVA to filter insignificant rows. Keep thr=1 to include all matrix rows.</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_plot_lab">plot_lab</code></td>
<td>
<p>Show 'text' or 'graph' style labels of the polar sections (or keep 'none' to omit).</p>
</td></tr>
<tr><td><code id="PolarCoordHeterPlot_+3A_col">col</code></td>
<td>
<p>Provide a color vector of length nrow(x).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>Will generate a plot in polar coordinates and return the x/y coordinates of the data points invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the provided experimental data
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam
x &lt;- t(raw)
colnames(x) &lt;- sam$GT
gt &lt;- c("B73","B73xMo17","Mo17")
PolarCoordHeterPlot(x=x, gt=gt, plot_lab="graph", thr=0.01, rev_log=exp(1))

coord &lt;- PolarCoordHeterPlot(x=x, gt=gt, thr=0.01, rev_log=exp(1))
points(x=coord$x[3], coord$y[3], pch=22, cex=4, col=2)
# using random data
gt &lt;- c("P1","P1xP2","P2")
set.seed(0)
x &lt;- matrix(rnorm(150), nrow = 10, dimnames = list(paste0("M",1:10), sample(rep(gt, 5))))
x[1:4,1:6]
PolarCoordHeterPlot(x=x, gt=gt)
# using text style labels for the sections
PolarCoordHeterPlot(x=x, gt=gt, plot_lab="text", exp_fac=0.75)
# reverting the order of parental genotypes
PolarCoordHeterPlot(x=x, gt=c("P2","P1xP2","P1"), plot_lab="text", exp_fac=0.75)
# using graph style labels for the sections
PolarCoordHeterPlot(x=x, gt=c("P2","P1xP2","P1"), plot_lab="graph")
# coloring data points
PolarCoordHeterPlot(x=x, gt=gt, col=1:10)
# applying ANOVA P value threshold to input rows
PolarCoordHeterPlot(x=x, gt=gt, col=1:10, thr=0.5)
PolarCoordHeterPlot(x=x, gt=gt, plot_lab="graph", col=1:10, thr=0.5)
</code></pre>

<hr>
<h2 id='raw'>Metabolomics data set</h2><span id='topic+raw'></span>

<h3>Description</h3>

<p>This data set contains a matrix of log10-transformed ion intensities from a maize root metabolomics study for in total 112 metabolites in 120 samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 120 rows and 112 columns.
</p>


<h3>Author(s)</h3>

<p>Jan Lisec <a href="mailto:jan.lisec@bam.de">jan.lisec@bam.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://onlinelibrary.wiley.com/doi/10.1111/j.1365-313X.2011.04689.x&gt;
</p>

<hr>
<h2 id='RemoveFactorsByANOVA'>RemoveFactorsByANOVA.</h2><span id='topic+RemoveFactorsByANOVA'></span>

<h3>Description</h3>

<p><code>RemoveFactorsByANOVA</code> will remove variance from data using an ANOVA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveFactorsByANOVA(
  y = NULL,
  sam = NULL,
  fmod = NULL,
  kmod = NULL,
  output = c("y_norm", "y_lm", "anova_y", "anova_y_norm", "boxplot")[1],
  remove_outliers = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RemoveFactorsByANOVA_+3A_y">y</code></td>
<td>
<p>Data vector (or data matrix) to normalize (numeric + in same order as sam).</p>
</td></tr>
<tr><td><code id="RemoveFactorsByANOVA_+3A_sam">sam</code></td>
<td>
<p>data.frame containing the factors or numerical vars for ANOVA model.</p>
</td></tr>
<tr><td><code id="RemoveFactorsByANOVA_+3A_fmod">fmod</code></td>
<td>
<p>Full model describing the experimental setting (provided as character string).</p>
</td></tr>
<tr><td><code id="RemoveFactorsByANOVA_+3A_kmod">kmod</code></td>
<td>
<p>Reduced model describing all the biological factors to keep (provided as character string).</p>
</td></tr>
<tr><td><code id="RemoveFactorsByANOVA_+3A_output">output</code></td>
<td>
<p>Should be <code>y_norm</code> in general but can be switched for testing.</p>
</td></tr>
<tr><td><code id="RemoveFactorsByANOVA_+3A_remove_outliers">remove_outliers</code></td>
<td>
<p>Should be a numeric integer x (with $x=0$ : no effect; $x&gt;=1$ remove all values which have error e with $e &gt; abs(mean + x * sd)$ ).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>Depends on <code>output</code>. Usually the normalized data vector (or matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up sample information
sam &lt;- data.frame(
  "GT" = gl(4, 10),
  "TR" = rep(gl(2, 5), 4),
  "Batch" = sample(gl(2, 20)),
  "Order" = sample(seq(-1, 1, length.out = 40))
)

# set up artificial measurement data
set.seed(1)
# specify main effects
m1 &lt;- c(5, 6, 2, 9)[sam$GT] + c(-2, 2)[sam$TR]
m2 &lt;- c(5, -6, 2, 4)[sam$GT] + c(-2, 2)[sam$TR]
# add run order bias and noise
m1 &lt;- m1 + c(-3, 3)[sam$Batch] + 3 * sam$Order + rnorm(nrow(sam), sd = 0.5)
m2 &lt;- m2 - 5 * sam$Order + rnorm(nrow(sam), sd = 0.8)
dat &lt;- data.frame(m1, m2)

# apply function to remove variance
# full model incorporating all relevant factors defined in sample table
fmod &lt;- "GT*TR+Batch+Order"
# reduced model: factors to be kept from full model; everything elso will be removed from the data
kmod &lt;- "GT*TR"
RemoveFactorsByANOVA(y = dat[, "m1"], sam = sam, fmod = fmod, kmod = kmod, output = "anova_y")
RemoveFactorsByANOVA(y = dat[, "m1"], sam = sam, fmod = fmod, kmod = kmod, output = "anova_y_norm")
</code></pre>

<hr>
<h2 id='ReplaceMissingValues'>ReplaceMissingValues.</h2><span id='topic+ReplaceMissingValues'></span>

<h3>Description</h3>

<p><code>ReplaceMissingValues</code> will replace missing values within
a numeric matrix based on a principal component analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplaceMissingValues(x, ncomp = 10, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplaceMissingValues_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="ReplaceMissingValues_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components to be used.</p>
</td></tr>
<tr><td><code id="ReplaceMissingValues_+3A_silent">silent</code></td>
<td>
<p>FALSE, suppress messages setting silent=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'nipals' algorithm is used to basically perform a PCA
on the sparse matrix. Missing values are imputed based on the major components
observed. Please check also the 'impute.nipals' function from mixOmics which
should basically give the same functionality since the 04/2021 update.
</p>


<h3>Value</h3>

<p>A matrix of similar dimensions as x without missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam

idx &lt;- apply(raw, 2, CheckForOutliers, group = sam$GT, n_sd = 5, method = "logical")
sum(idx) # 215 values would be classified as outlier using a five-sigma band
old_vals &lt;- raw[idx] # keep outlier values for comparison
raw_filt &lt;- raw
raw_filt[idx] &lt;- NA
raw_means &lt;- apply(raw, 2, function(x) {
  sapply(split(x, sam$GT), mean, na.rm = TRUE)[as.numeric(sam$GT)]
})[idx]
raw_repl &lt;- ReplaceMissingValues(x = raw_filt)
new_vals &lt;- raw_repl[idx]
par(mfrow = c(2, 1))
breaks &lt;- seq(-0.7, 1.3, 0.05)
hist(raw_means - old_vals, breaks = breaks, main = "", xlab = "Outliers", las = 1)
hist(raw_means - new_vals, breaks = breaks, main = "", xlab = "Replaced values", las = 1)
</code></pre>

<hr>
<h2 id='RestrictedPCA'>RestrictedPCA.</h2><span id='topic+RestrictedPCA'></span>

<h3>Description</h3>

<p><code>RestrictedPCA</code> combines an ANOVA based on 'fmod' and
restricts a PCA using the ANOVA result as a filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RestrictedPCA(
  dat = NULL,
  sam = NULL,
  use.sam = NULL,
  group.col = NULL,
  text.col = NULL,
  fmod = NULL,
  sign.col = NULL,
  p.adjust.method = "none",
  P = 0.01,
  pcaMethods.scale = "pareto",
  n.metab.min = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RestrictedPCA_+3A_dat">dat</code></td>
<td>
<p>Metabolite matrix (samples x metabolites).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_sam">sam</code></td>
<td>
<p>Sample definition dataframe.</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_use.sam">use.sam</code></td>
<td>
<p>Numeric index vector (or logical) to select specific samples to be included in the analysis or NULL to include all.</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_group.col">group.col</code></td>
<td>
<p>Column used for legend creation (column name from sam).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_text.col">text.col</code></td>
<td>
<p>Column used for text annotation of data points (column name from sam).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_fmod">fmod</code></td>
<td>
<p>ANOVA model to calculate before PCA.</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_sign.col">sign.col</code></td>
<td>
<p>Which column(s) of the ANOVA result shall be used for P-value filtering (specify column names or leave on NULL to filter on all).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Method use to adjust P-values (e.g. none, BH or bonferroni).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_p">P</code></td>
<td>
<p>P-value threshold used as a cutoff after P-value adjustment.</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_pcamethods.scale">pcaMethods.scale</code></td>
<td>
<p>pcaMethods scale parameter (usually pareto for metabolite data).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_n.metab.min">n.metab.min</code></td>
<td>
<p>Minimum number of metabolites kept for PCA calculation (even if they exceed P).</p>
</td></tr>
<tr><td><code id="RestrictedPCA_+3A_...">...</code></td>
<td>
<p>Handed through to <code><a href="#topic+PlotMetabolitePCA">PlotMetabolitePCA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;fmod' should be something like &rsquo;GT*TR+Batch' to perform
an ANOVA with these factors defined as columns in sam.
</p>


<h3>Value</h3>

<p>Will generate a PCA plot (generated by <a href="#topic+PlotMetabolitePCA">PlotMetabolitePCA</a> internally)
restricted based on an ANOVA result based on <a href="#topic+MetaboliteANOVA">MetaboliteANOVA</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load raw data and sample description
raw &lt;- MetabolomicsBasics::raw
sam &lt;- MetabolomicsBasics::sam
# standard behavior
RestrictedPCA(dat = raw, sam = sam, group.col = "GT")
## Not run: 
# apply multiple testing using a strict P-value cutoff,
# dont show a legend but plot group mean values and sd's as overlay
RestrictedPCA(
  dat = raw, sam = sam, group.col = "GT", p.adjust.method = "BH", P = 10^-10,
  fmod = "GT+Batch+Order", sign.col = "GT", medsd = T, legend.x = NULL
)
# limit to a subset of samples, switching the ANOVA selection of by setting P=1
# and adding text (from \code{sam}) to each data point
RestrictedPCA(
  dat = raw, sam = sam, use.sam = which(sam$GT %in% c("Mo17", "B73")), group.col = "GT",
  fmod = "GT+Batch+Order", P = 1, sign.col = "GT", legend.x = NULL, text.col = "Batch"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sam'>Sample table</h2><span id='topic+sam'></span>

<h3>Description</h3>

<p>This data frame contains the sample definition of 120 samples according to the rows of <a href="#topic+raw">raw</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 120 rows and 10 columns.
</p>


<h3>Author(s)</h3>

<p>Jan Lisec <a href="mailto:jan.lisec@bam.de">jan.lisec@bam.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://onlinelibrary.wiley.com/doi/10.1111/j.1365-313X.2011.04689.x&gt;
</p>

<hr>
<h2 id='spectra_format_converter'>spectra_format_converter.</h2><span id='topic+spectra_format_converter'></span>

<h3>Description</h3>

<p><code>spectra_format_converter</code> will generate a matrix with mz and int
columns out of a text representation of a spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectra_format_converter(txt = NULL, m_prec = 3, i_prec = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectra_format_converter_+3A_txt">txt</code></td>
<td>
<p>Sample table.</p>
</td></tr>
<tr><td><code id="spectra_format_converter_+3A_m_prec">m_prec</code></td>
<td>
<p>Mass precision of output spectrum.</p>
</td></tr>
<tr><td><code id="spectra_format_converter_+3A_i_prec">i_prec</code></td>
<td>
<p>Intensity precision of output spectrum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>Matrix with mz and int columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spectra_format_converter(txt = "57.1:100 58.0001:10")
spectra_format_converter(txt = "58.0001:10 57.1:100", m_prec = 4)
</code></pre>

<hr>
<h2 id='sumformula_from_CAS'>sumformula_from_CAS.</h2><span id='topic+sumformula_from_CAS'></span>

<h3>Description</h3>

<p><code>sumformula_from_CAS</code> will try to get a chemical sum formula from a CAS ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumformula_from_CAS(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumformula_from_CAS_+3A_x">x</code></td>
<td>
<p>Vector of CAS IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tbd.
</p>


<h3>Value</h3>

<p>A character vector of length input vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- readLines("C:/Users/jlisec/Documents/Francesco Russo/RECTOX/RECTOX_GC-EI-MS_CASRN")
sf &lt;- sumformula_from_CAS(x = x)

## End(Not run)
</code></pre>

<hr>
<h2 id='unique_labels'>unique_labels.</h2><span id='topic+unique_labels'></span>

<h3>Description</h3>

<p><code>unique_labels</code> will generate a dataframe with color and
plotting character specification out of a sample table definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_labels(sam = NULL, g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique_labels_+3A_sam">sam</code></td>
<td>
<p>Sample table.</p>
</td></tr>
<tr><td><code id="unique_labels_+3A_g">g</code></td>
<td>
<p>Either column name from sam containing factor column or factor of same length as sam.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a color/symbol specification exists for a sample set containing
replicate groups this function will help in retrieving this information
per group which is useful in boxplot or legend functions (cf. examples).
</p>


<h3>Value</h3>

<p>Dataframe with group levels names and their color and plotting character specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sam &lt;- MetabolomicsBasics::sam
unique_labels(sam = sam, g = "GT")
</code></pre>

<hr>
<h2 id='unique_subformula_masses'>unique_subformula_masses</h2><span id='topic+unique_subformula_masses'></span>

<h3>Description</h3>

<p><code>unique_subformula_masses</code> will generate a numeric vector of
potential sub formula masses regarding a chemical formula as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_subformula_masses(fml, names = TRUE, check_validity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique_subformula_masses_+3A_fml">fml</code></td>
<td>
<p>Chemical formula.</p>
</td></tr>
<tr><td><code id="unique_subformula_masses_+3A_names">names</code></td>
<td>
<p>Return respective sub formulas as vector names.</p>
</td></tr>
<tr><td><code id="unique_subformula_masses_+3A_check_validity">check_validity</code></td>
<td>
<p>Filter for chemically valid formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In mass spectrometry precursor masses are often fragmented and these
fragments are recorded as MS^2 spectra. A frequent task is then to compute
potential chemical formulas for the obtained MS^2 masses. The function
<code>unique_subformula_masses</code> follows the reverse approach. It allows to
calculate all masses that could be potential breakdown products of a precursor
formula
</p>


<h3>Value</h3>

<p>A named numeric vector. The names are the sub formulas for the calculated
exact masses given as numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify a formula and calculate all potential combinatorial masses
fml &lt;- c("C6H12O6", "C11H16NO4PS", "C24H51O4P")[1]
tmp &lt;- unique_subformula_masses(fml = fml)
length(tmp); any(duplicated(tmp))
hist(tmp, breaks=seq(floor(min(tmp))-1, ceiling(max(tmp))), main=fml)
# do the same as above but check for chemical plausibility
tmp2 &lt;- unique_subformula_masses(fml = fml, check_validity=TRUE)
length(tmp2)
hist(tmp2, breaks=seq(floor(min(tmp2))-1, ceiling(max(tmp2))), main=fml)
mz &lt;- 147
tmp[abs(tmp-mz)&lt;0.5]
tmp2[abs(tmp2-mz)&lt;0.5]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
