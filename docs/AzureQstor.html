<!DOCTYPE html><html><head><title>Help for package AzureQstor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AzureQstor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#queue_endpoint'><p>Create a queue endpoint object</p></a></li>
<li><a href='#QueueMessage'><p>R6 class representing a message from an Azure storage queue</p></a></li>
<li><a href='#storage_queue'><p>Message queues</p></a></li>
<li><a href='#StorageQueue'><p>R6 class representing an Azure storage queue</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interface to 'Azure Queue Storage'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface to 'Azure Queue Storage'. This is a cloud service for storing large numbers of messages, for example from automated sensors, that can be accessed remotely via authenticated calls using HTTP or HTTPS. Queue storage is often used to create a backlog of work to process asynchronously. Part of the 'AzureR' family of packages.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Azure/AzureQstor">https://github.com/Azure/AzureQstor</a>
<a href="https://github.com/Azure/AzureR">https://github.com/Azure/AzureR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Azure/AzureQstor/issues">https://github.com/Azure/AzureQstor/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, AzureRMR (&ge; 2.0.0), AzureStor (&ge; 3.0.0), openssl,
httr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-15 15:30:56 UTC; hongo</td>
</tr>
<tr>
<td>Author:</td>
<td>Hong Ooi [aut, cre],
  Microsoft [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hong Ooi &lt;hongooi73@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-15 23:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='queue_endpoint'>Create a queue endpoint object</h2><span id='topic+queue_endpoint'></span>

<h3>Description</h3>

<p>Create a queue endpoint object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queue_endpoint(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue_endpoint_+3A_endpoint">endpoint</code></td>
<td>
<p>The URL (hostname) for the endpoint, of the form <code style="white-space: pre;">&#8288;http[s]://{account-name}.queue.{core-host-name}&#8288;</code>. On the public Azure cloud, endpoints will be of the form <code style="white-space: pre;">&#8288;https://{account-name}.queue.core.windows.net&#8288;</code>.</p>
</td></tr>
<tr><td><code id="queue_endpoint_+3A_key">key</code></td>
<td>
<p>The access key for the storage account.</p>
</td></tr>
<tr><td><code id="queue_endpoint_+3A_token">token</code></td>
<td>
<p>An Azure Active Directory (AAD) authentication token. This can be either a string, or an object of class AzureToken created by <a href="AzureRMR.html#topic+reexports">AzureRMR::get_azure_token</a>. The latter is the recommended way of doing it, as it allows for automatic refreshing of expired tokens.</p>
</td></tr>
<tr><td><code id="queue_endpoint_+3A_sas">sas</code></td>
<td>
<p>A shared access signature (SAS) for the account.</p>
</td></tr>
<tr><td><code id="queue_endpoint_+3A_api_version">api_version</code></td>
<td>
<p>The storage API version to use when interacting with the host. Defaults to <code>"2019-07-07"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the queue storage counterpart to the endpoint functions defined in the AzureStor package.
</p>


<h3>Value</h3>

<p>An object of class <code>queue_endpoint</code>, inheriting from <code>storage_endpoint</code>.
</p>


<h3>See Also</h3>

<p><code><a href="AzureStor.html#topic+storage_endpoint">AzureStor::storage_endpoint</a></code>, <code><a href="AzureStor.html#topic+storage_endpoint">AzureStor::blob_endpoint</a></code>, <code><a href="#topic+storage_queue">storage_queue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# obtaining an endpoint from the storage account resource object
AzureRMR::get_azure_login()$
    get_subscription("sub_id")$
    get_resource_group("rgname")$
    get_storage_account("mystorage")$
    get_queue_endpoint()

# creating an endpoint standalone
queue_endpoint("https://mystorage.queue.core.windows.net/", key="access_key")


## End(Not run)
</code></pre>

<hr>
<h2 id='QueueMessage'>R6 class representing a message from an Azure storage queue</h2><span id='topic+QueueMessage'></span><span id='topic+message'></span>

<h3>Description</h3>

<p>This class stores the data, metadata and behaviour associated with a message.
</p>
<p>To generate a message object, call one of the methods exposed by the <code><a href="#topic+StorageQueue">StorageQueue</a></code> class.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>queue</code></dt><dd><p>The queue this message is from, an object of class <code><a href="#topic+StorageQueue">StorageQueue</a></code></p>
</dd>
<dt><code>id</code></dt><dd><p>The message ID.</p>
</dd>
<dt><code>insertion_time</code></dt><dd><p>The message insertion (creation) time.</p>
</dd>
<dt><code>expiry_time</code></dt><dd><p>The message expiration time.</p>
</dd>
<dt><code>text</code></dt><dd><p>The message text.</p>
</dd>
<dt><code>receipt</code></dt><dd><p>A pop receipt. This is present if the message was obtained by means other than <a href="#topic+StorageQueue">peeking</a>, and is required for updating or deleting the message.</p>
</dd>
<dt><code>next_visible_time</code></dt><dd><p>The time when this message will be next visible.</p>
</dd>
<dt><code>dequeue_count</code></dt><dd><p>The number of times this message has been read.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>QueueMessage$new()</code></a>
</p>
</li>
<li> <p><a href="#method-delete"><code>QueueMessage$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-update"><code>QueueMessage$update()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>QueueMessage$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>QueueMessage$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new message object. Rather than calling the <code>new</code> method manually, objects of this class should be created via the methods exposed by the <code><a href="#topic+StorageQueue">StorageQueue</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$new(message, queue)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>message</code></dt><dd><p>Details about the message.</p>
</dd>
<dt><code>queue</code></dt><dd><p>Object of class <code>StorageQueue</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Deletes this message from the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$delete()</pre></div>



<h5>Returns</h5>

<p>NULL, invisibly.
</p>


<hr>
<a id="method-update"></a>



<h4>Method <code>update()</code></h4>

<p>Updates this message in the queue.
</p>
<p>This operation can be used to continually extend the invisibility of a queue message. This functionality can be useful if you want a worker role to &quot;lease&quot; a message. For example, if a worker role calls <code><a href="#topic+StorageQueue">get_messages</a></code> and recognizes that it needs more time to process a message, it can continually extend the message's invisibility until it is processed. If the worker role were to fail during processing, eventually the message would become visible again and another worker role could process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$update(visibility_timeout, text = self$text)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>visibility_timeout</code></dt><dd><p>The new visibility timeout (time to when the message will again be visible).</p>
</dd>
<dt><code>text</code></dt><dd><p>Optionally, new message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for this class.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not currently used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QueueMessage$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- storage_endpoint("https://mystorage.queue.core.windows.net", key="key")
queue &lt;- storage_queue(endp, "queue1")

msg &lt;- queue$get_message()
msg$update(visibility_timeout=60, text="updated message")
msg$delete()


## End(Not run)
</code></pre>

<hr>
<h2 id='storage_queue'>Message queues</h2><span id='topic+storage_queue'></span><span id='topic+storage_queue.character'></span><span id='topic+storage_queue.queue_endpoint'></span><span id='topic+list_storage_queues'></span><span id='topic+list_storage_queues.character'></span><span id='topic+list_storage_queues.queue_endpoint'></span><span id='topic+list_storage_containers.queue_endpoint'></span><span id='topic+create_storage_queue'></span><span id='topic+create_storage_queue.character'></span><span id='topic+create_storage_queue.queue_endpoint'></span><span id='topic+create_storage_queue.StorageQueue'></span><span id='topic+delete_storage_queue'></span><span id='topic+delete_storage_queue.character'></span><span id='topic+delete_storage_queue.queue_endpoint'></span><span id='topic+delete_storage_queue.StorageQueue'></span>

<h3>Description</h3>

<p>Get, list, create, or delete queues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storage_queue(endpoint, ...)

## S3 method for class 'character'
storage_queue(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version"),
  ...
)

## S3 method for class 'queue_endpoint'
storage_queue(endpoint, name, ...)

list_storage_queues(endpoint, ...)

## S3 method for class 'character'
list_storage_queues(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version"),
  ...
)

## S3 method for class 'queue_endpoint'
list_storage_queues(endpoint, ...)

## S3 method for class 'queue_endpoint'
list_storage_containers(endpoint, ...)

create_storage_queue(endpoint, ...)

## S3 method for class 'character'
create_storage_queue(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version"),
  ...
)

## S3 method for class 'queue_endpoint'
create_storage_queue(endpoint, name, ...)

## S3 method for class 'StorageQueue'
create_storage_queue(endpoint, ...)

delete_storage_queue(endpoint, ...)

## S3 method for class 'character'
delete_storage_queue(
  endpoint,
  key = NULL,
  token = NULL,
  sas = NULL,
  api_version = getOption("azure_storage_api_version"),
  ...
)

## S3 method for class 'queue_endpoint'
delete_storage_queue(endpoint, name, ...)

## S3 method for class 'StorageQueue'
delete_storage_queue(endpoint, confirm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storage_queue_+3A_endpoint">endpoint</code></td>
<td>
<p>Either a queue endpoint object as created by <a href="AzureStor.html#topic+storage_endpoint">storage_endpoint</a>, or a character string giving the URL of the endpoint.</p>
</td></tr>
<tr><td><code id="storage_queue_+3A_...">...</code></td>
<td>
<p>Further arguments passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="storage_queue_+3A_key">key</code>, <code id="storage_queue_+3A_token">token</code>, <code id="storage_queue_+3A_sas">sas</code></td>
<td>
<p>If an endpoint object is not supplied, authentication credentials: either an access key, an Azure Active Directory (AAD) token, or a SAS, in that order of priority.</p>
</td></tr>
<tr><td><code id="storage_queue_+3A_api_version">api_version</code></td>
<td>
<p>If an endpoint object is not supplied, the storage API version to use when interacting with the host. Currently defaults to <code>"2019-07-07"</code>.</p>
</td></tr>
<tr><td><code id="storage_queue_+3A_name">name</code></td>
<td>
<p>The name of the queue to get, create, or delete.</p>
</td></tr>
<tr><td><code id="storage_queue_+3A_confirm">confirm</code></td>
<td>
<p>For deleting a queue, whether to ask for confirmation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can call these functions in a couple of ways: by passing the full URL of the storage queue, or by passing the endpoint object and the name of the share as a string.
</p>


<h3>Value</h3>

<p>For <code>storage_queue</code> and <code>create_storage_queue</code>, an object of class <code><a href="#topic+StorageQueue">StorageQueue</a></code>. For <code>list_storage_queues</code>, a list of such objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StorageQueue">StorageQueue</a></code>, <code><a href="#topic+queue_endpoint">queue_endpoint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- storage_endpoint("https://mystorage.queue.core.windows.net", key="key")

# to talk to an existing queue
queue &lt;- storage_queue(endp, "queue1")

# to create a new queue
queue2 &lt;- create_storage_queue(endp, "queue2")

# various ways to delete a queue (will ask for confirmation first)
queue2$delete()
delete_storage_queue(queue2)
delete_storage_queue(endp, "queue2")

## End(Not run)
</code></pre>

<hr>
<h2 id='StorageQueue'>R6 class representing an Azure storage queue</h2><span id='topic+StorageQueue'></span><span id='topic+queue'></span>

<h3>Description</h3>

<p>A storage queue holds messages. A queue can contain an unlimited number of messages, each of which can be up to 64KB in size. Messages are generally added to the end of the queue and retrieved from the front of the queue, although first in, first out (FIFO) behavior is not guaranteed.
</p>
<p>To generate a queue object, use one of the <code><a href="#topic+storage_queue">storage_queue</a></code>, <code><a href="#topic+list_storage_queues">list_storage_queues</a></code> or <code><a href="#topic+create_storage_queue">create_storage_queue</a></code> functions rather than calling the <code>new()</code> method directly.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>endpoint</code></dt><dd><p>A queue endpoint object. This contains the account and authentication information for the queue.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the queue.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>StorageQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-create"><code>StorageQueue$create()</code></a>
</p>
</li>
<li> <p><a href="#method-delete"><code>StorageQueue$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-clear"><code>StorageQueue$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-get_metadata"><code>StorageQueue$get_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-set_metadata"><code>StorageQueue$set_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-get_message"><code>StorageQueue$get_message()</code></a>
</p>
</li>
<li> <p><a href="#method-get_messages"><code>StorageQueue$get_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-peek_message"><code>StorageQueue$peek_message()</code></a>
</p>
</li>
<li> <p><a href="#method-peek_messages"><code>StorageQueue$peek_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-pop_message"><code>StorageQueue$pop_message()</code></a>
</p>
</li>
<li> <p><a href="#method-pop_messages"><code>StorageQueue$pop_messages()</code></a>
</p>
</li>
<li> <p><a href="#method-put_message"><code>StorageQueue$put_message()</code></a>
</p>
</li>
<li> <p><a href="#method-update_message"><code>StorageQueue$update_message()</code></a>
</p>
</li>
<li> <p><a href="#method-delete_message"><code>StorageQueue$delete_message()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>StorageQueue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>StorageQueue$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the queue object. Rather than calling this directly, you should use one of the <code><a href="#topic+storage_queue">storage_queue</a></code>, <code><a href="#topic+list_storage_queues">list_storage_queues</a></code> or <code><a href="#topic+create_storage_queue">create_storage_queue</a></code> functions.
</p>
<p>Note that initializing this object is a local operation only. If a queue of the given name does not already exist in the storage account, it has to be created remotely by calling the <code>create</code> method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$new(endpoint, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>endpoint</code></dt><dd><p>An endpoint object.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the queue.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-create"></a>



<h4>Method <code>create()</code></h4>

<p>Creates a storage queue in Azure, using the storage endpoint and name from this R6 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$create()</pre></div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>Deletes this storage queue in Azure.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$delete(confirm = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>confirm</code></dt><dd><p>Whether to ask for confirmation before deleting.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Clears (deletes) all messages in this storage queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$clear()</pre></div>



<h5>Returns</h5>

<p>The queue object, invisibly.
</p>


<hr>
<a id="method-get_metadata"></a>



<h4>Method <code>get_metadata()</code></h4>

<p>Retrieves user-defined metadata for the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_metadata()</pre></div>



<h5>Returns</h5>

<p>A named list of metadata properties.
</p>


<hr>
<a id="method-set_metadata"></a>



<h4>Method <code>set_metadata()</code></h4>

<p>Sets user-defined metadata for the queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$set_metadata(..., keep_existing = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Name-value pairs to set as metadata.</p>
</dd>
<dt><code>keep_existing</code></dt><dd><p>Whether to retain existing metadata information.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A named list of metadata properties, invisibly.
</p>


<hr>
<a id="method-get_message"></a>



<h4>Method <code>get_message()</code></h4>

<p>Reads a message from the front of the storage queue.
</p>
<p>When a message is read, the consumer is expected to process the message and then delete it. After the message is read, it is made invisible to other consumers for a specified interval. If the message has not yet been deleted at the time the interval expires, its visibility is restored, so that another consumer may process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-get_messages"></a>



<h4>Method <code>get_messages()</code></h4>

<p>Reads several messages at once from the front of the storage queue.
</p>
<p>When a message is read, the consumer is expected to process the message and then delete it. After the message is read, it is made invisible to other consumers for a specified interval. If the message has not yet been deleted at the time the interval expires, its visibility is restored, so that another consumer may process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$get_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of objects of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-peek_message"></a>



<h4>Method <code>peek_message()</code></h4>

<p>Reads a message from the storage queue, but does not alter its visibility.
</p>
<p>Note that a message obtained via the <code>peek_message</code> or <code>peek_messages</code> method will not include a pop receipt, which is required to delete or update it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$peek_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-peek_messages"></a>



<h4>Method <code>peek_messages()</code></h4>

<p>Reads several messages at once from the storage queue, without altering their visibility.
</p>
<p>Note that a message obtained via the <code>peek_message</code> or <code>peek_messages</code> method will not include a pop receipt, which is required to delete or update it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$peek_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of objects of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-pop_message"></a>



<h4>Method <code>pop_message()</code></h4>

<p>Reads a message from the storage queue, removing it at the same time. This is equivalent to calling <a href="#method-get_message"><code>get_message</code></a> and <a href="#method-delete_message"><code>delete_message</code></a> successively.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$pop_message()</pre></div>



<h5>Returns</h5>

<p>A new object of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-pop_messages"></a>



<h4>Method <code>pop_messages()</code></h4>

<p>Reads several messages at once from the storage queue, and then removes them.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$pop_messages(n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>How many messages to read. The maximum is 32.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of objects of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.
</p>


<hr>
<a id="method-put_message"></a>



<h4>Method <code>put_message()</code></h4>

<p>Writes a message to the back of the message queue.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$put_message(text, visibility_timeout = NULL, time_to_live = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>text</code></dt><dd><p>The message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
<dt><code>visibility_timeout</code></dt><dd><p>Optional visibility timeout after being read, in seconds. The default is 30 seconds.</p>
</dd>
<dt><code>time_to_live</code></dt><dd><p>Optional message time-to-live, in seconds. The default is 7 days.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The message text, invisibly.
</p>


<hr>
<a id="method-update_message"></a>



<h4>Method <code>update_message()</code></h4>

<p>Updates a message in the queue. This requires that the message object must include a pop receipt, which is present if it was obtained by means other than <a href="#method-peek_message">peeking</a>.
</p>
<p>This operation can be used to continually extend the invisibility of a queue message. This functionality can be useful if you want a worker role to &quot;lease&quot; a message. For example, if a worker role calls <a href="#method-get_messages"><code>get_messages</code></a> and recognizes that it needs more time to process a message, it can continually extend the message's invisibility until it is processed. If the worker role were to fail during processing, eventually the message would become visible again and another worker role could process it.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$update_message(msg, visibility_timeout, text = msg$text)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg</code></dt><dd><p>A message object, of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.</p>
</dd>
<dt><code>visibility_timeout</code></dt><dd><p>The new visibility timeout (time to when the message will again be visible).</p>
</dd>
<dt><code>text</code></dt><dd><p>Optionally, new message text, either a raw or character vector. If a raw vector, it is base64-encoded, and if a character vector, it is collapsed into a single string before being sent to the queue.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The message object, invisibly.
</p>


<hr>
<a id="method-delete_message"></a>



<h4>Method <code>delete_message()</code></h4>

<p>Deletes a message from the queue. This requires that the message object must include a pop receipt, which is present if it was obtained by means other than <a href="#method-peek_message">peeking</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$delete_message(msg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg</code></dt><dd><p>A message object, of class <code><a href="#topic+QueueMessage">QueueMessage</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method for this class.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not currently used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StorageQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+QueueMessage">QueueMessage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

endp &lt;- storage_endpoint("https://mystorage.queue.core.windows.net", key="key")

# to talk to an existing queue
queue &lt;- storage_queue(endp, "queue1")

# to create a new queue
queue2 &lt;- create_storage_queue(endp, "queue2")

# various ways to delete a queue (will ask for confirmation first)
queue2$delete()
delete_storage_queue(queue2)
delete_storage_queue(endp, "queue2")

# to get all queues in this storage account
queue_lst &lt;- list_storage_queues(endp)

# working with a queue: put, get, update and delete messages
queue$put_message("new message")
msg &lt;- queue$get_message()
msg$update(visibility_timeout=60, text="updated message")
queue$delete_message(msg)

# delete_message simply calls the message's delete() method, so this is equivalent
msg$delete()

# retrieving multiple messages at a time (up to 32)
msgs &lt;- queue$get_messages(30)

# deleting is still per-message
lapply(msgs, function(m) m$delete())

# you can use the process pool from AzureRMR to do this in parallel
AzureRMR::init_pool()
AzureRMR::pool_lapply(msgs, function(m) m$delete())
AzureRMR::delete_pool()


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
