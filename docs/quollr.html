<!DOCTYPE html><html><head><title>Help for package quollr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quollr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_data'><p>Assign data to hexagons</p></a></li>
<li><a href='#avg_highd_data'><p>Create a dataframe with averaged high-dimensional data</p></a></li>
<li><a href='#cal_2d_dist'><p>Calculate 2D Euclidean distances between vertices</p></a></li>
<li><a href='#calc_bins'><p>Calculate the effective number of bins along x-axis and y-axis</p></a></li>
<li><a href='#calc_y_max'><p>Compute maximum value of y for scaling</p></a></li>
<li><a href='#compute_aic'><p>Compute the Akaike Information Criterion (AIC) for a given model.</p></a></li>
<li><a href='#compute_mean_density_hex'><p>Compute mean density of hexagonal bins</p></a></li>
<li><a href='#compute_std_counts'><p>Compute standardize counts in hexagons</p></a></li>
<li><a href='#extract_hexbin_centroids'><p>Extract hexagonal bin centroids coordinates and the corresponding standardize counts.</p></a></li>
<li><a href='#find_lg_benchmark'><p>Compute a benchmark value to remove long edges</p></a></li>
<li><a href='#find_low_dens_hex'><p>Find low-density Hexagons</p></a></li>
<li><a href='#find_non_empty_bins'><p>Find the number of bins required to achieve required number of non-empty bins.</p></a></li>
<li><a href='#find_pts'><p>Find points in hexagonal bins</p></a></li>
<li><a href='#fit_highd_model'><p>Construct the 2D model and lift into high-D</p></a></li>
<li><a href='#gen_centroids'><p>Generate centroid coordinate</p></a></li>
<li><a href='#gen_edges'><p>Generate edge information</p></a></li>
<li><a href='#gen_hex_coord'><p>Generate hexagonal polygon coordinates</p></a></li>
<li><a href='#gen_scaled_data'><p>Scaling the data</p></a></li>
<li><a href='#gen_summary'><p>Generate evaluation metrics</p></a></li>
<li><a href='#geom_trimesh'><p>Create a trimesh plot</p></a></li>
<li><a href='#GeomTrimesh'><p>GeomTrimesh: A Custom ggplot2 Geom for Triangular Meshes</p></a></li>
<li><a href='#hex_binning'><p>Hexagonal binning</p></a></li>
<li><a href='#predict_emb'><p>Predict 2D embeddings</p></a></li>
<li><a href='#s_curve_noise'><p>S-curve dataset with noise dimensions</p></a></li>
<li><a href='#s_curve_noise_test'><p>S-curve dataset with noise dimensions for test</p></a></li>
<li><a href='#s_curve_noise_training'><p>S-curve dataset with noise dimensions for training</p></a></li>
<li><a href='#s_curve_noise_umap'><p>UMAP embedding for S-curve dataset which with noise dimensions</p></a></li>
<li><a href='#s_curve_noise_umap_predict'><p>Predicted UMAP embedding for S-curve dataset which with noise dimensions</p></a></li>
<li><a href='#s_curve_noise_umap_scaled'><p>Scaled UMAP embedding for S-curve dataset which with noise dimensions</p></a></li>
<li><a href='#show_langevitour'><p>Visualize the model overlaid on high-dimensional data</p></a></li>
<li><a href='#stat_trimesh'><p>stat_trimesh Custom Stat for trimesh plot</p></a></li>
<li><a href='#tri_bin_centroids'><p>Triangulate bin centroids</p></a></li>
<li><a href='#vis_lg_mesh'><p>Visualize triangular mesh with coloured long edges</p></a></li>
<li><a href='#vis_rmlg_mesh'><p>Visualize triangular mesh after removing the long edges</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualising How Nonlinear Dimension Reduction Warps Your Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>To construct a model in 2D
    space from 2D embedding data and then lift it to the high-dimensional
    space. Additionally, it provides tools to visualize the model in 2D
    space and to overlay the fitted model on data using the tour
    technique. Furthermore, it facilitates the generation of summaries of
    high-dimensional distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JayaniLakshika/quollr">https://github.com/JayaniLakshika/quollr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JayaniLakshika/quollr/issues">https://github.com/JayaniLakshika/quollr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, grid, interp (&ge; 1.1-6), langevitour, proxy,
rlang, rsample, stats, tibble, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), vdiffr, umap</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 00:11:03 UTC; jpiy0001</td>
</tr>
<tr>
<td>Author:</td>
<td>Jayani P.G. Lakshika
    <a href="https://orcid.org/0000-0002-6265-6481"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Dianne Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Paul Harrison <a href="https://orcid.org/0000-0002-3980-268X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michael Lydeamore <a href="https://orcid.org/0000-0001-6515-827X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Thiyanga S. Talagala
    <a href="https://orcid.org/0000-0002-0656-9789"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jayani P.G. Lakshika &lt;jayanilakshika76@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_data'>Assign data to hexagons</h2><span id='topic+assign_data'></span>

<h3>Description</h3>

<p>This function assigns the data to hexagons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_data(data, centroid_df, col_start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_data_+3A_data">data</code></td>
<td>
<p>data A tibble or data frame.</p>
</td></tr>
<tr><td><code id="assign_data_+3A_centroid_df">centroid_df</code></td>
<td>
<p>The dataset with centroid coordinates only.</p>
</td></tr>
<tr><td><code id="assign_data_+3A_col_start">col_start</code></td>
<td>
<p>The text that begins the column name of x and y axes of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains x and y coordinates and corresponding hexagon ID
(emb_1, emb_2, and hb_id respectively).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
centroid_list &lt;- gen_centroids(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA)
all_centroids_df &lt;- as.data.frame(do.call(cbind, centroid_list))
s_curve_noise_umap_scaled_rm_id &lt;- s_curve_noise_umap_scaled |&gt; dplyr::select(-ID)
assign_data(data = s_curve_noise_umap_scaled_rm_id,
centroid_df = all_centroids_df, col_start = "UMAP")

</code></pre>

<hr>
<h2 id='avg_highd_data'>Create a dataframe with averaged high-dimensional data</h2><span id='topic+avg_highd_data'></span>

<h3>Description</h3>

<p>This function calculates the average values of high-dimensional data within each hexagonal bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_highd_data(data, col_start = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_highd_data_+3A_data">data</code></td>
<td>
<p>A data frame containing the high-dimensional data and 2D embeddings
with hexagonal bin IDs.</p>
</td></tr>
<tr><td><code id="avg_highd_data_+3A_col_start">col_start</code></td>
<td>
<p>The text that begin the column name of the high-dimensional data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the average values of the high-dimensional data within each hexagonal bin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
umap_data_with_hb_id &lt;- as.data.frame(do.call(cbind, hb_obj$data_hb_id))
df_all &lt;- dplyr::bind_cols(s_curve_noise_training |&gt; dplyr::select(-ID), umap_data_with_hb_id)
avg_highd_data(data = df_all, col_start = "x")

</code></pre>

<hr>
<h2 id='cal_2d_dist'>Calculate 2D Euclidean distances between vertices</h2><span id='topic+cal_2d_dist'></span>

<h3>Description</h3>

<p>This function calculates the 2D distances between pairs of points in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_2d_dist(tr_coord_df, start_x, start_y, end_x, end_y, select_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_2d_dist_+3A_tr_coord_df">tr_coord_df</code></td>
<td>
<p>A data frame containing columns for the
x and y coordinates of start and end points.</p>
</td></tr>
<tr><td><code id="cal_2d_dist_+3A_start_x">start_x</code></td>
<td>
<p>Column name for the x-coordinate of the starting point.</p>
</td></tr>
<tr><td><code id="cal_2d_dist_+3A_start_y">start_y</code></td>
<td>
<p>Column name for the y-coordinate of the starting point.</p>
</td></tr>
<tr><td><code id="cal_2d_dist_+3A_end_x">end_x</code></td>
<td>
<p>Column name for the x-coordinate of the ending point.</p>
</td></tr>
<tr><td><code id="cal_2d_dist_+3A_end_y">end_y</code></td>
<td>
<p>Column name for the y-coordinate of the ending point.</p>
</td></tr>
<tr><td><code id="cal_2d_dist_+3A_select_vars">select_vars</code></td>
<td>
<p>A character vector specifying the columns to be
selected in the resulting data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for the starting point, ending point,
and calculated distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
tr_from_to_df &lt;- gen_edges(tri_object = tr1_object)
cal_2d_dist(tr_coord_df = tr_from_to_df, start_x = "x_from", start_y = "y_from",
end_x = "x_to", end_y = "y_to", select_vars = c("from", "to", "distance"))

</code></pre>

<hr>
<h2 id='calc_bins'>Calculate the effective number of bins along x-axis and y-axis</h2><span id='topic+calc_bins'></span>

<h3>Description</h3>

<p>This function calculates the effective number of bins along the x and y axes
of a hexagonal grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_bins(data, x, y, hex_size = NA, buffer_x = NA, buffer_y = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_bins_+3A_data">data</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="calc_bins_+3A_x">x</code></td>
<td>
<p>The name of the column that contains values along the x-axis.</p>
</td></tr>
<tr><td><code id="calc_bins_+3A_y">y</code></td>
<td>
<p>The name of the column that contains values along the y-axis.</p>
</td></tr>
<tr><td><code id="calc_bins_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer
circle surrounded by the hexagon.</p>
</td></tr>
<tr><td><code id="calc_bins_+3A_buffer_x">buffer_x</code></td>
<td>
<p>The buffer size along the x-axis.</p>
</td></tr>
<tr><td><code id="calc_bins_+3A_buffer_y">buffer_y</code></td>
<td>
<p>The buffer size along the y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numeric values that represents the effective number of
bins along the x and y axes of a hexagonal grid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1", y = "UMAP2",
hex_size = NA, buffer_x = NA, buffer_y = NA)

</code></pre>

<hr>
<h2 id='calc_y_max'>Compute maximum value of y for scaling</h2><span id='topic+calc_y_max'></span>

<h3>Description</h3>

<p>This function compute the maximum y value need to use for scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_y_max(aspect_ratio, hex_ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_y_max_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Numeric value representing the aspect ratio of the plot area.</p>
</td></tr>
<tr><td><code id="calc_y_max_+3A_hex_ratio">hex_ratio</code></td>
<td>
<p>Numeric value representing the ratio of the hexagon size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value which should be used as maximum value of y when scaling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calc_y_max(aspect_ratio = 2.019414, hex_ratio = 0.2309401)

</code></pre>

<hr>
<h2 id='compute_aic'>Compute the Akaike Information Criterion (AIC) for a given model.</h2><span id='topic+compute_aic'></span>

<h3>Description</h3>

<p>Compute the Akaike Information Criterion (AIC) for a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_aic(p, mse, num_bins, num_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_aic_+3A_p">p</code></td>
<td>
<p>Number of dimensions of the data set.</p>
</td></tr>
<tr><td><code id="compute_aic_+3A_mse">mse</code></td>
<td>
<p>Mean squared error (MSE) of the model.</p>
</td></tr>
<tr><td><code id="compute_aic_+3A_num_bins">num_bins</code></td>
<td>
<p>Total number of bins without empty bins used in the model.</p>
</td></tr>
<tr><td><code id="compute_aic_+3A_num_obs">num_obs</code></td>
<td>
<p>Total number of observations in the training or test set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AIC value for the specified model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of compute_aic function
p &lt;- 5
mse &lt;- 1500
num_bins &lt;- 10
num_obs &lt;- 100
aic_value &lt;- compute_aic(p, mse, num_bins, num_obs)
cat("AIC Value:", aic_value, "\n")

</code></pre>

<hr>
<h2 id='compute_mean_density_hex'>Compute mean density of hexagonal bins</h2><span id='topic+compute_mean_density_hex'></span>

<h3>Description</h3>

<p>This function calculates the mean density of hexagonal bins based on their neighboring bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mean_density_hex(df_bin_centroids, num_bins_x = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mean_density_hex_+3A_df_bin_centroids">df_bin_centroids</code></td>
<td>
<p>A data frame containing information about hexagonal bin centroids,
including the hexagon ID and the standard normalized counts (<code>std_counts</code>).</p>
</td></tr>
<tr><td><code id="compute_mean_density_hex_+3A_num_bins_x">num_bins_x</code></td>
<td>
<p>The number of bins along the x-axis for the hexagonal grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains hexagonal IDs and the mean
density of each hexagonal bin based on its neighboring bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df,
counts_df = counts_df)
compute_mean_density_hex(df_bin_centroids, num_bins_x = num_bins_x)

</code></pre>

<hr>
<h2 id='compute_std_counts'>Compute standardize counts in hexagons</h2><span id='topic+compute_std_counts'></span>

<h3>Description</h3>

<p>This function computes the standardize number of points within each hexagon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_std_counts(data_hex_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_std_counts_+3A_data_hex_id">data_hex_id</code></td>
<td>
<p>A data frame with x and y coordinates and hexagonal bin IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains hexagon IDs and the corresponding standardize counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
centroid_list &lt;- gen_centroids(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA)
all_centroids_df &lt;- as.data.frame(do.call(cbind, centroid_list))
s_curve_noise_umap_scaled_rm_id &lt;- s_curve_noise_umap_scaled |&gt; dplyr::select(-ID)
nldr_with_hb_id_list &lt;- assign_data(data = s_curve_noise_umap_scaled_rm_id,
centroid_df = all_centroids_df, col_start = "UMAP")
umap_with_hb_id &lt;- as.data.frame(do.call(cbind, nldr_with_hb_id_list))
compute_std_counts(data_hex_id = umap_with_hb_id)

</code></pre>

<hr>
<h2 id='extract_hexbin_centroids'>Extract hexagonal bin centroids coordinates and the corresponding standardize counts.</h2><span id='topic+extract_hexbin_centroids'></span>

<h3>Description</h3>

<p>Extract hexagonal bin centroids coordinates and the corresponding standardize counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_hexbin_centroids(centroids_df, counts_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_hexbin_centroids_+3A_centroids_df">centroids_df</code></td>
<td>
<p>A data frame contains all hexagonal bin centroid
coordinates with hexagon IDs.</p>
</td></tr>
<tr><td><code id="extract_hexbin_centroids_+3A_counts_df">counts_df</code></td>
<td>
<p>A data frame contains hexagon IDs with the standardize
number of points within each hexagon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame contains hexagon ID, centroid coordinates, and standardize counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)

</code></pre>

<hr>
<h2 id='find_lg_benchmark'>Compute a benchmark value to remove long edges</h2><span id='topic+find_lg_benchmark'></span>

<h3>Description</h3>

<p>This function finds the benchmark value to remove long edges based on
the differences in a distance column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_lg_benchmark(distance_edges, distance_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lg_benchmark_+3A_distance_edges">distance_edges</code></td>
<td>
<p>The data frame containing the distances.</p>
</td></tr>
<tr><td><code id="find_lg_benchmark_+3A_distance_col">distance_col</code></td>
<td>
<p>The name of the column containing the distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The benchmark value, which is the first largest difference in the distance column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
tr_from_to_df &lt;- gen_edges(tri_object = tr1_object)
distance_df &lt;- cal_2d_dist(tr_coord_df = tr_from_to_df, start_x = "x_from",
start_y = "y_from", end_x = "x_to", end_y = "y_to",
select_vars = c("from", "to", "distance"))
find_lg_benchmark(distance_edges = distance_df, distance_col = "distance")

</code></pre>

<hr>
<h2 id='find_low_dens_hex'>Find low-density Hexagons</h2><span id='topic+find_low_dens_hex'></span>

<h3>Description</h3>

<p>This function identifies hexagons with low density based on the mean density
of their neighboring hexagons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_low_dens_hex(df_bin_centroids_all, num_bins_x, df_bin_centroids_low)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_low_dens_hex_+3A_df_bin_centroids_all">df_bin_centroids_all</code></td>
<td>
<p>The data frame containing all hexagonal bin centroids.</p>
</td></tr>
<tr><td><code id="find_low_dens_hex_+3A_num_bins_x">num_bins_x</code></td>
<td>
<p>Number of bins along the x-axis for hexagon binning.</p>
</td></tr>
<tr><td><code id="find_low_dens_hex_+3A_df_bin_centroids_low">df_bin_centroids_low</code></td>
<td>
<p>The data frame containing identified low-density hexagonal bin centroids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the IDs of hexagons to be removed after investigating their neighboring bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df,
counts_df = counts_df)
df_bin_centroids_low &lt;- df_bin_centroids |&gt;
dplyr::filter(std_counts &lt;= 0.43)
find_low_dens_hex(df_bin_centroids_all = df_bin_centroids, num_bins_x = num_bins_x,
df_bin_centroids_low = df_bin_centroids_low)

</code></pre>

<hr>
<h2 id='find_non_empty_bins'>Find the number of bins required to achieve required number of non-empty bins.</h2><span id='topic+find_non_empty_bins'></span>

<h3>Description</h3>

<p>This function determines the number of bins along the x and y axes
to obtain a specific number of non-empty bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_non_empty_bins(
  data,
  x = x,
  y = y,
  non_empty_bins,
  x_start = NA,
  y_start = NA,
  buffer_x = NA,
  buffer_y = NA,
  hex_size = NA,
  col_start
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_non_empty_bins_+3A_data">data</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_x">x</code></td>
<td>
<p>The name of the column that contains values along the x-axis.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_y">y</code></td>
<td>
<p>The name of the column that contains values along the y-axis.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_non_empty_bins">non_empty_bins</code></td>
<td>
<p>The desired number of non-empty bins.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_x_start">x_start</code></td>
<td>
<p>Starting point along the x-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_y_start">y_start</code></td>
<td>
<p>Starting point along the y-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_buffer_x">buffer_x</code></td>
<td>
<p>The buffer size along the x-axis.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_buffer_y">buffer_y</code></td>
<td>
<p>The buffer size along the y-axis.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer
circle surrounding the hexagon.</p>
</td></tr>
<tr><td><code id="find_non_empty_bins_+3A_col_start">col_start</code></td>
<td>
<p>The text that begins the column name of x and y axes of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of bins along the x and y axes
needed to achieve a specific number of non-empty bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_non_empty_bins(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", non_empty_bins = 10, x_start = NA,
y_start = NA, buffer_x = NA, buffer_y = NA, hex_size = NA, col_start = "UMAP")

</code></pre>

<hr>
<h2 id='find_pts'>Find points in hexagonal bins</h2><span id='topic+find_pts'></span>

<h3>Description</h3>

<p>This function maps points to their corresponding hexagonal bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_pts(data_hex_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_pts_+3A_data_hex_id">data_hex_id</code></td>
<td>
<p>A data frame with data, ID and hexagonal bin IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with hexagonal bin IDs and the corresponding points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
centroid_list &lt;- gen_centroids(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA)
all_centroids_df &lt;- as.data.frame(do.call(cbind, centroid_list))
s_curve_noise_umap_scaled_rm_id &lt;- s_curve_noise_umap_scaled |&gt; dplyr::select(-ID)
nldr_with_hb_id_list &lt;- assign_data(data = s_curve_noise_umap_scaled_rm_id,
centroid_df = all_centroids_df, col_start = "UMAP")
umap_with_hb_id &lt;- as.data.frame(do.call(cbind, nldr_with_hb_id_list))
umap_with_hb_id &lt;- umap_with_hb_id |&gt; dplyr::mutate(ID = s_curve_noise_umap_scaled$ID)
find_pts(data_hex_id = umap_with_hb_id)

</code></pre>

<hr>
<h2 id='fit_highd_model'>Construct the 2D model and lift into high-D</h2><span id='topic+fit_highd_model'></span>

<h3>Description</h3>

<p>This function fits a high-dimensional model using hexagonal bins and provides options
to customize the modeling process, including the choice of bin centroids or bin means,
removal of low-density hexagons, and averaging of high-dimensional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_highd_model(
  training_data,
  nldr_df_with_id,
  x,
  y,
  num_bins_x = NA,
  num_bins_y = NA,
  x_start = NA,
  y_start = NA,
  buffer_x = NA,
  buffer_y = NA,
  hex_size = NA,
  is_rm_lwd_hex = FALSE,
  benchmark_to_rm_lwd_hex = NA,
  col_start_2d,
  col_start_highd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_highd_model_+3A_training_data">training_data</code></td>
<td>
<p>A data frame containing the training high-dimensional data.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_nldr_df_with_id">nldr_df_with_id</code></td>
<td>
<p>A data frame containing 2D embeddings with a unique identifier.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_x">x</code></td>
<td>
<p>The name of the column that contains first 2D embeddings component.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_y">y</code></td>
<td>
<p>The name of the column that contains second 2D embeddings component.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_num_bins_x">num_bins_x</code></td>
<td>
<p>Number of bins along the x-axis.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_num_bins_y">num_bins_y</code></td>
<td>
<p>Number of bins along the y-axis.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_x_start">x_start</code></td>
<td>
<p>Starting point along the x-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_y_start">y_start</code></td>
<td>
<p>Starting point along the y-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_buffer_x">buffer_x</code></td>
<td>
<p>The buffer size along the x-axis.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_buffer_y">buffer_y</code></td>
<td>
<p>The buffer size along the y-axis.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer circle
surrounding the hexagon.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_is_rm_lwd_hex">is_rm_lwd_hex</code></td>
<td>
<p>Logical, indicating whether to remove low-density hexagons
(default is FALSE).</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_benchmark_to_rm_lwd_hex">benchmark_to_rm_lwd_hex</code></td>
<td>
<p>The benchmark value to remove low-density hexagons.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_col_start_2d">col_start_2d</code></td>
<td>
<p>The text prefix for columns in the 2D embedding data.</p>
</td></tr>
<tr><td><code id="fit_highd_model_+3A_col_start_highd">col_start_highd</code></td>
<td>
<p>The text prefix for columns in the high-dimensional data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the data frame with high-dimensional coordinates
for 2D bin centroids (<code>df_bin</code>) and the data frame containing
information about hexagonal bin centroids (<code>df_bin_centroids</code>) in 2D.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_highd_model(training_data = s_curve_noise_training, x = "UMAP1", y = "UMAP2",
nldr_df_with_id = s_curve_noise_umap_scaled, col_start_2d = "UMAP", col_start_highd = "x")

</code></pre>

<hr>
<h2 id='gen_centroids'>Generate centroid coordinate</h2><span id='topic+gen_centroids'></span>

<h3>Description</h3>

<p>This function generates all possible centroids in the hexagonal grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_centroids(
  data,
  x,
  y,
  num_bins_x,
  num_bins_y,
  x_start = NA,
  y_start = NA,
  buffer_x = NA,
  buffer_y = NA,
  hex_size = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_centroids_+3A_data">data</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_x">x</code></td>
<td>
<p>The name of the column that contains values along the x-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_y">y</code></td>
<td>
<p>The name of the column that contains values along the y-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_num_bins_x">num_bins_x</code></td>
<td>
<p>Number of bins along the x-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_num_bins_y">num_bins_y</code></td>
<td>
<p>Number of bins along the y-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_x_start">x_start</code></td>
<td>
<p>Starting point along the x-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_y_start">y_start</code></td>
<td>
<p>Starting point along the y-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_buffer_x">buffer_x</code></td>
<td>
<p>The buffer size along the x-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_buffer_y">buffer_y</code></td>
<td>
<p>The buffer size along the y-axis.</p>
</td></tr>
<tr><td><code id="gen_centroids_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer
circle surrounding the hexagon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains hexIDs, x and y coordinates (hexID, c_x, c_y respectively)
of all hexagon bin centroids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
gen_centroids(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA)

</code></pre>

<hr>
<h2 id='gen_edges'>Generate edge information</h2><span id='topic+gen_edges'></span>

<h3>Description</h3>

<p>This function generates edge information from a given triangular object,
including the coordinates of the vertices and the from-to relationships
between the vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_edges(tri_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_edges_+3A_tri_object">tri_object</code></td>
<td>
<p>The triangular object from which to generate edge information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the edge information, including the from-to
relationships and the corresponding x and y coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
gen_edges(tri_object = tr1_object)

</code></pre>

<hr>
<h2 id='gen_hex_coord'>Generate hexagonal polygon coordinates</h2><span id='topic+gen_hex_coord'></span>

<h3>Description</h3>

<p>This function generates the coordinates of hexagons after passing hexagonal centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_hex_coord(centroids_df, hex_size = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_hex_coord_+3A_centroids_df">centroids_df</code></td>
<td>
<p>The dataset with all hexbin ID and centroid coordinates.</p>
</td></tr>
<tr><td><code id="gen_hex_coord_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer
circle surrounding the hexagon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains polygon id, x and y coordinates (hex_poly_id, x,
and y respectively) of hexagons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
centroid_list &lt;- gen_centroids(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA)
all_centroids_df &lt;- as.data.frame(do.call(cbind, centroid_list))
gen_hex_coord(centroids_df = all_centroids_df, hex_size = NA)

</code></pre>

<hr>
<h2 id='gen_scaled_data'>Scaling the data</h2><span id='topic+gen_scaled_data'></span>

<h3>Description</h3>

<p>This function scales the x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_scaled_data(data, x, y, hex_ratio = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_scaled_data_+3A_data">data</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="gen_scaled_data_+3A_x">x</code></td>
<td>
<p>The name of the column that contains values along the x-axis.</p>
</td></tr>
<tr><td><code id="gen_scaled_data_+3A_y">y</code></td>
<td>
<p>The name of the column that contains values along the y-axis.</p>
</td></tr>
<tr><td><code id="gen_scaled_data_+3A_hex_ratio">hex_ratio</code></td>
<td>
<p>Numeric value representing the ratio of the hexagon size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains scaled x and y coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_scaled_data(data = s_curve_noise_umap, x = "UMAP1", y = "UMAP2")

</code></pre>

<hr>
<h2 id='gen_summary'>Generate evaluation metrics</h2><span id='topic+gen_summary'></span>

<h3>Description</h3>

<p>This function generates an evaluation data frame based on the provided data and predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_summary(test_data, prediction_df, df_bin, col_start = "x")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_summary_+3A_test_data">test_data</code></td>
<td>
<p>The data set containing high-dimensional data along with an unique identifier.</p>
</td></tr>
<tr><td><code id="gen_summary_+3A_prediction_df">prediction_df</code></td>
<td>
<p>The data set with 2D embeddings, IDs, and predicted hexagonal IDs.</p>
</td></tr>
<tr><td><code id="gen_summary_+3A_df_bin">df_bin</code></td>
<td>
<p>The data set with averaged/weighted high-dimensional data.</p>
</td></tr>
<tr><td><code id="gen_summary_+3A_col_start">col_start</code></td>
<td>
<p>The text that begin the column name of the high-dimensional data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains MSE and AIC values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- fit_highd_model(training_data = s_curve_noise_training, x = "UMAP1", y = "UMAP2",
nldr_df_with_id = s_curve_noise_umap_scaled, col_start_2d = "UMAP", col_start_highd = "x")
df_bin_centroids &lt;- model$df_bin_centroids
df_bin &lt;- model$df_bin
pred_emb_list &lt;- predict_emb(test_data = s_curve_noise_training,
df_bin_centroids = df_bin_centroids, df_bin = df_bin, type_NLDR = "UMAP")
pred_df_test &lt;- as.data.frame(do.call(cbind, pred_emb_list))
gen_summary(test_data = s_curve_noise_training, prediction_df = pred_df_test,
df_bin = df_bin, col_start = "x")

</code></pre>

<hr>
<h2 id='geom_trimesh'>Create a trimesh plot</h2><span id='topic+geom_trimesh'></span>

<h3>Description</h3>

<p>Create a trimesh plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_trimesh(
  mapping = NULL,
  data = NULL,
  stat = "trimesh",
  position = "identity",
  show.legend = NA,
  na.rm = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_trimesh_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings for the plot.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_data">data</code></td>
<td>
<p>The data to be plotted.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to be applied.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_position">position</code></td>
<td>
<p>The position adjustment to be applied.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_show.legend">show.legend</code></td>
<td>
<p>Whether to show the legend for this layer.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to remove missing values.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Whether to inherit aesthetics from the plot or the layer.</p>
</td></tr>
<tr><td><code id="geom_trimesh_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the 'layer' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot2' layer object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
ggplot2::ggplot() +
geom_trimesh(data = df_bin_centroids, mapping = ggplot2::aes(x = c_x, y = c_y))

</code></pre>

<hr>
<h2 id='GeomTrimesh'>GeomTrimesh: A Custom ggplot2 Geom for Triangular Meshes</h2><span id='topic+GeomTrimesh'></span>

<h3>Description</h3>

<p>This function defines a custom ggplot2 Geom, GeomTrimesh, for rendering triangular meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomTrimesh
</code></pre>


<h3>Format</h3>

<p>A ggproto object
</p>


<h3>Details</h3>

<p>- <code>required_aes</code>: The required aesthetics for this geometry are <code>"x"</code>, <code>"y"</code>, <code>"xend"</code>, and <code>"yend"</code>.
- <code>default_aes</code>: The default aesthetics for this geometry include <code>shape = 19</code>, <code>linetype = 1</code>, <code>linewidth = 0.5</code>,
<code>size = 0.5</code>, <code>alpha = NA</code>, and <code>colour = "black"</code>.
- <code>draw_key</code>: The function describing how to draw the key glyph is <code>ggplot2::draw_key_point</code>.
- <code>draw_panel</code>: The function describing how to draw the panel takes <code>data</code>, <code>panel_scales</code>, and <code>coord</code>.
It creates a tibble of <code>vertices</code> and a tibble of <code>trimesh</code>. The final plot is constructed using <code>ggplot2::GeomPoint$draw_panel</code>
for vertices and <code>ggplot2::GeomSegment$draw_panel</code> for trimesh.
</p>

<hr>
<h2 id='hex_binning'>Hexagonal binning</h2><span id='topic+hex_binning'></span>

<h3>Description</h3>

<p>This function generates a list which contains hexagonal binning information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex_binning(
  data,
  x,
  y,
  num_bins_x,
  num_bins_y,
  x_start = NA,
  y_start = NA,
  buffer_x = NA,
  buffer_y = NA,
  hex_size = NA,
  col_start
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hex_binning_+3A_data">data</code></td>
<td>
<p>A tibble or data frame.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_x">x</code></td>
<td>
<p>The name of the column that contains values along the x-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_y">y</code></td>
<td>
<p>The name of the column that contains values along the y-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_num_bins_x">num_bins_x</code></td>
<td>
<p>Number of bins along the x-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_num_bins_y">num_bins_y</code></td>
<td>
<p>Number of bins along the y-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_x_start">x_start</code></td>
<td>
<p>Starting point along the x-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_y_start">y_start</code></td>
<td>
<p>Starting point along the y-axis for hexagonal binning.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_buffer_x">buffer_x</code></td>
<td>
<p>The buffer size along the x-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_buffer_y">buffer_y</code></td>
<td>
<p>The buffer size along the y-axis.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_hex_size">hex_size</code></td>
<td>
<p>A numeric value that initializes the radius of the outer
circle surrounding the hexagon.</p>
</td></tr>
<tr><td><code id="hex_binning_+3A_col_start">col_start</code></td>
<td>
<p>The text that begins the column name of x and y axes of data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains all hexagonal bin centroids (centroids),
hexagonal coordinates of the full grid(hex_poly),
2D embeddings with corresponding hexagon IDs (data_hb_id),
hex bins with their corresponding standardise counts (std_cts),
total number of hex bins(tot_bins), number of non-empty hex bins (non_bins)
and points within each hexagon (pts_bins).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")

</code></pre>

<hr>
<h2 id='predict_emb'>Predict 2D embeddings</h2><span id='topic+predict_emb'></span>

<h3>Description</h3>

<p>Given a test dataset, the centroid coordinates of hexagonal bins in  2D and high-dimensional space,
predict the 2D embeddings for each data point in the test dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_emb(test_data, df_bin_centroids, df_bin, type_NLDR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_emb_+3A_test_data">test_data</code></td>
<td>
<p>The test dataset containing high-dimensional coordinates and an unique identifier.</p>
</td></tr>
<tr><td><code id="predict_emb_+3A_df_bin_centroids">df_bin_centroids</code></td>
<td>
<p>Centroid coordinates of hexagonal bins in 2D space.</p>
</td></tr>
<tr><td><code id="predict_emb_+3A_df_bin">df_bin</code></td>
<td>
<p>Centroid coordinates of hexagonal bins in high dimensions.</p>
</td></tr>
<tr><td><code id="predict_emb_+3A_type_nldr">type_NLDR</code></td>
<td>
<p>The type of non-linear dimensionality reduction (NLDR) used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains predicted 2D embeddings, ID in the test data, and predicted hexagonal IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- fit_highd_model(training_data = s_curve_noise_training, x = "UMAP1", y = "UMAP2",
nldr_df_with_id = s_curve_noise_umap_scaled, col_start_2d = "UMAP", col_start_highd = "x")
df_bin_centroids &lt;- model$df_bin_centroids
df_bin &lt;- model$df_bin
predict_emb(test_data = s_curve_noise_training, df_bin_centroids = df_bin_centroids,
df_bin = df_bin, type_NLDR = "UMAP")

</code></pre>

<hr>
<h2 id='s_curve_noise'>S-curve dataset with noise dimensions</h2><span id='topic+s_curve_noise'></span>

<h3>Description</h3>

<p>The 's_curve_noise' dataset contains a 3-dimensional S-curve with added noise dimensions.
Each data point is represented by seven dimensions (x1 to x7) and an ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 8 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Identification number</p>
</dd>
<dt>x1, x2, x3, x4, x5, x6, x7</dt><dd><p>High-dimensional coordinates</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for illustrative purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise dataset
data(s_curve_noise)

# Display the first few rows of the dataset
head(s_curve_noise)

</code></pre>

<hr>
<h2 id='s_curve_noise_test'>S-curve dataset with noise dimensions for test</h2><span id='topic+s_curve_noise_test'></span>

<h3>Description</h3>

<p>The 's_curve_noise_test' dataset contains test data with dimensions x1,
x2, x3, x4, x5, x6, and x7. Each data point is identified by an ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise_test)
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 rows and 8 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Identification number</p>
</dd>
<dt>x1, x2, x3, x4, x5, x6, x7</dt><dd><p>High-dimensional coordinates</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for training purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise_test dataset
data(s_curve_noise_test)

# Display the first few rows of the dataset
head(s_curve_noise_test)

</code></pre>

<hr>
<h2 id='s_curve_noise_training'>S-curve dataset with noise dimensions for training</h2><span id='topic+s_curve_noise_training'></span>

<h3>Description</h3>

<p>The 's_curve_noise_training' dataset contains training data with dimensions x1,
x2, x3, x4, x5, x6, and x7. Each data point is identified by an ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise_training)
</code></pre>


<h3>Format</h3>

<p>A data frame with 75 rows and 8 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Identification number</p>
</dd>
<dt>x1, x2, x3, x4, x5, x6, x7</dt><dd><p>High-dimensional coordinates</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for training purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise_training dataset
data(s_curve_noise_training)

# Display the first few rows of the dataset
head(s_curve_noise_training)

</code></pre>

<hr>
<h2 id='s_curve_noise_umap'>UMAP embedding for S-curve dataset which with noise dimensions</h2><span id='topic+s_curve_noise_umap'></span>

<h3>Description</h3>

<p>The 's_curve_noise_umap' dataset contains the UMAP (Uniform Manifold
Approximation and Projection) embeddings of a three-dimensional S-curve with
added noise. Each data point is represented by two UMAP coordinates (UMAP1
and UMAP2) and an ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise_umap)
</code></pre>


<h3>Format</h3>

<p>## 's_curve_noise_umap'
A data frame with 75 rows and 3 columns:
</p>

<dl>
<dt>UMAP1</dt><dd><p>Numeric, first UMAP 2D embeddings.</p>
</dd>
<dt>UMAP2</dt><dd><p>Numeric, second UMAP 2D embeddings.</p>
</dd>
<dt>ID</dt><dd><p>Numeric, identifier for each data point.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for illustrative purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise_umap dataset
data(s_curve_noise_umap)

# Display the first few rows of the dataset
head(s_curve_noise_umap)

</code></pre>

<hr>
<h2 id='s_curve_noise_umap_predict'>Predicted UMAP embedding for S-curve dataset which with noise dimensions</h2><span id='topic+s_curve_noise_umap_predict'></span>

<h3>Description</h3>

<p>The 's_curve_noise_umap_predict' dataset contains the predicted UMAP (Uniform Manifold
Approximation and Projection) embeddings of a three-dimensional S-curve with
added noise. Each data point is represented by two UMAP coordinates (UMAP1
and UMAP2) and an ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise_umap_predict)
</code></pre>


<h3>Format</h3>

<p>## 's_curve_noise_umap_predict'
A data frame with 75 rows and 3 columns:
</p>

<dl>
<dt>UMAP1</dt><dd><p>Numeric, predicted first UMAP 2D embeddings.</p>
</dd>
<dt>UMAP2</dt><dd><p>Numeric, predicted second UMAP 2D embeddings.</p>
</dd>
<dt>ID</dt><dd><p>Numeric, identifier for each data point.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for illustrative purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise_umap_predict dataset
data(s_curve_noise_umap_predict)

# Display the first few rows of the dataset
head(s_curve_noise_umap_predict)

</code></pre>

<hr>
<h2 id='s_curve_noise_umap_scaled'>Scaled UMAP embedding for S-curve dataset which with noise dimensions</h2><span id='topic+s_curve_noise_umap_scaled'></span>

<h3>Description</h3>

<p>The 's_curve_noise_umap_scaled' dataset contains the scaled UMAP (Uniform Manifold
Approximation and Projection) embeddings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s_curve_noise_umap_scaled)
</code></pre>


<h3>Format</h3>

<p>## 's_curve_noise_umap_scaled'
A data frame with 25 rows and 3 columns:
</p>

<dl>
<dt>UMAP1</dt><dd><p>Numeric, Scaled first UMAP 2D embeddings.</p>
</dd>
<dt>UMAP2</dt><dd><p>Numeric, Scaled second UMAP 2D embedding.</p>
</dd>
<dt>ID</dt><dd><p>Numeric, identifier for each data point.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset is generated for illustrative purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the s_curve_noise_umap_scaled dataset
data(s_curve_noise_umap_scaled)

# Display the first few rows of the dataset
head(s_curve_noise_umap_scaled)

</code></pre>

<hr>
<h2 id='show_langevitour'>Visualize the model overlaid on high-dimensional data</h2><span id='topic+show_langevitour'></span>

<h3>Description</h3>

<p>This function generates a LangeviTour visualization based on different
conditions and input parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_langevitour(
  df,
  df_b,
  df_b_with_center_data,
  benchmark_value = NA,
  distance_df,
  distance_col,
  use_default_benchmark_val = FALSE,
  col_start
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_langevitour_+3A_df">df</code></td>
<td>
<p>A data frame containing the high-dimensional data.</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_df_b">df_b</code></td>
<td>
<p>A data frame containing the high-dimensional coordinates of bin centroids.</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_df_b_with_center_data">df_b_with_center_data</code></td>
<td>
<p>The dataset with hexbin centroids.</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_benchmark_value">benchmark_value</code></td>
<td>
<p>The benchmark value used to remove long edges (optional).</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_distance_df">distance_df</code></td>
<td>
<p>The distance dataframe.</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_distance_col">distance_col</code></td>
<td>
<p>The name of the distance column.</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_use_default_benchmark_val">use_default_benchmark_val</code></td>
<td>
<p>Logical, indicating whether to use default
benchmark value  to remove long edges (default is FALSE).</p>
</td></tr>
<tr><td><code id="show_langevitour_+3A_col_start">col_start</code></td>
<td>
<p>The text that begin the column name of the high-dimensional data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A langevitour object with the model and the high-dimensional data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
umap_data_with_hb_id &lt;- as.data.frame(do.call(cbind, hb_obj$data_hb_id))
df_all &lt;- dplyr::bind_cols(s_curve_noise_training |&gt; dplyr::select(-ID), umap_data_with_hb_id)
df_bin &lt;- avg_highd_data(data = df_all, col_start = "x")
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df,
counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
tr_from_to_df &lt;- gen_edges(tri_object = tr1_object)
distance_df &lt;- cal_2d_dist(tr_coord_df = tr_from_to_df, start_x = "x_from",
start_y = "y_from", end_x = "x_to", end_y = "y_to",
select_vars = c("from", "to", "distance"))
show_langevitour(df = df_all, df_b = df_bin, df_b_with_center_data = df_bin_centroids,
benchmark_value = 0.75, distance = distance_df, distance_col = "distance",
use_default_benchmark_val = FALSE, col_start = "x")

</code></pre>

<hr>
<h2 id='stat_trimesh'>stat_trimesh Custom Stat for trimesh plot</h2><span id='topic+stat_trimesh'></span>

<h3>Description</h3>

<p>stat_trimesh Custom Stat for trimesh plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_trimesh(
  mapping = NULL,
  data = NULL,
  geom = GeomTrimesh$default_aes(),
  position = "identity",
  show.legend = NA,
  outliers = TRUE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_trimesh_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings for the plot.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_data">data</code></td>
<td>
<p>The data to be plotted.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_geom">geom</code></td>
<td>
<p>The geometry to be used in the plot.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_position">position</code></td>
<td>
<p>The position adjustment to be applied.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_show.legend">show.legend</code></td>
<td>
<p>Whether to show the legend for this layer.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_outliers">outliers</code></td>
<td>
<p>Whether to include outliers.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>Whether to inherit aesthetics from the plot or the layer.</p>
</td></tr>
<tr><td><code id="stat_trimesh_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the 'layer' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot2' layer object.
</p>

<hr>
<h2 id='tri_bin_centroids'>Triangulate bin centroids</h2><span id='topic+tri_bin_centroids'></span>

<h3>Description</h3>

<p>This function triangulates the bin centroids using the x and y coordinates
provided in the input data frame and returns the triangular object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri_bin_centroids(hex_df, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri_bin_centroids_+3A_hex_df">hex_df</code></td>
<td>
<p>The data frame containing the bin centroids.</p>
</td></tr>
<tr><td><code id="tri_bin_centroids_+3A_x">x</code></td>
<td>
<p>The name of the column that contains x coordinates of bin centroids.</p>
</td></tr>
<tr><td><code id="tri_bin_centroids_+3A_y">y</code></td>
<td>
<p>The name of the column that contains y coordinates of bin centroids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A triangular object representing the triangulated bin centroids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")

</code></pre>

<hr>
<h2 id='vis_lg_mesh'>Visualize triangular mesh with coloured long edges</h2><span id='topic+vis_lg_mesh'></span>

<h3>Description</h3>

<p>This function visualize triangular mesh with coloured long edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_lg_mesh(distance_edges, benchmark_value, tr_coord_df, distance_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_lg_mesh_+3A_distance_edges">distance_edges</code></td>
<td>
<p>The data frame containing the edge information.</p>
</td></tr>
<tr><td><code id="vis_lg_mesh_+3A_benchmark_value">benchmark_value</code></td>
<td>
<p>The threshold value to determine long edges.</p>
</td></tr>
<tr><td><code id="vis_lg_mesh_+3A_tr_coord_df">tr_coord_df</code></td>
<td>
<p>A data frame containing columns for the x and y coordinates of start and end points.</p>
</td></tr>
<tr><td><code id="vis_lg_mesh_+3A_distance_col">distance_col</code></td>
<td>
<p>The column name in 'distance_edges' representing the distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the triangular mesh plot where long edges are
coloured differently.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
tr_from_to_df &lt;- gen_edges(tri_object = tr1_object)
distance_df &lt;- cal_2d_dist(tr_coord_df = tr_from_to_df, start_x = "x_from",
start_y = "y_from", end_x = "x_to", end_y = "y_to",
select_vars = c("from", "to", "distance"))
vis_lg_mesh(distance_edges = distance_df, benchmark_value = 0.75,
tr_coord_df = tr_from_to_df, distance_col = "distance")

</code></pre>

<hr>
<h2 id='vis_rmlg_mesh'>Visualize triangular mesh after removing the long edges</h2><span id='topic+vis_rmlg_mesh'></span>

<h3>Description</h3>

<p>This function visualize the triangular mesh after removing the long edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_rmlg_mesh(distance_edges, benchmark_value, tr_coord_df, distance_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_rmlg_mesh_+3A_distance_edges">distance_edges</code></td>
<td>
<p>The data frame containing the edge information.</p>
</td></tr>
<tr><td><code id="vis_rmlg_mesh_+3A_benchmark_value">benchmark_value</code></td>
<td>
<p>The threshold value to determine long edges.</p>
</td></tr>
<tr><td><code id="vis_rmlg_mesh_+3A_tr_coord_df">tr_coord_df</code></td>
<td>
<p>A data frame containing columns for the x and y coordinates of start and end points.</p>
</td></tr>
<tr><td><code id="vis_rmlg_mesh_+3A_distance_col">distance_col</code></td>
<td>
<p>The column name in 'distance_edges' representing the distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the triangular mesh plot where long edges are removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_bins_list &lt;- calc_bins(data = s_curve_noise_umap_scaled, x = "UMAP1",
y = "UMAP2", hex_size = NA, buffer_x = NA, buffer_y = NA)
num_bins_x &lt;- num_bins_list$num_x
num_bins_y &lt;- num_bins_list$num_y
hb_obj &lt;- hex_binning(data = s_curve_noise_umap_scaled,
x = "UMAP1", y = "UMAP2", num_bins_x = num_bins_x,
num_bins_y = num_bins_y, x_start = NA, y_start = NA, buffer_x = NA,
buffer_y = NA, hex_size = NA, col_start = "UMAP")
all_centroids_df &lt;- as.data.frame(do.call(cbind, hb_obj$centroids))
counts_df &lt;- as.data.frame(do.call(cbind, hb_obj$std_cts))
df_bin_centroids &lt;- extract_hexbin_centroids(centroids_df = all_centroids_df, counts_df = counts_df)
tr1_object &lt;- tri_bin_centroids(hex_df = df_bin_centroids, x = "c_x", y = "c_y")
tr_from_to_df &lt;- gen_edges(tri_object = tr1_object)
distance_df &lt;- cal_2d_dist(tr_coord_df = tr_from_to_df, start_x = "x_from",
start_y = "y_from", end_x = "x_to", end_y = "y_to",
select_vars = c("from", "to", "distance"))
vis_rmlg_mesh(distance_edges = distance_df, benchmark_value = 0.75,
tr_coord_df = tr_from_to_df, distance_col = "distance")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
