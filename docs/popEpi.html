<!DOCTYPE html><html><head><title>Help for package popEpi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {popEpi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust'><p>Adjust Estimates by Categorical Variables</p></a></li>
<li><a href='#aggre'><p>Aggregation of split <code>Lexis</code> data</p></a></li>
<li><a href='#all_names_present'><p>Check if all names are present in given data</p></a></li>
<li><a href='#array_df_ratetable_utils'><p>'array's, 'data.frame's and 'ratetable's</p></a></li>
<li><a href='#as.aggre'><p>Coercion to Class <code>aggre</code></p></a></li>
<li><a href='#as.Date.yrs'><p>Coerce Fractional Year Values to Date Values</p></a></li>
<li><a href='#cast_simple'><p>Cast <code>data.table</code>/<code>data.frame</code> from long format to wide format</p></a></li>
<li><a href='#cut_bound'><p>Change output values from cut(..., labels = NULL) output</p></a></li>
<li><a href='#direct_standardization'><p>Direct Adjusting in <span class="pkg">popEpi</span> Using Weights</p></a></li>
<li><a href='#fac2num'><p>Convert factor variable to numeric</p></a></li>
<li><a href='#flexible_argument'><p>Flexible Variable Usage in <span class="pkg">popEpi</span> Functions</p></a></li>
<li><a href='#get.yrs'><p>Convert date objects to fractional years</p></a></li>
<li><a href='#ICSS'><p>Age standardisation weights from the ICSS scheme.</p></a></li>
<li><a href='#is_leap_year'><p>Detect leap years</p></a></li>
<li><a href='#is.Date'><p>Test if object is a <code>Date</code> object</p></a></li>
<li><a href='#Lexis_fpa'><p>Create a Lexis Object with Follow-up Time, Period, and Age</p>
Time Scales</a></li>
<li><a href='#lexpand'><p>Split case-level observations</p></a></li>
<li><a href='#lines.sirspline'><p>lines method for sirspline-object</p></a></li>
<li><a href='#lines.survmean'><p>Graphically Inspect Curves Used in Mean Survival Computation</p></a></li>
<li><a href='#lines.survtab'><p><code>lines</code> method for survtab objects</p></a></li>
<li><a href='#lower_bound'><p>Return lower_bound value from char string (20,30]</p></a></li>
<li><a href='#ltable'><p>Tabulate Counts and Other Functions by Multiple Variables into a</p>
Long-Format Table</a></li>
<li><a href='#meanpop_fi'><p>Mean population counts in Finland year, sex, and age group.</p></a></li>
<li><a href='#na2zero'><p>Convert NA's to zero in data.table</p></a></li>
<li><a href='#plot.rate'><p>plot method for rate object</p></a></li>
<li><a href='#plot.sir'><p>Plot method for sir-object</p></a></li>
<li><a href='#plot.sirspline'><p><code>plot</code> method for sirspline-object</p></a></li>
<li><a href='#plot.survmean'><p>Graphically Inspect Curves Used in Mean Survival Computation</p></a></li>
<li><a href='#plot.survtab'><p><code>plot</code> method for survtab objects</p></a></li>
<li><a href='#poisson.ci'><p>Get rate and exact Poisson confidence intervals</p></a></li>
<li><a href='#popEpi-package'><p>popEpi: Functions for large-scale epidemiological analysis</p></a></li>
<li><a href='#pophaz'><p>Expected / Population Hazard Data Sets Usage in <span class="pkg">popEpi</span></p></a></li>
<li><a href='#popmort'><p>Population mortality rates in Finland 1951 - 2013 in 101 age groups and</p>
by gender. This is an example of a population hazard table as used in
<span class="pkg">popEpi</span>; for the general help page, see <code>pophaz</code>.</a></li>
<li><a href='#prepExpo'><p>Prepare Exposure Data for Aggregation</p></a></li>
<li><a href='#print.aggre'><p>Print an <code>aggre</code> Object</p></a></li>
<li><a href='#print.rate'><p>Print an rate object</p></a></li>
<li><a href='#print.survtab'><p>Print a survtab Object</p></a></li>
<li><a href='#rate'><p>Direct-Standardised Incidence/Mortality Rates</p></a></li>
<li><a href='#rate_ratio'><p>Confidence intervals for the rate ratios</p></a></li>
<li><a href='#relpois'><p>Excess hazard Poisson model</p></a></li>
<li><a href='#relpois_ag'><p>Excess hazard Poisson model</p></a></li>
<li><a href='#robust_values'><p>Convert values to numeric robustly</p></a></li>
<li><a href='#rpcurve'><p>Marginal piecewise parametric relative survival curve</p></a></li>
<li><a href='#RPL'><p>Relative Poisson family object</p></a></li>
<li><a href='#setaggre'><p>Set <code>aggre</code> attributes to an object by modifying in place</p></a></li>
<li><a href='#setclass'><p>Set the class of an object (convenience function for</p>
<code>setattr(obj, "class", CLASS)</code>); can add instead of replace</a></li>
<li><a href='#setcolsnull'><p>Delete <code>data.table</code> columns if there</p></a></li>
<li><a href='#sibr'><p>sibr - a simulated cohort of Finnish female breast cancer patients</p></a></li>
<li><a href='#sir'><p>Calculate SIR or SMR</p></a></li>
<li><a href='#sir_exp'><p>Calculate SMR</p></a></li>
<li><a href='#sir_ratio'><p>Confidence intervals for the ratio of two SIRs/SMRs</p></a></li>
<li><a href='#sire'><p>sire - a simulated cohort of Finnish female rectal cancer patients</p></a></li>
<li><a href='#sirspline'><p>Estimate splines for SIR or SMR</p></a></li>
<li><a href='#splitLexisDT'><p>Split case-level observations</p></a></li>
<li><a href='#splitMulti'><p>Split case-level observations</p></a></li>
<li><a href='#stdpop101'><p>World standard population by 1 year age groups from 1 to 101. Sums to 100 000.</p></a></li>
<li><a href='#stdpop18'><p>Standard populations from 2000: world, Europe and Nordic.</p></a></li>
<li><a href='#summary.aggre'><p>Summarize an <code>aggre</code> Object</p></a></li>
<li><a href='#summary.survtab'><p>Summarize a survtab Object</p></a></li>
<li><a href='#Surv'><p>Survival Objects</p></a></li>
<li><a href='#survmean'><p>Compute Mean Survival Times Using Extrapolation</p></a></li>
<li><a href='#survtab'><p>Estimate Survival Time Functions</p></a></li>
<li><a href='#survtab_ag'><p>Estimate Survival Time Functions</p></a></li>
<li><a href='#try2int'><p>Attempt coercion to integer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions for Epidemiological Analysis using Population Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.11</td>
</tr>
<tr>
<td>Author:</td>
<td>Joonas Miettinen <a href="https://orcid.org/0000-0001-8624-6754"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Matti Rantanen [aut],
  Karri Seppa [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joonas Miettinen &lt;joonas.miettinen@cancer.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables computation of epidemiological statistics, including
    those where counts or mortality rates of the reference population are
    used.  Currently supported: excess hazard models (Dickman, Sloggett,
    Hills, and Hakulinen (2012) &lt;<a href="https://doi.org/10.1002%2Fsim.1597">doi:10.1002/sim.1597</a>&gt;), rates, mean
    survival times, relative/net survival (in particular the Ederer II
    (Ederer and Heise (1959)) and Pohar Perme (Pohar Perme, Stare, and
    Esteve (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2011.01640.x">doi:10.1111/j.1541-0420.2011.01640.x</a>&gt;) estimators), and
    standardized incidence and mortality ratios, all of which can be
    easily adjusted for by covariates such as age. Fast splitting and
    aggregation of 'Lexis' objects (from package 'Epi') and other
    computations achieved using 'data.table'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FinnishCancerRegistry/popEpi">https://github.com/FinnishCancerRegistry/popEpi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FinnishCancerRegistry/popEpi/issues">https://github.com/FinnishCancerRegistry/popEpi/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.4), Epi (&ge; 2.0), splines, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, date, knitr, mstate, relsurv, rmarkdown, roxygen2,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 07:41:40 UTC; joonas.miettinen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust'>Adjust Estimates by Categorical Variables</h2><span id='topic+adjust'></span>

<h3>Description</h3>

<p>This function is only intended to be used within a formula
when supplied to e.g. <code><a href="#topic+survtab_ag">survtab_ag</a></code> and should not be
used elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_+3A_...">...</code></td>
<td>
<p>variables to adjust by, e.g. <code>adjust(factor(v1), v2, v3)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of promises of the variables supplied which can be
evaluated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y ~ x + adjust(z)
</code></pre>

<hr>
<h2 id='aggre'>Aggregation of split <code>Lexis</code> data</h2><span id='topic+aggre'></span>

<h3>Description</h3>

<p>Aggregates a split <code>Lexis</code> object by given variables 
and / or expressions into a long-format table of person-years and 
transitions / end-points. Automatic aggregation over time scales
by which data has been split if the respective time scales are mentioned
in the aggregation argument to e.g. intervals of calendar time, follow-up time
and/or age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggre(
  lex,
  by = NULL,
  type = c("unique", "full"),
  sum.values = NULL,
  subset = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggre_+3A_lex">lex</code></td>
<td>
<p>a <code>Lexis</code> object split with e.g. 
<code><a href="Epi.html#topic+splitLexis">splitLexis</a></code> or <code><a href="#topic+splitMulti">splitMulti</a></code></p>
</td></tr>
<tr><td><code id="aggre_+3A_by">by</code></td>
<td>
<p>variables to tabulate (aggregate) by.
<a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>by = c("V1", "V2")</code>. See Details and Examples.</p>
</td></tr>
<tr><td><code id="aggre_+3A_type">type</code></td>
<td>
<p>determines output levels to which data is aggregated varying
from returning only rows with <code>pyrs &gt; 0</code> (<code>"unique"</code>) to
returning all possible combinations of variables given in <code>aggre</code> even
if those combinations are not represented in data (<code>"full"</code>); 
see Details</p>
</td></tr>
<tr><td><code id="aggre_+3A_sum.values">sum.values</code></td>
<td>
<p>optional: additional variables to sum by argument
<code>by</code>. <a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>sum.values = c("V1", "V2")</code></p>
</td></tr>
<tr><td><code id="aggre_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset by before computations;
e.g. <code>subset = area %in% c("A", "B")</code></p>
</td></tr>
<tr><td><code id="aggre_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, the function returns timings
and some information useful for debugging along the aggregation process</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Basics</strong>
</p>
<p><code>aggre</code> is intended for aggregation of split <code>Lexis</code> data only.
See <code><a href="Epi.html#topic+Lexis">Lexis</a></code> for forming <code>Lexis</code> objects by hand
and e.g. <code><a href="Epi.html#topic+splitLexis">splitLexis</a></code>, <code><a href="#topic+splitLexisDT">splitLexisDT</a></code>, and
<code><a href="#topic+splitMulti">splitMulti</a></code> for splitting the data. <code><a href="#topic+lexpand">lexpand</a></code>
may be used for simple data sets to do both steps as well as aggregation
in the same function call.
</p>
<p>Here aggregation refers to computing person-years and the appropriate events
(state transitions and end points in status) for the subjects in the data.
Hence, it computes e.g. deaths (end-point and state transition) and 
censorings (end-point) as well as events in a multi-state setting
(state transitions).
</p>
<p>The result is a long-format <code>data.frame</code> or <code>data.table</code>
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>)
with the columns <code>pyrs</code> and the appropriate transitions named as
<code>fromXtoY</code>, e.g. <code>from0to0</code> and <code>from0to1</code> depending
on the values of <code>lex.Cst</code> and <code>lex.Xst</code>.
</p>
<p><strong>The by argument</strong>
</p>
<p>The <code>by</code> argument determines the length of the table, i.e.
the combinations of variables to which data is aggregated.  
<code>by</code> is relatively flexible, as it can be supplied as
</p>

<ul>
<li><p>a character string vector, e.g. <code>c("sex", "area")</code>, 
naming variables existing in <code>lex</code>
</p>
</li>
<li><p>an expression, e.g. <code>factor(sex, 0:1, c("m", "f"))</code> 
using any variable found in <code>lex</code>
</p>
</li>
<li><p>a list (fully or partially named) of expressions, e.g. 
<code>list(gender = factor(sex, 0:1, c("m", "f"), area)</code>
</p>
</li></ul>

<p>Note that expressions effectively allow a variable to be supplied simply as
e.g. <code>by = sex</code> (as a symbol/name in R lingo).
</p>
<p>The data is then aggregated to the levels of the given variables 
or expression(s). Variables defined to be time scales in the supplied 
<code>Lexis</code> are processed in a special way: If any are mentioned in the
<code>by</code> argument, intervals of them are formed based on the breaks
used to split the data: e.g. if <code>age</code> was split using the breaks 
<code>c(0, 50, Inf)</code>, mentioning <code>age</code> in <code>by</code> leads to
creating the <code>age</code> intervals <code>[0, 50)</code> and <code>[50, Inf)</code>
and aggregating to them. The intervals are identified in the output
as the lower bounds of the appropriate intervals.
</p>
<p>The order of multiple time scales mentioned in <code>by</code> matters,
as the last mentioned time scale is assumed to be a survival time scale
for when computing event counts. E.g. when the data is split by the breaks
<code>list(FUT = 0:5, CAL = c(2008,2010))</code>, time lines cut short at
<code>CAL = 2010</code> are considered to be censored, but time lines cut short at
<code>FUT = 5</code> are not. See Return.
</p>
<p><strong>Aggregation types (styles)</strong>
</p>
<p>It is almost always enough to aggregate the data to variable levels
that are actually represented in the data 
(default <code>aggre = "unique"</code>; alias <code>"non-empty"</code>). 
For certain uses it may be useful
to have also &quot;empty&quot; levels represented (resulting in some rows in output
with zero person-years and events); in these cases supplying
<code>aggre = "full"</code> (alias <code>"cartesian"</code>) causes <code>aggre</code>
to determine the Cartesian product of all the levels of the supplied 
<code>by</code> variables or expressions and aggregate to them. As an example
of a Cartesian product, try
</p>
<p><code>merge(1:2, 1:5)</code>.
</p>


<h3>Value</h3>

<p>A long <code>data.frame</code> or <code>data.table</code> of aggregated person-years 
(<code>pyrs</code>), numbers of subjects at risk (<code>at.risk</code>), and events
formatted <code>fromXtoY</code>, where <code>X</code> and <code>X</code> are states 
transitioning from and to or states at the end of each <code>lex.id</code>'s 
follow-up (implying <code>X</code> = <code>Y</code>). Subjects at risk are computed 
in the beginning of an interval defined by any Lexis time scales and 
mentioned in <code>by</code>, but events occur at any point within an interval.
</p>
<p>When the data has been split along multiple time scales, the last
time scale mentioned in <code>by</code> is considered to be the survival time 
scale with regard to computing events. Time lines cut short by the
extrema of non-survival-time-scales are considered to be censored
(&quot;transitions&quot; from the current state to the current state).
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aggregate">aggregate</a></code> for a similar base R solution,
and <code><a href="#topic+ltable">ltable</a></code> for a <code>data.table</code> based aggregator. Neither
are directly applicable to split <code>Lexis</code> data.
</p>
<p>Other aggregation functions: 
<code><a href="#topic+as.aggre">as.aggre</a>()</code>,
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+setaggre">setaggre</a>()</code>,
<code><a href="#topic+summary.aggre">summary.aggre</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## form a Lexis object
library(Epi)
data(sibr)
x &lt;- sibr[1:10,]
x[1:5,]$sex &lt;- 0 ## pretend some are male
x &lt;- Lexis(data = x,
           entry = list(AGE = dg_age, CAL = get.yrs(dg_date)),
           exit = list(CAL = get.yrs(ex_date)),
           entry.status=0, exit.status = status)
x &lt;- splitMulti(x, breaks = list(CAL = seq(1993, 2013, 5), 
                                 AGE = seq(0, 100, 50)))

## these produce the same results (with differing ways of determining aggre)
a1 &lt;- aggre(x, by = list(gender = factor(sex, 0:1, c("m", "f")), 
             agegroup = AGE, period = CAL))

a2 &lt;- aggre(x, by = c("sex", "AGE", "CAL"))

a3 &lt;- aggre(x, by = list(sex, agegroup = AGE, CAL))

## returning also empty levels
a4 &lt;- aggre(x, by = c("sex", "AGE", "CAL"), type = "full")

## computing also expected numbers of cases
x &lt;- lexpand(sibr[1:10,], birth = bi_date, entry = dg_date,
             exit = ex_date, status = status %in% 1:2, 
             pophaz = popmort, fot = 0:5, age = c(0, 50, 100))
x$d.exp &lt;- with(x, lex.dur*pop.haz)
## these produce the same result
a5 &lt;- aggre(x, by = c("sex", "age", "fot"), sum.values = list(d.exp))
a5 &lt;- aggre(x, by = c("sex", "age", "fot"), sum.values = "d.exp")
a5 &lt;- aggre(x, by = c("sex", "age", "fot"), sum.values = d.exp)
## same result here with custom name
a5 &lt;- aggre(x, by = c("sex", "age", "fot"), 
             sum.values = list(expCases = d.exp))
             
## computing pohar-perme weighted figures
x$d.exp.pp &lt;- with(x, lex.dur*pop.haz*pp)
a6 &lt;- aggre(x, by = c("sex", "age", "fot"), 
             sum.values = c("d.exp", "d.exp.pp"))
## or equivalently e.g. sum.values = list(expCases = d.exp, expCases.p = d.exp.pp).
</code></pre>

<hr>
<h2 id='all_names_present'>Check if all names are present in given data</h2><span id='topic+all_names_present'></span>

<h3>Description</h3>

<p>Given a character vector, checks if all names are present in <code>names(data)</code>.
Throws error if <code>stops=TRUE</code>, else returns <code>FALSE</code> if some variable name is not present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_names_present(data, var.names, stops = TRUE, msg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_names_present_+3A_data">data</code></td>
<td>
<p>dataset where the variable names should be found</p>
</td></tr>
<tr><td><code id="all_names_present_+3A_var.names">var.names</code></td>
<td>
<p>a character vector of variable names, e.g.
<code>c("var1", "var2")</code></p>
</td></tr>
<tr><td><code id="all_names_present_+3A_stops">stops</code></td>
<td>
<p>logical, stop returns exception</p>
</td></tr>
<tr><td><code id="all_names_present_+3A_msg">msg</code></td>
<td>
<p>Custom message to return instead of default message.
Special: include <code>%%VARS%%</code> in message string and the missing 
variable names will be inserted there (quoted, separated by comma, e.g. 
<code>'var1'</code>, <code>'var2'</code> &mdash; no leading or tracing white space).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'TRUE' if all 'var.names' are in 'data', else 'FALSE',
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust_values">robust_values</a></code>
</p>

<hr>
<h2 id='array_df_ratetable_utils'>'array's, 'data.frame's and 'ratetable's</h2><span id='topic+array_df_ratetable_utils'></span><span id='topic+long_df_to_array'></span><span id='topic+long_df_to_ratetable'></span><span id='topic+long_dt_to_array'></span><span id='topic+long_dt_to_ratetable'></span><span id='topic+array_to_long_df'></span><span id='topic+array_to_long_dt'></span><span id='topic+array_to_ratetable'></span><span id='topic+ratetable_to_array'></span><span id='topic+ratetable_to_long_df'></span><span id='topic+ratetable_to_long_dt'></span>

<h3>Description</h3>

<p>Utilities to transform objects between 'array', 'data.frame', and
[survival::ratetable].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_df_to_array(x, stratum.col.nms, value.col.nm)

long_df_to_ratetable(
  x,
  stratum.col.nms,
  value.col.nm,
  dim.types,
  cut.points = NULL
)

long_dt_to_array(x, stratum.col.nms, value.col.nm)

long_dt_to_ratetable(
  x,
  stratum.col.nms,
  value.col.nm,
  dim.types,
  cut.points = NULL
)

array_to_long_df(x)

array_to_long_dt(x)

array_to_ratetable(x, dim.types, cut.points = NULL)

ratetable_to_array(x)

ratetable_to_long_df(x)

ratetable_to_long_dt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_df_ratetable_utils_+3A_x">x</code></td>
<td>
<p>'[data.frame, data.table, array, ratetable]' (mandatory, no default)
</p>
<p>- 'long_df_to_array': a 'data.frame'
- 'long_df_to_ratetable': a 'data.frame'
- 'long_dt_to_array': a 'data.table'
- 'long_dt_to_ratetable': a 'data.table'
- 'array_to_long_df': an 'array'
- 'array_to_long_dt': an 'array'
- 'array_to_ratetable': an 'array'
- 'ratetable_to_array': a [survival::ratetable]
- 'ratetable_to_long_df': a [survival::ratetable]
- 'ratetable_to_long_dt': a [survival::ratetable]</p>
</td></tr>
<tr><td><code id="array_df_ratetable_utils_+3A_stratum.col.nms">stratum.col.nms</code></td>
<td>
<p>'[character]' (mandatory, no default)
</p>
<p>a vector of column names in 'x' by which values are stratified</p>
</td></tr>
<tr><td><code id="array_df_ratetable_utils_+3A_value.col.nm">value.col.nm</code></td>
<td>
<p>'[character]' (mandatory, no default)
</p>
<p>name of column in 'x' containing values (these will be contents of the
array)</p>
</td></tr>
<tr><td><code id="array_df_ratetable_utils_+3A_dim.types">dim.types</code></td>
<td>
<p>'[integer]' (mandatory, no default)
</p>
<p>see 'type' under **Details** in [survival::ratetable]</p>
</td></tr>
<tr><td><code id="array_df_ratetable_utils_+3A_cut.points">cut.points</code></td>
<td>
<p>'[NULL, list]' (optional, default 'NULL')
</p>
<p>see 'cutpoints' under **Details** in [survival::ratetable] 
</p>
<p>- 'NULL': automatically set using 'dimnames(x)' and 'dim.types'
- 'list': one element for each dimensions of 'x'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- 'long_df_to_array': converts a long-format 'data.frame' to an 'array'
with one or more dimensions
</p>
<p>- 'long_df_to_ratetable': calls 'long_df_to_array' and then 
'array_to_ratetable'
</p>
<p>- 'long_dt_to_array': simply asserts that 'x' is a 'data.table' and 
calls 'long_df_to_array'
</p>
<p>- 'long_dt_to_ratetable': calls 'long_dt_to_array' and then 
'array_to_ratetable'
</p>
<p>- 'array_to_long_df': converts an array with one or more dimensions into
a long-format 'data.frame'; any [dimnames] are used to name and fill the 
stratifying columns; for dimensions without a name, '&quot;.dX&quot;' is used
for stratifying column number 'X'; for each 'k', if there are no contents
in 'dimnames(x)[[k]]', the elements of 'seq(dim(x)[k])' are used to fill 
the corresponding stratifying column; the value column always has the name
'&quot;value&quot;'
</p>
<p>- 'array_to_long_dt': calls 'array_to_long_df' and converts result to a 
'data.table' for convenience
</p>
<p>- 'array_to_ratetable': converts an array to a [survival::ratetable]
</p>
<p>- 'ratetable_to_array': converts a [survival::ratetable] to an array
</p>
<p>- 'ratetable_to_long_df': calls 'ratetable_to_array' and then
'array_to_long_df'
</p>
<p>- 'ratetable_to_long_dt': calls 'ratetable_to_array' and then
'array_to_long_dt'
</p>


<h3>Value</h3>

<p>- 'long_df_to_array': an 'array'
- 'long_df_to_ratetable': a [survival::ratetable]
- 'long_dt_to_array': an 'array'
- 'long_dt_to_ratetable': a [survival::ratetable]
- 'array_to_long_df': an 'data.frame'
- 'array_to_long_dt': an 'data.table'
- 'array_to_ratetable': a [survival::ratetable]
- 'ratetable_to_array': an 'array'
- 'ratetable_to_long_df': a 'data.frame'
- 'ratetable_to_long_dt': a 'data.table'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
long_dt &lt;- popEpi::popmort
arr &lt;- long_df_to_array(long_dt, c("agegroup", "year", "sex"), "haz") 
rt &lt;- array_to_ratetable(arr, dim.types = c(2L, 4L, 1L))

arr2 &lt;- ratetable_to_array(rt)
long_df2 &lt;- array_to_long_df(arr2)

identical(sort(long_dt[["haz"]]), sort(long_df2[["value"]]))
</code></pre>

<hr>
<h2 id='as.aggre'>Coercion to Class <code>aggre</code></h2><span id='topic+as.aggre'></span><span id='topic+as.aggre.data.frame'></span><span id='topic+as.aggre.data.table'></span><span id='topic+as.aggre.default'></span>

<h3>Description</h3>

<p>Coerces an R object to an <code>aggre</code> object, identifying
the object as one containing aggregated counts, person-years and other
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.aggre(x, values = NULL, by = NULL, breaks = NULL, ...)

## S3 method for class 'data.frame'
as.aggre(x, values = NULL, by = NULL, breaks = NULL, ...)

## S3 method for class 'data.table'
as.aggre(x, values = NULL, by = NULL, breaks = NULL, ...)

## Default S3 method:
as.aggre(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.aggre_+3A_x">x</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code></p>
</td></tr>
<tr><td><code id="as.aggre_+3A_values">values</code></td>
<td>
<p>a character string vector; the names of value variables</p>
</td></tr>
<tr><td><code id="as.aggre_+3A_by">by</code></td>
<td>
<p>a character string vector; the names of variables by which 
<code>values</code> have been tabulated</p>
</td></tr>
<tr><td><code id="as.aggre_+3A_breaks">breaks</code></td>
<td>
<p>a list of breaks, where each element is a breaks vector
as usually passed to e.g. <code><a href="#topic+splitLexisDT">splitLexisDT</a></code>. The list must be
fully named, with the names corresponding to time scales at the aggregate
level in your data. Every unique value in a time scale variable in data must
also exist in the corresponding vector in the breaks list.</p>
</td></tr>
<tr><td><code id="as.aggre_+3A_...">...</code></td>
<td>
<p>arguments passed to or from methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a copy of 'x' with attributes set to those of an object of class
'&quot;aggre&quot;'.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.aggre(data.frame)</code>: Coerces a <code>data.frame</code> to an <code>aggre</code> object
</p>
</li>
<li> <p><code>as.aggre(data.table)</code>: Coerces a <code>data.table</code> to an <code>aggre</code> object
</p>
</li>
<li> <p><code>as.aggre(default)</code>: Default method for <code>as.aggre</code> (stops computations
if no class-specific method found)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+aggre">aggre</a>()</code>,
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+setaggre">setaggre</a>()</code>,
<code><a href="#topic+summary.aggre">summary.aggre</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
df &lt;- data.frame(sex = rep(c("male", "female"), each = 5), 
                 obs = rpois(10, rep(7,5, each=5)), 
                 pyrs = rpois(10, lambda = 10000))
dt &lt;- as.data.table(df)

df &lt;- as.aggre(df, values = c("pyrs", "obs"), by = "sex")
dt &lt;- as.aggre(dt, values = c("pyrs", "obs"), by = "sex")

class(df)
class(dt)

BL &lt;- list(fot = 0:5)
df &lt;- data.frame(df)
df &lt;- as.aggre(df, values = c("pyrs", "obs"), by = "sex", breaks = BL)

</code></pre>

<hr>
<h2 id='as.Date.yrs'>Coerce Fractional Year Values to Date Values</h2><span id='topic+as.Date.yrs'></span>

<h3>Description</h3>

<p>Coerces an <code>yrs</code> object to a <code>Date</code> object.
Some loss of information comes if <code>year.length = "approx"</code> 
was set when using <code><a href="#topic+get.yrs">get.yrs</a></code>, so the transformation back
to <code>Date</code> will not be perfect there. With <code>year.length = "actual"</code>
the original values are perfectly retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'yrs'
as.Date(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Date.yrs_+3A_x">x</code></td>
<td>
<p>an <code>yrs</code> object created by <code>get.yrs</code></p>
</td></tr>
<tr><td><code id="as.Date.yrs_+3A_...">...</code></td>
<td>
<p>unused, included for compatibility with other <code>as.Date</code>
methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 'Date' values based on the input fractional years.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.yrs">get.yrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sire", package = "popEpi")

## approximate year lengths: here 20 % have an extra day added
sire$dg_yrs &lt;- get.yrs(sire$dg_date)
summary(sire$dg_yrs)
dg_date2 &lt;- as.Date(sire$dg_yrs)
summary(as.numeric(dg_date2 - as.Date(sire$dg_date)))

## using actual year lengths
sire$dg_yrs &lt;- get.yrs(sire$dg_date, year.length = "actual")
summary(sire$dg_yrs)
dg_date2 &lt;- as.Date(sire$dg_yrs)
summary(as.numeric(dg_date2 - as.Date(sire$dg_date)))
</code></pre>

<hr>
<h2 id='cast_simple'>Cast <code>data.table</code>/<code>data.frame</code> from long format to wide format</h2><span id='topic+cast_simple'></span>

<h3>Description</h3>

<p>Convenience function for using <code><a href="data.table.html#topic+dcast.data.table">dcast.data.table</a></code>;
inputs are character strings (names of variables) instead of a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_simple(data = NULL, columns = NULL, rows = NULL, values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_simple_+3A_data">data</code></td>
<td>
<p>a <code>data.table</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cast_simple_+3A_columns">columns</code></td>
<td>
<p>a character string vector; the (unique combinations of the) 
levels of these variable will be different rows</p>
</td></tr>
<tr><td><code id="cast_simple_+3A_rows">rows</code></td>
<td>
<p>a character string vector; the (unique combinations of the) 
levels of these variable will be different columns</p>
</td></tr>
<tr><td><code id="cast_simple_+3A_values">values</code></td>
<td>
<p>a character string; the variable which will be represented
on rows and columns as specified by <code>columns</code> and <code>rows</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a small interface for <code>dcast</code> / 
<code>dcast.data.table</code> and less flexible than the originals.
</p>
<p>Note that all <code>data.table</code> objects are also <code>data.frame</code> 
objects, but that each have their own <code>dcast</code> method.
<code><a href="data.table.html#topic+dcast.data.table">dcast.data.table</a></code> is faster.
</p>
<p>If any values in <code>value.vars</code> need to be 
aggregated, they are aggregated using <code>sum</code>.
See <code>?dcast</code>.
</p>


<h3>Value</h3>

<p>A 'data.table' just like '[data.table::dcast]'.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen, Joonas Miettinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("data.table")
## e.g. silly counts from a long-format table to a wide format
test &lt;- data.table::copy(popEpi::sire)
test$dg_y &lt;- year(test$dg_date)
test$ex_y &lt;- year(test$ex_date)
tab &lt;- ltable(test, c("dg_y","ex_y"))
cast_simple(tab, columns='dg_y', rows="ex_y", values="obs")

</code></pre>

<hr>
<h2 id='cut_bound'>Change output values from cut(..., labels = NULL) output</h2><span id='topic+cut_bound'></span>

<h3>Description</h3>

<p>Selects lowest values of each factor after cut() based
on the assumption that the value starts from index 2 and end in comma &quot;,&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_bound(t, factor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_bound_+3A_t">t</code></td>
<td>
<p>is a character vector of elements, e.g. &quot;(20,60]&quot;</p>
</td></tr>
<tr><td><code id="cut_bound_+3A_factor">factor</code></td>
<td>
<p>logical; TRUE returns informative character string, FALSE numeric (left value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>type = 'factor': &quot;[50,52)&quot; -&gt; &quot;50-51&quot; OR &quot;[50,51)&quot; -&gt; &quot;50&quot;
</p>
<p>type = 'numeric': lowest bound in numeric.
</p>


<h3>Value</h3>

<p>If 'factor = TRUE', returns a character vector; else returns a numeric 
vector.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cut_bound("[1900, 1910)") ## "1900-1909"
</code></pre>

<hr>
<h2 id='direct_standardization'>Direct Adjusting in <span class="pkg">popEpi</span> Using Weights</h2><span id='topic+direct_standardization'></span><span id='topic+direct_adjusting'></span>

<h3>Description</h3>

<p>Several functions in <span class="pkg">popEpi</span> have support for direct standardization
of estimates. This document explains the usage of weighting with those
functions.
</p>


<h3>Details</h3>

<p>Direct standardization is performed by computing estimates of
<code>E</code>
by the set of adjusting variables <code>A</code>, to which a set of weights 
<code>W</code> is applicable. The weighted average over <code>A</code> is then the
direct-adjusted estimate of <code>E</code> (<code>E*</code>).
</p>
<p>To enable both quick and easy as well as more rigorous usage of direct
standardization with weights, the weights arguments in <span class="pkg">popEpi</span>
can be supplied in several ways. Ability to use the different
ways depends on the number of adjusting variables.
</p>
<p>The weights are always handled internally to sum to 1, so they do not
need to be scaled in this manner when they are supplied. E.g.
counts of subjects in strata may be passed.
</p>


<h3>Basic usage - one adjusting variable</h3>

<p>In the simple case where we are adjusting by only one variable 
(e.g. by age group), one can simply supply a vector of weights:
</p>
<p><code>FUN(weights = c(0.1, 0.25, 0.25, 0.2, 0.2))</code>
</p>
<p>which may be stored in advance:
</p>
<p><code>w &lt;- c(0.1, 0.25, 0.25, 0.2, 0.2)</code>
</p>
<p><code>FUN(weights = w)</code>
</p>
<p>The order of the weights matters. <span class="pkg">popEpi</span> functions with direct
adjusting enabled match the supplied weights to the adjusting variables
as follows: If the adjusting variable is a <code>factor</code>, the order
of the levels is used. Otherwise, the alphabetic order of the unique
values is used (try <code>sort</code> to see how it works). For clarity
and certainty we recommend using <code>factor</code> or <code>numeric</code> variables
when possible. <code>character</code> variables should be avoided: to see why,
try <code>sort(15:9)</code> and <code>sort(as.character(15:9))</code>.
</p>
<p>It is also possible to supply a <code>character</code> string corresponding
to one of the age group standardization schemes integrated into <span class="pkg">popEpi</span>:
</p>

<ul>
<li> <p><code>'europe_1976_18of5'</code> - European std. population (1976), 18 age groups
</p>
</li>
<li> <p><code>'nordic_2000_18of5'</code> - Nordic std. population (2000), 18 age groups
</p>
</li>
<li> <p><code>'world_1966_18of5'</code> - world standard (1966), 18 age groups
</p>
</li>
<li> <p><code>'world_2000_18of5'</code> - world standard (2000), 18 age groups
</p>
</li>
<li> <p><code>'world_2000_20of5'</code> - world standard (2000), 20 age groups 
</p>
</li>
<li> <p><code>'world_2000_101of1'</code> - world standard (2000), 101 age groups
</p>
</li></ul>

<p>Additionally, <code><a href="#topic+ICSS">ICSS</a></code> contains international weights used in 
cancer survival analysis, but they are not currently usable by passing
a string to <code>weights</code> and must be supplied by hand.
</p>
<p>You may also supply <code>weights = "internal"</code> to use internally
computed weights, i.e. usually simply the counts of subjects / person-time
experienced in each stratum. E.g.
</p>
<p><code>FUN(weights = "world_2000_18of5")</code>
</p>
<p>will use the world standard population from 2000 as 
weights for 18 age groups, that your adjusting variable is 
assumed to contain. The adjusting variable must be coded in this case as 
a numeric variable containing <code>1:18</code> or as a <code>factor</code> with
18 levels (coded from the youngest to the oldest age group).
</p>


<h3>More than one adjusting variable</h3>

<p>In the case that you employ more than one adjusting variable, separate
weights should be passed to match to the levels of the different adjusting
variables. When supplied correctly, &quot;grand&quot; weights are formed based on
the variable-specific weights by multiplying over the variable-specific
weights (e.g. if men have <code>w = 0.5</code> and the age group 0-4 has 
<code>w = 0.1</code>, the &quot;grand&quot; weight for men aged 0-4 is <code>0.5*0.1</code>).
The &quot;grand&quot; weights are then used for adjusting after ensuring they
sum to one.
</p>
<p>When using multiple adjusting variables, you
are allowed to pass either a named <code>list</code> of 
weights or a <code>data.frame</code> of weights. E.g.
</p>
<p><code>WL &lt;- list(agegroup = age_w, sex = sex_w)</code>
</p>
<p><code>FUN(weights = WL)</code>
</p>
<p>where <code>age_w</code> and <code>sex_w</code> are numeric vectors. Given the 
conditions explained in the previous section are satisfied, you may also do
e.g.
</p>
<p><code>WL &lt;- list(agegroup = "world_2000_18of", sex = sex_w)</code>
</p>
<p><code>FUN(weights = WL)</code>
</p>
<p>and the world standard pop is used as weights for the age groups as outlined
in the previous section.
</p>
<p>Sometimes using a <code>data.frame</code> can be clearer (and it is fool-proof
as well). To do this, form a <code>data.frame</code> that repeats the levels
of your adjusting variables by each level of every other adjusting variable,
and assign the weights as a column named <code>"weights"</code>. E.g.
</p>
<p><code>wdf &lt;- data.frame(sex = rep(0:1, each = 18), agegroup = rep(1:18, 2))</code>
</p>
<p><code>wdf$weights &lt;- rbinom(36, size = 100, prob = 0.25)</code>
</p>
<p><code>FUN(weights = wdf)</code>
</p>
<p>If you want to use the counts of subjects in strata as the weights,
one way to do this is by e.g.
</p>
<p><code>wdf &lt;- as.data.frame(x$V1, x$V2, x$V3)</code>
<code>names(wdf) &lt;- c("V1", "V2", "V3", "weights")</code>
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>References</h3>

<p>Source of the Nordic standard population in 5-year age groups 
(also contains European &amp; 1966 world standards):
<a href="https://www-dep.iarc.fr/NORDCAN/english/glossary.htm">https://www-dep.iarc.fr/NORDCAN/english/glossary.htm</a>
</p>
<p>Source of the 1976 European standard population: 
</p>
<p>Waterhouse, J.,Muir, C.S.,Correa, P.,Powell, J., eds (1976). 
Cancer Incidence in Five Continents, Vol. III. 
IARC Scientific Publications, No. 15, Lyon, IARC.
ISBN: 9789283211150
</p>
<p>Source of 2000 world standard population in 1-year age groups:
<a href="https://seer.cancer.gov/stdpopulations/stdpop.singleages.html">https://seer.cancer.gov/stdpopulations/stdpop.singleages.html</a>
</p>


<h3>See Also</h3>

<p>Other weights: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>
<p>Other popEpi argument evaluation docs: 
<code><a href="#topic+flexible_argument">flexible_argument</a></code>
</p>

<hr>
<h2 id='fac2num'>Convert factor variable to numeric</h2><span id='topic+fac2num'></span>

<h3>Description</h3>

<p>Convert factor variable with numbers as levels into a numeric variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac2num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fac2num_+3A_x">x</code></td>
<td>
<p>a factor variable with numbers as levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, a factor with levels <code>c("5","7")</code> is converted into 
a numeric variable with values <code>c(5,7)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector based on the levels of 'x'.
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/3418128/how-to-convert-a-factor-to-an-integer-numeric-without-a-loss-of-information">Stackoverflow thread</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robust_values">robust_values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this is often not intended
as.numeric(factor(c(5,7))) ## result: c(1,2)
## but this
fac2num(factor(c(5,7))) ## result: c(5,7)

## however
as.numeric(factor(c("5","7","a"))) ## 1:3

suppressWarnings(
  fac2num(factor(c("5","7","a"))) ## c(5,7,NA)
)


</code></pre>

<hr>
<h2 id='flexible_argument'>Flexible Variable Usage in <span class="pkg">popEpi</span> Functions</h2><span id='topic+flexible_argument'></span>

<h3>Description</h3>

<p>Certain arguments in <span class="pkg">popEpi</span> can be passed in multiple 
ways. This document shows the usage and a pitfall in the
usage of such flexible arguments.
</p>


<h3>Details</h3>

<p>Flexible arguments in <span class="pkg">popEpi</span> are used to pass variables existing
in your data or in the environment where the function is used 
(for everyday users this is the global environment - in simple terms,
where your data is / your work space). The flexible arguments
are modelled after the <code>by</code> argument in <code>data.tables</code> - 
see <code>?data.table</code>. There are many ways to supply the same information
to certain functions in <span class="pkg">popEpi</span>, but the possible ways listed below
may be limited in some of them to only allow for using only a part of them.
</p>


<h3>Everyday usage</h3>

<p>Most commonly you may pass
variable names as character strings, e.g.
</p>
<p><code>FUN(arg = c("V1", "V2"), data = x)</code>
</p>
<p>which may be stored in advance:
</p>
<p><code>vars &lt;- c("V1", "V2")</code>
</p>
<p><code>FUN(arg = vars, data = x)</code>
</p>
<p>where <code>x</code> contains those variables. You may also supply variable
names as symbols:
</p>
<p><code>FUN(arg = V1, data = x)</code>
</p>
<p>Or as a list of symbols (similarly to as in <code><a href="stats.html#topic+aggregate">aggregate</a></code>):
</p>
<p><code>FUN(arg = list(V1, V2), data = x)</code>
</p>
<p>Or as a list of expressions:
</p>
<p><code>FUN(arg = list(V1 + 1, factor(V2)), data = x)</code>
</p>
<p>A formula without a left-hand-side specified is sometimes allowed as well:
</p>
<p><code>FUN(arg = ~ I(V1 + 1) + factor(V2), data = x)</code>
</p>
<p>Using a symbol or a list of symbols/expressions typically
causes the function to look for the variable(s)
first in the supplied data (if any) and then where the function was called.
For everyday users this means you might define e.g.
</p>
<p><code>V3 &lt;- factor(letters)</code>
</p>
<p>and do e.g.
</p>
<p><code>FUN(arg = list(V1 + 1, factor(V2), V3), data = x)</code>
</p>
<p>provided <code>V1</code> and <code>V2</code> exist in <code>x</code> or in the function calling
environment.
</p>


<h3>A pitfall</h3>

<p>There is one way to use flexible arguments incorrectly: By supplying
the name of a variable which exists both in the supplied data
and the calling environment, and intending the latter to be used. E.g.
</p>
<p><code>vars &lt;- c("V2")</code>
</p>
<p><code>FUN(arg = V3, data = x)</code>
</p>
<p>where <code>x</code> has a column named <code>vars</code>. This causes the function to
use <code>x$vars</code> and NOT <code>x$V2</code>.
</p>


<h3>Advanced</h3>

<p>Function programmers are advised to pass character strings
whenever possible. To fool-proof against conflicts as described in the
section above, refer to the calling environment explicitly when
passing the variable containing the character strings:
</p>
<p><code>TF &lt;- environment() ## current env to refer to</code>
</p>
<p><code>vars &lt;- c("V1", "V2")</code>
</p>
<p><code>FUN(arg = TF$vars, data = x)</code>
</p>
<p>Even if <code>x</code> has columns named <code>vars</code> and <code>TF</code>, 
using <code>TF$vars</code> does not use those columns but only evaluates
<code>TF$vars</code>
in the calling environment. This is made possible by the fact
that data is always passed as a <code>data.frame</code>, within which evaluation
of expressions using the dollar operator is not possible. Therefore
it is safe to assume the data should not be used. However, lists of 
expressions will not be checked for dollar use and will fail in conflict
situations:
</p>
<p><code>TF &lt;- environment() ## current env to refer to</code>
</p>
<p><code>vars &lt;- letters[1:5]</code>
</p>
<p><code>x &lt;- data.frame(vars = 1:5, TF = 5:1, V1 = 10:6)</code>
</p>
<p><code>FUN(arg = list(TF$vars, V1), data = x)</code>
</p>
<p>On the other hand you may typically also pass quoted (<code><a href="base.html#topic+quote">quote</a></code>)
or substituted <code><a href="base.html#topic+substitute">substitute</a></code> expressions etc., where
the <code>env$object</code> trick will work as well:
</p>
<p><code>q &lt;- quote(list(vars, V1))</code>
</p>
<p><code>FUN(arg = TF$q, data = x)</code>
</p>
<p>This works even with
</p>
<p><code>a &lt;- 1:5</code>
</p>
<p><code>V1 &lt;- quote(TF$a)</code>
</p>
<p><code>FUN(arg = TF$V1, data = x)</code>
</p>
<p>So no conflicts should occur.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other popEpi argument evaluation docs: 
<code><a href="#topic+direct_standardization">direct_standardization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sire)
## prepare data for e.g. 5-year "period analysis" for 2008-2012
## note: sire is a simulated cohort integrated into popEpi.
BL &lt;- list(fot=seq(0, 5, by = 1/12))
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date, exit = ex_date,
             status = status %in% 1:2,
             breaks = BL)
              
x &lt;- aggre(x, by = fot)

## silly example of referring to pyrs data by fixed character string;
## its possible that the real name wont be fixed in a real-life application.
pyrs &lt;- "actual_pyrs"  
TF &lt;- environment()
x$actual_pyrs &lt;- as.numeric(x$pyrs)
x$pyrs &lt;- 1
             
## this works (uses actual_pyrs eventually)
st &lt;- survtab_ag(fot ~ 1, data = x, surv.type = "surv.obs",
                 pyrs = TF$pyrs, d = from0to1, 
                 surv.method = "hazard")
## this would be wrong (sees expression 'pyrs' and uses that column,
## which is not what is intended here)
st &lt;- survtab_ag(fot ~ 1, data = x, surv.type = "surv.obs",
                 pyrs = pyrs, d = from0to1,
                 surv.method = "hazard")
</code></pre>

<hr>
<h2 id='get.yrs'>Convert date objects to fractional years</h2><span id='topic+get.yrs'></span>

<h3>Description</h3>

<p>Using Date objects, calculates given 
dates as fractional years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.yrs(x, year.length = "approx", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.yrs_+3A_x">x</code></td>
<td>
<p>a <code>Date</code> object, or anything that <code>link{as.Date}</code>
accepts</p>
</td></tr>
<tr><td><code id="get.yrs_+3A_year.length">year.length</code></td>
<td>
<p>character string, either <code>'actual'</code> or 
<code>'approx'</code>; can be abbreviated; see Details</p>
</td></tr>
<tr><td><code id="get.yrs_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="base.html#topic+as.Date">as.Date</a></code>;
typically <code>format</code> when <code>x</code> is a character string variable,
and <code>origin</code> when <code>x</code> is numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> should preferably be a <code>date</code>, <code>Date</code> or <code>IDate</code> 
object, although it can also be a character string variable 
which is coerced internally to <code>Date</code> format 
using <code><a href="base.html#topic+as.Date.character">as.Date.character</a></code>.
</p>
<p>When <code> year.length = 'actual' </code>, fractional years are calculated as 
<code> year + (day_in_year-1)/365 </code> for non-leap-years
and as <code> year + (day_in_year-1)/366 </code> for leap years. 
If <code> year.length = 'approx' </code>, fractional years are always
calculated as in <code> year + (day_in_year-1)/365.242199 </code>. 
</p>
<p>There is a slight difference, then, between the two methods
when calculating durations between fractional years. For
meticulous accuracy one might instead want to calculate durations using
dates (days) and convert the results to fractional years.
</p>
<p>Note that dates are effectively converted to fractional years at 
<code> 00:00:01 </code> o'clock:
</p>
<p><code> get.yrs("2000-01-01") = 2000 </code>, and
<code> get.yrs("2000-01-02") = 2000 + 1/365.242199 </code>.
</p>


<h3>Value</h3>

<p>A numeric vector of fractional years.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="Epi.html#topic+cal.yr">cal.yr</a></code>, <code><a href="#topic+as.Date.yrs">as.Date.yrs</a></code>, <code><a href="base.html#topic+as.Date">as.Date</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sire")
sire$dg_yrs &lt;- get.yrs(sire$dg_date)
summary(sire$dg_yrs)

## see: ?as.Date.yrs
dg_date2 &lt;- as.Date(sire$dg_yrs)
summary(as.numeric(dg_date2 - as.Date(sire$dg_date)))

## Epi's cal.yr versus get.yrs
d &lt;- as.Date("2000-01-01")
Epi::cal.yr(d) ## 1999.999
get.yrs(d) ## 2000

## "..." passed on to as.Date, so character / numeric also accepted as input
## (and whatever else as.Date accepts)
get.yrs("2000-06-01")
get.yrs("20000601", format = "%Y%m%d")
get.yrs("1/6/00", format = "%d/%m/%y")

get.yrs(100, origin = "1970-01-01")


</code></pre>

<hr>
<h2 id='ICSS'>Age standardisation weights from the ICSS scheme.</h2><span id='topic+ICSS'></span>

<h3>Description</h3>

<p>Contains three sets age-standardisation weights for age-standardized survival (net, relative or observed).
</p>


<h3>Format</h3>

<p>data.table with columns
</p>

<ul>
<li><p> age - lower bound of the age group
</p>
</li>
<li><p> ICSS1 - first set of weights, sums to 100 000
</p>
</li>
<li><p> ICSS2 - second set of weights, sums to 100 000
</p>
</li>
<li><p> ICSS3 - third set of weights, sums to 100 000
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://seer.cancer.gov/stdpopulations/survival.html">ICSS weights (US National Cancer Institute website)</a>
</p>
<p>Corazziari, Isabella, Mike Quinn, and Riccardo Capocaccia. &quot;Standard cancer patient population for age standardising survival ratios.&quot; European Journal of Cancer 40.15 (2004): 2307-2316.
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>
<p>Other weights: 
<code><a href="#topic+direct_standardization">direct_standardization</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## aggregate weights to a subset of age groups
data(ICSS)
cut &lt;- c(0, 30, 50, 70, Inf)
agegr &lt;- cut(ICSS$age, cut, right = FALSE)
aggregate(ICSS1~agegr, data = ICSS, FUN = sum)
</code></pre>

<hr>
<h2 id='is_leap_year'>Detect leap years</h2><span id='topic+is_leap_year'></span>

<h3>Description</h3>

<p>Given a vector or column of year values (numeric or integer), <code><a href="#topic+is_leap_year">is_leap_year</a></code> returns a vector of equal length
of logical indicators, i.e. a vector where corresponding leap years have value TRUE, and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_leap_year(years)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_leap_year_+3A_years">years</code></td>
<td>
<p>a vector or column of year values (numeric or integer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' vector where 'TRUE' indicates a leap year.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## can be used to assign new columns easily, e.g. a dummy indicator column
df &lt;- data.frame(yrs=c(1900,1904,2005,1995))
df$lyd &lt;- as.integer(is_leap_year(df$yrs))

## mostly it is useful as a condition or to indicate which rows have leap years
which(is_leap_year(df$yrs)) # 2
df[is_leap_year(df$yrs),] # 2nd row

</code></pre>

<hr>
<h2 id='is.Date'>Test if object is a <code>Date</code> object</h2><span id='topic+is.Date'></span>

<h3>Description</h3>

<p>Tests if an object is a <code>Date</code> object and returns
a logical vector of length 1. <code>IDate</code> objects are also 
<code>Date</code> objects, but <code>date</code> objects from package <span class="pkg">date</span>
are not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Date(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Date_+3A_obj">obj</code></td>
<td>
<p>object to test on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'TRUE' if 'obj' is of class '&quot;Date&quot;' or '&quot;IDate&quot;'.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.yrs">get.yrs</a></code>, <code><a href="#topic+is_leap_year">is_leap_year</a></code>, <code><a href="base.html#topic+as.Date">as.Date</a></code>
</p>

<hr>
<h2 id='Lexis_fpa'>Create a Lexis Object with Follow-up Time, Period, and Age
Time Scales</h2><span id='topic+Lexis_fpa'></span>

<h3>Description</h3>

<p>This is a simple wrapper around <code><a href="Epi.html#topic+Lexis">Lexis</a></code> for creating
a <code>Lexis</code> object with the time scales <code>fot</code>, <code>per</code>,
and <code>age</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lexis_fpa(
  data,
  birth = NULL,
  entry = NULL,
  exit = NULL,
  entry.status = NULL,
  exit.status = NULL,
  subset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lexis_fpa_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code>; mandatory</p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_birth">birth</code></td>
<td>
<p>the time of birth; A character string naming the variable in 
data or an expression to evaluate - see 
<a href="#topic+flexible_argument">Flexible input</a></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_entry">entry</code></td>
<td>
<p>the time at entry to follow-up; supplied the 
same way as <code>birth</code></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_exit">exit</code></td>
<td>
<p>the time at exit from follow-up; supplied the 
same way as <code>birth</code></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_entry.status">entry.status</code></td>
<td>
<p>passed on to <code><a href="Epi.html#topic+Lexis">Lexis</a></code> if not <code>NULL</code>;
supplied the same way as <code>birth</code></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_exit.status">exit.status</code></td>
<td>
<p>passed on to <code><a href="Epi.html#topic+Lexis">Lexis</a></code> if not <code>NULL</code>;
supplied the same way as <code>birth</code></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset by before passing data
and arguments to <code><a href="Epi.html#topic+Lexis">Lexis</a></code></p>
</td></tr>
<tr><td><code id="Lexis_fpa_+3A_...">...</code></td>
<td>
<p>additional optional arguments passed on to 
<code><a href="Epi.html#topic+Lexis">Lexis</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Lexis</code> object with the usual columns that <code>Lexis</code> objects
have, with time scale columns <code>fot</code>, <code>per</code>, and <code>age</code>.
They are calculated as
</p>
<p><code>fot = entry - entry</code> (to ensure correct format, e.g. difftime)
</p>
<p><code>per = entry</code>
</p>
<p>and 
</p>
<p><code>age = entry - birth</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sire", package = "popEpi")

lex &lt;- Lexis_fpa(sire, 
                 birth = "bi_date", 
                 entry = dg_date, 
                 exit = ex_date + 1L,
                 exit.status = "status")

## some special cases
myVar &lt;- "bi_date"
l &lt;- list(myVar = "bi_date")
sire$l &lt;- sire$myVar &lt;- 1

## conflict: myVar taken from data when "bi_date" was intended
lex &lt;- Lexis_fpa(sire, 
                 birth = myVar, 
                 entry = dg_date, 
                 exit = ex_date + 1L,
                 exit.status = "status")

## no conflict with names in data
lex &lt;- Lexis_fpa(sire, 
                 birth = l$myVar, 
                 entry = dg_date, 
                 exit = ex_date + 1L,
                 exit.status = "status")
</code></pre>

<hr>
<h2 id='lexpand'>Split case-level observations</h2><span id='topic+lexpand'></span>

<h3>Description</h3>

<p>Given subject-level data, data is split 
by calendar time (<code>per</code>), <code>age</code>, and follow-up
time (<code>fot</code>, from 0 to the end of follow-up) 
into subject-time-interval rows according to 
given <code>breaks</code> and additionally processed if requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lexpand(
  data,
  birth = NULL,
  entry = NULL,
  exit = NULL,
  event = NULL,
  status = status != 0,
  entry.status = NULL,
  breaks = list(fot = c(0, Inf)),
  id = NULL,
  overlapping = TRUE,
  aggre = NULL,
  aggre.type = c("unique", "cartesian"),
  drop = TRUE,
  pophaz = NULL,
  pp = TRUE,
  subset = NULL,
  merge = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lexpand_+3A_data">data</code></td>
<td>
<p>dataset of e.g. cancer cases as rows</p>
</td></tr>
<tr><td><code id="lexpand_+3A_birth">birth</code></td>
<td>
<p>birth time in date format 
or fractional years; string, symbol or expression</p>
</td></tr>
<tr><td><code id="lexpand_+3A_entry">entry</code></td>
<td>
<p>entry time in date format 
or fractional years; string, symbol or expression</p>
</td></tr>
<tr><td><code id="lexpand_+3A_exit">exit</code></td>
<td>
<p>exit from follow-up time in date 
format or fractional years; string, symbol or expression</p>
</td></tr>
<tr><td><code id="lexpand_+3A_event">event</code></td>
<td>
<p>advanced: time of possible event differing from <code>exit</code>;
typically only used in certain SIR/SMR calculations - see Details; 
string, symbol or expression</p>
</td></tr>
<tr><td><code id="lexpand_+3A_status">status</code></td>
<td>
<p>variable indicating type of event at <code>exit</code> or <code>event</code>; 
e.g. <code>status = status != 0</code>; expression or quoted variable name</p>
</td></tr>
<tr><td><code id="lexpand_+3A_entry.status">entry.status</code></td>
<td>
<p>input in the same way as <code>status</code>; 
status at <code>entry</code>; see Details</p>
</td></tr>
<tr><td><code id="lexpand_+3A_breaks">breaks</code></td>
<td>
<p>a named list of vectors of time breaks; 
e.g. <code>breaks = list(fot=0:5, age=c(0,45,65,Inf))</code>; see Details</p>
</td></tr>
<tr><td><code id="lexpand_+3A_id">id</code></td>
<td>
<p>optional; an id variable; e.g. <code>id = my_id</code>;
string, symbol or expression</p>
</td></tr>
<tr><td><code id="lexpand_+3A_overlapping">overlapping</code></td>
<td>
<p>advanced, logical; if <code>FALSE</code> AND if <code>data</code> contains
multiple rows per subject, 
ensures that the timelines of <code>id</code>-specific rows do not overlap;
this ensures e.g. that person-years are only computed once per subject 
in a multi-state paradigm</p>
</td></tr>
<tr><td><code id="lexpand_+3A_aggre">aggre</code></td>
<td>
<p>e.g. <code>aggre = list(sex, fot)</code>; 
a list of unquoted variables and/or expressions thereof,
which are interpreted as factors; data events and person-years will
be aggregated by the unique combinations of these; see Details</p>
</td></tr>
<tr><td><code id="lexpand_+3A_aggre.type">aggre.type</code></td>
<td>
<p>one of <code>c("unique","cartesian")</code>;
can be abbreviated; see Details</p>
</td></tr>
<tr><td><code id="lexpand_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops all resulting rows 
after splitting that reside outside
the time window as defined by the given breaks (all time scales)</p>
</td></tr>
<tr><td><code id="lexpand_+3A_pophaz">pophaz</code></td>
<td>
<p>a dataset of population hazards to merge
with split data; see Details</p>
</td></tr>
<tr><td><code id="lexpand_+3A_pp">pp</code></td>
<td>
<p>logical; if <code>TRUE</code>, computes Pohar-Perme weights using
<code>pophaz</code>; adds variable with reserved name <code>pp</code>; 
see Details for computing method</p>
</td></tr>
<tr><td><code id="lexpand_+3A_subset">subset</code></td>
<td>
<p>a logical vector or any logical condition; data is subsetted
before splitting accordingly</p>
</td></tr>
<tr><td><code id="lexpand_+3A_merge">merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, retains all 
original variables from the data</p>
</td></tr>
<tr><td><code id="lexpand_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty and 
returns some messages along the way</p>
</td></tr>
<tr><td><code id="lexpand_+3A_...">...</code></td>
<td>
<p>e.g. <code>fot = 0:5</code>; instead of specifying a <code>breaks</code> list, 
correctly named breaks vectors can be given 
for <code>fot</code>, <code>age</code>, and <code>per</code>; these override any breaks in the
<code>breaks</code> list; see Examples</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Basics</strong>
</p>
<p><code><a href="#topic+lexpand">lexpand</a></code> splits a given data set (with e.g. cancer diagnoses 
as rows) to subintervals of time over 
calendar time, age, and follow-up time with given time breaks 
using <code><a href="#topic+splitMulti">splitMulti</a></code>.
</p>
<p>The dataset must contain appropriate 
<code>Date</code> / <code>IDate</code> / <code>date</code> format or
other numeric variables that can be used
as the time variables.
</p>
<p>You may take a look at a simulated cohort 
<code><a href="#topic+sire">sire</a></code> as an example of the
minimum required information for processing data with <code>lexpand</code>.
</p>
<p>Many arguments can be supplied as a character string naming the appropriate
variable (e.g. <code>"sex"</code>), as a symbol (e.g. <code>sex</code>) or as an expression
(e.g. <code>factor(sex, 0:1, c("m", "f"))</code>) for flexibility.
</p>
<p><strong>Breaks</strong>
</p>
<p>You should define all breaks as left inclusive and right exclusive 
time points (e.g.<code>[a,b)</code> )
for 1-3 time dimensions so that the last member of a breaks vector
is a meaningful &quot;final upper limit&quot;,
e.g. <code>per = c(2002,2007,2012)</code> 
to create a last subinterval of the form <code>[2007,2012)</code>. 
</p>
<p>All breaks are explicit, i.e. if <code>drop = TRUE</code>,
any data beyond the outermost breaks points are dropped. 
If one wants to have unspecified upper / lower limits on one time scale,
use <code>Inf</code>: e.g. <code>breaks = list(fot = 0:5, age = c(0,45,Inf))</code>.
Breaks for <code>per</code> can also be given in 
<code>Date</code>/<code>IDate</code>/<code>date</code> format, whereupon
they are converted to fractional years before used in splitting.
</p>
<p>The <code>age</code> time scale can additionally 
be automatically split into common age grouping schemes
by naming the scheme with an appropriate character string:
</p>

<ul>
<li> <p><code>"18of5"</code>: age groups 0-4, 5-9, 10-14, ..., 75-79, 80-84, 85+
</p>
</li>
<li> <p><code>"20of5"</code>: age groups 0-4, 5-9, 10-14, ..., 85-89, 90-94, 95+
</p>
</li>
<li> <p><code>"101of1"</code>: age groups 0, 1, 2, ..., 98, 99, 100+
</p>
</li></ul>

<p><strong>Time variables</strong>
</p>
<p>If any of the given time variables
(<code>birth</code>, <code>entry</code>, <code>exit</code>, <code>event</code>)
is in any kind of date format, they are first coerced to 
fractional years before splitting
using <code><a href="#topic+get.yrs">get.yrs</a></code> (with <code>year.length = "actual"</code>).
</p>
<p>Sometimes in e.g. SIR/SMR calculation one may want the event time to differ
from the time of exit from follow-up, if the subject is still considered
to be at risk of the event. If <code>event</code> is specified, the transition to
<code>status</code> is moved to <code>event</code> from <code>exit</code> 
using <code><a href="Epi.html#topic+cutLexis">cutLexis</a></code>. See Examples.
</p>
<p><strong>The status variable</strong>
</p>
<p>The statuses in the expanded output (<code>lex.Cst</code> and <code>lex.Xst</code>)
are determined by using either only <code>status</code> or both <code>status</code>
and <code>entry.status</code>. If <code>entry.status = NULL</code>, the status at entry
is guessed according to the type of variable supplied via <code>status</code>:
For numeric variables it will be zero, for factors the first level
(<code>levels(status)[1]</code>) and otherwise the first unique value in alphabetical
order (<code>sort(unique(status))[1]</code>). 
</p>
<p>Using numeric or factor status
variables is strongly recommended. Logical expressions are also allowed
(e.g. <code>status = my_status != 0L</code>) and are converted to integer internally.
</p>
<p><strong>Merging population hazard information</strong>
</p>
<p>To enable computing relative/net survivals with <code><a href="#topic+survtab">survtab</a></code>
and <code><a href="#topic+relpois">relpois</a></code>, <code>lexpand</code> merges an appropriate
population hazard data (<code>pophaz</code>) to the expanded data 
before dropping rows outside the specified
time window (if <code>drop = TRUE</code>). <code>pophaz</code> must, for this reason, 
contain at a minimum the variables named
<code>agegroup</code>, <code>year</code>, and <code>haz</code>. <code>pophaz</code> may contain additional variables to specify
different population hazard levels in different strata; e.g. <code>popmort</code> includes <code>sex</code>.
All the strata-defining variables must be present in the supplied <code>data</code>. <code>lexpand</code> will
automatically detect variables with common names in the two datasets and merge using them.
</p>
<p>Currently <code>year</code> must be an integer variable specifying the appropriate year. <code>agegroup</code>
must currently also specify one-year age groups, e.g. <code>popmort</code> specifies 101 age groups
of length 1 year. In both
<code>year</code> and <code>agegroup</code> variables the values are interpreted as the lower bounds of intervals
(and passed on to a <code>cut</code> call). The mandatory variable <code>haz</code>
must specify the appropriate average rate at the person-year level;
e.g. <code>haz = -log(survProb)</code> where <code>survProb</code> is a one-year conditional
survival probability will be the correct hazard specification. 
</p>
<p>The corresponding <code>pophaz</code> population hazard value is merged by using the mid points
of the records after splitting as reference values. E.g. if <code>age=89.9</code> at the start
of a 1-year interval, then the reference age value is <code>90.4</code> for merging. 
This way we get a &quot;typical&quot; population hazard level for each record.
</p>
<p><strong>Computing Pohar-Perme weights</strong>
</p>
<p>If <code>pp = TRUE</code>, Pohar-Perme weights 
(the inverse of cumulative population survival) are computed. This will
create the new <code>pp</code> variable in the expanded data. <code>pp</code> is a
reserved name and <code>lexpand</code> throws exception if a variable with that name
exists in <code>data</code>.
</p>
<p>When a survival interval contains one or several rows per subject
(e.g. due to splitting by the <code>per</code> scale),
<code>pp</code> is cumulated from the beginning of the first record in a survival
interval for each subject to the mid-point of the remaining time within that
survival interval, and  that value is given for every other record 
that a given person has within the same survival interval. 
</p>
<p>E.g. with 5 rows of duration <code>1/5</code> within a survival interval 
<code>[0,1)]</code>, <code>pp</code> is determined for all records by a cumulative 
population survival from <code>0</code> to <code>0.5</code>. The existing accuracy is used,
so that the weight is cumulated first up to the end of the second row
and then over the remaining distance to the mid-point (first to 0.4, then to
0.5). This ensures that more accurately merged population hazards are fully
used.
</p>
<p><strong>Event not at end of follow-up &amp; overlapping time lines</strong>
</p>
<p><code>event</code> may be used if the event indicated by <code>status</code> should
occur at a time differing from <code>exit</code>. If <code>event</code> is defined,
<code>cutLexis</code> is used on the data set after coercing it to the <code>Lexis</code>
format and before splitting. Note that some values of <code>event</code> are allowed
to be <code>NA</code> as with <code>cutLexis</code> to accommodate observations
without an event occurring.
</p>
<p>Additionally, setting <code>overlapping = FALSE</code> ensures that (irrespective
of using <code>event</code>) the each subject defined by <code>id</code> only has one
continuous time line instead of possibly overlapping time lines if
there are multiple rows in <code>data</code> by <code>id</code>.
</p>
<p><strong>Aggregating</strong>
</p>
<p>Certain analyses such as SIR/SMR calculations require tables of events and
person-years by the unique combinations (interactions) of several variables. 
For this, <code>aggre</code> can be specified as a list of such variables 
(preferably <code>factor</code> variables but not mandatory)
and any arbitrary functions of the 
variables at one's disposal. E.g. 
</p>
<p><code>aggre = list(sex, agegr = cut(dg_age, 0:100))</code>
</p>
<p>would tabulate events and person-years by sex and an ad-hoc age group
variable. Every ad-hoc-created variable should be named.
</p>
<p><code>fot</code>, <code>per</code>, and <code>age</code> are special reserved variables which,
when present in the <code>aggre</code> list, are output as categories of the
corresponding time scale variables by using 
e.g. 
</p>
<p><code>cut(fot, breaks$fot, right=FALSE)</code>. 
</p>
<p>This only works if
the corresponding breaks are defined in <code>breaks</code> or via &quot;<code>...</code>&quot;.
E.g. 
</p>
<p><code>aggre = list(sex, fot.int = fot)</code> with 
</p>
<p><code>breaks = list(fot=0:5)</code>.
</p>
<p>The output variable <code>fot.int</code> in the above example will have
the lower limits of the appropriate intervals as values.
</p>
<p><code>aggre</code> as a named list will output numbers of events and person-years
with the given new names as categorizing variable names, e.g. 
<code>aggre = list(follow_up = fot, gender = sex, agegroup = age)</code>.
</p>
<p>The output table has person-years (<code>pyrs</code>) and event counts
(e.g. <code>from0to1</code>) as columns. Event counts are the numbers of transitions
(<code>lex.Cst != lex.Xst</code>) or the <code>lex.Xst</code> value at a subject's 
last record (subject possibly defined by <code>id</code>).
</p>
<p>If <code>aggre.type = "unique"</code> (alias <code>"non-empty"</code>), 
the above results are computed for existing
combinations of expressions given in <code>aggre</code>, but also for non-existing
combinations if <code>aggre.type = "cartesian"</code> (alias <code>"full"</code>). E.g. if a
factor variable has levels <code>"a", "b", "c"</code> but the data is limited
to only have levels <code>"a", "b"</code> present 
(more than zero rows have these level values), the former setting only
computes results for <code>"a", "b"</code>, and the latter also for <code>"c"</code>
and any combination with other variables or expression given in <code>aggre</code>.
In essence, <code>"cartesian"</code> forces also combinations of variables used
in <code>aggre</code> that have no match in data to be shown in the result.
</p>
<p>If <code>aggre</code> is not <code>NULL</code> and <code>pophaz</code> has been supplied,
<code>lexpand</code> also aggregates the expected counts of events, which
appears in the output data by the reserved name <code>d.exp</code>. Additionally,
having <code>pp = TRUE</code> causes <code>lexpand</code> to also compute various
Pohar-Perme weighted figures necessary for computing Pohar-Perme net survivals
with <code><a href="#topic+survtab_ag">survtab_ag</a></code>. This can be slow, so consider what is really
needed. The Pohar-Perme weighted figures have the suffix <code>.pp</code>.
</p>


<h3>Value</h3>

<p>If <code>aggre = NULL</code>, returns 
a <code>data.table</code> or <code>data.frame</code> 
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>) 
object expanded to accommodate split observations with time scales as
fractional years and <code>pophaz</code> merged in if given. Population
hazard levels in new variable <code>pop.haz</code>, and Pohar-Perme
weights as new variable <code>pp</code> if requested.
</p>
<p>If <code>aggre</code> is defined, returns a long-format 
<code>data.table</code>/<code>data.frame</code> with the variable <code>pyrs</code> (person-years),
and variables for the counts of transitions in state or state at end of 
follow-up formatted <code>fromXtoY</code>, where <code>X</code> and <code>Y</code> are 
the states transitioned from and to, respectively. The data may also have
the columns <code>d.exp</code> for expected numbers of cases and various
Pohar-Perme weighted figures as identified by the suffix <code>.pp</code>; see 
Details.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="Epi.html#topic+Lexis">Lexis</a></code>, <code><a href="#topic+popmort">popmort</a></code>
</p>
<p>Other splitting functions: 
<code><a href="#topic+splitLexisDT">splitLexisDT</a>()</code>,
<code><a href="#topic+splitMulti">splitMulti</a>()</code>
</p>
<p>Other aggregation functions: 
<code><a href="#topic+aggre">aggre</a>()</code>,
<code><a href="#topic+as.aggre">as.aggre</a>()</code>,
<code><a href="#topic+setaggre">setaggre</a>()</code>,
<code><a href="#topic+summary.aggre">summary.aggre</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## prepare data for e.g. 5-year cohort survival calculation
x &lt;- lexpand(sire, breaks=list(fot=seq(0, 5, by = 1/12)), 
             birth = bi_date, entry = dg_date, exit = ex_date,
             status =  status != 0, pophaz=popmort)

## prepare data for e.g. 5-year "period analysis" for 2008-2012
BL &lt;- list(fot = seq(0, 5, by = 1/12), per = c("2008-01-01", "2013-01-01"))
x &lt;- lexpand(sire, breaks = BL, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             pophaz=popmort, status =  status != 0)

## aggregating
BL &lt;- list(fot = 0:5, per = c("2003-01-01","2008-01-01", "2013-01-01"))
ag &lt;- lexpand(sire, breaks = BL, status = status != 0, 
             birth = bi_date, entry = dg_date, exit = ex_date,
              aggre=list(sex, period = per, surv.int = fot))

## aggregating even more
ag &lt;- lexpand(sire, breaks = BL, status = status != 0, 
              birth = bi_date, entry = dg_date, exit = ex_date,
              aggre=list(sex, period = per, surv.int = fot),
              pophaz = popmort, pp = TRUE)

## using "..."
x &lt;- lexpand(sire, fot=0:5, status =  status != 0,
             birth = bi_date, entry = dg_date, exit = ex_date,
             pophaz=popmort) 

x &lt;- lexpand(sire, fot=0:5, status =  status != 0, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             aggre=list(sex, surv.int = fot))
             
## using the "event" argument: it just places the transition to given "status"
## at the "event" time instead of at the end, if possible using cutLexis
x &lt;- lexpand(sire, status = status, event = dg_date,
             birth = bi_date, entry = dg_date, exit = ex_date,) 

## aggregating with custom "event" time
## (the transition to status is moved to the "event" time)
x &lt;- lexpand(sire, status = status, event = dg_date, 
             birth = bi_date, entry = dg_date, exit = ex_date,
             per = 1970:2014, age = c(0:100,Inf),
             aggre = list(sex, year = per, agegroup = age)) 



</code></pre>

<hr>
<h2 id='lines.sirspline'>lines method for sirspline-object</h2><span id='topic+lines.sirspline'></span>

<h3>Description</h3>

<p>Plot SIR spline lines with R base graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sirspline'
lines(x, conf.int = TRUE, print.levels = NA, select.spline, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.sirspline_+3A_x">x</code></td>
<td>
<p>an object returned by function sirspline</p>
</td></tr>
<tr><td><code id="lines.sirspline_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; default TRUE draws also the 95 confidence intervals</p>
</td></tr>
<tr><td><code id="lines.sirspline_+3A_print.levels">print.levels</code></td>
<td>
<p>name(s) to be plotted. Default plots all levels.</p>
</td></tr>
<tr><td><code id="lines.sirspline_+3A_select.spline">select.spline</code></td>
<td>
<p>select which spline variable (a number or a name) is plotted.</p>
</td></tr>
<tr><td><code id="lines.sirspline_+3A_...">...</code></td>
<td>
<p>arguments passed on to lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>lines.sirspline</code> most of graphical parameters is user 
adjustable.
Desired spline variable can be selected with <code>select.spline</code> and only one
can be plotted at a time. The spline variable can include 
several levels, e.g. gender (these are the levels of <code>print</code>
from <code>sirspline</code>). All levels are printed by default, but a
specific level can be selected using argument
<code>print.levels</code>. Printing the levels separately enables  e.g. to
give different colours for each level.
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>See Also</h3>

<p>Other sir functions: 
<code><a href="#topic+plot.sirspline">plot.sirspline</a>()</code>,
<code><a href="#topic+sir_exp">sir_exp</a>()</code>,
<code><a href="#topic+sir_ratio">sir_ratio</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>
</p>

<hr>
<h2 id='lines.survmean'>Graphically Inspect Curves Used in Mean Survival Computation</h2><span id='topic+lines.survmean'></span>

<h3>Description</h3>

<p>Plots the observed (with extrapolation) and expected survival
curves for all strata in an object created by <code><a href="#topic+survmean">survmean</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survmean'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.survmean_+3A_x">x</code></td>
<td>
<p>a <code>survmean</code> object</p>
</td></tr>
<tr><td><code id="lines.survmean_+3A_...">...</code></td>
<td>
<p>arguments passed (ultimately) to <code>matlines</code>; you
may, therefore, supply e.g. <code>lwd</code> through this, though arguments
such as <code>lty</code> and <code>col</code> will not work</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be a workhorse for <code><a href="#topic+plot.survmean">plot.survmean</a></code>.
If you want finer control over the plotted curves, extract the curves from
the <code>survmean</code> output using 
</p>
<p><code>attr(x, "curves")</code>
</p>
<p>where <code>x</code> is a <code>survmean</code> object.
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survmean functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+plot.survmean">plot.survmean</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>
</p>

<hr>
<h2 id='lines.survtab'><code>lines</code> method for survtab objects</h2><span id='topic+lines.survtab'></span>

<h3>Description</h3>

<p>Plot <code>lines</code> from a <code>survtab</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survtab'
lines(x, y = NULL, subset = NULL, conf.int = TRUE, col = NULL, lty = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.survtab_+3A_x">x</code></td>
<td>
<p>a <code>survtab</code> output object</p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_y">y</code></td>
<td>
<p>a variable to plot; a quoted name of a variable
in <code>x</code>; e.g. <code>y = "surv.obs"</code>;
if <code>NULL</code>, picks last survival variable column in order in <code>x</code></p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_subset">subset</code></td>
<td>
<p>a logical condition; <code>obj</code> is subset accordingly 
before plotting; use this for limiting to specific strata, 
e.g. <code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; if <code>TRUE</code>, also plots any confidence intervals
present in <code>obj</code> for variables in <code>y</code></p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_col">col</code></td>
<td>
<p>line colour passed to <code>matlines</code></p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_lty">lty</code></td>
<td>
<p>line type passed to <code>matlines</code></p>
</td></tr>
<tr><td><code id="lines.survtab_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to to a <code>matlines</code> call;
e.g. <code>lwd</code> can be defined this way</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sire)
data(sibr)
si &lt;- rbind(sire, sibr)
si$period &lt;- cut(si$dg_date, as.Date(c("1993-01-01", "2004-01-01", "2013-01-01")), right = FALSE)
si$cancer &lt;- c(rep("rectal", nrow(sire)), rep("breast", nrow(sibr)))
x &lt;- lexpand(si, birth = bi_date, entry = dg_date, exit = ex_date, 
             status = status %in% 1:2, 
             fot = 0:5, aggre = list(cancer, period, fot))
st &lt;- survtab_ag(fot ~ cancer + period, data = x, 
                 surv.method = "lifetable", surv.type = "surv.obs")

plot(st, "surv.obs", subset = cancer == "breast", ylim = c(0.5, 1), col = "blue")
lines(st, "surv.obs", subset = cancer == "rectal", col = "red")

## or
plot(st, "surv.obs", col = c(2,2,4,4), lty = c(1, 2, 1, 2))
</code></pre>

<hr>
<h2 id='lower_bound'>Return lower_bound value from char string (20,30]</h2><span id='topic+lower_bound'></span>

<h3>Description</h3>

<p>selects lowest values of each factor after cut() based
on that the value starts from index 2 and end in comma &quot;,&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower_bound(cut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower_bound_+3A_cut">cut</code></td>
<td>
<p>is a character vector of elements &quot;(20,60]&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>

<hr>
<h2 id='ltable'>Tabulate Counts and Other Functions by Multiple Variables into a 
Long-Format Table</h2><span id='topic+ltable'></span><span id='topic+expr.by.cj'></span>

<h3>Description</h3>

<p><code>ltable</code> makes use of <code>data.table</code> 
capabilities to tabulate frequencies or 
arbitrary functions of given variables into a long format 
<code>data.table</code>/<code>data.frame</code>. <code>expr.by.cj</code> is the 
equivalent for more advanced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltable(
  data,
  by.vars = NULL,
  expr = list(obs = .N),
  subset = NULL,
  use.levels = TRUE,
  na.rm = FALSE,
  robust = TRUE
)

expr.by.cj(
  data,
  by.vars = NULL,
  expr = list(obs = .N),
  subset = NULL,
  use.levels = FALSE,
  na.rm = FALSE,
  robust = FALSE,
  .SDcols = NULL,
  enclos = parent.frame(1L),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltable_+3A_data">data</code></td>
<td>
<p>a <code>data.table</code>/<code>data.frame</code></p>
</td></tr>
<tr><td><code id="ltable_+3A_by.vars">by.vars</code></td>
<td>
<p>names of variables that are used for categorization, 
as a character vector, e.g. <code>c('sex','agegroup')</code></p>
</td></tr>
<tr><td><code id="ltable_+3A_expr">expr</code></td>
<td>
<p>object or a list of objects where each object is a function 
of a variable (see: details)</p>
</td></tr>
<tr><td><code id="ltable_+3A_subset">subset</code></td>
<td>
<p>a logical condition; data is limited accordingly before
evaluating <code>expr</code> - but the result of <code>expr</code> is also
returned as <code>NA</code> for levels not existing in the subset. See Examples.</p>
</td></tr>
<tr><td><code id="ltable_+3A_use.levels">use.levels</code></td>
<td>
<p>logical; if <code>TRUE</code>, uses factor levels of given 
variables if present;  if you want e.g. counts for levels
that actually have zero observations but are levels in a factor variable, 
use this</p>
</td></tr>
<tr><td><code id="ltable_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops rows in table that have 
<code>NA</code> as values in any of <code>by.vars</code> columns</p>
</td></tr>
<tr><td><code id="ltable_+3A_robust">robust</code></td>
<td>
<p>logical; if <code>TRUE</code>, runs the output data's 
<code>by.vars</code> columns through <code>robust_values</code> before outputting</p>
</td></tr>
<tr><td><code id="ltable_+3A_.sdcols">.SDcols</code></td>
<td>
<p>advanced; a character vector of column names 
passed to inside the data.table's brackets 
<code>DT[, , ...]</code>; see <code><a href="data.table.html#topic+data.table">data.table</a></code>; if <code>NULL</code>,
uses all appropriate columns. See Examples for usage.</p>
</td></tr>
<tr><td><code id="ltable_+3A_enclos">enclos</code></td>
<td>
<p>advanced; an environment; the enclosing
environment of the data.</p>
</td></tr>
<tr><td><code id="ltable_+3A_...">...</code></td>
<td>
<p>advanced; other arguments passed to inside the 
data.table's brackets <code>DT[, , ...]</code>; see <code><a href="data.table.html#topic+data.table">data.table</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>expr</code> for each unique combination of given <code>by.vars</code>.
</p>
<p>By default makes use of any and all <code><a href="base.html#topic+levels">levels</a></code> present for 
each variable in  <code>by.vars</code>. This is useful,
because even if a subset of the data does not contain observations 
for e.g. a specific age group, those age groups are 
nevertheless presented in the resulting table; e.g. with the default 
<code>expr = list(obs = .N)</code> all age group levels
are represented by a row and can have  <code>obs = 0</code>.
</p>
<p>The function differs from the
vanilla <code><a href="base.html#topic+table">table</a></code> by giving a long format table of values
regardless of the number of <code>by.vars</code> given.
Make use of e.g. <code><a href="#topic+cast_simple">cast_simple</a></code> if data needs to be 
presented in a wide format (e.g. a two-way table).
</p>
<p>The rows of the long-format table are effectively Cartesian products 
of the levels of each variable in  <code>by.vars</code>,
e.g. with  <code>by.vars = c("sex", "area")</code> all levels of  
<code>area</code> are repeated for both levels of  <code>sex</code>
in the table.
</p>
<p>The <code>expr</code> allows the user to apply any function(s) on all 
levels defined by  <code>by.vars</code>. Here are some examples:
</p>

<ul>
<li><p> .N or list(.N) is a function used inside a <code>data.table</code> to 
calculate counts in each group
</p>
</li>
<li><p> list(obs = .N), same as above but user assigned variable name
</p>
</li>
<li><p> list(sum(obs), sum(pyrs), mean(dg_age)), multiple objects in a list
</p>
</li>
<li><p> list(obs = sum(obs), pyrs = sum(pyrs)), same as above with user 
defined variable names
</p>
</li></ul>

<p>If  <code>use.levels = FALSE</code>, no <code>levels</code> information will
be used. This means that if e.g. the  <code>agegroup</code>
variable is a factor and has 18 levels defined, but only 15 levels
are present in the data, no rows for the missing
levels will be shown in the table.
</p>
<p><code>na.rm</code> simply drops any rows from the resulting table where 
any of the  <code>by.vars</code> values was <code>NA</code>.
</p>


<h3>Value</h3>

<p>A 'data.table' of statistics (e.g. counts) stratified by the columns defined
in 'by.vars'.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>expr.by.cj()</code>: Somewhat more streamlined <code>ltable</code> with 
defaults for speed. Explicit determination of enclosing environment
of data.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Joonas Miettinen, Matti Rantanen
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="#topic+cast_simple">cast_simple</a></code>, <code><a href="data.table.html#topic+melt">melt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sire", package = "popEpi")
sr &lt;- sire
sr$agegroup &lt;- cut(sr$dg_age, breaks=c(0,45,60,75,85,Inf))
## counts by default
ltable(sr, "agegroup")

## any expression can be given
ltable(sr, "agegroup", list(mage = mean(dg_age)))
ltable(sr, "agegroup", list(mage = mean(dg_age), vage = var(dg_age)))

## also returns levels where there are zero rows (expressions as NA)
ltable(sr, "agegroup", list(obs = .N, 
                            minage = min(dg_age), 
                            maxage = max(dg_age)), 
       subset = dg_age &lt; 85)
       
#### expr.by.cj
expr.by.cj(sr, "agegroup")

## any arbitrary expression can be given
expr.by.cj(sr, "agegroup", list(mage = mean(dg_age)))
expr.by.cj(sr, "agegroup", list(mage = mean(dg_age), vage = var(dg_age)))

## only uses levels of by.vars present in data
expr.by.cj(sr, "agegroup", list(mage = mean(dg_age), vage = var(dg_age)), 
           subset = dg_age &lt; 70)
           
## .SDcols trick
expr.by.cj(sr, "agegroup", lapply(.SD, mean), 
           subset = dg_age &lt; 70, .SDcols = c("dg_age", "status"))
</code></pre>

<hr>
<h2 id='meanpop_fi'>Mean population counts in Finland year, sex, and age group.</h2><span id='topic+meanpop_fi'></span>

<h3>Description</h3>

<p>Mean population counts in Finland year, sex, and age group.
</p>


<h3>Format</h3>

<p><code>data.table</code> with columns
</p>

<ul>
<li> <p><code>sex</code> gender coded as male, female (0, 1)
</p>
</li>
<li> <p><code>year</code> calendar year 1981-2016
</p>
</li>
<li> <p><code>agegroup</code> - coded 0 to 100; one-year age groups
</p>
</li>
<li> <p><code>meanpop</code> the mean population count; that is, the mean of the
annual population counts of two consecutive years; e.g. for 1990 
<code>meanpop</code> is the mean of population counts for 1990 and 1991 
(counted at 1990-01-01 and 1991-01-01, respectively)
</p>
</li></ul>



<h3>Source</h3>

<p>Statistics Finland
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>

<hr>
<h2 id='na2zero'>Convert NA's to zero in data.table</h2><span id='topic+na2zero'></span>

<h3>Description</h3>

<p>Given a <code>data.table DT</code>, replaces any <code>NA</code> values
in the variables given in <code>vars</code> in <code>DT</code>. Takes a copy of the 
original data and returns the modified copy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na2zero(DT, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na2zero_+3A_dt">DT</code></td>
<td>
<p><code>data.table</code> object</p>
</td></tr>
<tr><td><code id="na2zero_+3A_vars">vars</code></td>
<td>
<p>a character string vector of variables names in <code>DT</code>;
if <code>NULL</code>, uses all variable names in <code>DT</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>data.table</code> object, converts <code>NA</code> values
to numeric (double) zeros for all variables named in <code>vars</code> or
all variables if <code>vars = NULL</code>.
</p>


<h3>Value</h3>

<p>A copy of 'DT' where 'NA' values have been replaced with zero.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>

<hr>
<h2 id='plot.rate'>plot method for rate object</h2><span id='topic+plot.rate'></span>

<h3>Description</h3>

<p>Plot rate estimates with confidence intervals lines using R base graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rate'
plot(x, conf.int = TRUE, eps = 0.2, left.margin, xlim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rate_+3A_x">x</code></td>
<td>
<p>a rate object (see <code><a href="#topic+rate">rate</a></code>)</p>
</td></tr>
<tr><td><code id="plot.rate_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; default TRUE draws the confidence intervals</p>
</td></tr>
<tr><td><code id="plot.rate_+3A_eps">eps</code></td>
<td>
<p>is the height of the ending of the error bars</p>
</td></tr>
<tr><td><code id="plot.rate_+3A_left.margin">left.margin</code></td>
<td>
<p>set a custom left margin for long variable names. Function
tries to do it by default.</p>
</td></tr>
<tr><td><code id="plot.rate_+3A_xlim">xlim</code></td>
<td>
<p>change the x-axis location</p>
</td></tr>
<tr><td><code id="plot.rate_+3A_...">...</code></td>
<td>
<p>arguments passed on to graphical functions points and segment 
(e.g. <code>col</code>, <code>lwd</code>, <code>pch</code> and <code>cex</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is limited explanatory tool but most graphical 
parameters are user adjustable.
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>

<hr>
<h2 id='plot.sir'>Plot method for sir-object</h2><span id='topic+plot.sir'></span>

<h3>Description</h3>

<p>Plot SIR estimates with error bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sir'
plot(
  x,
  conf.int = TRUE,
  ylab,
  xlab,
  xlim,
  main,
  eps = 0.2,
  abline = TRUE,
  log = FALSE,
  left.margin,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sir_+3A_x">x</code></td>
<td>
<p>an object returned by function <code>sir</code></p>
</td></tr>
<tr><td><code id="plot.sir_+3A_conf.int">conf.int</code></td>
<td>
<p>default TRUE draws confidence intervals</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_ylab">ylab</code></td>
<td>
<p>overwrites default y-axis label</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_xlab">xlab</code></td>
<td>
<p>overwrites default x-axis label</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_xlim">xlim</code></td>
<td>
<p>x-axis minimum and maximum values</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_main">main</code></td>
<td>
<p>optional plot title</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_eps">eps</code></td>
<td>
<p>error bar vertical bar height (works only in 'model' or 'univariate')</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_abline">abline</code></td>
<td>
<p>logical; draws a grey line in SIR = 1</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_log">log</code></td>
<td>
<p>logical; SIR is not in log scale by default</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_left.margin">left.margin</code></td>
<td>
<p>adjust left marginal of the plot to fit long variable names</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_...">...</code></td>
<td>
<p>arguments passed on to plot(), segment and lines()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot SIR estimates and confidence intervals 
</p>

<ul>
<li><p> univariate - plots SIR with univariate confidence intervals
</p>
</li>
<li><p> model - plots SIR with Poisson modelled confidence intervals
</p>
</li></ul>

<p><strong>Customize</strong>
Normal plot parameters can be passed to <code>plot</code>. These can be a vector when plotting error bars:
</p>

<ul>
<li> <p><code>pch</code> - point type
</p>
</li>
<li> <p><code>lty</code> - line type
</p>
</li>
<li> <p><code>col</code> - line/point colour 
</p>
</li>
<li> <p><code>lwd</code> - point/line size
</p>
</li></ul>

<p><strong>Tips for plotting splines</strong>
It's possible to use <code>plot</code> to first draw the 
confidence intervals using specific line type or colour and then plotting 
again the estimate using <code>lines(... , conf.int = FALSE)</code> with different 
settings. This works only when <code>plot.type</code> is 'splines'.
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sir">sir</a></code>,  <code><a href="#topic+sirspline">sirspline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot SIR estimates
# plot(sir.by.gender, col = c(4,2), log=FALSE, eps=0.2, lty=1, lwd=2, pch=19,  
#      main = 'SIR by gender', abline=TRUE)

</code></pre>

<hr>
<h2 id='plot.sirspline'><code>plot</code> method for sirspline-object</h2><span id='topic+plot.sirspline'></span>

<h3>Description</h3>

<p>Plot SIR splines using R base graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sirspline'
plot(x, conf.int = TRUE, abline = TRUE, log = FALSE, type, ylab, xlab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sirspline_+3A_x">x</code></td>
<td>
<p>an object returned by function sirspline</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; default TRUE draws also the 95 confidence intervals</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_abline">abline</code></td>
<td>
<p>logical; draws a reference line where SIR = 1</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_log">log</code></td>
<td>
<p>logical; default FALSE. Should the y-axis be in log scale</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_type">type</code></td>
<td>
<p>select <code>type = 'n'</code> to plot only figure frames</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_ylab">ylab</code></td>
<td>
<p>overwrites default y-axis label; can be a vector if multiple splines fitted</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_xlab">xlab</code></td>
<td>
<p>overwrites default x-axis label; can be a vector if multiple splines fitted</p>
</td></tr>
<tr><td><code id="plot.sirspline_+3A_...">...</code></td>
<td>
<p>arguments passed on to plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>plot.sirspline</code> almost every graphical parameter are user
adjustable, such as <code>ylim</code>, <code>xlim</code>.
<code>plot.sirsplines</code> calls <code>lines.splines</code> to add lines.
</p>
<p>The plot axis without lines can be plotted using option <code>type = 'n'</code>. 
On top of the frame it's then possible to add a <code>grid</code>, 
<code>abline</code> or text before plotting the lines (see: <code>sirspline</code>).
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>See Also</h3>

<p>Other sir functions: 
<code><a href="#topic+lines.sirspline">lines.sirspline</a>()</code>,
<code><a href="#topic+sir_exp">sir_exp</a>()</code>,
<code><a href="#topic+sir_ratio">sir_ratio</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>
</p>

<hr>
<h2 id='plot.survmean'>Graphically Inspect Curves Used in Mean Survival Computation</h2><span id='topic+plot.survmean'></span>

<h3>Description</h3>

<p>Plots the observed (with extrapolation) and expected survival
curves for all strata in an object created by <code><a href="#topic+survmean">survmean</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survmean'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survmean_+3A_x">x</code></td>
<td>
<p>a <code>survmean</code> object</p>
</td></tr>
<tr><td><code id="plot.survmean_+3A_...">...</code></td>
<td>
<p>arguments passed (ultimately) to <code>matlines</code>; you
may, therefore, supply e.g. <code>xlab</code> through this, though arguments
such as <code>lty</code> and <code>col</code> will not work</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples see <code><a href="#topic+survmean">survmean</a></code>. This function is intended only
for graphically inspecting that the observed survival curves with extrapolation
and the expected survival curves have been sensibly computed in <code>survmean</code>.
</p>
<p>If you want finer control over the plotted curves, extract the curves from
the <code>survmean</code> output using 
</p>
<p><code>attr(x, "curves")</code>
</p>
<p>where <code>x</code> is a <code>survmean</code> object.
</p>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survmean functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survmean">lines.survmean</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>
</p>

<hr>
<h2 id='plot.survtab'><code>plot</code> method for survtab objects</h2><span id='topic+plot.survtab'></span>

<h3>Description</h3>

<p>Plotting for <code>survtab</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survtab'
plot(
  x,
  y = NULL,
  subset = NULL,
  conf.int = TRUE,
  col = NULL,
  lty = NULL,
  ylab = NULL,
  xlab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survtab_+3A_x">x</code></td>
<td>
<p>a <code>survtab</code> output object</p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_y">y</code></td>
<td>
<p>survival a character vector of a variable names to plot;
e.g. <code>y = "r.e2"</code></p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_subset">subset</code></td>
<td>
<p>a logical condition; <code>obj</code> is subset accordingly 
before plotting; use this for limiting to specific strata, 
e.g. <code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_conf.int">conf.int</code></td>
<td>
<p>logical; if <code>TRUE</code>, also plots any confidence intervals
present in <code>obj</code> for variables in <code>y</code></p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_col">col</code></td>
<td>
<p>line colour; one value for each stratum; will be recycled</p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_lty">lty</code></td>
<td>
<p>line type; one value for each stratum; will be recycled</p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_ylab">ylab</code></td>
<td>
<p>label for Y-axis</p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_xlab">xlab</code></td>
<td>
<p>label for X-axis</p>
</td></tr>
<tr><td><code id="plot.survtab_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>plot</code> and 
<code>lines.survtab</code>; e.g. <code>ylim</code> can be defined this way</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sire)
data(sibr)
si &lt;- rbind(sire, sibr)
si$period &lt;- cut(si$dg_date, as.Date(c("1993-01-01", "2004-01-01", "2013-01-01")), right = FALSE)
si$cancer &lt;- c(rep("rectal", nrow(sire)), rep("breast", nrow(sibr)))
x &lt;- lexpand(si, birth = bi_date, entry = dg_date, exit = ex_date, 
             status = status %in% 1:2, 
             fot = 0:5, aggre = list(cancer, period, fot))
st &lt;- survtab_ag(fot ~ cancer + period, data = x, 
                 surv.method = "lifetable", surv.type = "surv.obs")

plot(st, "surv.obs", subset = cancer == "breast", ylim = c(0.5, 1), col = "blue")
lines(st, "surv.obs", subset = cancer == "rectal", col = "red")

## or
plot(st, "surv.obs", col = c(2,2,4,4), lty = c(1, 2, 1, 2))
</code></pre>

<hr>
<h2 id='poisson.ci'>Get rate and exact Poisson confidence intervals</h2><span id='topic+poisson.ci'></span>

<h3>Description</h3>

<p>Computes confidence intervals for Poisson rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson.ci(x, pt = 1, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisson.ci_+3A_x">x</code></td>
<td>
<p>observed</p>
</td></tr>
<tr><td><code id="poisson.ci_+3A_pt">pt</code></td>
<td>
<p>expected</p>
</td></tr>
<tr><td><code id="poisson.ci_+3A_conf.level">conf.level</code></td>
<td>
<p>alpha level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns
</p>

<ul>
<li> <p><code>x</code>: arg <code>x</code>
</p>
</li>
<li> <p><code>pt</code>: arg <code>pt</code>
</p>
</li>
<li> <p><code>rate</code>: result of <code>x / pt</code>
</p>
</li>
<li> <p><code>lower</code>: lower bound of CI
</p>
</li>
<li> <p><code>upper</code>: upper bound of CI
</p>
</li>
<li> <p><code>conf.level</code>: arg <code>conf.level</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>epitools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
poisson.ci(x = 4, pt = 5, conf.level = 0.95)
</code></pre>

<hr>
<h2 id='popEpi-package'>popEpi: Functions for large-scale epidemiological analysis</h2><span id='topic+popEpi'></span><span id='topic+popEpi-package'></span>

<h3>Description</h3>

<p><span class="pkg">popEpi</span> is built for the needs of registry-based (large-scale)
epidemiological analysis. This is in most part enabled by the
efficient <span class="pkg">data.table</span> package for handling and aggregating large data sets.
</p>
<p><span class="pkg">popEpi</span> currently supplies some utility functions such as <code><a href="#topic+splitMulti">splitMulti</a></code>
and <code><a href="#topic+get.yrs">get.yrs</a></code> for preparing large data sets for epidemiological analysis.
Included are also a a few functions that can be used in
epidemiological analysis such as <code><a href="#topic+sir">sir</a></code> for estimating
standardized incidence/mortality ratios (SIRs/SMRs) and <code><a href="#topic+survtab">survtab</a></code> for
estimating observed and relative/net survival as well as cumulative incidence
functions (CIFs). In particular, <code>survtab</code> implements the Ederer II
(Ederer and Heise (1959)) and
Pohar Perme estimators (Pohar Perme, Stare, and Esteve (2012)
<a href="https://doi.org/10.1111/j.1541-0420.2011.01640.x">doi:10.1111/j.1541-0420.2011.01640.x</a>) and allows for easy
age-standardisation.
</p>
<p>Since there are many benefits to using <code>data.tables</code>, <span class="pkg">popEpi</span> returns
outputs by default in the <code>data.table</code> format where appropriate.
Since <code>data.table</code>
objects are usually modified by reference, this may have surprising side
effects for users uninitiated in using <code>data.table</code>. To ensure
that appropriate outputs are in the <code>data.frame</code> format, set
<code>options("popEpi.datatable" = FALSE)</code>. However, <code>data.table</code>
usage is recommended due to better performance and testing coverage.
<code>data.table</code> is used
by most functions internally in both cases.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joonas Miettinen <a href="mailto:joonas.miettinen@cancer.fi">joonas.miettinen@cancer.fi</a> (<a href="https://orcid.org/0000-0001-8624-6754">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Matti Rantanen <a href="mailto:matti.rantanen@statfinn.com">matti.rantanen@statfinn.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Karri Seppa <a href="mailto:karri.seppa@cancer.fi">karri.seppa@cancer.fi</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/FinnishCancerRegistry/popEpi">https://github.com/FinnishCancerRegistry/popEpi</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/FinnishCancerRegistry/popEpi/issues">https://github.com/FinnishCancerRegistry/popEpi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='pophaz'>Expected / Population Hazard Data Sets Usage in <span class="pkg">popEpi</span></h2><span id='topic+pophaz'></span>

<h3>Description</h3>

<p>Several functions in <span class="pkg">popEpi</span> make use of population or expected
hazards in computing the intended estimates (e.g. <code><a href="#topic+survtab">survtab</a></code>).
This document explains using such data sets in this package.
</p>


<h3>Details</h3>

<p>Population hazard data sets (pophaz for short) in <span class="pkg">popEpi</span> should
be <code>data.frame</code>s in the &quot;long&quot; format where one of the columns must be
named <code>haz</code> (for hazard), and other columns define the values or 
levels in variables relating to subjects in your data. For example,
<code><a href="#topic+popmort">popmort</a></code> contains Finnish population mortality hazards
by sex, calendar year, and 1-year age group.
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>sex</code> </td><td style="text-align: right;"> <code>year</code> </td><td style="text-align: right;"> <code>agegroup</code> </td><td style="text-align: right;"> <code>haz</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0.036363176</td>
</tr>
<tr>
 <td style="text-align: right;">  
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0.003616547</td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 0.002172384</td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 0.001581249</td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 0.001180690</td>
</tr>
<tr>
 <td style="text-align: right;">
0 </td><td style="text-align: right;"> 1951 </td><td style="text-align: right;"> 5 </td><td style="text-align: right;"> 0.001070595
</td>
</tr>

</table>

<p>The names of the columns should match to the names of the variables
that you have in your subject-level data. Time variables in your pophaz
may also correspond to <code>Lexis</code> time scales; see 
<code><a href="#topic+survtab">survtab</a></code>.
</p>
<p>Any time variables (as they usually have) should be coded consistently:
When using fractional years in your data, the time variables in your pophaz
must also be coded in fractional years. When using e.g. <code>Date</code>s in your
data, ensure that the pophaz time variables are coded at the level of days
(or <code>Date</code>s for calendar time). 
</p>
<p>The <code>haz</code> variable in your pophaz should also be coded consistently
with the used time variables. E.g. <code>haz</code> values in life-tables
reported as deaths per person-year should be multiplied by 365.25 when
using day-level time variables. Typically you'll have calendar time and age
expressed in years, which means <code>haz</code> should be expressed as the number
of deaths per person-year.
</p>
<p>If you have your population hazards in a <code>ratetable</code> object
usable by functions in <span class="pkg">survival</span> and <span class="pkg">relsurv</span>, you may
transform them to long-format <code>data.frame</code>s using
<code><a href="#topic+ratetable_to_long_dt">ratetable_to_long_dt</a></code>. Ensure, however, that the
created <code>haz</code> column is coded at the right level (events per
days or years typically).
</p>
<p>National statistical institutions, the WHO, and e.g. the Human
Life-Table Database supply life-table data.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>

<hr>
<h2 id='popmort'>Population mortality rates in Finland 1951 - 2013 in 101 age groups and
by gender. This is an example of a population hazard table as used in 
<span class="pkg">popEpi</span>; for the general help page, see <code><a href="#topic+pophaz">pophaz</a></code>.</h2><span id='topic+popmort'></span>

<h3>Description</h3>

<p>Population mortality rates in Finland 1951 - 2013 in 101 age groups and
by gender. This is an example of a population hazard table as used in 
<span class="pkg">popEpi</span>; for the general help page, see <code><a href="#topic+pophaz">pophaz</a></code>.
</p>


<h3>Format</h3>

<p><code>data.table</code> with columns
</p>

<ul>
<li> <p><code>sex</code> gender coded as male, female (0, 1)
</p>
</li>
<li> <p><code>year</code> calendar year
</p>
</li>
<li> <p><code>agegroup</code> - coded 0 to 100; one-year age groups
</p>
</li>
<li> <p><code>haz</code> the average population mortality rate per person-year 
(d/(pyrs), where d is the number of deaths and pyrs is the person-years)
</p>
</li></ul>



<h3>Source</h3>

<p>Statistics Finland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pophaz">pophaz</a></code>
</p>
<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>

<hr>
<h2 id='prepExpo'>Prepare Exposure Data for Aggregation</h2><span id='topic+prepExpo'></span>

<h3>Description</h3>

<p><code>prepExpo</code> uses a <code>Lexis</code> object of periods of exposure
to fill gaps between the periods and overall entry and exit times without
accumulating exposure time in periods of no exposure, and splits the
result if requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepExpo(
  lex,
  freezeScales = "work",
  cutScale = "per",
  entry = min(get(cutScale)),
  exit = max(get(cutScale)),
  by = "lex.id",
  breaks = NULL,
  freezeDummy = NULL,
  subset = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepExpo_+3A_lex">lex</code></td>
<td>
<p>a <code><a href="Epi.html#topic+Lexis">Lexis</a></code> object with ONLY periods of exposure
as rows; one or multiple rows per subject allowed</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_freezescales">freezeScales</code></td>
<td>
<p>a character vector naming <code>Lexis</code> time scales of exposure
which should be frozen in periods where no exposure occurs (in the gap
time periods)</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_cutscale">cutScale</code></td>
<td>
<p>the <code>Lexis</code> time scale along which the subject-specific
ultimate entry and exit times are specified</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_entry">entry</code></td>
<td>
<p>an expression; the time of entry to follow-up which may be earlier, at, or after
the first time of exposure in <code>freezeScales</code>; evaluated separately
for each unique combination of <code>by</code>, so e.g. with 
<code>entry = min(Var1)</code> and <code>by = "lex.id"</code> it 
sets the <code>lex.id</code>-specific minima of <code>Var1</code> to be the original times
of entry for each <code>lex.id</code></p>
</td></tr>
<tr><td><code id="prepExpo_+3A_exit">exit</code></td>
<td>
<p>the same as <code>entry</code> but for the ultimate exit time per unique
combination of <code>by</code></p>
</td></tr>
<tr><td><code id="prepExpo_+3A_by">by</code></td>
<td>
<p>a character vector indicating variable names in <code>lex</code>,
the unique combinations of which identify separate subjects for which
to fill gaps in the records from <code>entry</code> to <code>exit</code>;
for novices of <code>{<a href="data.table.html#topic+data.table">data.table</a>}</code>, this is passed to a 
<code>data.table</code>'s <code>by</code> argument.</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_breaks">breaks</code></td>
<td>
<p>a named list of breaks; 
e.g. <code>list(work = 0:20,per = 1995:2015)</code>; passed on to 
<code><a href="#topic+splitMulti">splitMulti</a></code> so see that function's help for more details</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_freezedummy">freezeDummy</code></td>
<td>
<p>a character string; specifies the name for a dummy variable
that this function will create and add to output which 
identifies rows where the <code>freezeScales</code> are frozen and where not
(<code>0</code> implies not frozen, <code>1</code> implies frozen);
if <code>NULL</code>, no dummy is created</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset data by before computations;
e.g. <code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="prepExpo_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty and returns
some messages and timings during its run.</p>
</td></tr>
<tr><td><code id="prepExpo_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+splitMulti">splitMulti</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prepExpo</code> is a convenience function for the purpose of eventually aggregating 
person-time and events in categories of not only normally progressing 
<code>Lexis</code> time scales but also some time scales which should not
progress sometimes. For example a person may work at a production facility
only intermittently, meaning exposure time (to work-related substances 
for example) should not progress outside of periods of work. This allows for
e.g. a correct aggregation of person-time and events by categories of cumulative
time of exposure.
</p>
<p>Given a <code>Lexis</code> object containing rows (time lines)
where a subject is exposed to something (and NO periods without exposure),
fills any gaps between exposure periods for each unique combination of <code>by</code>
and the subject-specific &quot;ultimate&quot; <code>entry</code> and <code>exit</code> times,
&quot;freezes&quot; the cumulative exposure times in periods of no exposure,
and splits data using <code>breaks</code> passed to <code><a href="#topic+splitMulti">splitMulti</a></code>
if requested. Results in a (split) <code>Lexis</code> object where <code>freezeScales</code>
do not progress in time periods where no exposure was recorded in <code>lex</code>.
</p>
<p>This function assumes that <code>entry</code> and <code>exit</code> arguments are the
same for each row within a unique combination of variables named in <code>by</code>.
E.g. with <code>by = "lex.id"</code> only each <code>lex.id</code> has a unique value
for <code>entry</code> and <code>exit</code> at most.
</p>
<p>The supplied <code>breaks</code> split the data using <code>splitMulti</code>, with
the exception that breaks supplied concerning any frozen time scales
ONLY split the rows where the time scales are not frozen. E.g.
with <code>freezeScales = "work"</code>, 
<code>breaks = list(work = 0:10, cal = 1995:2010)</code> splits all rows over
<code>"cal"</code> but only non-frozen rows over <code>"work"</code>.
</p>
<p>Only supports frozen time scales that advance and freeze contemporaneously:
e.g. it would not currently be possible to take into account the cumulative
time working at a facility and the cumulative time doing a single task
at the facility, if the two are not exactly the same. On the other hand
one might use the same time scale for different exposure types, supply them
as separate rows, and identify the different exposures using a dummy variable.
</p>


<h3>Value</h3>

<p>Returns a <code>Lexis</code> object that has been split if <code>breaks</code> is specified.
The resulting time is also a <code>data.table</code> if 
<code>options("popEpi.datatable") == TRUE</code> (see: <code>?popEpi</code>)
</p>

<hr>
<h2 id='print.aggre'>Print an <code>aggre</code> Object</h2><span id='topic+print.aggre'></span>

<h3>Description</h3>

<p>Print method function for <code>aggre</code> objects; see
<code><a href="#topic+as.aggre">as.aggre</a></code> and <code><a href="#topic+aggre">aggre</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aggre'
print(x, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.aggre_+3A_x">x</code></td>
<td>
<p>an <code>aggre</code> object</p>
</td></tr>
<tr><td><code id="print.aggre_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset results table by
before printing; use this to limit to a certain stratum. E.g.
<code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="print.aggre_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>print.data.table</code>; try e.g.
<code>top = 2</code> for numbers of rows in head and tail printed 
if the table is large, 
<code>nrow = 100</code> for number of rows to print, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>

<hr>
<h2 id='print.rate'>Print an rate object</h2><span id='topic+print.rate'></span>

<h3>Description</h3>

<p>Print method function for <code>rate</code> objects; see
<code><a href="#topic+rate">rate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rate'
print(x, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rate_+3A_x">x</code></td>
<td>
<p>an <code>rate</code> object</p>
</td></tr>
<tr><td><code id="print.rate_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset results table by
before printing; use this to limit to a certain stratum. E.g.
<code>subset = sex == "female"</code></p>
</td></tr>
<tr><td><code id="print.rate_+3A_...">...</code></td>
<td>
<p>arguments for data.tables print method, e.g. row.names = FALSE suppresses row numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>

<hr>
<h2 id='print.survtab'>Print a survtab Object</h2><span id='topic+print.survtab'></span>

<h3>Description</h3>

<p>Print method function for <code>survtab</code> objects; see
<code><a href="#topic+survtab_ag">survtab_ag</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survtab'
print(x, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.survtab_+3A_x">x</code></td>
<td>
<p>a <code>survtab</code> object</p>
</td></tr>
<tr><td><code id="print.survtab_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset results table by
before printing; use this to limit to a certain stratum. E.g.
<code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="print.survtab_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>print.data.table</code>; try e.g.
<code>top = 2</code> for numbers of rows in head and tail printed 
if the table is large, 
<code>nrow = 100</code> for number of rows to print, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>

<hr>
<h2 id='rate'>Direct-Standardised Incidence/Mortality Rates</h2><span id='topic+rate'></span>

<h3>Description</h3>

<p><code>rate</code> calculates adjusted rates using
preloaded weights data or user specified weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate(
  data,
  obs = NULL,
  pyrs = NULL,
  print = NULL,
  adjust = NULL,
  weights = NULL,
  subset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate_+3A_data">data</code></td>
<td>
<p>aggregated data (see e.g. <code><a href="#topic+lexpand">lexpand</a></code>, 
<code><a href="#topic+aggre">aggre</a></code> if you have subject-level data)</p>
</td></tr>
<tr><td><code id="rate_+3A_obs">obs</code></td>
<td>
<p>observations variable name in data.
<a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>obs = obs</code>.</p>
</td></tr>
<tr><td><code id="rate_+3A_pyrs">pyrs</code></td>
<td>
<p>person-years variable name in data.
<a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>pyrs = pyrs</code>.</p>
</td></tr>
<tr><td><code id="rate_+3A_print">print</code></td>
<td>
<p>variable name to stratify the rates.
<a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>print = sex</code> or <code>print = list(sex, area)</code>.</p>
</td></tr>
<tr><td><code id="rate_+3A_adjust">adjust</code></td>
<td>
<p>variable for adjusting the rates.
<a href="#topic+flexible_argument">Flexible input</a>, typically e.g.
<code>adjust = agegroup</code>.</p>
</td></tr>
<tr><td><code id="rate_+3A_weights">weights</code></td>
<td>
<p>typically a list of weights or a <code>character</code> string
specifying an age group standardization scheme; see
the <a href="#topic+direct_standardization">dedicated help page</a> 
and examples.</p>
</td></tr>
<tr><td><code id="rate_+3A_subset">subset</code></td>
<td>
<p>a logical expression to subset data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data needs to be in aggregated format with observations 
and person-years. For individual data use <code><a href="#topic+lexpand">lexpand</a></code>, or
<code><a href="#topic+ltable">ltable</a></code> and merge person-years manually.
</p>
<p>The confidence intervals are based on the normal approximation of the logarithm of the rate.
The variance of the log rate that is used to derive the confidence intervals 
is derived using the delta method.
</p>


<h3>Value</h3>

<p>Returns a <code>data.table</code> with observations, person-years, rates and
adjusted rates, if available. Results are stratified by <code>print</code>.
Adjusted rates are identified with suffix <code>.adj</code> and  
<code>.lo</code> and <code>.hi</code> are for confidence intervals lower and upper 
95% bounds, respectively.
The prefix <code>SE.</code> stands for standard error.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen, Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexpand">lexpand</a></code>, <code><a href="#topic+ltable">ltable</a></code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other rate functions: 
<code><a href="#topic+rate_ratio">rate_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Prepare data with lexpand and then reformat agegroup.
data(sibr)
x &lt;- lexpand(sibr, birth = bi_date, entry = dg_date, exit = ex_date,  
             breaks = list(per = c(1990,2000,2010,2020), age = c(0:17*5,Inf)),
             aggre = list(agegroup = age, year.cat = per),
             status =  status != 0)

x$agegroup &lt;- cut(x$agegroup,  c(0:17*5,Inf), right = FALSE)

## calculate rates for selected periods with Nordic 2000 weights:
r1 &lt;- rate( data = x, obs = from0to1, pyrs = pyrs, print = year.cat, 
            adjust = agegroup, weights = 'nordic')
r1

## use total person-years by stratum as weights (some have zero)
w &lt;- ltable(x, by.vars = "agegroup", expr = sum(pyrs))
w[is.na(w$V1),]$V1 &lt;- 0

r2 &lt;- rate( data = x, obs = from0to1, pyrs = pyrs, print = year.cat, 
            adjust = agegroup,
            weights = w$V1)
r2

## use data.frame of weights:
names(w) &lt;- c("agegroup", "weights")
r2 &lt;- rate( data = x, obs = from0to1, pyrs = pyrs, print = year.cat, 
            adjust = agegroup,
            weights = w)
r2

## internal weights (same result as above)
r3 &lt;- rate( data = x, obs = from0to1, pyrs = pyrs, print = year.cat, 
            adjust = agegroup,
            weights = "internal")
r3

</code></pre>

<hr>
<h2 id='rate_ratio'>Confidence intervals for the rate ratios</h2><span id='topic+rate_ratio'></span>

<h3>Description</h3>

<p>Calculate rate ratio with confidence intervals for rate objects or observations and person-years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_ratio(x, y, crude = FALSE, SE.method = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate_ratio_+3A_x">x</code></td>
<td>
<p>a rate-object, vector of two; rate and standard error or observed and person-years.</p>
</td></tr>
<tr><td><code id="rate_ratio_+3A_y">y</code></td>
<td>
<p>a rate-object, vector of two; rate and standard error or observed and person-years.</p>
</td></tr>
<tr><td><code id="rate_ratio_+3A_crude">crude</code></td>
<td>
<p>set TRUE to use crude rates; default is FALSE.</p>
</td></tr>
<tr><td><code id="rate_ratio_+3A_se.method">SE.method</code></td>
<td>
<p>default TRUE; if <code>x</code> and <code>y</code> are vectors of observed and 
person-years, this must be changed to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate rate ratio of two age standardized rate objects (see <code><a href="#topic+rate">rate</a></code>). 
Multiple rates for each objects is supported if there are an equal number of rates. 
Another option is to set <code>x</code> and <code>y</code> as a vector of two.
</p>

<ol>
<li><p> rate and its standard error, and  set <code>SE.method = TRUE</code>.
</p>
</li>
<li><p> observations and person-year, and  set <code>SE.method = FALSE</code>.
</p>
</li></ol>

<p>See examples.
</p>


<h3>Value</h3>

<p>A vector length of three: rate_ratio, and lower and upper confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rate">rate</a></code>
</p>
<p>Other rate functions: 
<code><a href="#topic+rate">rate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two rate ratios; silly example with female rectal / breast cancer 
## mortality rates
data("sire", package = "popEpi")
data("sibr", package = "popEpi")

BL &lt;- list(per = 2000:2005)

re &lt;- lexpand(sire, birth = "bi_date", entry = "dg_date", exit = "ex_date",
              status = status == 1, breaks = BL, aggre = list(per))
br &lt;- lexpand(sibr, birth = "bi_date", entry = "dg_date", exit = "ex_date",
              status = status == 1, breaks = BL, aggre = list(per))

r_re &lt;- rate(re, obs = "from0to1", pyrs = "pyrs")
r_br &lt;- rate(br, obs = "from0to1", pyrs = "pyrs")

rate_ratio(r_re, r_br, SE.method = TRUE)


# manually set rates (0.003 and 0.005) and SEs (0.001 and 0.002)
# so that x = y = c('rate', 'SE')
rate_ratio(x= c(0.003, 0.001), y= c(0.005, 0.002), SE.method = TRUE) 

# observed numbers (10 and 20) and person-years (30000 and 40000):
rate_ratio(x = c(10, 30000), y = c(20, 40000), SE.method = FALSE)

</code></pre>

<hr>
<h2 id='relpois'>Excess hazard Poisson model</h2><span id='topic+relpois'></span>

<h3>Description</h3>

<p>Estimate a Poisson piecewise constant excess
hazards model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relpois(data, formula, fot.breaks = NULL, subset = NULL, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relpois_+3A_data">data</code></td>
<td>
<p>a dataset split with e.g. <code><a href="#topic+lexpand">lexpand</a></code>;
must have expected hazard merged within</p>
</td></tr>
<tr><td><code id="relpois_+3A_formula">formula</code></td>
<td>
<p>a formula which is passed on to <code>glm</code>; see Details</p>
</td></tr>
<tr><td><code id="relpois_+3A_fot.breaks">fot.breaks</code></td>
<td>
<p>optional; a numeric vector of [a,b) breaks to specify
survival intervals over the follow-up time; if <code>NULL</code>, the 
existing breaks along the mandatory <code>fot</code> time scale in <code>data</code>
are used (e.g. the breaks for <code>fot</code> supplied to <code>lexpand</code>)</p>
</td></tr>
<tr><td><code id="relpois_+3A_subset">subset</code></td>
<td>
<p>a logical vector or condition; e.g. <code>subset = sex == 1</code>;
limits the data before estimation</p>
</td></tr>
<tr><td><code id="relpois_+3A_check">check</code></td>
<td>
<p>logical; if <code>TRUE</code>, tabulates excess cases by all
factor variables in the formula to check for negative / <code>NA</code> 
excess cases before fitting the GLM</p>
</td></tr>
<tr><td><code id="relpois_+3A_...">...</code></td>
<td>
<p>any argument passed on to <code>glm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Basics</strong>
</p>
<p><code>relpois</code> employs a custom link function of the Poisson variety
to estimate piecewise constant parametric excess hazards. The pieces
are determined by <code>fot.breaks</code>. A <code>log(person-years)</code> offset
is passed automatically to the <code>glm</code> call.
</p>
<p><strong>Formula usage</strong>
</p>
<p>The formula can be used like any ordinary <code>glm</code> formula. The user must
define the outcome in some manner, which is usually <code>lex.Xst</code> after splitting
with e.g. <code>lexpand</code>. The exception is the possibility of including 
the baseline excess hazard terms by including the 
reserved term <code>FOT</code> in the formula.
</p>
<p>For example, <code>lex.Xst != 0 ~ FOT + agegr</code> estimates a model with constant
excess hazards at the follow-up intervals as specified by 
the pertinent breaks used in splitting <code>data</code>,
as well as for the different age groups.
<code>FOT</code> is created ad hoc if it is used in the formula.
If you leave out <code>FOT</code>, the hazard is effectively
assumed to be constant across the whole follow-up time. 
</p>
<p>You can also simply use your own follow-up time interval variable that
you have created before calling <code>relpois</code>. However, when using 
<code>FOT</code>, <code>relpois</code> automatically checks for e.g. 
negative excess cases in follow-up intervals,
allowing for quickly finding splitting breaks
where model estimation is possible. It also drops any data outside the
follow-up time window.
</p>
<p><strong>Splitting and merging population hazard</strong>
</p>
<p>The easiest way to both split and to include population hazard information is 
by using <code><a href="#topic+lexpand">lexpand</a></code>. You may also fairly easily do it by hand
by splitting first and then merging in your population hazard information.
</p>
<p><strong>Data requirements</strong>
</p>
<p>The population hazard information must be available for each record and named
<code>pop.haz</code>. The follow-up time variable must be named <code>"fot"</code> e.g.
as a result of using <code>lexpand</code>. The <code>lex.dur</code> variable must also
be present, containing person-year information.
</p>


<h3>Value</h3>

<p>A <code>glm</code> object created using a custom Poisson family construct. Some
<code>glm</code> methods are applicable.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen, Karri Seppa
</p>


<h3>References</h3>

<p>Paul W Dickman, Andy Sloggett, Michael Hills, and Timo Hakulinen.
Regression models for relative survival. 
Stat Med. 2004 Jan 15;23(1):51-64.
<a href="https://doi.org/10.1002/sim.1597">doi:10.1002/sim.1597</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexpand">lexpand</a></code>, <code><a href="stats.html#topic+poisson">poisson</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other relpois functions: 
<code><a href="#topic+RPL">RPL</a></code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+rpcurve">rpcurve</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use the simulated rectal cancer cohort
data("sire", package = "popEpi")
sire$agegr &lt;- cut(sire$dg_age, c(0,45,60,Inf), right=FALSE)

## usable straight away after splitting
fb &lt;- c(0,3/12,6/12,1,2,3,4,5)
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date,
             exit = ex_date, status=status,
             breaks = list(fot=fb), pophaz=popmort)
rpm &lt;- relpois(x, formula = lex.Xst %in% 1:2 ~ FOT + agegr)
 
## some methods for glm work. e.g. test for interaction

rpm2 &lt;- relpois(x, formula = lex.Xst %in% 1:2 ~ FOT*agegr)
anova(rpm, rpm2, test="LRT")
AIC(rpm, rpm2)
## update() won't work currently

</code></pre>

<hr>
<h2 id='relpois_ag'>Excess hazard Poisson model</h2><span id='topic+relpois_ag'></span>

<h3>Description</h3>

<p>Estimate a Poisson Piecewise Constant Excess
Hazards Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relpois_ag(
  formula,
  data,
  d.exp,
  offset = NULL,
  breaks = NULL,
  subset = NULL,
  piecewise = TRUE,
  check = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relpois_ag_+3A_formula">formula</code></td>
<td>
<p>a formula with the counts of events as the response.
Passed on to <code>glm</code>. May contain usage of the <code>offset()</code> function
instead of supplying the offset for the Poisson model via the argument
<code>offset</code>.</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_data">data</code></td>
<td>
<p>an <code>aggre</code> object (an aggregated data set; 
see <code><a href="#topic+as.aggre">as.aggre</a></code> and <code><a href="#topic+aggre">aggre</a></code>)</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_d.exp">d.exp</code></td>
<td>
<p>the counts of expected cases. Mandatory.
E.g. <code>d.exp = EXC_CASES</code>, where <code>EXC_CASES</code> is a column in data.</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_offset">offset</code></td>
<td>
<p>the offset for the Poisson model, supplied as e.g.
<code>offset = log(PTIME)</code>, where <code>PTIME</code> is a subject-time
variable in data. Not mandatory, but almost always should be supplied.</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_breaks">breaks</code></td>
<td>
<p>optional; a numeric vector of [a,b) breaks to specify
survival intervals over the follow-up time; if <code>NULL</code>, the 
existing breaks along the mandatory time scale mentioned in <code>formula</code>
are used</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_subset">subset</code></td>
<td>
<p>a logical vector or condition; e.g. <code>subset = sex == 1</code>;
limits the data before estimation</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_piecewise">piecewise</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, and if any time scale
from data is used (mentioned) in the formula, the time scale is 
transformed into a factor variable indicating intervals on the time scale.
Otherwise the time scale left as it is, usually a numeric variable.
E.g. if <code>formula = counts ~ TS1*VAR1</code>, <code>TS1</code> is transformed
into a factor before fitting model.</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_check">check</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, performs check on the 
negativity excess cases by factor-like covariates in formula - 
negative excess cases will very likely lead to non-converging model</p>
</td></tr>
<tr><td><code id="relpois_ag_+3A_...">...</code></td>
<td>
<p>any other argument passed on to <code><a href="stats.html#topic+glm">glm</a></code> such as 
<code>control</code> or <code>weights</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>relpois</code> object created using a custom Poisson family construct.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen, Karri Seppa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexpand">lexpand</a></code>, <code><a href="stats.html#topic+poisson">poisson</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other relpois functions: 
<code><a href="#topic+RPL">RPL</a></code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+rpcurve">rpcurve</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use the simulated rectal cancer cohort
data(sire, package = "popEpi")
sire$agegr &lt;- cut(sire$dg_age, c(0,45,60,Inf), right=FALSE)

## create aggregated example data
fb &lt;- c(0,3/12,6/12,1,2,3,4,5)
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date,
             exit = ex_date, status=status %in% 1:2,
             breaks = list(fot=fb), 
             pophaz=popmort, pp = FALSE,
             aggre = list(agegr, fot))
             
## fit model using aggregated data
rpm &lt;- relpois_ag(formula = from0to1 ~ fot + agegr,  data = x,
                  d.exp = d.exp, offset = log(pyrs))
summary(rpm)
 
## the usual functions for handling glm models work
rpm2 &lt;- update(rpm, . ~ fot*agegr)
anova(rpm, rpm2, test="LRT")
AIC(rpm, rpm2)

## other features such as residuals or predicting are not guaranteed
## to work as intended.
</code></pre>

<hr>
<h2 id='robust_values'>Convert values to numeric robustly</h2><span id='topic+robust_values'></span>

<h3>Description</h3>

<p>Brute force solution for ensuring a variable is numeric by 
coercing a variable of any type first to factor and then to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_values(num.values, force = FALSE, messages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust_values_+3A_num.values">num.values</code></td>
<td>
<p>values to convert to numeric</p>
</td></tr>
<tr><td><code id="robust_values_+3A_force">force</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns a vector of values where values that cannot be interpreted as numeric are
set to <code>NA</code>; if <code>FALSE</code>, returns the original vector and gives a warning if any value cannot be interpreted as
numeric.</p>
</td></tr>
<tr><td><code id="robust_values_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>TRUE</code>, returns a message of what was done with the <code>num.values</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Note</h3>

<p>Returns <code>NULL</code> if given <code>num.values</code> is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## this works
values &lt;- c("1", "3", "5")
values &lt;- robust_values(values)

## this works
values &lt;- c("1", "3", "5", NA)
values &lt;- robust_values(values)

## this returns originals and throws warnings
values &lt;- c("1", "3", "5", "a")
suppressWarnings(
  values &lt;- robust_values(values)
)


## this forces "a" to NA and works otherwise; throws warning about NAs
values &lt;- c("1", "3", "5", "a")
suppressWarnings(
  values &lt;- robust_values(values, force=TRUE)
)

</code></pre>

<hr>
<h2 id='rpcurve'>Marginal piecewise parametric relative survival curve</h2><span id='topic+rpcurve'></span>

<h3>Description</h3>

<p>Fit a marginal relative survival curve based on a <code>relpois</code> fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpcurve(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpcurve_+3A_object">object</code></td>
<td>
<p>a <code>relpois</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a marginal curve, i.e. the average of all
possible individual curves. 
</p>
<p>Only supported when the reserved <code>FOT</code> variable was used in <code>relpois</code>.
Computes a curve for each unique combination of covariates (e.g. 4 sets) 
and returns a weighted average curve based on the counts
of subjects for each combination (e.g. 1000, 125, 50, 25 respectively). 
Fairly fast when only categorical variables have been used, otherwise
go get a cup of coffee.
</p>
<p>If delayed entry is present in data due to period analysis limiting,
the marginal curve is constructed only for those whose follow-up started
in the respective period.
</p>


<h3>Value</h3>

<p>A 'data.table' of relative survival curves.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other relpois functions: 
<code><a href="#topic+RPL">RPL</a></code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## use the simulated rectal cancer cohort
data("sire", package = "popEpi")
ab &lt;- c(0,45,55,65,70,Inf)
sire$agegr &lt;- cut(sire$dg_age, breaks = ab, right = FALSE)

BL &lt;- list(fot= seq(0,10,1/12))
pm &lt;- data.frame(popEpi::popmort)
x &lt;- lexpand(sire, breaks=BL, pophaz=pm, 
             birth = bi_date, 
             entry = dg_date, exit = ex_date, 
             status  = status %in% 1:2)

rpm &lt;- relpois(x, formula = lex.Xst %in% 1:2 ~ -1+ FOT + agegr, 
               fot.breaks=c(0,0.25,0.5,1:8,10))
pmc &lt;- rpcurve(rpm)

## compare with non-parametric estimates
names(pm) &lt;- c("sex", "per", "age", "haz")
x$agegr &lt;- cut(x$dg_age, c(0,45,55,65,75,Inf), right = FALSE)
st &lt;- survtab(fot ~ adjust(agegr), data = x, weights = "internal",
              pophaz = pm)


plot(st, y = "r.e2.as")
lines(y = pmc$est, x = pmc$Tstop, col="red")




</code></pre>

<hr>
<h2 id='RPL'>Relative Poisson family object</h2><span id='topic+RPL'></span>

<h3>Description</h3>

<p>A family object for GLM fitting of relative Poisson models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RPL
</code></pre>


<h3>Format</h3>

<p>A list very similar to that created by <code>poisson()</code>.
</p>


<h3>Author(s)</h3>

<p>Karri Seppa
</p>


<h3>See Also</h3>

<p>Other relpois functions: 
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+rpcurve">rpcurve</a>()</code>
</p>

<hr>
<h2 id='setaggre'>Set <code>aggre</code> attributes to an object by modifying in place</h2><span id='topic+setaggre'></span>

<h3>Description</h3>

<p>Coerces an R object to an <code>aggre</code> object, identifying
the object as one containing aggregated counts, person-years and other
information. <code>setaggre</code> modifies in place without taking any copies.
Retains all other attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setaggre(x, values = NULL, by = NULL, breaks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setaggre_+3A_x">x</code></td>
<td>
<p>a <code>data.frame</code> or <code>data.table</code></p>
</td></tr>
<tr><td><code id="setaggre_+3A_values">values</code></td>
<td>
<p>a character string vector; the names of value variables</p>
</td></tr>
<tr><td><code id="setaggre_+3A_by">by</code></td>
<td>
<p>a character string vector; the names of variables by which 
<code>values</code> have been tabulated</p>
</td></tr>
<tr><td><code id="setaggre_+3A_breaks">breaks</code></td>
<td>
<p>a list of breaks, where each element is a breaks vector
as usually passed to e.g. <code><a href="#topic+splitLexisDT">splitLexisDT</a></code>. The list must be
fully named, with the names corresponding to time scales at the aggregate
level in your data. Every unique value in a time scale variable in data must
also exist in the corresponding vector in the breaks list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setaggre</code> sets <code>x</code> to the <code>aggre</code> class in place 
without taking a copy as e.g. <code>as.data.frame.XXX</code> functions do; see e.g. 
<code><a href="data.table.html#topic+setDT">setDT</a></code>.
</p>


<h3>Value</h3>

<p>Returns 'x' invisibly after setting attributes to it without taking a copy.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+aggre">aggre</a>()</code>,
<code><a href="#topic+as.aggre">as.aggre</a>()</code>,
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+summary.aggre">summary.aggre</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(sex = rep(c("male", "female"), each = 5), 
                 obs = rpois(10, rep(7,5, each=5)), 
                 pyrs = rpois(10, lambda = 10000))
## without any breaks
setaggre(df, values = c("obs", "pyrs"), by = "sex")
df &lt;- data.frame(df)
df$FUT &lt;- 0:4
## with breaks list
setaggre(df, values = c("obs", "pyrs"), by = "sex", breaks = list(FUT = 0:5))
</code></pre>

<hr>
<h2 id='setclass'>Set the class of an object (convenience function for
<code>setattr(obj, "class", CLASS)</code>); can add instead of replace</h2><span id='topic+setclass'></span>

<h3>Description</h3>

<p>Sets the class of an object in place to <code>cl</code>
by replacing or adding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setclass(obj, cl, add = FALSE, add.place = "first")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setclass_+3A_obj">obj</code></td>
<td>
<p>and object for which to set class</p>
</td></tr>
<tr><td><code id="setclass_+3A_cl">cl</code></td>
<td>
<p>class to set</p>
</td></tr>
<tr><td><code id="setclass_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, adds <code>cl</code> to the 
classes of the <code>obj</code>; otherwise replaces the class information</p>
</td></tr>
<tr><td><code id="setclass_+3A_add.place">add.place</code></td>
<td>
<p><code>"first"</code> or <code>"last"</code>; adds <code>cl</code>
to the front or to the back of the <code>obj</code>'s class vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>

<hr>
<h2 id='setcolsnull'>Delete <code>data.table</code> columns if there</h2><span id='topic+setcolsnull'></span>

<h3>Description</h3>

<p>Deletes columns in a <code>data.table</code> conveniently.
May only delete columns that are found silently. Sometimes useful in e.g.
<code>on.exit</code> expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setcolsnull(
  DT = NULL,
  delete = NULL,
  keep = NULL,
  colorder = FALSE,
  soft = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcolsnull_+3A_dt">DT</code></td>
<td>
<p>a <code>data.table</code></p>
</td></tr>
<tr><td><code id="setcolsnull_+3A_delete">delete</code></td>
<td>
<p>a character vector of column names to be deleted</p>
</td></tr>
<tr><td><code id="setcolsnull_+3A_keep">keep</code></td>
<td>
<p>a character vector of column names to keep; 
the rest will be removed; <code>keep</code> overrides <code>delete</code></p>
</td></tr>
<tr><td><code id="setcolsnull_+3A_colorder">colorder</code></td>
<td>
<p>logical; if <code>TRUE</code>, also does <code>setcolorder</code> using
<code>keep</code></p>
</td></tr>
<tr><td><code id="setcolsnull_+3A_soft">soft</code></td>
<td>
<p>logical; if <code>TRUE</code>, does not cause an error if any variable
name in <code>keep</code> or <code>delete</code> is missing; <code>soft = FALSE</code> useful 
for programming sometimes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns 'NULL' invisibly.
This function is called for its side effects.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>

<hr>
<h2 id='sibr'>sibr - a simulated cohort of Finnish female breast cancer patients</h2><span id='topic+sibr'></span>

<h3>Description</h3>

<p><code>sibr</code> is a simulated cohort pertaining female Finnish breast cancer patients
diagnosed between 1993-2012. Instead of actual original dates, the dates are masked
via modest randomization within several time windows. The dataset is additionally
a random sample of 10 000 cases from the pertaining time window.
</p>


<h3>Format</h3>

<p>data.table with columns
</p>

<ul>
<li><p> sex - gender of the patient (1 = female)
</p>
</li>
<li><p> bi_date - date of birth
</p>
</li>
<li><p> dg_date - date of cancer diagnosis
</p>
</li>
<li><p> ex_date - date of exit from follow-up (death or censoring)
</p>
</li>
<li><p> status  - status of the person at exit; 0 alive; 1 dead due to pertinent cancer; 2 dead due to other causes
</p>
</li>
<li><p> dg_age  - age at diagnosis expressed as fractional years
</p>
</li></ul>



<h3>Details</h3>

<p>The closing date for the pertinent data was 2012-12-31, meaning status information was
available only up to that point &mdash; hence the maximum possible <code>ex_date</code> is <code>2012-12-31</code>.
</p>


<h3>Author(s)</h3>

<p>Karri Seppa
</p>


<h3>Source</h3>

<p>The Finnish Cancer Registry
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>
<p>Other survival data: 
<code><a href="#topic+sire">sire</a></code>
</p>

<hr>
<h2 id='sir'>Calculate SIR or SMR</h2><span id='topic+sir'></span>

<h3>Description</h3>

<p>Poisson modelled standardised incidence or mortality ratios (SIRs / SMRs) i.e. 
indirect method for calculating standardised rates. SIR is a ratio of observed and expected cases.
Expected cases are derived by multiplying the strata-specific population rate with the
corresponding person-years of the cohort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir(
  coh.data,
  coh.obs,
  coh.pyrs,
  ref.data = NULL,
  ref.obs = NULL,
  ref.pyrs = NULL,
  ref.rate = NULL,
  subset = NULL,
  print = NULL,
  adjust = NULL,
  mstate = NULL,
  test.type = "homogeneity",
  conf.type = "profile",
  conf.level = 0.95,
  EAR = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sir_+3A_coh.data">coh.data</code></td>
<td>
<p>aggregated cohort data, see e.g. <code><a href="#topic+lexpand">lexpand</a></code></p>
</td></tr>
<tr><td><code id="sir_+3A_coh.obs">coh.obs</code></td>
<td>
<p>variable name for observed cases; quoted or unquoted. A vector when using <code>mstata</code>.</p>
</td></tr>
<tr><td><code id="sir_+3A_coh.pyrs">coh.pyrs</code></td>
<td>
<p>variable name for person years in cohort data; 
quoted (as a string <code>'myvar'</code>) or unquoted (AKA as a name; <code>myvar</code>)</p>
</td></tr>
<tr><td><code id="sir_+3A_ref.data">ref.data</code></td>
<td>
<p>population data. Can be left NULL if <code>coh.data</code> 
is stratified in <code>print</code>. See <code><a href="#topic+pophaz">pophaz</a></code> for details.</p>
</td></tr>
<tr><td><code id="sir_+3A_ref.obs">ref.obs</code></td>
<td>
<p>variable name for observed cases; quoted or unquoted</p>
</td></tr>
<tr><td><code id="sir_+3A_ref.pyrs">ref.pyrs</code></td>
<td>
<p>variable name for person-years in population data; quoted or unquoted</p>
</td></tr>
<tr><td><code id="sir_+3A_ref.rate">ref.rate</code></td>
<td>
<p>population rate variable (cases/person-years). Overwrites 
arguments <code>ref.pyrs</code> and <code>ref.obs</code>. Quoted or unquoted</p>
</td></tr>
<tr><td><code id="sir_+3A_subset">subset</code></td>
<td>
<p>logical condition to select data from <code>coh.data</code> before any computations</p>
</td></tr>
<tr><td><code id="sir_+3A_print">print</code></td>
<td>
<p>variable names to stratify results; quoted vector or unquoted named list with functions</p>
</td></tr>
<tr><td><code id="sir_+3A_adjust">adjust</code></td>
<td>
<p>variable names for adjusting without stratifying output; quoted vector or unquoted list</p>
</td></tr>
<tr><td><code id="sir_+3A_mstate">mstate</code></td>
<td>
<p>set column names for cause specific observations; quoted or unquoted. Relevant only
when <code>coh.obs</code> length is two or more. See details.</p>
</td></tr>
<tr><td><code id="sir_+3A_test.type">test.type</code></td>
<td>
<p>Test for equal SIRs. Test available are 'homogeneity' and 'trend'.</p>
</td></tr>
<tr><td><code id="sir_+3A_conf.type">conf.type</code></td>
<td>
<p>Confidence interval type: 'profile'(=default), 'wald' or 'univariate'.</p>
</td></tr>
<tr><td><code id="sir_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of type-I error in confidence intervals, default 0.05 is 95% CI.</p>
</td></tr>
<tr><td><code id="sir_+3A_ear">EAR</code></td>
<td>
<p>logical; TRUE calculates Excess Absolute Risks for univariate SIRs.
(see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sir</code> is a comprehensive tool for modelling SIRs/SMRs with flexible 
options to adjust and print SIRs, test homogeneity and utilize 
multi-state data. The cohort data and the variable names for observation 
counts and person-years are required.
The reference data is optional, since the cohort data 
can be stratified (<code>print</code>) and compared to total.
</p>
<p><strong>Adjust and print</strong>
</p>
<p>A SIR can be adjusted or standardised using the covariates found in both <code>coh.data</code> and <code>ref.data</code>.
Variable to adjust are given in <code>adjust</code>.
Variable names needs to match in both <code>coh.data</code> and <code>ref.data</code>. 
Typical variables to adjust by are gender, age group and calendar period.
</p>
<p><code>print</code> is used to stratify the SIR output. In other words, the variables 
assigned to <code>print</code> are the covariates of the Poisson model.
Variable levels are treated as categorical.
Variables can be assigned in both <code>print</code> and <code>adjust</code>. 
This means the output it adjusted and printed by these variables.
</p>
<p><code>print</code> can also be a list of expressions. This enables changing variable 
names or transforming variables with functions such as <code>cut</code> and <code>round</code>.
For example, the existing variables <code>agegroup</code> and <code>year</code> could be
transformed to new levels using <code>cut</code> by
</p>
<p><code>print = list( age.category = cut(agegroup, breaks = c(0,50,75,100)), 
year.cat = cut(year, seq(1950,2010,20)))</code>
</p>
<p><strong>ref.rate or ref.obs &amp; ref.pyrs</strong>
</p>
<p>The population rate variable can be given to the <code>ref.rate</code> parameter. 
That is, when using e.g. the <code>popmort</code> or a comparable data file, one may
supply <code>ref.rate</code> instead of <code>ref.obs</code> and <code>ref.pyrs</code>, which
will be ignored if <code>ref.rate</code> is supplied. 
</p>
<p>Note that if all the stratifying variables in 
<code>ref.data</code> are not listed in <code>adjust</code>, 
or when the categories are otherwise combined,
the (unweighted) mean of rates is used for computing expected cases.
This might incur a small bias in comparison to when exact numbers of observations
and person-years are available. 
</p>
<p><strong>mstate</strong>
</p>
<p>E.g. using <code>lexpand</code> it's possible to compute counts for several outcomes
so that the population at risk is same for each 
outcome such as a certain kind of cancer. 
The transition counts are in wide data format, 
and the relevant columns can be supplied to <code>sir</code>
in a vector via the <code>coh.obs</code> argument. 
The name of the corresponding new column in <code>ref.data</code> is given in
<code>mstate</code>. It's recommended to include the <code>mstate</code> variable in <code>adjust</code>,
so the corresponding information should also be available in <code>ref.data</code>.
More examples in sir-vignette.
</p>
<p>This approach is analogous to where SIRs are calculated separately their 
own function calls.
</p>
<p><strong>Other parameters</strong>
</p>
<p><code>univariate</code> confidence intervals are calculated using exact 
Poisson intervals (<code>poisson.ci</code>). The options <code>profile</code> and <code>wald</code> are
is based on a Poisson regression model: profile-likelihood confidence intervals 
or Wald's normal-approximation. P-value is Poisson model based <code>conf.type</code>
or calculated using the method described by Breslow and Day. Function automatically
switches to another <code>conf.type</code> if calculation is not possible with a message.
Usually model fit fails if there is print stratum with zero expected values.
</p>
<p>The LRT p-value tests the levels of <code>print</code>. The test can be either 
<code>"homogeneity"</code>, a likelihood ratio test where the model variables defined in
<code>print</code> (factor) is compared to the constant model.
Option <code>"trend"</code> tests if the linear trend of the continuous variable in
<code>print</code> is significant (using model comparison).
</p>
<p><strong>EAR: Excess Absolute Risk</strong>
</p>
<p>Excess Absolute Risk is a simple way to quantify the absolute difference between cohort risk and 
population risk.
Make sure that the person-years are calculated accordingly before using EAR. (when using mstate)
</p>
<p>Formula for EAR:
</p>
<p style="text-align: center;"><code class="reqn">EAR = \frac{observed - expected}{person years} \times 1000.</code>
</p>

<p><strong>Data format</strong>
</p>
<p>The data should be given in tabulated format. That is the number of observations 
and person-years are represented for each stratum.
Note that also individual data is allowed as long as each observations, 
person-years, and print and adjust variables are presented in columns.
The extra variables and levels are reduced automatically before estimating SIRs. 
Example of data format:
</p>

<table>
<tr>
 <td style="text-align: right;">
  sex </td><td style="text-align: right;"> age </td><td style="text-align: right;"> period </td><td style="text-align: right;"> obs </td><td style="text-align: right;"> pyrs </td>
</tr>
<tr>
 <td style="text-align: right;">
  0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 2010 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 390 </td>
</tr>
<tr>
 <td style="text-align: right;">
  0 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 2010 </td><td style="text-align: right;"> 5 </td><td style="text-align: right;"> 385 </td>
</tr>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 2010 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 308 </td>
</tr>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 2010 </td><td style="text-align: right;"> 12 </td><td style="text-align: right;"> 315
</td>
</tr>

</table>



<h3>Value</h3>

<p>A sir-object that is a <code>data.table</code> with meta information in the attributes.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen, Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexpand">lexpand</a></code>
<a href="../doc/sir.html">A SIR calculation vignette</a>
</p>
<p>Other sir functions: 
<code><a href="#topic+lines.sirspline">lines.sirspline</a>()</code>,
<code><a href="#topic+plot.sirspline">plot.sirspline</a>()</code>,
<code><a href="#topic+sir_exp">sir_exp</a>()</code>,
<code><a href="#topic+sir_ratio">sir_ratio</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(popmort)
data(sire)
c &lt;- lexpand( sire, status = status, birth = bi_date, exit = ex_date, entry = dg_date,
              breaks = list(per = 1950:2013, age = 1:100, fot = c(0,10,20,Inf)), 
              aggre = list(fot, agegroup = age, year = per, sex) )
## SMR due other causes: status = 2
se &lt;- sir( coh.data = c, coh.obs = 'from0to2', coh.pyrs = 'pyrs', 
           ref.data = popmort, ref.rate = 'haz', 
           adjust = c('agegroup', 'year', 'sex'), print = 'fot')
se
## for examples see: vignette('sir')


</code></pre>

<hr>
<h2 id='sir_exp'>Calculate SMR</h2><span id='topic+sir_exp'></span><span id='topic+sir_lex'></span><span id='topic+sir_ag'></span>

<h3>Description</h3>

<p>Calculate Standardized Mortality Ratios (SMRs) using 
a single data set that includes
observed and expected cases and additionally person-years.
</p>
<p><code>sir_lex</code> solves SMR from a <code><a href="Epi.html#topic+Lexis">Lexis</a></code> object 
calculated with <code>lexpand</code>.
</p>
<p><code>sir_ag</code> solves SMR from a <code><a href="#topic+aggre">aggre</a></code> object 
calculated using <code><a href="#topic+lexpand">lexpand</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir_exp(
  x,
  obs,
  exp,
  pyrs = NULL,
  print = NULL,
  conf.type = "profile",
  test.type = "homogeneity",
  conf.level = 0.95,
  subset = NULL
)

sir_lex(x, print = NULL, breaks = NULL, ...)

sir_ag(
  x,
  obs = "from0to1",
  print = attr(x, "aggre.meta")$by,
  exp = "d.exp",
  pyrs = "pyrs",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sir_exp_+3A_x">x</code></td>
<td>
<p>Data set e.g. <code>aggre</code> or <code>Lexis</code> object 
(see: <code><a href="#topic+lexpand">lexpand</a></code>)</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_obs">obs</code></td>
<td>
<p>Variable name of the observed cases in the data set</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_exp">exp</code></td>
<td>
<p>Variable name or expression for expected cases</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_pyrs">pyrs</code></td>
<td>
<p>Variable name for person-years (optional)</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_print">print</code></td>
<td>
<p>Variables or expression to stratify the results</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_conf.type">conf.type</code></td>
<td>
<p>select confidence interval type: (default=) 'profile', 'wald', 'univariate'</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_test.type">test.type</code></td>
<td>
<p>Test for equal SIRs. Test available are 'homogeneity' and 'trend'</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of type-I error in confidence intervals, default 0.05 is 95% CI</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_subset">subset</code></td>
<td>
<p>a logical vector for subsetting data</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_breaks">breaks</code></td>
<td>
<p>a named list to split age group (age), period (per) or follow-up (fot).</p>
</td></tr>
<tr><td><code id="sir_exp_+3A_...">...</code></td>
<td>
<p>pass arguments to <code>sir_exp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are intended to calculate SMRs from a single data set 
that includes both observed and expected number of cases. For example utilizing the
argument <code>pop.haz</code> of the <code><a href="#topic+lexpand">lexpand</a></code>.
</p>
<p><code>sir_lex</code> automatically exports the transition <code>fromXtoY</code> using the first
state in <code>lex.Str</code> as <code>0</code> and all other as <code>1</code>. No missing values
is allowed in observed, pop.haz or person-years.
</p>


<h3>Value</h3>

<p>A sir object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sir_lex()</code>: 
</p>
</li>
<li> <p><code>sir_ag()</code>: 
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexpand">lexpand</a></code>
<a href="../doc/sir.html">A SIR calculation vignette</a>
</p>
<p>Other sir functions: 
<code><a href="#topic+lines.sirspline">lines.sirspline</a>()</code>,
<code><a href="#topic+plot.sirspline">plot.sirspline</a>()</code>,
<code><a href="#topic+sir_ratio">sir_ratio</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

BL &lt;- list(fot = 0:5, per = c("2003-01-01","2008-01-01", "2013-01-01"))

## Aggregated data
x1 &lt;- lexpand(sire, breaks = BL, status = status != 0, 
              birth = bi_date, entry = dg_date, exit = ex_date,
              pophaz=popmort,
              aggre=list(sex, period = per, surv.int = fot))
sir_ag(x1, print = 'period')


# no aggreate or breaks
x2 &lt;- lexpand(sire, status = status != 0, 
              birth = bi_date, entry = dg_date, exit = ex_date,
              pophaz=popmort)
sir_lex(x2, breaks = BL, print = 'per')


</code></pre>

<hr>
<h2 id='sir_ratio'>Confidence intervals for the ratio of two SIRs/SMRs</h2><span id='topic+sir_ratio'></span>

<h3>Description</h3>

<p>Calculate ratio of two SIRs/SMRs and the confidence intervals of the ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sir_ratio(
  x,
  y,
  digits = 3,
  alternative = "two.sided",
  conf.level = 0.95,
  type = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sir_ratio_+3A_x">x</code></td>
<td>
<p>a sir-object or a vector of two; observed and expected cases.</p>
</td></tr>
<tr><td><code id="sir_ratio_+3A_y">y</code></td>
<td>
<p>a sir-object or a vector of two; observed and expected cases.</p>
</td></tr>
<tr><td><code id="sir_ratio_+3A_digits">digits</code></td>
<td>
<p>number of digits in the output</p>
</td></tr>
<tr><td><code id="sir_ratio_+3A_alternative">alternative</code></td>
<td>
<p>The null-hypothesis test: (default:) <code>two.sided</code>, <code>less</code>, <code>greater</code></p>
</td></tr>
<tr><td><code id="sir_ratio_+3A_conf.level">conf.level</code></td>
<td>
<p>the type-I error in confidence intervals, default 0.95 for 95% CI.</p>
</td></tr>
<tr><td><code id="sir_ratio_+3A_type">type</code></td>
<td>
<p>How the binomial confidence intervals are calculated (default:) <code>exact</code> or <code>asymptotic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function works with pooled sir-objects i.e. the <code>print</code> argument in <code>sir</code> is ignored.
Also <code>x</code> and <code>y</code> can be a vector of two where first index is the
observed cases and second is expected cases (see examples).
Note that the ratio of two SIR's is only applicable when the age distributions are similar
in both populations.
</p>
<p><strong>Formula</strong>
</p>
<p>The observed number of first sir <code>O1</code> is considered as a Binomial variable with sample 
size of <code>O1+O2</code>. The confidence intervals for Binomial proportion <code>A</code> 
is solved using <code>exact</code> or <code>asymptotic</code> 
method. Now the CI for ratio <code>O1/O2</code> is <code>B = A/(1 - A)</code>. And further the CI for SIR/SMR 
is B*E2/E1. (Ederer and Mantel)
</p>


<h3>Value</h3>

<p>A vector length of three: sir_ratio, and lower and upper confidence intervals.
</p>


<h3>Note</h3>

<p>Parameter <code>alternative</code> is always <code>two.sided</code> when parameter 
<code>type</code> is set to <code>asymptotic</code>.
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen
</p>


<h3>References</h3>

<p>Statistics with Confidence: Confidence Intervals and Statistical Guidelines, 
Douglas Altman, 2000. ISBN: 978-0-727-91375-3
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sir">sir</a></code>
<a href="../doc/sir.html">A SIR calculation vignette</a>
</p>
<p>Other sir functions: 
<code><a href="#topic+lines.sirspline">lines.sirspline</a>()</code>,
<code><a href="#topic+plot.sirspline">plot.sirspline</a>()</code>,
<code><a href="#topic+sir_exp">sir_exp</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Ratio for sir-object and the same values given manually:


## create example dataset
dt1 &lt;- data.frame(obs = rep(c(5,7), 10),
                  pyrs = rep(c(250,300,350,400), 5),
                  var = 1:20)
Ref &lt;- data.frame(obs = rep(c(50,70,80,100), 5),
                 pyrs = rep(c(2500,3000,3500,4000), 5),
                 var = 1:20)
## sir using the function
s1 &lt;- sir(coh.data = dt1, coh.obs = obs, coh.pyrs = pyrs, 
          ref.data = Ref, ref.obs = obs, ref.pyrs = pyrs,
          adjust = var)

## Ratio is simply 1:
sir_ratio(s1, c(120, 150))

</code></pre>

<hr>
<h2 id='sire'>sire - a simulated cohort of Finnish female rectal cancer patients</h2><span id='topic+sire'></span>

<h3>Description</h3>

<p><code>sire</code> is a simulated cohort pertaining female Finnish rectal cancer patients
diagnosed between 1993-2012. Instead of actual original dates, the dates are masked
via modest randomization within several time windows.
</p>


<h3>Format</h3>

<p>data.table with columns
</p>

<ul>
<li><p> sex - gender of the patient (1 = female)
</p>
</li>
<li><p> bi_date - date of birth
</p>
</li>
<li><p> dg_date - date of cancer diagnosis
</p>
</li>
<li><p> ex_date - date of exit from follow-up (death or censoring)
</p>
</li>
<li><p> status  - status of the person at exit; 0 alive; 1 dead due to pertinent cancer; 2 dead due to other causes
</p>
</li>
<li><p> dg_age  - age at diagnosis expressed as fractional years
</p>
</li></ul>



<h3>Details</h3>

<p>The closing date for the pertinent data was 2012-12-31, meaning status information was
available only up to that point &mdash; hence the maximum possible <code>ex_date</code> is <code>2012-12-31</code>.
</p>


<h3>Author(s)</h3>

<p>Karri Seppa
</p>


<h3>Source</h3>

<p>The Finnish Cancer Registry
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>
<p>Other survival data: 
<code><a href="#topic+sibr">sibr</a></code>
</p>

<hr>
<h2 id='sirspline'>Estimate splines for SIR or SMR</h2><span id='topic+sirspline'></span>

<h3>Description</h3>

<p>Splines for standardised incidence or mortality ratio. A useful 
tool to e.g. check whether a constant SIR can be assumed for all calendar periods,
age groups or follow-up intervals. Splines can be fitted for these time dimensions
separately or in the same model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirspline(
  coh.data,
  coh.obs,
  coh.pyrs,
  ref.data = NULL,
  ref.obs = NULL,
  ref.pyrs = NULL,
  ref.rate = NULL,
  subset = NULL,
  print = NULL,
  adjust = NULL,
  mstate = NULL,
  spline,
  knots = NULL,
  reference.points = NULL,
  dependent.splines = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirspline_+3A_coh.data">coh.data</code></td>
<td>
<p>cohort data with observations and at risk time variables</p>
</td></tr>
<tr><td><code id="sirspline_+3A_coh.obs">coh.obs</code></td>
<td>
<p>variable name for observed cases</p>
</td></tr>
<tr><td><code id="sirspline_+3A_coh.pyrs">coh.pyrs</code></td>
<td>
<p>variable name for person-years in cohort data</p>
</td></tr>
<tr><td><code id="sirspline_+3A_ref.data">ref.data</code></td>
<td>
<p>aggregated population data</p>
</td></tr>
<tr><td><code id="sirspline_+3A_ref.obs">ref.obs</code></td>
<td>
<p>variable name for observed cases</p>
</td></tr>
<tr><td><code id="sirspline_+3A_ref.pyrs">ref.pyrs</code></td>
<td>
<p>variable name for person-years in population data</p>
</td></tr>
<tr><td><code id="sirspline_+3A_ref.rate">ref.rate</code></td>
<td>
<p>population rate observed/expected. This overwrites the parameters
<code>ref.pyrs</code> and <code>ref.obs</code>.</p>
</td></tr>
<tr><td><code id="sirspline_+3A_subset">subset</code></td>
<td>
<p>logical condition to subset <code>coh.data</code> before any computations</p>
</td></tr>
<tr><td><code id="sirspline_+3A_print">print</code></td>
<td>
<p>variable names for which to estimate SIRs/SMRs and 
associated splines separately</p>
</td></tr>
<tr><td><code id="sirspline_+3A_adjust">adjust</code></td>
<td>
<p>variable names for adjusting the expected cases</p>
</td></tr>
<tr><td><code id="sirspline_+3A_mstate">mstate</code></td>
<td>
<p>set column names for cause specific observations. Relevant only
when coh.obs length is two or more. See help for <code>sir</code>.</p>
</td></tr>
<tr><td><code id="sirspline_+3A_spline">spline</code></td>
<td>
<p>variable name(s) for the splines</p>
</td></tr>
<tr><td><code id="sirspline_+3A_knots">knots</code></td>
<td>
<p>number knots (vector),  pre-defined knots (list of vectors) or for optimal number of knots left NULL</p>
</td></tr>
<tr><td><code id="sirspline_+3A_reference.points">reference.points</code></td>
<td>
<p>fixed reference values for rate ratios. If left <code>NULL</code>
the smallest value is the reference point (where SIR = 1). 
Ignored if <code>dependent.splines = FALSE</code></p>
</td></tr>
<tr><td><code id="sirspline_+3A_dependent.splines">dependent.splines</code></td>
<td>
<p>logical; if TRUE, all splines are fitted in same model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+sir">sir</a></code> for help on SIR/SMR estimation in general; usage of splines
is discussed below.
</p>
<p><strong>The spline variables</strong>
</p>
<p>The model can include one, two or three splines variables.
Variables can be included in the same model selecting <code>dependent.splines = TRUE</code>
and SIR ratios are calculated (first one is the SIR, others SIR ratios). 
Reference points vector can be set via <code>reference.points</code>
where first element of the vector is the reference point for first ratio.
</p>
<p>Variable(s) to fit splines are given as a vector in argument <code>spline</code>.
Order will affect the results.
</p>
<p><strong>dependent.splines</strong> 
</p>
<p>By default dependent.splines is FALSE and all splines are fitted in separate models. 
If TRUE, the first variable in <code>spline</code> is a function of a SIR and other(s) are ratios.
</p>
<p><strong>knots</strong>
</p>
<p>There are three options to set knots to splines:
</p>
<p>Set the number of knots for each spline variable with a <strong>vector</strong>. 
The knots are automatically placed to the quantiles of observed cases in cohort data. 
The first and last knots are always the maximum and minimum values, so knot
value needs to be at least two.
</p>
<p>Predefined knot places can be set with a <strong>list</strong> of vectors.
The vector for each spline in the list specifies the knot places. The lowest 
and the largest values are the boundary knots and these should be checked beforehand.
</p>
<p>If <code>knots</code> is left <strong>NULL</strong>, the model searches the optimal number 
of knots by model AIC by fitting models iteratively from 2 to 15 knots and 
the one with smallest AIC is selected.
If <code>dependent.splines = TRUE</code>, the number of knots is searched by fitting each spline
variable separately.
</p>
<p><strong>print</strong>
</p>
<p>Splines can be stratified by the levels of variable given in <code>print</code>. If 
<code>print</code> is a vector, only the first variable is accounted for. The knots 
are placed globally for all levels of <code>print</code>. This also ensures that the likelihood 
ratio test is valid.
Splines are also fitted independently for each level of <code>print</code>.
This allows for searching interactions, e.g. by fitting spline for period 
(<code>splines='period'</code>) for each age group (<code>print = 'agegroup'</code>).
</p>
<p><strong>p-values</strong>
</p>
<p>The output p-value is a test of whether the splines are equal (homogenous)
at different levels of <code>print</code>. 
The test is based on the likelihood ratio test, where the full model 
includes <code>print</code> and is 
compared to a null model without it.
When <code>(dependent.splines = TRUE)</code> the p-value returned is a global p-value.
Otherwise the p-value is spline-specific.
</p>


<h3>Value</h3>

<p>A list of data.frames and vectors.
Three spline estimates are named as <code>spline.est.A/B/C</code> and the corresponding values
in <code>spline.seq.A/B/C</code> for manual plotting
</p>


<h3>Author(s)</h3>

<p>Matti Rantanen, Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitMulti">splitMulti</a></code> 
<a href="../doc/sir.html">A SIR calculation vignette</a>
</p>
<p>Other sir functions: 
<code><a href="#topic+lines.sirspline">lines.sirspline</a>()</code>,
<code><a href="#topic+plot.sirspline">plot.sirspline</a>()</code>,
<code><a href="#topic+sir_exp">sir_exp</a>()</code>,
<code><a href="#topic+sir_ratio">sir_ratio</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## for examples see: vignette('sir')

</code></pre>

<hr>
<h2 id='splitLexisDT'>Split case-level observations</h2><span id='topic+splitLexisDT'></span>

<h3>Description</h3>

<p>Split a <code>Lexis</code> object along one time scale
(as <code><a href="Epi.html#topic+splitLexis">splitLexis</a></code>) with speed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitLexisDT(lex, breaks, timeScale, merge = TRUE, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitLexisDT_+3A_lex">lex</code></td>
<td>
<p>a Lexis object, split or not</p>
</td></tr>
<tr><td><code id="splitLexisDT_+3A_breaks">breaks</code></td>
<td>
<p>a vector of <code>[a,b)</code> breaks to split <code>data</code> by</p>
</td></tr>
<tr><td><code id="splitLexisDT_+3A_timescale">timeScale</code></td>
<td>
<p>a character string; name of the time scale to split by</p>
</td></tr>
<tr><td><code id="splitLexisDT_+3A_merge">merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, retains all variables 
from the original data - i.e. original variables are
repeated for all the rows by original subject</p>
</td></tr>
<tr><td><code id="splitLexisDT_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops all resulting rows 
after expansion that reside outside the time window
defined by the given breaks</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitLexisDT</code> is in essence a <span class="pkg">data.table</span> version of
<code>splitLexis</code> or <code>survSplit</code> for splitting along a single
time scale. It requires a Lexis object as input, which may have already
been split along some time scale.
</p>
<p>Unlike <code>splitLexis</code>, <code>splitLexisDT</code> drops observed time outside
the roof and floor of <code>breaks</code> by default - with <code>drop = FALSE</code>
the functions have identical behaviour.
</p>
<p>The <code>Lexis</code> time scale variables can be of any arbitrary 
format, e.g. <code>Date</code>,
fractional years (see <code><a href="Epi.html#topic+cal.yr">cal.yr</a></code>) and <code><a href="#topic+get.yrs">get.yrs</a></code>,
or other. However, using <code>date</code> variables (from package <span class="pkg">date</span>)
are not recommended, as <code>date</code> variables are always stored as integers,
whereas <code>Date</code> variables (see <code>?as.Date</code>) are typically stored
in double (&quot;numeric&quot;) format. This allows for breaking days into fractions
as well, when using e.g. hypothetical years of 365.25 days.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code> 
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>) 
object expanded to accommodate split observations.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other splitting functions: 
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+splitMulti">splitMulti</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Epi)
data("sire", package = "popEpi")
x &lt;- Lexis(data=sire[1000:1100, ], 
           entry = list(fot=0, per=get.yrs(dg_date), age=dg_age), 
           exit=list(per=get.yrs(ex_date)), exit.status=status)
BL &lt;- list(fot=seq(0, 5, by = 3/12), per=c(2008, 2013))

x2 &lt;- splitMulti(x, breaks = BL, drop = FALSE)

x3 &lt;- splitLexisDT(x, breaks = BL$fot, timeScale = "fot", drop = FALSE)
x3 &lt;- splitLexisDT(x3, breaks = BL$per, timeScale = "per", drop = FALSE)

x4 &lt;- splitLexis(x,  breaks = BL$fot, time.scale = "fot")
x4 &lt;- splitLexis(x4, breaks = BL$per, time.scale = "per")
## all produce identical results

## using Date variables
x &lt;- Lexis(data=sire[1000:1100, ], 
           entry = list(fot=0, per=dg_date, age=dg_date-bi_date), 
           exit=list(per=ex_date), exit.status=status)
BL &lt;- list(fot = 0:5*365.25, per = as.Date(c("2008-01-01", "2013-01-01")))

x2 &lt;- splitMulti(x, breaks = BL, drop = FALSE)

x3 &lt;- splitLexisDT(x, breaks = BL$fot, timeScale = "fot", drop = FALSE)
x3 &lt;- splitLexisDT(x3, breaks = BL$per, timeScale = "per", drop = FALSE)

## splitLexis may not work when using Dates
</code></pre>

<hr>
<h2 id='splitMulti'>Split case-level observations</h2><span id='topic+splitMulti'></span>

<h3>Description</h3>

<p>Split a <code>Lexis</code> object along multiple time scales
with speed and ease
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitMulti(
  data,
  breaks = NULL,
  ...,
  drop = TRUE,
  merge = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitMulti_+3A_data">data</code></td>
<td>
<p>a Lexis object with event cases as rows</p>
</td></tr>
<tr><td><code id="splitMulti_+3A_breaks">breaks</code></td>
<td>
<p>a list of named numeric vectors of breaks; see Details and Examples</p>
</td></tr>
<tr><td><code id="splitMulti_+3A_...">...</code></td>
<td>
<p>alternate way of supplying breaks as named vectors;
e.g. <code>fot = 0:5</code> instead of <code>breaks = list(fot = 0:5)</code>;
if <code>breaks</code> is not <code>NULL</code>, <code>breaks</code> is used and any breaks
passed through <code>...</code> are NOT used; note also that due to partial 
matching of argument names in R, 
if you supply e.g. <code>dat = my_breaks</code> and you 
do not pass argument <code>data</code> explicitly (<code>data = my_data</code>), then R
interprets this as <code>data = my_breaks</code> &mdash; so choose the names of your
time scales wisely</p>
</td></tr>
<tr><td><code id="splitMulti_+3A_drop">drop</code></td>
<td>
<p>logical; if <code>TRUE</code>, drops all resulting rows 
after expansion that reside outside the time window
defined by the given breaks</p>
</td></tr>
<tr><td><code id="splitMulti_+3A_merge">merge</code></td>
<td>
<p>logical; if <code>TRUE</code>, retains all variables 
from the original data - i.e. original variables are
repeated for all the rows by original subject</p>
</td></tr>
<tr><td><code id="splitMulti_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty 
and returns some messages along the way</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitMulti</code> is in essence a <span class="pkg">data.table</span> version of
<code>splitLexis</code> or <code>survSplit</code> for splitting along multiple
time scales.
It requires a Lexis object as input.
</p>
<p>The <code>breaks</code> must be a list of named vectors of the appropriate type. 
The breaks are fully explicit and
left-inclusive and right exclusive, e.g. <code>fot=c(0,5)</code> 
forces the data to only include time between
<code>[0,5)</code> for each original row (unless <code>drop = FALSE</code>). 
Use <code>Inf</code> or <code>-Inf</code> for open-ended intervals,
e.g. <code>per=c(1990,1995,Inf)</code> creates the intervals 
<code>[1990,1995), [1995, Inf)</code>.
</p>
<p>Instead of specifying <code>breaks</code>, one may make use of the <code>...</code>
argument to pass breaks: e.g. 
</p>
<p><code>splitMulti(x, breaks = list(fot = 0:5))</code> 
</p>
<p>is equivalent to
</p>
<p><code>splitMulti(x, fot = 0:5)</code>.
</p>
<p>Multiple breaks can be supplied in the same manner. However, if both
<code>breaks</code> and <code>...</code> are used, only the breaks in <code>breaks</code>
are utilized within the function. 
</p>
<p>The <code>Lexis</code> time scale variables can be of any arbitrary 
format, e.g. <code>Date</code>,
fractional years (see <code><a href="Epi.html#topic+cal.yr">cal.yr</a></code>) and <code><a href="#topic+get.yrs">get.yrs</a></code>,
or other. However, using <code>date</code> variables (from package <span class="pkg">date</span>)
are not recommended, as <code>date</code> variables are always stored as integers,
whereas <code>Date</code> variables (see <code>?as.Date</code>) are typically stored
in double (&quot;numeric&quot;) format. This allows for breaking days into fractions
as well, when using e.g. hypothetical years of 365.25 days.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> or <code>data.frame</code> 
(depending on <code>options("popEpi.datatable")</code>; see <code>?popEpi</code>) 
object expanded to accommodate split observations.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p><code><a href="Epi.html#topic+splitLexis">splitLexis</a></code>, <code><a href="Epi.html#topic+Lexis">Lexis</a></code>,  
<code><a href="survival.html#topic+survSplit">survSplit</a></code>
</p>
<p>Other splitting functions: 
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+splitLexisDT">splitLexisDT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### let's prepare data for computing period method survivals
#### in case there are problems with dates, we first 
#### convert to fractional years.

library("Epi")
library("data.table")
data("sire", package = "popEpi")
x &lt;- Lexis(data=sire[dg_date &lt; ex_date, ], 
           entry = list(fot=0, per=get.yrs(dg_date), age=dg_age), 
           exit=list(per=get.yrs(ex_date)), exit.status=status)
x2 &lt;- splitMulti(x, breaks = list(fot=seq(0, 5, by = 3/12), per=c(2008, 2013)))
# equivalently:
x2 &lt;- splitMulti(x, fot=seq(0, 5, by = 3/12), per=c(2008, 2013))

## using dates; note: breaks must be expressed as dates or days!
x &lt;- Lexis(data=sire[dg_date &lt; ex_date, ], 
           entry = list(fot=0, per=dg_date, age=dg_date-bi_date), 
           exit=list(per=ex_date), exit.status=status)
BL &lt;- list(fot = seq(0, 5, by = 3/12)*365.242199,
           per = as.Date(paste0(c(1980:2014),"-01-01")),
           age = c(0,45,85,Inf)*365.242199)
x2 &lt;- splitMulti(x, breaks = BL, verbose=TRUE)


## multistate example (healty - sick - dead)
sire2 &lt;- data.frame(sire)
sire2 &lt;- sire2[sire2$dg_date &lt; sire2$ex_date, ]

set.seed(1L) 
not_sick &lt;- sample.int(nrow(sire2), 6000L, replace = FALSE)
sire2$dg_date[not_sick] &lt;- NA
sire2$status[!is.na(sire2$dg_date) &amp; sire2$status == 0] &lt;- -1

sire2$status[sire2$status==2] &lt;- 1
sire2$status &lt;- factor(sire2$status, levels = c(0, -1, 1), 
                       labels = c("healthy", "sick", "dead"))
 
xm &lt;- Lexis(data = sire2, 
            entry = list(fot=0, per=get.yrs(bi_date), age=0), 
            exit = list(per=get.yrs(ex_date)), exit.status=status)
xm2 &lt;- cutLexis(xm, cut = get.yrs(xm$dg_date), 
                timescale = "per", 
                new.state = "sick")
xm2[xm2$lex.id == 6L, ]

xm2 &lt;- splitMulti(xm2, breaks = list(fot = seq(0,150,25)))
xm2[xm2$lex.id == 6L, ]


</code></pre>

<hr>
<h2 id='stdpop101'>World standard population by 1 year age groups from 1 to 101. Sums to 100 000.</h2><span id='topic+stdpop101'></span>

<h3>Description</h3>

<p>World standard population by 1 year age groups from 1 to 101. Sums to 100 000.
</p>


<h3>Format</h3>

<p>data.table with columns
</p>

<ul>
<li> <p><code>world_std</code> weight that sums to 100000 (numeric)
</p>
</li>
<li> <p><code>agegroup</code> age group from 1 to 101 (numeric)
</p>
</li></ul>



<h3>Source</h3>

<p>Standard population is from:
<a href="https://seer.cancer.gov/stdpopulations/stdpop.singleages.html">world standard population &quot;101of1&quot;</a>
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>
<p>Other weights: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+direct_standardization">direct_standardization</a></code>,
<code><a href="#topic+stdpop18">stdpop18</a></code>
</p>

<hr>
<h2 id='stdpop18'>Standard populations from 2000: world, Europe and Nordic.</h2><span id='topic+stdpop18'></span>

<h3>Description</h3>

<p>World, European, and Nordic standard populations by 18 age categories. 
Sums to 100000.
</p>


<h3>Format</h3>

<p>data.table with columns
</p>

<ul>
<li> <p><code>agegroup</code>, age group in 18 categories (character)
</p>
</li>
<li> <p><code>world</code>, World 2000 standard population (numeric)
</p>
</li>
<li> <p><code>europe</code>, European standard population (numeric)
</p>
</li>
<li> <p><code>nordic</code>, Nordic standard population (numeric)
</p>
</li></ul>



<h3>Source</h3>

<p>Nordcan, 2000
</p>


<h3>See Also</h3>

<p>Other popEpi data: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+meanpop_fi">meanpop_fi</a></code>,
<code><a href="#topic+popmort">popmort</a></code>,
<code><a href="#topic+sibr">sibr</a></code>,
<code><a href="#topic+sire">sire</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>
</p>
<p>Other weights: 
<code><a href="#topic+ICSS">ICSS</a></code>,
<code><a href="#topic+direct_standardization">direct_standardization</a></code>,
<code><a href="#topic+stdpop101">stdpop101</a></code>
</p>

<hr>
<h2 id='summary.aggre'>Summarize an <code>aggre</code> Object</h2><span id='topic+summary.aggre'></span>

<h3>Description</h3>

<p><code>summary</code> method function for <code>aggre</code> objects; see
<code><a href="#topic+as.aggre">as.aggre</a></code> and <code><a href="#topic+aggre">aggre</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aggre'
summary(object, by = NULL, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.aggre_+3A_object">object</code></td>
<td>
<p>an <code>aggre</code> object</p>
</td></tr>
<tr><td><code id="summary.aggre_+3A_by">by</code></td>
<td>
<p>list of columns to summarize by - e.g. <code>list(V1, V2)</code>
where <code>V1</code> and <code>V2</code> are columns in the data.</p>
</td></tr>
<tr><td><code id="summary.aggre_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset results table by
before summarizing; use this to limit to a certain stratum. E.g.
<code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="summary.aggre_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 'data.table' &mdash; a further aggregated version of 'object'.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other aggregation functions: 
<code><a href="#topic+aggre">aggre</a>()</code>,
<code><a href="#topic+as.aggre">as.aggre</a>()</code>,
<code><a href="#topic+lexpand">lexpand</a>()</code>,
<code><a href="#topic+setaggre">setaggre</a>()</code>
</p>

<hr>
<h2 id='summary.survtab'>Summarize a survtab Object</h2><span id='topic+summary.survtab'></span>

<h3>Description</h3>

<p>Summary method function for <code>survtab</code> objects; see
<code><a href="#topic+survtab_ag">survtab_ag</a></code>. Returns estimates at given time points
or all time points if <code>t</code> and <code>q</code> are both <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survtab'
summary(object, t = NULL, subset = NULL, q = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.survtab_+3A_object">object</code></td>
<td>
<p>a <code>survtab</code> object</p>
</td></tr>
<tr><td><code id="summary.survtab_+3A_t">t</code></td>
<td>
<p>a vector of times at which time points (actually intervals that
contain t) to print summary table of survival function estimates by strata;
values not existing in any interval cause rows containing only <code>NAs</code> to
be returned.</p>
</td></tr>
<tr><td><code id="summary.survtab_+3A_subset">subset</code></td>
<td>
<p>a logical condition to subset results table by
before printing; use this to limit to a certain stratum. E.g.
<code>subset = sex == "male"</code></p>
</td></tr>
<tr><td><code id="summary.survtab_+3A_q">q</code></td>
<td>
<p>a named <code>list</code> of quantiles to include in returned data set,
where names must match to estimates in <code>object</code>;
returns intervals where the quantiles are reached first;
e.g. <code>list(surv.obs = 0.5)</code> finds the interval where <code>surv.obs</code>
is 0.45 and 0.55 at the beginning and end of the interval, respectively;
returns rows with <code>NA</code> values for quantiles not reached in estimates
(e.g. if <code>q = list(surv.obs = 0.5)</code> but lowest estimate is 0.6);
see Examples.</p>
</td></tr>
<tr><td><code id="summary.survtab_+3A_...">...</code></td>
<td>
<p>unused; required for congruence with other <code>summary</code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function returns the intervals and NOT the time points
corresponding to quantiles / estimates corresponding to time points.
If you want precise estimates at time points that are not interval breaks,
add the time points as breaks and re-estimate the survival time function.
In interval-based estimation, the estimates denote e.g. probability of 
dying <em>during</em> the interval, so time points within the intervals
are not usually considered at all. See e.g. Seppa, Dyba, and Hakulinen 
(2015).
</p>


<h3>Value</h3>

<p>A 'data.table': a slice from 'object' based on 't', 'subset', and 'q'.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>References</h3>

<p>Seppa K., Dyba T. and Hakulinen T.: Cancer Survival, 
Reference Module in Biomedical Sciences. Elsevier. 08-Jan-2015.
<a href="https://doi.org/10.1016/B978-0-12-801238-3.02745-8">doi:10.1016/B978-0-12-801238-3.02745-8</a>
</p>


<h3>See Also</h3>

<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Epi)

## NOTE: recommended to use factor status variable
x &lt;- Lexis(entry = list(FUT = 0, AGE = dg_age, CAL = get.yrs(dg_date)), 
           exit = list(CAL = get.yrs(ex_date)), 
           data = sire[sire$dg_date &lt; sire$ex_date, ],
           exit.status = factor(status, levels = 0:2, 
           labels = c("alive", "canD", "othD")), 
           merge = TRUE)
## pretend some are male
set.seed(1L)
x$sex &lt;- rbinom(nrow(x), 1, 0.5)
## observed survival
st &lt;- survtab(Surv(time = FUT, event = lex.Xst) ~ sex, data = x, 
                  surv.type = "cif.obs",
                  breaks = list(FUT = seq(0, 5, 1/12)))

## estimates at full years of follow-up
summary(st, t = 1:5)

## interval estimate closest to 75th percentile, i.e.
## first interval where surv.obs &lt; 0.75 at end
## (just switch 0.75 to 0.5 for median survival, etc.)
summary(st, q = list(surv.obs = 0.75))
## multiple quantiles
summary(st, q = list(surv.obs = c(0.75, 0.90), CIF_canD = 0.20))

## if you want all estimates in a new data.frame, you can also simply do

x &lt;- as.data.frame(st)
</code></pre>

<hr>
<h2 id='Surv'>Survival Objects</h2><span id='topic+Surv'></span>

<h3>Description</h3>

<p>Wrapper for <a href="survival.html#topic+Surv">survival::Surv</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Surv(
  time,
  time2,
  event,
  type = c("right", "left", "interval", "counting", "interval2", "mstate"),
  origin = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Surv_+3A_time">time</code></td>
<td>
<p>see  <a href="survival.html#topic+Surv">survival::Surv</a></p>
</td></tr>
<tr><td><code id="Surv_+3A_time2">time2</code></td>
<td>
<p>see  <a href="survival.html#topic+Surv">survival::Surv</a></p>
</td></tr>
<tr><td><code id="Surv_+3A_event">event</code></td>
<td>
<p>see  <a href="survival.html#topic+Surv">survival::Surv</a></p>
</td></tr>
<tr><td><code id="Surv_+3A_type">type</code></td>
<td>
<p>see  <a href="survival.html#topic+Surv">survival::Surv</a></p>
</td></tr>
<tr><td><code id="Surv_+3A_origin">origin</code></td>
<td>
<p>see <a href="survival.html#topic+Surv">survival::Surv</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code style="white-space: pre;">&#8288;[survival::Surv]&#8288;</code>.
</p>


<h3>Surv in survival vs. in popEpi</h3>

<p><code>popEpi::Surv</code> is a wrapper for <a href="survival.html#topic+Surv">survival::Surv</a>.
Therefore you don't need to to do <code>library("survival")</code> when using <code>Surv</code>
with e.g.
<code><a href="#topic+survtab">survtab</a></code>. Remember that if you do <code>library("survival")</code> after
<code>library("popEpi")</code>, the <code>Surv</code> from <span class="pkg">survival</span> is used instead of
from <span class="pkg">popEpi</span> (<code>R</code> throws a warning about this) when an expression
such as <code>Surv(my_times, my_events)</code> is evaluated. You can avoid such
conflicts by writing e.g. <code>popEpi::Surv(my_times, my_events)</code> instead.
However, <code>popEpi::Surv</code> is designed in such a way that this should not
become a problem and you should be able to use the two interchangeably.
</p>


<h3>See Also</h3>

<p>Other main functions: 
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other survtab functions: 
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other survmean functions: 
<code><a href="#topic+lines.survmean">lines.survmean</a>()</code>,
<code><a href="#topic+plot.survmean">plot.survmean</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>
</p>

<hr>
<h2 id='survmean'>Compute Mean Survival Times Using Extrapolation</h2><span id='topic+survmean'></span>

<h3>Description</h3>

<p>Computes mean survival times based on survival estimation up to
a point in follow-up time (e.g. 10 years), 
after which survival is extrapolated
using an appropriate hazard data file (<code>pophaz</code>) to yield the &quot;full&quot;
survival curve. The area under the full survival curve is the mean survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survmean(
  formula,
  data,
  adjust = NULL,
  weights = NULL,
  breaks = NULL,
  pophaz = NULL,
  e1.breaks = NULL,
  e1.pophaz = pophaz,
  r = "auto",
  surv.method = "hazard",
  subset = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survmean_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code>, e.g. <code>FUT ~ V1</code> or 
<code>Surv(FUT, lex.Xst) ~ V1</code>.
Supplied in the same way as to <code><a href="#topic+survtab">survtab</a></code>, see that help
for more info.</p>
</td></tr>
<tr><td><code id="survmean_+3A_data">data</code></td>
<td>
<p>a <code>Lexis</code> data set; see <code><a href="Epi.html#topic+Lexis">Lexis</a></code>.</p>
</td></tr>
<tr><td><code id="survmean_+3A_adjust">adjust</code></td>
<td>
<p>variables to adjust estimates by, e.g. <code>adjust = "agegr"</code>.
<a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survmean_+3A_weights">weights</code></td>
<td>
<p>weights to use to adjust mean survival times. See the
<a href="#topic+direct_standardization">dedicated help page</a> for more details on 
weighting. <code>survmean</code>
computes curves separately by all variables to adjust by, computes mean
survival times, and computes weighted means of the mean survival times.
See Examples.</p>
</td></tr>
<tr><td><code id="survmean_+3A_breaks">breaks</code></td>
<td>
<p>a list of breaks defining the time window to compute 
observed survival in, and the intervals used in estimation. E.g.
<code>list(FUT = 0:10)</code> when <code>FUT</code> is the follow-up time scale in your
data.</p>
</td></tr>
<tr><td><code id="survmean_+3A_pophaz">pophaz</code></td>
<td>
<p>a data set of population hazards passed to 
<code><a href="#topic+survtab">survtab</a></code> (see the 
<a href="#topic+pophaz">dedicated help page</a> and the help page of
<code>survtab</code> for more information). Defines the 
population hazard in the time window where observed survival is estimated.</p>
</td></tr>
<tr><td><code id="survmean_+3A_e1.breaks">e1.breaks</code></td>
<td>
<p><code>NULL</code> or a list of breaks defining the time 
window to compute 
<strong>expected</strong> survival in, and the intervals used in estimation. E.g.
<code>list(FUT = 0:100)</code> when <code>FUT</code> is the follow-up time scale in your
data to extrapolate up to 100 years from where the observed survival
curve ends. <strong>NOTE:</strong> the breaks on the survival time scale
MUST include the breaks supplied to argument <code>breaks</code>; see Examples.
If <code>NULL</code>, uses decent defaults (maximum follow-up time of 50 years).</p>
</td></tr>
<tr><td><code id="survmean_+3A_e1.pophaz">e1.pophaz</code></td>
<td>
<p>Same as <code>pophaz</code>, except this defines the 
population hazard in the time window where <strong>expected</strong> 
survival is estimated. By default uses the same data as 
argument <code>pophaz</code>.</p>
</td></tr>
<tr><td><code id="survmean_+3A_r">r</code></td>
<td>
<p>either a numeric multiplier such as <code>0.995</code>, <code>"auto"</code>, or
<code>"autoX"</code> where <code>X</code> is an integer;
used to determine the relative survival ratio (RSR) persisting after where 
the estimated observed survival curve ends. See Details.</p>
</td></tr>
<tr><td><code id="survmean_+3A_surv.method">surv.method</code></td>
<td>
<p>passed to <code>survtab</code>; see that help for more info.</p>
</td></tr>
<tr><td><code id="survmean_+3A_subset">subset</code></td>
<td>
<p>a logical condition; e.g. <code>subset = sex == 1</code>; 
subsets the data before computations</p>
</td></tr>
<tr><td><code id="survmean_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, the function is returns
some messages and results along the run, which may be useful in debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Basics</strong>
</p>
<p><code>survmean</code> computes mean survival times. For median survival times
(i.e. where 50 
use <code><a href="#topic+survtab">survtab</a></code>.
</p>
<p>The mean survival time is simply the area under the survival curve.
However, since full follow-up rarely happens, the observed survival curves
are extrapolated using expected survival: E.g. one might compute observed
survival till up to 10 years and extrapolate beyond that 
(till e.g. 50 years) to yield an educated guess on the full observed survival
curve. 
</p>
<p>The area is computed by trapezoidal integration of the area under the curve.
This function also computes the &quot;full&quot; expected survival curve from
T = 0 till e.g. T = 50 depending on supplied arguments. The
expected mean survival time is the area under the 
mean expected survival curve.
This function returns the mean expected survival time to be compared with 
the mean survival time and for computing years of potential life lost (YPLL).
</p>
<p>Results can be formed by strata and adjusted for e.g. age by using
the <code>formula</code> argument as in <code>survtab</code>. See also Examples.
</p>
<p><strong>Extrapolation tweaks</strong>
</p>
<p>Argument <code>r</code> controls the relative survival ratio (RSR) assumed to
persist beyond the time window where observed survival is computed
(defined by argument <code>breaks</code>; e.g. up to <code>FUT = 10</code>).
The RSR is simply <code>RSR_i = p_oi / p_ei</code> for a time interval <code>i</code>, 
i.e. the observed divided by the expected 
(conditional, not cumulative) probability of surviving from the beginning of
a time interval till its end. The cumulative product of <code>RSR_i</code>
over time is the (cumulative) relative survival curve. 
</p>
<p>If <code>r</code> is numeric, e.g. <code>r = 0.995</code>, that RSR level is assumed
to persist beyond the observed survival curve. 
Numeric <code>r</code> should be <code>&gt; 0</code> and expressed at the annual level
when using fractional years as the scale of the time variables.
E.g. if RSR is known to be <code>0.95</code> at the month level, then the
annualized RSR is <code>0.95^12</code>. This enables correct usage of the RSR
with survival intervals of varying lengths. When using day-level time 
variables (such as <code>Dates</code>; see <code>as.Date</code>), numeric <code>r</code>
should be expressed at the day level, etc.
</p>
<p>If <code>r = "auto"</code> or <code>r = "auto1"</code>, this function computes
RSR estimates internally and automatically uses the <code>RSR_i</code>
in the last survival interval in each stratum (and adjusting group)
and assumes that to persist beyond the observed survival curve.
Automatic determination of <code>r</code> is a good starting point,
but in situations where the RSR estimate is uncertain it may produce poor
results. Using <code>"autoX"</code> such as <code>"auto6"</code> causes <code>survmean</code>
to use the mean of the estimated RSRs in the last X survival intervals, 
which may be more stable.
Automatic determination will not use values <code>&gt;1</code> but set them to 1. 
Visual inspection of the produced curves is always recommended: see
Examples.
</p>
<p>One may also tweak the accuracy and length of extrapolation and 
expected survival curve computation by using 
<code>e1.breaks</code>. By default this is whatever was supplied to <code>breaks</code>
for the survival time scale, to which
</p>
<p><code>c(seq(1/12, 1, 1/12), seq(1.2, 1.8, 0.2), 2:19, seq(20, 50, 5))</code>
</p>
<p>is added after the maximum value, e.g. with <code>breaks = list(FUT = 0:10)</code>
we have 
</p>
<p><code>..., 10+1/12, ..., 11, 11.2, ..., 2, 3, ..., 19, 20, 25, ... 50</code>
</p>
<p>as the <code>e1.breaks</code>. Supplying <code>e1.breaks</code> manually requires
the breaks over time survival time scale supplied to argument <code>breaks</code>
to be reiterated in <code>e1.breaks</code>; see Examples. <strong>NOTE</strong>: the
default extrapolation breaks assume the time scales in the data to be 
expressed as fractional years, meaning this will work extremely poorly
when using e.g. day-level time scales (such as <code>Date</code> variables). 
Set the extrapolation breaks manually in such cases.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> or <code>data.table</code> (depending on 
<code>getOptions("popEpi.datatable")</code>; see <code>?popEpi</code>) containing the
following columns:
</p>

<ul>
<li><p>est: The estimated mean survival time
</p>
</li>
<li><p>exp: The computed expected survival time
</p>
</li>
<li><p>obs: Counts of subjects in data
</p>
</li>
<li><p>YPLL: Years of Potential Life Lost, computed as 
(<code>(exp-est)*obs</code>) - though your time data may be in e.g. days,
this column will have the same name regardless.
</p>
</li></ul>

<p>The returned data also has columns named according to the variables
supplied to the right-hand-side of the formula.
</p>


<h3>Author(s)</h3>

<p>Joonas Miettinen
</p>


<h3>See Also</h3>

<p>Other survmean functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survmean">lines.survmean</a>()</code>,
<code><a href="#topic+plot.survmean">plot.survmean</a>()</code>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Epi)
## take 500 subjects randomly for demonstration
data(sire)
sire &lt;- sire[sire$dg_date &lt; sire$ex_date, ]
set.seed(1L)
sire &lt;- sire[sample(x = nrow(sire), size = 500),]

## NOTE: recommended to use factor status variable
x &lt;- Lexis(entry = list(FUT = 0, AGE = dg_age, CAL = get.yrs(dg_date)),
           exit = list(CAL = get.yrs(ex_date)),
           data = sire,
           exit.status = factor(status, levels = 0:2,
                                labels = c("alive", "canD", "othD")),
           merge = TRUE)

## phony variable
set.seed(1L)
x$group &lt;- rbinom(nrow(x), 1, 0.5)
## age group
x$agegr &lt;- cut(x$dg_age, c(0,45,60,Inf), right=FALSE)

## population hazards data  set
pm &lt;- data.frame(popEpi::popmort)
names(pm) &lt;- c("sex", "CAL", "AGE", "haz")

## breaks to define observed survival estimation
BL &lt;- list(FUT = seq(0, 10, 1/12))

## crude mean survival
sm1 &lt;- survmean(Surv(FUT, lex.Xst != "alive") ~ 1,
                pophaz = pm, data = x, weights = NULL,
                breaks = BL)
                
sm1 &lt;- survmean(FUT ~ 1,
                pophaz = pm, data = x, weights = NULL,
                breaks = BL)             

## mean survival by group                 
sm2 &lt;- survmean(FUT ~ group,
                pophaz = pm, data = x, weights = NULL,
                breaks = BL)
                
## ... and adjusted for age using internal weights (counts of subjects)      
## note: need also longer extrapolation here so that all curves
## converge to zero in the end.
eBL &lt;- list(FUT = c(BL$FUT, 11:75))
sm3 &lt;- survmean(FUT ~ group + adjust(agegr),
                pophaz = pm, data = x, weights = "internal",
                breaks = BL, e1.breaks = eBL)

## visual inspection of how realistic extrapolation is for each stratum;
## solid lines are observed + extrapolated survivals;
## dashed lines are expected survivals
plot(sm1)

## plotting object with both stratification and standardization
## plots curves for each strata-std.group combination
plot(sm3)

## for finer control of plotting these curves, you may extract
## from the survmean object using e.g.
attributes(sm3)$survmean.meta$curves


#### using Dates

x &lt;- Lexis(entry = list(FUT = 0L, AGE = dg_date-bi_date, CAL = dg_date),
           exit = list(CAL = ex_date),
           data = sire[sire$dg_date &lt; sire$ex_date, ],
           exit.status = factor(status, levels = 0:2, 
                                labels = c("alive", "canD", "othD")), 
           merge = TRUE)
## phony group variable
set.seed(1L)
x$group &lt;- rbinom(nrow(x), 1, 0.5)

                  
## NOTE: population hazard should be reported at the same scale
## as time variables in your Lexis data.
data(popmort, package = "popEpi")
pm &lt;- data.frame(popmort)
names(pm) &lt;- c("sex", "CAL", "AGE", "haz")
## from year to day level
pm$haz &lt;- pm$haz/365.25 
pm$CAL &lt;- as.Date(paste0(pm$CAL, "-01-01")) 
pm$AGE &lt;- pm$AGE*365.25 

BL &lt;- list(FUT = seq(0, 8, 1/12)*365.25)
eBL &lt;- list(FUT = c(BL$FUT, c(8.25,8.5,9:60)*365.25))
smd &lt;- survmean(FUT ~ group, data = x, 
                pophaz = pm, verbose = TRUE, r = "auto5",
                breaks = BL, e1.breaks = eBL)     
plot(smd)



</code></pre>

<hr>
<h2 id='survtab'>Estimate Survival Time Functions</h2><span id='topic+survtab'></span>

<h3>Description</h3>

<p>This function estimates survival time functions: survival, 
relative/net survival, and crude/absolute risk functions (CIF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survtab(
  formula,
  data,
  adjust = NULL,
  breaks = NULL,
  pophaz = NULL,
  weights = NULL,
  surv.type = "surv.rel",
  surv.method = "hazard",
  relsurv.method = "e2",
  subset = NULL,
  conf.level = 0.95,
  conf.type = "log-log",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survtab_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code>; e.g. <code>fot ~ sex</code>,
where <code>fot</code> is the time scale over which you wish to estimate a
survival time function; this
assumes that <code>lex.Xst</code> in your data is the status variable in the
intended format (almost always right). 
To be explicit, use <code><a href="survival.html#topic+Surv">Surv</a></code>: e.g. 
<code>Surv(fot, lex.Xst) ~ sex</code>. 
Variables on the right-hand side of the formula
separated by <code>+</code> are considered stratifying variables, for which 
estimates are computed separately. May contain usage of <code>adjust()</code> 
&mdash; see Details and Examples.</p>
</td></tr>
<tr><td><code id="survtab_+3A_data">data</code></td>
<td>
<p>a <code>Lexis</code> object with at least the survival time scale</p>
</td></tr>
<tr><td><code id="survtab_+3A_adjust">adjust</code></td>
<td>
<p>can be used as an alternative to passing variables to 
argument <code>formula</code> within a call to <code>adjust()</code>; e.g.
<code>adjust = "agegr"</code>. <a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survtab_+3A_breaks">breaks</code></td>
<td>
<p>a named list of breaks, e.g.
<code>list(FUT = 0:5)</code>. If data is not split in advance, <code>breaks</code>
must at the very least contain a vector of breaks to split the survival time 
scale (mentioned in argument <code>formula</code>). If data has already been split
(using e.g. <code><a href="#topic+splitMulti">splitMulti</a></code>) along at least the used survival time
scale, this may be <code>NULL</code>. It is generally recommended (and sufficient; 
see Seppa, Dyban and Hakulinen (2015)) to use monthly
intervals where applicable.</p>
</td></tr>
<tr><td><code id="survtab_+3A_pophaz">pophaz</code></td>
<td>
<p>a <code>data.frame</code> containing
expected hazards for the event of interest to occur. See the
<a href="#topic+pophaz">dedicated help page</a>. Required when
<code>surv.type = "surv.rel"</code> or <code>"cif.rel"</code>. <code>pophaz</code> must
contain one column named <code>"haz"</code>, and any number of other columns
identifying levels of variables to do a merge with split data within
<code>survtab</code>. Some columns may be time scales, which will
allow for the expected hazard to vary by e.g. calendar time and age.</p>
</td></tr>
<tr><td><code id="survtab_+3A_weights">weights</code></td>
<td>
<p>typically a list of weights or a <code>character</code> string
specifying an age group standardization scheme; see
the <a href="#topic+direct_standardization">dedicated help page</a> 
and examples. NOTE: <code>weights = "internal"</code> is based on the counts
of persons in follow-up at the start of follow-up (typically T = 0)</p>
</td></tr>
<tr><td><code id="survtab_+3A_surv.type">surv.type</code></td>
<td>
<p>one of <code>'surv.obs'</code>,
<code>'surv.cause'</code>, <code>'surv.rel'</code>, 
<code>'cif.obs'</code> or <code>'cif.rel'</code>; 
defines what kind of survival time function(s) is/are estimated; see Details</p>
</td></tr>
<tr><td><code id="survtab_+3A_surv.method">surv.method</code></td>
<td>
<p>either <code>'lifetable'</code> or <code>'hazard'</code>; determines
the method of calculating survival time functions, where the former computes
ratios such as <code>p = d/(n - n.cens)</code> 
and the latter utilizes subject-times 
(typically person-years) for hazard estimates such as <code>d/pyrs</code> 
which are used to compute survival time function estimates.
The former method requires argument <code>n.cens</code> and the latter 
argument <code>pyrs</code> to be supplied.</p>
</td></tr>
<tr><td><code id="survtab_+3A_relsurv.method">relsurv.method</code></td>
<td>
<p>either <code>'e2'</code> or <code>'pp'</code>; 
defines whether to compute relative survival using the
EdererII method or using Pohar-Perme weighting;
ignored if <code>surv.type != "surv.rel"</code></p>
</td></tr>
<tr><td><code id="survtab_+3A_subset">subset</code></td>
<td>
<p>a logical condition; e.g. <code>subset = sex == 1</code>; 
subsets the data before computations</p>
</td></tr>
<tr><td><code id="survtab_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level used in confidence intervals; 
e.g. <code>0.95</code> for 95 percent confidence intervals</p>
</td></tr>
<tr><td><code id="survtab_+3A_conf.type">conf.type</code></td>
<td>
<p>character string; must be one of <code>"plain"</code>, 
<code>"log-log"</code> and <code>"log"</code>; 
defines the transformation used on the survival time
function to yield confidence 
intervals via the delta method</p>
</td></tr>
<tr><td><code id="survtab_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty and
returns some messages and timings along the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table of life time function values and other 
information with survival intervals as rows.
Returns some of the following estimates of survival time functions:
</p>

<ul>
<li> <p><code>surv.obs</code> - observed (raw, overall) survival
</p>
</li>
<li> <p><code>surv.obs.K</code> - observed cause-specific survival for cause K
</p>
</li>
<li> <p><code>CIF_k</code> - cumulative incidence function for cause <code>k</code>
</p>
</li>
<li> <p><code>CIF.rel</code> - cumulative incidence function using excess cases
</p>
</li>
<li> <p><code>r.e2</code> -  relative survival, EdererII
</p>
</li>
<li> <p><code>r.pp</code> -  relative survival, Pohar-Perme weighted
</p>
</li></ul>

<p>The suffix <code>.as</code> implies adjusted estimates, and <code>.lo</code> and
<code>.hi</code> imply lower and upper confidence limits, respectively. 
The prefix <code>SE.</code> stands for standard error.
</p>


<h3>Basics</h3>

<p>This function computes interval-based estimates of survival time functions,
where the intervals are set by the user. For product-limit-based
estimation see packages <span class="pkg">survival</span> and <span class="pkg">relsurv</span>.
</p>
<p>if <code>surv.type = 'surv.obs'</code>, only 'raw' observed survival 
is estimated over the chosen time intervals. With
<code>surv.type = 'surv.rel'</code>, also relative survival estimates 
are supplied in addition to observed survival figures. 
</p>
<p><code>surv.type = 'cif.obs'</code> requests cumulative incidence functions (CIF) 
to be estimated. 
CIFs are estimated for each competing risk based 
on a survival-interval-specific proportional hazards
assumption as described by Chiang (1968).  
With <code>surv.type = 'cif.rel'</code>, a CIF is estimated with using 
excess cases as the &rdquo;cause-specific&rdquo; cases. Finally, with 
<code>surv.type = 'surv.cause'</code>, cause-specific survivals are 
estimated separately for each separate type of event. 
</p>
<p>In hazard-based estimation (<code>surv.method = "hazard"</code>) survival
time functions are transformations of the estimated corresponding hazard
in the intervals. The hazard itself is estimated using counts of events
(or excess events) and total subject-time in the interval. Life table
<code>surv.method = "lifetable"</code> estimates are constructed as transformations 
of probabilities computed using counts of events and counts of subjects 
at risk.
</p>
<p>The vignette <a href="../doc/survtab_examples.html">survtab_examples</a> 
has some practical examples.
</p>


<h3>Relative survival</h3>

<p>When <code>surv.type = 'surv.rel'</code>, the user can choose 
<code>relsurv.method = 'pp'</code>, whereupon Pohar-Perme weighting is used.
By default <code>relsurv.method = 'e2'</code>, i.e. the Ederer II method
is used to estimate relative survival.
</p>


<h3>Adjusted estimates</h3>

<p>Adjusted estimates in this context mean computing estimates separately
by the levels of adjusting variables and returning weighted averages
of the estimates. For example, computing estimates separately by
age groups and returning a weighted average estimate (age-adjusted estimate).
</p>
<p>Adjusting requires specification of both the adjusting variables and
the weights for all the levels of the adjusting variables. The former can be
accomplished by using <code>adjust()</code> with the argument <code>formula</code>,
or by supplying variables directly to argument <code>adjust</code>. E.g. the
following are all equivalent:
</p>
<p><code>formula = fot ~ sex + adjust(agegr) + adjust(area)</code>
</p>
<p><code>formula = fot ~ sex + adjust(agegr, area)</code>
</p>
<p><code>formula  = fot ~ sex, adjust = c("agegr", "area")</code>
</p>
<p><code>formula  = fot ~ sex, adjust = list(agegr, area)</code>
</p>
<p>The adjusting variables must match with the variable names in the
argument <code>weights</code>;
see the <a href="#topic+direct_standardization">dedicated help page</a>. 
Typically weights are supplied as a <code>list</code> or
a <code>data.frame</code>. The former can be done by e.g.
</p>
<p><code>weights = list(agegr = VEC1, area = VEC2)</code>,
</p>
<p>where <code>VEC1</code> and <code>VEC2</code> are vectors of weights (which do not
have to add up to one). See 
<a href="../doc/survtab_examples.html">survtab_examples</a> 
for an example of using a <code>data.frame</code> to pass weights.
</p>


<h3>Period analysis and other data selection schemes</h3>

<p>To calculate e.g. period analysis (delayed entry) estimates, 
limit the data when/before supplying to this function.See 
<a href="../doc/survtab_examples.html">survtab_examples</a>.
</p>


<h3>References</h3>

<p>Perme, Maja Pohar, Janez Stare, and Jacques Esteve. 
&quot;On estimation in relative survival.&quot; Biometrics 68.1 (2012): 113-120.
<a href="https://doi.org/10.1111/j.1541-0420.2011.01640.x">doi:10.1111/j.1541-0420.2011.01640.x</a>
</p>
<p>Hakulinen, Timo, Karri Seppa, and Paul C. Lambert. 
&quot;Choosing the relative survival method for cancer survival estimation.&quot; 
European Journal of Cancer 47.14 (2011): 2202-2210.
<a href="https://doi.org/10.1016/j.ejca.2011.03.011">doi:10.1016/j.ejca.2011.03.011</a>
</p>
<p>Seppa, Karri, Timo Hakulinen, and Arun Pokhrel. 
&quot;Choosing the net survival method for cancer survival estimation.&quot; 
European Journal of Cancer (2013).
<a href="https://doi.org/10.1016/j.ejca.2013.09.019">doi:10.1016/j.ejca.2013.09.019</a>
</p>
<p>CHIANG, Chin Long. Introduction to stochastic processes in biostatistics. 
1968. ISBN-14: 978-0471155003
</p>
<p>Seppa K., Dyba T. and Hakulinen T.: Cancer Survival, 
Reference Module in Biomedical Sciences. Elsevier. 08-Jan-2015.
<a href="https://doi.org/10.1016/B978-0-12-801238-3.02745-8">doi:10.1016/B978-0-12-801238-3.02745-8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitMulti">splitMulti</a></code>, <code><a href="#topic+lexpand">lexpand</a></code>, 
<code><a href="#topic+ICSS">ICSS</a></code>, <code><a href="#topic+sire">sire</a></code>
<a href="../doc/survtab_examples.html">The survtab_examples vignette</a>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>
</p>
<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab_ag">survtab_ag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sire", package = "popEpi")
library(Epi)

## NOTE: recommended to use factor status variable
x &lt;- Lexis(entry = list(FUT = 0, AGE = dg_age, CAL = get.yrs(dg_date)), 
           exit = list(CAL = get.yrs(ex_date)), 
           data = sire[sire$dg_date &lt; sire$ex_date, ],
           exit.status = factor(status, levels = 0:2, 
                                labels = c("alive", "canD", "othD")), 
           merge = TRUE)

## phony group variable
set.seed(1L)
x$group &lt;- rbinom(nrow(x), 1, 0.5)

## observed survival. explicit supplying of status:
st &lt;- survtab(Surv(time = FUT, event = lex.Xst) ~ group, data = x, 
              surv.type = "surv.obs",
              breaks = list(FUT = seq(0, 5, 1/12)))
## this assumes the status is lex.Xst (right 99.9 % of the time)
st &lt;- survtab(FUT ~ group, data = x, 
              surv.type = "surv.obs",
              breaks = list(FUT = seq(0, 5, 1/12)))
              
## relative survival (ederer II)
data("popmort", package = "popEpi")
pm &lt;- data.frame(popmort)
names(pm) &lt;- c("sex", "CAL", "AGE", "haz")
st &lt;- survtab(FUT ~ group, data = x, 
              surv.type = "surv.rel",
              pophaz = pm,
              breaks = list(FUT = seq(0, 5, 1/12)))

## ICSS weights usage
data("ICSS", package = "popEpi")
cut &lt;- c(0, 30, 50, 70, Inf)
agegr &lt;- cut(ICSS$age, cut, right = FALSE)
w &lt;- aggregate(ICSS1~agegr, data = ICSS, FUN = sum)
x$agegr &lt;- cut(x$dg_age, cut, right = FALSE)
st &lt;- survtab(FUT ~ group + adjust(agegr), data = x, 
              surv.type = "surv.rel",
              pophaz = pm, weights = w$ICSS1,
              breaks = list(FUT = seq(0, 5, 1/12)))

#### using dates with survtab
x &lt;- Lexis(entry = list(FUT = 0L, AGE = dg_date-bi_date, CAL = dg_date),
           exit = list(CAL = ex_date),
           data = sire[sire$dg_date &lt; sire$ex_date, ],
           exit.status = factor(status, levels = 0:2, 
                                labels = c("alive", "canD", "othD")), 
           merge = TRUE)
## phony group variable
set.seed(1L)
x$group &lt;- rbinom(nrow(x), 1, 0.5)

st &lt;- survtab(Surv(time = FUT, event = lex.Xst) ~ group, data = x, 
              surv.type = "surv.obs",
              breaks = list(FUT = seq(0, 5, 1/12)*365.25))    
                  
## NOTE: population hazard should be reported at the same scale
## as time variables in your Lexis data.
data(popmort, package = "popEpi")
pm &lt;- data.frame(popmort)
names(pm) &lt;- c("sex", "CAL", "AGE", "haz")
## from year to day level
pm$haz &lt;- pm$haz/365.25 
pm$CAL &lt;- as.Date(paste0(pm$CAL, "-01-01")) 
pm$AGE &lt;- pm$AGE*365.25 

st &lt;- survtab(Surv(time = FUT, event = lex.Xst) ~ group, data = x, 
              surv.type = "surv.rel", relsurv.method = "e2",
              pophaz = pm,
              breaks = list(FUT = seq(0, 5, 1/12)*365.25))  

</code></pre>

<hr>
<h2 id='survtab_ag'>Estimate Survival Time Functions</h2><span id='topic+survtab_ag'></span>

<h3>Description</h3>

<p>This function estimates survival time functions: survival, 
relative/net survival, and crude/absolute risk functions (CIF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survtab_ag(
  formula = NULL,
  data,
  adjust = NULL,
  weights = NULL,
  surv.breaks = NULL,
  n = "at.risk",
  d = "from0to1",
  n.cens = "from0to0",
  pyrs = "pyrs",
  d.exp = "d.exp",
  n.pp = NULL,
  d.pp = "d.pp",
  d.pp.2 = "d.pp.2",
  n.cens.pp = "n.cens.pp",
  pyrs.pp = "pyrs.pp",
  d.exp.pp = "d.exp.pp",
  surv.type = "surv.rel",
  surv.method = "hazard",
  relsurv.method = "e2",
  subset = NULL,
  conf.level = 0.95,
  conf.type = "log-log",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survtab_ag_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code>; the response 
must be the time scale to compute survival time function estimates
over, e.g. <code>fot ~ sex</code>. Variables on the right-hand side of the formula
separated by <code>+</code> are considered stratifying variables, for which 
estimates are computed separately. May contain usage of <code>adjust()</code> 
&mdash; see Details and Examples.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_data">data</code></td>
<td>
<p>since popEpi 0.4.0, a <code>data.frame</code>
containing variables used in <code>formula</code> and other arguments.
<code>aggre</code> objects are recommended as they contain information on any
time scales and are therefore safer; for creating <code>aggre</code> objects see
<code><a href="#topic+as.aggre">as.aggre</a></code> when your data is already aggregated and <code>aggre</code>
for aggregating split <code>Lexis</code> objects.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_adjust">adjust</code></td>
<td>
<p>can be used as an alternative to passing variables to 
argument <code>formula</code> within a call to <code>adjust()</code>; e.g.
<code>adjust = "agegr"</code>. <a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_weights">weights</code></td>
<td>
<p>typically a list of weights or a <code>character</code> string
specifying an age group standardization scheme; see
the <a href="#topic+direct_standardization">dedicated help page</a> 
and examples. NOTE: <code>weights = "internal"</code> is based on the counts
of persons in follow-up at the start of follow-up (typically T = 0)</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_surv.breaks">surv.breaks</code></td>
<td>
<p>a vector of breaks on the 
survival time scale. Optional if <code>data</code> is an <code>aggre</code> object
and mandatory otherwise. Must define each intended interval;
e.g. <code>surv.breaks = 0:5</code> when data has intervals defined by 
breaks <code>seq(0, 5, 1/12)</code> will aggregate to wider intervals first.
It is generally recommended (and sufficient; 
see Seppa, Dyban and Hakulinen (2015)) to use monthly
intervals where applicable.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_n">n</code></td>
<td>
<p>variable containing counts of subjects at-risk at the start of a 
time interval; e.g. <code>n = "at.risk"</code>. 
Required when <code>surv.method = "lifetable"</code>.
<a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_d">d</code></td>
<td>
<p>variable(s) containing counts of subjects experiencing an event. 
With only one type of event, e.g. <code>d = "deaths"</code>. With multiple types of 
events (for CIF or cause-specific survival estimation), supply e.g.
<code>d = c("canD", "othD")</code>. If the survival time function to be estimated
does not use multiple types of events, supplying more than one variable
to <code>d</code> simply causes the variables to be added together. 
Always required. <a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_n.cens">n.cens</code></td>
<td>
<p>variable containing counts of subjects censored during a 
survival time interval; E.g. <code>n.cens = "alive"</code>.
Required when <code>surv.method = "lifetable"</code>. 
<a href="#topic+flexible_argument">Flexible input</a>.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_pyrs">pyrs</code></td>
<td>
<p>variable containing total subject-time accumulated within a 
survival time interval; E.g. <code>pyrs = "pyrs"</code>. 
Required when <code>surv.method = "hazard"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_d.exp">d.exp</code></td>
<td>
<p>variable denoting total &quot;expected numbers of events&quot; 
(typically computed <code>pyrs * pop.haz</code>, where 
<code>pop.haz</code> is the expected hazard level) 
accumulated within a survival time interval; E.g. <code>pyrs = "pyrs"</code>.
Required when computing EdererII relative survivals or 
CIFs based on excess counts of events. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_n.pp">n.pp</code></td>
<td>
<p>variable containing total Pohar-Perme weighted counts of
subjects at risk in an interval,
supplied as argument <code>n</code> is supplied. 
Computed originally on the subject
level as analogous to <code>pp * as.integer(status == "at-risk")</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_d.pp">d.pp</code></td>
<td>
<p>variable(s) containing Pohar-Perme weighted counts of events,
supplied as argument <code>d</code> is supplied. Computed originally on the subject
level as analogous to <code>pp * as.integer(status == some_event)</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_d.pp.2">d.pp.2</code></td>
<td>
<p>variable(s) containing total Pohar-Perme 
&quot;double-weighted&quot; counts of events,
supplied as argument <code>d</code> is supplied. Computed originally on the subject
level as analogous to <code>pp * pp * as.integer(status == some_event)</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_n.cens.pp">n.cens.pp</code></td>
<td>
<p>variable containing total Pohar-Perme weighted counts 
censorings,
supplied as argument <code>n.cens</code> is supplied. 
Computed originally on the subject
level as analogous to <code>pp * as.integer(status == "censored")</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_pyrs.pp">pyrs.pp</code></td>
<td>
<p>variable containing total Pohar-Perme weighted subject-times,
supplied as argument <code>pyrs</code> is supplied. 
Computed originally on the subject
level as analogous to <code>pp * pyrs</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_d.exp.pp">d.exp.pp</code></td>
<td>
<p>variable containing total Pohar-Perme weighted counts 
of excess events,
supplied as argument <code>pyrs</code> is supplied. 
Computed originally on the subject
level as analogous to <code>pp * d.exp</code>.
Required when <code>relsurv.method = "pp"</code>. Flexible input.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_surv.type">surv.type</code></td>
<td>
<p>one of <code>'surv.obs'</code>,
<code>'surv.cause'</code>, <code>'surv.rel'</code>, 
<code>'cif.obs'</code> or <code>'cif.rel'</code>; 
defines what kind of survival time function(s) is/are estimated; see Details</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_surv.method">surv.method</code></td>
<td>
<p>either <code>'lifetable'</code> or <code>'hazard'</code>; determines
the method of calculating survival time functions, where the former computes
ratios such as <code>p = d/(n - n.cens)</code> 
and the latter utilizes subject-times 
(typically person-years) for hazard estimates such as <code>d/pyrs</code> 
which are used to compute survival time function estimates.
The former method requires argument <code>n.cens</code> and the latter 
argument <code>pyrs</code> to be supplied.</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_relsurv.method">relsurv.method</code></td>
<td>
<p>either <code>'e2'</code> or <code>'pp'</code>; 
defines whether to compute relative survival using the
EdererII method or using Pohar-Perme weighting;
ignored if <code>surv.type != "surv.rel"</code></p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_subset">subset</code></td>
<td>
<p>a logical condition; e.g. <code>subset = sex == 1</code>; 
subsets the data before computations</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level used in confidence intervals; 
e.g. <code>0.95</code> for 95 percent confidence intervals</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_conf.type">conf.type</code></td>
<td>
<p>character string; must be one of <code>"plain"</code>, 
<code>"log-log"</code> and <code>"log"</code>; 
defines the transformation used on the survival time
function to yield confidence 
intervals via the delta method</p>
</td></tr>
<tr><td><code id="survtab_ag_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, the function is chatty and
returns some messages and timings along the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a table of life time function values and other 
information with survival intervals as rows.
Returns some of the following estimates of survival time functions:
</p>

<ul>
<li> <p><code>surv.obs</code> - observed (raw, overall) survival
</p>
</li>
<li> <p><code>surv.obs.K</code> - observed cause-specific survival for cause K
</p>
</li>
<li> <p><code>CIF_k</code> - cumulative incidence function for cause <code>k</code>
</p>
</li>
<li> <p><code>CIF.rel</code> - cumulative incidence function using excess cases
</p>
</li>
<li> <p><code>r.e2</code> -  relative survival, EdererII
</p>
</li>
<li> <p><code>r.pp</code> -  relative survival, Pohar-Perme weighted
</p>
</li></ul>

<p>The suffix <code>.as</code> implies adjusted estimates, and <code>.lo</code> and
<code>.hi</code> imply lower and upper confidence limits, respectively. 
The prefix <code>SE.</code> stands for standard error.
</p>


<h3>Basics</h3>

<p>This function computes interval-based estimates of survival time functions,
where the intervals are set by the user. For product-limit-based
estimation see packages <span class="pkg">survival</span> and <span class="pkg">relsurv</span>.
</p>
<p>if <code>surv.type = 'surv.obs'</code>, only 'raw' observed survival 
is estimated over the chosen time intervals. With
<code>surv.type = 'surv.rel'</code>, also relative survival estimates 
are supplied in addition to observed survival figures. 
</p>
<p><code>surv.type = 'cif.obs'</code> requests cumulative incidence functions (CIF) 
to be estimated. 
CIFs are estimated for each competing risk based 
on a survival-interval-specific proportional hazards
assumption as described by Chiang (1968).  
With <code>surv.type = 'cif.rel'</code>, a CIF is estimated with using 
excess cases as the &rdquo;cause-specific&rdquo; cases. Finally, with 
<code>surv.type = 'surv.cause'</code>, cause-specific survivals are 
estimated separately for each separate type of event. 
</p>
<p>In hazard-based estimation (<code>surv.method = "hazard"</code>) survival
time functions are transformations of the estimated corresponding hazard
in the intervals. The hazard itself is estimated using counts of events
(or excess events) and total subject-time in the interval. Life table
<code>surv.method = "lifetable"</code> estimates are constructed as transformations 
of probabilities computed using counts of events and counts of subjects 
at risk.
</p>
<p>The vignette <a href="../doc/survtab_examples.html">survtab_examples</a> 
has some practical examples.
</p>


<h3>Relative survival</h3>

<p>When <code>surv.type = 'surv.rel'</code>, the user can choose 
<code>relsurv.method = 'pp'</code>, whereupon Pohar-Perme weighting is used.
By default <code>relsurv.method = 'e2'</code>, i.e. the Ederer II method
is used to estimate relative survival.
</p>


<h3>Adjusted estimates</h3>

<p>Adjusted estimates in this context mean computing estimates separately
by the levels of adjusting variables and returning weighted averages
of the estimates. For example, computing estimates separately by
age groups and returning a weighted average estimate (age-adjusted estimate).
</p>
<p>Adjusting requires specification of both the adjusting variables and
the weights for all the levels of the adjusting variables. The former can be
accomplished by using <code>adjust()</code> with the argument <code>formula</code>,
or by supplying variables directly to argument <code>adjust</code>. E.g. the
following are all equivalent:
</p>
<p><code>formula = fot ~ sex + adjust(agegr) + adjust(area)</code>
</p>
<p><code>formula = fot ~ sex + adjust(agegr, area)</code>
</p>
<p><code>formula  = fot ~ sex, adjust = c("agegr", "area")</code>
</p>
<p><code>formula  = fot ~ sex, adjust = list(agegr, area)</code>
</p>
<p>The adjusting variables must match with the variable names in the
argument <code>weights</code>;
see the <a href="#topic+direct_standardization">dedicated help page</a>. 
Typically weights are supplied as a <code>list</code> or
a <code>data.frame</code>. The former can be done by e.g.
</p>
<p><code>weights = list(agegr = VEC1, area = VEC2)</code>,
</p>
<p>where <code>VEC1</code> and <code>VEC2</code> are vectors of weights (which do not
have to add up to one). See 
<a href="../doc/survtab_examples.html">survtab_examples</a> 
for an example of using a <code>data.frame</code> to pass weights.
</p>


<h3>Period analysis and other data selection schemes</h3>

<p>To calculate e.g. period analysis (delayed entry) estimates, 
limit the data when/before supplying to this function.See 
<a href="../doc/survtab_examples.html">survtab_examples</a>.
</p>


<h3>Data requirements</h3>

<p><code>survtab_ag</code> computes estimates of survival time functions using 
pre-aggregated data. For using subject-level data directly, use 
<code><a href="#topic+survtab">survtab</a></code>. For aggregating data, see <code><a href="#topic+lexpand">lexpand</a></code>
and <code><a href="#topic+aggre">aggre</a></code>. 
</p>
<p>By default, and if data is an <code>aggre</code> object (not mandatory), 
<code>survtab_ag</code> makes use of the exact same breaks that were used in 
splitting the original data (with e.g. <code>lexpand</code>), so it is not 
necessary to specify any <code>surv.breaks</code>. If specified, the 
<code>surv.breaks</code> must be a subset of the pertinent 
pre-existing breaks. When data is not an <code>aggre</code> object, breaks
must always be specified. Interval lengths (<code>delta</code> in output) are 
also calculated based on whichever breaks are used, 
so the upper limit of the breaks should
therefore be meaningful and never e.g. <code>Inf</code>.
</p>


<h3>References</h3>

<p>Perme, Maja Pohar, Janez Stare, and Jacques Esteve. 
&quot;On estimation in relative survival.&quot; Biometrics 68.1 (2012): 113-120.
<a href="https://doi.org/10.1111/j.1541-0420.2011.01640.x">doi:10.1111/j.1541-0420.2011.01640.x</a>
</p>
<p>Hakulinen, Timo, Karri Seppa, and Paul C. Lambert. 
&quot;Choosing the relative survival method for cancer survival estimation.&quot; 
European Journal of Cancer 47.14 (2011): 2202-2210.
<a href="https://doi.org/10.1016/j.ejca.2011.03.011">doi:10.1016/j.ejca.2011.03.011</a>
</p>
<p>Seppa, Karri, Timo Hakulinen, and Arun Pokhrel. 
&quot;Choosing the net survival method for cancer survival estimation.&quot; 
European Journal of Cancer (2013).
<a href="https://doi.org/10.1016/j.ejca.2013.09.019">doi:10.1016/j.ejca.2013.09.019</a>
</p>
<p>CHIANG, Chin Long. Introduction to stochastic processes in biostatistics. 
1968. ISBN-14: 978-0471155003
</p>
<p>Seppa K., Dyba T. and Hakulinen T.: Cancer Survival, 
Reference Module in Biomedical Sciences. Elsevier. 08-Jan-2015.
<a href="https://doi.org/10.1016/B978-0-12-801238-3.02745-8">doi:10.1016/B978-0-12-801238-3.02745-8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitMulti">splitMulti</a></code>, <code><a href="#topic+lexpand">lexpand</a></code>, 
<code><a href="#topic+ICSS">ICSS</a></code>, <code><a href="#topic+sire">sire</a></code>
<a href="../doc/survtab_examples.html">The survtab_examples vignette</a>
</p>
<p>Other main functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+rate">rate</a>()</code>,
<code><a href="#topic+relpois_ag">relpois_ag</a>()</code>,
<code><a href="#topic+relpois">relpois</a>()</code>,
<code><a href="#topic+sirspline">sirspline</a>()</code>,
<code><a href="#topic+sir">sir</a>()</code>,
<code><a href="#topic+survmean">survmean</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>
<p>Other survtab functions: 
<code><a href="#topic+Surv">Surv</a>()</code>,
<code><a href="#topic+lines.survtab">lines.survtab</a>()</code>,
<code><a href="#topic+plot.survtab">plot.survtab</a>()</code>,
<code><a href="#topic+print.survtab">print.survtab</a>()</code>,
<code><a href="#topic+summary.survtab">summary.survtab</a>()</code>,
<code><a href="#topic+survtab">survtab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see more examples with explanations in vignette("survtab_examples")

#### survtab_ag usage

data("sire", package = "popEpi")
## prepare data for e.g. 5-year "period analysis" for 2008-2012
## note: sire is a simulated cohort integrated into popEpi.
BL &lt;- list(fot=seq(0, 5, by = 1/12),
           per = c("2008-01-01", "2013-01-01"))
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date, exit = ex_date,
             status = status %in% 1:2,
             breaks = BL,
             pophaz = popmort,
             aggre = list(fot))
             
## calculate relative EdererII period method
## NOTE: x is an aggre object here, so surv.breaks are deduced
## automatically
st &lt;- survtab_ag(fot ~ 1, data = x)

summary(st, t = 1:5) ## annual estimates
summary(st, q = list(r.e2 = 0.75)) ## 1st interval where r.e2 &lt; 0.75 at end

plot(st)


## non-aggre data: first call to survtab_ag would fail
df &lt;- data.frame(x)
# st &lt;- survtab_ag(fot ~ 1, data = x)
st &lt;- survtab_ag(fot ~ 1, data = x, surv.breaks = BL$fot)

## calculate age-standardised 5-year relative survival ratio using 
## Ederer II method and period approach 

sire$agegr &lt;- cut(sire$dg_age,c(0,45,55,65,75,Inf),right=FALSE)
BL &lt;- list(fot=seq(0, 5, by = 1/12),
           per = c("2008-01-01", "2013-01-01"))
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date, exit = ex_date,
             status = status %in% 1:2,
             breaks = BL,
             pophaz = popmort,
             aggre = list(agegr, fot))

## age standardisation using internal weights (age distribution of 
## patients diagnosed within the period window)
## (NOTE: what is done here is equivalent to using weights = "internal")
w &lt;- aggregate(at.risk ~ agegr, data = x[x$fot == 0], FUN = sum)
names(w) &lt;- c("agegr", "weights")

st &lt;- survtab_ag(fot ~ adjust(agegr), data = x, weights = w)
plot(st, y = "r.e2.as", col = c("blue"))

## age standardisation using ICSS1 weights
data(ICSS)
cut &lt;- c(0, 45, 55, 65, 75, Inf)
agegr &lt;- cut(ICSS$age, cut, right = FALSE)
w &lt;- aggregate(ICSS1~agegr, data = ICSS, FUN = sum)
names(w) &lt;- c("agegr", "weights")

st &lt;- survtab_ag(fot ~ adjust(agegr), data = x, weights = w)
lines(st, y = "r.e2.as", col = c("red"))


## cause-specific survival
sire$stat &lt;- factor(sire$status, 0:2, c("alive", "canD", "othD"))
x &lt;- lexpand(sire, birth = bi_date, entry = dg_date, exit = ex_date,
             status = stat,
             breaks = BL,
             pophaz = popmort,
             aggre = list(agegr, fot))
st &lt;- survtab_ag(fot ~ adjust(agegr), data = x, weights = w,
                 d = c("fromalivetocanD", "fromalivetoothD"),
                 surv.type = "surv.cause")
plot(st, y = "surv.obs.fromalivetocanD.as")
lines(st, y = "surv.obs.fromalivetoothD.as", col = "red")



</code></pre>

<hr>
<h2 id='try2int'>Attempt coercion to integer</h2><span id='topic+try2int'></span>

<h3>Description</h3>

<p>Attempts to convert a numeric object to integer, 
but won't if loss of information is imminent (if values after decimal
are not zero for even one value in <code>obj</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try2int(obj, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try2int_+3A_obj">obj</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="try2int_+3A_tol">tol</code></td>
<td>
<p>tolerance; if each numeric value in <code>obj</code> deviate from
the corresponding integers at most the value of <code>tol</code>, they are considered
to be integers; e.g. by default <code>1 + .Machine$double.eps</code> is considered
to be an integer but <code>1 + .Machine$double.eps^0.49</code> is not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'integer' vector if no information is lost in coercion; else 'numeric' 
vector.
</p>


<h3>Author(s)</h3>

<p>James Arnold
</p>


<h3>Source</h3>

<p><a href="https://stackoverflow.com/questions/3476782/how-to-check-if-the-number-is-integer">Stackoverflow thread</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
