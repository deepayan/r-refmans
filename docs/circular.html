<!DOCTYPE html><html><head><title>Help for package circular</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {circular}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Circular'><p>Package &lsquo;circular&rsquo;: summary information</p></a></li>
<li><a href='#[.circular'><p>Extract or Replace Parts of a Circular Object</p></a></li>
<li><a href='#A1'><p>Ratio of First and Zeroth Order Bessel Functions</p></a></li>
<li><a href='#A1FirstDerivative'><p>First derivative of the Ratio of First and Zeroth Order Bessel Functions.</p></a></li>
<li><a href='#A1inv'><p>Inverse of A1</p></a></li>
<li><a href='#A1SecondDerivative'><p>Second derivative of the Ratio of First and Zeroth Order Bessel Functions.</p></a></li>
<li><a href='#angular.deviation'><p>A measure of deviation for Circular Data</p></a></li>
<li><a href='#angular.variance'><p>A measure of variance for Circular Data</p></a></li>
<li><a href='#aov.circular'><p>Analysis of Variance for circular data</p></a></li>
<li><a href='#arrows.circular'><p>Add Arrows to a Circular Plot</p></a></li>
<li><a href='#as.data.frame.circular'><p>as.data.frame.circular</p></a></li>
<li><a href='#asytriangular'><p>Asymmetric Triangular Density Function</p></a></li>
<li><a href='#axialvonMises'><p>Axial von Mises Density Function</p></a></li>
<li><a href='#axis.circular'><p>Add Axis to a Circular Plot</p></a></li>
<li><a href='#bandwidth'><p>Bandwidth Selectors for Kernel Density Estimation for Circular Data</p></a></li>
<li><a href='#c.circular'><p>A method for circular object, which combines its arguments</p></a></li>
<li><a href='#Cardioid'><p>Cardioid Density Function</p></a></li>
<li><a href='#Carthwrite'><p>Carthwrite's Power-of-Cosine Density Function</p></a></li>
<li><a href='#change.point'><p>Change Point Test</p></a></li>
<li><a href='#circle.control'><p>Auxiliary for Controlling Circular Plots</p></a></li>
<li><a href='#circular'><p>Create Objects of class circular for Circular data.</p></a></li>
<li><a href='#Circular Uniform'><p>Circular Uniform Density Function</p></a></li>
<li><a href='#circular.colors'>
<p>Color Palettes for Circular</p></a></li>
<li><a href='#circularp'><p>Attributes for a Circular Object</p></a></li>
<li><a href='#conversion.circular'><p>Unit of Measure Conversion for Circular Data and other conversions</p></a></li>
<li><a href='#Coope'><p>Coope dataset</p></a></li>
<li><a href='#coord2rad'>
<p>Angles between a vector and the x-axis</p></a></li>
<li><a href='#cor.circular'><p>Correlation Coefficient for Angular Variables</p></a></li>
<li><a href='#curve.circular'><p>Draw Function Plots in a Circle</p></a></li>
<li><a href='#deg'><p>Degrees</p></a></li>
<li><a href='#density.circular'><p>Kernel Density Estimation for Circular Data</p></a></li>
<li><a href='#dist.circular'><p>Distance Matrix Computation for Circular Data</p></a></li>
<li><a href='#equal.kappa.test'><p>Equal Kappa Test</p></a></li>
<li><a href='#fisherB1'><p>B.1 Arrival times at an intensive care unit</p></a></li>
<li><a href='#fisherB10'><p>B.10 Directions of desert ants</p></a></li>
<li><a href='#fisherB11'><p>B.11 Movements of sea stars</p></a></li>
<li><a href='#fisherB12'><p>B.12: Vanishing directions of homing pigeons</p></a></li>
<li><a href='#fisherB13'><p>B.13: Orientations of termite mounds</p></a></li>
<li><a href='#fisherB18'><p>B.18 Wind direction and ozone concentration.</p></a></li>
<li><a href='#fisherB2'><p>B.2 Measurements of long-axis orientation of 133 feldspar laths in basalt</p></a></li>
<li><a href='#fisherB20'><p>B.20 Movements of blue periwinkles.</p></a></li>
<li><a href='#fisherB3'><p>B.3 Movements of turtles</p></a></li>
<li><a href='#fisherB4'><p>B.4 Directional preferences of starhead topminnows</p></a></li>
<li><a href='#fisherB5'><p>B.5 Measurements of long-axis orientation of 164 feldspar laths in basalt</p></a></li>
<li><a href='#fisherB6'><p>B.6 Cross-bed azimuths of palaeocurrents</p></a></li>
<li><a href='#fisherB7'><p>B.7 Movements of ants</p></a></li>
<li><a href='#fisherB8'><p>B.8 Orientations of pebbles</p></a></li>
<li><a href='#fisherB9'><p>B.9 Dance directions of bees</p></a></li>
<li><a href='#GenVonMises'><p>Generalized Von Mises Density Function</p></a></li>
<li><a href='#heatmap.circular'>
<p>Draw a Heat Map for circular data</p></a></li>
<li><a href='#I.0'><p>Zeroth Order Bessel Function of the First Kind</p></a></li>
<li><a href='#I.1'><p>First Order Bessel Function of the First Kind</p></a></li>
<li><a href='#I.p'><p>P-th Order Bessel Function of the First Kind</p></a></li>
<li><a href='#intersect.modal.region'>
<p>Intersection between model region and a given interval.</p></a></li>
<li><a href='#JonesPewsey'><p>Jones and Pewsey Density Function</p></a></li>
<li><a href='#KatoJones'><p>Kato and Jones Density Function</p></a></li>
<li><a href='#kuiper.test'><p>Kuiper's Test</p></a></li>
<li><a href='#lines.circular'><p>Add Connected Line Segments to a Circular Plot</p></a></li>
<li><a href='#lines.density.circular'><p>Add a Plot for Kernel Density Estimation for Circular Data</p></a></li>
<li><a href='#lm.circular'><p>Circular-Circular and Circular-Linear Regression</p></a></li>
<li><a href='#lsfit.circle'><p>Fit a 2D circle to an (x,y) dataset</p></a></li>
<li><a href='#mean.circular'><p>Mean Direction</p></a></li>
<li><a href='#meandeviation'><p>A measure of deviation for Circular Data</p></a></li>
<li><a href='#median.circular'>
<p>Median Direction</p></a></li>
<li><a href='#medianHL.circular'>
<p>Median using Hodges-Lehmann estimate.</p></a></li>
<li><a href='#minusPiPlusPi'>
<p>return angles in the [-pi,pi] interval.</p></a></li>
<li><a href='#mixedvonmises'><p>Mixture of von Mises Distributions</p></a></li>
<li><a href='#mle.vonmises'><p>von Mises Maximum Likelihood Estimates</p></a></li>
<li><a href='#mle.vonmises.bootstrap.ci'><p>Bootstrap Confidence Intervals</p></a></li>
<li><a href='#mle.wrappedcauchy'><p>Wrapped Cauchy Maximum Likelihood Estimates</p></a></li>
<li><a href='#mle.wrappednormal'><p>Wrapped Normal Maximum Likelihood Estimates</p></a></li>
<li><a href='#modal.region'>
<p>Modal regions</p></a></li>
<li><a href='#ncfrog'><p>Northern Cricket Frog</p></a></li>
<li><a href='#pigeons'><p>Initial orientation of displaced homing pigeons</p></a></li>
<li><a href='#plot.circular'><p>Circular Data Plot</p></a></li>
<li><a href='#plot.density.circular'><p>Plot Method for Kernel Density Estimation for Circular Data</p></a></li>
<li><a href='#plot.edf'><p>Plot Circular Empirical Distribution Function</p></a></li>
<li><a href='#plot.lsfit.circle'><p>Plot method for lsfit.circle function</p></a></li>
<li><a href='#points.circular'><p>Add Points to a Circular Plot</p></a></li>
<li><a href='#pp.plot'><p>von Mises Probability-Probability Plot</p></a></li>
<li><a href='#pp.unif.plot'><p>Uniform Circular Probability-Probability Plot</p></a></li>
<li><a href='#projected bivariate normal on the circle'>
<p>Projected bivariate normal on the circle</p></a></li>
<li><a href='#quantile.circular'><p>Sample Circular Quantiles</p></a></li>
<li><a href='#rad'><p>Radians</p></a></li>
<li><a href='#range.circular'><p>Circular Range</p></a></li>
<li><a href='#rao.spacing.test'><p>Rao's Spacing Test of Uniformity</p></a></li>
<li><a href='#rao.table'><p>Table for Rao's Spacing Test of Uniformity</p></a></li>
<li><a href='#rao.test'><p>Rao's Tests for Homogeneity</p></a></li>
<li><a href='#rayleigh.test'><p>Rayleigh Test of Uniformity</p></a></li>
<li><a href='#rho.circular'><p>Mean Resultant Length</p></a></li>
<li><a href='#rose.diag'><p>Rose Diagram</p></a></li>
<li><a href='#rstable'><p>Random Generation from the Stable Family of Distributions</p></a></li>
<li><a href='#rwrappedstable'><p>Random Generation from the Wrapped Stable Distribution</p></a></li>
<li><a href='#sd'><p>Standard Deviation</p></a></li>
<li><a href='#sd.circular'><p>Circular Standard Deviation</p></a></li>
<li><a href='#summary.circular'><p>Circular Summary Statistics</p></a></li>
<li><a href='#swallows'>
<p>Orientation of juvenile barn swallows</p></a></li>
<li><a href='#ticks.circular'><p>Draw Tick-Marks in a Circular Plot</p></a></li>
<li><a href='#totalvariation.circular'>
<p>Conditional total variation distance between two circular samples.</p></a></li>
<li><a href='#triangular'><p>Triangular Density Function</p></a></li>
<li><a href='#trigonometric.moment'><p>Trigonometric Moments</p></a></li>
<li><a href='#turtles'>
<p>Arrival directions of displaced sea turtles</p></a></li>
<li><a href='#unique.circular'><p>Extract Unique Elements from a circular vector</p></a></li>
<li><a href='#var'><p>Variance</p></a></li>
<li><a href='#var.circular'><p>A measure of variance for Circular Data</p></a></li>
<li><a href='#vonMises'><p>von Mises Density Function</p></a></li>
<li><a href='#wallraff.test'><p>Wallraff Test of Angular Distances</p></a></li>
<li><a href='#watson.test'><p>Watson's Test</p></a></li>
<li><a href='#watson.two.test'><p>Watson's Two-Sample Test of Homogeneity</p></a></li>
<li><a href='#watson.wheeler.test'><p>Watson-Williams Test of Homogeneity of Means</p></a></li>
<li><a href='#watson.williams.test'><p>Watson-Williams Test of Homogeneity of Means</p></a></li>
<li><a href='#weighted.mean.circular'><p>Weighted Mean Direction</p></a></li>
<li><a href='#wind'>
<p>Col De La Roa wind direction</p></a></li>
<li><a href='#windrose'><p>Windrose Generator</p></a></li>
<li><a href='#wrappedCauchy'><p>Wrapped Cauchy Density Function</p></a></li>
<li><a href='#wrappedNormal'><p>Wrapped Normal Density Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Circular Statistics</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-0</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulric Lund &lt;ulund@calpoly.edu&gt; [aut],
  Claudio Agostinelli &lt;claudio.agostinelli@unitn.it&gt; [aut],
  Hiroyoshi Arai &lt;h_arai@aoni.waseda.jp&gt; [ctb],
  Alessando Gagliardi &lt;gagliardi@stud.unive.it&gt; [ctb],
  Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt; [ctb, cre],
  Dimitri Giunchi &lt;dimitri.giunchi@unipi.it&gt; [ctb],
  Jean-Olivier Irisson &lt;irisson@normalesup.org&gt; [ctb],
  Matthew Pocernich &lt;pocernic@ucar.edu&gt; [ctb],
  Federico Rotolo [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-05</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Circular Statistics, from "Topics in circular Statistics" (2001) S. Rao Jammalamadaka and A. SenGupta, World Scientific.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-05 18:36:24 UTC; Eduardo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 19:50:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='Circular'>Package &lsquo;circular&rsquo;: summary information</h2><span id='topic+Circular'></span><span id='topic+circular-package'></span>

<h3>Description</h3>

<p>The package &lsquo;circular&rsquo; provides functions for the statistical analysis
and graphics representation of circular data (observations which are
angles). It originally started as a porting from S-plus to R of
functions developed for the book: Circular Statistics, from &quot;Topics in
circular Statistics&quot; (2001) S. Rao Jammalamadaka and A. SenGupta,
World Scientific. Now, it has an S3 implementation and several new
functions and datasets.  
</p>


<h3>Version</h3>

<p>The version level of the package is given by the command 
<code>packageDescription("circular")</code>.
The most recent version of the package can be obtained from
the R-Forge repository at <a href="https://r-forge.r-project.org/projects/circular/">https://r-forge.r-project.org/projects/circular/</a>
</p>


<h3>Author</h3>

<p>Claudio Agostinelli, Department of Mathematics
University of Trento, Italy
(<a href="http://datascience.maths.unitn.it/~claudio/">http://datascience.maths.unitn.it/~claudio/</a>)
</p>
<p>Ulric Lund, Department of Statistics, California Polytechnic State
University, San Luis Obispo, California, USA
(<a href="https://statistics.calpoly.edu/ulric-lund">https://statistics.calpoly.edu/ulric-lund</a>)
</p>


<h3>Licence</h3>

<p>This package and its documentation are usable under the terms of the 
&quot;GNU General Public License&quot;, a copy of which is distributed with the 
package. While the software is freely usable, it would be appreciated
if a reference is inserted in publications or other work
which makes use of it; for this purpose, see the command
<code>citation("circular")</code>. 
</p>


<h3>Acknowledgements</h3>

<p>The package has evolved through several versions, developed over some years.
</p>
<p>Many thanks to all that points out bugs, provide suggestions and comments.
</p>
<p>The functions <code>median</code> and <code>medianHS</code> are developed together with
Alessandro Gagliardi <a href="mailto:alessandro.gagliardi@unipd.it">mailto:alessandro.gagliardi@unipd.it</a>
</p>
<p>The functions <code>watson.wiliams.test</code> and <code>wallraff.test</code> are
developed by Jean-Olivier Irisson (<a href="https://www.obs-vlfr.fr/~irisson/">https://www.obs-vlfr.fr/~irisson/</a>)
</p>
<p>The functions <code>dcarthwrite</code>, <code>dgenvonmises</code>,
<code>(d,r)katojones</code>, <code>djonespewsey</code> are developed by Federico Rotolo
</p>
<p>The function <code>rose.diag</code> has contribution by Hiroyoshi Arai (<a href="mailto:h_arai@aoni.waseda.jp">mailto:h_arai@aoni.waseda.jp</a>)
</p>
<p>The function <code>windrose</code> is developed by Matthew Pocernich 
</p>
<p>Dataset <code>swallows</code> is kindly provided by Dimitri Giunchi <a href="http://unimap.unipi.it/cercapersone/dettaglio.php?ri=2504&amp;template=dettaglio.tpl">http://unimap.unipi.it/cercapersone/dettaglio.php?ri=2504&amp;template=dettaglio.tpl</a>
</p>
<p>The function <code>bw.circular</code> is developed together with Eduardo Garcia Portugues <a href="https://egarpor.github.io/">https://egarpor.github.io/</a>
</p>
<p>If I miss to report your contribution please let me know by email at <a href="mailto:claudio.agostinelli@unitn.it">mailto:claudio.agostinelli@unitn.it</a>
</p>

<hr>
<h2 id='+5B.circular'>Extract or Replace Parts of a Circular Object</h2><span id='topic++5B.circular'></span>

<h3>Description</h3>

<p>Operators act on vectors and matrices to extract or
replace subsets, methods for Circular Data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.circular_+3A_x">x</code></td>
<td>
<p>object from which to extract elements.</p>
</td></tr>
<tr><td><code id="+2B5B.circular_+3A_i">i</code>, <code id="+2B5B.circular_+3A_...">...</code></td>
<td>
<p>elements to extract or replace.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- circular(matrix(rwrappednormal(n=100, mu=circular(0)), nrow=5))
dim(x)
x[1,]
x[,1]
x[,1, drop=FALSE]
</code></pre>

<hr>
<h2 id='A1'>Ratio of First and Zeroth Order Bessel Functions</h2><span id='topic+A1'></span>

<h3>Description</h3>

<p>Evaluates the first and zeroth order Bessel functions of the first kind at a specified non-negative real number, and returns the ratio.</p>


<h3>Usage</h3>

<pre><code class='language-R'>A1(kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A1_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value at which to evaluate the Bessel functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code><a href="base.html#topic+besselI">besselI</a></code>.
</p>


<h3>Value</h3>

<p>If I1(kappa) is the first order Bessel function and I0(kappa) is the zeroth order Bessel function, then A1(kappa) returns I1(kappa)/I0(kappa).
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselI">besselI</a></code>, <code><a href="#topic+A1inv">A1inv</a></code>.
</p>

<hr>
<h2 id='A1FirstDerivative'>First derivative of the Ratio of First and Zeroth Order Bessel Functions.</h2><span id='topic+A1FirstDerivative'></span>

<h3>Description</h3>

<p>Evaluates the first derivative of the Ratio of First and Zeroth Order Bessel Functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>  A1FirstDerivative(kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A1FirstDerivative_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value at which to evaluate the first derivative of A1 function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula (3.48) of  Fisher (1993), pag. 52 is implemented.
The function uses <code><a href="#topic+A1">A1</a></code> and <code><a href="base.html#topic+besselI">besselI</a></code>.
</p>


<h3>Value</h3>

<p>The value of the first derivative of A1 function in the point <code>kappa</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi.</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+A1">A1</a></code>, <code><a href="base.html#topic+besselI">besselI</a></code>, <code><a href="#topic+A1inv">A1inv</a></code>.
</p>

<hr>
<h2 id='A1inv'>Inverse of A1</h2><span id='topic+A1inv'></span>

<h3>Description</h3>

<p>Inverse function of the ratio of the first and zeroth order Bessel functions of the first kind.  This function is used to compute the maximum likelihood estimate of the concentration parameter of a von Mises distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A1inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A1inv_+3A_x">x</code></td>
<td>
<p>numeric value in the interval between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A1inv(0) = 0 and A1inv(1) = Inf.  This function is useful in estimating
the concentration parameter of data from a von Mises distribution. Our
function use the results in Best and Fisher (1981). Tables use tabulated
values by Gumbel, Greenwood and Durand (1953).
</p>


<h3>Value</h3>

<p>Returns the value k, such that A1inv(x) = k, i.e. A1(k) = x.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>BEST, D.J. and FISHER, N.I. 1981. The bias of the maximum 
likelihood estimators for the von Mises-Fisher concentration 
parameters. Communications in Statistics, 10, 493-502.
</p>
<p>GUMBEL, E.J., GREENWOOD, J.A. AND DURAND, D.  1953.  The circular 
normal distribution: theory and tables.  J. Amer. Statis. Assoc., 
48, 131-152.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle.vonmises">mle.vonmises</a></code>, <code><a href="#topic+A1">A1</a></code>, <code><a href="base.html#topic+besselI">besselI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate data from a von Mises distribution
data &lt;- rvonmises(n=50, mu=circular(pi), kappa=4)
#Estimate the concentration parameter
s &lt;- sum(sin(data))
c &lt;- sum(cos(data))
mean.dir &lt;- atan2(s, c)
kappa &lt;- A1inv(mean(cos(data - mean.dir)))
</code></pre>

<hr>
<h2 id='A1SecondDerivative'>Second derivative of the Ratio of First and Zeroth Order Bessel Functions.</h2><span id='topic+A1SecondDerivative'></span>

<h3>Description</h3>

<p>Evaluates the second derivative of the second derivative of the Ratio of First and Zeroth Order Bessel Functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  A1SecondDerivative(kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A1SecondDerivative_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value at which to evaluate the second derivative of A1 function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formula (3.49) of  Fisher (1993), pag. 52 is implemented.
The function uses <code><a href="#topic+A1">A1</a></code>, <code><a href="#topic+A1FirstDerivative">A1FirstDerivative</a></code> and <code><a href="base.html#topic+besselI">besselI</a></code>.
</p>


<h3>Value</h3>

<p>The value of the second derivative of A1 function in the point <code>kappa</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi.</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+A1">A1</a></code>, <code><a href="#topic+A1FirstDerivative">A1FirstDerivative</a></code>, <code><a href="base.html#topic+besselI">besselI</a></code>, <code><a href="#topic+A1inv">A1inv</a></code>.
</p>

<hr>
<h2 id='angular.deviation'>A measure of deviation for Circular Data</h2><span id='topic+angular.deviation'></span>

<h3>Description</h3>

<p>Returns the square root of twice one minus the mean resultant length divided by the sample size of a vector of circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular.deviation(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angular.deviation_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="angular.deviation_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the square root of twice one minus the mean resultant length divided by the sample size.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Batschelet, E. (1981) Circular Statistics in Biology. Academic Press, London.
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>
<p>Zar, J.H. (2010) Biostatistical Analysis. Fifth edition. Pearson
Educational International.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sd.circular">sd.circular</a></code>, <code><a href="#topic+angular.variance">angular.variance</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=100, mu=circular(0), kappa=1)
angular.deviation(x)
</code></pre>

<hr>
<h2 id='angular.variance'>A measure of variance for Circular Data</h2><span id='topic+angular.variance'></span>

<h3>Description</h3>

<p>Returns twice one minus the mean resultant length divided by the sample size of a vector of circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angular.variance(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angular.variance_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="angular.variance_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns twice one minus the mean resultant length divided by the sample size.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Batschelet, E. (1981) Circular Statistics in Biology. Academic Press, London.
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>
<p>Zar, J.H. (2010) Biostatistical Analysis. Fifth edition. Pearson
Educational International.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+angular.deviation">angular.deviation</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=100, mu=circular(0), kappa=1)
angular.variance(x)
</code></pre>

<hr>
<h2 id='aov.circular'>Analysis of Variance for circular data</h2><span id='topic+aov.circular'></span><span id='topic+print.aov.circular'></span>

<h3>Description</h3>

<p>One Critrion Analysis of Variance for circular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aov.circular(x, group, kappa = NULL,
    method = c("F.test", "LRT"), F.mod = TRUE, control.circular=list())
## S3 method for class 'aov.circular'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aov.circular_+3A_x">x</code></td>
<td>
<p>a vector of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_group">group</code></td>
<td>
<p>a vector identifying the groups or samples.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_kappa">kappa</code></td>
<td>
<p>the common value of the concentration parameter. Used
when <code>method</code> is <code>"LRT"</code>.  If left unspecified (by default) 
the maximum likelihood estimate of kappa is computed and used in the test statistic.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_method">method</code></td>
<td>
<p>the test statistic to use; either a high-concentration F-test or a 
likelihood ratio test.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_f.mod">F.mod</code></td>
<td>
<p>logical; if <code>TRUE</code>, the AOV F-statistic is modified by a factor of 1+3/8k 
to improve its approximate F distribution. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the coordinate system used in the output for the objects <code>mu</code> and <code>mu.all</code>. See <code><a href="#topic+circular">circular</a></code> for details.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="aov.circular_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples are assumed to have been drawn from von Mises populations with 
equal concentration parameter, kappa. The null hypothesis being tested is 
that all populations also have the same mean direction. 
</p>
<p>If <code>method</code> is <code>"F.test"</code> a high concentration F-test makes use 
of a decomposition of total sample variation into between groups and within 
groups variation, analogous to the one-way classification analysis of variance 
for linear data.  Stephens (1972) presented an improved modification to the 
F-test derived from this decomposition.  This is implemented when <code>F.mod</code> 
is <code>TRUE</code>.
</p>
<p>A likelihood ratio test is performed when <code>method</code> is <code>"LRT"</code>. This 
function uses the test statistic presented by Cordeiro, Paula, and Botter (1994) which has 
an approximate chi-squared distribution. If the common concentration parameter 
is known, it can be specified and used in the computation of the test statistic. 
Otherwise, the maximum likelihood estimate of the common concentration parameter is used.
</p>


<h3>Value</h3>

<p>An object of class <code>aov.circular</code> with the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>mean direction for each sample with class <code>circular</code>.</p>
</td></tr>
<tr><td><code>mu.all</code></td>
<td>
<p>mean direction of all samples combined with class <code>circular</code>.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>concentration parameter for each sample.</p>
</td></tr>
<tr><td><code>kappa.all</code></td>
<td>
<p>concentration parameter for all samples combined.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>mean resultant length for each sample.</p>
</td></tr>
<tr><td><code>rho.all</code></td>
<td>
<p>mean resultant length for all samples combined.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the test statistic used.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p.value of the test statistic.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
</table>
<p>If the <code>method</code> is <code>"F.test"</code> then the object contains also:
</p>
<table>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of squares used in F-test.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>Mean squares used in F-test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Cordeiro, G., Paula, G. and Botter, D. (1994). Improved likelihood ratio tests for 
dispersion models. International Statistical Review, 62, 257-274. 
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 5.3, 
World Scientific Press, Singapore. 
</p>
<p>Mardia, K. and Jupp, P. (1999). Directional Statistics, Section 7.4, John 
Wiley and Sons, England. 
</p>
<p>Stephens, M. (1972). Multi-sample tests for the von Mises distribution. Technical 
Report 190, Department of Statistics, Stanford University. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rvonmises(50, circular(0), 1), rvonmises(100, circular(pi/3), 10))
group &lt;- c(rep(0, 50), rep(1, 100))

aov.circular(x, group)
aov.circular(x, group, method="LRT")
</code></pre>

<hr>
<h2 id='arrows.circular'>Add Arrows to a Circular Plot</h2><span id='topic+arrows.circular'></span>

<h3>Description</h3>

<p>Draw arrows in a circular plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrows.circular(x, y = NULL, x0 = 0, y0 = 0, na.rm = FALSE, 
  shrink = 1, plot.info = NULL, zero = NULL, rotation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrows.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_y">y</code></td>
<td>
<p>a vector with the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_x0">x0</code></td>
<td>
<p>a vector of origins (x axis).</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_y0">y0</code></td>
<td>
<p>a vector of origins (y axis).</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be omitted.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted circle.
Default is 1.  Larger values shrink the circle, while smaller values
enlarge the circle.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_plot.info">plot.info</code></td>
<td>
<p>an object from <code><a href="#topic+plot.circular">plot.circular</a></code> that
contains information on the <code>zero</code>, the <code>rotation</code> and <code>next.points</code>.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_zero">zero</code></td>
<td>
<p>the zero used in the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation used in the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="arrows.circular_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function call <code><a href="graphics.html#topic+arrows">arrows</a></code> and it is not a method of <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+arrows">arrows</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rvonmises(10, circular(0), kappa=1))
  arrows.circular(rvonmises(10, circular(0), kappa=1))
  arrows.circular(rvonmises(10, circular(0), kappa=1), y=runif(10), col=2)
  arrows.circular(rvonmises(10, circular(0), kappa=1), y=runif(10), 
    x0=runif(10, -1, 1), y0=runif(10, -1, 1), col=3)
</code></pre>

<hr>
<h2 id='as.data.frame.circular'>as.data.frame.circular</h2><span id='topic+as.data.frame.circular'></span>

<h3>Description</h3>

<p>This function is a method of <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> for a circular object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.circular_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.circular_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.circular_+3A_optional">optional</code></td>
<td>
<p>logical; if <code>TRUE</code> setting row names is
optional.</p>
</td></tr>
<tr><td><code id="as.data.frame.circular_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>

<hr>
<h2 id='asytriangular'>Asymmetric Triangular Density Function</h2><span id='topic+dasytriangular'></span>

<h3>Description</h3>

<p>Density the Asymmetric Triangular circular distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dasytriangular(x, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asytriangular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="asytriangular_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution.  rho must be
between 0 and <code class="reqn">1/pi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dasytriangular</code> gives the density. 
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Mardia (1972) Statistics for Directional Data, Wiley. Pag. 52
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff &lt;- function(x) dasytriangular(x, rho=0.3)
curve.circular(ff, shrink=1.2, join=TRUE)

</code></pre>

<hr>
<h2 id='axialvonMises'>Axial von Mises Density Function</h2><span id='topic+daxialvonmises'></span>

<h3>Description</h3>

<p>Density for the axial von Mises circular distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daxialvonmises(x, mu, kappa, l = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axialvonMises_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="axialvonMises_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution. The object is coerced to class <code><a href="#topic+circular">circular</a></code></p>
</td></tr>
<tr><td><code id="axialvonMises_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value for the concentration parameter of the distribution.</p>
</td></tr>
<tr><td><code id="axialvonMises_+3A_l">l</code></td>
<td>
<p>a positive number. <code>l=2</code> provide the axial distribution in the range [0, pi].</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>daxialvonmises</code> gives the density.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.4, World Scientific Press, Singapore.
</p>

<hr>
<h2 id='axis.circular'>Add Axis to a Circular Plot</h2><span id='topic+axis.circular'></span>

<h3>Description</h3>

<p>Add axis to a plot of circular data points on the current graphics
device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis.circular(at=NULL, labels=NULL,  units = NULL, template=NULL,  
          modulo=NULL, zero=NULL, rotation=NULL, tick=TRUE, lty, lwd, 
          cex, col, font, tcl=0.025, tcl.text=0.125, digits=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis.circular_+3A_at">at</code></td>
<td>
<p>the points at which tick-marks are to be drawn. If <code>NULL</code> the
tick-marks are placed to 0, pi/2, pi and 3pi/2 radians.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_labels">labels</code></td>
<td>
<p>a vector of character strings to be placed at the
tickpoints. If <code>NULL</code> the labels are chosen according to
<code>units</code> and <code>template</code> arguments.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_units">units</code></td>
<td>
<p>either <code>radians</code> or <code>degrees</code>. If <code>NULL</code> the value is taken from the attributes of the object <code>at</code>.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_template">template</code></td>
<td>
<p>either <code>none</code> or <code>geographics</code>. If <code>NULL</code> the value is taken from the attributes of the object <code>at</code>.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_modulo">modulo</code></td>
<td>
<p>either <code>asis</code> or <code>2pi</code> or <code>pi</code>. If <code>NULL</code> the value is taken from the attributes of the object <code>at</code>.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the plot (in radians, counterclockwise). If <code>NULL</code> the value is taken from the attributes of the object <code>at</code>.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the plot. If <code>NULL</code> the value is taken from the attributes of the object <code>at</code>.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_tick">tick</code></td>
<td>
<p>logical: if <code>TRUE</code> ticks are plotted at tick-marks.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_lty">lty</code>, <code id="axis.circular_+3A_lwd">lwd</code></td>
<td>
<p>line type, width for the tick marks. If missing means to
use &lsquo;par(&quot;lty&quot;)&rsquo; and &lsquo;par(&quot;lwd&quot;)&rsquo;.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_cex">cex</code></td>
<td>
<p>a numerical value giving the amount by which plotting text and symbols should be scaled relative to the default.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_col">col</code></td>
<td>
<p>color for the the tick marks. If missing means to use &lsquo;par(&quot;col.axis&quot;)&rsquo;. </p>
</td></tr>
<tr><td><code id="axis.circular_+3A_font">font</code></td>
<td>
<p>font for text. If missing means to use &lsquo;par(&quot;font.axis&quot;)&rsquo;.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_tcl.text">tcl.text</code></td>
<td>
<p>The position of the axis labels.</p>
</td></tr>
<tr><td><code id="axis.circular_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code> and <code><a href="#topic+ticks.circular">ticks.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.vm &lt;- rvonmises(n=100, mu=circular(0), kappa=3) 
plot(data.vm, axes=FALSE, ticks=FALSE)
axis.circular(at=circular(seq(0, 11/6*pi, pi/6)), labels=c("0",
expression(frac(pi,6)), expression(paste(frac(1,3), pi)),
expression(frac(pi,2)), expression(paste(frac(2,3), pi)),
expression(paste(frac(5,6), pi)), expression(pi),
expression(paste(frac(7,6), pi)), expression(paste(frac(4,3), pi)),
expression(paste(frac(3,2), pi)), expression(paste(frac(5,3), pi)),
expression(paste(frac(11,6), pi))))
</code></pre>

<hr>
<h2 id='bandwidth'>Bandwidth Selectors for Kernel Density Estimation for Circular Data</h2><span id='topic+bw.cv.mse.circular'></span><span id='topic+bw.cv.ml.circular'></span><span id='topic+bw.nrd.circular'></span>

<h3>Description</h3>

<p>Bandwidth selectors for circular kernels in <code><a href="#topic+density.circular">density.circular</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.cv.mse.circular(x, lower=NULL, upper=NULL, tol = 1e-4,
  kernel = c("vonmises", "wrappednormal"), K = NULL, min.k = 10)

bw.cv.ml.circular(x, lower=NULL, upper=NULL, tol = 1e-4,
  kernel = c("vonmises", "wrappednormal"), K = NULL, min.k = 10)

bw.nrd.circular(x, lower=NULL, upper=NULL,
  kappa.est=c("ML","trigmoments"), kappa.bias=FALSE, P=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_+3A_x">x</code></td>
<td>
<p>the data from which the bandwidth is to be computed. The object is coerced to class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_lower">lower</code>, <code id="bandwidth_+3A_upper">upper</code></td>
<td>
<p>range over which to minimize for cross validatory
bandwidths. The default is almost always satisfactory, although it
is recommended experiment a little with different ranges. A warning
message indicates if the resulting bandwidth is too near to the
endpoints of the interval search.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_tol">tol</code></td>
<td>
<p>for cross validatory bandwidths, the convergence tolerance for <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_kernel">kernel</code></td>
<td>
<p>a character string giving the smoothing kernel to be used. This must be one of <code>"vonmises"</code> or <code>"wrappednormal"</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_k">K</code></td>
<td>
<p>number of terms to be used in approximating the wrappednormal density. See <code><a href="#topic+dwrappednormal">dwrappednormal</a></code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_min.k">min.k</code></td>
<td>
<p>minimum number of terms used in approximating the
wrappednormal density. See <code><a href="#topic+dwrappednormal">dwrappednormal</a></code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_kappa.est">kappa.est</code></td>
<td>
<p>a numerical value or one available method.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_kappa.bias">kappa.bias</code></td>
<td>
<p>logical. If <code>TRUE</code>, when <code>kappa.est=="ML"</code>
a bias correction in the estimation of kappa is applied.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_p">P</code></td>
<td>
<p>integer, the maximum order of the sample trigonometric
moments used in the estimation of <code>kappa</code> when
<code>kappa.est=="trigmoments"</code>, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bw.cv.mse.circular</code> and <code>bw.cv.ml.circular</code> implement cross validatory bandwidths minimizing squared&ndash;error loss and Kullback&ndash;Leibler loss, respectively. This is done by minimizing the second and third equations in section 5 of Hall, Watson and Cabrera (1987). Kullback&ndash;Leibler loss is equivalent to maximize the cross validation log&ndash;likelihood with respect to the bandwidth parameter.
</p>
<p><code>bw.nrd.circular</code> implements a rule-of-thumb for choosing the
bandwidth of a von Mises kernel density estimator with underlying
population von Mises. It was proposed by Taylor (2008, equation (7)) and
is the circular analogue of the usual rule of thumb used for the normal
distribution. The only remarkable difference between them is that
Taylor's bandwidth supposes a von Mises population for the derivation of
AMISE, while normal rule of thumb only introduces distribution
assumption to compute the density curvature. Estimation of the spread is
done by maximum likelihood. The &quot;trigmoments&quot; method for the estimation of
<code>kappa</code> is implemented as follows. Let <code class="reqn">\mu_p</code> be the p-th
sample trigonometric moment. Let <code class="reqn">k_p</code> be the estimates of
<code>kappa</code> using the p-th sample trigonometric moment, as solution
(using <code>uniroot</code> function) of the equation <code class="reqn">A_p(k) = \frac{1}{n}
  \sum_{i=1}^n \cos(p x_i - \mu_p)</code>. We let <code>kappa</code> equal to
<code class="reqn">max(k_1, k_2, \cdots, k_P)</code>, see Taylor (2008) for further details.
</p>
<p>Note that circular bandwidth has a different scale from linear bandwidth (see Hall, Watson and Cabrera (1987)). The behaviour of the circular bandwidth is the <em>inverse</em> of the linear: large values overestimate the density, whereas small values underestimate. 
</p>


<h3>Value</h3>

<p>A bandwidth on a scale suitable for the <code>bw</code> argument
of <code>density.circular</code>.
</p>


<h3>Warning</h3>

<p>Plug-in bandwidth selector <code>bw.nrd.circular</code> assumes that the
underlying population is von Mises. If this is not true, it might lead
to serious misestimations of the circular bandwidth. Example 2 below
shows how this behaviour can appear with multimodality populations. In
those cases, the use of <code>kappa.est="trigmoments"</code> could be of help.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Eduardo Garcia&ndash;Portugues</p>


<h3>References</h3>

<p>P. Hall and G.S. Watson and J. Cabrera (1987). Kernel Density Estimation
with Spherical Data, Biometrika, 74, 4, 751&ndash;762.
</p>
<p>C.C Taylor (2008). Automatic bandwidth selection for circular density estimation. Computational Statistics and Data Analysis, 52, 7, 3493&ndash;3500.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.circular">density.circular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)

## Example 1: von Mises ##
theta1 &lt;- rvonmises(n=150,mu=circular(pi),kappa=2)

bw.nrd1 &lt;- bw.nrd.circular(theta1)
bw.cv.mse1 &lt;- bw.cv.mse.circular(theta1)
bw.cv.ml1 &lt;- bw.cv.ml.circular(theta1)

## Linear plot
plot(function(x) dvonmises(circular(x), mu=circular(pi), kappa=2),
type="l", lwd=2, col=1, main="von Mises", xlab=expression(theta),
ylab="Density", from=0, to=2*pi)
plot(approxfun(density.circular(x=theta1, bw=bw.nrd1)), col=2, from=0, to=2*pi, add=TRUE)
plot(approxfun(density.circular(x=theta1, bw=bw.cv.mse1)), col=3,
from=0, to=2*pi, add=TRUE)
plot(approxfun(density.circular(x=theta1, bw=bw.cv.ml1)), col=4, from=0,
to=2*pi, add=TRUE)
legend("topright", legend=c("True", "Taylor", "LSCV", "MLCV"), col=1:4, lwd=2)
rug(theta1)

## Circular plot
dvonmises1 &lt;- function(x) dvonmises(circular(x), mu=circular(pi), kappa=2)
curve.circular(dvonmises1, lwd=2, col=1, main="von Mises", xlim=c(-1.5,
1.5), ylim=c(-1.5,1.5))
lines(density.circular(x=theta1, bw=bw.nrd1), col=2)
lines(density.circular(x=theta1, bw=bw.cv.mse1), col=3)
lines(density.circular(x=theta1, bw=bw.cv.ml1), col=4)
legend("topright", legend=c("True", "Taylor", "LSCV", "MLCV"), col=1:4, lwd=2)
points(theta1)

## Example 2: mixture of von Mises ##

theta2 &lt;- rmixedvonmises(n=150, mu1=circular(pi/2),
mu2=circular(3*pi/2), kappa1=5, kappa2=5,p=0.5)

bw.nrd2 &lt;- bw.nrd.circular(theta2)
bw.cv.mse2 &lt;- bw.cv.mse.circular(theta2)
bw.cv.ml2 &lt;- bw.cv.ml.circular(theta2)

## Linear plot
plot(function(x) dmixedvonmises(circular(x), mu1=circular(pi/2),
mu2=circular(3*pi/2), kappa1=5, kappa2=5, p=0.5), type="l", lwd=2,
col=1, main="mixture of von Mises", xlab=expression(theta),
ylab="Density", from=0, to=2*pi)
lines(density.circular(x=theta2, bw=bw.nrd2), plot.type='line', col=2)
lines(density.circular(x=theta2, bw=bw.cv.mse2), plot.type='line',
col=3)
lines(density.circular(x=theta2, bw=bw.cv.ml2), plot.type='line', col=4)
rug(theta2)
legend("topright", legend=c("True", "Taylor", "LSCV", "MLCV"), col=1:4, lwd=2)

## Circular plot
dmixedvonmises1 &lt;- function(x) dmixedvonmises(circular(x), mu1=circular(pi/2),
mu2=circular(3*pi/2), kappa1=5, kappa2=5, p=0.5)
curve.circular(dmixedvonmises1, join=TRUE,
xlim=c(-1.5, 1.5), ylim=c(-1.5, 1.5), lwd=2, col=1, main="mixture of von
Mises")
lines(density.circular(x=theta2, bw=bw.nrd2), col=2)
lines(density.circular(x=theta2, bw=bw.cv.mse2), col=3)
lines(density.circular(x=theta2, bw=bw.cv.ml2), col=4)
points(theta2)
legend("topright", legend=c("True", "Taylor", "LSCV", "MLCV"), col=1:4, lwd=2)

## Example 3: mixture of von Mises and Wrapped Cauchy ##

rmixture &lt;- function(n){
  x &lt;- circular(sapply(runif(n), function(u) ifelse(u&gt;0.5,
  rvonmises(n=1, mu=circular(pi),kappa=10),
  rwrappedcauchy(n=1,mu=circular(pi/2),rho=0.75))))
  return(x)
}

theta3 &lt;- rmixture(n=150)

bw.nrd3 &lt;- bw.nrd.circular(theta3)
bw.cv.mse3 &lt;- bw.cv.mse.circular(theta3, lower=0.1, upper=100)
bw.cv.ml3 &lt;- bw.cv.ml.circular(theta3, lower=0.1, upper=100)

dmixture &lt;- function(x) (dvonmises(x, mu=circular(pi),
kappa=10)+dwrappedcauchy(x, mu=circular(pi/2), rho=0.75))/2
curve.circular(dmixture, join=TRUE, xlim=c(-1.5, 1.5), ylim=c(-1.5,
1.5), lwd=2, col=1, main="mixture of von Mises and Wrapped Normal")
lines(density.circular(x=theta3, bw=bw.nrd3), col=2)
lines(density.circular(x=theta3, bw=bw.cv.mse3), col=3)
lines(density.circular(x=theta3, bw=bw.cv.ml3), col=4)
legend("topright", legend=c("True", "Taylor", "LSCV", "MLCV"), col=1:4, lwd=2)
points(theta3)
</code></pre>

<hr>
<h2 id='c.circular'>A method for circular object, which combines its arguments</h2><span id='topic+c.circular'></span>

<h3>Description</h3>

<p>A method for circular object, which combines its arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.circular_+3A_...">...</code></td>
<td>
<p>vectors, the first of which of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="c.circular_+3A_recursive">recursive</code></td>
<td>
<p>logical. If 'recursive=TRUE', the function recursively
descends through lists combining all their elements into a
vector.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+c">c</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvonmises(10, circular(0), 10)
y &lt;- rvonmises(10, circular(0), 10, control.circular=list(units="degrees"))
z &lt;- runif(10, 0, 20) # here you do not use circular properties, 
#####but you mean it is measured in degrees
c(x, y, z) # While y is converted in radians, z is treated as it was!

</code></pre>

<hr>
<h2 id='Cardioid'>Cardioid Density Function</h2><span id='topic+dcardioid'></span><span id='topic+rcardioid'></span>

<h3>Description</h3>

<p>Density and random generation for the Cardioid circular distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcardioid(x, mu = circular(0), rho = 0)
rcardioid(n, mu = circular(0), rho = 0, control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cardioid_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="Cardioid_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>  
<tr><td><code id="Cardioid_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="Cardioid_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution. Absolute value of <code>rho</code> must be less than 0.5.</p>
</td></tr>
<tr><td><code id="Cardioid_+3A_control.circular">control.circular</code></td>
<td>
<p>the coordinate system used in the output of <code>rcardioid</code>. See <code><a href="#topic+circular">circular</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcardioid</code> gives the density and <code>rcardioid</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.2, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1234) 
  resrad &lt;- rcardioid(n=10)
  set.seed(1234)
  resdeg &lt;- rcardioid(n=10, control.circular=list(units="radians", zero=pi))  
  max(abs(resrad - conversion.circular(resdeg, zero=0)))
</code></pre>

<hr>
<h2 id='Carthwrite'>Carthwrite's Power-of-Cosine Density Function</h2><span id='topic+dcarthwrite'></span>

<h3>Description</h3>

<p>Density for the Carthwrite's power-of-cosine distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcarthwrite(x, mu, psi)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Carthwrite_+3A_x">x</code></td>
<td>
<p>a vector. The <code>x</code> and <code>q</code> objects are coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="Carthwrite_+3A_mu">mu</code></td>
<td>
<p>the location angular parameter. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="Carthwrite_+3A_psi">psi</code></td>
<td>
<p>the positive shape parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Carthwrite's power-of-cosine distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
		f(x)=\frac{2^{(1/\psi)-1} \Gamma^2((1/\psi)+1) (1+\cos(x-\mu))^{1/\psi}}
		{\pi\Gamma((2/\psi)+1)},
	</code>
</p>

<p>for <code class="reqn">0 \le x &lt; 2\pi</code>.
</p>


<h3>Value</h3>

<p>The density</p>


<h3>Author(s)</h3>

<p>Federico Rotolo</p>


<h3>References</h3>

<p>Carthwrite, D.E. (1963). The use of directional spectra in studying the output of a wave recorder on a moving ship. Ocean Wave Spectra , 203-218.</p>

<hr>
<h2 id='change.point'>Change Point Test</h2><span id='topic+change.point'></span>

<h3>Description</h3>

<p>Tests for a change in mean direction, concentration, or both, given a set of directional data points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change.point(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change.point_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In either context, the user can choose which statistic (max or ave) to use, and then consult the appropriate table provided in the book referenced below. The critical values for these 4 statistics are to be found in Table 11.3 (or Figure 11.3) for rmax, Table 11.4 (or Figure 11.4) for rave, Figure 11.5 for tmax and Figure 11.6 for tave.
</p>


<h3>Value</h3>

<p>Returns a list with variables n, rho, rmax, k.r, rave, tmax, k.t, and
tave. The first of these is the sample size, followed by the overall
mean resultant length. Both of these are needed to enter any of the
tables or nomograms (see under Details). The other values represent the change point test statistics.  While rmax and rave test for a change in mean direction (with unknown concentration), tmax and tave are useful in the context of testing more generally, for a change in mean direction and/or concentration. k.r and k.t are the observation numbers for which rmax and tmax attain their maximum value and indicate the observation at which the change is most likely to have occurred, when the tables or nomograms indicate significance. 
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Chapter 11, World Scientific Press, Singapore.  
</p>

<hr>
<h2 id='circle.control'>Auxiliary for Controlling Circular Plots</h2><span id='topic+circle.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for circular plots. Typically only used when calling plot.circular. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle.control(n = 1000, type = "l", col = 1, bg = par("bg"), 
  pch = 1, cex = 1, lty = 1, lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle.control_+3A_n">n</code></td>
<td>
<p>number of points used to interpolate the circle</p>
</td></tr>
<tr><td><code id="circle.control_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. The following values are possible, for details, see <code><a href="graphics.html#topic+plot">plot</a></code>: &quot;p&quot; for points, &quot;l&quot; for lines, &quot;o&quot; for overplotted points and lines, &quot;b&quot;, &quot;c&quot; for (empty if &quot;c&quot;) points joined by lines, &quot;s&quot; and &quot;S&quot; for stair steps and &quot;h&quot; for histogram-like vertical lines. Finally, &quot;n&quot; does not produce any points or lines.</p>
</td></tr>
<tr><td><code id="circle.control_+3A_col">col</code></td>
<td>
<p>The color used.</p>
</td></tr>
<tr><td><code id="circle.control_+3A_bg">bg</code></td>
<td>
<p>The color to be used for the background of the device region. </p>
</td></tr>
<tr><td><code id="circle.control_+3A_pch">pch</code></td>
<td>
<p>Either an integer specifying a symbol or a single character to be used as the default in plotting points. See <code><a href="graphics.html#topic+points">points</a></code> for possible values and their interpretation. Note that only integers and single-character strings can be set as a graphics parameter (and not <code>NA</code> nor <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="circle.control_+3A_cex">cex</code></td>
<td>
<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default.</p>
</td></tr>
<tr><td><code id="circle.control_+3A_lty">lty</code></td>
<td>
<p>The line type. Line types can either be specified as an integer (0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 5=longdash, 6=twodash) or as one of the character strings &quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or &quot;twodash&quot;, where &quot;blank&quot; uses 'invisible lines' (i.e., does not draw them). Alternatively, a string of up to 8 characters (from c(1:9, &quot;A&quot;:&quot;F&quot;)) may be given, giving the length of line segments which are alternatively drawn and skipped. See section 'Line Type Specification'. </p>
</td></tr>
<tr><td><code id="circle.control_+3A_lwd">lwd</code></td>
<td>
<p>The line width, a positive number, defaulting to 1. The interpretation is device-specific, and some devices do not implement line widths less than one. (See the help on the device for details of the interpretation.) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rvonmises(10, circular(0), 1), control.circle=circle.control(col=2, lty=2))
</code></pre>

<hr>
<h2 id='circular'>Create Objects of class circular for Circular data.</h2><span id='topic+circular'></span><span id='topic+as.circular'></span><span id='topic+is.circular'></span><span id='topic+print.circular'></span>

<h3>Description</h3>

<p>The function <code>circular</code> is used to create circular objects. <code>as.circular</code> and <code>is.circular</code> coerce an object to a circular and  test whether an object is a circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular(x, type = c("angles", "directions"), 
  units = c("radians", "degrees", "hours"),
  template = c("none", "geographics", "clock12", "clock24"),
  modulo = c("asis", "2pi", "pi"), 
  zero = 0, rotation = c("counter", "clock"), names)
## S3 method for class 'circular'
as(x, control.circular=list(), ...)
## S3 method for class 'circular'
is(x)
## S3 method for class 'circular'
print(x, info=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circular_+3A_x">x</code></td>
<td>
<p>a vector or a matrix. If a data.frame is supply then it is coerced to a matrix.</p>
</td></tr>
<tr><td><code id="circular_+3A_type">type</code></td>
<td>
<p>the type of measures (Not Used Yet).</p>
</td></tr>
<tr><td><code id="circular_+3A_units">units</code></td>
<td>
<p>units of the measures.</p>
</td></tr>
<tr><td><code id="circular_+3A_template">template</code></td>
<td>
<p>how the data should be plotted. This set <code>modulo</code>, <code>zero</code> and <code>rotation</code> to some suitable values. For instance for 'geographics': zero=pi/2 and rotation='clock'. It is also used to set default labels on the plots.</p>
</td></tr>
<tr><td><code id="circular_+3A_modulo">modulo</code></td>
<td>
<p>if we need to reduce the measures to modulo.</p>
</td></tr>
<tr><td><code id="circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the axes (in radians, counter).</p>
</td></tr>
<tr><td><code id="circular_+3A_rotation">rotation</code></td>
<td>
<p>the orientation of the axes.</p>
</td></tr>
<tr><td><code id="circular_+3A_names">names</code></td>
<td>
<p>names of the data.</p>
</td></tr>
<tr><td><code id="circular_+3A_info">info</code></td>
<td>
<p>if <code>TRUE</code> information on the properties of the data
are printed.</p>
</td></tr>
<tr><td><code id="circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute (coordinate system) used to coerced the resulting objects. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="circular_+3A_...">...</code></td>
<td>
<p>For <code>as.circular</code> an alternative way of setting the coordinate system of the resulting objects. Passed parameters to <code>print.default</code> for <code>print.circular</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+circular">circular</a></code>. Since version 0.3-5 the previous class of the object is retain.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+conversion.circular">conversion.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- circular(c(pi, pi/3, pi/4))
print(x)
is.circular(x)

x &lt;- circular(runif(10, -pi/2, pi/2), template="geographics")
plot(x)
class(x)

x &lt;- circular(data.frame(runif(10, -pi/2, pi/2)))
plot(x)
class(x)

cbind(x, x) # the matrix, cbind, rbind functions unclass and lost attributes! 
########Use it with care.

x &lt;- c(pi/12,2*pi+pi/12)
print(x)
x &lt;- unique(x)
print(x)

x[1]==x[2]

all.equal(x[1], x[2])

x &lt;- as.circular(pi, control.circular=list(units="radians", zero=pi))
y &lt;- conversion.circular(circular(pi), zero=pi)
res &lt;- plot(x)
points(y, col=2, plot.info=res)

</code></pre>

<hr>
<h2 id='Circular+20Uniform'>Circular Uniform Density Function</h2><span id='topic+dcircularuniform'></span><span id='topic+rcircularuniform'></span>

<h3>Description</h3>

<p>Density and random generation for the Circular Uniform distribution on the whole circle. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcircularuniform(x)
rcircularuniform(n, control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Circular+2B20Uniform_+3A_x">x</code></td>
<td>
<p>a vector. The object is not coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="Circular+2B20Uniform_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Circular+2B20Uniform_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcircularuniform</code> gives the density and <code>rcircularuniform</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.1, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- rcircularuniform(100, control.circular=list(units="degrees"))
plot(data1)

curve.circular(dcircularuniform, join=TRUE, xlim=c(-1.2, 1.2), 
  ylim=c(-1.2, 1.2), main="Density of a Circular Uniform Distribution")
</code></pre>

<hr>
<h2 id='circular.colors'>
Color Palettes for Circular
</h2><span id='topic+circular.colors'></span>

<h3>Description</h3>

<p>Create a vector of <code>n</code> contiguous colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circular.colors(n, m = 0, M = 2 * pi, offset = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circular.colors_+3A_n">n</code></td>
<td>
<p>the number of colors (&gt;= 1) to be in the palette.</p>
</td></tr>
<tr><td><code id="circular.colors_+3A_m">m</code></td>
<td>
<p>the smallest angle in radians.</p>
</td></tr>
<tr><td><code id="circular.colors_+3A_m">M</code></td>
<td>
<p>the largest angle in radians.</p>
</td></tr>
<tr><td><code id="circular.colors_+3A_offset">offset</code></td>
<td>
<p>the zero in radians.</p>
</td></tr>
<tr><td><code id="circular.colors_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code><a href="grDevices.html#topic+hsv">hsv</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+hsv">hsv</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  circular.colors(n=10, m=0, M=2*pi)
</code></pre>

<hr>
<h2 id='circularp'>Attributes for a Circular Object</h2><span id='topic+circularp'></span><span id='topic+circularp+3C-'></span>

<h3>Description</h3>

<p>&lsquo;circularp&rsquo; returns the &lsquo;circularp&rsquo; attribute (or &lsquo;NULL&rsquo;).  &lsquo;circularp&lt;-&rsquo; sets the &lsquo;circularp&rsquo; attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularp(x)
circularp(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circularp_+3A_x">x</code></td>
<td>
<p>a vector or a matrix of circular data.</p>
</td></tr>
<tr><td><code id="circularp_+3A_value">value</code></td>
<td>
<p>a vector of length 6 or a list with six components: type, units,
template, modulo, zero and rotation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>circularp</code> attribute is a list of six elements: type, units,
template, modulo, zero and rotation; see <code><a href="#topic+circular">circular</a></code> for
their meaning.
</p>
<p>Assignments are checked for consistency.    
</p>
<p>Assigning <code>NULL</code> removes the <code>circularp</code> attribute
and any <code>"circular"</code> class of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular">circular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- pi
circularp(x) # now NULL
circularp(x) &lt;- list(type="angles", units="radians", template="none", 
  modulo="asis", zero=0, rotation="counter")
circularp(x)
x
class(x) &lt;- "circular" # now we set also the class so that print.circular is used
x
</code></pre>

<hr>
<h2 id='conversion.circular'>Unit of Measure Conversion for Circular Data and other conversions</h2><span id='topic+conversion.circular'></span>

<h3>Description</h3>

<p>Conversion for Circular Data from one coordinate/units system to another one. For back compatibility, without arguments the function converts data from degrees to radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conversion.circular(x, units = c("radians", "degrees", "hours"), type = NULL, 
  template = NULL, modulo = NULL, zero = NULL, rotation = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion.circular_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_units">units</code></td>
<td>
<p>unit of the transformed data.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_type">type</code></td>
<td>
<p>type of the transformed data. If <code>NULL</code> no action is performed.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_template">template</code></td>
<td>
<p>template of the transformed data. If <code>NULL</code> no action is performed.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_modulo">modulo</code></td>
<td>
<p>modulo of the transformed data. If <code>NULL</code> no action is performed.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_zero">zero</code></td>
<td>
<p>zero of the transformed data. If <code>NULL</code> no action is performed.</p>
</td></tr>
<tr><td><code id="conversion.circular_+3A_rotation">rotation</code></td>
<td>
<p>rotation of the transformed data. If <code>NULL</code> no action is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+circular">circular</a></code> with the specified unit of measure, modulo, zero and rotation.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg">deg</a></code> and <code><a href="#topic+rad">rad</a></code>. If you want to set the properties of an object instead to transform it, you can use <code><a href="#topic+circular">circular</a></code> or <code><a href="#topic+circularp+3C-">circularp&lt;-</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=10, mu=circular(0), kappa=9, control.circular=list(units="degrees"))
par(mfcol=c(2, 2))
plot(x)
y &lt;- conversion.circular(x) # only the unit is changed (to radians) and 
####### the data converted.
plot(y)
z &lt;- conversion.circular(x, units="degrees", zero=pi) # only the zero is changed and 
####### the data converted.
plot(z)
w &lt;- conversion.circular(x, zero=pi, rotation="clock") # zero and rotation is 
####### changed and the data converted.
plot(w)
</code></pre>

<hr>
<h2 id='Coope'>Coope dataset  </h2><span id='topic+x.coope'></span><span id='topic+y.coope'></span>

<h3>Description</h3>

<p>A dataset taken from the paper of Coope (1993). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coope)
</code></pre>


<h3>Format</h3>

<p><code>x.coope</code> and <code>y.coope</code> are vectors of length  8.
</p>


<h3>Source</h3>

<p>Coope, I. (1993). Circle fitting by linear and non-linear least squares. 
Journal of Optimization Theory and Applications, 76, 381-388. 
</p>

<hr>
<h2 id='coord2rad'>
Angles between a vector and the x-axis
</h2><span id='topic+coord2rad'></span>

<h3>Description</h3>

<p>From coordinates of the end point of a vector in 2 dimensions to the angle between this vector and the x-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord2rad(x, y = NULL, control.circular = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord2rad_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> or a <code>data.frame</code> with two columns if y
is <code>NULL</code> otherwise a vector.</p>
</td></tr>
<tr><td><code id="coord2rad_+3A_y">y</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="coord2rad_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+circular">circular</a></code>  
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Frederick T. Wehrle  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circular">circular</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- cbind(rnorm(20), rnorm(20))
y &lt;- coord2rad(x)
</code></pre>

<hr>
<h2 id='cor.circular'>Correlation Coefficient for Angular Variables</h2><span id='topic+cor.circular'></span>

<h3>Description</h3>

<p>Computes a circular version of the Pearson's product moment correlation, and performs a significance test if requested. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.circular(x, y=NULL, test=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor.circular_+3A_x">x</code></td>
<td>
<p>vector or matrix of circular data.</p>
</td></tr>
<tr><td><code id="cor.circular_+3A_y">y</code></td>
<td>
<p>vector or matrix of circular data.</p>
</td></tr>
<tr><td><code id="cor.circular_+3A_test">test</code></td>
<td>
<p>if <code>test == TRUE</code>, then a significance test for the correlation coefficient is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation coefficient is computed like Pearson's product moment correlation for two linear variables X and Y.  In the computational formula,  however, (xi - xbar) and (yi - ybar) are replaced by sin(xi - xbar) and sin(yi - ybar), where xbar and ybar in the second two expressions are the mean directions of the samples.
</p>


<h3>Value</h3>

<p>Returns a vector or a matrix of a circular version of the Pearson's
product moment correlation, if <code>test == TRUE</code> then a list is
reported with statistic and p.value, the test statistic and p-value respectively, for testing significance of the correlation coefficient.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 8.2, World Scientific Press, Singapore.
</p>
<p>Jammalamadaka, S. and Sarma, Y. (1988).  A correlation coefficient for angular variables.  Statistical Theory and Data Analysis 2. North Holland:  New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two circular data sets, and compute their correlation.
x &lt;- rvonmises(n=50, mu=circular(0), kappa=3)
y &lt;- x + rvonmises(n=50, mu=circular(pi), kappa=10)
cor.circular(x, y, test=TRUE)
</code></pre>

<hr>
<h2 id='curve.circular'>Draw Function Plots in a Circle</h2><span id='topic+curve.circular'></span><span id='topic+plot.function.circular'></span>

<h3>Description</h3>

<p>Draws a curve corresponding to the given function or expression (in
<code>x</code>) over the interval <code>[from,to]</code> in a circle. Mainly used to 
plot circular density functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
curve(expr, from=NULL, to=NULL, n=101, add=FALSE, 
  cex=1, axes=TRUE, ticks=FALSE, shrink=1, tcl=0.025, 
  tcl.text=0.125, tol=0.04, uin=NULL, xlim=c(-1, 1), 
  ylim=c(-1, 1), digits=2, modulo=c("2pi", "asis", "pi"), 
  main=NULL, sub=NULL, xlab="", ylab="", 
  control.circle=circle.control(), ...)
## S3 method for class 'function.circular'
plot(x, from=0, to=2*pi, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve.circular_+3A_expr">expr</code></td>
<td>
<p>an expression written as a function of <code>x</code>, or
alternatively the name of a function which will be plotted.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_x">x</code></td>
<td>
<p>a &lsquo;vectorizing&rsquo; numeric <span class="rlang"><b>R</b></span> function.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_from">from</code>, <code id="curve.circular_+3A_to">to</code></td>
<td>
<p>the range over which the function will be plotted.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_n">n</code></td>
<td>
<p>integer; the number of x values at which to evaluate.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code> add to already existing plot.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_axes">axes</code></td>
<td>
<p>logical: if <code>TRUE</code> axis are added to the plot.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_ticks">ticks</code></td>
<td>
<p>logical: if <code>TRUE</code> tick - marks are added to the plot.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted circle.
Default is 1.  Larger values shrink the circle, while smaller values
enlarge the circle.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_tcl.text">tcl.text</code></td>
<td>
<p>The position of the axis labels.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length
1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_xlim">xlim</code>, <code id="curve.circular_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y
axes. Useful for centering the plot.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_modulo">modulo</code></td>
<td>
<p>the modulo used to process the data.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_main">main</code>, <code id="curve.circular_+3A_sub">sub</code>, <code id="curve.circular_+3A_xlab">xlab</code>, <code id="curve.circular_+3A_ylab">ylab</code>, <code id="curve.circular_+3A_cex">cex</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_control.circle">control.circle</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> in order to draw the circle. The function <code><a href="#topic+circle.control">circle.control</a></code> is used to set the parameters.</p>
</td></tr>
<tr><td><code id="curve.circular_+3A_...">...</code></td>
<td>
<p>parameters, passed to <code><a href="#topic+lines.circular">lines.circular</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For now, curve circular draws functions defined in radians, counterclockwise coordinate and zero at 0.
</p>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.circular">lines.circular</a></code> and <code><a href="#topic+circle.control">circle.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff &lt;- function(x) sqrt(x)/20
curve.circular(ff)
curve.circular(ff, to=6*pi, join=FALSE, nosort=TRUE, n=1001, modulo="asis",
  shrink=1.2)

plot.function.circular(function(x) dvonmises(x, circular(0), 10), xlim=c(-1, 2.2))
</code></pre>

<hr>
<h2 id='deg'>Degrees</h2><span id='topic+deg'></span>

<h3>Description</h3>

<p>Converts radians to degrees. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg_+3A_x">x</code></td>
<td>
<p>vector or matrix of radian measurements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is available for compatibility with the CircStats
package; please use <code><a href="#topic+conversion.circular">conversion.circular</a></code>.</p>


<h3>Value</h3>

<p>Returns a vector or matrix of degree measurements corresponding to the
data in radians.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+conversion.circular">conversion.circular</a></code> and <code><a href="#topic+rad">rad</a></code>
</p>

<hr>
<h2 id='density.circular'>Kernel Density Estimation for Circular Data</h2><span id='topic+density.circular'></span><span id='topic+print.density.circular'></span>

<h3>Description</h3>

<p>The function <code>density.circular</code> computes kernel density estimates
with the given kernel and bandwidth for circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
density(x, z=NULL, bw, adjust = 1, type = c("K", "L"),
  kernel = c("vonmises", "wrappednormal"), na.rm = FALSE, 
  from = circular(0), to = circular(2 * pi), n = 512, K = NULL, min.k=10, 
  control.circular=list(), ...)
## S3 method for class 'density.circular'
print(x, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.circular_+3A_x">x</code></td>
<td>
<p>the data from which the estimate is to be computed. The object is coerced to class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_z">z</code></td>
<td>
<p>the points where the density is estimated. If <code>NULL</code>
equally spaced points are used according to the parameters
<code>from</code>, <code>to</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used. When the <code>kernel</code>
is <code>vonmises</code> the bandwidth is equal to the concentration
parameter.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>. This
makes it easy to specify values like &ldquo;half the default bandwidth&rdquo;.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_type">type</code></td>
<td>
<p>Not Yet Used.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_kernel">kernel</code></td>
<td>
<p>a character string giving the smoothing kernel to be
used. This must be one of <code>"vonmises"</code> or
<code>"wrappednormal"</code>, that are kernels of <code>type</code> <code>"K"</code>.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, missing values are removed from
<code>x</code>. If <code>FALSE</code> any missing values cause an error.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_from">from</code>, <code id="density.circular_+3A_to">to</code></td>
<td>
<p>the left and right-most
points of the grid at which the density is to be estimated. The objects are coerced to class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_n">n</code></td>
<td>
<p>the number of equally spaced points at which the density is
to be estimated.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_k">K</code></td>
<td>
<p>number of terms to be used in approximating the density.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_min.k">min.k</code></td>
<td>
<p>minimum number of terms used in approximating the density.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>x</code> component).</p>
</td></tr>
<tr><td><code id="density.circular_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="density.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object with class <code>"density.circular"</code> whose
underlying structure is a list containing the following components.
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>original dataset.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the <code>n</code> coordinates of the points where the density is
estimated. It is a circular objects with coordinate system setting using <code>control.circular</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the estimated density values.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth used.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the sample size after elimination of missing values.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call which produced the result.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the deparsed name of the <code>x</code> argument.</p>
</td></tr>
<tr><td><code>has.na</code></td>
<td>
<p>logical, for compatibility (always FALSE).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Z.D. Bai and C.R. Rao and L.C. Zhao (1988). Kernel Estimators of Density
Function of Directional Data, Journal of Multivariate Analysis, 27, 24-39.
</p>
<p>J. Klemel\&quot;a (2000). Estimation of densities and derivatives of
densities with directional data, Journal of Multivariate Analysis, 73, 18-40.
</p>
<p>V.R. Prayag and A.P. Gore (1990). Density Estimation for Randomly
Distributed Circular Objects, Metrika, 1990, 37, 63-69.
</p>
<p>P. Hall and G.S. Watson and J. Cabrera (1987). Kernel Density Estimation
with Spherical Data, Biometrika, 74, 4, 751&ndash;762.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.density.circular">plot.density.circular</a></code> and <code><a href="#topic+lines.density.circular">lines.density.circular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=100, mu=circular(pi), kappa=2)
res25 &lt;- density(x, bw=25, control.circular=list(units="degrees"))
circularp(res25$x)
plot(res25, points.plot=TRUE, xlim=c(-1.6,1))
res50 &lt;- density(x, bw=25, adjust=2)
lines(res50, col=2)
lines(res50, col=3, shrink=0.9) #shrink the plot wrt the function :-)
lines(res50, col=4, offset=0.5) #draw it with a reference circle of 0.5 
</code></pre>

<hr>
<h2 id='dist.circular'>Distance Matrix Computation for Circular Data</h2><span id='topic+dist.circular'></span>

<h3>Description</h3>

<p>This function computes and returns the distance matrix computed by
using the specified distance measure to compute the distances between
the rows of a data matrix containing circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.circular(x, method = "correlation", diag = FALSE, upper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.circular_+3A_x">x</code></td>
<td>
<p>a numeric matrix of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="dist.circular_+3A_method">method</code></td>
<td>
<p>the distance measure to be used. This must be one of
<code>"correlation"</code>, <code>"angularseparation"</code>, <code>"chord"</code>,
<code>"geodesic"</code>. Any unambiguous substring can be given.</p>
</td></tr>
<tr><td><code id="dist.circular_+3A_diag">diag</code></td>
<td>
<p>logical value indicating whether the diagonal of the
distance matrix should be printed by <code>print.dist</code>.</p>
</td></tr>
<tr><td><code id="dist.circular_+3A_upper">upper</code></td>
<td>
<p>logical value indicating whether the upper triangle of the
distance matrix should be printed by <code>print.dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available distance measures are (written for two vectors <code class="reqn">x</code> and
<code class="reqn">y</code>):
</p>

<dl>
<dt><code>correlation</code>:</dt><dd><p><code class="reqn">\sqrt{1 - \rho}</code> where <code class="reqn">\rho</code> is the Circular Correlation coefficient defined as </p>
<p style="text-align: center;"><code class="reqn">\frac{\sum_{i=1}^n \sin(x_i - \mu_x) \sin(y_i - \mu_y)}{\sqrt{\sum_{i=1}^n \sin^2(x_i - \mu_x) \sum_{i=1}^n \sin^2(y_i - \mu_y)}}</code>
</p>
<p> and <code class="reqn">\mu_x</code>, <code class="reqn">\mu_y</code> are the mean direction of the two vectors</p>
</dd> 
<dt><code>angularseparation</code>:</dt><dd><p><code class="reqn">\sum_{i=1}^n 1 - cos(x_i - y_i)</code></p>
</dd>
<dt><code>chord</code>:</dt><dd><p><code class="reqn">\sum_{i=1}^n \sqrt{2 (1 - \cos(x_i - y_i))}</code></p>
</dd>
<dt><code>geodesic</code>:</dt><dd><p><code class="reqn">\sum_{i=1}^n \pi - |\pi - |x_i - y_i||</code> where the abs(x - y) is expressed with an angle in [-pi,pi]</p>
</dd>
</dl>

<p>Missing values are allowed, and are excluded from all computations
involving the rows within which they occur.
Further, when <code>Inf</code> values are involved, all pairs of values are
excluded when their contribution to the distance gave <code>NaN</code> or
<code>NA</code>. <br />
If some columns are excluded in calculating the sum is scaled up proportionally
to the number of columns used.  If all pairs are excluded when calculating a
particular distance, the value is <code>NA</code>.
</p>


<h3>Value</h3>

<p><code>dist.circular</code> returns an object of class <code>"dist"</code>.
</p>
<p>The lower triangle of the distance matrix stored by columns in a
vector, say <code>do</code>. If <code>n</code> is the number of
observations, i.e., <code>n &lt;- attr(do, "Size")</code>, then
for <code class="reqn">i &lt; j &lt;= n</code>, the dissimilarity between (row) i and j is
<code>do[n*(i-1) - i*(i-1)/2 + j-i]</code>.
The length of the vector is <code class="reqn">n*(n-1)/2</code>, i.e., of order <code class="reqn">n^2</code>.
</p>
<p>The object has the following attributes (besides <code>"class"</code> equal
to <code>"dist"</code>):
</p>
<table>
<tr><td><code>Size</code></td>
<td>
<p>integer, the number of observations in the dataset.</p>
</td></tr>
<tr><td><code>Labels</code></td>
<td>
<p>optionally, contains the labels, if any, of the
observations of the dataset.</p>
</td></tr>
<tr><td><code>Diag</code>, <code>Upper</code></td>
<td>
<p>logicals corresponding to the arguments <code>diag</code>
and <code>upper</code> above, specifying how the object should be printed.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>optionally, the <code><a href="base.html#topic+call">call</a></code> used to create the
object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>optionally, the distance method used; resulting from
<code><a href="#topic+dist.circular">dist.circular</a>()</code>, the (<code><a href="base.html#topic+match.arg">match.arg</a>()</code>ed) <code>method</code>
argument.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>

<hr>
<h2 id='equal.kappa.test'>Equal Kappa Test</h2><span id='topic+equal.kappa.test'></span><span id='topic+print.equal.kappa.test'></span>

<h3>Description</h3>

<p>This function tests for the homogeneity of concentration parameters for multiple 
samples of directional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal.kappa.test(x, group)
## S3 method for class 'equal.kappa.test'
print(x, digits = max(3, getOption("digits") - 3), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equal.kappa.test_+3A_x">x</code></td>
<td>
<p>a vector of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="equal.kappa.test_+3A_group">group</code></td>
<td>
<p>a vector identifying the groups or samples.</p>
</td></tr>
<tr><td><code id="equal.kappa.test_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="equal.kappa.test_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples are assumed to have been drawn from von Mises populations. 
The null hypothesis tested is that all populations sampled have the same 
concentration parameter, kappa. 
</p>
<p>When the pooled data has high concentration, sample mean resultant length 
above 0.70, Bartlett's test is used. For less concentrated pooled data, 
variance-stabilizing transformations are used to improve normal 
approximations needed to arrive at an approximate chi-squared 
test statistic (see references below). For pooled sample mean resultant 
length below 0.45, it is possible that individually a sample may in fact have 
quite a large sample mean resultant length. In this case, it is possible that 
the variance-stabilizing transformation involving the inverse sine function 
is passed a value outside of -1,1. If this occurs, the function will 
automatically use Bartlett's test and issue a warning to that effect. 
</p>


<h3>Value</h3>

<p>An object of class <code>equal.kappa.test</code> with the following
components:
</p>
<table>
<tr><td><code>kappa</code></td>
<td>
<p>concentration parameter for each sample.</p>
</td></tr>
<tr><td><code>kappa.all</code></td>
<td>
<p>concentration parameter of all samples combined.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>mean resultant length for each sample.</p>
</td></tr>
<tr><td><code>rho.all</code></td>
<td>
<p>mean resultant length of all samples combined.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom for chi-squared distribution.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the chi-squared test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p.value of the test statistic.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, 
Section 5.3, World Scientific Press, Singapore. 
</p>
<p>Mardia, K. and Jupp, P. (1999). Directional Statistics, Section 7.4, John 
Wiley and Sons, England. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(rvonmises(50, circular(0), 1), rvonmises(100, circular(pi/3), 10))
group &lt;- c(rep(0, 50), rep(1, 100)) 

equal.kappa.test(x, group)

</code></pre>

<hr>
<h2 id='fisherB1'>B.1 Arrival times at an intensive care unit</h2><span id='topic+fisherB1'></span><span id='topic+fisherB1c'></span>

<h3>Description</h3>

<p>Arrival time on a 24-hour clock of 254 patients at an intensive care unit, over a period of about 12 months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB1)
data(fisherB1c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB1</code> is a vector of 254 observations (in the format hours.minutes).
<code>fisherB1c</code> contains the same observations in a circular objects (minutes are expressed as decimals).
</p>


<h3>Source</h3>

<p>Cox, D.R. and Lewis, P.A.W. (1966) The Statistical Analysis of Series of Events. London : Methuen &amp; CO. Ltd. pp. 254-255</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB1c)
par(mfcol=c(1,2))
plot(fisherB1c, main="Clock 24", shrink=1.5)
plot(fisherB1c, template="clock12", main="Clock 12", shrink=1.5)
</code></pre>

<hr>
<h2 id='fisherB10'>B.10 Directions of desert ants</h2><span id='topic+fisherB10'></span><span id='topic+fisherB10c'></span>

<h3>Description</h3>

<p>Directions of 11 long-legged desert ants (Cataglyphis fortis) after one eye on each ant was 'trained' to learn the ant's home direction, then covered and the other eye uncovered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB10)
data(fisherB10c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB10</code> is a list (in degrees).
<code>fisherB10c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Personal communication of Prof. Dr. R. Wehner to Prof. N.I. Fisher, experiment described in 
</p>
<p>R. Wehner and M. Muller (1985) Does interocular transfer occur in visual navigation by ants? Nature, 315, 228-9.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 244-245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB10c)
res &lt;- plot(fisherB10c$set1)
points(fisherB10c$set2, col=2, plot.info=res)
points(fisherB10c$set3, col=3, plot.info=res)
</code></pre>

<hr>
<h2 id='fisherB11'>B.11 Movements of sea stars</h2><span id='topic+fisherB11'></span><span id='topic+fisherB11c'></span>

<h3>Description</h3>

<p>Resultant directions of 22 sea stars 11 days after being displaced from their natural habitat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB11)
data(fisherB11c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB11</code> a vector of 22 observations (in degrees).
<code>fisherB11c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>G.J.G. Upton and B. Fingleton (1989) Spatial Data Analysis by Example. Volume 2. Categorical and Directional Data. New York: John Wiley
as adapted from
B. Pabst and H. Vicentini (1978) Dislocation experiments in the migrating seastar. Astropecten jonstoni. Marine Biology 48, 271-8. 
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB11c)
plot(fisherB11c, stack=TRUE, shrink=1.5)
</code></pre>

<hr>
<h2 id='fisherB12'>B.12: Vanishing directions of homing pigeons</h2><span id='topic+fisherB12'></span><span id='topic+fisherB12c'></span>

<h3>Description</h3>

<p>Vanishing directions of 15 homing pigeons, released just over
16 kilometres Northwest of their loft.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB12)
data(fisherB12c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB12</code> a vector of 15 observations (in degrees).
<code>fisherB12c</code> contains the same observations in a circular objects.</p>


<h3>Source</h3>

<p>Schmidt-Koenig (1963) On the role of the loft, the distance and site of
release in pigeon homing (the &quot;cross-loft experiment&quot;). Biol. Bull. (125)154-164.
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB12c)
plot(fisherB12c, stack=TRUE, shrink=1.5)
</code></pre>

<hr>
<h2 id='fisherB13'>B.13: Orientations of termite mounds</h2><span id='topic+fisherB13'></span><span id='topic+fisherB13c'></span>

<h3>Description</h3>

<p>Orientations of termite mounds of Amitermes laurensis at 14 sites in
Cape York Penisula, North Queensland. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB13)
data(fisherB13c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB13</code> a list of 14 datasets (axes in degrees) at several locations.
<code>fisherB13c</code> contains the same observations in a circular objects.</p>


<h3>Details</h3>

<p>Set 1: n=100, Latitude -15'43&rdquo;, Longitude 144'42&rdquo;
Set 2: n=50, Latitude -15'32&rdquo;, Longitude 144'17&rdquo;  
</p>


<h3>Source</h3>

<p>A.V. Spain, T. Okello-Oloya and R.D. John (1983) Orientation of the
termitaria of two species of Amitermes (Isoptera:Termitinae) from
Northern Queensland. Aust. J. Zoo. (31):167-177.
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB13c)
plot(fisherB13c$set1, stack=TRUE, shrink=1.5)
</code></pre>

<hr>
<h2 id='fisherB18'>B.18 Wind direction and ozone concentration.</h2><span id='topic+fisherB18'></span><span id='topic+fisherB18c'></span>

<h3>Description</h3>

<p>19 measurements of wind direction 'theta' and ozone level 'x' taken at 6.00am at four-day intervals between April 18th and June 29th, 1975 at a weather station in Milwaukee.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB18)
data(fisherB18c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB18</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code> of integer value.
<code>fisherB18c</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the same observations, but in the first column, the data is a <code><a href="#topic+circular">circular</a></code> object.
</p>


<h3>Source</h3>

<p>N.I. Fisher (1993) pag. 251. Johnson &amp; Wehrly (1977, Table 1).
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB18)
data(fisherB18c)
par(mfcol=c(1,3))
plot(fisherB18c$theta, xlab=expression(theta))
boxplot(fisherB18c$x, xlab="x")
plot(c(fisherB18$x, fisherB18$x), c(fisherB18$theta,
  fisherB18$theta+360), xlab="x", ylab=expression(theta))
</code></pre>

<hr>
<h2 id='fisherB2'>B.2 Measurements of long-axis orientation of 133 feldspar laths in basalt</h2><span id='topic+fisherB2'></span><span id='topic+fisherB2c'></span>

<h3>Description</h3>

<p>Measurements of long-axis orientation of 133 feldspar laths in basalt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB2)
data(fisherB2c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB2</code> is a vector of 133 observations (in degrees).
<code>fisherB2c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Smith, N.M. (1988) Reconstruction of the Tertiary drainage systems of the Inverell region. Unpublished B.Sc. (Hons.) thesis, Department of Geography, University of Sydney, Australia.
</p>
<p>This dataset (set 28-6-1co.prn) was kindly supplied by Ms Nicola Smith to Prof. N.I. Fisher.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB2c)
plot(fisherB2c)
</code></pre>

<hr>
<h2 id='fisherB20'>B.20 Movements of blue periwinkles.</h2><span id='topic+fisherB20'></span><span id='topic+fisherB20c'></span>

<h3>Description</h3>

<p>Distances 'x' and directions 'theta' by small blue periwinkles, Nodilittorina unifasciata, after they had been transplanted downshore from the height at which they normally live.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB20)
data(fisherB20c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB20</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code> of integer value.
<code>fisherB20c</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code> that contains the same observations, but in the first column, the data is a <code><a href="#topic+circular">circular</a></code> object.
</p>


<h3>Source</h3>

<p>N.I. Fisher (1993) pag. 252-253. Data kindly supplied by Dr A. Underwood and Ms G. Chapman.
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB20)
data(fisherB20c)
par(mfcol=c(1,3))
plot(fisherB20c$theta, xlab=expression(theta))
boxplot(fisherB20c$x, xlab="x")
plot(c(fisherB20$x, fisherB20$x), c(fisherB20$theta,
  fisherB20$theta+360), xlab="x", ylab=expression(theta))

</code></pre>

<hr>
<h2 id='fisherB3'>B.3 Movements of turtles</h2><span id='topic+fisherB3'></span><span id='topic+fisherB3c'></span>

<h3>Description</h3>

<p>Measurements of the directions taken by 76 turtles after treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB3)
data(fisherB3c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB3</code> is a vector of 76 observations (in degrees).
<code>fisherB3c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Stephens, M.A. (1969) Techniques for directional data. Technical Report #150, Department of Statistics, Stanford University, Stanford, CA.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 241.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB3c)
plot(fisherB3c)
</code></pre>

<hr>
<h2 id='fisherB4'>B.4 Directional preferences of starhead topminnows</h2><span id='topic+fisherB4'></span><span id='topic+fisherB4c'></span>

<h3>Description</h3>

<p>Sun compass orientations of 50 starhead topminnows, measured under heavily overcast conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB4)
data(fisherB4c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB4</code> is a vector of 50 observations (in degrees).
<code>fisherB4c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Goodyear (1970) Terrestrial and aquatic orientation in the Starhead Topminnow, Fundulus notti. Science 168, 603-5. Figure 1D.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 241.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB3c)
plot(fisherB3c)
</code></pre>

<hr>
<h2 id='fisherB5'>B.5 Measurements of long-axis orientation of 164 feldspar laths in basalt</h2><span id='topic+fisherB5'></span><span id='topic+fisherB5c'></span>

<h3>Description</h3>

<p>Measurements of long-axis orientation of 164 feldspar laths in basalt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB5)
data(fisherB5c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB5</code> is a vector of 164 observations (in degrees).
<code>fisherB5c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Smith, N.M. (1988) Reconstruction of the Tertiary drainage systems of the Inverell region. Unpublished B.Sc. (Hons.) thesis, Department of Geography, University of Sydney, Australia.
</p>
<p>This dataset (set 24-6-5co.prn) was kindly supplied by Ms Nicola Smith to Prof. N.I. Fisher.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB5c)
plot(fisherB5c)
</code></pre>

<hr>
<h2 id='fisherB6'>B.6 Cross-bed azimuths of palaeocurrents</h2><span id='topic+fisherB6'></span><span id='topic+fisherB6c'></span>

<h3>Description</h3>

<p>Set of cross-bed azimuths of palaeocurrents measured in the Belford Anticline (New South Wales).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB6)
data(fisherB6c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB6</code> is a list (in degrees).
<code>fisherB6c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Fisher, N.I. &amp; Powell C. McA. (1989) Statistical analysis of two-dimensional palaeocurrent data: Methods and examples. Aust. J. Earth Sci. 36, 91-107.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB6c)
res &lt;- plot(fisherB6c$set1)
points(fisherB6c$set2, col=2, plot.info=res)
points(fisherB6c$set3, col=3, plot.info=res)
</code></pre>

<hr>
<h2 id='fisherB7'>B.7 Movements of ants</h2><span id='topic+fisherB7'></span><span id='topic+fisherB7c'></span>

<h3>Description</h3>

<p>Directions chosen by 100 ants in response to an evenly illuminated black targets placed as shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB7)
data(fisherB7c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB7</code> a vector of 100 observations (in degrees).
<code>fisherB7c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Randomly selected values from 
Jander, R. (1957) Die optische Richtangsorientierung der roten Waldameise (Formica rufa. L.) Z. vergl. Physiologie 40, 162-238. Figure 18A. 
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 243.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB7c)
plot(fisherB7c, zero=pi/2, rotation='clock', stack=TRUE)
</code></pre>

<hr>
<h2 id='fisherB8'>B.8 Orientations of pebbles</h2><span id='topic+fisherB8'></span><span id='topic+fisherB8c'></span>

<h3>Description</h3>

<p>Horizontal axes of 100 outwash pebbles fromo a late Wisconsin outwash terrace along Fox river, near Cary, Illinois
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB8)
data(fisherB8c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB8</code> a vector of 100 observations (in degrees).
<code>fisherB8c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Mardia, K.V. (1972) Statistics of Directional Data. London: Academic Press. Table 1.6
adapted from
Krumbein W.C. (1939) Preferred orientations of pebbles in sedimentary deposits. J. Geol. 47, 673-706.
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 243.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB8c)
plot(fisherB8c, stack=TRUE, shrink=1.5)
</code></pre>

<hr>
<h2 id='fisherB9'>B.9 Dance directions of bees</h2><span id='topic+fisherB9'></span><span id='topic+fisherB9direction'></span><span id='topic+fisherB9frequency'></span><span id='topic+fisherB9c'></span>

<h3>Description</h3>

<p>Dance directions of 279 honey bees viewing a zenith patch of artificially polarised light.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fisherB9)
data(fisherB9c)
</code></pre>


<h3>Format</h3>

<p><code>fisherB9</code> a vector of 279 observations (in degrees).
<code>fisherB9c</code> contains the same observations in a circular objects.
</p>


<h3>Source</h3>

<p>Adapted by Prof. N.I. Fisher from 
R. Wehner &amp; S. Strasser (1985) The POL area of the honey bee's eye: behavioural evidence. Physiol. Entomol. 10, 337-49. Pag. 346. 
</p>


<h3>See Also</h3>

<p>N.I. Fisher (1993) Statistical analysis of circular data. Cambridge University Press. Pag. 244.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fisherB9c)
plot(fisherB9c, stack=TRUE, shrink=1.5)
</code></pre>

<hr>
<h2 id='GenVonMises'>Generalized Von Mises Density Function</h2><span id='topic+dgenvonmises'></span><span id='topic+genvonmises'></span>

<h3>Description</h3>

<p>Density for the Generalized von Mises circular distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgenvonmises(x, mu1, mu2, kappa1, kappa2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenVonMises_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="GenVonMises_+3A_mu1">mu1</code></td>
<td>
<p>principal direction of the distribution. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="GenVonMises_+3A_mu2">mu2</code></td>
<td>
<p>secondary direction parameter. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="GenVonMises_+3A_kappa1">kappa1</code></td>
<td>
<p>non-negative numeric parameter of the distribution.</p>
</td></tr>
<tr><td><code id="GenVonMises_+3A_kappa2">kappa2</code></td>
<td>
<p>non-negative numeric parameter of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generalized von Mises distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
	        f(x)=\frac1{2\pi G_0(\delta,\kappa_1,\kappa_2)}
	        \exp\{\kappa_1 \cos(x-\mu_1) + \kappa_2 \cos2(x-\mu_2)\},
	</code>
</p>

<p>for <code class="reqn">0 \le x &lt; 2\pi</code>, where <code class="reqn">\delta=(\mu_1-\mu_2)</code> and <code class="reqn">G_0</code> is the normalizing constant.
</p>


<h3>Value</h3>

<p>The density</p>


<h3>Author(s)</h3>

<p>Federico Rotolo</p>


<h3>References</h3>

<p>Gatto , R. &amp; Jammalamadaka , S.R. (2007). The generalized von Mises distribution. Statistical Methodology 4, 341-353.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- function(x) dgenvonmises(x, mu1=circular(5*pi/4), mu2=circular(pi/4), kappa1=.3, kappa2=1)
curve.circular(ff, join=TRUE, xlim=c(-1, 1), ylim=c(-1.2, 1.2),
  main="Density of a Generalized von Mises Distribution",
  xlab=expression(paste(mu,"1=5/4",pi,", ",mu2,"=",pi/4,", ",kappa,"1=0.3, ",kappa,"2=1"))
  )
</code></pre>

<hr>
<h2 id='heatmap.circular'>
Draw a Heat Map for circular data
</h2><span id='topic+heatmap.circular'></span>

<h3>Description</h3>

<p>A heat map is a false color image (basically
<code><a href="Matrix.html#topic+image">image</a>(t(x))</code>) with a dendrogram added to the left side
and to the top.  Typically, reordering of the rows and columns
according to some set of values (row or column means) within the
restrictions imposed by the dendrogram is carried out. See also <code><a href="stats.html#topic+heatmap">heatmap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.circular(x, Rowv = NULL, Colv = if (symm) "Rowv" else NULL, 
distfun = dist.circular, hclustfun = hclust, 
reorderfun = function(d, w) reorder(d, w), add.expr, symm = FALSE, 
revC = identical(Colv, "Rowv"), na.rm = TRUE, margins = c(5, 5), 
lwid = c(1, 4), lhei = c(1, 4), ColSideColors, RowSideColors, 
NAColors = "black", cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), 
labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, 
keep.dendro = FALSE, annotate.expr, annotate = rep(NA, 4), 
verbose = getOption("verbose"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmap.circular_+3A_x">x</code></td>
<td>
<p>numeric matrix of class <code><a href="#topic+circular">circular</a></code> of the values to be plotted.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_rowv">Rowv</code></td>
<td>
<p>determines if and how the <em>row</em> dendrogram should be
computed and reordered.  Either a <code><a href="stats.html#topic+dendrogram">dendrogram</a></code> or a
vector of values used to reorder the row dendrogram or
<code><a href="base.html#topic+NA">NA</a></code> to suppress any row dendrogram (and reordering) or
by default, <code><a href="base.html#topic+NULL">NULL</a></code>, see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_colv">Colv</code></td>
<td>
<p>determines if and how the <em>column</em> dendrogram should be
reordered.  Has the same options as the <code>Rowv</code> argument above and
<em>additionally</em> when <code>x</code> is a square matrix, <code>Colv =
      "Rowv"</code> means that columns should be treated identically to the
rows (and so if there is to be no row dendrogram there will not be a
column one either).</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity)
between both rows and columns.  Defaults to <code><a href="#topic+dist.circular">dist.circular</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_hclustfun">hclustfun</code></td>
<td>
<p>function used to compute the hierarchical clustering
when <code>Rowv</code> or <code>Colv</code> are not dendrograms.  Defaults to
<code><a href="stats.html#topic+hclust">hclust</a></code>. Should take as argument a result of <code>distfun</code>
and return an object to which <code><a href="stats.html#topic+as.dendrogram">as.dendrogram</a></code> can be applied.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_reorderfun">reorderfun</code></td>
<td>
<p>function(d,w) of dendrogram and weights for
reordering the row and column dendrograms.  The default uses
<code><a href="stats.html#topic+reorder.dendrogram">reorder.dendrogram</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_add.expr">add.expr</code></td>
<td>
<p>expression that will be evaluated after the call to
<code>image</code>.  Can be used to add components to the plot.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_symm">symm</code></td>
<td>
<p>logical indicating if <code>x</code> should be treated
<b>symm</b>etrically; can only be true when <code>x</code> is a square matrix.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_revc">revC</code></td>
<td>
<p>logical indicating if the column order should be
<code><a href="base.html#topic+rev">rev</a></code>ersed for plotting, such that e.g., for the
symmetric case, the symmetry axis is as usual.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code>'s should be removed.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_margins">margins</code></td>
<td>
<p>numeric vector of length 2 containing the margins
(see <code><a href="graphics.html#topic+par">par</a>(mar= *)</code>) for column and row names, respectively.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_lwid">lwid</code></td>
<td>
<p>a vector of values for the widths of columns on the device.
Relative widths are specified with numeric values. Absolute
widths (in centimetres) are specified with the <code><a href="graphics.html#topic+lcm">lcm</a>()</code>
function (see <code><a href="graphics.html#topic+layout">layout</a></code>).</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_lhei">lhei</code></td>
<td>
<p>a vector of values for the heights of rows on the device.
Relative and absolute heights can be specified, see <code>lwid</code> above.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_colsidecolors">ColSideColors</code></td>
<td>
<p>(optional) character vector of length <code>ncol(x)</code>
containing the color names for a horizontal side bar that may be used to
annotate the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_rowsidecolors">RowSideColors</code></td>
<td>
<p>(optional) character vector of length <code>nrow(x)</code>
containing the color names for a vertical side bar that may be used to
annotate the rows of <code>x</code>.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_nacolors">NAColors</code></td>
<td>

<p>the color used to plot missing values.
</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_cexrow">cexRow</code>, <code id="heatmap.circular_+3A_cexcol">cexCol</code></td>
<td>
<p>positive numbers, used as <code>cex.axis</code> in
for the row or column axis labeling.  The defaults currently only
use number of rows or columns, respectively.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_labrow">labRow</code>, <code id="heatmap.circular_+3A_labcol">labCol</code></td>
<td>
<p>character vectors with row and column labels to
use; these default to <code>rownames(x)</code> or <code>colnames(x)</code>,
respectively.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_main">main</code>, <code id="heatmap.circular_+3A_xlab">xlab</code>, <code id="heatmap.circular_+3A_ylab">ylab</code></td>
<td>
<p>main, x- and y-axis titles; defaults to none.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_keep.dendro">keep.dendro</code></td>
<td>
<p>logical indicating if the dendrogram(s) should be
kept as part of the result (when <code>Rowv</code> and/or <code>Colv</code> are
not NA).</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_annotate">annotate</code></td>
<td>
<p>annotation in the four external side of the figure. A positive value in a position means you want annotate something in that position (1=bottom, 2=left, 3=top, 4=right). For instance, <code>annotate=c(0.1, NA, NA, 1, 1)</code> means you want to annotate one thing on the bottom with dimension <code>0.1</code> and two things on right each with dimension <code>1</code>.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_annotate.expr">annotate.expr</code></td>
<td>
<p>must be a list of expressions with the same length as <code>annotate</code>. For instance for <code>annotate=c(0.1, NA, NA, 1, 1)</code> you must have something as <code>annotate.expr=list(expr1, NA, NA, expr2, expr2)</code> where <code>expr1</code> etc. must be a valid <code>R</code> expression able to produce a plot.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information should be printed.</p>
</td></tr>
<tr><td><code id="heatmap.circular_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="Matrix.html#topic+image">image</a></code>,
e.g., <code>col</code> specifying the colors.</p>
</td></tr></table>


<h3>Details</h3>

<p>If either <code>Rowv</code> or <code>Colv</code> are dendrograms they are honored
(and not reordered).  Otherwise, dendrograms are computed as
<code>dd &lt;- as.dendrogram(hclustfun(distfun(X)))</code> where <code>X</code> is
either <code>x</code> or <code>t(x)</code>.
</p>
<p>If either is a vector (of &lsquo;weights&rsquo;) then the appropriate
dendrogram is reordered according to the supplied values subject to
the constraints imposed by the dendrogram, by <code><a href="stats.html#topic+reorder">reorder</a>(dd,
    Rowv)</code>, in the row case.
If either is missing, as by default, then the ordering of the
corresponding dendrogram is by the mean direction value of the rows/columns,
i.e., in the case of rows, <code>Rowv &lt;- rowMeans(x, na.rm=na.rm)</code>.
If either is <code><a href="base.html#topic+NULL">NULL</a></code>, <em>no reordering</em> will be done for
the corresponding side.
</p>
<p>Unless <code>Rowv = NA</code> (or <code>Colw = NA</code>), the original rows and
columns are reordered <em>in any case</em> to match the dendrogram,
e.g., the rows by <code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a>(Rowv)</code> where
<code>Rowv</code> is the (possibly <code><a href="stats.html#topic+reorder">reorder</a>()</code>ed) row
dendrogram.
</p>
<p><code>heatmap()</code> uses <code><a href="graphics.html#topic+layout">layout</a></code> and draws the
<code><a href="Matrix.html#topic+image">image</a></code> in the lower right corner of a 2x2 layout.
Consequentially, it can <b>not</b> be used in a multi column/row
layout, i.e., when <code><a href="graphics.html#topic+par">par</a>(mfrow= *)</code> or <code>(mfcol= *)</code>
has been called.
</p>


<h3>Value</h3>

<p><code><a href="graphics.html#topic+par">par</a>(mfrow= *)</code> or <code>(mfcol= *)</code>
has been called.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli using the code from <code><a href="stats.html#topic+heatmap">heatmap</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.circular">dist.circular</a></code>, <code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code></p>

<hr>
<h2 id='I.0'>Zeroth Order Bessel Function of the First Kind</h2><span id='topic+I.0'></span>

<h3>Description</h3>

<p>An alias of <code>besselI(x, nu=0)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>I.0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="I.0_+3A_x">x</code></td>
<td>
<p>non-negative numerical value at which to evaluate the Bessel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the zeroth order Bessel function of the first kind evaluated at a specified real number.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselI">besselI</a></code>.
</p>

<hr>
<h2 id='I.1'>First Order Bessel Function of the First Kind</h2><span id='topic+I.1'></span>

<h3>Description</h3>

<p>An alias of <code>besselI(x, nu=1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>I.1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="I.1_+3A_x">x</code></td>
<td>
<p>non-negative numerical value at which to evaluate the Bessel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the first order Bessel function of the first kind, evaluated at a specified real number.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselI">besselI</a></code>. 
</p>

<hr>
<h2 id='I.p'>P-th Order Bessel Function of the First Kind</h2><span id='topic+I.p'></span>

<h3>Description</h3>

<p>An alias of <code>besselI(x, nu=p)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>I.p(p, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="I.p_+3A_p">p</code></td>
<td>
<p>positive integer order of the Bessel function.</p>
</td></tr>
<tr><td><code id="I.p_+3A_x">x</code></td>
<td>
<p>non-negative numerical value at which to evaluate the Bessel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the p-th order Bessel function of the first kind, evaluated at a specified real number.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselI">besselI</a></code>.
</p>

<hr>
<h2 id='intersect.modal.region'>
Intersection between model region and a given interval.
</h2><span id='topic+intersect.modal.region'></span><span id='topic+intersect.modal.region.default'></span><span id='topic+intersect.modal.region.circular'></span>

<h3>Description</h3>

<p>Find an estimates of the probability of the intersection between a modal region and a given interval. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect.modal.region(x, ...)
## Default S3 method:
intersect.modal.region(x, ...)
## S3 method for class 'circular'
intersect.modal.region(x, breaks, z = NULL, q = 0.95, bw,
  adjust = 1, type = c("K", "L"), kernel = c("vonmises", "wrappednormal"),
  na.rm = FALSE, step = 0.01, eps.lower = 10^(-4), eps.upper = 10^(-4), ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.modal.region_+3A_x">x</code></td>
<td>
<p>numeric or an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_breaks">breaks</code></td>
<td>
<p>a matrix with two columns. Each row specifies a sub-interval.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_z">z</code></td>
<td>
<p>numeric or object of class <code><a href="#topic+circular">circular</a></code>. The grid
were the kernel density estimate will be evaluated. If <code>NULL</code>
equally spaced points in the interval [0,2*pi) with step <code>step</code>.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_q">q</code></td>
<td>
<p>numeric in the interval [0,1]. The quantile of the modal
region.</p>
</td></tr> 
<tr><td><code id="intersect.modal.region_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used. When the <code>kernel</code>
is <code>vonmises</code> the bandwidth is equal to the concentration
parameter.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>. This
makes it easy to specify values like &ldquo;half the default bandwidth&rdquo;.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_type">type</code></td>
<td>
<p>Not Yet Used.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_kernel">kernel</code></td>
<td>
<p>a character string giving the smoothing kernel to be
used. This must be one of <code>"vonmises"</code> or
<code>"wrappednormal"</code>, that are kernels of <code>type</code> <code>"K"</code>.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, missing values are removed from
<code>x</code>. If <code>FALSE</code> any missing values cause an error.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_step">step</code></td>
<td>
<p>numeric. Used in the construction of the regular grid <code>z</code>.</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_eps.lower">eps.lower</code>, <code id="intersect.modal.region_+3A_eps.upper">eps.upper</code></td>
<td>
<p>the cut point in the density is searched in
the interval [min(density)*(1+eps.lower),max(density)*(1-eps.upper)].</p>
</td></tr>
<tr><td><code id="intersect.modal.region_+3A_...">...</code></td>
<td>
<p>further arguments passed to the next methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Only the version for circular data is actually implemented. 
</p>


<h3>Value</h3>

<p>For the circular method a list with the following three components  
</p>
<table>
<tr><td><code>tot</code></td>
<td>
<p>the total area.</p>
</td></tr>
<tr><td><code>areas</code></td>
<td>
<p>information for each subinterval.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>the extremes of each subinterval.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modal.region">modal.region</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rvonmises(100, circular(pi), 10)  
  res &lt;- intersect.modal.region(x, breaks=circular(matrix(c(pi,pi+pi/12,
    pi-pi/12, pi), ncol=2, byrow=TRUE)), bw=50)
  res$tot

  x &lt;- rvonmises(100, circular(0), 10)
  res &lt;- intersect.modal.region(x, breaks=circular(matrix(c(pi,pi+pi/12),
    ncol=2)), bw=50)
  res$tot
  
  res &lt;- intersect.modal.region(x, breaks=circular(matrix(c(pi/12,
    2*pi-pi/12), ncol=2, byrow=TRUE)), bw=50)
  res$tot
</code></pre>

<hr>
<h2 id='JonesPewsey'>Jones and Pewsey Density Function</h2><span id='topic+djonespewsey'></span><span id='topic+jonespewsey'></span>

<h3>Description</h3>

<p>Density for the Jones and Pewsey circular distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>djonespewsey(x, mu, kappa, psi)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JonesPewsey_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="JonesPewsey_+3A_mu">mu</code></td>
<td>
<p>direction parameter of the distribution. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="JonesPewsey_+3A_kappa">kappa</code></td>
<td>
<p>non-negative concentration parameter of the distribution.</p>
</td></tr>
<tr><td><code id="JonesPewsey_+3A_psi">psi</code></td>
<td>
<p>real shape parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The JonesPewsey distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
		f(x)=\frac{(\cosh(\kappa\psi) + \sinh(\kappa\psi)\cos(x-\mu))^{1/\psi}}
		{2\pi P_{1/\psi}(\cosh(\kappa\psi))},
	</code>
</p>

<p>for <code class="reqn">0 \le x &lt; 2\pi</code>, where <code class="reqn">P_{1/\psi}(\cdot)</code> is the associated Legendre function of the first kind, 		degree <code class="reqn">1/\psi</code> and order 0.
</p>


<h3>Value</h3>

<p>The density</p>


<h3>Author(s)</h3>

<p>Federico Rotolo</p>


<h3>References</h3>

<p>Jones , M.C. and Pewsey, A. (2005). A family of symmetric distributions on the circle. J. Am. Statist. Assoc. 100, 1422-1428</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- function(x) djonespewsey(x, mu=circular(4), kappa=1.8, psi=-.6)
curve.circular(ff, join=TRUE, xlim=c(-1, 1), ylim=c(-1.2, 1.2),
  main="Density of a JonesPewsey Distribution",
  xlab=expression(paste(mu,"=1.3",pi,", ",kappa,"=1.8, ",psi,"=-0.6"))
  )
</code></pre>

<hr>
<h2 id='KatoJones'>Kato and Jones Density Function</h2><span id='topic+rkatojones'></span><span id='topic+dkatojones'></span>

<h3>Description</h3>

<p>Density and random generation for the Kato and Jones distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rkatojones(n, mu, nu, r, kappa, control.circular=list())
dkatojones(x, mu, nu, r, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KatoJones_+3A_x">x</code></td>
<td>
<p>the angular value the density must be computed in.</p>
</td></tr>
<tr><td><code id="KatoJones_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>  
<tr><td><code id="KatoJones_+3A_mu">mu</code></td>
<td>
<p>the Mobius 'mu' parameter. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="KatoJones_+3A_nu">nu</code></td>
<td>
<p>the Mobius 'nu' parameter. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="KatoJones_+3A_r">r</code></td>
<td>
<p>the Mobius 'r' parameter. It must be in [0,1).</p>
</td></tr>
<tr><td><code id="KatoJones_+3A_kappa">kappa</code></td>
<td>
<p>the positive vonMises parameter.</p>
</td></tr>
<tr><td><code id="KatoJones_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The Kato and Jones distribution has density
</p>
<p style="text-align: center;"><code class="reqn">
		f(x)= \frac{1-r^2}{2\pi\mathcal I_0(\kappa)}
		\exp\left[
			\frac{\kappa\{ \xi\cos(x-\eta)-2r\cos\nu \}}
			{1+r^2-2r\cos(x -\gamma)}
		\right]\\
		\phantom{\exp[]} \times \frac1{1+r^2-2r\cos(x -\gamma)},
	</code>
</p>

<p>for <code class="reqn">0 \le x &lt; 2\pi</code>, 
where <code class="reqn">\gamma=\mu+\nu</code>, <code class="reqn">\xi=\{r^4+2r^2\cos(2\nu)+1\}^{1/2}</code>
and <code class="reqn">\eta=\mu+\arg[ r^2\{\cos(2\nu)+i\sin(2\nu)\}+1 ]</code>.
</p>
<p>Original code for random generation is by Kato, S. and Jones, M.C. and can be found at the address 
http://pubs.amstat.org/doi/suppl/10.1198/jasa.2009.tm08313/suppl_file/t08-313code.txt.
</p>


<h3>Value</h3>

<p>The density.
<code>dkatojones</code> gives the density and <code>rkatojones</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Federico Rotolo</p>


<h3>References</h3>

<p>Kato , S. and Jones, M.C. (2010). A family of distributions on the circle with links to, and applications arising from,
Mobius transformation. J. Am. Statist. Assoc. 105, 249-262.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- rkatojones(n=100, mu=circular(0), nu=circular(pi/4), r=.2, kappa=1)
plot(data1)

data1 &lt;- rkatojones(n=100, mu=circular(pi/3), nu=circular(pi), r=.7, kappa=2.3)
plot(data1)

ff &lt;- function(x) dkatojones(x, mu=circular(pi/3), nu=circular(pi), r=.7, kappa=2.3)
curve.circular(ff, join=TRUE, xlim=c(-1, 1), ylim=c(-1.2, 1.2),
  main="Density of a KatoJones Distribution",
  xlab=expression(paste(mu,"=",pi,"/3, ",nu,"=",pi,", r=0.7, ",kappa,"=2.3"))
  )
</code></pre>

<hr>
<h2 id='kuiper.test'>Kuiper's Test</h2><span id='topic+kuiper.test'></span><span id='topic+print.kuiper.test'></span>

<h3>Description</h3>

<p>Performs Kuiper's one-sample test of uniformity on the circle. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kuiper.test(x, alpha=0)
## S3 method for class 'kuiper.test'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kuiper.test_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="kuiper.test_+3A_alpha">alpha</code></td>
<td>
<p>significance level of the test.  Possible levels are
0.15, 0.1, 0.05, 0.025, 0.01.  Alpha may be omitted or set to zero,
in which case a range for the p-value of the test will be printed.</p>
</td></tr>
<tr><td><code id="kuiper.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="kuiper.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kuiper's test statistic is a rotation-invariant Kolmogorov-type test statistic.  The critical values of a modified Kuiper's test statistic are used according to the tabulation given in Stephens (1970). 
</p>


<h3>Value</h3>

<p>A list with the statistic and alpha value.
</p>


<h3>Note</h3>

<p>Kuiper's one-sample test of uniformity is performed, and the results are printed to the screen.  If alpha is specified and non-zero, the test statistic is printed along with the critical value and decision.  If alpha is omitted, the test statistic is printed and a range for the p-value of the test is given.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 7.2, World Scientific Press, Singapore.
</p>
<p>Stephens, M. (1970).  Use of the Kolmogorov-Smirnov, Cramer-von Mises and related statistics without extensive tables.  Journal of the Royal Statistical Society, B32, 115-122.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+range.circular">range.circular</a></code>, <code><a href="#topic+rao.spacing.test">rao.spacing.test</a></code>,
<code><a href="#topic+rayleigh.test">rayleigh.test</a></code> and <code><a href="#topic+watson.test">watson.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from the uniform distribution on the circle.
data &lt;- circular(runif(100, 0, 2*pi))
kuiper.test(data)
# Generate data from the von Mises distribution.
data &lt;- rvonmises(n=100, mu=circular(0), kappa=3)
kuiper.test(data, alpha=0.01)
</code></pre>

<hr>
<h2 id='lines.circular'>Add Connected Line Segments to a Circular Plot</h2><span id='topic+lines.circular'></span>

<h3>Description</h3>

<p>A method taking coordinates in a polar system and joining the corresponding points with line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
lines(x, y, join = FALSE, nosort = FALSE, offset=1, shrink=1,
  plot.info = NULL, zero = NULL, rotation = NULL, modulo = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.circular_+3A_x">x</code></td>
<td>
<p>a vector of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_y">y</code></td>
<td>
<p>a vector with the same length as 'x'.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_join">join</code></td>
<td>
<p>logical: if <code>TRUE</code> the first and the last values are joined by a line.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_nosort">nosort</code></td>
<td>
<p>logical: if <code>TRUE</code> the data are not sorted before
join them.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_offset">offset</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted function.
Default is 1.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_plot.info">plot.info</code></td>
<td>
<p>an object from another circular graphic function.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the axis.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the axis.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_modulo">modulo</code></td>
<td>
<p>the modulo applied to 'x' before sorting.</p>
</td></tr>
<tr><td><code id="lines.circular_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code><a href="graphics.html#topic+lines.default">lines.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvonmises(20, circular(0), 10)
y &lt;- runif(20, 0.5, 1)

plot(x, shrink=2)
lines(x, y)

</code></pre>

<hr>
<h2 id='lines.density.circular'>Add a Plot for Kernel Density Estimation for Circular Data</h2><span id='topic+lines.density.circular'></span>

<h3>Description</h3>

<p>The <code>lines</code> add a plot for <code>density.circular</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density.circular'
lines(x, type = "l", zero.line = TRUE,
  points.plot = FALSE, points.col = 1, points.pch = 1, points.cex = 1,
  plot.type = c("circle", "line"), bins = NULL, offset=1, shrink = 1,
  tcl = 0.025, sep = 0.025, join = TRUE, nosort = FALSE,
  plot.info = NULL, zero = NULL, rotation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.density.circular_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+density.circular">density.circular</a></code>.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_type">type</code></td>
<td>
<p>plotting parameter with useful default.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_zero.line">zero.line</code></td>
<td>
<p>logical; if <code>TRUE</code>, add a base line at <code class="reqn">y =
      0</code>. Used when <code>plot.type</code> is <code>"line"</code>.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_points.plot">points.plot</code></td>
<td>
<p>logical; if <code>TRUE</code> original data are added to
the plot.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_points.col">points.col</code>, <code id="lines.density.circular_+3A_points.pch">points.pch</code>, <code id="lines.density.circular_+3A_points.cex">points.cex</code></td>
<td>
<p>parameters used to draw the points.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_plot.type">plot.type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_bins">bins</code></td>
<td>
<p>number of ticks to plot. </p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_offset">offset</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>  
<tr><td><code id="lines.density.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted function.
Default is 1.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_sep">sep</code></td>
<td>
<p>constant used to specify the distance between stacked points. Default is 0.025; smaller values will create smaller spaces.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_join">join</code></td>
<td>
<p>logical: should the first and the last point joined.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_nosort">nosort</code></td>
<td>
<p>logical: should the data sort before plotting. Defaults is to sort.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_plot.info">plot.info</code></td>
<td>
<p>an object from <code><a href="#topic+plot.circular">plot.circular</a></code> that
contains information on the <code>zero</code>, the <code>rotation</code> and <code>next.points</code>.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="lines.density.circular_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+lines.default">lines.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points and,
if available, the coordinates x and y.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.circular">density.circular</a></code> and <code><a href="#topic+plot.density.circular">plot.density.circular</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- rvonmises(n=100, mu=circular(pi), kappa=2)
y &lt;- rvonmises(n=100, mu=circular(pi/2), kappa=2)
resx &lt;- density(x, bw=25)
res &lt;- plot(resx, points.plot=TRUE, xlim=c(-1.5,1), ylim=c(-1.1, 1.5))
resy &lt;- density(y, bw=25)
lines(resy, points.plot=TRUE, col=2, points.col=2, plot.info=res)
</code></pre>

<hr>
<h2 id='lm.circular'>Circular-Circular and Circular-Linear Regression</h2><span id='topic+lm.circular'></span><span id='topic+lm.circular.cc'></span><span id='topic+lm.circular.cl'></span><span id='topic+print.lm.circular.cl'></span>

<h3>Description</h3>

<p>Fits a regression model for a circular dependent and circular
independent variable or for a circular dependent and linear independent
variables.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.circular(..., type=c("c-c", "c-l"))
lm.circular.cc(y, x, order = 1, level = 0.05, control.circular = list())
lm.circular.cl(y, x, init = NULL, verbose = FALSE, tol = 1e-10, 
  control.circular = list())
## S3 method for class 'lm.circular.cl'
print(x, digits = max(3, getOption("digits") - 3), 
  signif.stars= getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.circular_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>lm.circular.cc</code> or to
<code>lm.circular.cl</code> depending on the value of <code>type</code>.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_type">type</code></td>
<td>
<p>if <code>type=="c-c"</code> then <code>lm.circular.cc</code> is called
otherwise <code>lm.circular.cl</code> is called.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_y">y</code></td>
<td>
<p>vector of data for the dependent circular variable.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_x">x</code></td>
<td>
<p>vector of data for the independent circular variable if
<code>type="c-c"</code> or <code>lm.circular.cc</code> is used otherwise a matrix
or a vector containing the independent linear variables.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_order">order</code></td>
<td>
<p>order of trigonometric polynomial to be fit. Order must be
an integer value.  By default, order=1. Used if <code>type="c-c"</code>.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_level">level</code></td>
<td>
<p>level of the test for the significance of higher order
trigonometric terms. Used if <code>type="c-c"</code>.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>fitted</code>, <code>residuals</code> components in the case of <code>type=="c-c"</code> and <code>mu</code> and <code>se.mu</code>) otherwise.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_init">init</code></td>
<td>
<p>a vector with initial values of length equal to the columns
of <code>x</code>.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_verbose">verbose</code></td>
<td>
<p>logical: if <code>TRUE</code> messages are printed while the
function is running.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_tol">tol</code></td>
<td>
<p>the absolute accuracy to be used to achieve convergence of the
algorithm.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
<tr><td><code id="lm.circular_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical; if <code>TRUE</code>, P-values are additionally encoded
visually as &ldquo;significance stars&rdquo; in order to help scanning of long
coefficient tables. It defaults to the <code>show.signif.stars</code> slot of <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type=="c-c"</code> or <code>lm.circular.cc</code> is called directly a
trigonometric polynomial of x is fit against the cosine and sine of y.
The order of trigonometric polynomial is specified by order.  Fitted
values of y are obtained by taking the inverse tangent of the predicted
values of sin(y) divided by the predicted values of cos(y).  Details of
the regression model can be found in Sarma and Jammalamadaka (1993).
</p>
<p>If <code>type=="c-l"</code> or <code>lm.circular.cl</code> is called directly, 
this function implements the homoscedastic version of the maximum 
likelihood regression model proposed by Fisher and Lee (1992). The 
model assumes that a circular response variable theta has a von Mises 
distribution with concentration parameter kappa, and mean direction 
related to a vector of linear predictor variables according to the 
relationship: mu + 2*atan(beta'*x), where mu and beta are unknown 
parameters, beta being a vector of regression coefficients. The 
function uses Green's (1984) iteratively reweighted least squares 
algorithm to perform the maximum likelihood estimation of kappa, mu, 
and beta. Standard errors of the estimates of kappa, mu, and beta are 
estimated via large-sample asymptotic variances using the information 
matrix. An estimated circular standard error of the estimate of mu is 
then obtained according to Fisher and Lewis (1983, Example 1). 
</p>


<h3>Value</h3>

<p>If <code>type=="c-c"</code> or <code>lm.circular.cc</code> is called directly an
object of class <code>lm.circular.cc</code> is returned with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>square root of the average of the squares of the estimated
conditional concentration parameters of y given x.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values of the model of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>matrix whose columns correspond to x and y.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>circular residuals of the model of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>matrix whose entries are the estimated coefficients of the
model. The first column corresponds to the coefficients of the model predicting
the cosine of y, while the second column contains the estimates for the model
predicting the sine of y.  The rows of the matrix correspond to the coefficients
according to increasing trigonometric order.</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>p-values testing whether the (order + 1) trigonometric terms are
significantly different from zero.</p>
</td></tr>  
<tr><td><code>A.k</code></td>
<td>
<p>is mean of the cosines of the circular residuals.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>assuming the circular residuals come from a von Mises
distribution, kappa is the MLE of the concentration parameter.</p>
</td></tr>
</table>
<p>If <code>type=="c-l"</code> or <code>lm.circular.cl</code> is called directly an
object of class <code>lm.circular.cc</code> is returned with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the independent variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the dependent variable.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the circular mean of the dependent variable of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>se.mu</code></td>
<td>
<p>an estimated standard error of the circular mean with the same units of measure used for <code>mu</code>.</p>
</td></tr> 
<tr><td><code>kappa</code></td>
<td>
<p>the concentration parameter for the dependent variable.</p>
</td></tr>
<tr><td><code>se.kappa</code></td>
<td>
<p>an estimated standard error of the concentration parameter.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients.</p>
</td></tr>
<tr><td><code>cov.coef</code></td>
<td>
<p>covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>se.coef</code></td>
<td>
<p>standard errors of the estimated coefficients.</p>
</td></tr>
<tr><td><code>log.lik</code></td>
<td>
<p>log-likelihood.</p>
</td></tr>
<tr><td><code>t.values</code></td>
<td>
<p>values of the t statistics for the coefficients.</p>
</td></tr>
<tr><td><code>p.values</code></td>
<td>
<p>p-values of the t statistics. Approximated values using
Normal distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Fisher, N. and Lee, A. (1992). Regression models for an angular response. 
Biometrics, 48, 665-677. 
</p>
<p>Fisher, N. and Lewis, T. (1983). Estimating the common mean direction of 
several circular or spherical distributions with different dispersions. 
Biometrika, 70, 333-341. 
</p>
<p>Green, P. (1984). Iteratively reweighted least squares for maximum 
likelihood estimation, and some robust and resistant alternatives. 
Journal of the Royal Statistical Society, B, 46, 149-192. 
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics,
Section 8.3, World Scientific Press, Singapore.
</p>
<p>Sarma, Y. and Jammalamadaka, S. (1993).  Circular Regression.  Statistical
Science and Data Analysis, 109-128.  Proceeding of the Thrid Pacific Area
Statistical Conference.  VSP: Utrecht, Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data set of dependent circular variables.
x &lt;- circular(runif(50, 0, 2*pi))
y &lt;- atan2(0.15*cos(x) + 0.25*sin(x), 0.35*sin(x)) + 
  rvonmises(n=50, mu=circular(0), kappa=5)

# Fit a circular-circular regression model.
circ.lm &lt;- lm.circular(y, x, order=1)
# Obtain a crude plot of the data and fitted regression line.
plot.default(x, y)
circ.lm$fitted[circ.lm$fitted&gt;pi] &lt;- circ.lm$fitted[circ.lm$fitted&gt;pi] - 2*pi 
points.default(x[order(x)], circ.lm$fitted[order(x)], type='l')

# Fit a circular-linear regression model and show predictions.
set.seed(1234)
x &lt;- cbind(rnorm(10), rep(1, 10))
x &lt;- cbind(rnorm(10), rep(1,10))
y &lt;- circular(2*atan(c(x%*%c(5,1))))+rvonmises(10, mu=circular(0), kappa=100)
lm.circular(y=y, x=x, init=c(5,1), type='c-l', verbose=TRUE)
plot(y)
lmC &lt;- lm.circular(y=y, x=x, init=c(5,1), type='c-l', verbose=TRUE)
p &lt;- circular(lmC$mu+2*atan(x%*%lmC$coefficients))
points(p, col=2, pch= "+")
</code></pre>

<hr>
<h2 id='lsfit.circle'>Fit a 2D circle to an (x,y) dataset</h2><span id='topic+lsfit.circle'></span><span id='topic+print.lsfit.circle'></span>

<h3>Description</h3>

<p>Fit a 2D circle to an (x,y) dataset using LS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsfit.circle(x, y, init = NULL, units = c("radians", "degrees"), 
  template = c("none", "geographics"),
  modulo = c("asis", "2pi", "pi"), zero = 0, 
  rotation = c("counter", "clock"), ...)
## S3 method for class 'lsfit.circle'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsfit.circle_+3A_x">x</code></td>
<td>
<p>either a matrix with two columns or a vector.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_y">y</code></td>
<td>
<p>if <code>x</code> is a vector then <code>y</code> must be a vector with the same length.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_init">init</code></td>
<td>
<p>initial values of the parameters. A vector of length 3 with
the following components: radius of the circle, x-coordinate of the
center, y-coordinate of the center. If <code>NULL</code> the vector is set
to <code>c(max(c(abs(x-mean(x)), abs(y-mean(y)))), mean(x), mean(y)</code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_units">units</code></td>
<td>
<p>the <code>units</code> used in defining the angles between
observations and the center of the circle. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_template">template</code></td>
<td>
<p>the <code>template</code> used in defining the angles between
observations and the center of the circle. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_modulo">modulo</code></td>
<td>
<p>the <code>modulo</code> used in defining the angles between
observations and the center of the circle. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_zero">zero</code></td>
<td>
<p>the <code>zero</code> used in defining the angles between
observations and the center of the circle. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_rotation">rotation</code></td>
<td>
<p>the <code>rotation</code> used in defining the angles between
observations and the center of the circle. See <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_...">...</code></td>
<td>
<p>further parameters passed to the <code>optim</code> function.</p>
</td></tr>
<tr><td><code id="lsfit.circle_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>lsfit.circle</code> uses the <code>optim</code> function to minimize the sum of the
squared residuals between the observations and the optimally fitting circle.
</p>


<h3>Value</h3>

<p>An object of class <code>lsfit.circle</code>.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a vector of length 3 with the estimated radius and
coordinate of the center of the fitted circle.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the x-coordinate.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the y-coordinate.</p>
</td></tr>
<tr><td><code>x.centered</code></td>
<td>
<p>the x-coordinate re-centered at the center of the circle.</p>
</td></tr>
<tr><td><code>y.centered</code></td>
<td>
<p>the y-coordinate re-centered at the center of the circle.</p>
</td></tr>
<tr><td><code>angles</code></td>
<td>
<p>angles of the observations with respect to the center
coordinate of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>the distance between the observations and the center
coordinate</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>value from the function optim.</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>the output from the function optim.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

 
<p>Coope, I. (1993). Circle fitting by linear and non-linear least squares. 
Journal of Optimization Theory and Applications, 76, 381-388. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coope)
res &lt;- lsfit.circle(x=x.coope, y=y.coope)
res

plot(res)

par(mfcol=c(1,2))
plot(res$angles)
hist(res$radius)

plot(circular(0), type="n", xlim=c(-5.2, 5.2), ylim=c(-5.2, 5.2), 
  xlab="The Radius of the circle \n is measured from the base line of the axes.")
lines(x=res$angles, y=res$radius, join=TRUE, type="b")
ff &lt;- function(x) sqrt((res$coefficients[1]*cos(x))^2+(res$coefficients[1]*sin(x))^2)
curve.circular(ff, add=TRUE, join=TRUE, nosort=FALSE, col=2)

windrose(x=res$angles, y=res$radius)
</code></pre>

<hr>
<h2 id='mean.circular'>Mean Direction</h2><span id='topic+mean.circular'></span>

<h3>Description</h3>

<p>Returns the mean direction of a vector of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
mean(x, na.rm=FALSE, control.circular=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="mean.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
<tr><td><code id="mean.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="mean.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is treated as a unit vector, or point  on the unit
circle.  The resultant vector of the observations is found, and the
direction of the resultant vector is returned. An <code><a href="base.html#topic+NA">NA</a></code> is
returned if the resultant length (see <code><a href="#topic+rho.circular">rho.circular</a></code>) is
less than <code><a href="base.html#topic+.Machine">.Machine</a></code> 
</p>


<h3>Value</h3>

<p>Returns the mean direction of the data as an object of class <code>circular</code> with the attribute given by <code>control.circular</code> or from <code>x</code> if missed in <code>control.circular</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+summary.circular">summary.circular</a></code>,
<code><a href="#topic+mle.vonmises">mle.vonmises</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="base.html#topic+.Machine">.Machine</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the mean direction of a random sample of observations.
x &lt;- circular(runif(50, circular(0), pi))
mean(x)
</code></pre>

<hr>
<h2 id='meandeviation'>A measure of deviation for Circular Data</h2><span id='topic+meandeviation'></span>

<h3>Description</h3>

<p>Returns a measure of spread associated with the circular median of a vector of circular data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meandeviation(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meandeviation_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="meandeviation_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See equation (2.33) at pag. 36 in Fisher (1993)
for its definition. In the case the circular median is not defined, that
is, every angle is a median axis, the mean deviation is not reported and
set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>Returns a measure of spread associated with the circular median of a
vector of circular data.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge
University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+median.circular">median.circular</a></code>, <code><a href="#topic+sd.circular">sd.circular</a></code>, <code><a href="#topic+angular.variance">angular.variance</a></code>, <code><a href="#topic+angular.deviation">angular.deviation</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=100, mu=circular(0), kappa=1)
meandeviation(x)
</code></pre>

<hr>
<h2 id='median.circular'>
Median Direction
</h2><span id='topic+median.circular'></span>

<h3>Description</h3>

<p>Sample median direction for a vector of circular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
median(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.
</p>
</td></tr>
<tr><td><code id="median.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.
</p>
</td></tr>
<tr><td><code id="median.circular_+3A_...">...</code></td>
<td>
<p>NotYetUsed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Definition in equations 2.32 &amp; 2.33 from N.I. Fisher's 'Statistical Analysis of Circular Data', Cambridge Univ. Press 1993. is implemented.
Since version 0.4-4, the algorithm (not the definition) for the
calculation of the median is changed. For a measure of spread associated to the circular median use function <code><a href="#topic+meandeviation">meandeviation</a></code>.
</p>


<h3>Value</h3>

<p>A scalar with the circular median value.
</p>
<p>The median is returned as an object of class <code>circular</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi
</p>


<h3>References</h3>

<p>N.I. Fisher (1993) Statistical Analysis of Circular Data, Cambridge
University Press.
</p>
<p>R.Y. Liu and K. Singh (1992) Ordering Directional Data: Concepts of
Data Depth on Circles and Spheres, The Annals of Statistics, vol. 20,
n. 3, 1468-1484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meandeviation">meandeviation</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+summary.circular">summary.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and  <code><a href="#topic+medianHL.circular">medianHL.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the median direction of a random sample of observations.
x &lt;- circular(runif(50, circular(0), pi))
median(x) #only the median is returned
meandeviation(x) #mean deviation is reported
</code></pre>

<hr>
<h2 id='medianHL.circular'>
Median using Hodges-Lehmann estimate.
</h2><span id='topic+medianHL.circular'></span><span id='topic+medianHL'></span><span id='topic+medianHL.default'></span>

<h3>Description</h3>

<p>Sample median for a vector of data using Hodges-Lehmann estimate
and Sample median direction measure for a vector of circular data
using Hodges-Lehmann estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medianHL(x, na.rm=FALSE, ...)
## Default S3 method:
medianHL(x, na.rm=FALSE,
       method=c("HL1","HL2","HL3"), prop=NULL,...)
## S3 method for class 'circular'
medianHL(x, na.rm=FALSE,
       method=c("HL1","HL2","HL3"), prop=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medianHL.circular_+3A_x">x</code></td>
<td>
<p>a vector. For the function <code>medianHL.circular</code> the object is
coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="medianHL.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be omitted.</p>
</td></tr>
<tr><td><code id="medianHL.circular_+3A_method">method</code></td>
<td>
<p>The method used to calculate the median, see details below.</p>
</td></tr>
<tr><td><code id="medianHL.circular_+3A_prop">prop</code></td>
<td>
<p>The proportion of pairs that are sampled. If <code>NULL</code>
all combinations are used. It must be a number in the interval (0,1)
or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="medianHL.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to the next method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is as follows:
</p>
<p>The algorithm will create pairs of elements of the vector <code>x</code>.
</p>
<p>It will calculate the circular mean on those pairs.
</p>
<p>It will calculate the circular median on these averages.
</p>
<p>The type of pairs considered are controlled by <code>method</code>:
</p>
<p>if <code>method</code> is &quot;HL1&quot; are considered unordered pairs without
replications and repetition in the number of <code>(n*(n-1))/2</code> pairs;
</p>
<p>if <code>method</code> is &quot;HL2&quot; are considered unordered pairs without
replications in the number of <code>(n*(n+1))/2</code> pairs;
</p>
<p>if <code>method</code> is &quot;HL3&quot; all pairs are considered in the number of <code>n^2</code>.
</p>
<p>If <code>prop</code> is not <code>NULL</code>, the algorithm will consider a
subsample following the rules specified by <code>method</code>, however, the
number of pairs considered is prop * (number of pairs defined by <code>method</code>).
</p>
<p>For more details see Bennett Sango Otieno, 'An Alternative Estimate of
Preferred Direction for Circular Data', Virginia Tech (2002) pag. 27-28 and 46-47.
</p>


<h3>Value</h3>

<p>For <code>medianHL.circular</code> the median is returned as an object of
class <code>circular</code> with the attribute given by those of <code>x</code>.
An attributes <code>medians</code> reports all the averages which are
minimizer of the circular median function.   
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi.
</p>


<h3>References</h3>

<p>Bennett Sango Otieno, An Alternative Estimate of Preferred Direction for Circular Data, Virginia Tech (July 2002).
</p>
<p>Bennett Sango Otieno and Christine M. Anderson-Cook,Measures of preferred direction for environmental and ecological circular data, Springer (June 2004).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+median.circular">median.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the median direction of a random sample of observations.
  x &lt;- circular(runif(50, circular(0), pi))
# Calculate the three medians for each method without \code{prop} argument.
  medianHL.circular(x,method="HL1")
  medianHL.circular(x,method="HL2")
  medianHL.circular(x,method="HL3")
</code></pre>

<hr>
<h2 id='minusPiPlusPi'>
return angles in the [-pi,pi] interval. 
</h2><span id='topic+minusPiPlusPi'></span>

<h3>Description</h3>

<p>return angles in the (-pi,pi] interval. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  minusPiPlusPi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minusPiPlusPi_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+circular">circular</a></code> object with values in the interval (-pi,pi].
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- circular(c(0, 90, 180, 270), units="degrees")
  minusPiPlusPi(x)
</code></pre>

<hr>
<h2 id='mixedvonmises'>Mixture of von Mises Distributions</h2><span id='topic+dmixedvonmises'></span><span id='topic+rmixedvonmises'></span><span id='topic+pmixedvonmises'></span>

<h3>Description</h3>

<p>Density and random generation for the mixed von Mises circular distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixedvonmises(x, mu1, mu2, kappa1, kappa2, prop)
rmixedvonmises(n, mu1, mu2, kappa1, kappa2, prop, control.circular = list())
pmixedvonmises(q, mu1, mu2, kappa1, kappa2, prop, from=NULL, tol = 1e-020)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixedvonmises_+3A_x">x</code>, <code id="mixedvonmises_+3A_q">q</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_mu1">mu1</code></td>
<td>
<p>mean direction of one of the two von Mises distributions as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_mu2">mu2</code></td>
<td>
<p>mean direction of the other von Mises distribution as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_kappa1">kappa1</code></td>
<td>
<p>concentration parameter of one of the two von Mises distributions.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_kappa2">kappa2</code></td>
<td>
<p>concentration parameter of the other von Mises distribution.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_prop">prop</code></td>
<td>
<p>mixing proportion.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_from">from</code></td>
<td>
<p>if <code>NULL</code> is set equal to <code class="reqn">0</code> (Notice the
difference from the corresponding vonmises distribution). This is the value from which the pmixedvonmises is evaluated. It should be a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_tol">tol</code></td>
<td>
<p>the precision in evaluating the distribution function or the
quantile.</p>
</td></tr>
<tr><td><code id="mixedvonmises_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dmixedvonmises</code> gives the density, <code>pmixedvonmises</code> gives the
distribution function and <code>rmixedvonmises</code> generates random deviates. 
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+dvonmises">dvonmises</a></code> <code><a href="#topic+pvonmises">pvonmises</a></code> and <code><a href="#topic+rvonmises">rvonmises</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rmixedvonmises(n=100, mu1=circular(0), mu2=circular(pi), kappa1=15, 
  kappa2=15, prop=0.5)
plot(x)


</code></pre>

<hr>
<h2 id='mle.vonmises'>von Mises Maximum Likelihood Estimates</h2><span id='topic+mle.vonmises'></span><span id='topic+print.mle.vonmises'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimates for the parameters of a von Mises distribution:  the mean direction and the concentration parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.vonmises(x, mu=NULL, kappa=NULL, bias=FALSE, control.circular=list())
## S3 method for class 'mle.vonmises'
print(x,
    digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.vonmises_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_mu">mu</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the mean
direction is calculated. If provided it is coerced to a class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_kappa">kappa</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the
concentration parameter is calculated.</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_bias">bias</code></td>
<td>
<p>logical, if <code>TRUE</code>, the estimate for kappa is
computed with a bias corrected method.  Default is <code>FALSE</code>,
i.e. no bias correction.</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>mu</code>)</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="mle.vonmises_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Best and Fisher (1981) show that the MLE of kappa is seriously biased when both sample size and mean resultant length are small. They suggest a bias-corrected estimate for kappa when n &lt; 16.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the estimate of the mean direction or the value supplied as an object of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>the estimate of the concentration parameter or the
value supplied</p>
</td></tr>
<tr><td><code>se.mu</code></td>
<td>
<p>the standard error for the estimate of the mean
direction (0 if the value is supplied) in the same units of <code>mu</code>.</p>
</td></tr>
<tr><td><code>se.kappa</code></td>
<td>
<p>the standard error for the estimate of the
concentration parameter (0 if the value is supplied).</p>
</td></tr>
<tr><td><code>est.mu</code></td>
<td>
<p>TRUE if the estimator is reported.</p>
</td></tr>
<tr><td><code>est.kappa</code></td>
<td>
<p>TRUE if the estimator is reported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular
Statistics, Section 4.2.1, World Scientific Press, Singapore.
</p>
<p>Best, D. and Fisher N. (1981).  The bias of the maximum likelihood
estimators of the von Mises-Fisher concentration parameters.
Communications in Statistics - Simulation and Computation,
B10(5), 493-502.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code> and <code><a href="#topic+mle.vonmises.bootstrap.ci">mle.vonmises.bootstrap.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=50, mu=circular(0), kappa=5)
mle.vonmises(x) # estimation of mu and kappa
mle.vonmises(x, mu=circular(0)) # estimation of kappa only
</code></pre>

<hr>
<h2 id='mle.vonmises.bootstrap.ci'>Bootstrap Confidence Intervals</h2><span id='topic+mle.vonmises.bootstrap.ci'></span><span id='topic+print.mle.vonmises.bootstrap.ci'></span>

<h3>Description</h3>

<p>Generates simple bootstrap confidence intervals for the parameters of a von Mises distribution: the mean direction mu, and the concentration parameter kappa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.vonmises.bootstrap.ci(x, mu = NULL, bias = FALSE, alpha = 0.05, 
          reps = 1000, control.circular = list())
## S3 method for class 'mle.vonmises.bootstrap.ci'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_x">x</code></td>
<td>
<p>vector of angular measurements as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_mu">mu</code></td>
<td>
<p>If <code>NULL</code> the value is estimated. This value is used in the bootstrap replications for <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_bias">bias</code></td>
<td>
<p>logical, if <code>TRUE</code>, the replication estimates for kappa are computed with a bias corrected method.  See <code><a href="#topic+mle.vonmises">mle.vonmises</a></code>.  Default is <code>FALSE</code>, i.e. no bias correction.</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_alpha">alpha</code></td>
<td>
<p>parameter determining level of confidence intervals. 1-alpha confidence intervals for <code>mu</code> and <code>kappa</code> are computed.  By default, 95% confidence intervals are generated.</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_reps">reps</code></td>
<td>
<p>number of resampled data sets to use.  Default is 1000.</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>mu</code>, <code>mu.ci</code>).</p>
</td></tr>
<tr><td><code id="mle.vonmises.bootstrap.ci_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Percentile confidence intervals are computed by resampling from the original data set <code>reps</code> times.  For each resampled data set, the MLE's of mu and kappa are computed.  The bootstrap confidence intervals are the alpha/2 and 1-alpha/2 percentiles of the <code>reps</code> MLE's computed for each resampled data set.
</p>


<h3>Value</h3>

<p>A list is returned with the following components:
</p>
<table>
<tr><td><code>mu.ci</code></td>
<td>
<p>limits of the confidence interval for mu as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code>kappa.ci</code></td>
<td>
<p>limits of the confidence interval for kappa.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>estimate of mu as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>estimate of kappa.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle.vonmises">mle.vonmises</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=25, mu=circular(0), kappa=3)
x.bs &lt;- mle.vonmises.bootstrap.ci(x, alpha=.10)
par(mfcol=c(1,2))
rose.diag(x.bs$mu, bins=30, main=expression(mu))
hist(x.bs$kappa, main=expression(kappa))
</code></pre>

<hr>
<h2 id='mle.wrappedcauchy'>Wrapped Cauchy Maximum Likelihood Estimates</h2><span id='topic+mle.wrappedcauchy'></span><span id='topic+print.mle.wrappedcauchy'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimates for the parameters of a
Wrapped Cauchy distribution:  mean and concentration parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.wrappedcauchy(x, mu = NULL, rho = NULL, tol = 1e-15, 
        max.iter = 100, control.circular = list())
## S3 method for class 'mle.wrappedcauchy'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.wrappedcauchy_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_mu">mu</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the mean
direction is calculated otherwise it is coerced to an object of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_rho">rho</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the
concentration parameter is calculated.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_tol">tol</code></td>
<td>
<p>precision of the estimation.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>mu</code>)</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="mle.wrappedcauchy_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the estimate of the mean direction or the value supplied as an object of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the estimate of the concentration parameter or the
value supplied</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>TRUE if convergence is achieved.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular
Statistics, Section 4.2.1, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rwrappedcauchy(n=50, mu=circular(0), rho=0.5)
mle.wrappedcauchy(x) # estimation of mu and rho
mle.wrappedcauchy(x, mu=circular(0)) # estimation of rho only
</code></pre>

<hr>
<h2 id='mle.wrappednormal'>Wrapped Normal Maximum Likelihood Estimates</h2><span id='topic+mle.wrappednormal'></span><span id='topic+print.mle.wrappednormal'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimates for the parameters of a
Wrapped Normal distribution:  mean and concentration parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.wrappednormal(x, mu = NULL, rho = NULL, sd = NULL, K = NULL, 
  tol = 1e-05, min.sd = 1e-3, min.k = 10, max.iter = 100, 
  verbose = FALSE, control.circular=list())
## S3 method for class 'mle.wrappednormal'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.wrappednormal_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_mu">mu</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the mean
direction is calculated, otherwise the value is coerced to an object of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_rho">rho</code></td>
<td>
<p>if <code>NULL</code> the maximum likelihood estimate of the
concentration parameter is calculated.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the (unwrapped) normal. Used as an
alternative parametrization.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_k">K</code></td>
<td>
<p>number of terms to be used in approximating the density.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_tol">tol</code></td>
<td>
<p>precision of the estimation.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_min.sd">min.sd</code></td>
<td>
<p>minimum value should be reached by the search procedure
for the standard deviation parameter.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_min.k">min.k</code></td>
<td>
<p>minimum number of terms used in approximating the density.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code> information on the convergence
process are printed.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting objects (<code>mu</code>)</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="mle.wrappednormal_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the estimate of the mean direction or the value supplied as an object of class <code>circular</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the estimate of the concentration parameter or the
value supplied</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the estimate of the standard deviation or the value supplied.</p>
</td></tr>
<tr><td><code>est.mu</code></td>
<td>
<p>TRUE if the estimator is reported.</p>
</td></tr>
<tr><td><code>est.rho</code></td>
<td>
<p>TRUE if the estimator is reported.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>TRUE if the convergence is achieved.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli with a bug fix by Ana Nodehi</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular
Statistics, Section 4.2.1, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rwrappednormal(n=50, mu=circular(0), rho=0.5)
mle.wrappednormal(x) # estimation of mu and rho (and sd)
mle.wrappednormal(x, mu=circular(0)) # estimation of rho (and sd) only
</code></pre>

<hr>
<h2 id='modal.region'>
Modal regions
</h2><span id='topic+modal.region'></span><span id='topic+modal.region.default'></span><span id='topic+modal.region.circular'></span>

<h3>Description</h3>

<p>Evaluate the modal regions for a data set. Only the version for
circular data is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modal.region(x, ...)
## Default S3 method:
modal.region(x, ...)
## S3 method for class 'circular'
modal.region(x, z=NULL, q=0.95, bw, adjust = 1,
  type = c("K", "L"), kernel = c("vonmises", "wrappednormal"),
  na.rm = FALSE, step=0.01, eps.lower=10^(-4), eps.upper=10^(-4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modal.region_+3A_x">x</code></td>
<td>
<p>numeric or an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_z">z</code></td>
<td>
<p>numeric or object of class <code><a href="#topic+circular">circular</a></code>. The grid
were the kernel density estimate will be evaluated. If <code>NULL</code>
equally spaced points in the interval [0,2*pi) with step <code>step</code>.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_q">q</code></td>
<td>
<p>numeric in the interval [0,1]. The quantile of the modal
region.</p>
</td></tr> 
<tr><td><code id="modal.region_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used. When the <code>kernel</code>
is <code>vonmises</code> the bandwidth is equal to the concentration
parameter.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>. This
makes it easy to specify values like &ldquo;half the default bandwidth&rdquo;.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_type">type</code></td>
<td>
<p>Not Yet Used.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_kernel">kernel</code></td>
<td>
<p>a character string giving the smoothing kernel to be
used. This must be one of <code>"vonmises"</code> or
<code>"wrappednormal"</code>, that are kernels of <code>type</code> <code>"K"</code>.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, missing values are removed from
<code>x</code>. If <code>FALSE</code> any missing values cause an error.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_step">step</code></td>
<td>
<p>numeric. Used in the construction of the regular grid <code>z</code>.</p>
</td></tr>
<tr><td><code id="modal.region_+3A_eps.lower">eps.lower</code>, <code id="modal.region_+3A_eps.upper">eps.upper</code></td>
<td>
<p>the cut point in the density is searched in
the interval [min(density)*(1+eps.lower),max(density)*(1-eps.upper)].</p>
</td></tr>
<tr><td><code id="modal.region_+3A_...">...</code></td>
<td>
<p>further arguments passed to the next methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the version for circular data is actually implemented.
</p>


<h3>Value</h3>

<p>A list of class <code>modal.region.circular</code> with the following elements
</p>
<table>
<tr><td><code>zeros</code></td>
<td>
<p>extremes of modal regions, possible as a matrix</p>
</td></tr>
<tr><td><code>areas</code></td>
<td>
<p>a list with two components: <code>tot</code> with the total
(area under the density) probability, which should approximately equal
to <code>q</code> and <code>areas</code> with the probability of each modal region.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>the object from function <code>density.circular</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>the modal region order as in input.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the cut point at the density scale.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli
</p>


<h3>References</h3>

<p>L.G.R. Oliveira-Santos, C.A. Zucco and C. Agostinelli (2013) Using
conditional circular kernel density functions to test hypotheses on
animal circadian activity. Animal Behaviour, 85(1) 269-280.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+totalvariation.circular">totalvariation.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, circular(pi), 10)
res &lt;- modal.region(x, bw=50)
plot(res)
</code></pre>

<hr>
<h2 id='ncfrog'>Northern Cricket Frog</h2><span id='topic+ncfrog'></span><span id='topic+ncfrog.rad'></span>

<h3>Description</h3>

<p>In an experiment due to Ferguson et al. (1967) a number of northern
cricket frogs (Acris crepitans) were collected from the mud flats of an
abandoned stream meandering near Indianola, Mississippi, and taken to a test pen
lying to the north west of the collection point. After 30 hours of
enclosure within a dark environmental chamber, 14 of them were released and
the directions taken by these frogs recorded. 0 degrees means North.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ncfrog)
</code></pre>


<h3>Format</h3>

<p><code>ncfrog</code> is a vector of 14 observations (in degrees).
<code>ncfrog.rad</code> contains the same observations in radians (pi/180).
</p>


<h3>Source</h3>

<p>Collett, D. (1980)
Outliers in Circular Data
<em>Applied Statistics</em>
<b>29</b>, 1, 50&ndash;57.
</p>


<h3>See Also</h3>

<p>Ferguson, D.E, Landreth, H.F. and McKeown, J.P. (1967)
Sun compass orientation of the northern cricket frog, <em>Acris crepitans</em>.
<em>Anim. Behav.</em>,
<b>14</b>, 45&ndash;53.
</p>

<hr>
<h2 id='pigeons'>Initial orientation of displaced homing pigeons</h2><span id='topic+pigeons'></span>

<h3>Description</h3>

<p>This data set has 108 rows and 2 columns. The observations
are the vanishing bearings of homing pigeons displaced and released at
two unfamiliar locations. The data are pooled with respect to the home
direction (home direction set in 360 grades). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pigeons)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>treatment</code></dt><dd><p>, a factor with levels: <em>c</em>, control pigeon
(unmanipulated); <em>v1</em>, pigeons subjected to bilateral section
of the ophthalmic branch of the trigeminal nerve; <em>on</em>,
pigeons subjected to bilateral section of the olfactory nerve</p>
</dd>
<dt><code>bearing</code></dt><dd><p>, vanishing bearing of each bird in degrees</p>
</dd>
</dl>



<h3>References</h3>

<p>Gagliardo A., Ioale' P., Savini M., and Wild M. (2008). Navigational
abilities of homing pigeons deprived of olfactory or trigeminally
mediated magnetic information when young. <em>J. Exp. Biol.</em>,
<b>211</b>:2046&ndash;2051.
</p>

<hr>
<h2 id='plot.circular'>Circular Data Plot</h2><span id='topic+plot.circular'></span>

<h3>Description</h3>

<p>Creates a plot of circular data points on the current graphics device.  Data points are either plotted as points on the unit circle, or the range of the circle is divided into a specified number of bins, and points are stacked in the bins corresponding to the number of observations in each bin. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
plot(x, pch = 16, cex = 1, stack = FALSE,
  axes = TRUE, start.sep=0, sep = 0.025, shrink = 1,
  bins = NULL, ticks = FALSE, tcl = 0.025, tcl.text = 0.125,
  col = NULL, tol = 0.04, uin = NULL,
  xlim = c(-1, 1), ylim = c(-1, 1), digits = 2, units = NULL,
  template = NULL, zero = NULL, rotation = NULL, 
  main = NULL, sub=NULL, xlab = "", ylab = "", 
  control.circle=circle.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.circular_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data.frame. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_pch">pch</code></td>
<td>
<p>point character to use.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_cex">cex</code></td>
<td>
<p>point character size.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_stack">stack</code></td>
<td>
<p>logical; if <code>TRUE</code>, points are stacked on the perimeter of the circle.  Otherwise, all points are plotted on the perimeter of the circle.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_axes">axes</code></td>
<td>
<p>logical; if <code>TRUE</code> axes are plotted according to
properties of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_start.sep">start.sep</code></td>
<td>
<p>constant used to specify the distance between the
center of the point and the axis.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_sep">sep</code></td>
<td>
<p>constant used to specify the distance between stacked points,
if <code>stack==TRUE</code> or in the case of more than one dataset.  Default is 0.025; smaller values will create smaller spaces.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted circle.
Default is 1.  Larger values shrink the circle, while smaller values
enlarge the circle.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_bins">bins</code></td>
<td>
<p>if <code>stack==TRUE</code>, bins is the number of arcs to partition the circle with.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_ticks">ticks</code></td>
<td>
<p>logical; if <code>TRUE</code> ticks are plotted according to the
value of <code>bins</code>.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_tcl.text">tcl.text</code></td>
<td>
<p>The position of the axis labels.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_col">col</code></td>
<td>
<p>color of the points. The values are recycled if needed.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length
1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_xlim">xlim</code>, <code id="plot.circular_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y
axes. Useful for centering the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_main">main</code>, <code id="plot.circular_+3A_sub">sub</code>, <code id="plot.circular_+3A_xlab">xlab</code>, <code id="plot.circular_+3A_ylab">ylab</code></td>
<td>
<p>title, subtitle, x label and y label of the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_units">units</code></td>
<td>
<p>the units used in the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_template">template</code></td>
<td>
<p>the template used in the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_zero">zero</code></td>
<td>
<p>the zero used in the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation used in the plot.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_control.circle">control.circle</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> in order to draw the circle. The function <code><a href="#topic+circle.control">circle.control</a></code> is used to set the parameters.</p>
</td></tr>
<tr><td><code id="plot.circular_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+points.default">points.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When there are many closely distributed observations, stacking is
recommended. When stacking the points, if there are many points in a particular bin, it may be necessary to shrink the plot of the circle so that all points fit. This is controlled with the parameter <code>shrink</code>. Generally the parameter <code>sep</code> does not need adjustment, however, when shrinking the plot, or for a very large number of observations, it may be helpful. Since version 0.3-9 the intervals are on the form [a,b).
</p>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points.
</p>


<h3>Note</h3>

<p>some codes from <code><a href="MASS.html#topic+eqscplot">eqscplot</a></code> in MASS is used.</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+axis.circular">axis.circular</a></code>, <code><a href="#topic+ticks.circular">ticks.circular</a></code>, <code><a href="#topic+points.circular">points.circular</a></code>, <code><a href="#topic+lines.circular">lines.circular</a></code>, <code><a href="#topic+rose.diag">rose.diag</a></code>, <code><a href="#topic+windrose">windrose</a></code> and <code><a href="#topic+curve.circular">curve.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 100 observations from a von Mises distribution.
# with mean direction 0 and concentration 3.
data.vm &lt;- rvonmises(n=100, mu=circular(0), kappa=3) 

# Plot data set. All points do not fit on plot.
plot(data.vm, stack=TRUE, bins=150) 

# Shrink the plot so that all points fit.
plot(data.vm, stack=TRUE, bins=150, shrink=1.5) 

# Recentering the figure in a different place
plot(data.vm, stack=TRUE, bins=150, xlim=c(-1,1.2), ylim=c(-1,0)) 

</code></pre>

<hr>
<h2 id='plot.density.circular'>Plot Method for Kernel Density Estimation for Circular Data</h2><span id='topic+plot.density.circular'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code>density.circular</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density.circular'
plot(x, main=NULL, sub=NULL, xlab=NULL, ylab="Density circular", type="l",
  zero.line=TRUE, points.plot=FALSE, points.col=1, points.pch=1, 
  points.cex=1, plot.type=c("circle", "line"), axes=TRUE, ticks=FALSE, 
  bins=NULL, offset=1, shrink=1, tcl=0.025, tcl.text = 0.125, sep=0.025, tol=0.04, 
  digits=2, cex=1, uin=NULL, xlim=NULL, ylim=NULL, join=FALSE, nosort=FALSE, 
  units=NULL, template=NULL, zero=NULL, rotation=NULL, 
  control.circle=circle.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.density.circular_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+density.circular">density.circular</a></code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_main">main</code>, <code id="plot.density.circular_+3A_sub">sub</code>, <code id="plot.density.circular_+3A_xlab">xlab</code>, <code id="plot.density.circular_+3A_ylab">ylab</code>, <code id="plot.density.circular_+3A_type">type</code></td>
<td>
<p>plotting parameters with useful defaults.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_zero.line">zero.line</code></td>
<td>
<p>logical; if <code>TRUE</code>, add a base line at <code class="reqn">y =
      0</code>. Used when <code>plot.type</code> is <code>"line"</code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_points.plot">points.plot</code></td>
<td>
<p>logical; if <code>TRUE</code> original data are added to
the plot.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_points.col">points.col</code>, <code id="plot.density.circular_+3A_points.pch">points.pch</code>, <code id="plot.density.circular_+3A_points.cex">points.cex</code></td>
<td>
<p>parameters used to draw the points.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_plot.type">plot.type</code></td>
<td>
<p>type of the plot: &quot;line&quot;: linear plot, &quot;circle&quot;: circular plot.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_axes">axes</code></td>
<td>
<p>logical; if <code>TRUE</code> axis are drawn.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_ticks">ticks</code></td>
<td>
<p>logical; if <code>TRUE</code> ticks are drawn.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_bins">bins</code></td>
<td>
<p>number of ticks to plot. </p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_offset">offset</code></td>
<td>
<p>the radius of the circle</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted function.
Default is 1.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_tcl.text">tcl.text</code></td>
<td>
<p>The position of the axis labels.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_sep">sep</code></td>
<td>
<p>constant used to specify the distance between stacked points. Default is 0.025; smaller values will create smaller spaces.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_cex">cex</code></td>
<td>
<p>point character size.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length
1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_xlim">xlim</code>, <code id="plot.density.circular_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y axes. Useful for centering the plot.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_join">join</code></td>
<td>
<p>logical: should the first and the last point joined.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_nosort">nosort</code></td>
<td>
<p>logical: should the data sort before plotting. Defaults is to sort.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_units">units</code></td>
<td>
<p>units measure used in the plot. If <code>NULL</code> the value is taken from the attribute of object 'x' from the argument 'x', i.e. <code>x$x</code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_template">template</code></td>
<td>
<p>template used in the plot.  If <code>NULL</code> the value is taken from the attribute of object 'x' from the argument 'x', i.e. <code>x$x</code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_zero">zero</code></td>
<td>
<p>position of the zero used in the plot.  If <code>NULL</code> the value is taken from the attribute of object 'x' from the argument 'x', i.e. <code>x$x</code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_rotation">rotation</code></td>
<td>
<p>rotation used in the plot.  If <code>NULL</code> the value is taken from the attribute of object 'x' from the argument 'x', i.e. <code>x$x</code>.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_control.circle">control.circle</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> in order to draw the circle. The function <code><a href="#topic+circle.control">circle.control</a></code> is used to set the parameters.</p>
</td></tr>
<tr><td><code id="plot.density.circular_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.circular">density.circular</a></code>, <code><a href="#topic+lines.density.circular">lines.density.circular</a></code>, <code><a href="#topic+plot.circular">plot.circular</a></code>, <code><a href="#topic+lines.circular">lines.circular</a></code> and <code><a href="#topic+curve.circular">curve.circular</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
x &lt;- rvonmises(n=100, mu=circular(pi), kappa=2)
res25x &lt;- density(x, bw=25)
plot(res25x, points.plot=TRUE, xlim=c(-1.5,1))
res50x &lt;- density(x, bw=25, adjust=2)
lines(res50x, col=2)

resp25x &lt;- plot(res25x, points.plot=TRUE, xlim=c(-1, 1.3), ylim=c(-1.5,1.2), 
  template="geographics", main="Plotting density estimate for two data set")
y &lt;- rvonmises(n=100, mu=circular(pi/2), kappa=2, 
  control.circular=list(template="geographics"))
res25y &lt;- density(y, bw=25)
lines(res25y, points.plot=TRUE, plot.info=resp25x, col=2, points.col=2)

plot(res25x, plot.type="line", points.plot=TRUE, xlim=c(-1, 1.3), ylim=c(-1.5,1.2), 
  template="geographics", main="Plotting density estimate for two data set")
lines(res25y, plot.type="line", points.plot=TRUE, col=2, points.col=2)

</code></pre>

<hr>
<h2 id='plot.edf'>Plot Circular Empirical Distribution Function</h2><span id='topic+plot.edf'></span><span id='topic+lines.edf'></span>

<h3>Description</h3>

<p>Plots the empirical distribution function of a circular data set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'edf'
plot(x, type = "s", xlim = c(0, 2 * pi), ylim = c(0, 1), ...)
## S3 method for class 'edf'
lines(x, type = "s", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.edf_+3A_x">x</code></td>
<td>
<p>vector of circular data measured.</p>
</td></tr>
<tr><td><code id="plot.edf_+3A_type">type</code>, <code id="plot.edf_+3A_xlim">xlim</code>, <code id="plot.edf_+3A_ylim">ylim</code></td>
<td>
<p>plotting parameters with useful defaults. <code>xlim</code> is in radians.</p>
</td></tr>
<tr><td><code id="plot.edf_+3A_...">...</code></td>
<td>
<p>optional graphical parameters.  See help section on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector of data is taken modulo 2*pi, and then the linear ranks are used to generate an empirical distribution function.
</p>


<h3>Note</h3>

<p>Creates a plot or adds a plot (<code>lines.edf</code>) of the empirical
distribution function of the circular data vector.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ecdf">plot.ecdf</a></code>, <code><a href="#topic+curve.circular">curve.circular</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare the edf's of two simulated sets of data.
data1 &lt;- rvonmises(n=10, mu=circular(0), kappa=3)
data2 &lt;- rvonmises(n=10, mu=circular(0), kappa=1)
plot.edf(data1, xlab="Data", ylab="EDF", main="Plots of Two EDF's")
lines.edf(data2, lty=2, col=2)

#You can use standard ecdf and plot.ecdf functions
ff &lt;- function(x, data) {
     x &lt;- x
     data &lt;- data
     temp &lt;- ecdf(data)
     temp(x)
}
plot(function(x) ff(x, data=data1), from=0, to=2*pi-3*.Machine$double.eps)

#Or curve.circular
plot.function.circular(function(x) ff(x, data=data1), from=0, 
  to=(2*pi-3*.Machine$double.eps), join=FALSE, nosort=TRUE, xlim=c(-2,2), 
  ylim=c(-2,2), modulo="asis", main="Empirical Distribution Function", 
  n=2001, tcl.text=0.25)

res &lt;- plot.function.circular(function(x) ff(x, data=data2), from=0, 
  to=(2*pi-3*.Machine$double.eps), join=FALSE, nosort=TRUE, modulo="asis", 
  add=TRUE, col=2, n=2001)

res1 &lt;- points(data1, plot.info=res)
points(data2, plot.info=res1, col=2, sep=0.05)

legend(-1.9, 1.9, legend=c("data1", "data2"), col=c(1,2), lty=c(1,1))
</code></pre>

<hr>
<h2 id='plot.lsfit.circle'>Plot method for lsfit.circle function</h2><span id='topic+plot.lsfit.circle'></span>

<h3>Description</h3>

<p>This is a plot method for objects of class <code>lsfit.circle</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsfit.circle'
plot(x, add = FALSE, main = NULL, xlim = NULL, ylim = NULL, 
  xlab = NULL, ylab = NULL, uin, tol = 0.04, plus.cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lsfit.circle_+3A_x">x</code></td>
<td>
<p>an object of class <code>lsfit.circle</code>.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_add">add</code></td>
<td>
<p>logical: if <code>TRUE</code> the plot is superimposed on the
active device.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (min,max) of the plot.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_ylab">ylab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length 1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_plus.cex">plus.cex</code></td>
<td>
<p>dimension of the cross in the center of the circle.</p>
</td></tr>
<tr><td><code id="plot.lsfit.circle_+3A_...">...</code></td>
<td>
<p>further arguments passed to the next method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsfit.circle">lsfit.circle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coope)
res &lt;- lsfit.circle(x=x.coope, y=y.coope)
plot(res)
</code></pre>

<hr>
<h2 id='points.circular'>Add Points to a Circular Plot</h2><span id='topic+points.circular'></span>

<h3>Description</h3>

<p>Add points to a plot of circular data points on the current graphics device. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
points(x, pch = 16, cex = 1, stack = FALSE,
  start.sep=0, sep = 0.025, 
  shrink = 1, bins = NULL, col = NULL, next.points = NULL, 
  plot.info = NULL, zero = NULL, rotation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.circular_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data.frame. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_pch">pch</code></td>
<td>
<p>point character to use.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_cex">cex</code></td>
<td>
<p>point character size.  See help on par.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_stack">stack</code></td>
<td>
<p>logical: if <code>TRUE</code>, points are stacked on the
perimeter of the circle.  Otherwise, all points are plotted on the
perimeter of the circle.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_start.sep">start.sep</code></td>
<td>
<p>constant used to specify the distance between the
center of the point and the axis.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_sep">sep</code></td>
<td>
<p>constant used to specify the distance between stacked points,
if <code>stack==TRUE</code> or in the case of more than one dataset.  Default is 0.025; smaller values will create smaller spaces.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted circle.
Default is 1.  Larger values shrink the circle, while smaller values
enlarge the circle.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_bins">bins</code></td>
<td>
<p>if <code>stack==TRUE</code>, bins is the number of arcs to partition the circle with.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_col">col</code></td>
<td>
<p>color of the points. The values are recycled if needed.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_next.points">next.points</code></td>
<td>
<p>if <code>stack=FALSE</code>, the distance from the circle
the next dataset is plotted. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_plot.info">plot.info</code></td>
<td>
<p>an object from <code><a href="#topic+plot.circular">plot.circular</a></code> that
contains information on the <code>zero</code>, the <code>rotation</code> and <code>next.points</code>.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="points.circular_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+points.default">points.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When there are many closely distributed observations, stacking is
recommended. When stacking the points, if there are many points in a particular bin, it may be necessary to shrink the plot of the circle so that all points fit. This is controlled with the parameter <code>shrink</code>. Generally the parameter <code>sep</code> does not need adjustment, however, when shrinking the plot, or for a very large number of observations, it may be helpful. Since version 0.3-9 the intervals are on the form [a,b).
</p>


<h3>Value</h3>

<p>A list with information on the plot: zero, rotation and next.points.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code> and <code><a href="#topic+lines.circular">lines.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.1 &lt;- rvonmises(n=100, mu=circular(0), kappa=3)
data.2 &lt;- rvonmises(n=100, mu=circular(pi/3), kappa=3) 
res &lt;- plot(data.1, stack=FALSE, col=1) 
points(data.2, plot.info=res, col=2)
</code></pre>

<hr>
<h2 id='pp.plot'>von Mises Probability-Probability Plot</h2><span id='topic+pp.plot'></span>

<h3>Description</h3>

<p>Plots the empirical distribution of a data set against the best fitting
von Mises distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.plot(x, ref.line = TRUE, tol=1e-20,  xlab = "von Mises Distribution", 
  ylab = "Empirical Distribution", control.circular = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.plot_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="pp.plot_+3A_ref.line">ref.line</code></td>
<td>
<p>logical, if TRUE a 45 degree reference line is added to
the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pp.plot_+3A_tol">tol</code></td>
<td>
<p>parameter passed to <code><a href="#topic+pvonmises">pvonmises</a></code>.</p>
</td></tr>
<tr><td><code id="pp.plot_+3A_xlab">xlab</code>, <code id="pp.plot_+3A_ylab">ylab</code></td>
<td>
<p>labels of the axis.</p>
</td></tr>
<tr><td><code id="pp.plot_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="pp.plot_+3A_...">...</code></td>
<td>
<p>parameters passed to the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum likelihood estimates of the parameters of the von Mises distribution are computed from the given data set.  The empirical distribution function is plotted against a von Mises distribution function with parameters given by the MLEs computed. 
</p>


<h3>Value</h3>

<p>a list with the estimated mean and concentration parameter for a von
Mises distribution.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 10.2, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mle.vonmises">mle.vonmises</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=25, mu=circular(0), kappa=3)
pp.plot(x)
x &lt;- c(rvonmises(n=20, mu=circular(0), kappa=7), 
  rvonmises(n=20, mu=circular(pi), kappa=7))
pp.plot(x)
</code></pre>

<hr>
<h2 id='pp.unif.plot'>Uniform Circular Probability-Probability Plot</h2><span id='topic+pp.unif.plot'></span>

<h3>Description</h3>

<p>Plots the empirical distribution of a data set against a uniform circular distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.unif.plot(x, ref.line = TRUE, frac = NULL,  xlab = "Uniform Distribution", 
  ylab = "Empirical Distribution", col = NULL,
  col.inf = NULL, col.sup = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.unif.plot_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="pp.unif.plot_+3A_ref.line">ref.line</code></td>
<td>
<p>logical, if TRUE a 45 degree reference line is added to
the plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pp.unif.plot_+3A_frac">frac</code></td>
<td>
<p>a number in the [0,1] interval or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pp.unif.plot_+3A_xlab">xlab</code>, <code id="pp.unif.plot_+3A_ylab">ylab</code></td>
<td>
<p>labels of the axis.</p>
</td></tr>
<tr><td><code id="pp.unif.plot_+3A_col">col</code></td>
<td>
<p>color of the points.</p>
</td></tr>
<tr><td><code id="pp.unif.plot_+3A_col.inf">col.inf</code>, <code id="pp.unif.plot_+3A_col.sup">col.sup</code></td>
<td>
<p>color of the <code>frac</code>tion of the points replicated in the left bottom and right upper corner of the plot.</p>
</td></tr>    
<tr><td><code id="pp.unif.plot_+3A_...">...</code></td>
<td>
<p>parameters passed to the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp.plot">pp.plot</a> for the von Mises distribution.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=25, mu=circular(0), kappa=3)
pp.unif.plot(x)
pp.unif.plot(x, frac=0.2)  
</code></pre>

<hr>
<h2 id='projected+20bivariate+20normal+20on+20the+20circle'>
Projected bivariate normal on the circle  
</h2><span id='topic+dpnorm'></span><span id='topic+rpnorm'></span>

<h3>Description</h3>

<p>The projected normal distribution provides a flexible distribution for circular data, e.g., asymmetry and possible bimodality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpnorm(x, mu, sigma, log = FALSE)
rpnorm(n, mu, sigma, control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_x">x</code></td>
<td>
<p>a vector. The <code>x</code> and <code>q</code> objects are coerced to class <code><a href="#topic+circular">circular</a></code>.
</p>
</td></tr>
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr> 
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_mu">mu</code></td>
<td>
<p>the mean vector of the bivariate normal.</p>
</td></tr>
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_sigma">sigma</code></td>
<td>
<p>the 2x2 variance and covariance matrix of the bivariate normal.</p>
</td></tr>
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code> the log of the density is reported.</p>
</td></tr>
<tr><td><code id="projected+2B20bivariate+2B20normal+2B20on+2B20the+2B20circle_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p><code>dpnorm</code> gives the density, <code>rpnorm</code> generates random deviates.</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli
</p>


<h3>References</h3>

<p>S.R. Jammalamadaka and A. SenGupta (2001). Topics in Circular Statistics, Section 2.2.4, World Scientific Press, Singapore.
K.V. Mardia (1972). Statistics of Directional Data. Academic Press. London and New York.    
F. Wang and A.E. Gelfand (2013). Directional data analysis under the general projected normal distribution. Stat Methodol. 10(1):113-127. doi:10.1016/j.stamet.2012.07.005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- rpnorm(100, mu=c(0,0), sigma=diag(2),
  control.circular=list(units="degrees")) # Uniform on the circle
plot(data1)

ff &lt;- function(x) dpnorm(x, mu=c(0,0), sigma=diag(2)) # Uniform on the circle
curve.circular(ff, join=TRUE,
  main="Density of a Projected Normal Distribution \n mu=(0,0), sigma=diag(2)")

ff &lt;- function(x) dpnorm(x, mu=c(1,1), sigma=diag(2)) # Unimodal
curve.circular(ff, join=TRUE, xlim=c(-1, 2.3),
  main="Density of a Projected Normal Distribution \n mu=(1,1), sigma=diag(2)")

sigma &lt;- matrix(c(1,0.9,0.9,1), nrow=2)  
ff &lt;- function(x) dpnorm(x, mu=c(0.5,0.5), sigma=sigma) # Bimodal
curve.circular(ff, join=TRUE, xlim=c(-1, 2.3),
  main="Density of a Projected Normal Distribution \n mu=(0.5,0.5), rho=0.9")
</code></pre>

<hr>
<h2 id='quantile.circular'>Sample Circular Quantiles</h2><span id='topic+quantile.circular'></span>

<h3>Description</h3>

<p>The function <code>quantile.circular</code> produces sample circular quantiles
corresponding to the given probabilities for a circular data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
quantile(x, probs = seq(0, 1, 0.25), na.rm=FALSE, names = TRUE, type = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.circular_+3A_x">x</code></td>
<td>
<p>numeric circular vector whose sample quantiles are wanted. <code><a href="base.html#topic+NA">NA</a></code> and <code>NaN</code> values are not
allowed in numeric vectors unless <code>na.rm</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="quantile.circular_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in
<code class="reqn">[0,1]</code>.  (Values up to &lsquo;<span class="samp">&#8288;2e-14&#8288;</span>&rsquo; outside that
range are accepted and moved to the nearby endpoint.)</p>
</td></tr>
<tr><td><code id="quantile.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any <code><a href="base.html#topic+NA">NA</a></code> and <code>NaN</code>'s
are removed from <code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="quantile.circular_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code><a href="base.html#topic+names">names</a></code>
attribute.  Set to <code>FALSE</code> for speedup with many <code>probs</code>.</p>
</td></tr>
<tr><td><code id="quantile.circular_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the
nine quantile algorithms detailed below to be used.</p>
</td></tr>
<tr><td><code id="quantile.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.
Like <code>quantile</code> and so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector of length <code>length(probs)</code> is returned;
if <code>names = TRUE</code>, it has a <code><a href="base.html#topic+names">names</a></code> attribute.
</p>
<p><code><a href="base.html#topic+NA">NA</a></code> and <code><a href="base.html#topic+NaN">NaN</a></code> values in <code>probs</code> are
propagated to the result.
</p>
<p>The algorithm will proceed how described below:
1) Linearize the circular observations.
2) Calculate the linear median like type establish.
3) The value it will transformed in circular.
</p>


<h3>Types</h3>

<p>See description on documentation of <code>quantile</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Alessandro Gagliardi.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(1001, mu=circular(pi), kappa=5)
quantile.circular(x) # Extremes &amp; Quartiles by default
</code></pre>

<hr>
<h2 id='rad'>Radians</h2><span id='topic+rad'></span>

<h3>Description</h3>

<p>Converts degrees to radians. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rad_+3A_x">x</code></td>
<td>
<p>vector or matrix of degree measurements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is available for compatibility with the CircStats
package, please use <code><a href="#topic+conversion.circular">conversion.circular</a></code>.</p>


<h3>Value</h3>

<p>Returns a vector or matrix of radian measurements corresponding to the data in degrees.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+conversion.circular">conversion.circular</a></code> and <code><a href="#topic+deg">deg</a></code>
</p>

<hr>
<h2 id='range.circular'>Circular Range</h2><span id='topic+range.circular'></span>

<h3>Description</h3>

<p>Computes the circular range of a data set and performs a test of uniformity if specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
range(x, test=FALSE, na.rm = FALSE, finite = FALSE, 
  control.circular=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="range.circular_+3A_test">test</code></td>
<td>
<p>logical flag:  if TRUE then the test of uniformity is
performed; otherwise the test is not performed.  Default is FALSE.</p>
</td></tr>
<tr><td><code id="range.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be omitted.</p>
</td></tr>
<tr><td><code id="range.circular_+3A_finite">finite</code></td>
<td>
<p>logical, indicating if all non-finite elements should be
omitted.</p>
</td></tr>
<tr><td><code id="range.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="range.circular_+3A_...">...</code></td>
<td>
<p>further parameter passed from/to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The circular range is the shortest arc on the circle containing the
entire set of data.  The p-value is computed using the exact
distribution of the circular range under the hypothesis of uniformity,
details can be found in Mardia and Jupp (1999) pag. 107.
</p>


<h3>Value</h3>

<p>Returns the circular range as a <code>circular</code> object.  If the significance test is requested the p-value of the test is returned as p.value.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>K.V. Mardia and P.E. Jupp (1999) Directional Statistics, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kuiper.test">kuiper.test</a></code>, <code><a href="#topic+rao.spacing.test">rao.spacing.test</a></code>,
<code><a href="#topic+rayleigh.test">rayleigh.test</a></code> and <code><a href="#topic+watson.test">watson.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rvonmises(n=50, mu=circular(0), kappa=2)
range(data, test=TRUE)
data &lt;- circular(runif(50, 0, 2*pi))
range(data, test=TRUE)
</code></pre>

<hr>
<h2 id='rao.spacing.test'>Rao's Spacing Test of Uniformity</h2><span id='topic+rao.spacing.test'></span><span id='topic+print.rao.spacing.test'></span>

<h3>Description</h3>

<p>Performs Rao's spacing test of uniformity. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rao.spacing.test(x, alpha=0)
## S3 method for class 'rao.spacing.test'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rao.spacing.test_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="rao.spacing.test_+3A_alpha">alpha</code></td>
<td>
<p>numeric value specifying the significance level of the
test. The default value is 0, in which case, a range for the p-value
will be returned.  Valid significance levels are 0.10, 0.05, 0.01 and
0.001.</p>
</td></tr>
<tr><td><code id="rao.spacing.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="rao.spacing.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If alpha is specified, critical values are determined (using the <code>print</code> function) from a table of simulated critical points (see reference below); in this case the <code>print</code> function return a further value <code>accepted</code> which is <code>TRUE</code> if the null hypothesis is accepted and <code>FALSE</code> otherwise. If alpha is not specified, a range for the p-value is determined using the table of simulated critical points in the <code>print</code> function but not reported.
</p>


<h3>Value</h3>

<p>a list with the statistic, alpha and the number of observations.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 7.4, World Scientific Press, Singapore.
</p>
<p>Rao, J.S. (1976). Some tests based on arc-lengths for the circle. Sankhya, The Indian Journal of Statistics, Serial B(4), 38, 329-338.
</p>
<p>Russell, G.S. and Levitin, D.J. (1995).  An expanded table of probability values for Rao's Spacing Test.  Communications in Statistics - Simulation and Computation, 24, 4, 879-888.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+range.circular">range.circular</a></code>, <code><a href="#topic+kuiper.test">kuiper.test</a></code>, <code><a href="#topic+rayleigh.test">rayleigh.test</a></code> and <code><a href="#topic+watson.test">watson.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- circular(runif(200, 0, 2*pi))
rao.spacing.test(x)

res &lt;- print(rao.spacing.test(x, alpha=0.1))
res$accepted

x &lt;- rvonmises(100, circular(0), 20)
rao.spacing.test(x)
</code></pre>

<hr>
<h2 id='rao.table'>Table for Rao's Spacing Test of Uniformity</h2><span id='topic+rao.table'></span>

<h3>Description</h3>

<p>Table for Rao's spacing test of uniformity</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rao.table)</code></pre>


<h3>Author(s)</h3>

<p>Ulric Lund</p>


<h3>See Also</h3>

<p><code><a href="#topic+rao.spacing.test">rao.spacing.test</a></code>
</p>

<hr>
<h2 id='rao.test'>Rao's Tests for Homogeneity</h2><span id='topic+rao.test'></span><span id='topic+print.rao.test'></span>

<h3>Description</h3>

<p>Performs Rao's test for homogeneity on k populations of angular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rao.test(..., alpha=0)
## S3 method for class 'rao.test'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rao.test_+3A_...">...</code></td>
<td>
<p>a sequence of <code><a href="#topic+circular">circular</a></code> for the
<code>rao.test</code> and further arguments passed to or from other
methods for the <code>print.rao.test</code> function.</p>
</td></tr>
<tr><td><code id="rao.test_+3A_alpha">alpha</code></td>
<td>
<p>numeric value specifying the significance level of the
test. Default is 0, in which case p-values for the test statistic is
printed.</p>
</td></tr>
<tr><td><code id="rao.test_+3A_x">x</code></td>
<td>
<p>an object from the <code>rao.test</code>.</p>
</td></tr>
<tr><td><code id="rao.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Critical values and p-values are determined according to the chi-squared approximation of the test statistic.
</p>


<h3>Value</h3>

<p>A list with the statistic and p.value for the mean and the dispersion
and the value of alpha. 
</p>


<h3>Note</h3>

<p>The test is performed, and the results are written to the screen. Test results are given for both the test of equality of polar vectors, and of dispersions.  If alpha is specified, the test statistic is printed, along with the level critical value.  If alpha is not specified, a p-value for the test is printed.  
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 7.6.1, World Scientific Press, Singapore.
</p>
<p>Rao, J.S. (1967). Large sample tests for the homogeneity of angular data, Sankhya, Ser, B., 28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, circular(0), kappa=10)
y &lt;- rvonmises(100, circular(0), kappa=10)

rao.test(x, y)

</code></pre>

<hr>
<h2 id='rayleigh.test'>Rayleigh Test of Uniformity</h2><span id='topic+rayleigh.test'></span><span id='topic+print.rayleigh.test'></span>

<h3>Description</h3>

<p>Performs a Rayleigh test of uniformity, assessing the significance of
the mean resultant length.  The alternative hypothesis is a unimodal
distribution with unknown mean direction and unknown mean resultant
length if <code>mu</code> is <code>NULL</code> otherwise the alternative hypothesis is a unimodal distribution with a specified mean direction and unknown mean resultant length.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayleigh.test(x, mu = NULL)
## S3 method for class 'rayleigh.test'
print(x, digits=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rayleigh.test_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="rayleigh.test_+3A_mu">mu</code></td>
<td>
<p>Specified mean direction in alternative hypothesis as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="rayleigh.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="rayleigh.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three components:  the mean resultant length, <code>statistic</code>, the p-value of the test statistic, <code>p.value</code> and
the value of the alternative mean direction <code>mu</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Sections 3.3.2 and 3.4.1, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+range.circular">range.circular</a></code>, <code><a href="#topic+kuiper.test">kuiper.test</a></code>,
<code><a href="#topic+rao.spacing.test">rao.spacing.test</a></code> and <code><a href="#topic+watson.test">watson.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=25, mu=circular(pi), kappa=2)
# General alternative
rayleigh.test(x)
# Specified alternative
rayleigh.test(x, mu=circular(0))
</code></pre>

<hr>
<h2 id='rho.circular'>Mean Resultant Length</h2><span id='topic+rho.circular'></span>

<h3>Description</h3>

<p>Returns the mean resultant length of a vector of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho.circular(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="rho.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is treated as a unit vector, or point  on the unit circle.  The resultant vector of the observations is found, and the length of the resultant vector divided by the sample size is returned.
</p>


<h3>Value</h3>

<p>Returns the mean resultant length of data.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+var.circular">var.circular</a></code>,
<code><a href="#topic+summary.circular">summary.circular</a></code> and <code><a href="#topic+mle.vonmises">mle.vonmises</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the mean resultant length of a random sample of observations.
data &lt;- circular(runif(100, 0, 2*pi))
rho.circular(data)
</code></pre>

<hr>
<h2 id='rose.diag'>Rose Diagram</h2><span id='topic+rose.diag'></span>

<h3>Description</h3>

<p>Creates a rose diagram of a circular data set on the current graphics device.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose.diag(x, pch = 16, cex = 1, axes = TRUE, shrink = 1, 
  bins = NULL, upper = TRUE, ticks = TRUE, tcl = 0.025, tcl.text = 0.125,
  radii.scale = c("sqrt", "linear"), border=NULL, col=NULL, tol = 0.04,
  uin = NULL, xlim = c(-1, 1), ylim = c(-1, 1), prop = 1, digits = 2, 
  plot.info = NULL, units = NULL, template = NULL, zero = NULL, 
  rotation = NULL, main = NULL, sub = NULL, xlab = "", ylab = "",
  add = FALSE, control.circle = circle.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose.diag_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data.frame. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_pch">pch</code></td>
<td>
<p>point character to use.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_cex">cex</code></td>
<td>
<p>point character size.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_axes">axes</code></td>
<td>
<p>logical: if <code>TRUE</code> axes are plotted according to properties of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_shrink">shrink</code></td>
<td>
<p>parameter that controls the size of the plotted circle.
Default is 1.  Larger values shrink the circle, while smaller values enlarge the circle.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_bins">bins</code></td>
<td>
<p>number of arcs to partition the circle with.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_upper">upper</code></td>
<td>
<p>therose diagram cells are &quot;upper&quot;-closed intervals.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_ticks">ticks</code></td>
<td>
<p>logical: if <code>TRUE</code> ticks are plotted according to the
value of <code>bins</code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_tcl.text">tcl.text</code></td>
<td>
<p>the position of the axis labels.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_radii.scale">radii.scale</code></td>
<td>
<p>make possible to choose sector radius form:
square-root of relative frequency (<code>sqrt</code>, default) or
conventional linear scale (<code>linear</code>).</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_border">border</code></td>
<td>
<p>the color to draw the border. The default, <code>NULL</code>, means to
use <code>par("fg")</code>.  Use <code>border = NA</code> to omit borders.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_col">col</code></td>
<td>
<p>the color for filling the rose diagram. The default,
<code>NULL</code>, is to leave rose diagram unfilled.
color of the points. The values are recycled if needed.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length
1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_xlim">xlim</code>, <code id="rose.diag_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y
axes. Useful for centering the plot.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_prop">prop</code></td>
<td>
<p>numerical constant determining the radii of the sectors.  By default, prop = 1.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_plot.info">plot.info</code></td>
<td>
<p>an object from <code><a href="#topic+plot.circular">plot.circular</a></code> that
contains information on the <code>zero</code>, the <code>rotation</code> and <code>next.points</code>.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_units">units</code></td>
<td>
<p>the <code>units</code> used in the plot. If <code>NULL</code> the <code>units</code> of the first component of 'x' is used.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_template">template</code></td>
<td>
<p>the template of the plot. Ignored if <code>plot.info</code> is provided.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_zero">zero</code></td>
<td>
<p>the zero of the plot. Ignored if <code>plot.info</code> or <code>template</code> are provided.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the plot. Ignored if <code>plot.info</code> or <code>template</code> are provided.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_main">main</code>, <code id="rose.diag_+3A_sub">sub</code>, <code id="rose.diag_+3A_xlab">xlab</code>, <code id="rose.diag_+3A_ylab">ylab</code></td>
<td>
<p>title, subtitle, x label and y label of the plot.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_add">add</code></td>
<td>
<p>add the rose diag to an existing plot.</p>
</td></tr>
<tr><td><code id="rose.diag_+3A_control.circle">control.circle</code></td>
<td>
<p>parameters passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code> in order to draw the circle. The function <code><a href="#topic+circle.control">circle.control</a></code> is used to set the parameters.</p>
</td></tr> 
<tr><td><code id="rose.diag_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The circumference of the circle is split into groups, the number of groups specified by bins. For each group, a sector is drawn. The radii of the sectors are by default equal to the square root of the relative frequencies of observations in each group. This ensures that the area of the sector is proportional to the group frequency. The length of the radii can be controlled by varying the parameter prop. Since version 0.3-9 the intervals are on the form [a,b).
</p>


<h3>Value</h3>

<p>a list with information on the plot: zero, rotation and next.points.
</p>


<h3>Note</h3>

<p>some codes from <code><a href="MASS.html#topic+eqscplot">eqscplot</a></code> in MASS is used. Since
version 0.4-1 the meaning of the <code>col</code> parameter is changed.</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli, Ulric Lund and Hiroyoshi Arai</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate uniform data and create several rose diagrams.  
# Some optional parameters may be needed to optimize plots.
x &lt;- circular(runif(50, 0, 2*pi))
rose.diag(x, bins = 18, main = 'Uniform Data')
points(x)

# Generate von Mises data and create several rose diagrams.
x &lt;- rvonmises(n=50, mu=circular(0), kappa=5, control.circular=list(zero=pi/4))
y &lt;- rose.diag(x, bins=18) # Points fall out of bounds.
points(x, plot.info=y, stack=TRUE)
y &lt;- rose.diag(x, bins=18, prop=1.5, shrink=1.5) # Adjust optional parameters to fit
######## all points on plot.
points(x, plot.info=y, stack=TRUE)

# Add the rose diag to a plot
plot(x)
rose.diag(x, bins=12, add=TRUE, col=2)

# Examples on using radii.scale and prop with a dummy dataset where 
# highest proportion is 50% in bin 2
x &lt;- c(2, 2, 2, 2, 5, 5, 10, 20)
circ.x &lt;- circular::circular(x, units = "hours", template = "clock24")
old_par &lt;- par(mfrow = c(2, 2))
rose.diag(circ.x, bins=24, main="radii.scale=linear, prop=1",
          radii.scale="linear", prop=1)
rose.diag(circ.x, bins=24, main = "radii.scale=linear, prop=2",
          radii.scale="linear", prop=2)
rose.diag(circ.x, bins=24, main = "radii.scale=sqrt, prop=1",
          radii.scale="sqrt", prop=1)
rose.diag(circ.x, bins=24, main = "radii.scale=sqrt, prop=sqrt(2)",
          radii.scale="sqrt", prop=sqrt(2))
par(old_par)
</code></pre>

<hr>
<h2 id='rstable'>Random Generation from the Stable Family of Distributions</h2><span id='topic+rstable'></span>

<h3>Description</h3>

<p>Returns random deviates from the stable family of probability distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstable(n, scale = 1, index = stop("no index arg"), skewness = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstable_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="rstable_+3A_index">index</code></td>
<td>
<p>number from the interval (0, 2]. An index of 2 corresponds to the normal, 1 to the Cauchy.  Smaller values mean longer tails.</p>
</td></tr>
<tr><td><code id="rstable_+3A_skewness">skewness</code></td>
<td>
<p>number giving the modified skewness (see Chambers et al., 1976).  Negative values correspond to skewness to the left (the median is smaller than the mean, if it exists), and positive values correspond to skewness to the right (the median is larger than the mean). The absolute value of skewness should not exceed 1.</p>
</td></tr>
<tr><td><code id="rstable_+3A_scale">scale</code></td>
<td>
<p>the scale of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return random variates from the Levy skew stable
distribution with <code>index</code>=<code class="reqn">\alpha</code>, <code>scale</code>=<code class="reqn">c</code> and <code>skewness</code>=<code class="reqn">\beta</code>.  The <code>skewness</code> parameter must lie in the range [-1,1] while the <code>index</code> parameter must lie in the range (0,2].  The Levy skew stable probability distribution is defined by a Fourier transform,
</p>
<p style="text-align: center;"><code class="reqn">
p(x) = {1 \over 2 \pi} \int_{-\infty}^{+\infty} dt \exp(-it x - |c t|^\alpha (1-i \beta sign(t) \tan(\pi\alpha/2)))
</code>
</p>

<p>When <code class="reqn">\alpha = 1</code> the term <code class="reqn">\tan(\pi \alpha/2)</code> is replaced by <code class="reqn">-(2/\pi)\log|t|</code>.   For <code class="reqn">\alpha = 2</code> the distribution reduces to a Gaussian distribution with <code class="reqn">\sigma = \sqrt{2} scale</code> and the skewness parameter has no effect. For <code class="reqn">\alpha &lt; 1</code> the tails of the distribution become extremely wide. The symmetric distribution corresponds to <code class="reqn">\beta = 0</code>.
</p>
<p>The Levy alpha-stable distributions have the property that if <code class="reqn">N</code> alpha-stable variates are drawn from the distribution <code class="reqn">p(c, \alpha, \beta)</code> then the sum <code class="reqn">Y = X_1 + X_2 + \dots + X_N</code> will also be distributed as an alpha-stable variate, <code class="reqn">p(N^{1/\alpha} c, \alpha, \beta)</code>.
</p>
<p>There is no explicit solution for the form of <code class="reqn">p(x)</code> and there are no density, probability or quantile functions supplied for this distribution.
</p>


<h3>Value</h3>

<p>random sample from the specified stable distribution.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Chambers, J. M., Mallows, C. L. and Stuck, B. W. (1976). A Method for Simulating Stable Random Variables. Journal of the American Statistical Association 71, 340-344.
</p>
<p>Logaeve, M. (1977). Probability Theory I. (fourth edition) Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rnorm">rnorm</a>, <a href="stats.html#topic+rcauchy">rcauchy</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist(rstable(200, 1.5, .5)) #fairly long tails, skewed right
</code></pre>

<hr>
<h2 id='rwrappedstable'>Random Generation from the Wrapped Stable Distribution</h2><span id='topic+rwrappedstable'></span>

<h3>Description</h3>

<p>Generates pseudo-random numbers from a wrapped stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwrappedstable(n, scale=1, index, skewness, control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwrappedstable_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate.</p>
</td></tr>
<tr><td><code id="rwrappedstable_+3A_scale">scale</code></td>
<td>
<p>the scale of the distribution.</p>
</td></tr>
<tr><td><code id="rwrappedstable_+3A_index">index</code></td>
<td>
<p>number from the interval (0, 2]. An index of 2 corresponds to the normal, 1 to the Cauchy.  Smaller values mean longer tails.</p>
</td></tr>
<tr><td><code id="rwrappedstable_+3A_skewness">skewness</code></td>
<td>
<p>number giving the modified skewness. Negative values correspond to skewness to the left (the median is smaller than the mean, if it exists), and positive values correspond to skewness to the right (the median is larger than the mean). The absolute value of skewness should not exceed 1.</p>
</td></tr>
<tr><td><code id="rwrappedstable_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n random numbers are generated from a stable distribution with with parameters index, skewness and scale. The function returns these values modulo 2*pi.
</p>


<h3>Value</h3>

<p>Returns a vector of n independent random numbers generated from a wrapped stable distribution.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.8, World Scientific Press, Singapore.
</p>

<hr>
<h2 id='sd'>Standard Deviation</h2><span id='topic+sd'></span><span id='topic+sd.default'></span><span id='topic+sd.data.frame'></span>

<h3>Description</h3>

<p>The <code>sd</code> function from the <span class="pkg">base</span> is replace by a new
<code>method</code> in order to report the standard deviation of circular data
appropriately. <code>sd.default</code> is an alias of the original function
<code>sd</code> see <code><a href="stats.html#topic+sd">sd</a></code>. The behavior would be the same
for objects which are not from <code><a href="base.html#topic+class">class</a></code>
<code><a href="base.html#topic+data.frame">data.frame</a></code> and <code><a href="#topic+circular">circular</a></code> (in the last case
the standard deviation is define as in Mardia (1972) </p>
<p style="text-align: center;"><code class="reqn">\sqrt{-2\ln r}</code>
</p>
<p> where <code>r</code> is the mean resultant length of
the data, see <code><a href="#topic+sd.circular">sd.circular</a></code> for more details). The method for
<code>data.frame</code> will apply the <code>sd</code> function to each columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd(x, ...)
## Default S3 method:
sd(x, na.rm = FALSE, ...)
## S3 method for class 'data.frame'
sd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="sd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="sd_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="#topic+sd.circular">sd.circular</a></code>, <code><a href="#topic+var.circular">var.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>

<hr>
<h2 id='sd.circular'>Circular Standard Deviation</h2><span id='topic+sd.circular'></span>

<h3>Description</h3>

<p>Returns the circular standard deviation of a vector of circular data which is
defined as the square root of minus 2 times the log of the mean resultant
length divided by the number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
sd(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="sd.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
<tr><td><code id="sd.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the circular standard deviation as defined by Mardia (1972) </p>
<p style="text-align: center;"><code class="reqn">\sqrt{-2\ln r}</code>
</p>
<p> where <code>r</code> is the mean resultant length of the data.
</p>


<h3>Value</h3>

<p>Returns the circular standard deviation.
</p>



<h3>Author(s)</h3>

<p>Claudio Agostinelli and Jean-Olivier Irisson</p>


<h3>References</h3>

<p>Mardia, K.V. (1972) Statistics of Directional Data. Academic Press,
London, sec. 26.5, p. 617
</p>
<p>Fisher, N.I. (1993) Statistical analysis of circular data. Cambridge University Press.
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>
<p>Zar, J H (2010). Biostatistical analysis. Prentice Hall. sec. 26.5, p. 617
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+angular.deviation">angular.deviation</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the circular standard deviation of a random
# sample of observations from a von Mises distribution
x &lt;- rvonmises(n=100, mu=circular(0, units="degrees"), kappa=10)
sd(x)
</code></pre>

<hr>
<h2 id='summary.circular'>Circular Summary Statistics</h2><span id='topic+summary.circular'></span>

<h3>Description</h3>

<p>Computes circular summary statistics including the sample size, mean
direction and mean resultant length and quartiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
summary(object,
   digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.circular_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="summary.circular_+3A_digits">digits</code></td>
<td>
<p>digits to be used in printing.</p>
</td></tr>
<tr><td><code id="summary.circular_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="base.html#topic+summary.matrix">summary.matrix</a></code> if needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is  treated  as  a  unit  vector or a point on the unit circle.  The resultant vector of the observations is found, and the direction of the resultant vector is returned as well as its length divided by the sample size.  
</p>


<h3>Value</h3>

<p>Returns a vector with the sample size, the sample mean direction and the sample mean resultant length.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli, David Andel and Alessandro Gagliardi</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+median.circular">median.circular</a></code>,
<code><a href="#topic+quantile.circular">quantile.circular</a></code>, <code><a href="#topic+var.circular">var.circular</a></code>,
<code><a href="#topic+mle.vonmises">mle.vonmises</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute summary statistics of a random sample of observations. 
data &lt;- circular(runif(50, 0, pi))
summary(data)
summary(data.frame(data, runif(50, 0, pi)))
</code></pre>

<hr>
<h2 id='swallows'>
Orientation of juvenile barn swallows
</h2><span id='topic+swallows'></span>

<h3>Description</h3>

<p>The _swallows_ dataset has 114 rows and 2 columns. The observations are the headings of juvenile barn swallows (_Hirundo rustica_) tested in orientation cages (Emlen funnels) during autumn migration under simulated overcast conditions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swallows)</code></pre>


<h3>Format</h3>

<p>A data frame with 114 observations on the following 2 variables.
</p>

<dl>
<dt><code>treatment</code></dt><dd><p>a factor with levels <code>control</code> (control
group: local magnetic field) and 
<code>shifted</code> (shifted magnetic field, magnetic North =
geographical West)</p>
</dd>
<dt><code>heading</code></dt><dd><p>a numeric vector:  modal heading of each bird</p>
</dd>
</dl>



<h3>Source</h3>

<p>Giunchi, D., and Baldaccini N. E. (2004) Orientation of juvenile barn swallows (Hirundo rustica) tested in Emlen funnels during autumn migration. Behav. Ecol. Sociobiol. (56):124-131. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swallows)

swallows &lt;- split(swallows$heading, swallows$treatment)
swallows &lt;- lapply(swallows, function(x) circular(x, units='degrees', template='geographics'))

plot(swallows[[1]])
points(swallows[[2]], col=2)
legend('topright', legend=c('control', 'shifted'), pch=c(19,19), col=c(1,2))
</code></pre>

<hr>
<h2 id='ticks.circular'>Draw Tick-Marks in a Circular Plot</h2><span id='topic+ticks.circular'></span>

<h3>Description</h3>

<p>Draw tick-marks in a circular plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ticks.circular(x, template = c("none", "geographics"), zero = NULL, 
  rotation = NULL, tcl = 0.025, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ticks.circular_+3A_x">x</code></td>
<td>
<p>the points at which tick-marks are to be drawn.</p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_template">template</code></td>
<td>
<p>either <code>none</code> or <code>geographics</code>.</p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_zero">zero</code></td>
<td>
<p>the zero of the plot (in radians).</p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_rotation">rotation</code></td>
<td>
<p>the rotation of the plot.</p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_col">col</code></td>
<td>
<p>color for the tick marks. If <code>NULL</code>, function uses &lsquo;par(&quot;col.axis&quot;)&rsquo;. </p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks.</p>
</td></tr>
<tr><td><code id="ticks.circular_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>line.default</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.circular">plot.circular</a></code> and <code><a href="#topic+axis.circular">axis.circular</a></code>.
</p>

<hr>
<h2 id='totalvariation.circular'>
Conditional total variation distance between two circular samples. 
</h2><span id='topic+totalvariation.circular'></span>

<h3>Description</h3>

<p>The total variation distance between two circular samples is
evaluated conditional on a circular modal region.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totalvariation.circular(x, y, z = NULL, q = 0.95, bw, adjust = 1,
type = c("K", "L"), kernel = c("vonmises", "wrappednormal"),
na.rm = FALSE, step = 0.001, eps.lower = 10^(-4), eps.upper = 10^(-4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalvariation.circular_+3A_x">x</code></td>
<td>
<p>numeric or an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_y">y</code></td>
<td>
<p>numeric or an object of class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_z">z</code></td>
<td>
<p>numeric or object of class <code><a href="#topic+circular">circular</a></code>. The grid
were the kernel density estimate will be evaluated. If <code>NULL</code>
equally spaced points in the interval [0,2*pi) with step <code>step</code>.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_q">q</code></td>
<td>
<p>numeric in the interval [0,1]. The quantile of the modal
region.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_bw">bw</code></td>
<td>
<p>the smoothing bandwidth to be used. When the <code>kernel</code>
is <code>vonmises</code> the bandwidth is equal to the concentration
parameter.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>. This
makes it easy to specify values like &ldquo;half the default bandwidth&rdquo;.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_type">type</code></td>
<td>
<p>Not Yet Used.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_kernel">kernel</code></td>
<td>
<p>a character string giving the smoothing kernel to be
used. This must be one of <code>"vonmises"</code> or
<code>"wrappednormal"</code>, that are kernels of <code>type</code> <code>"K"</code>.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, missing values are removed from
<code>x</code>. If <code>FALSE</code> any missing values cause an error.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_step">step</code></td>
<td>
<p>numeric. Used in the construction of the regular grid <code>z</code>.</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_eps.lower">eps.lower</code>, <code id="totalvariation.circular_+3A_eps.upper">eps.upper</code></td>
<td>
<p>the cut point in the density is searched in
the interval [min(density)*(1+eps.lower),max(density)*(1-eps.upper)].</p>
</td></tr>
<tr><td><code id="totalvariation.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to the
<code>modal.region.circular</code> function. Not used at present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>totalvariation.circular</code> with the following
components
</p>
<table>
<tr><td><code>tv</code></td>
<td>
<p>the (conditional) total variation.</p>
</td></tr>
<tr><td><code>ovl</code></td>
<td>
<p>the (conditional) overlapping coefficient.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>the order of the modal regions.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth value as in input.</p>
</td></tr> 
<tr><td><code>modal.x</code></td>
<td>
<p>an object of class <code><a href="#topic+modal.region.circular">modal.region.circular</a></code>
for the <code>x</code> data set.</p>
</td></tr>
<tr><td><code>modal.y</code></td>
<td>
<p>an object of class <code><a href="#topic+modal.region.circular">modal.region.circular</a></code>
for the <code>y</code> data set.</p>
</td></tr>
<tr><td><code>density.x</code></td>
<td>
<p>an object of class <code><a href="#topic+density.circular">density.circular</a></code>
for the <code>x</code> data set.</p>
</td></tr>
<tr><td><code>density.y</code></td>
<td>
<p>an object of class <code><a href="#topic+density.circular">density.circular</a></code>
for the <code>y</code> data set.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>a function which report the positive part of the
difference between the estimated density of the two data sets.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Claudio Agostinelli
</p>


<h3>References</h3>

<p>L.G.R. Oliveira-Santos, C.A. Zucco and C. Agostinelli (2013) Using
conditional circular kernel density functions to test hypotheses on
animal circadian activity. Animal Behaviour, 85(1) 269-280.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modal.region.circular">modal.region.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(100, circular(pi), 10)
y &lt;- rvonmises(100, circular(pi+pi/8), 10)
res &lt;- totalvariation.circular(x,y,bw=50)
plot(res)
</code></pre>

<hr>
<h2 id='triangular'>Triangular Density Function</h2><span id='topic+dtriangular'></span><span id='topic+rtriangular'></span>

<h3>Description</h3>

<p>Density and random generation for the Triangular circular distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtriangular(x, rho)
rtriangular(n, rho, control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="triangular_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>  
<tr><td><code id="triangular_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution.  rho must be
between 0 and <code class="reqn">4/pi^2</code>.</p>
</td></tr>
<tr><td><code id="triangular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dtriangular</code> gives the density and <code>rtriangular</code> generates
random deviates.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.3, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- rtriangular(100, 0.3, control.circular=list(units="degrees"))
plot(data1)

ff &lt;- function(x) dtriangular(x, rho=0.3)
curve.circular(ff, shrink=1.2, join=TRUE)

</code></pre>

<hr>
<h2 id='trigonometric.moment'>Trigonometric Moments</h2><span id='topic+trigonometric.moment'></span>

<h3>Description</h3>

<p>Computes the specified order trigonometric moment for a set of directional data points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trigonometric.moment(x, p = 1, center = FALSE, control.circular = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trigonometric.moment_+3A_x">x</code></td>
<td>
<p>a vector of class <code>circular</code>.</p>
</td></tr>
<tr><td><code id="trigonometric.moment_+3A_p">p</code></td>
<td>
<p>order of trigonometric moment to be computed. Default is for a first order trigonometric moment.</p>
</td></tr>
<tr><td><code id="trigonometric.moment_+3A_center">center</code></td>
<td>
<p>logical, whether to compute centered moments or not.  Default is to compute an uncentered moment.</p>
</td></tr>
<tr><td><code id="trigonometric.moment_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object <code>mu</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with variables mu, rho, cos, sin, p, n, call,
respectively the pth trigonometric moment's direction, resultant length,
real and imaginary components, the order, the number of observations and
the call.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>,
<code><a href="#topic+summary.circular">summary.circular</a></code>, <code><a href="#topic+mle.vonmises">mle.vonmises</a></code> and <code><a href="#topic+rho.circular">rho.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvonmises(100, circular(0), 5)
trigonometric.moment(x, control.circular=list(units="degrees"))

</code></pre>

<hr>
<h2 id='turtles'>
Arrival directions of displaced sea turtles</h2><span id='topic+turtles'></span>

<h3>Description</h3>

<p>The _turtles_ dataset has 10 rows and 2 columns. The observations are the directions from which 10 green sea turtles approached their nesting island (Ascension Island, South Atlantic Ocean) after having been displaced to open-sea sites.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(turtles)</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 2 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector: the turtle ID</p>
</dd>
<dt><code>arrival</code></dt><dd><p>a numeric vector: the direction of arrival to Ascension Island</p>
</dd>
</dl>



<h3>Source</h3>

<p>Luschi, P., Akesson, S., Broderick, A. C., Glen, F., Godley, B. J., Papi F., and Hays, G. C. (2001) Testing the navigational abilities of ocean migrants: displacement experiments on green sea turtles (_Chelonia mydas_). Behav. Ecol. Sociobiol. (50):528-534.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turtles)
turtles[,2] &lt;- circular(turtles[,2], units='degrees', template='geographics')
plot(turtles[,2])
</code></pre>

<hr>
<h2 id='unique.circular'>Extract Unique Elements from a circular vector</h2><span id='topic+unique.circular'></span>

<h3>Description</h3>

<p><code>unique.circular</code> returns a circular vector but with duplicate  elements removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
unique(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.circular_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unique.circular_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="base.html#topic+unique.default">unique.default</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code>circular</code> object. See the documentation of <code><a href="base.html#topic+unique">unique</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same type of <code>x</code>, but if
an element is equal to one with a smaller index, it is removed.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rvonmises(10, circular(0), 10)
unique(x)

</code></pre>

<hr>
<h2 id='var'>Variance</h2><span id='topic+var'></span><span id='topic+var.default'></span><span id='topic+var.data.frame'></span>

<h3>Description</h3>

<p>The <code>var</code> function from the <span class="pkg">stats</span> is replace by a new
<code>method</code> in order to report the variance of circular data
appropriately. <code>var.default</code> is an alias of the original function
<code>var</code> see <code><a href="stats.html#topic+cor">cor</a></code>. The behavior would be the same for objects which are not
from <code><a href="base.html#topic+class">class</a></code> <code><a href="base.html#topic+data.frame">data.frame</a></code> and
<code><a href="#topic+circular">circular</a></code> (in the last case the variance is define as one
minus the mean resultant length divided by the sample size of data, see
<code><a href="#topic+var.circular">var.circular</a></code> for more details). The method for
<code>data.frame</code> will apply the <code>var</code> function to each columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var(x, ...)
## Default S3 method:
var(x, y = NULL, na.rm = FALSE, use, ...)
## S3 method for class 'data.frame'
var(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="var_+3A_y">y</code></td>
<td>
<p><code>NULL</code> (default) or a vector, matrix or data frame with
compatible dimensions to <code>x</code>.  The default is equivalent to
<code>y = x</code> (but more efficient).</p>
</td></tr>
<tr><td><code id="var_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="var_+3A_use">use</code></td>
<td>
<p>an optional character string giving a
method for computing covariances in the presence
of missing values.  This must be (an abbreviation of) one of the strings
<code>"all.obs"</code>, <code>"complete.obs"</code> or <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="var_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code>, <code><a href="#topic+var.circular">var.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>

<hr>
<h2 id='var.circular'>A measure of variance for Circular Data</h2><span id='topic+var.circular'></span>

<h3>Description</h3>

<p>Returns one minus the mean resultant length divided by the sample size of a vector of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
var(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="var.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
<tr><td><code id="var.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one minus the mean resultant length divided by the sample size of data.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Mardia, K.V. (1972) Statistics of Directional Data. Academic Press, London. 
</p>
<p>Fisher, N.I. (1993) Statistical analysis of circular data. Cambridge
University Press.
</p>
<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 1.3, World Scientific Press, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sd.circular">sd.circular</a></code>, <code><a href="#topic+angular.variance">angular.variance</a></code>, <code><a href="#topic+mean.circular">mean.circular</a></code>, <code><a href="#topic+rho.circular">rho.circular</a></code> and <code><a href="#topic+summary.circular">summary.circular</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rvonmises(n=100, mu=circular(0), kappa=1)
var(x)
</code></pre>

<hr>
<h2 id='vonMises'>von Mises Density Function</h2><span id='topic+vonMises'></span><span id='topic+dvonmises'></span><span id='topic+rvonmises'></span><span id='topic+pvonmises'></span><span id='topic+qvonmises'></span>

<h3>Description</h3>

<p>Density, distribution function, random generation and quantiles for
the von Mises circular distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvonmises(n, mu, kappa, control.circular=list())
dvonmises(x, mu, kappa, log)
pvonmises(q, mu, kappa, from=NULL, tol = 1e-020)
qvonmises(p, mu = circular(0), kappa=NULL, from=NULL, tol = .Machine$double.eps^(0.6), 
  control.circular = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vonMises_+3A_x">x</code>, <code id="vonMises_+3A_q">q</code>, <code id="vonMises_+3A_p">p</code></td>
<td>
<p>a vector. The <code>x</code> and <code>q</code> objects are coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>  
<tr><td><code id="vonMises_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution. The object is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_kappa">kappa</code></td>
<td>
<p>non-negative numeric value for the concentration parameter
of the distribution.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="vonMises_+3A_from">from</code></td>
<td>
<p>if <code>NULL</code>  is set to <code class="reqn">mu-pi</code>. This is the value from which the pvonmises and qvonmises are evaluated. It should be a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_tol">tol</code></td>
<td>
<p>the precision in evaluating the distribution function or the
quantile.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="vonMises_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dvonmises</code> gives the density, <code>pvonmises</code> gives the
distribution function, <code>rvonmises</code> generates random deviates and
<code>qvonmises</code> provides quantiles.
</p>
<p>Since version 0.3-5 the random deviates are generated using a C code.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli, Ulric Lund and Harry Southworth</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.4, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- rvonmises(100, circular(0), 10, control.circular=list(units="degrees"))
plot(data1)

ff &lt;- function(x) dvonmises(x, mu=circular(pi), kappa=10)
curve.circular(ff, join=TRUE, xlim=c(-2.3, 1),
  main="Density of a VonMises Distribution \n mu=pi, kappa=10")

ff &lt;- function(x) pvonmises(x, mu=circular(pi), kappa=10)
curve.circular(ff, join=FALSE, xlim=c(-2, 2), ylim=c(-2, 1), 
  to=(2*pi-3*.Machine$double.eps), modulo="asis", nosort=TRUE, 
  main="Probability of a VonMises Distribution \n mu=pi, kappa=10")

plot(function(x) qvonmises(x, mu=circular(0), kappa=5), from=0, to=1)
##curve do not work!
plot(function(x) qvonmises(x, mu=circular(pi), kappa=5), from=0, to=1)
plot(function(x) qvonmises(x, mu=circular(pi), kappa=5, from=circular(pi/2)), from=0, to=1)
</code></pre>

<hr>
<h2 id='wallraff.test'>Wallraff Test of Angular Distances</h2><span id='topic+wallraff.test'></span><span id='topic+wallraff.test.default'></span><span id='topic+wallraff.test.list'></span><span id='topic+wallraff.test.formula'></span>

<h3>Description</h3>

<p>Performs the Wallraff test of angular distances or angular dispersion around the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wallraff.test(x, ...)

## Default S3 method:
wallraff.test(x, group, ref=NULL, ...)

## S3 method for class 'list'
wallraff.test(x, ref=NULL, ...)

## S3 method for class 'formula'
wallraff.test(formula, data, ref=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wallraff.test_+3A_x">x</code></td>
<td>
<p>a vector of angles (coerced to class <code><a href="#topic+circular">circular</a></code>) or a list of such angles. When <code>x</code> is a list, its elements are taken as the samples to be compared.</p>
</td></tr>
<tr><td><code id="wallraff.test_+3A_group">group</code></td>
<td>
<p>a vector or factor object giving the group for the corresponding elements of <code>x</code>. Ignored if <code>x</code> is a list</p>
</td></tr>
<tr><td><code id="wallraff.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> is a vector of angles and <code>rhs</code> a vector or factor giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="wallraff.test_+3A_data">data</code></td>
<td>
<p>an optional data.frame containing the variables in the formula <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="wallraff.test_+3A_ref">ref</code></td>
<td>
<p>a vector of angles used as reference to compute the angular distances from, in each group. It should contain as many elements as there are groups, <em>in the same order</em>.
</p>
<p>If <code>x</code> is a list, the order is the order of the elements of the list.
</p>
<p>In the default or formula interfaces, if the grouping vector is a factor, the order is the order of its levels; if the grouping vector is not a factor, it is coerced as such but with levels in the order of their appearance in the original vector. In this case a warning is issued to make sure the order of <code>ref</code> is correct.
</p>
<p>If <code>ref</code> has less elements than the number of groups (typically one: a common reference for all groups), it is recycled to match the number of groups.
</p>
<p>If <code>ref</code> is <code>NULL</code> (the default), the mean angle of each group will be used as reference. In this situation, the Wallraff test becomes a comparison of angular dispersion around the mean.</p>
</td></tr>
<tr><td><code id="wallraff.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wallraff test of angular distances between two or more groups is performed and the results are printed. The null hypothesis is that distances are equal across groups.
</p>
<p>The test proceeds by computing the angular distances from a reference angle, in each group. The angular distance between two angles is the circular range and is computed with <code><a href="#topic+range.circular">range.circular</a></code>. Then the distances are compared with a usual rank sum test (Kruskal-Wallis, <code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>). When there are only two groups, the Wilcoxon-Mann-Whitney test could be used but <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> without continuity correction for the p-value is equivalent to <code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> so only <code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> is used here.
</p>
<p>The Wallraff test is most frequently used to compare angular dispersion around the mean, between samples. In this case, the reference angle is the mean angle of each sample. This is the default here, when no reference angles are provided.
</p>
<p>All angles should be of class <code><a href="#topic+circular">circular</a></code> and will be coerced as such with the default parameters if they are not. An exception are the reference angles in <code>ref</code>. For ease of use, those can be only numeric and are then considered to be in the same angular reference as <code>x</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the chi-squared statistic from <code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the chi-squared statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string containing the name of the test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean-Olivier Irisson</p>


<h3>References</h3>

<p>Batschelet, E (1981). Circular Statistics in Biology. chap. 6.10, p. 124
</p>
<p>Zar, J H (2010). Biostatistical analysis. sec. 27.7-8, p. 643
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code> for the Kruskal-Wallis rank sum test used on the angular distances.
</p>
<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> for the two samples alternative to the Kruskal-Wallis test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Homing of pigeons
# Example used in Batschelet (1981)
data &lt;- list(
  control = circular(c(70, 80, 80, 85, 85, 90, 95, 95), 
        units="degrees", template="geographics"),
  experimental = circular(c(5, 5, 15, 55, 55, 65, 105, 120, 340), 
            units="degrees", template="geographics")
)

# compare the angular dispersion between the two groups
wallraff.test(data)

# compare the homing performance
# home azimuth is 40 degrees for both groups
wallraff.test(data, 
              ref = circular(c(40, 40), units="degrees",
                                 template="geographics")
             )
# we could have more simply used
wallraff.test(data, ref=40)
# because ref is automatically repeated and considered
# in the same circular reference as the data

</code></pre>

<hr>
<h2 id='watson.test'>Watson's Test </h2><span id='topic+watson.test'></span><span id='topic+print.watson.test'></span>

<h3>Description</h3>

<p>Performs a Watson's goodness of fit test for the von Mises or circular uniform distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson.test(x, alpha=0, dist=c("uniform", "vonmises"))
## S3 method for class 'watson.test'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson.test_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="watson.test_+3A_alpha">alpha</code></td>
<td>
<p>significance level of the test.  Valid levels are 0.01, 0.05, 0.1.  This argument may be omitted, in which case, a range for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="watson.test_+3A_dist">dist</code></td>
<td>
<p>distribution to test for.  The default is the uniform
distribution. To test for the von Mises distribution, set <code>dist</code>
to &quot;vonmises&quot;.</p>
</td></tr>
<tr><td><code id="watson.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="watson.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>dist</code> = &quot;uniform&quot;, Watson's one-sample test for the circular uniform distribution is performed, and the results are printed.  If alpha is specified and non-zero, the test statistic is printed along with the critical value and decision.  If alpha is omitted, the test statistic is printed and a range for the p-value of the test is given.
</p>
<p>If <code>dist</code> = &quot;vonmises&quot;, estimates of the population parameters are used to evaluate the von Mises distribution function at all data points, thereby arriving at a sample of approximately uniformly distributed data, if the original observations have a von Mises distribution. The one-sample Watson test is then applied to the transformed data as above.
</p>


<h3>Value</h3>

<p>a list with the statistic, alpha, the number of observations, the
distribution and 'row' which is used by <code>print.watson.test</code> to
evaluate the p-value.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 7.2, World Scientific Press, Singapore.
</p>
<p>Stephens, M. (1970).  Use of the Kolmogorov-Smirnov, Cramer-von Mises and related statistics without extensive tables.  Journal of the Royal Statistical Society, B32, 115-122.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+range.circular">range.circular</a></code>, <code><a href="#topic+kuiper.test">kuiper.test</a></code>, <code><a href="#topic+rao.spacing.test">rao.spacing.test</a></code> and <code><a href="#topic+rayleigh.test">rayleigh.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from the uniform distribution on the circle.
x &lt;- circular(runif(100, 0, 2*pi))  
watson.test(x)
# Generate data from a von Mises distribution.
x &lt;- rvonmises(n=50, mu=circular(0), kappa=4) 
watson.test(x, alpha=0.05, dist="vonmises")
</code></pre>

<hr>
<h2 id='watson.two.test'>Watson's Two-Sample Test of Homogeneity</h2><span id='topic+watson.two.test'></span><span id='topic+print.watson.two.test'></span>

<h3>Description</h3>

<p>Performs Watson's test for homogeneity on two samples of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson.two.test(x, y, alpha=0)
## S3 method for class 'watson.two.test'
print(x, digits=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson.two.test_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="watson.two.test_+3A_y">y</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="watson.two.test_+3A_alpha">alpha</code></td>
<td>
<p>significance level of the test.  Valid levels are 0.001, 0.01, 0.05, 0.1.  This argument may be omitted, in which case, a range for the p-value will be returned.</p>
</td></tr>
<tr><td><code id="watson.two.test_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used.</p>
</td></tr>
<tr><td><code id="watson.two.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Watson's two-sample test of homogeneity is performed, and the results are printed.  If alpha is specified and non-zero, the test statistic is printed along with the critical value and decision.  If alpha is omitted, the test statistic is printed and a range for the p-value of the test is given.
</p>
<p>Critical values for the test statistic are obtained using the asymptotic distribution of the test statistic.  It is recommended to use the obtained critical values and ranges for p-values only for combined sample sizes in excess of 17.  Tables are available for smaller sample sizes and can be found in Mardia (1972) for instance.
</p>


<h3>Value</h3>

<p>a list with statistic, alpha and the number of observations of the first and 
second sample.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 7.5, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform a two-sample test of homogeneity on two
# simulated data sets.
data1 &lt;- rvonmises(n=20, mu=circular(0), kappa=3)
data2 &lt;- rvonmises(n=20, mu=circular(pi), kappa=2)
watson.two.test(data1, data2, alpha=0.05)
watson.two.test(data1, data2)
</code></pre>

<hr>
<h2 id='watson.wheeler.test'>Watson-Williams Test of Homogeneity of Means</h2><span id='topic+watson.wheeler.test'></span><span id='topic+watson.wheeler.test.default'></span><span id='topic+watson.wheeler.test.list'></span><span id='topic+watson.wheeler.test.formula'></span>

<h3>Description</h3>

<p>Performs the Watson-Wheeler test for homogeneity on two or more samples of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson.wheeler.test(x, ...)

## Default S3 method:
watson.wheeler.test(x, group, ...)

## S3 method for class 'list'
watson.wheeler.test(x, ...)

## S3 method for class 'formula'
watson.wheeler.test(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson.wheeler.test_+3A_x">x</code></td>
<td>
<p>a vector of angles (coerced to class <code><a href="#topic+circular">circular</a></code>) or a list of such angles.</p>
</td></tr>
<tr><td><code id="watson.wheeler.test_+3A_group">group</code></td>
<td>
<p>a vector or factor object giving the groups for the corresponding elements of <code>x</code>. Ignored if <code>x</code> is a list</p>
</td></tr>
<tr><td><code id="watson.wheeler.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> is a vector of angles and <code>rhs</code> a vector or factor giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="watson.wheeler.test_+3A_data">data</code></td>
<td>
<p>an optional data.frame containing the variables in the formula <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="watson.wheeler.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Watson-Wheeler (or Mardia-Watson-Wheeler, or uniform score) test is a non-parametric test to compare two or several samples. The difference between the samples can be in either the mean or the variance.
</p>
<p>The <em>p</em>-value is estimated by assuming that the test statistic follows a chi-squared distribution. For this approximation to be valid, all groups must have at least 10 elements.
</p>
<p>In the default method, <code>x</code> is a vector of angles and <code>group</code> must be a vector or factor object of the same length as <code>x</code> giving the group for the corresponding elements of <code>x</code>.
</p>
<p>If <code>x</code> is a list, its elements are taken as the samples to be compared.
</p>
<p>In the <code><a href="stats.html#topic+formula">formula</a></code> method, the angles and grouping elements are identified as the left and right hand side of the formula respectively.
</p>
<p>All angles should be of class <code><a href="#topic+circular">circular</a></code> and will be coerced as such if they are not.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>W, the statistic of the test, which is approximately distributed as a chi-squared.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the chi-squared approximation of the statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string containing the name of the test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean-Olivier Irisson</p>


<h3>References</h3>

<p>Batschelet, E (1981). Circular Statistics in Biology. chap 6.3, p. 104
</p>
<p>Zar, J H (1999). Biostatistical analysis. section 27.5, p. 640
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example used in Zar (1999)
x1 &lt;- circular(c(35, 45, 50, 55, 60, 70, 85, 95, 105, 120),
  units="degrees", template="geographics")
x2 &lt;- circular(c(75, 80, 90, 100, 110, 130, 135, 140, 150, 160, 165),
  units="degrees", template="geographics")

watson.wheeler.test(list(x1,x2))
</code></pre>

<hr>
<h2 id='watson.williams.test'>Watson-Williams Test of Homogeneity of Means</h2><span id='topic+watson.williams.test'></span><span id='topic+watson.williams.test.default'></span><span id='topic+watson.williams.test.list'></span><span id='topic+watson.williams.test.formula'></span>

<h3>Description</h3>

<p>Performs the Watson-Williams test for homogeneity of means between several samples of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watson.williams.test(x, ...)

## Default S3 method:
watson.williams.test(x, group, ...)

## S3 method for class 'list'
watson.williams.test(x, ...)

## S3 method for class 'formula'
watson.williams.test(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watson.williams.test_+3A_x">x</code></td>
<td>
<p>a vector of angles (coerced to class <code><a href="#topic+circular">circular</a></code>) or a list of such angles.</p>
</td></tr>
<tr><td><code id="watson.williams.test_+3A_group">group</code></td>
<td>
<p>a vector or factor object giving the group for the corresponding elements of <code>x</code>. Ignored if <code>x</code> is a list</p>
</td></tr>
<tr><td><code id="watson.williams.test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> is a vector of angles and <code>rhs</code> a vector or factor giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="watson.williams.test_+3A_data">data</code></td>
<td>
<p>an optional data.frame containing the variables in the formula <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="watson.williams.test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Watson-Williams test for the homogeneity of means between two or more groups is performed and the results are printed. The null hypothesis is that means are equal across groups.
</p>
<p>The assumptions are that: (1) the samples are drawn from populations with a von Mises distribution; (2) the parameter of concentration has the same value in all populations; (3) this parameter is sufficiently large (i.e. &gt; 1). Assumptions 2 and 3 are checked and a warning is issued if they are not met.
</p>
<p>In the default method, <code>x</code> is a vector of angles and <code>group</code> must be a vector or factor object of the same length as <code>x</code> giving the group for the corresponding elements of <code>x</code>.
</p>
<p>If <code>x</code> is a list, its elements are taken as the samples to be compared.
</p>
<p>In the <code><a href="stats.html#topic+formula">formula</a></code> method, the angles and grouping elements are identified as the left and right hand side of the formula respectively.
</p>
<p>All angles should be of class <code><a href="#topic+circular">circular</a></code> and will be coerced as such if they are not.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the F statistic of the test.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the F statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a vector of the means of each group.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string containing the name of the test.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean-Olivier Irisson</p>


<h3>References</h3>

<p>Batschelet, E (1981). Circular Statistics in Biology. chap. 6.2, p. 99
</p>
<p>Mardia, KV and Jupp, PE (2000). Directional statistics. p. 135
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Ant orientation from Duelli and Wehner (1973)
# Example used in Batschelet (1981)
data &lt;- list(
  exp = circular(rep(c(-20, -10, 0), c(1,7,2)), 
        units="degrees", template="geographics"),
  control = circular(rep(c(-10, 0, 10, 20), c(3,3,3,1)), 
            units="degrees", template="geographics")
)

watson.williams.test(data)

</code></pre>

<hr>
<h2 id='weighted.mean.circular'>Weighted Mean Direction</h2><span id='topic+weighted.mean.circular'></span>

<h3>Description</h3>

<p>Returns the weighetd mean direction of a vector of circular data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'circular'
weighted.mean(x, w, na.rm=FALSE,
  control.circular=list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.mean.circular_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="weighted.mean.circular_+3A_w">w</code></td>
<td>
<p>a numerical vector of weights the same length as <code>x</code>
giving the weights to use for elements of <code>x</code>.</p>
</td></tr>
<tr><td><code id="weighted.mean.circular_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicating if <code><a href="base.html#topic+NA">NA</a></code>'s should be
omitted.</p>
</td></tr>
<tr><td><code id="weighted.mean.circular_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="weighted.mean.circular_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each observation is treated as a unit vector, or point  on the unit
circle.  The resultant vector of the observations is found, and the
direction of the resultant vector is returned. An <code><a href="base.html#topic+NA">NA</a></code> is
returned if the weighted resultant length is less than
<code><a href="base.html#topic+.Machine">.Machine</a></code>.
</p>
<p>If <code>w</code> is missing then all elements of <code>x</code> are given the same
weight, otherwise the weights coerced to numeric by <code>as.numeric</code> and normalized to sum to one.
</p>
<p>Missing values in <code>w</code> are not handled specially and so give a
missing value as the result. However, zero weights are handled
specially and the corresponding <code>x</code> values are omitted from the
computation.
</p>


<h3>Value</h3>

<p>Returns the weighted mean direction of the data as an object of class <code>circular</code> with the attribute given by <code>control.circular</code> or from <code>x</code> if missed in <code>control.circular</code>.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.circular">mean.circular</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the weighted mean direction of a random sample of observations.
x &lt;- circular(runif(50, circular(0), pi))
w &lt;- runif(50, 0, 1)
weighted.mean(x, w)
</code></pre>

<hr>
<h2 id='wind'>
Col De La Roa wind direction  
</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>In a place named &quot;Col de la Roa&quot; in the Italian Alps there is a
meteorological station that records via data-logger several
parameters. Measures are made every 15 minutes, in this dataset
we report the wind direction recorded every day from January 29,
2001 to March 31, 2001 from 3.00am to 4.00am included. Which
means 5 observations every day for a total of 310 measures.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wind)</code></pre>


<h3>Format</h3>

<p>This data frame contains one variables (wind direction) in radians.
</p>


<h3>Source</h3>

<p>http://www.tesaf.unipd.it/SanVito/dati.htm
</p>


<h3>References</h3>

<p>C. Agostinelli (2007) Robust estimation for circular data, Computational
Statistics and Data Analysis, 51(12), 5867-5875,
doi = doi:10.1016/j.csda.2006.11.002
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(wind)
  wind &lt;- circular(wind, template='geographics')
  par(mfcol=c(1,2))
  plot(wind)
  plot(density(wind, bw=40), main='')
</code></pre>

<hr>
<h2 id='windrose'>Windrose Generator</h2><span id='topic+windrose'></span>

<h3>Description</h3>

<p>This function creates a windrose used to visualize
the direction and magnitude of wind.  The pedals of a windrose
indicate the proportion of time wind comes from a given
direction. Bands on the windrose indicate the proportions of
winds of each magnitude.</p>


<h3>Usage</h3>

<pre><code class='language-R'>windrose(x, y=NULL, breaks=NULL, bins=12, increment = 10, 
  main='Wind Rose', cir.ind = 0.05, fill.col=NULL, plot.mids=TRUE, 
  mids.size=1.2, osize=0.1, axes=TRUE, ticks=TRUE, tcl=0.025, 
  tcl.text=-0.15, cex=1, digits=2, units=NULL,
  template=NULL, zero=NULL, rotation=NULL,
  num.ticks=12, xlim=c(-1.2, 1.2), ylim=c(-1.2, 1.2),
  uin, tol=0.04, right=FALSE, shrink=NULL, 
  label.freq=FALSE, calm=c("0", "NA"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="windrose_+3A_x">x</code></td>
<td>
<p>a vector contains direction or a two columns data frame, where the first component is the direction and the second the magnitude.  The vector or the first column in the case of data frame is coerced to class <code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="windrose_+3A_y">y</code></td>
<td>
<p>a vector contains magnitude. If 'y' is not NULL and 'x' is a dataframe,  only the first column of 'x' is used for direction.</p>
</td></tr>
<tr><td><code id="windrose_+3A_breaks">breaks</code></td>
<td>
<p>the extremes of the pedals. The biggest value (in 2*pi) is recycled for building the first pedal. The vector is coerced to class <code><a href="#topic+circular">circular</a></code> but only the units is used.</p>
</td></tr>
<tr><td><code id="windrose_+3A_bins">bins</code></td>
<td>
<p>Number of pedals. Ignored if 'breaks' is not NULL.</p>
</td></tr>
<tr><td><code id="windrose_+3A_increment">increment</code></td>
<td>
<p>Grouping size of magnitude. These are the bins of the magnitudes displayed on each pedal.</p>
</td></tr>
<tr><td><code id="windrose_+3A_main">main</code></td>
<td>
<p>Title for plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_cir.ind">cir.ind</code></td>
<td>
<p>Percent intervals expressed on each circle if the pedals are equally spaced, otherwise values of density</p>
</td></tr>
<tr><td><code id="windrose_+3A_fill.col">fill.col</code></td>
<td>
<p>colors used to fill the pedals for each magnitude. The colors are recycled if necessary. The default is to use 'blue' and 'red'.</p>
</td></tr> 
<tr><td><code id="windrose_+3A_plot.mids">plot.mids</code></td>
<td>
<p>plot lines at the midpoints of the pedals.</p>
</td></tr>
<tr><td><code id="windrose_+3A_mids.size">mids.size</code></td>
<td>
<p>length of the lines for midpoints.</p>
</td></tr>
<tr><td><code id="windrose_+3A_osize">osize</code></td>
<td>
<p>radius of the circle draws at the center of the plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_axes">axes</code></td>
<td>
<p>if TRUE axes are added to the plot. The function <code><a href="#topic+axis.circular">axis.circular</a></code> is used.</p>
</td></tr>
<tr><td><code id="windrose_+3A_ticks">ticks</code></td>
<td>
<p>if TRUE ticks are added to the plot. The function <code><a href="#topic+ticks.circular">ticks.circular</a></code> is used.</p>
</td></tr>
<tr><td><code id="windrose_+3A_tcl">tcl</code></td>
<td>
<p>length of the ticks.</p>
</td></tr>
<tr><td><code id="windrose_+3A_tcl.text">tcl.text</code></td>
<td>
<p>The position of the axis labels.</p>
</td></tr>
<tr><td><code id="windrose_+3A_cex">cex</code></td>
<td>
<p>point character size.  See help on <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="windrose_+3A_digits">digits</code></td>
<td>
<p>number of digits used to print axis values and other numbers.</p>
</td></tr>
<tr><td><code id="windrose_+3A_units">units</code></td>
<td>
<p>the units used in the plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_template">template</code></td>
<td>
<p>the template used in the plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_zero">zero</code></td>
<td>
<p>the zero used in the plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_rotation">rotation</code></td>
<td>
<p>the rotation used in the plot.</p>
</td></tr> 
<tr><td><code id="windrose_+3A_num.ticks">num.ticks</code></td>
<td>
<p>number of tick marks draw.</p>
</td></tr>
<tr><td><code id="windrose_+3A_tol">tol</code></td>
<td>
<p>proportion of white space at the margins of plot</p>
</td></tr>
<tr><td><code id="windrose_+3A_uin">uin</code></td>
<td>
<p>desired values for the units per inch parameter. If of length 1, the desired units per inch on the x axis.</p>
</td></tr>
<tr><td><code id="windrose_+3A_xlim">xlim</code>, <code id="windrose_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y axes. Useful for centering the plot.</p>
</td></tr>
<tr><td><code id="windrose_+3A_right">right</code></td>
<td>
<p>logical; if TRUE, the pedals are right-closed (left open) intervals.</p>
</td></tr>
<tr><td><code id="windrose_+3A_shrink">shrink</code></td>
<td>
<p>maximum length of the pedals, it can be used to plot several graphics with the same scale.</p>
</td></tr>
<tr><td><code id="windrose_+3A_label.freq">label.freq</code></td>
<td>
<p>logical; if TRUE, the relative frequencies are used in the magnitude instead of intensities, when the breaks are equally spaced.</p>
</td></tr>
<tr><td><code id="windrose_+3A_calm">calm</code></td>
<td>
<p>&quot;0&quot; or &quot;NA&quot;, see details below.</p>
</td></tr>
<tr><td><code id="windrose_+3A_...">...</code></td>
<td>
<p>further parameters ignored for now.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the convention of the National Weather Service, winds
with a direction of 0 are considered calm, while winds with a
direction of 360 degrees (2*pi radians) are assumed to be from the north.  Calm winds
are excluded from the wind rose creation. We allow, in direction, to use <code>NA</code> to indicate calm wind (argument <code>calm</code>). 
</p>
<p>This wind rose preserve areas of pedals, that is counts are proportional to the area of the pedals rather than to the length of the pedals. This is also for the slides created for the magnitudes.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>directions</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>magnitudes</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>Matrix output of the counts of wind direction and magnitude.
Columns are in the same units as the data, according to step size, and rows are
based on the increment size.</p>
</td></tr>
<tr><td><code>number.obs</code></td>
<td>
<p>Total number of observations.</p>
</td></tr>
<tr><td><code>number.calm</code></td>
<td>
<p>The number of calm observations omitted from the wind rose plot.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>extremes of the pedals.</p>
</td></tr>
<tr><td><code>mids</code></td>
<td>
<p>midpoints of pedals.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code><a href="base.html#topic+match.call">match.call</a></code> result.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>some codes from <code><a href="MASS.html#topic+eqscplot">eqscplot</a></code> in 'MASS' is used.</p>


<h3>Author(s)</h3>

<p>Matt Pocernich &lt;pocernic@rap.ucar.edu&gt;, ported in the package 'circular' by Claudio Agostinelli</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random distribution of direction and magnitude in degrees

dir &lt;- circular(runif(100, 0, 360), units="degrees")
mag &lt;-  rgamma(100, 15)
sample &lt;- data.frame(dir=dir, mag=mag)

par(mfrow=c(2,2))
res &lt;- windrose(sample)
## we join two pedals and keep the same shrink (scale of the plot)
breaks &lt;-circular(seq(0, 2 * pi, by = pi/6))
breaks &lt;- breaks[-2]
windrose(sample, breaks=breaks, main="The same but with two pedals joined", 
  shrink=res$shrink)
## change the rotation
sample &lt;- data.frame(dir=circular(dir, units="degrees", rotation="clock"), mag=mag)
windrose(sample, breaks=breaks, main="Change the rotation", shrink=res$shrink)
## use geographics template
sample &lt;- data.frame(dir=circular(dir, units="degrees", template="geographics"),
  mag=mag)
windrose(sample, breaks=breaks, main="Use the template 'geographics'", 
  shrink=res$shrink)

## do the same plot but in radians
dir &lt;- conversion.circular(dir)
windrose(x=dir, y=mag, xlim=c(-1.3, 1.3))

## magnify some part of the plot
windrose(x=dir, y=mag, xlim=c(0, 1.3))
</code></pre>

<hr>
<h2 id='wrappedCauchy'>Wrapped Cauchy Density Function</h2><span id='topic+dwrappedcauchy'></span><span id='topic+rwrappedcauchy'></span>

<h3>Description</h3>

<p>Density, and random generation for the wrapped Cauchy circular distribution.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwrappedcauchy(x, mu = circular(0), rho = exp(-1))
rwrappedcauchy(n, mu = circular(0), rho = exp(-1), control.circular=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrappedCauchy_+3A_x">x</code></td>
<td>
<p>a vector. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="wrappedCauchy_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>  
<tr><td><code id="wrappedCauchy_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="wrappedCauchy_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution.  <code>rho</code>
must be in the interval from 0 to 1.</p>
</td></tr>
<tr><td><code id="wrappedCauchy_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dwrappedcauchy</code> gives the density and <code>rwrappedcauchy</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.7, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- rwrappedcauchy(100, mu=circular(0), rho=0.7, 
  control.circular=list(units="degrees"))
plot(data1)

ff &lt;- function(x) dwrappedcauchy(x, mu=circular(pi), rho=0.7)
curve.circular(ff, join=TRUE, xlim=c(-2, 1), 
  main="Density of a Wrapped Cauchy Distribution \n mu=pi, rho=0.7")

</code></pre>

<hr>
<h2 id='wrappedNormal'>Wrapped Normal Density Function</h2><span id='topic+dwrappednormal'></span><span id='topic+rwrappednormal'></span><span id='topic+pwrappednormal'></span><span id='topic+qwrappednormal'></span>

<h3>Description</h3>

<p>Density, and random generation for the wrapped normal circular distribution.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwrappednormal(n, mu = circular(0), rho = NULL, sd = 1, 
  control.circular = list())
dwrappednormal(x, mu = circular(0), rho = NULL, sd = 1, 
  K = NULL, min.k = 10)
pwrappednormal(q, mu = circular(0), rho = NULL, sd = 1, 
  from = NULL, K = NULL, min.k = 10, ...)
qwrappednormal(p, mu = circular(0), rho = NULL, sd = 1, 
  from = NULL, K = NULL, min.k = 10, tol = .Machine$double.eps^(0.6), 
  control.circular = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrappedNormal_+3A_x">x</code>, <code id="wrappedNormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles. The object is coerced to class
<code><a href="#topic+circular">circular</a></code>.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr> 
<tr><td><code id="wrappedNormal_+3A_mu">mu</code></td>
<td>
<p>mean direction of the distribution as a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_rho">rho</code></td>
<td>
<p>concentration parameter of the distribution.  <code>rho</code>
must be in the interval from 0 to 1.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the (unwrapped) normal distribution.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_from">from</code></td>
<td>
<p>if <code>NULL</code>  is set to <code class="reqn">mu-pi</code>. This is the value from which the pwrappednormal and qwrappednormal are evaluated. It should be a <code>circular</code> object.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_k">K</code></td>
<td>
<p>number of terms to be used in approximating the density.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_min.k">min.k</code></td>
<td>
<p>minimum number of terms used in approximating the density.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_tol">tol</code></td>
<td>
<p>passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_control.circular">control.circular</code></td>
<td>
<p>the attribute of the resulting object.</p>
</td></tr>
<tr><td><code id="wrappedNormal_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dwrappednormal</code> gives the density and <code>rwrappednormal</code>
generates random deviates,  <code>pwrappednormal</code> gives the
distribution function, and <code>qwrappednormal</code> provides quantiles.
</p>


<h3>Author(s)</h3>

<p>Claudio Agostinelli and Ulric Lund</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 2.2.7, World Scientific Press, Singapore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- rwrappednormal(100, mu=circular(0), rho=0.7, 
  control.circular=list(units="degrees"))
plot(data1)

ff &lt;- function(x) dwrappednormal(x, mu=circular(pi), rho=0.7)
curve.circular(ff, join=TRUE, xlim=c(-1.5, 1), 
  main="Density of a Wrapped Normal Distribution \n mu=pi, rho=0.7")

ff &lt;- function(x) pwrappednormal(x, mu=circular(pi), rho=0.7)
curve.circular(ff, join=FALSE, xlim=c(-2, 2), ylim=c(-2, 2), 
  to=(2*pi-3*.Machine$double.eps), modulo="asis", nosort=TRUE, 
  main="Probability of a Wrapped Normal Distribution \n mu=pi, 
  rho=0.7, from=0")

ff &lt;- function(x) pwrappednormal(x, mu=circular(pi), rho=0.7, from=circular(pi))
curve.circular(ff, join=FALSE, xlim=c(-2, 2), ylim=c(-2, 2), from=-pi, 
  to=(pi-3*.Machine$double.eps), modulo="asis", nosort=TRUE, 
  main="Probability of a Wrapped Normal Distribution \n mu=pi, 
  rho=0.7, from=pi")

plot(qwrappednormal, from=0, to=1)
plot(function(x) qwrappednormal(p=x, mu=circular(pi)), from=0, to=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
