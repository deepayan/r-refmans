<!DOCTYPE html><html><head><title>Help for package table1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {table1}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.table1'><p>Convert a <code>table1</code> object to a <code>data.frame</code>.</p></a></li>
<li><a href='#eqcut'><p>Cut a continuous variable into equal-sized groups.</p></a></li>
<li><a href='#knit_print.table1'><p>Method for printing in a <code>knitr</code> context.</p></a></li>
<li><a href='#label'><p>Label attribute.</p></a></li>
<li><a href='#parse.abbrev.render.code'><p>Parse abbreviated code for rendering table output.</p></a></li>
<li><a href='#print.table1'><p>Print <code>table1</code> object.</p></a></li>
<li><a href='#render.categorical.default'><p>Render categorical values for table output.</p></a></li>
<li><a href='#render.continuous.default'><p>Render continuous values for table output.</p></a></li>
<li><a href='#render.default'><p>Render values for table output.</p></a></li>
<li><a href='#render.missing.default'><p>Render missing values for table output.</p></a></li>
<li><a href='#render.strat.default'><p>Render strata labels for table output.</p></a></li>
<li><a href='#render.varlabel'><p>Render variable labels for table output.</p></a></li>
<li><a href='#signif_pad'><p>Round numbers with 0-padding.</p></a></li>
<li><a href='#stats.apply.rounding'><p>Apply rounding to basic descriptive statistics.</p></a></li>
<li><a href='#stats.default'><p>Compute some basic descriptive statistics.</p></a></li>
<li><a href='#subsetp'><p>Subset function that preserves column attributes.</p></a></li>
<li><a href='#t1flex'><p>Convert a <code>table1</code> object to <code>flextable</code>.</p></a></li>
<li><a href='#t1kable'><p>Convert a <code>table1</code> object to <code>kabelExtra</code>.</p></a></li>
<li><a href='#t1read'><p>Read and augment data with extended metadata attributes</p></a></li>
<li><a href='#table.rows'><p>Convert to HTML table rows.</p></a></li>
<li><a href='#table1'><p>Generate an HTML table of descriptive statistics.</p></a></li>
<li><a href='#units'><p>Units attribute.</p></a></li>
<li><a href='#update_html'><p>Update HTML.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Tables of Descriptive Statistics in HTML</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Rich [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Rich &lt;mail@benjaminrich.net&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/benjaminrich/table1">https://github.com/benjaminrich/table1</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benjaminrich/table1/issues">https://github.com/benjaminrich/table1/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Create HTML tables of descriptive statistics, as one would expect
    to see as the first table (i.e. "Table 1") in a medical/epidemiological journal
    article.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,Formula,knitr,htmltools,yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot,MatchIt,rmarkdown,printr,kableExtra,flextable</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-05 22:41:24 UTC; ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.table1'>Convert a <code>table1</code> object to a <code>data.frame</code>.</h2><span id='topic+as.data.frame.table1'></span>

<h3>Description</h3>

<p>Convert a <code>table1</code> object to a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table1'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.table1_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.table1_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>

<hr>
<h2 id='eqcut'>Cut a continuous variable into equal-sized groups.</h2><span id='topic+eqcut'></span><span id='topic+eqcut.default.labeling'></span>

<h3>Description</h3>

<p>Cut a continuous variable into equal-sized groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqcut(
  x,
  ngroups,
  labeling = eqcut.default.labeling,
  withhold = NULL,
  varlabel = if (has.label(x)) label(x) else deparse(substitute(x)),
  quantile.type = 7,
  right = FALSE,
  ...
)

eqcut.default.labeling(x, xcat, which, what, from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqcut_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_ngroups">ngroups</code></td>
<td>
<p>The number of groups desired.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_labeling">labeling</code></td>
<td>
<p>A function that produces the category labels (see Details).</p>
</td></tr>
<tr><td><code id="eqcut_+3A_withhold">withhold</code></td>
<td>
<p>A named list of logical vectors (see Details).</p>
</td></tr>
<tr><td><code id="eqcut_+3A_varlabel">varlabel</code></td>
<td>
<p>A character string to be used as a label for <code>x</code>, or
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_quantile.type">quantile.type</code></td>
<td>
<p>An integer from 1 to 9, passed as the <code>type</code> argument to function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_right">right</code></td>
<td>
<p>Should intervals be right-closed? (passed to <code><a href="base.html#topic+cut">cut</a></code>).</p>
</td></tr>
<tr><td><code id="eqcut_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to function <code>labeling</code>.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_xcat">xcat</code></td>
<td>
<p>A factor returned by <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
<tr><td><code id="eqcut_+3A_which">which</code>, <code id="eqcut_+3A_what">what</code></td>
<td>
<p>Character vectors for labeling the categories in an
appropriate way (see Examples).</p>
</td></tr>
<tr><td><code id="eqcut_+3A_from">from</code>, <code id="eqcut_+3A_to">to</code></td>
<td>
<p>Numeric vectors giving the ranges covered by the categories
of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>labeling</code> must have the signature <code>function(x, xcat,
which, what, from, to, ...)</code> and produces the character vector of factor
levels. See below for an example.
</p>
<p>The <code>withhold</code> list can be used when <code>x</code> contains special values
that should not be considered in the calculation of the quantiles used to
create the <code>ngroups</code> categories. The special values are given a label
that corresponds to the name of the corresponding list element. See below
for an example.
</p>


<h3>Value</h3>

<p>A <code>factor</code> of the same length as <code>x</code>. There are
<code>ngroups</code> levels plus one additional level for each element of
<code>withhold</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>eqcut.default.labeling()</code>: The default labeling function.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(100)
table(eqcut(x, 2))
table(eqcut(x, 3))
table(eqcut(x, 4))
table(eqcut(x, 5))
table(eqcut(x, 6))
table(eqcut(x, 7))
table(eqcut(x, 8))

# An example of using eqcut in a table with custom labeling function.
dat &lt;- expand.grid(id=1:100, sex=c("Male", "Female"), treat=c("Treated", "Placebo"))
dat$age &lt;- runif(nrow(dat), 18, 50)
dat$wt &lt;- exp(rnorm(nrow(dat), log(75 + 10*(dat$sex=="Male")), 0.2))
dat$auc &lt;- ifelse(dat$treat=="Placebo", NA, exp(rnorm(nrow(dat), log(1000), 0.34)))
dat$auc[3] &lt;- NA  # Add a missing value

label(dat$sex) &lt;- "Sex"
label(dat$age) &lt;- "Age"
label(dat$wt)  &lt;- "Weight"
label(dat$auc) &lt;- "AUC"
units(dat$age) &lt;- "y"
units(dat$wt)  &lt;- "kg"
units(dat$auc) &lt;- "ng.h/mL"

w &lt;- list(Placebo=(dat$treat=="Placebo"), Excluded=is.na(dat$auc))
f &lt;- function(x, xcat, which, what, from, to, ...) {
   what &lt;- sub("of ", "of&lt;br/&gt;", what)
   sprintf("%s %s&lt;br/&gt;&amp;ge;%s to &amp;lt;%s",
       which, what, signif_pad(from, 3, FALSE), signif_pad(to, 3, FALSE))
}
table1(~ sex + age + wt | eqcut(auc, 3, f, w), data=dat)

</code></pre>

<hr>
<h2 id='knit_print.table1'>Method for printing in a <code>knitr</code> context.</h2><span id='topic+knit_print.table1'></span>

<h3>Description</h3>

<p>Method for printing in a <code>knitr</code> context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table1'
knit_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_print.table1_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
<tr><td><code id="knit_print.table1_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>knitr::knit_print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the target is HTML, the usual internal formatting will be
applied; otherwise, fall back to a 'data.frame'.
</p>

<hr>
<h2 id='label'>Label attribute.</h2><span id='topic+label'></span><span id='topic+label+3C-'></span><span id='topic+setLabel'></span><span id='topic+has.label'></span>

<h3>Description</h3>

<p>Label attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(x)

label(x) &lt;- value

setLabel(x, value)

has.label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="label_+3A_value">value</code></td>
<td>
<p>A <code>character</code> specifying the label.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>label(x) &lt;- value</code>: Set label attribute.
</p>
</li>
<li> <p><code>setLabel()</code>: Set label attribute.
</p>
</li>
<li> <p><code>has.label()</code>: Check for label attribute.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
label(x) &lt;- "Foo"
x &lt;- setLabel(x, "Foo") # Alternative syntax
has.label(x)
label(x)
</code></pre>

<hr>
<h2 id='parse.abbrev.render.code'>Parse abbreviated code for rendering table output.</h2><span id='topic+parse.abbrev.render.code'></span>

<h3>Description</h3>

<p>Parse abbreviated code for rendering table output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.abbrev.render.code(code, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.abbrev.render.code_+3A_code">code</code></td>
<td>
<p>A <code>character</code> vector specifying the statistics to display
in abbreviated code. See Details.</p>
</td></tr>
<tr><td><code id="parse.abbrev.render.code_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In abbreviated code, the words N, NMISS, MEAN, SD, MIN, MEDIAN,
MAX, IQR, CV, GMEAN, GSD, GCV, FREQ and PCT are substituted for their respective
values (see <code><a href="#topic+stats.default">stats.default</a></code>). The substitution is case
insensitive, and the substituted values are rounded appropriately (see
<code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>). Other text is left unchanged. The
<code>code</code> can be a vector, in which case each element is displayed in its
own row in the table. The <code>names</code> of <code>code</code> are used as row
labels; if no names are present, then the <code>code</code> itself is used unless
<code>code</code> is of length 1, in which case no label is used (for numeric
variables only, categorical variables are always labeled by the class
label). The special name '.' also indicates that <code>code</code> itself be is
used as the row label.
</p>


<h3>Value</h3>

<p>A function that takes a single argument and returns a
<code>character</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- round(exp(rnorm(100, log(20), 1)), 2)
stats.default(x)
f &lt;- parse.abbrev.render.code(c("Mean (SD)", "Median [Min, Max]"), 3)
f(x)
f2 &lt;- parse.abbrev.render.code(c("Geo. Mean (Geo. CV%)" = "GMean (GCV%)"), 3)
f2(x)
f3 &lt;- parse.abbrev.render.code(c("Mean (SD)"), 3)
f3(x)

x &lt;- sample(c("Male", "Female"), 30, replace=T)
stats.default(x)
f &lt;- parse.abbrev.render.code("Freq (Pct%)")
f(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.table1'>Print <code>table1</code> object.</h2><span id='topic+print.table1'></span>

<h3>Description</h3>

<p>Print <code>table1</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.table1_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
<tr><td><code id="print.table1_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to other <code>print</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an interactive context, the rendered table will be displayed in
a web browser. Otherwise, the HTML code will be printed as text.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>

<hr>
<h2 id='render.categorical.default'>Render categorical values for table output.</h2><span id='topic+render.categorical.default'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1">table1</a></code> by default to render categorical (i.e.
<code>factor</code>, <code>character</code> or <code>logical</code>) values for displaying in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.categorical.default(x, ..., na.is.category = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.categorical.default_+3A_x">x</code></td>
<td>
<p>A vector of type <code>factor</code>, <code>character</code> or <code>logical</code>.</p>
</td></tr>
<tr><td><code id="render.categorical.default_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>.</p>
</td></tr>
<tr><td><code id="render.categorical.default_+3A_na.is.category">na.is.category</code></td>
<td>
<p>Include missing values in the denominator for
calculating percentages (the default) or omit them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector. Each element is to be displayed in a
separate cell in the table. The <code><a href="base.html#topic+names">names</a></code> of the vector are the
labels to use in the table. However, the first names should be empty as it
will be replaced by the name of the variable. Empty strings are allowed and
result in empty table cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- factor(sample(0:1, 99, replace=TRUE), labels=c("Female", "Male"))
y[1:10] &lt;- NA
render.categorical.default(y)
</code></pre>

<hr>
<h2 id='render.continuous.default'>Render continuous values for table output.</h2><span id='topic+render.continuous.default'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1">table1</a></code> by default to render continuous (i.e.
<code>numeric</code>) values for displaying in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.continuous.default(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.continuous.default_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="render.continuous.default_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector. Each element is to be displayed in a
separate cell in the table. The <code><a href="base.html#topic+names">names</a></code> of the vector are the
labels to use in the table. However, the first names should be empty as it
will be replaced by the name of the variable. Empty strings are allowed and
result in empty table cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- exp(rnorm(100, 1, 1))
render.continuous.default(x)

</code></pre>

<hr>
<h2 id='render.default'>Render values for table output.</h2><span id='topic+render.default'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1">table1</a></code> by default to render values for
displaying in the table. This function forwards the call to separate
functions for rendering continuous, categorical and missing values.
The idea is that each of these functions can be overridden to customize
the table output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.default(
  x,
  name,
  missing = any(is.na(x)),
  transpose = F,
  render.empty = "NA",
  render.continuous = render.continuous.default,
  render.categorical = render.categorical.default,
  render.missing = render.missing.default,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.default_+3A_x">x</code></td>
<td>
<p>A vector or numeric, factor, character or logical values.</p>
</td></tr>
<tr><td><code id="render.default_+3A_name">name</code></td>
<td>
<p>Name of the variable to be rendered (ignored).</p>
</td></tr>
<tr><td><code id="render.default_+3A_missing">missing</code></td>
<td>
<p>Should missing values be included?</p>
</td></tr>
<tr><td><code id="render.default_+3A_transpose">transpose</code></td>
<td>
<p>Logical indicating whether on not the table is transposed.</p>
</td></tr>
<tr><td><code id="render.default_+3A_render.empty">render.empty</code></td>
<td>
<p>A <code>character</code> to return when <code>x</code> is empty.</p>
</td></tr>
<tr><td><code id="render.default_+3A_render.continuous">render.continuous</code></td>
<td>
<p>A function to render continuous (i.e.
<code>numeric</code>) values. Can also be a <code>character</code> string, in which case
it is passed to <code><a href="#topic+parse.abbrev.render.code">parse.abbrev.render.code</a></code>.</p>
</td></tr>
<tr><td><code id="render.default_+3A_render.categorical">render.categorical</code></td>
<td>
<p>A function to render categorical (i.e.
<code>factor</code>, <code>character</code> or <code>logical</code>) values. Can also be a
<code>character</code> string, in which case it is passed to
<code><a href="#topic+parse.abbrev.render.code">parse.abbrev.render.code</a></code>.</p>
</td></tr>
<tr><td><code id="render.default_+3A_render.missing">render.missing</code></td>
<td>
<p>A function to render missing (i.e. <code>NA</code>) values.
Can also be a <code>character</code> string, in which case it is passed to
<code><a href="#topic+parse.abbrev.render.code">parse.abbrev.render.code</a></code>. Set to <code>NULL</code> to ignore missing
values.</p>
</td></tr>
<tr><td><code id="render.default_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector. Each element is to be displayed in a
separate cell in the table. The <code><a href="base.html#topic+names">names</a></code> of the vector are the
labels to use in the table. However, the first names should be empty as it
will be replaced by the name of the variable. Empty strings are allowed and
result in empty table cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- exp(rnorm(100, 1, 1))
render.default(x)
render.default(x, TRUE)

y &lt;- factor(sample(0:1, 99, replace=TRUE), labels=c("Female", "Male"))
y[1:10] &lt;- NA
render.default(y)

</code></pre>

<hr>
<h2 id='render.missing.default'>Render missing values for table output.</h2><span id='topic+render.missing.default'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1">table1</a></code> by default to render missing (i.e.
<code>NA</code>) values for displaying in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.missing.default(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.missing.default_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="render.missing.default_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code><a href="#topic+stats.apply.rounding">stats.apply.rounding</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector. Each element is to be displayed in a
separate cell in the table. The <code><a href="base.html#topic+names">names</a></code> of the vector are the
labels to use in the table. Empty strings are allowed and
result in empty table cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- factor(sample(0:1, 99, replace=TRUE), labels=c("Female", "Male"))
y[1:10] &lt;- NA
render.missing.default(y)
</code></pre>

<hr>
<h2 id='render.strat.default'>Render strata labels for table output.</h2><span id='topic+render.strat.default'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1.formula">table1.formula</a></code> to render strata labels
for displaying in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.strat.default(label, n, transpose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.strat.default_+3A_label">label</code></td>
<td>
<p>A <code>character</code> vector containing the labels.</p>
</td></tr>
<tr><td><code id="render.strat.default_+3A_n">n</code></td>
<td>
<p>A <code>numeric</code> vector containing the sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code>, which may contain HTML markup.
</p>

<hr>
<h2 id='render.varlabel'>Render variable labels for table output.</h2><span id='topic+render.varlabel'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+table1.formula">table1.formula</a></code> by default to render variable labels
for displaying in the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render.varlabel(x, transpose = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render.varlabel_+3A_x">x</code></td>
<td>
<p>A vector, usually with the <code><a href="#topic+label">label</a></code> and (if appropriate)
<code><a href="grid.html#topic+unit">unit</a></code> attributes.</p>
</td></tr>
<tr><td><code id="render.varlabel_+3A_transpose">transpose</code></td>
<td>
<p>Logical indicating whether on not the table is transposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code>, which may contain HTML markup.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- exp(rnorm(100, 1, 1))
label(x) &lt;- "Weight"
units(x) &lt;- "kg"
render.varlabel(x)

y &lt;- factor(sample(0:1, 99, replace=TRUE), labels=c("Female", "Male"))
y[1:10] &lt;- NA
label(y) &lt;- "Sex"
render.varlabel(y)
</code></pre>

<hr>
<h2 id='signif_pad'>Round numbers with 0-padding.</h2><span id='topic+signif_pad'></span><span id='topic+round_pad'></span>

<h3>Description</h3>

<p>Utility functions to round numbers, similar the the base functions <code>signif</code>
and <code>round</code>, but resulting in character representations that keep zeros at
the right edge if they are significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif_pad(x, digits = 3, round.integers = TRUE, round5up = TRUE, dec, ...)

round_pad(x, digits = 2, round5up = TRUE, dec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signif_pad_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="signif_pad_+3A_digits">digits</code></td>
<td>
<p>An integer specifying the number of significant digits to keep
(for <code>signif_pad</code>) or the number of digits after the decimal point (for
<code>round_pad</code>).</p>
</td></tr>
<tr><td><code id="signif_pad_+3A_round.integers">round.integers</code></td>
<td>
<p>Should rounding be limited to digits to the right of
the decimal point?</p>
</td></tr>
<tr><td><code id="signif_pad_+3A_round5up">round5up</code></td>
<td>
<p>Should numbers with 5 as the last digit always be rounded
up? The standard R approach is &quot;go to the even digit&quot; (IEC 60559 standard,
see <code><a href="base.html#topic+round">round</a></code>), while some other softwares (e.g. SAS, Excel)
always round up.</p>
</td></tr>
<tr><td><code id="signif_pad_+3A_dec">dec</code></td>
<td>
<p>The character symbol to use as decimal mark (locale
specific). [Deprecated; use <code>decimal.mark</code> instead]</p>
</td></tr>
<tr><td><code id="signif_pad_+3A_...">...</code></td>
<td>
<p>Further options, passed to <code>formatC</code> (which is used
internally). Not all options will work, but some might be useful (e.g.
<code>big.mark</code>, <code>decimal.mark</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the rounded numbers.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+signif">signif</a></code>
<code><a href="base.html#topic+round">round</a></code>
<code><a href="base.html#topic+formatC">formatC</a></code>
<code><a href="base.html#topic+prettyNum">prettyNum</a></code>
<code><a href="base.html#topic+format">format</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.9001, 12345, 1.2, 1., 0.1, 0.00001 , 1e5)
signif_pad(x, digits=3)
signif_pad(x, digits=3, round.integers=TRUE)

# Compare:
as.character(signif(x, digits=3))
format(x, digits=3, nsmall=3)
prettyNum(x, digits=3, drop0trailing=TRUE)
prettyNum(x, digits=3, drop0trailing=FALSE)

# This is very close.
formatC(x, format="fg", flag="#", digits=3) 
formatC(signif(x, 3), format="fg", flag="#", digits=3)

# Could always remove the trailing "."
sub("[.]$", "", formatC(x, format="fg", flag="#", digits=3))

</code></pre>

<hr>
<h2 id='stats.apply.rounding'>Apply rounding to basic descriptive statistics.</h2><span id='topic+stats.apply.rounding'></span>

<h3>Description</h3>

<p>Not all statistics should be rounded in the same way, or at all. This
function will apply rounding selectively to a list of statistics as returned
by <code><a href="#topic+stats.default">stats.default</a></code>. In particular we don't round counts (N, NMISS and
FREQ), and for MIN, MAX and MEDIAN the <code>digits</code> is interpreted as the
<em>minimum</em> number of significant digits, so that we don't loose any
precision. Percentages are rounded to a fixed number of decimal places
(default 1) rather than a specific number of significant digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats.apply.rounding(
  x,
  digits = 3,
  digits.pct = 1,
  round.median.min.max = TRUE,
  round.integers = TRUE,
  round5up = TRUE,
  rounding.fn = signif_pad,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats.apply.rounding_+3A_x">x</code></td>
<td>
<p>A list, such as that returned by <code><a href="#topic+stats.default">stats.default</a></code>.</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_digits">digits</code></td>
<td>
<p>An integer specifying the number of significant digits to keep.</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_digits.pct">digits.pct</code></td>
<td>
<p>An integer specifying the number of digits after the
decimal place for percentages.</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_round.median.min.max">round.median.min.max</code></td>
<td>
<p>Should rounding applied to median, min and max?</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_round.integers">round.integers</code></td>
<td>
<p>Should rounding be limited to digits to the right of
the decimal point?</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_round5up">round5up</code></td>
<td>
<p>Should numbers with 5 as the last digit always be rounded
up? The standard R approach is &quot;go to the even digit&quot; (IEC 60559 standard,
see <code><a href="base.html#topic+round">round</a></code>), while some other softwares (e.g. SAS, Excel)
always round up.</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_rounding.fn">rounding.fn</code></td>
<td>
<p>The function to use to do the rounding. Defaults to
<code><a href="#topic+signif_pad">signif_pad</a></code>.</p>
</td></tr>
<tr><td><code id="stats.apply.rounding_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same number of elements as <code>x</code>. The rounded
values will be <code>character</code> (not <code>numeric</code>) and will have 0 padding
to ensure consistent number of significant digits.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signif_pad">signif_pad</a></code>
<code><a href="#topic+stats.default">stats.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- round(exp(rnorm(100, 1, 1)), 6)
stats.default(x)
stats.apply.rounding(stats.default(x), digits=3)
stats.apply.rounding(stats.default(round(x, 1)), digits=3)

</code></pre>

<hr>
<h2 id='stats.default'>Compute some basic descriptive statistics.</h2><span id='topic+stats.default'></span>

<h3>Description</h3>

<p>Values of type <code>factor</code>, <code>character</code> and <code>logical</code> are
treated as categorical. For logicals, the two categories are given the
labels 'Yes' for <code>TRUE</code>, and 'No' for <code>FALSE</code>.  Factor levels with
zero counts are retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats.default(x, quantile.type = 7, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats.default_+3A_x">x</code></td>
<td>
<p>A vector or numeric, factor, character or logical values.</p>
</td></tr>
<tr><td><code id="stats.default_+3A_quantile.type">quantile.type</code></td>
<td>
<p>An integer from 1 to 9, passed as the <code>type</code>
argument to function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="stats.default_+3A_...">...</code></td>
<td>
<p>Further arguments (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. For numeric <code>x</code>, the list contains the numeric elements:
</p>

<ul>
<li> <p><code>N</code>: the number of non-missing values
</p>
</li>
<li> <p><code>NMISS</code>: the number of missing values
</p>
</li>
<li> <p><code>SUM</code>: the sum of the non-missing values
</p>
</li>
<li> <p><code>MEAN</code>: the mean of the non-missing values
</p>
</li>
<li> <p><code>SD</code>: the standard deviation of the non-missing values
</p>
</li>
<li> <p><code>MIN</code>: the minimum of the non-missing values
</p>
</li>
<li> <p><code>MEDIAN</code>: the median of the non-missing values
</p>
</li>
<li> <p><code>CV</code>: the percent coefficient of variation of the non-missing values
</p>
</li>
<li> <p><code>GMEAN</code>: the geometric mean of the non-missing values if non-negative, or <code>NA</code>
</p>
</li>
<li> <p><code>GSD</code>: the geometric standard deviation of the non-missing values if non-negative, or <code>NA</code>
</p>
</li>
<li> <p><code>GCV</code>: the percent geometric coefficient of variation of the
non-missing values if non-negative, or <code>NA</code>
</p>
</li>
<li> <p><code>qXX</code>: various quantiles (percentiles) of the non-missing
values (q01: 1%, q02.5: 2.5%, q05: 5%, q10: 10%, q25: 25% (first
quartile), q33.3: 33.33333% (first tertile), q50: 50% (median, or second
quartile), q66.7: 66.66667% (second tertile), q75: 75% (third quartile),
q90: 90%, q95: 95%, q97.5: 97.5%, q99: 99%)
</p>
</li>
<li> <p><code>Q1</code>: the first quartile of the non-missing values (alias <code>q25</code>)
</p>
</li>
<li> <p><code>Q2</code>: the second quartile of the non-missing values (alias <code>q50</code> or <code>Median</code>)
</p>
</li>
<li> <p><code>Q3</code>: the third quartile of the non-missing values (alias <code>q75</code>)
</p>
</li>
<li> <p><code>IQR</code>: the inter-quartile range of the non-missing values (i.e., <code>Q3 - Q1</code>)
</p>
</li>
<li> <p><code>T1</code>: the first tertile of the non-missing values (alias <code>q33.3</code>)
</p>
</li>
<li> <p><code>T2</code>: the second tertile of the non-missing values (alias <code>q66.7</code>)
</p>
</li></ul>

<p>If <code>x</code> is categorical (i.e. factor, character or logical), the list
contains a sublist for each category, where each sublist contains the
numeric elements:
</p>

<ul>
<li> <p><code>FREQ</code>: the frequency count
</p>
</li>
<li> <p><code>PCT</code>: the percent relative frequency, including NA in the denominator
</p>
</li>
<li> <p><code>PCTnoNA</code>: the percent relative frequency, excluding NA from the denominator
</p>
</li>
<li> <p><code>NMISS</code>: the number of missing values
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- exp(rnorm(100, 1, 1))
stats.default(x)

y &lt;- factor(sample(0:1, 99, replace=TRUE), labels=c("Female", "Male"))
y[1:10] &lt;- NA
stats.default(y)
stats.default(is.na(y))

</code></pre>

<hr>
<h2 id='subsetp'>Subset function that preserves column attributes.</h2><span id='topic+subsetp'></span>

<h3>Description</h3>

<p>Subset function that preserves column attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetp(x, ..., droplevels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetp_+3A_x">x</code></td>
<td>
<p>An object to be subsetted (usually a <code><a href="base.html#topic+data.frame">data.frame</a></code>).</p>
</td></tr>
<tr><td><code id="subsetp_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+subset">subset</a></code>.</p>
</td></tr>
<tr><td><code id="subsetp_+3A_droplevels">droplevels</code></td>
<td>
<p>If <code>TRUE</code> (the default), then unused factor levels are dropped (see <code><a href="base.html#topic+droplevels">droplevels</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object similar to <code>x</code> containing just the selected elements.
In the case of a <code><a href="base.html#topic+data.frame">data.frame</a></code>, attributes of columns (such as
<code><a href="#topic+label">label</a></code> and <code><a href="#topic+units">units</a></code>) are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>
<code><a href="base.html#topic+droplevels">droplevels</a></code>
</p>

<hr>
<h2 id='t1flex'>Convert a <code>table1</code> object to <code>flextable</code>.</h2><span id='topic+t1flex'></span>

<h3>Description</h3>

<p>Convert a <code>table1</code> object to <code>flextable</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t1flex(x, tablefn = c("qflextable", "flextable", "regulartable"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t1flex_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
<tr><td><code id="t1flex_+3A_tablefn">tablefn</code></td>
<td>
<p>Choose a function from the <code>flextable</code> package to use as
the basis for the table.</p>
</td></tr>
<tr><td><code id="t1flex_+3A_...">...</code></td>
<td>
<p>Further options passed to <code>tablefn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>flextable</code> object.
</p>


<h3>Note</h3>

<p>The <code>flextable</code> package needs to be installed for this to work.
</p>

<hr>
<h2 id='t1kable'>Convert a <code>table1</code> object to <code>kabelExtra</code>.</h2><span id='topic+t1kable'></span>

<h3>Description</h3>

<p>Convert a <code>table1</code> object to <code>kabelExtra</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t1kable(x, booktabs = TRUE, ..., format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t1kable_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
<tr><td><code id="t1kable_+3A_booktabs">booktabs</code></td>
<td>
<p>Passed to <code>kbl</code> (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="t1kable_+3A_...">...</code></td>
<td>
<p>Other options passed to <code>kbl</code>.</p>
</td></tr>
<tr><td><code id="t1kable_+3A_format">format</code></td>
<td>
<p>Passed to <code>kbl</code> (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>kabelExtra</code> object.
</p>


<h3>Note</h3>

<p>The <code>kableExtra</code> package needs to be installed for this to work.
</p>

<hr>
<h2 id='t1read'>Read and augment data with extended metadata attributes</h2><span id='topic+t1read'></span>

<h3>Description</h3>

<p>Read and augment data with extended metadata attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t1read(data, metadata = NULL, read.fun = read.csv, ..., escape.html = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t1read_+3A_data">data</code></td>
<td>
<p>Either a file name (<code>character</code>) or a <code>data.frame</code>. If
a file name it will be read using the function <code>read.fun</code>.</p>
</td></tr>
<tr><td><code id="t1read_+3A_metadata">metadata</code></td>
<td>
<p>Either a file name (<code>character</code>) or a <code>list</code>. If a
file name it will be read using the function <code><a href="yaml.html#topic+read_yaml">read_yaml</a></code>
(so it should be a file the contains valid YAML text), and a <code>list</code> results.
See Details regarding the <code>list</code> contents.</p>
</td></tr>
<tr><td><code id="t1read_+3A_read.fun">read.fun</code></td>
<td>
<p>A function to read files. It should accept a file name as
its first argument and return a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="t1read_+3A_...">...</code></td>
<td>
<p>Further optional arguments, passed to <code>read.fun</code>.</p>
</td></tr>
<tr><td><code id="t1read_+3A_escape.html">escape.html</code></td>
<td>
<p>Logical. Should strings (labels, units) be converted to
valid HTML by escaping special symbols?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>metadata</code> list may contain the following 3 named elements
(other elements are ignored):
</p>

<ul>
<li> <p><code>labels</code>: a named list, with names corresponding to columns in <code>data</code>
and values the associated label attribute.
</p>
</li>
<li> <p><code>units</code>: a named list, with names corresponding to columns in <code>data</code>
and values the associated units attribute.
</p>
</li>
<li> <p><code>categoricals</code>: a named list, with names corresponding to columns in
<code>data</code> and values are themselves lists, used to convert the column to
a <code>factor</code>: the list names are the levels, and the values are the
associated labels. The names can also be omitted if the goal is just to
specify the order of the factor levels.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> (as returned by <code>read.fun</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data
set.seed(123)
data &lt;- expand.grid(sex=0:1, cohort=1:3)[rep(1:6, times=c(7, 9, 21, 22, 11, 14)),]
data$age &lt;- runif(nrow(data), 18, 80)
data$agecat &lt;- 1*(data$age &gt;= 65)
data$wgt &lt;- rnorm(nrow(data), 75, 15)

metadata &lt;- list(
  labels=list(
    cohort = "Cohort",
    sex = "Sex",
    age = "Age",
    agecat  = "Age category",
    wgt = "Weight"),
  units=list(
    age = "years",
    wgt = "kg"),
  categoricals=list(
    cohort = list(
      `1` = "Cohort A",
      `2` = "Cohort B",
      `3` = "Cohort C"),
    sex = list(
      `0` = "Female",
      `1` = "Male"),
    agecat = list(
      `0` = "&lt; 65",
      `1` = "\U{2265} 65")))

 data &lt;- t1read(data, metadata)
 table1(~ sex + age + agecat + wgt | cohort, data=data)

</code></pre>

<hr>
<h2 id='table.rows'>Convert to HTML table rows.</h2><span id='topic+table.rows'></span><span id='topic+table.data'></span>

<h3>Description</h3>

<p>Many functions exist in R to generate HTML tables.  These functions are
useful for generating HTML table fragments (rather than whole tables), which
can then be used to build up complete tables. The first column my be used to
label the rows of the table. Row labels, if specified, can have a special
HTML <code>class</code> designated, which can be useful as a hook to customize
their appearance using CSS. The same is true for the the first and last row
of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.rows(
  x,
  row.labels = rownames(x),
  th = FALSE,
  class = NULL,
  rowlabelclass = "rowlabel",
  firstrowclass = "firstrow",
  lastrowclass = "lastrow",
  ...
)

table.data(
  x,
  row.labels = rownames(x),
  th = FALSE,
  class = NULL,
  rowlabelclass = "rowlabel",
  firstrowclass = "firstrow",
  lastrowclass = "lastrow",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.rows_+3A_x">x</code></td>
<td>
<p>A vector or table-like structure (e.g. a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code>).</p>
</td></tr>
<tr><td><code id="table.rows_+3A_row.labels">row.labels</code></td>
<td>
<p>Values for the first column, typically used to label the row, or <code>NULL</code> to omit.</p>
</td></tr>
<tr><td><code id="table.rows_+3A_th">th</code></td>
<td>
<p>A logical. Should <code>th</code> tags be used rather than <code>td</code>?</p>
</td></tr>
<tr><td><code id="table.rows_+3A_class">class</code></td>
<td>
<p>HTML class attribute. Can be a single <code>character</code>, a vector or a matrix.</p>
</td></tr>
<tr><td><code id="table.rows_+3A_rowlabelclass">rowlabelclass</code></td>
<td>
<p>HTML class attribute for the row labels (i.e. first column).</p>
</td></tr>
<tr><td><code id="table.rows_+3A_firstrowclass">firstrowclass</code></td>
<td>
<p>HTML class attribute for the first row of cells.</p>
</td></tr>
<tr><td><code id="table.rows_+3A_lastrowclass">lastrowclass</code></td>
<td>
<p>HTML class attribute for the last row of cells.</p>
</td></tr>
<tr><td><code id="table.rows_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> which contains an HTML table fragment.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>table.data()</code>: Convert to HTML table data (cells).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(signif_pad(exp(rnorm(5*5, 1, 1))), 5, 5)
table.data(x)
cat(table.rows(x, NULL))
cat(table.rows(x, LETTERS[1:nrow(x)]))
cat(table.rows(LETTERS[1:3], "Headings", th=TRUE))
</code></pre>

<hr>
<h2 id='table1'>Generate an HTML table of descriptive statistics.</h2><span id='topic+table1'></span><span id='topic+table1.default'></span><span id='topic+table1.formula'></span>

<h3>Description</h3>

<p>Produces a nicely formatted table of descriptive statistics for any number
of numeric or categorical variables, optionally stratified by a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table1(x, ...)

## Default S3 method:
table1(
  x,
  labels,
  groupspan = NULL,
  rowlabelhead = "",
  transpose = FALSE,
  topclass = "Rtable1",
  footnote = NULL,
  caption = NULL,
  render = render.default,
  render.strat = render.strat.default,
  extra.col = NULL,
  extra.col.pos = NULL,
  ...
)

## S3 method for class 'formula'
table1(
  x,
  data,
  overall = "Overall",
  rowlabelhead = "",
  transpose = FALSE,
  droplevels = TRUE,
  topclass = "Rtable1",
  footnote = NULL,
  caption = NULL,
  render = render.default,
  render.strat = render.strat.default,
  extra.col = NULL,
  extra.col.pos = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table1_+3A_x">x</code></td>
<td>
<p>An object, typically a <code>formula</code> or list of <code>data.frame</code>s (see Details).</p>
</td></tr>
<tr><td><code id="table1_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>render</code>.</p>
</td></tr>
<tr><td><code id="table1_+3A_labels">labels</code></td>
<td>
<p>A list containing labels for variables, strata and groups (see Details).</p>
</td></tr>
<tr><td><code id="table1_+3A_groupspan">groupspan</code></td>
<td>
<p>A vector of integers specifying the number of strata to group together.</p>
</td></tr>
<tr><td><code id="table1_+3A_rowlabelhead">rowlabelhead</code></td>
<td>
<p>A heading for the first column of the table, which contains the row labels.</p>
</td></tr>
<tr><td><code id="table1_+3A_transpose">transpose</code></td>
<td>
<p>Logical. Should the table be transposed (i.e. strata as
rows and variables as columns)?</p>
</td></tr>
<tr><td><code id="table1_+3A_topclass">topclass</code></td>
<td>
<p>A class attribute for the outermost (i.e. <code>&lt;table&gt;</code>) tag.</p>
</td></tr>
<tr><td><code id="table1_+3A_footnote">footnote</code></td>
<td>
<p>A character string to be added as a footnote to the table.
Can also be a vector which results in multiple lines of footnotes.
The default <code>NULL</code> causes the footnote to be omitted.</p>
</td></tr>
<tr><td><code id="table1_+3A_caption">caption</code></td>
<td>
<p>A character string to be added as a caption to the table.
The default <code>NULL</code> causes the caption to be omitted.</p>
</td></tr>
<tr><td><code id="table1_+3A_render">render</code></td>
<td>
<p>A function to render the table cells (see Details).</p>
</td></tr>
<tr><td><code id="table1_+3A_render.strat">render.strat</code></td>
<td>
<p>A function to render the stratum labels. Accepts 3
arguments: the stratum label, the stratum size (number of observations), and
a flag indicating whether we are in transpose mode or not. See
<code><a href="#topic+render.strat.default">render.strat.default</a></code> for an example.</p>
</td></tr>
<tr><td><code id="table1_+3A_extra.col">extra.col</code></td>
<td>
<p>An optional names list of functions that produce extra columns in the table (see Details).</p>
</td></tr>
<tr><td><code id="table1_+3A_extra.col.pos">extra.col.pos</code></td>
<td>
<p>An optional integer vector given the positions of extra columns (see Details).</p>
</td></tr>
<tr><td><code id="table1_+3A_data">data</code></td>
<td>
<p>For the formula interface, a <code>data.frame</code> from which the
variables in <code>x</code> should be taken.</p>
</td></tr>
<tr><td><code id="table1_+3A_overall">overall</code></td>
<td>
<p>A label for the &quot;Overall&quot; column. Specify <code>NULL</code> or
<code>FALSE</code> to omit the column altogether. By default, the &quot;Overall&quot; column
appears at the right end of the table; to place it on the left instead use a
named <code>character</code> with the name &quot;left&quot;, e.g. <code>c(left="Overall")</code>.</p>
</td></tr>
<tr><td><code id="table1_+3A_droplevels">droplevels</code></td>
<td>
<p>Should empty factor levels be dropped?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two interfaces, the default, which typically takes a list of
<code>data.frame</code>s for <code>x</code>, and the formula interface. The formula
interface is less flexible, but simpler to use and designed to handle the
most common use cases. It is important to use factors appropriately for
categorical variables (i.e. have the levels labeled properly and in the
desired order). The contents of the table can be customized by providing
user-defined &lsquo;renderer&rsquo; functions. Customization of the table appearance is
deliberately not attempted, as this is best accomplished with CSS. To
facilitate this, some tags (such as row labels) are given specific classes
for easy CSS selection.
</p>
<p>For the formula version, the formula is expected to be a one-sided formula,
optionally  with a vertical bar separating the variables that are to appear
as data in the table (as rows) from those used for stratification (i.e.
columns). There can be at most 2 variables for stratification (and only one
if <code>transpose = TRUE</code> is specified), and if 2 are specified, the second
is nested within the first. Stratification variables may not contain missing
values. The formula may contain a dot (&quot;.&quot;) to refer to &quot;all variables in
<code>data</code> other than those that appear elsewhere in the formula&quot;. It is
legitimate to use functions inside the formula to create new variables.
</p>
<p>For the default version, is is expected that <code>x</code> is a named
list of <code>data.frame</code>s, one for each stratum, with names corresponding to
strata labels.
</p>
<p>Extra columns can be added to the table using the <code>extra.col</code> argument.
This is an optional named list of functions, with the names corresponding to
the column headings. Each function will be called once for each variable
included in the table. Each function should expect 2 arguments, the first
being a list, the second the name of the variable. The contents of the
list passed in as the first argument will be the data associated with each
stratum in the table; i.e., one element for each normal column (not extra
column). It is then up the function to compute the value to appear in
the extra column and return it as a string. By default, extra columns will
be placed to the far right, after the normal columns, in the order they are
specified in. This can be overridden, however, using the
<code>extra.col.pos</code> vector of integer positions. For example, to place the
first extra column in position 1 (far left), and the second extra column in
position 3, use <code>extra.col.pos = c(1, 3)</code>; any extra columns that are
not assigned positions will be placed to the far right. A typical use case
for extra columns would be a column of p-values for differences between
strata. Note that this feature is not available when the option
<code>transpose = TRUE</code> is specified.
</p>


<h3>Value</h3>

<p>An object of class &quot;table1&quot;.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>table1(default)</code>: The default interface, where <code>x</code> is a <code>data.frame</code>.
</p>
</li>
<li> <p><code>table1(formula)</code>: The <code>formula</code> interface.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- expand.grid(id=1:10, sex=c("Male", "Female"), treat=c("Treated", "Placebo"))
dat$age &lt;- runif(nrow(dat), 10, 50)
dat$age[3] &lt;- NA  # Add a missing value
dat$wt &lt;- exp(rnorm(nrow(dat), log(70), 0.2))

label(dat$sex) &lt;- "Sex"
label(dat$age) &lt;- "Age"
label(dat$treat) &lt;- "Treatment Group"
label(dat$wt) &lt;- "Weight"

units(dat$age) &lt;- "years"
units(dat$wt) &lt;- "kg"

# One level of stratification
table1(~ sex + age + wt | treat, data=dat)

# Two levels of stratification (nesting)
table1(~ age + wt | treat*sex, data=dat)

# Switch the order or nesting
table1(~ age + wt | sex*treat, data=dat)

# No stratification
table1(~ treat + sex + age + wt, data=dat)

# Something more complicated

dat$dose &lt;- ifelse(dat$treat=="Placebo", "Placebo",
                   sample(c("5 mg", "10 mg"), nrow(dat), replace=TRUE))
dat$dose &lt;- factor(dat$dose, levels=c("Placebo", "5 mg", "10 mg"))

strata &lt;- c(split(dat, dat$dose),
            list("All treated"=subset(dat, treat=="Treated")),
            list(Overall=dat))

labels &lt;- list(
    variables=list(sex=render.varlabel(dat$sex),
                   age=render.varlabel(dat$age),
                   wt=render.varlabel(dat$wt)),
    groups=list("", "Treated", ""))

my.render.cont &lt;- function(x) {
    with(stats.default(x), 
        sprintf("%0.2f (%0.1f)", MEAN, SD))
}

table1(strata, labels, groupspan=c(1, 3, 1), render.continuous=my.render.cont)

# Transposed table
table1(~ age + wt | treat, data=dat, transpose=TRUE)

</code></pre>

<hr>
<h2 id='units'>Units attribute.</h2><span id='topic+units'></span><span id='topic+units+3C-'></span><span id='topic+has.units'></span>

<h3>Description</h3>

<p>Units attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>units(x)

units(x) &lt;- value

has.units(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="units_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="units_+3A_value">value</code></td>
<td>
<p>A <code>character</code> specifying the units</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>units(x) &lt;- value</code>: Set units attribute.
</p>
</li>
<li> <p><code>has.units()</code>: Check for attribute.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
units(x) &lt;- "cm"
has.units(x)
units(x)
</code></pre>

<hr>
<h2 id='update_html'>Update HTML.</h2><span id='topic+update_html'></span>

<h3>Description</h3>

<p>Used to (re-)generate the HTML code for a <code>link{table1}</code> object. In
most cases, this should not be used direction, unless you know what you are
doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_html(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_html_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+table1">table1</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;table1&quot; which contains the updated HTML.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
