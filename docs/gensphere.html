<!DOCTYPE html><html><head><title>Help for package gensphere</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gensphere}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cfunc.new'><p>Define and evaluate a contour function</p></a></li>
<li><a href='#gensphere'><p>Generalized spherical distribution definition, density, simulation</p></a></li>
<li><a href='#gensphere-package'><p>gensphere</p></a></li>
<li><a href='#genspheremisc'><p>Miscellaneous functions used in working with generalized spherical laws</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Spherical Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-12</td>
</tr>
<tr>
<td>Author:</td>
<td>John P Nolan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John P Nolan &lt;jpnolan@american.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), mvmesh, geometry, SphericalCubature (&ge; 1.5), rgl,
utils, grDevices, graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Define and compute with generalized spherical distributions - multivariate probability
 laws that are specified by a star shaped contour (directional behavior) and a radial component.
 The methods are described in Nolan (2016) &lt;<a href="https://doi.org/10.1186%2Fs40488-016-0053-0">doi:10.1186/s40488-016-0053-0</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>SimplicialCubature</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-12 16:44:57 UTC; John</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-12 18:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cfunc.new'>Define and evaluate a contour function
</h2><span id='topic+cfunc.new'></span><span id='topic+cfunc.add.term'></span><span id='topic+cfunc.finish'></span><span id='topic+cfunc.eval'></span>

<h3>Description</h3>

<p>The directional part of a generalized spherical distribution is defined
by a contour function, cfunc for short.  These functions are used to
define a contour function and then evaluate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfunc.new(d)
cfunc.add.term(cfunc, type, k)
cfunc.finish(cfunc, nsubdiv = 2, maxEvals=100000, norm.const.method="integrate",...)
cfunc.eval(cfunc, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfunc.new_+3A_d">d</code></td>
<td>
<p>dimension of the space
</p>
</td></tr>
<tr><td><code id="cfunc.new_+3A_cfunc">cfunc</code></td>
<td>
<p>an object of class &quot;gensphere.contour&quot;
</p>
</td></tr>  
<tr><td><code id="cfunc.new_+3A_type">type</code></td>
<td>
<p>string describing what type of term to add to the contour
</p>
</td></tr>
<tr><td><code id="cfunc.new_+3A_k">k</code></td>
<td>
<p>a vector of constants used to specify a term
</p>
</td></tr>  
<tr><td><code id="cfunc.new_+3A_x">x</code></td>
<td>
<p>a (d x n) matrix, with columns x[,i] being points in R^d
</p>
</td></tr>    
<tr><td><code id="cfunc.new_+3A_nsubdiv">nsubdiv</code></td>
<td>
<p>number of dyadic subdivisions of the sphere, controls the refinement of the tessellation. Typical values are 2 or 3.
</p>
</td></tr>
<tr><td><code id="cfunc.new_+3A_maxevals">maxEvals</code></td>
<td>
<p>maximum number of evaluations of the integrand function, see details section below
</p>
</td></tr>
<tr><td><code id="cfunc.new_+3A_norm.const.method">norm.const.method</code></td>
<td>
<p>method used to compute the norming constant.  Can be &quot;integrate&quot; (the default, in which case the contour function is
numerically integrated to get the norming constant), or &quot;simplex.area&quot; (in which case no integration is done; the surface area of the contour is 
approximated by the surface area of the tesselation).  This later choice is for complex surface or higher dimensional surfaces where
the numerical integration may fail or take a very long time.  This allows simulation in cases where the numerical integration is not feasible.
</p>
</td></tr>
<tr><td><code id="cfunc.new_+3A_...">...</code></td>
<td>
<p>optional arguments to pass to integration routine, see details section below
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A contour function describes the directional behavior of a generalized spherical distribution.
In this package, a contour function is built by calling three functions:
<code>cfunc.new</code> to start the definition of a d-dimensional contour, <code>cfunc.add.term</code> to add a
new term to a contour (may be called more than once), and <code>cfunc.finish</code> to complete the
defintion of a contour.  
</p>
<p>When adding a term, type is one of the literal strings &quot;constant&quot;, &quot;elliptical&quot;, &quot;proj.normal&quot;, &quot;lp.norm&quot;, &quot;gen.lp.norm&quot;, or &quot;cone&quot;.
The vector k contains the constants necessary to specify the desired shape.  k[1]=the first element of k
is always a scale, it allows one to expand or contract a 
shape.  The remaining elements of k depend on the value of 'type'.:
</p>

<ul>
<li><p>&quot;constant&quot;: k is a single number; k[1]=radius of the sphere
</p>
</li>
<li><p>&quot;elliptical&quot;: k is a vector of length d^2+1; k[1]=scale of ellipse, k[2:(d^2+1)] specify the symmetric positive definite matrix B with is used to compute
the elliptical contour
</p>
</li>
<li><p>&quot;proj.normal&quot;: k is a vector of length d+2; k[1]=scale of the bump, mu=k[2:(d+1)] is the vector pointing 
in the direction where the normal bump is centered,     k[d+2]=standard deviation of the isotropic normal bump
</p>
</li>
<li><p>&quot;lp.norm&quot;: k is a vector of length 2; k[1]=scale and k[2]=p, the power used in the l_p norm
</p>
</li>
<li><p>&quot;gen.lp.norm&quot;: k is vector of length 2+m*d for some positive integer m; k[1]=scale, k[2]=p, the power used in the l-p norm, k[3:(2+m*d)] 
spcifies a matrix A that is used to compute || A x ||_p 
</p>
</li>
<li><p>&quot;cone&quot;: k is a vector of length d+2, k[1]=scale, mu=k[2:(d+1)]= the center of the cone, k[d+2]=base of the cone
</p>
</li></ul>

<p>Note that <code>cfunc.finish</code> does a lot of calculation, and may take a while, especially
in dimension d &gt; 2.  The most time consuming part is numerically integrating over the contour,
a (d-1) dimensional surface in d-dimensional space and in tesselating the contour in a way that
focuses on the bulges in the contour from cones and normal bumps.  The integration is 
required to calculate the norming constant needed to compute the density.  This integration is
performed by using function <code>adaptIntegrateSphereTri</code> in <span class="pkg">SphericalCubature</span> and is 
numerically challenging.  In dimension d &gt; 3 or if nsubdiv &gt; 4, users may need to adjust the arguments maxEvals
and ...  The default value maxEvals=100000 workw in most 3 dim. problems, and it takes a
few seconds to calculate.  (For an idea of the size and time required, a d=4 dim. case
used maxEvals=1e+7 and took around 5 minutes. A d=5 dim. case used maxEvals=1e+8, used
160167 simplices and took over 2 days.)  Note that this calculation is only done once;
calculating densities and simulating is still fast in higher dimensions.  It may be useful
to save a complicated/large contour object so that it can be reused across
R sessions via <code>save(cfunc)</code> and <code>load(cfunc)</code>.
</p>
<p>Note: the first time <code>cfunc.finish</code> is called, a warning message 
about &quot;no degenerate regions are returned&quot; is printed by the package
<span class="pkg">geometry</span>.  I do not know how to turn that off; so just ignore it.
</p>
<p><code>cfunc.eval</code> is used to evaluate a completed
contour function.
</p>


<h3>Value</h3>

<p><code>cfunc.new</code> and <code>cfunc.add.term</code> return a list that is an incomplete definition
of a contour function.  <code>cfunc.finish</code> completes the definition and returns an S3 object of
class &quot;gensphere.contour&quot; with fields:
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of terms in the contour function, i.e. the number of times <code>cfunc.add.term</code> was called</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a vector length m of type list, with each list describing a term in the contour function</p>
</td></tr>
<tr><td><code>norm.const</code></td>
<td>
<p>norming constant</p>
</td></tr>
<tr><td><code>functionEvaluations</code></td>
<td>
<p>number of times the integrand (contour) function is evaluated by <code>adaptIntegrateSphereTri</code> when computing norm.const</p>
</td></tr>
<tr><td><code>tessellation</code></td>
<td>
<p>an object of type &quot;mvmesh&quot; that gives a geometrical description of the contour. It is used
to plot the contour and to simulate from the contour</p>
</td></tr>
<tr><td><code>tessellation.weights</code></td>
<td>
<p>weights used in simulation; surface area of the simplices in the tessellation</p>
</td></tr>
<tr><td><code>simplex.count</code></td>
<td>
<p>vector of length 3 giving the number of simplices used at the end of
three internal stages of construction: after initial subdivision, after refining the sphere based on cones and bumps, 
and final count have adaptive integration routine partitions the sphere</p>
</td></tr>
<tr><td><code>norm.const.method</code></td>
<td>
<p>value of input argument norm.const.method</p>
</td></tr>
</table>
<p><code>cfunc.eval</code> returns a vector of length n=nrow(x); y[i] = cfunc(x[,i]) = value of the contour function at point x[,i].
</p>
<p>The plots below show the three contours defined in the examples below.
</p>

<p><img src="../help/figures/contours2d.png" alt="contours2d.png" />
</p>
<p><img src="../help/figures/ballbump.png" alt="ballbump.png" />


</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2-dim diamond
cfunc1 &lt;- cfunc.new(d=2)
cfunc1 &lt;- cfunc.add.term( cfunc1,"lp.norm",k=c(1,1))
cfunc1 &lt;- cfunc.finish( cfunc1 )
cfunc1
cfunc.eval( cfunc1, c(sqrt(2)/2, sqrt(2)/2) )
if( interactive()) { plot( cfunc1, col='red', lwd=3, main="diamond contour") }

# 2-dim blob
cfunc2 &lt;- cfunc.new(d=2)
cfunc2 &lt;- cfunc.add.term( cfunc2,"constant",k=1)
cfunc2 &lt;- cfunc.add.term( cfunc2,"proj.normal",k=c( 1, sqrt(2)/2, sqrt(2)/2, 0.1) )
cfunc2 &lt;- cfunc.add.term( cfunc2,"proj.normal",k=c( 1, -1,0, 0.1) )
cfunc2 &lt;- cfunc.finish( cfunc2, nsubdiv=4 )
if(interactive()) {
  plot( cfunc2, col='green', lwd=3, main="contour with two bumps")

  # 3-dim ball with one spike
  cfunc3 &lt;- cfunc.new( d=3 )
  cfunc3 &lt;- cfunc.add.term( cfunc3, "elliptical",k=c( 1,  1,0,0, 0,1,0, 0,0,1 ) )
  cfunc3 &lt;- cfunc.add.term( cfunc3, "proj.normal",k=c( 1, 1,0,0, .25 ) ) 
  cfunc3 &lt;- cfunc.finish( cfunc3, nsubdiv=3 ) # takes ~20 seconds, get warnings
  plot( cfunc3, show.faces=TRUE, col='blue')
  nS &lt;- dim(cfunc3$tessellation$S)[3]
  title3d( paste("ball with bump with",nS,"simplices"))
}
</code></pre>

<hr>
<h2 id='gensphere'>Generalized spherical distribution definition, density, simulation
</h2><span id='topic+gensphere'></span><span id='topic+dgensphere'></span><span id='topic+rgensphere'></span>

<h3>Description</h3>

<p>Define a generalized spherical distribution by 
specifying a contour function, a radial density function, 
a radial simulation function, and a value of the density at the origin.
Once it is defined, compute density and simulate that distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gensphere(cfunc, dradial, rradial, g0)
dgensphere(x, gs.dist)
rgensphere(n, gs.dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gensphere_+3A_cfunc">cfunc</code></td>
<td>
<p>contour function object defined by <code>cfunc.new</code>, <code>cfunc.add.term</code> and <code>cfunc.finish</code>
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_dradial">dradial</code></td>
<td>
<p>a function to evaluate the density for the radial component of distribution
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_rradial">rradial</code></td>
<td>
<p>a function to simulate values of the radial distribution
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_g0">g0</code></td>
<td>
<p>g(0) = value of the multivariate density at the origin
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_x">x</code></td>
<td>
<p>(d x n) matrix of point where the density is to be evaluated.  Columns x[,i] are vectors in d-space
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_gs.dist">gs.dist</code></td>
<td>
<p>a generalized spherical distribution, an object returned by function <code>gensphere</code>
</p>
</td></tr>
<tr><td><code id="gensphere_+3A_n">n</code></td>
<td>
<p>number of values to generate
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generalized spherical distribution is specified by calling function <code>gensphere</code> with
the contour function (defined via function <code>cfunc.new</code>, <code>cfunc.add.term</code> and <code>cfunc.finish</code>),
a function to compute the density of the radial term R, a runction to simulate from the radial term R,
and g(0)=the value of the density at the origin.  See the general representation of generalized spherical
laws in <a href="#topic+gensphere-package">gensphere-package</a>.  
</p>
<p>If the distribution is d dimensional and the radial term is
a gamma distribution with shape=shape and scale=1,g(0)=0 if  d &lt; shape, g(0)=cfunc$norm.const if d=shape,
<code class="reqn">g(0)=\infty</code> if d &gt; shape.  In general, 
<code class="reqn"> g(0)=\lim_{r \to 0^+} r^{1-d} dradial(r)</code>. 
</p>


<h3>Value</h3>

<p><code>gensphere</code> returns an S3 object of class &quot;gensphere.distribution&quot; with components:
</p>
<table>
<tr><td><code>cfunc</code></td>
<td>
<p>a contour function defined with <code>cfunc.new</code>, etc.</p>
</td></tr>
<tr><td><code>dradial</code></td>
<td>
<p>a function that evaluates the desnity of the radial component</p>
</td></tr>
<tr><td><code>rradial</code></td>
<td>
<p>a function that simulates values of the radial component</p>
</td></tr>
<tr><td><code>g0</code></td>
<td>
<p>g(0), the value of the multivariate density g(x) at the origin</p>
</td></tr>
</table>
<p><code>dgensphere</code> returns a numeric vector y that contains the value of the
density of <b>X</b>: y[i]=g(x[,i]), i=1,...,n.  Note that g(x) is the density of
the vector <b>X</b>, whereas <code>dradial</code> is the denis of the univariate radial term R.
</p>
<p><code>rgensphere</code> returns a (d x n) matrix of simulated values of <b>X</b>. Note that
these values are an approximation to the distribution of X because the contour
is approximated to a limited accuracy in <code>cfund.finish</code>.
</p>
<p>Here are plots of the density surface and simulated points generated by the examples below.
</p>

<p><img src="../help/figures/densitysurface.png" alt="densitysurface.png" />
<img src="../help/figures/rgensphere.png" alt="rgensphere.png" />


</p>


<h3>See Also</h3>

<p><code><a href="#topic+gensphere-package">gensphere-package</a></code>, <code><a href="#topic+cfunc.new">cfunc.new</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define a diamond shaped contour
cfunc1 &lt;- cfunc.new(d=2)
cfunc1 &lt;- cfunc.add.term( cfunc1,"gen.lp.norm",k=c(1,1,2,0,0,1))
cfunc1 &lt;- cfunc.finish( cfunc1 )
cfunc1


# define a generalized spherical distribution
rradial &lt;- function( n ) { rgamma( n, shape=2 ) }
dradial &lt;- function( x ) { dgamma( x, shape=2 ) }
dist1 &lt;- gensphere( cfunc1, dradial, rradial, g0=cfunc1$norm.const ) 
dist1

# calculate density at a few points
dgensphere( x=matrix( c(0,0, 0,1, 0,2), nrow=2, ncol=3), dist1 )

# simulate values from the distribution
x &lt;- rgensphere( 10000, dist1 )

# calculate and plot density surface on a grid
xy.grid &lt;- seq(-3,3,.1)
if( interactive() ) {
  z &lt;- gs.pdf2d.plot( dist1, xy.grid )
  title3d("density surface")
  plot(t(x),xlab="x",ylab="y",main="simulated points")
} 


</code></pre>

<hr>
<h2 id='gensphere-package'>gensphere
</h2><span id='topic+gensphere-package'></span>

<h3>Description</h3>

<p>Define and compute with generalized spherical distributions - multivariate probability
laws that are specified by a star shaped contour (directional behavior) and a radial component.
</p>


<h3>Details</h3>

<p>This package implements some classes of generalized spherical distributions in dimensions 2, 3, and above.
Functions <code>cfunc.new</code>, <code>cfunc.add.term</code>, <code>cfunc.finish</code> give a flexible way to define a range of shapes for the 
star-shaped contours.  Then function <code>gensphere</code> defines a generalized spherical distribution
using a contour function and a specification of the radial term.  Function <code>dgensphere</code> is used 
to compute the multivariate density g(x) for X and function  <code>rgensphere</code> is
used to simulate a sample random vectors with the (approximate) distribution X.
</p>
<p>A large class of distribution can be described as generalized spherical laws. 
In particular, all isotropic/radially symmetric distributions and all elliptically contoured
distributions are generalized spherical laws. Such distributions can be represented as:
<code class="reqn">\mathbf{X} = R \mathbf{S}</code>
where R is a positive random variable and <b>S</b> is a random vector distributed uniformly (with respect to surface area) on 
the contour, see Nolan (2015).  
</p>
<p>Throughout this package, points in d-dimensional space are represented as column vectors; this is different
than what base <span class="rlang"><b>R</b></span> and packages <span class="pkg">mvmesh</span>, <span class="pkg">geometry</span>, etc. use; but it is the same as package <span class="pkg">SphericalCubature</span>,
<span class="pkg">SimplicialCubature</span>, and other packages.
</p>
<p>This research was supported by an agreement with Cornell University, Operations 
Research &amp; Information Engineering, under contract W911NF-12-1-0385 from the Army 
Research Development and Engineering Command.
</p>
<p>Please let me know if you find any mistakes.  I will try to fix bugs promptly.
Constructive comments for improvements are welcome;  
actually implementing any suggestions will be dependent on time constraints.
</p>
<p>Version 1.0 was released on 18 May 2016.  Version 1.1 was released on 13 September 2017 and includes a 
new optional argument norm.const.method in the function cfunc.finish.  Also changes were made to 
accomodate changes in package SphericalCubature.
</p>
<p>Version 1.2 (never on CRAN, 10 January 2021) has a minor change to work with the update of package
SphericalCubature to version 1.5, updated a reference, and the
examples include <code>if( interactive() )</code> around calls to plotting functions.
Version 1.3 (12 January 2021) adds links to the DOI for the paper this work
is based on, and provides a faster 3-d example.
</p>


<h3>Author(s)</h3>

<p>John P Nolan
</p>
<p>Maintainer: John P Nolan
</p>


<h3>References</h3>

<p>B. C. Arnold, E. Castillo and J. M. Sarabia (2008), Multivariate distributions defined in terms of contours,
J. Stat. Planning and Inference, 138, 4158 - 4171 
</p>
<p>C. Fernandez, J. Osiewalksi and M. F. J. Steel (1995), Modeling and Inference with v-Spherical Distributions,
J. Amer. Stat. Assoc., 90, 1331-1340 
</p>
<p>J. P. Nolan (2016),  An R package for modeling and simulating  generalized spherical and related distributions,
J. of Statistical Distributions and Applications, 3:14, online at 
doi: <a href="https://doi.org/10.1186/s40488-016-0053-0">10.1186/s40488-016-0053-0</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfunc.new">cfunc.new</a></code>, <code><a href="#topic+gensphere">gensphere</a></code> 
</p>

<hr>
<h2 id='genspheremisc'>Miscellaneous functions used in working with generalized spherical laws
</h2><span id='topic+gs.cone'></span><span id='topic+gs.elliptical'></span><span id='topic+gs.gen.lp.norm'></span><span id='topic+gs.lp.norm'></span><span id='topic+gs.pdf2d.plot'></span><span id='topic+gs.proj.normal'></span><span id='topic+gs.vfunc.eval'></span><span id='topic+RefineSphericalTessellation'></span><span id='topic+NearbyPointsOnSphere'></span><span id='topic+RotateInNDimensions'></span><span id='topic+print.gensphere.contour'></span><span id='topic+plot.gensphere.contour'></span><span id='topic+print.gensphere.distribution'></span>

<h3>Description</h3>

<p>Miscellaneous internal functions for the gensphere package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gs.cone(x, mu, theta0)
gs.elliptical(x, B)
gs.gen.lp.norm(x, p, A)
gs.lp.norm(x,p)
gs.proj.normal(x, mu, sigma)
gs.vfunc.eval(cfunc, x)
gs.pdf2d.plot(gs.dist, xy.grid = seq(-10, 10, 0.1) )
RefineSphericalTessellation(V1, V2)
NearbyPointsOnSphere(x, epsilon)
RotateInNDimensions(x, y)
## S3 method for class 'gensphere.contour'
print(x,...)
## S3 method for class 'gensphere.distribution'
print(x,...)
## S3 method for class 'gensphere.contour'
plot(x,multiplier=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genspheremisc_+3A_x">x</code>, <code id="genspheremisc_+3A_y">y</code></td>
<td>
<p>vectors representing points in d-dimensional space
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_mu">mu</code></td>
<td>
<p>direction of the mode for a cone/normal bump
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_theta0">theta0</code></td>
<td>
<p>angle between peak of the cone and the base of the cone
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_b">B</code></td>
<td>
<p>(d x d) positive definite shape matrix
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_a">A</code></td>
<td>
<p> matrix used to compute || A x ||_p
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_p">p</code></td>
<td>
<p>power of the l^p norm; p=2 is Euclidean distance
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_gs.dist">gs.dist</code></td>
<td>
<p>object of class &quot;gensphere.distribution&quot; defined by <code>gensphere</code>
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_xy.grid">xy.grid</code></td>
<td>
<p>a matrix of (x,y) values in 2-dimensions
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_cfunc">cfunc</code></td>
<td>
<p>an object of class &quot;gensphere.contour&quot; defined by <code>cfunc.new</code>, etc.
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_...">...</code></td>
<td>
<p>optional arguments to the 2-dimensional plot, e.g. col='red', etc.
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter for a normal bump
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_epsilon">epsilon</code></td>
<td>
<p>vector of positive numbers where there are points added around a particular direction
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_v1">V1</code>, <code id="genspheremisc_+3A_v2">V2</code></td>
<td>
<p>matrices of vertices which are joined together to get a refinement of the grid
</p>
</td></tr>
<tr><td><code id="genspheremisc_+3A_multiplier">multiplier</code></td>
<td>
<p>a positive number used to scale the contour
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are undocumented functions that are used internally.  The functions 
<code>gs.cone</code>, <code>gs.elliptical</code>, <code>gs.gen.lp.norm</code>, <code>gs.lp.norm</code>, 
<code>gs.proj.normal</code>, <code>gs.vfunc.eval</code> are used in evalutating a contour function.
<code>RefineSphericalTessellation</code>, <code>NearbyPointsOnSphere</code> are used in defining 
the tessellation of the contour that identifies bumps and cones.
<code>gs.pdf2d.plot</code> and the plot/print methods are initial attempts at plotting and
printing a summary of objects. 
</p>
<p>These functions may change or disappear in the future.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
