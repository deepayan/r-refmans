<!DOCTYPE html><html><head><title>Help for package MiDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MiDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IMexpression'><p>Infectious mononucleosis transcriptome</p></a></li>
<li><a href='#IMspecimen'><p>Specimen features</p></a></li>
<li><a href='#MiBiClassGBODT'><p>Binary classification using gradient boosting over desicion trees</p></a></li>
<li><a href='#MiDataSample'><p>Select matrix columns based on values of attendant vector</p></a></li>
<li><a href='#MiFracData'><p>Subset an expression matrix based on probe's feature importance</p></a></li>
<li><a href='#MiInflCount'><p>Mean microarray probes' feature importance from binary classification</p></a></li>
<li><a href='#MiIntDepthAjust'><p>Ajust maximum depth parameter for fitting  generalized boosted regression models</p></a></li>
<li><a href='#MiNorm'><p>Microarray data normalization</p></a></li>
<li><a href='#MiNTreesAjust'><p>Ajust number of trees parameter for fitting  generalized boosted regression models</p></a></li>
<li><a href='#MiSelectSignif'><p>Select biological markers with high fold change and classification importance</p></a></li>
<li><a href='#MiShrinkAjust'><p>Ajust learning rate parameter for fitting  generalized boosted regression modelsfor fitting  generalized boosted regression models</p></a></li>
<li><a href='#MiSpecimenSample'><p>Select values from factor vector</p></a></li>
<li><a href='#MiStatCount'><p>FDR for microarray gene expression data</p></a></li>
<li><a href='#MiSummarize'><p>Microarray data summarization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Microarray Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elena Filatova &lt;filatova@nniiem.ru&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions designed to simplify transcriptome analysis and identification of marker molecules using microarrays data. The package includes a set of functions that allows performing full pipeline of analysis including data normalization, summarisation, binary classification, FDR (False Discovery Rate) multiple comparison and the definition of potential biological markers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, gbm, genefilter, graphics, limma, preprocessCore, pROC,
stats, SQN</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-18 10:03:35 UTC; MYAFF</td>
</tr>
<tr>
<td>Author:</td>
<td>Elena Filatova [aut, cre],
  Nikolai Sakharnov [dtc],
  Dmitry Knyazev [dtc],
  Oleg Utkin [dtc],
  Blokhina Scientific Research Institute of Epidemiology and Microbiology
    of Nizhny Novgorod, Russia [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-18 10:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='IMexpression'>Infectious mononucleosis transcriptome</h2><span id='topic+IMexpression'></span>

<h3>Description</h3>

<p>This is compilied numeric matrix of raw microarray intensities data. Each of 100 rows corresponds to a
probe (gene, transcript) and each of 89 column correspondes to a specimen (patient). Specimen is total mRNA
samples from human peripheral blood leukocytes' taken from healthy children and children with
infectious mononucleosis of different ethiology.
Specimen features are in <code>IMspecimen</code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IMexpression)
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 89 variables</p>


<h3>Details</h3>


<ul>
<li><p> rownames. Probes IDs. For most transcripts there are several probes.
</p>
</li>
<li><p> colnames. Specimen IDs.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolai A. Sakharnov, Dmitry I. Knyazev, Oleg V. Utkin
</p>

<hr>
<h2 id='IMspecimen'>Specimen features</h2><span id='topic+IMspecimen'></span>

<h3>Description</h3>

<p>A dataset containing information about specimens from <code>IMexpression</code> data: IDs and diagnoses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IMspecimen)
</code></pre>


<h3>Format</h3>

<p>A data frame with 89 rows and 2 variables.</p>


<h3>Details</h3>


<ul>
<li><p> ID. Specimen ID, factor variable with 89 levels.
</p>
</li>
<li><p> diagnosis. Specimen diagnosis:
&quot;ebv&quot; (children with acute EBV mononucleosis),
&quot;hhv6&quot; (children with acute HHV6 mononucleosis),
&quot;norm&quot; (healthy children). Factor variable with 3 levels.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nikolai A. Sakharnov, Dmitry I. Knyazev, Oleg V. Utkin
</p>

<hr>
<h2 id='MiBiClassGBODT'>Binary classification using gradient boosting over desicion trees</h2><span id='topic+MiBiClassGBODT'></span>

<h3>Description</h3>

<p>This function conducts a binary classification of specimens based on microarray gene (transcript) expression data.
Gradient boosting over desicion trees algorithm is used.
Several generalized boosted regression models are fitted during cross-validation, for each model
measurements of classification quality and feature importance are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiBiClassGBODT(Matrix, specimens, n.crossval = 5, ntrees = 10000,
  shrinkage = 0.1, intdepth = 2, n.terminal = 10, bag.frac = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiBiClassGBODT_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with two levels specifying specimens in the columns of the <code>Matrix</code>.</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_n.crossval">n.crossval</code></td>
<td>
<p>integer specifying number of cross-validation folds.</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_ntrees">ntrees</code></td>
<td>
<p>integer specifying the total number of decision trees (boosting iterations).</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric specifying the learning rate. Scales the step size in the gradient descent procedure.</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_intdepth">intdepth</code></td>
<td>
<p>integer specifying the maximum depth of each tree.</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_n.terminal">n.terminal</code></td>
<td>
<p>integer specifying the actual minimum number of observations in the terminal nodes of the trees.</p>
</td></tr>
<tr><td><code id="MiBiClassGBODT_+3A_bag.frac">bag.frac</code></td>
<td>
<p>the fraction of the training set observations randomly selected to propose the next tree in the expansion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Matrix</code> must contain specimens from two classification groups only. To sample expression matrix
use <code><a href="#topic+MiDataSample">MiDataSample</a></code>.
<br />
The order of the variables in <code>specimens</code> and the columns of <code>Matrix</code> must be the same. Levels of
<code>specimens</code> are two classification groups. To sample specimens use <code><a href="#topic+MiSpecimenSample">MiSpecimenSample</a></code>.
<br />
Number of cross-validation folders defines number of models to be fitted. For example,
if n.crossval=5 then all specimens are divided into 5 folders, each of them is later used for model testing,
so 5 models are fitted. See <code><a href="caret.html#topic+createFolds">createFolds</a></code> for details.
<br />
While boosting, basis functions are iteratively adding in a greedy fashion
so that each additional basis function further reduces the selected loss function.
Gaussian distribution (squared error) is used.
<code>ntrees</code>, <code>shrinkage</code>, <code>intdepth</code> are parameters for model tuning.
<code>bag.frac</code> introduces randomnesses into the model fit.
If <code>bag.frac</code> &lt; 1 then running the same model twice will result in similar but different fits.
Number of specimens in train sample must be enough to provide the minimum number of observations in terminal nodes.I.e.
<br />(1-1/<code>n.crossval</code>)*<code>bag.frac</code> &gt; <code>n.terminal</code>.
<br />
See <code><a href="gbm.html#topic+gbm">gbm</a></code> for details.
</p>


<h3>Value</h3>

<p>list of 2:
<br />
<code>QC</code> - matrix containing quality measures for each fitted model and their summary.
Accur - accuracy (percentage of correct predictions),
AUC - area under ROC curve (see <code><a href="pROC.html#topic+roc">roc</a></code>),
MCC - Mattew's correlation coefficient
<br />
formula ((TP*TN)-(FP*FN))/sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN)),
<br />
F1sc - F1 score
<br />
formula 2xPresxRec/(Pres+Rec).
<br />
If all the data points from one class are misclassified into other, MCC and F1 score may get NaN values.
<br />
<br />
<code>Importance</code> - list of data frames containing for each fitted model:
<code>var</code> - probe ID and <code>rel.inf</code> - its feature importance for classification (relative influence).
<br />
Feature importance (relative influence) graphs are also produced.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="caret.html#topic+createFolds">createFolds</a></code>, <code><a href="gbm.html#topic+gbm">gbm</a></code>, <code><a href="#topic+MiSpecimenSample">MiSpecimenSample</a></code>, <code><a href="#topic+MiDataSample">MiDataSample</a></code>,
<code><a href="pROC.html#topic+roc">roc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#get gene expression and specimen data
data("IMexpression");data("IMspecimen")
#sample expression matrix and specimen data for binary classification,
#only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running
BoostRes&lt;-MiBiClassGBODT(SampleMatrix, SampleSpecimen, n.crossval = 3,
                       ntrees = 10, shrinkage = 1, intdepth = 2)
BoostRes[[1]] # QC values for n.crossval = 3 models and its summary
length(BoostRes[[2]]) # n.crossval = 3 data frames of probes feature importance for classification
head(BoostRes[[2]][[1]])

</code></pre>

<hr>
<h2 id='MiDataSample'>Select matrix columns based on values of attendant vector</h2><span id='topic+MiDataSample'></span>

<h3>Description</h3>

<p>This function selects columns of a matrix that correspond to 1 or 2 factor levels of attendant vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiDataSample(Matrix, specimens, group1, group2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiDataSample_+3A_matrix">Matrix</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="MiDataSample_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with length equal to number of <code>Matrix</code> columns</p>
</td></tr>
<tr><td><code id="MiDataSample_+3A_group1">group1</code></td>
<td>
<p>value of factor level to sample</p>
</td></tr>
<tr><td><code id="MiDataSample_+3A_group2">group2</code></td>
<td>
<p>additional value of factor level to sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is ment for sampling specimens in  gene/transcript expression matrix for binary classification
in case when specimens belong to more than two groups. The aim is to create gene/transcript expression
matrix that contains specimens for only 1 or 2 groups.
Groups are specified in corresponding factor vector that contains specimens description.
It should be used together with <code><a href="#topic+MiSpecimenSample">MiSpecimenSample</a></code> that samples specimens'
description in the same way.
</p>


<h3>Value</h3>

<p><code>Matrix</code> with rescricted number of columns that correspond to specimens from 1 or 2 groups.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MiSpecimenSample">MiSpecimenSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#get gene expression and specimen data
data("IMexpression");data("IMspecimen")
dim(IMexpression) # 100 columns (genes/transcripts) - 89 specimens
colnames(IMexpression)[1:10] # look at first 10 columns of matrix - specimens IDs
IMspecimen[1:10,] # specimens IDs and group factor - diagnoses in attendant vector
# note that specimens in matrix columns are in the same order as specimens in description data
# select specimens with only EBV and NORM diagnoses (and sample the description data as well)
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis, "ebv", "norm")
SampleSamples&lt;-MiSpecimenSample(IMspecimen$diagnosis, "ebv", "norm")
dim(SampleMatrix)# only 68 specimens with EBV and NORM diagnoses left
colnames(SampleMatrix)[1:10]
SampleSamples[1:10] # corresponding diagnoses

</code></pre>

<hr>
<h2 id='MiFracData'>Subset an expression matrix based on probe's feature importance</h2><span id='topic+MiFracData'></span>

<h3>Description</h3>

<p>This function reduces the number of rows (probes) in gene/transcript expression matrix,
leaving only those that have the biggest feature importance for binary classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiFracData(Matrix, importance.list, NRows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiFracData_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient). Probe IDs must be indicated as matrix row names.</p>
</td></tr>
<tr><td><code id="MiFracData_+3A_importance.list">importance.list</code></td>
<td>
<p>a list of data frames, containing the result of binary classification:
probe IDs in first column and probe's feature importance (relative influence) in the second column
in the order from most important to the least important for classification.
Such list is the <code><a href="#topic+MiBiClassGBODT">MiBiClassGBODT</a></code> output (<code>Importance</code>).</p>
</td></tr>
<tr><td><code id="MiFracData_+3A_nrows">NRows</code></td>
<td>
<p>integer defines how many probes are to be left in the expression matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function provides gene expression matrix subsetting according to probe's feature importance for binary
classification, i.e., feature selection. Feature selection provides better classification and
identification of significant genes while &quot;not important&quot; genes are taken away from analysis.
The procedure of the pairwise combinations of the feature selection and classification methods are
described by Pirooznia et al (2008).
<br />
The function is able to use multiple feature importance data at a time to subset one expression matrix.
If <code>importance.list</code> contains more than one data frame (i.e., the result of a binary classification
for more than one model created during cross-validation), the function selects most important probes
from each data frame and then removes the repeats.
Thus, the output matrix may contain number of probes more than <code>NRows</code>.
</p>


<h3>Value</h3>

<p>expression matrix with only selected probes in alphabetical order as rows
and all specimens as columns.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Pirooznia M., Yang J.Y., Yang M.Q., Deng Y. (2008) A comparative study of different machine learning methods on microarray gene expression data. BMC Genomics 9 (Suppl1), S13. <a href="https://doi.org/10.1186/1471-2164-9-S1-S13">https://doi.org/10.1186/1471-2164-9-S1-S13</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MiBiClassGBODT">MiBiClassGBODT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get gene expression and specimen data
data("IMexpression");data("IMspecimen")
#sample expression matrix and specimen data for binary classification,
#only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
dim(SampleMatrix) # 100 probes
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running
ClassRes&lt;-MiBiClassGBODT(SampleMatrix, SampleSpecimen, n.crossval = 3,
                         ntrees = 10, shrinkage = 1, intdepth = 2)
# List of influence data frames for all 3 models build using cross-validation
# is the 2nd element of BiClassGBODT results
# take 10 most important probes from each model
Sample2Matrix&lt;-MiFracData(SampleMatrix, importance.list = ClassRes[[2]], 10)
dim(Sample2Matrix) # less than 100 probes left

</code></pre>

<hr>
<h2 id='MiInflCount'>Mean microarray probes' feature importance from binary classification</h2><span id='topic+MiInflCount'></span>

<h3>Description</h3>

<p>Counts mean of probes' feature importance for multiple models of binary classification built
on microarray gene/transcript expression data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiInflCount(importance.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiInflCount_+3A_importance.list">importance.list</code></td>
<td>
<p>a list of data frames, containing the result of binary classification:
probe IDs in first column and probe's feature importance (relative influence) in the second column
in the order from most important to the least important for classification.
Such list is the <code><a href="#topic+MiBiClassGBODT">MiBiClassGBODT</a></code> output (<code>Importance</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the result of binary classification performed with cross-validation
and counts mean of each probe's feature importance (relative influence) gained in all fitted models.
</p>


<h3>Value</h3>

<p>a list of 2
<br />
<code>data.mean</code> - data frame of probe names (in alphabetical order), their mean feature importance
and standard deviation.
<br />
<code>data.importance</code> - data frame of probe IDs (in alphabetical order) and their
original feature importance values gained in all cross-validation models.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MiBiClassGBODT">MiBiClassGBODT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get gene expression and specimen data
data("IMexpression");data("IMspecimen")
# sample expression matrix and specimen data for binary classification,
# only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running
ClassRes&lt;-MiBiClassGBODT(SampleMatrix, SampleSpecimen, n.crossval = 3,
                        ntrees = 10, shrinkage = 1, intdepth = 2)
# List of influence data frames for all 3 models build using cross-validation
# is the 2nd element of BiClassGBODT results
Importances&lt;-MiInflCount(ClassRes[[2]])
Importances[[1]][1:10,] # mean and sd. 0s are for low feature importance
Importances[[2]][1:10,] # original values for n.crossval = 3 models

</code></pre>

<hr>
<h2 id='MiIntDepthAjust'>Ajust maximum depth parameter for fitting  generalized boosted regression models</h2><span id='topic+MiIntDepthAjust'></span>

<h3>Description</h3>

<p>Test maximum depth parameter for microarray data binary classification using gradient boosting
over desicion trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiIntDepthAjust(Matrix, specimens, test.frac = 5, times = 5,
  ntrees = 1000, shrinkage = 0.1, intdepth = c(1:4),
  n.terminal = 10, bag.frac = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiIntDepthAjust_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with two levels specifying specimens in the columns of the <code>Matrix</code></p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_test.frac">test.frac</code></td>
<td>
<p>integer specifying fraction of data to use for model testing</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_times">times</code></td>
<td>
<p>integer specifying number of trials</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_ntrees">ntrees</code></td>
<td>
<p>integer specifying the total number of decision trees (boosting iterations).</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric specifying the learning rate. Scales the step size in the gradient descent procedure.</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_intdepth">intdepth</code></td>
<td>
<p>vector of integers specifying the maximum depth of each tree. The tested parameter.</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_n.terminal">n.terminal</code></td>
<td>
<p>integer specifying the actual minimum number of observations in the terminal nodes of the trees.</p>
</td></tr>
<tr><td><code id="MiIntDepthAjust_+3A_bag.frac">bag.frac</code></td>
<td>
<p>the fraction of the training set observations randomly selected to propose the next tree in the expansion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>test.frac</code> defines fraction of specimens that will be used for model testing. For example, if
<code>test.frac</code>=5 then 4/5th of specimens will be used for model fitting (train data) and 1/5th of specimens
will be used for model testing (test data). Specimens for test and train data will be selected by random.
So with <code>times</code>&gt;1, train and test data will differ each time.
<br />
While boosting basis functions are iteratively adding in a greedy fashion
so that each additional basis function further reduces the selected loss function.
Gaussian distribution (squared error) is used.
<code>ntrees</code>, <code>shrinkage</code>, <code>intdeep</code> are parameters for model tuning.
<code>bag.frac</code> introduces randomnesses into the model fit.
If <code>bag.frac</code> &lt; 1 then running the same model twice will result in similar but different fits.
Number of specimens in train sample must be enough to provide the minimum number of observations in terminal nodes.I.e.
<br />(1-1/<code>test.frac</code>)*<code>bag.frac</code> &gt; <code>n.terminal</code>.
<br />
See <code><a href="gbm.html#topic+gbm">gbm</a></code> for details.
<br />
Use <code><a href="#topic+MiNTreesAjust">MiNTreesAjust</a></code> and <code><a href="#topic+MiShrinkAjust">MiShrinkAjust</a></code> for ajusting other parameters.
<br />
Function is rather time-costing. If specimens are not equally distributed between two classified groups,
NA may be produced.
</p>


<h3>Value</h3>

<p>list of 2
<br />
<code>train.accuracy</code> - a data frame of train data classification accuracy
for each <code>intdepth</code> value in each trial and their median.
<br />
<code>test.accuracy</code> - a data frame of test data classification accuracy
for each <code>intdepth</code> value in each trial and their median.
<br />
Also a plot for <code>intdepth</code> versus Accuracy is produced.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="gbm.html#topic+gbm">gbm</a></code>, <code><a href="#topic+MiNTreesAjust">MiNTreesAjust</a></code>, <code><a href="#topic+MiShrinkAjust">MiShrinkAjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get gene expression and specimen data
data("IMexpression");data("IMspecimen")
#sample expression matrix and specimen data for binary classification,
#only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running. Test intdepth
set.seed(1)
ClassRes&lt;-MiIntDepthAjust(SampleMatrix, SampleSpecimen, test.frac = 5, times=3,
                          ntrees = 10, shrinkage = 1, intdepth =  c(1,2))
ClassRes[[1]] # train accuracy
ClassRes[[2]] # test accuracy

</code></pre>

<hr>
<h2 id='MiNorm'>Microarray data normalization</h2><span id='topic+MiNorm'></span>

<h3>Description</h3>

<p>Normalizes microarray expression intensities using different methods with or without background correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiNorm(Matrix, posNC, method = "none", leaveNC = TRUE, BGcor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiNorm_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of intensities data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiNorm_+3A_posnc">posNC</code></td>
<td>
<p>numeric vector specifying numbers of rows containing  negative controls (non-coding areas).
Used for <code>method="SQN"</code> only.
Rows with negative controls will be removed from an intensity matrix after the normalization if <code>leaveNC=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MiNorm_+3A_method">method</code></td>
<td>
<p>character string specifying normalization method. Possible values are:
<code>"none"</code> (no normalization)
<code>"center"</code> (subtracting the row mean),
<code>"scale"</code> (dividing by row standard deviation),
<code>"standardize"</code> (subtracting the row mean and dividing by row standard deviation - z-score transformation),
<code>"range"</code> (ranges from 0 to 1),
<code>"QN"</code> (normalization based upon quantiles),
<code>"SQN"</code> (subset quantile normalization using negative control features),
<code>"Loess"</code> (cyclicly applying loess normalization).</p>
</td></tr>
<tr><td><code id="MiNorm_+3A_leavenc">leaveNC</code></td>
<td>
<p>logical value indicating whether rows with negative control should be deleted
from intensity matrix after normalization.</p>
</td></tr>
<tr><td><code id="MiNorm_+3A_bgcor">BGcor</code></td>
<td>
<p>logical value indicating whether background correction should be done before normalization.
Could be used for background correction only (without data normalization) if <code>method="none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to normalize microarray intensities data between arrays.
Background correction is optional.
<br />
Background correction method is &quot;normexp&quot;,  which is based on a convolution model (Ritchie, 2007).
See <code>backgroundCorrect</code> for details.
<br />
Quantile normalization method implies that we can give each array the same distribution
See <code>normalize.quantiles</code> for details.
<br />
Subset quantile normalization is performed based on a subset of negative (or non-coding) controls
according to (Wu and Aryee, 2010). Number of normal distributions in the mixture approximation is 5,
weight given to the parametric normal mixture model is 0.9. See <code><a href="SQN.html#topic+SQN">SQN</a></code> for details.
<br />
Cyclic loess normalization implements method of Ballman et al (2004),
whereby each array is normalized to the average of all the arrays.
See <code>normalizeCyclicLoess</code> for details.
</p>


<h3>Value</h3>

<p>A matrix of the same dimensions as <code>Matrix</code> containing normalized values with or without
background correction. If <code>leaveNC=FALSE</code> the function returns a matrix with
normalized values without rows containing negative controls.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Ballman K.V., Grill D.E., Oberg A.L. and Therneau T.M. (2004). Faster cyclic loess: normalizing RNA arrays via linear models. Bioinformatics 20, 2778-2786.
<a href="https://doi.org/10.1093/bioinformatics/bth327">https://doi.org/10.1093/bioinformatics/bth327</a>
<br />
<br />
Bolstad B.M., Irizarry R.A., Astrand M. and Speed T.P. (2003) A Comparison of Normalization Methods for High Density Oligonucleotide Array Data Based on Bias and Variance. Bioinformatics 19(2), 185-193.
<a href="https://doi.org/10.1093/bioinformatics/19.2.185">https://doi.org/10.1093/bioinformatics/19.2.185</a>
<br />
<br />
Ritchie M.E., Silver J., Oshlack A., Silver J., Holmes M., Diyagama D., Holloway A. and Smyth G.K. (2007). A comparison of background correction methods for two-colour microarrays. Bioinformatics 23, 2700-2707.
<a href="https://doi.org/10.1093/bioinformatics/btm412">https://doi.org/10.1093/bioinformatics/btm412</a>
<br />
<br />
Wu Z and Aryee M. (2010). Subset Quantile Normalization using Negative Control Features. Journal of Computational Biology 17(10), 1385-1395.
<a href="https://doi.org/10.1089/cmb.2010.0049">https://doi.org/10.1089/cmb.2010.0049</a>
</p>


<h3>See Also</h3>

<p><code>backgroundCorrect</code>, <code>normalizeCyclicLoess</code>,
<code>normalize.quantiles</code>, <code><a href="SQN.html#topic+SQN">SQN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IMexpression")
# Loess normalization
LoMatrix&lt;-MiNorm(IMexpression, method="Loess")
par(mfrow=c(1,2))
boxplot(log2(IMexpression),main="Before normalization")
boxplot(log2(LoMatrix),main="Loess normalization")
par(mfrow=c(1,1))


</code></pre>

<hr>
<h2 id='MiNTreesAjust'>Ajust number of trees parameter for fitting  generalized boosted regression models</h2><span id='topic+MiNTreesAjust'></span>

<h3>Description</h3>

<p>Test total number of trees parameter for microarray data binary classification using gradient boosting
over desicion trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiNTreesAjust(Matrix, specimens, test.frac = 5, times = 5,
  ntrees = c(100, 500, 1000, 5000, 10000), shrinkage = 0.1,
  intdepth = 2, n.terminal = 10, bag.frac = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiNTreesAjust_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with two levels specifying specimens in the columns of the <code>Matrix</code></p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_test.frac">test.frac</code></td>
<td>
<p>integer specifying fraction of data to use for model testing</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_times">times</code></td>
<td>
<p>integer specifying number of trials</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_ntrees">ntrees</code></td>
<td>
<p>vector of integer specifying the total number of decision trees (boosting iterations).The tested parameter.</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric specifying the learning rate. Scales the step size in the gradient descent procedure.</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_intdepth">intdepth</code></td>
<td>
<p>integer specifying the maximum depth of each tree.</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_n.terminal">n.terminal</code></td>
<td>
<p>integer specifying the actual minimum number of observations in the terminal nodes of the trees.</p>
</td></tr>
<tr><td><code id="MiNTreesAjust_+3A_bag.frac">bag.frac</code></td>
<td>
<p>the fraction of the training set observations randomly selected to propose the next tree in the expansion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>test.frac</code> defines fraction of specimens that will be used for model testing. For example, if
<code>test.frac</code>=5 then 4/5th of specimens will be used for model fitting (train data) and 1/5th of specimens
will be used for model testing (test data). Specimens for test and train data will be selected by random.
So with <code>times</code>&gt;1, train and test data will differ each time.
<br />
While boosting basis functions are iteratively adding in a greedy fashion
so that each additional basis function further reduces the selected loss function.
Gaussian distribution (squared error) is used.
<code>ntrees</code>, <code>shrinkage</code>, <code>intdeep</code> are parameters for model tuning.
<code>bag.frac</code> introduces randomnesses into the model fit.
If <code>bag.frac</code> &lt; 1 then running the same model twice will result in similar but different fits.
Number of specimens in train sample must be enough to provide the minimum number of observations in terminal nodes.I.e.
<br />(1-1/<code>test.frac</code>)*<code>bag.frac</code> &gt; <code>n.terminal</code>.
<br />
See <code><a href="gbm.html#topic+gbm">gbm</a></code> for details.
<br />
Use <code><a href="#topic+MiIntDepthAjust">MiIntDepthAjust</a></code> and <code><a href="#topic+MiShrinkAjust">MiShrinkAjust</a></code> for ajusting other parameters.
<br />
Function is rather time-costing. If specimens are not equally distributed between two classified groups,
NA may be produced.
</p>


<h3>Value</h3>

<p>list of 2
<br />
<code>train.accuracy</code> - a data frame of train data classification accuracy
for each <code>ntrees</code> value in each trial and their median.
<br />
<code>test.accuracy</code> - a data frame of test data classification accuracy
for each <code>ntrees</code> value in each trial and their median.
<br />
Also a plot for <code>ntrees</code> versus Accuracy is produced.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="gbm.html#topic+gbm">gbm</a></code>, <code><a href="#topic+MiIntDepthAjust">MiIntDepthAjust</a></code>, <code><a href="#topic+MiShrinkAjust">MiShrinkAjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get gene expression and specimen data
data("IMexpression");data("IMspecimen")
#sample expression matrix and specimen data for binary classification,
#only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running. Test ntrees
set.seed(1)
ClassRes&lt;-MiNTreesAjust(SampleMatrix, SampleSpecimen, test.frac = 5, times = 3,
                       ntrees = c(10, 20), shrinkage = 1, intdepth = 2)
ClassRes[[1]] # train accuracy
ClassRes[[2]] # test accuracy


</code></pre>

<hr>
<h2 id='MiSelectSignif'>Select biological markers with high fold change and classification importance</h2><span id='topic+MiSelectSignif'></span>

<h3>Description</h3>

<p>Choose probes which change is biologically significant based on binary classification feature importance,
gene expression fold change and statistical significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiSelectSignif(probes, mean1, mean2, FC.method, infl, stat.val,
  tresh.FC = 0.75, tresh.infl = 0.75, tresh.stat = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiSelectSignif_+3A_probes">probes</code></td>
<td>
<p>character vector of probe (gene, transcript) names.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_mean1">mean1</code></td>
<td>
<p>numeric vector of mean values for probes expression in the first group of comparison.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_mean2">mean2</code></td>
<td>
<p>numeric vector of mean values for probes expression in the second group of comparison.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_fc.method">FC.method</code></td>
<td>
<p>character specifying the method of fold change counting. Possible values are:
&quot;absolute&quot; (mean1-mean2),
&quot;percent&quot; ((mean1*100/mean2)-100),
&quot;ratio&quot; (mean1/ mean2),
&quot;Log2.ratio&quot; (log2(mean1/mean2)).</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_infl">infl</code></td>
<td>
<p>numeric vector of mean values for probes feature importance (relative influence) from binary classification.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_stat.val">stat.val</code></td>
<td>
<p>numeric vector of statistical significance (p-value, q-value) for testing differences
of <code>mean1</code> and <code>mean2</code>.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_tresh.fc">tresh.FC</code></td>
<td>
<p>numeric from o to 1 specifying the tresh hold for fold change <code>FC</code> parameters (quantile).The significant
fold change is bigger than <code>tresh.FC</code>.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_tresh.infl">tresh.infl</code></td>
<td>
<p>numeric from o to 1 specifying the tresh hold for feature importance <code>infl</code> parameters (quantile).The significant
feature importance is bigger than <code>tresh.infl</code>.</p>
</td></tr>
<tr><td><code id="MiSelectSignif_+3A_tresh.stat">tresh.stat</code></td>
<td>
<p>numeric from o to 1 specifying the tresh hold for statistical significance <code>stat.val</code>.The significant
fold change is lesser than <code>tresh.stat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order must be the same for all parameters.
<br />
This function marks as &quot;markers&quot; probes that statistically significant change their expression in two
groups of comparison with high (over tresh hold) fold change and feature importance from binary classification.
</p>


<h3>Value</h3>

<p>data frame of probe names, their fold change values, statistical significance values,
feature inportance values and marker values.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probes&lt;-paste("probe", 1:50, sep="") #probes
mean1&lt;-rnorm(50, mean=0, sd=1) #means
mean2&lt;-rnorm(50, mean=5, sd=1)
infl&lt;-c(1:50) # influence
stat.val&lt;-rep(c(0.05, 0.04), c(20, 30))
Result&lt;-MiSelectSignif(probes, mean1, mean2, FC.method="absolute", infl, stat.val,
                      tresh.FC=0.75, tresh.infl=0.75, tresh.stat=0.05)
Result[1:5,]

</code></pre>

<hr>
<h2 id='MiShrinkAjust'>Ajust learning rate parameter for fitting  generalized boosted regression modelsfor fitting  generalized boosted regression models</h2><span id='topic+MiShrinkAjust'></span>

<h3>Description</h3>

<p>Test learning rate (shrinkage) parameter for microarrat data binary classification using gradient boosting
over desicion trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiShrinkAjust(Matrix, specimens, test.frac = 5, times = 5,
  ntrees = 1000, shrinkage = c(0.001, 0.01, 0.1), intdepth = 2,
  n.terminal = 10, bag.frac = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiShrinkAjust_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with two levels specifying specimens in the columns of the <code>Matrix</code></p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_test.frac">test.frac</code></td>
<td>
<p>integer specifying fraction of data to use for model testing</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_times">times</code></td>
<td>
<p>integer specifying number of trials</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_ntrees">ntrees</code></td>
<td>
<p>integer specifying the total number of decision trees (boosting iterations).</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric vector specifying the learning rate.
Scales the step size in the gradient descent procedure. The tested parameter.</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_intdepth">intdepth</code></td>
<td>
<p>vinteger specifying the maximum depth of each tree.</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_n.terminal">n.terminal</code></td>
<td>
<p>integer specifying the actual minimum number of observations in the terminal nodes of the trees.</p>
</td></tr>
<tr><td><code id="MiShrinkAjust_+3A_bag.frac">bag.frac</code></td>
<td>
<p>the fraction of the training set observations randomly selected to propose the next tree in the expansion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>test.frac</code> defines fraction of specimens that will be used for model testing. For example, if
<code>test.frac</code>=5 then 4/5th of specimens will be used for model fitting (train data) and 1/5th of specimens
will be used for model testing (test data). Specimens for test and train data will be selected by random.
So with <code>times</code>&gt;1, train and test data will differ each time.
<br />
While boosting basis functions are iteratively adding in a greedy fashion
so that each additional basis function further reduces the selected loss function.
Gaussian distribution (squared error) is used.
<code>ntrees</code>, <code>shrinkage</code>, <code>intdeep</code> are parameters for model tuning.
<code>bag.frac</code> introduces randomnesses into the model fit.
If <code>bag.frac</code> &lt; 1 then running the same model twice will result in similar but different fits.
Number of specimens in train sample must be enough to provide the minimum number of observations in terminal nodes.I.e.
<br />(1-1/<code>test.frac</code>)*<code>bag.frac</code> &gt; <code>n.terminal</code>.
<br />
See <code><a href="gbm.html#topic+gbm">gbm</a></code> for details.
<br />
Use <code><a href="#topic+MiIntDepthAjust">MiIntDepthAjust</a></code> and <code><a href="#topic+MiNTreesAjust">MiNTreesAjust</a></code> for ajusting other parameters.
<br />
Function is rather time-costing. If specimens are not equally distributed between two classified groups,
NA may be produced.
</p>


<h3>Value</h3>

<p>list of 2
<br />
<code>train.accuracy</code> - a data frame of train data classification accuracy
for each <code>shrinkage</code> value in each trial and their median.
<br />
<code>test.accuracy</code> - a data frame of test data classification accuracy
for each <code>shrinkage</code> value in each trial and their median.
<br />
Also a plot for <code>shrinkage</code> versus Accuracy is produced.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="gbm.html#topic+gbm">gbm</a></code>, <code><a href="#topic+MiIntDepthAjust">MiIntDepthAjust</a></code>, <code><a href="#topic+MiNTreesAjust">MiNTreesAjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IMexpression");data("IMspecimen")
#sample expression matrix and specimen data for binary classification,
#only "NORM" and "EBV" specimens are left
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"norm", "ebv")
SampleSpecimen&lt;-MiSpecimenSample(IMspecimen$diagnosis, "norm", "ebv")
#Fitting, low tuning for faster running. Test shrinkage
set.seed(1)
ClassRes&lt;-MiShrinkAjust(SampleMatrix, SampleSpecimen, test.frac = 5, times = 3,
                        ntrees = 10, shrinkage = c(0.1, 1), intdepth = 2)
ClassRes[[1]] # train accuracy
ClassRes[[2]] # test accuracy

</code></pre>

<hr>
<h2 id='MiSpecimenSample'>Select values from factor vector</h2><span id='topic+MiSpecimenSample'></span>

<h3>Description</h3>

<p>This function takes factor vector with multiple levels and selects values for 1 or 2 levels only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiSpecimenSample(x, group1, group2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiSpecimenSample_+3A_x">x</code></td>
<td>
<p>factor vector</p>
</td></tr>
<tr><td><code id="MiSpecimenSample_+3A_group1">group1</code></td>
<td>
<p>value of factor level to sample</p>
</td></tr>
<tr><td><code id="MiSpecimenSample_+3A_group2">group2</code></td>
<td>
<p>additional value of factor level to sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is ment for sampling specimens for binary classification when they belong to more
than two groups. The aim is to create factor vector with only two levels specifying specimens
in the columns of corresponding microarray expression matrix.
It should be used together with <code><a href="#topic+MiDataSample">MiDataSample</a></code> that samples columns of microarray
expression matrix in the same way.
</p>


<h3>Value</h3>

<p>factor vector with values for 1 or 2 levels only
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MiDataSample">MiDataSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#get gene expression and specimen data
data("IMexpression");data("IMspecimen")
dim(IMexpression) # 100 columns (genes/transcripts) - 89 specimens
colnames(IMexpression)[1:10] # look at first 10 columns of matrix - specimens IDs
IMspecimen[1:10,] # specimens IDs and group factor - diagnoses in attendant vector
# note that specimens in matrix columns are in the same order as specimens in description data
# select specimens with only EBV and NORM diagnoses (and sample the description data as well)
SampleMatrix&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis, "ebv", "norm")
SampleSamples&lt;-MiSpecimenSample(IMspecimen$diagnosis, "ebv", "norm")
dim(SampleMatrix)# only 68 specimens with EBV and NORM diagnoses left
colnames(SampleMatrix)[1:10]
SampleSamples[1:10] # corresponding diagnoses

</code></pre>

<hr>
<h2 id='MiStatCount'>FDR for microarray gene expression data</h2><span id='topic+MiStatCount'></span>

<h3>Description</h3>

<p>Performs descriptive statistics and FDR (False Discovery Rate) test for microarray expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiStatCount(Matrix, specimens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiStatCount_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of expression data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).</p>
</td></tr>
<tr><td><code id="MiStatCount_+3A_specimens">specimens</code></td>
<td>
<p>factor vector with two levels specifying specimens in the columns of the <code>Matrix</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes matrix of expression data and performs T-test with FDR correction for two groups
for each probe.
<br />
T-test is a two-sided, two-class with equal variances against the null hypothesis 'mean1=mean2' for each row.
See <code>rowttests</code> for details.
</p>


<h3>Value</h3>

<p>a data frame containing for each probe: mean and sd values for both groups, difference of means,
p-value for T-test and q-value for FDR (False Discovery Rate) correction.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>References</h3>

<p>Welch B.L.(1951) On the comparison of several mean values: an alternative approach. Biometrika 38, 330-336.
<a href="https://doi.org/10.1093/biomet/38.3-4.330">https://doi.org/10.1093/biomet/38.3-4.330</a>
</p>


<h3>See Also</h3>

<p><code>rowttests</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IMexpression"); data("IMspecimen") # load data and specimen information
#sampling data and specimen information
ExpData&lt;-MiDataSample(IMexpression, IMspecimen$diagnosis,"ebv", "norm")
Specimens&lt;-MiSpecimenSample(IMspecimen$diagnosis, "ebv", "norm")
#Counting statistics
StatRes&lt;-MiStatCount(ExpData, Specimens)
head(StatRes)

</code></pre>

<hr>
<h2 id='MiSummarize'>Microarray data summarization</h2><span id='topic+MiSummarize'></span>

<h3>Description</h3>

<p>Counts median of intensities for multiple probes that target one gene/transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MiSummarize(Matrix, sep, method = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MiSummarize_+3A_matrix">Matrix</code></td>
<td>
<p>numeric matrix of intensities data where each row corresponds to a probe (gene, transcript),
and each column correspondes to a specimen (patient).
Row names of <code>Matrix</code> should contain probe IDs that consist of three terms:
gene name - transcript name - probe name.</p>
</td></tr>
<tr><td><code id="MiSummarize_+3A_sep">sep</code></td>
<td>
<p>a character string to separate the terms in probe IDs.</p>
</td></tr>
<tr><td><code id="MiSummarize_+3A_method">method</code></td>
<td>
<p>character string specifying summarization method. Possible values are &quot;median&quot; and &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for summarizing expression intensities data when multiple probes target
one gene/transcript. Row names of <code>Matrix</code> should contain probe IDs that consist of 3 terms:
&quot;Gene name - sep - transcript name - sep - probe name&quot; (for example, &quot;AGTR2.ALL&quot; - for gene, only one probe;
&quot;AGTR2.NM_000686.z1&quot; - 1st probe to AGTR2 NM_000686 mRNA transcript).
</p>


<h3>Value</h3>

<p>gene/transcript expression matrix with median/mean of expression intensities for each gene/transcript.
</p>


<h3>Author(s)</h3>

<p>Elena N. Filatova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IMexpression") # load data
# See 5 zonds to AGTR2.NM_000686
IMexpression [1:10, 1:5]
SumMatrix&lt;-MiSummarize(IMexpression, sep=".")
# now there is median expression for AGTR2.NM_000686
SumMatrix[ 1:10, 1:5]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
