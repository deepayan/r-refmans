<!DOCTYPE html><html lang="en"><head><title>Help for package AnimalSequences</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AnimalSequences}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#association_metrics'><p>Calculate Association Metrics for Sequences</p></a></li>
<li><a href='#average_seq_length'><p>Calculate the Average Length of Sequences</p></a></li>
<li><a href='#calculate_conditional_entropy'><p>Calculate Conditional Entropy of B given A in Bits</p></a></li>
<li><a href='#calculate_distance_matrix'><p>Calculate Distance Matrix from Co-occurrence Matrix</p></a></li>
<li><a href='#calculate_transition_counts'><p>Calculate Transition Counts from Sequences</p></a></li>
<li><a href='#calculate_transition_probs'><p>Calculate Transition Probabilities from Sequences</p></a></li>
<li><a href='#cluster_elements'><p>Cluster Elements Using Hierarchical Clustering</p></a></li>
<li><a href='#compare_distinct_elements_per_list_item'><p>Compare True and Shuffled Distinct Elements per List Item</p></a></li>
<li><a href='#cooccurrence_matrix'><p>Calculate Co-occurrence Matrix for Sequences</p></a></li>
<li><a href='#count_distinct_elements'><p>Count Distinct Elements in Sequences</p></a></li>
<li><a href='#count_distinct_elements_per_list_item'><p>Count Distinct Elements per List Item</p></a></li>
<li><a href='#count_distinct_elements_per_list_item_shuffled'><p>Count Distinct Elements per List Item in Shuffled Sequences</p></a></li>
<li><a href='#element_covariate'><p>Calculate Element-Covariate Conditional Probabilities</p></a></li>
<li><a href='#element_covariate_network'><p>Plot the network of elements and covariates based on the long format of sequences</p></a></li>
<li><a href='#element_duration'><p>Calculate Individual Element Durations</p></a></li>
<li><a href='#element_position'><p>Calculate Median Position of Each Element in Sequences</p></a></li>
<li><a href='#find_most_similar_columns'><p>Find Most Similar Columns in a Distance Matrix</p></a></li>
<li><a href='#generate_sequence'><p>Generate a Sequence of Elements</p></a></li>
<li><a href='#long_to_sequences'><p>Convert Long Format to Sequences</p></a></li>
<li><a href='#median_seq_length'><p>Calculate the Median Length of Sequences</p></a></li>
<li><a href='#menzerath_plot'><p>Create a Menzerath-Altmann Plot</p></a></li>
<li><a href='#min_max_seq_length'><p>Calculate the Minimum and Maximum Length of Sequences</p></a></li>
<li><a href='#perform_clustering'><p>Perform Various Clustering Methods</p></a></li>
<li><a href='#plot_seq_length_distribution'><p>Plot the Distribution of Sequence Lengths</p></a></li>
<li><a href='#redundancy'><p>Calculate Observed and Expected Redundancy of Sequences</p></a></li>
<li><a href='#sd_seq_length'><p>Calculate the Standard Deviation of Sequence Lengths</p></a></li>
<li><a href='#sequence_duration_summary'><p>Summarize Sequence Durations</p></a></li>
<li><a href='#sequence_length_summary'><p>Summarize Sequence Lengths</p></a></li>
<li><a href='#sequence_length_summary_covariate'><p>Summarize Sequence Lengths by Covariate</p></a></li>
<li><a href='#sequence_length_summary_element'><p>Summarize Sequence Lengths by Element</p></a></li>
<li><a href='#sequences_to_long'><p>Convert Sequences to Long Format</p></a></li>
<li><a href='#shuffle_sequences_across'><p>Shuffle Elements Across All Sequences</p></a></li>
<li><a href='#shuffle_sequences_within'><p>Shuffle Elements Within Each Sequence</p></a></li>
<li><a href='#temporal_overlap'><p>Temporal Overlap</p></a></li>
<li><a href='#transition_chisq'><p>Perform a Chi-Squared Test for Transition Counts</p></a></li>
<li><a href='#transition_entropy'><p>Calculate Transition Entropy for Sequences</p></a></li>
<li><a href='#transition_predictions'><p>Transition Predictions</p></a></li>
<li><a href='#transition_test'><p>Perform a Statistical Test for Transition Probabilities</p></a></li>
<li><a href='#zipf_plot'><p>Create a Zipf's Law Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyse Animal Sequential Behaviour and Communication</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>All animal behaviour occurs sequentially. The package has a number of functions to format sequence data from different sources, to analyse sequential behaviour and communication in animals. It also has functions to plot the data and to calculate the entropy of sequences.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, dplyr, tidytext, ggplot2, fpc, mclust, kernlab,
dbscan, apcluster, tidyr, tibble, stats, rlang, igraph, ggraph,
magrittr, naivebayes, ranger</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-20 15:07:29 UTC; Alexander</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Mielke [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Mielke &lt;a.mielke@qmul.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 13:02:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='association_metrics'>Calculate Association Metrics for Sequences</h2><span id='topic+association_metrics'></span>

<h3>Description</h3>

<p>This function calculates various association metrics for elements in a sequence,
such as Pointwise Mutual Information (PMI), normalized PMI, attraction, reliance,
Delta P, z-score, t-score, Chi-squared, Jaccard coefficient, Dice coefficient,
log odds ratio, and geometric mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>association_metrics(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="association_metrics_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences to analyze.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the calculated association metrics for each dyad (pair of elements).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences &lt;- c("A B C", "A B", "A C", "B C", "A B C D")
result &lt;- association_metrics(sequences)
print(result)
</code></pre>

<hr>
<h2 id='average_seq_length'>Calculate the Average Length of Sequences</h2><span id='topic+average_seq_length'></span>

<h3>Description</h3>

<p>This function calculates the average length of a sequence of elements, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_seq_length(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average_seq_length_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the average length of the sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
average_seq_length(sequences)
</code></pre>

<hr>
<h2 id='calculate_conditional_entropy'>Calculate Conditional Entropy of B given A in Bits</h2><span id='topic+calculate_conditional_entropy'></span>

<h3>Description</h3>

<p>This function calculates the conditional entropy of B given A in bits between two categorical vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_conditional_entropy(vectorA, vectorB)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_conditional_entropy_+3A_vectora">vectorA</code></td>
<td>
<p>A categorical vector representing the conditioning variable A</p>
</td></tr>
<tr><td><code id="calculate_conditional_entropy_+3A_vectorb">vectorB</code></td>
<td>
<p>A categorical vector representing the conditioned variable B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The conditional entropy of B given A in bits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vectorA &lt;- c("A", "B", "A", "A", "B", "C", "C", "C", "A", "B")
vectorB &lt;- c("X", "Y", "X", "Y", "X", "Y", "Y", "X", "X", "Y")
calculate_conditional_entropy(vectorA, vectorB)
</code></pre>

<hr>
<h2 id='calculate_distance_matrix'>Calculate Distance Matrix from Co-occurrence Matrix</h2><span id='topic+calculate_distance_matrix'></span>

<h3>Description</h3>

<p>This function calculates a distance matrix from a given co-occurrence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_distance_matrix(cooccurrence_matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_distance_matrix_+3A_cooccurrence_matrix">cooccurrence_matrix</code></td>
<td>
<p>A matrix representing the co-occurrence counts of elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix computed from the normalized co-occurrence matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
cooccurrence_matrix &lt;- matrix(c(3, 2, 1, 2, 5, 0, 1, 0, 4), nrow = 3, byrow = TRUE)
result &lt;- calculate_distance_matrix(cooccurrence_matrix)
print(result)
</code></pre>

<hr>
<h2 id='calculate_transition_counts'>Calculate Transition Counts from Sequences</h2><span id='topic+calculate_transition_counts'></span>

<h3>Description</h3>

<p>This function calculates the transition counts between elements in a set of sequences. It creates a matrix where each element represents the number of times a transition occurs from one element to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_transition_counts(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_transition_counts_+3A_sequences">sequences</code></td>
<td>
<p>A vector of character strings, where each string represents a sequence of elements separated by spaces. Elements should be labeled with prefixes (e.g., &quot;e1&quot;, &quot;e2&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that elements in the sequences are labeled with prefixes (e.g., &quot;e1&quot;, &quot;e2&quot;), which are stripped to extract the integer labels for counting. The matrix is initialized to be of size <code>num_elements x num_elements</code>, where <code>num_elements</code> should be defined in your script or session. Ensure that <code>num_elements</code> is set to the correct number of unique elements before running this function.
</p>


<h3>Value</h3>

<p>A matrix where the entry at <code>[i, j]</code> represents the number of times an element labeled <code>i</code> is followed by an element labeled <code>j</code> across all sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c("e1 e2 e3", "e2 e3 e1", "e1 e3")
num_elements &lt;- 3
calculate_transition_counts(sequences)
</code></pre>

<hr>
<h2 id='calculate_transition_probs'>Calculate Transition Probabilities from Sequences</h2><span id='topic+calculate_transition_probs'></span>

<h3>Description</h3>

<p>This function calculates the transition probabilities between elements in a set of sequences. It computes the probability of transitioning from one element to another based on the frequency of transitions observed in the input sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_transition_probs(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_transition_probs_+3A_sequences">sequences</code></td>
<td>
<p>A vector of character strings, where each string represents a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the 'unnest_tokens' function from the 'tidytext' package to split sequences into individual elements. It then calculates transition counts and probabilities for each pair of consecutive elements in the sequences. The resulting data frame shows the transition probabilities for each possible element pair.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>previous_element</code></td>
<td>
<p>The element that transitions to the next element.</p>
</td></tr>
<tr><td><code>element</code></td>
<td>
<p>The element that follows the previous element.</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>The number of times the transition from the previous element to the current element occurs.</p>
</td></tr>
<tr><td><code>probability</code></td>
<td>
<p>The probability of transitioning from the previous element to the current element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(tidytext)
sequences &lt;- c("A B C", "A B", "B C A")
calculate_transition_probs(sequences)
</code></pre>

<hr>
<h2 id='cluster_elements'>Cluster Elements Using Hierarchical Clustering</h2><span id='topic+cluster_elements'></span>

<h3>Description</h3>

<p>This function performs hierarchical clustering on a distance matrix and optionally plots the dendrogram. It uses the specified method for clustering and can visualize the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_elements(distance_matrix, method = "complete", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_elements_+3A_distance_matrix">distance_matrix</code></td>
<td>
<p>A matrix of distances between elements. Should be a symmetric matrix with row and column names representing elements.</p>
</td></tr>
<tr><td><code id="cluster_elements_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for hierarchical clustering. Options include &quot;complete&quot;, &quot;average&quot;, &quot;single&quot;, etc. Default is &quot;complete&quot;.</p>
</td></tr>
<tr><td><code id="cluster_elements_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether to plot the dendrogram. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hierarchical clustering is performed using the specified method. If <code>plot</code> is TRUE, the function will generate a dendrogram to visualize the clustering.
</p>


<h3>Value</h3>

<p>An object of class <code>"hclust"</code> representing the hierarchical clustering result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a distance matrix
distance_matrix &lt;- dist(matrix(rnorm(20), nrow = 5))

# Perform hierarchical clustering and plot the dendrogram
cluster_elements(distance_matrix, method = "complete", plot = TRUE)

</code></pre>

<hr>
<h2 id='compare_distinct_elements_per_list_item'>Compare True and Shuffled Distinct Elements per List Item</h2><span id='topic+compare_distinct_elements_per_list_item'></span>

<h3>Description</h3>

<p>This function compares the true number of distinct elements per list item in a list of sequences to the number of distinct elements per list item in shuffled sequences. The comparison is done by calculating p-values from shuffled sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_distinct_elements_per_list_item(sequences, iterations = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_distinct_elements_per_list_item_+3A_sequences">sequences</code></td>
<td>
<p>A list of character vectors, where each vector contains sequences of elements separated by spaces.</p>
</td></tr>
<tr><td><code id="compare_distinct_elements_per_list_item_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the number of shuffling iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>true_distinct_elements</code></td>
<td>
<p>The number of distinct elements per list item in the original sequences.</p>
</td></tr>
<tr><td><code>shuffled_distinct_elements</code></td>
<td>
<p>The average number of distinct elements per list item in shuffled sequences.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>The p-value representing the proportion of shuffled sequences where the number of distinct elements is less than or equal to the true number.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world', 'hello world')
compare_distinct_elements_per_list_item(sequences, iterations = 100)
</code></pre>

<hr>
<h2 id='cooccurrence_matrix'>Calculate Co-occurrence Matrix for Sequences</h2><span id='topic+cooccurrence_matrix'></span>

<h3>Description</h3>

<p>This function calculates a co-occurrence matrix for elements in sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cooccurrence_matrix(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cooccurrence_matrix_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences to analyze.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the co-occurrence counts of elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences &lt;- c("e1 e2 e3", "e2 e3 e4", "e1 e4", "e1 e2 e4")
result &lt;- cooccurrence_matrix(sequences)
print(result)
</code></pre>

<hr>
<h2 id='count_distinct_elements'>Count Distinct Elements in Sequences</h2><span id='topic+count_distinct_elements'></span>

<h3>Description</h3>

<p>This function counts the number of distinct elements across all sequences, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_distinct_elements(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_distinct_elements_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer representing the number of distinct elements across all sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
count_distinct_elements(sequences)
</code></pre>

<hr>
<h2 id='count_distinct_elements_per_list_item'>Count Distinct Elements per List Item</h2><span id='topic+count_distinct_elements_per_list_item'></span>

<h3>Description</h3>

<p>This function calculates the average number of distinct elements per item in a list of sequences, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_distinct_elements_per_list_item(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_distinct_elements_per_list_item_+3A_sequences">sequences</code></td>
<td>
<p>A list of character vectors, where each vector contains sequences of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the average number of distinct elements per list item.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
count_distinct_elements_per_list_item(sequences)
</code></pre>

<hr>
<h2 id='count_distinct_elements_per_list_item_shuffled'>Count Distinct Elements per List Item in Shuffled Sequences</h2><span id='topic+count_distinct_elements_per_list_item_shuffled'></span>

<h3>Description</h3>

<p>This function calculates the number of distinct elements per list item in a list of sequences shuffled using the 'shuffle_sequences_across' function. The shuffling is performed a specified number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_distinct_elements_per_list_item_shuffled(sequences, iterations = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_distinct_elements_per_list_item_shuffled_+3A_sequences">sequences</code></td>
<td>
<p>A list of character vectors, where each vector contains sequences of elements separated by spaces.</p>
</td></tr>
<tr><td><code id="count_distinct_elements_per_list_item_shuffled_+3A_iterations">iterations</code></td>
<td>
<p>An integer specifying the number of shuffling iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 'iterations', each element representing the number of distinct elements per list item in a shuffled sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
count_distinct_elements_per_list_item_shuffled(sequences, iterations = 100)
</code></pre>

<hr>
<h2 id='element_covariate'>Calculate Element-Covariate Conditional Probabilities</h2><span id='topic+element_covariate'></span>

<h3>Description</h3>

<p>This function calculates the conditional probability of each element given each covariate and
performs permutation tests to compute the expected conditional probabilities and p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_covariate(
  sequences_long,
  element = "element",
  covariate = "covariate",
  n_permutations = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_covariate_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame containing the sequences, with columns for elements and covariates.</p>
</td></tr>
<tr><td><code id="element_covariate_+3A_element">element</code></td>
<td>
<p>A string specifying the column name for elements in the sequences data frame.</p>
</td></tr>
<tr><td><code id="element_covariate_+3A_covariate">covariate</code></td>
<td>
<p>A string specifying the column name for covariates in the sequences data frame.</p>
</td></tr>
<tr><td><code id="element_covariate_+3A_n_permutations">n_permutations</code></td>
<td>
<p>An integer specifying the number of permutations for the bootstrapping process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the calculated probabilities, expected probabilities, and p-values for each element-covariate pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences_long &lt;- data.frame(
  element = rep(letters[1:3], each = 4),
  covariate = rep(letters[4:7], times = 3)
)
result &lt;- element_covariate(sequences_long,
                            element = 'element',
                            covariate = 'covariate',
                            n_permutations = 50)
print(result)
</code></pre>

<hr>
<h2 id='element_covariate_network'>Plot the network of elements and covariates based on the long format of sequences</h2><span id='topic+element_covariate_network'></span>

<h3>Description</h3>

<p>Plot the network of elements and covariates based on the long format of sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_covariate_network(
  sequences_long,
  cutoff = 3,
  element,
  covariate,
  n_permutations = 1000,
  pvalue = 0.01,
  clusters = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_covariate_network_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame containing the sequences, with columns for elements and contexts.</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_cutoff">cutoff</code></td>
<td>
<p>minimum number of occurrences for which element or covariate should be included</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_element">element</code></td>
<td>
<p>A string specifying the column name for elements in the sequences data frame.</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_covariate">covariate</code></td>
<td>
<p>A string specifying the column name for contexts in the sequences data frame.</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_n_permutations">n_permutations</code></td>
<td>
<p>An integer specifying the number of permutations for the bootstrapping process.</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_pvalue">pvalue</code></td>
<td>
<p>cutoff pvalue to include combination</p>
</td></tr>
<tr><td><code id="element_covariate_network_+3A_clusters">clusters</code></td>
<td>
<p>should clusters be calculated and added?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of bimodal network containing the elements and covariates
</p>

<hr>
<h2 id='element_duration'>Calculate Individual Element Durations</h2><span id='topic+element_duration'></span>

<h3>Description</h3>

<p>This function calculates the individual element durations and compares them to a shuffled distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_duration(sequences_long, n_permutations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_duration_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame containing sequences with start and end times for each element.</p>
</td></tr>
<tr><td><code id="element_duration_+3A_n_permutations">n_permutations</code></td>
<td>
<p>An integer specifying the number of permutations to perform. Default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the median duration, standard deviation, expected duration, effect size, and p-value for each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences_long &lt;- data.frame(
  element = c("A", "B", "C", "A", "B", "C"),
  start_time = c(0, 5, 10, 15, 20, 25),
  end_time = c(5, 10, 15, 20, 25, 30)
)
result &lt;- element_duration(sequences_long, n_permutations = 100)
print(result)
</code></pre>

<hr>
<h2 id='element_position'>Calculate Median Position of Each Element in Sequences</h2><span id='topic+element_position'></span>

<h3>Description</h3>

<p>This function calculates the median position of each element across sequences,
summarizes the distribution, and compares it to a shuffled distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_position(sequences, n_permutations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_position_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences to analyze.</p>
</td></tr>
<tr><td><code id="element_position_+3A_n_permutations">n_permutations</code></td>
<td>
<p>The number of permutations to use for the null distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the median position, standard deviation, expected position, effect size, and p-value for each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences &lt;- c("A B C", "A B", "A C", "B C", "A B C D")
result &lt;- element_position(sequences)
print(result)
</code></pre>

<hr>
<h2 id='find_most_similar_columns'>Find Most Similar Columns in a Distance Matrix</h2><span id='topic+find_most_similar_columns'></span>

<h3>Description</h3>

<p>This function identifies the most similar columns for each column in a distance matrix. For each column, it finds the columns with the smallest distances (i.e., most similar) based on the given number of similar columns to retrieve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_most_similar_columns(distance_matrix, n_similar = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_most_similar_columns_+3A_distance_matrix">distance_matrix</code></td>
<td>
<p>A numeric matrix where the distance between columns is represented. The rows and columns should correspond to the same set of entities.</p>
</td></tr>
<tr><td><code id="find_most_similar_columns_+3A_n_similar">n_similar</code></td>
<td>
<p>An integer specifying the number of most similar columns to find for each column. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors. Each element of the list corresponds to a column in the distance matrix and contains the column names of the most similar columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample distance matrix
distance_matrix &lt;- matrix(c(0, 1, 2, 1, 0, 3, 2, 3, 0),
                          nrow = 3,
                          dimnames = list(NULL, c("A", "B", "C")))

# Find the 2 most similar columns for each column
find_most_similar_columns(distance_matrix, n_similar = 2)
</code></pre>

<hr>
<h2 id='generate_sequence'>Generate a Sequence of Elements</h2><span id='topic+generate_sequence'></span>

<h3>Description</h3>

<p>This function generates a sequence of elements based on a given length function, a transition matrix, and probabilities for the first element. The sequence is generated by sampling from the transition matrix and then combining the sampled elements into a single sequence string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sequence(length_func, transition_matrix, first_element_probs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_sequence_+3A_length_func">length_func</code></td>
<td>
<p>A function that generates a numeric value representing the length of the sequence. It is typically a random function that defines the length distribution of the sequence.</p>
</td></tr>
<tr><td><code id="generate_sequence_+3A_transition_matrix">transition_matrix</code></td>
<td>
<p>A matrix representing the transition probabilities between elements. Each entry in the matrix indicates the probability of transitioning from one element to another.</p>
</td></tr>
<tr><td><code id="generate_sequence_+3A_first_element_probs">first_element_probs</code></td>
<td>
<p>A numeric vector of probabilities for selecting the first element in the sequence. The length of the vector should match the number of possible elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the generated sequence. The sequence elements are prefixed with &quot;e&quot; and separated by spaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define parameters
num_elements &lt;- 3
average_sequence_length &lt;- 5
sequence_length_sd &lt;- 1
length_func &lt;- function() {
  rnorm(1, mean = average_sequence_length, sd = sequence_length_sd)
}
transition_matrix &lt;- matrix(c(0.1, 0.6, 0.3,
                               0.2, 0.5, 0.3,
                               0.3, 0.3, 0.4), nrow = 3, byrow = TRUE)
first_element_probs &lt;- c(0.3, 0.4, 0.3)

# Generate a sequence
generate_sequence(length_func, transition_matrix, first_element_probs)

</code></pre>

<hr>
<h2 id='long_to_sequences'>Convert Long Format to Sequences</h2><span id='topic+long_to_sequences'></span>

<h3>Description</h3>

<p>This function converts a data frame in long format into sequences by combining all rows with the same sequence identifier. It also aggregates covariates if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_to_sequences(
  sequences_long,
  elements = "element",
  sequence_identifier = "sequence_identifier",
  start_time = "start_time",
  end_time = "end_time",
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="long_to_sequences_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame in long format containing the sequences.</p>
</td></tr>
<tr><td><code id="long_to_sequences_+3A_elements">elements</code></td>
<td>
<p>Column name for elements that should be combined into sequences.</p>
</td></tr>
<tr><td><code id="long_to_sequences_+3A_sequence_identifier">sequence_identifier</code></td>
<td>
<p>Column name with the sequence identifier.</p>
</td></tr>
<tr><td><code id="long_to_sequences_+3A_start_time">start_time</code></td>
<td>
<p>Column name with the start time.</p>
</td></tr>
<tr><td><code id="long_to_sequences_+3A_end_time">end_time</code></td>
<td>
<p>Column name with the end time.</p>
</td></tr>
<tr><td><code id="long_to_sequences_+3A_covariates">covariates</code></td>
<td>
<p>A vector with column names of the covariates. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with sequences, start time, end time, and aggregated covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences_long &lt;- data.frame(sequence_identifier = c(1, 1, 2, 2, 2),
                             element = c('A', 'B', 'A', 'B', 'C'),
                             start_time = c(1, 2, 1, 2, 3),
                             end_time = c(2, 3, 2, 3, 4),
                             covariate1 = c('X', 'Y', 'X', 'Y', 'Z'),
                             covariate2 = c('M', 'N', 'M', 'N', 'O'))
long_to_sequences(sequences_long,
                  elements = 'element',
                  sequence_identifier = 'sequence_identifier',
                  start_time = 'start_time',
                  covariates = c('covariate1', 'covariate2'))
</code></pre>

<hr>
<h2 id='median_seq_length'>Calculate the Median Length of Sequences</h2><span id='topic+median_seq_length'></span>

<h3>Description</h3>

<p>This function calculates the median length of a sequence of elements, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_seq_length(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median_seq_length_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the median length of the sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
median_seq_length(sequences)
</code></pre>

<hr>
<h2 id='menzerath_plot'>Create a Menzerath-Altmann Plot</h2><span id='topic+menzerath_plot'></span>

<h3>Description</h3>

<p>This function generates a Menzerath-Altmann plot from a data frame in long format. The plot visualizes the relationship between the number of elements in sequences and the mean duration of these sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menzerath_plot(sequences_long)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="menzerath_plot_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame in long format. It should include columns for 'sequence_nr', 'start_time', and 'end_time'. Each row represents an element in the sequence with its start and end times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the duration of each element as the difference between 'end_time' and 'start_time'. It then groups the data by 'sequence_nr' to compute the number of elements and the mean duration of each sequence. The resulting plot helps in understanding the relationship described by the Menzerath-Altmann law, which postulates that larger linguistic units tend to have shorter mean durations.
</p>


<h3>Value</h3>

<p>A 'ggplot' object. The plot shows the number of elements (x-axis) against the mean duration of sequences (y-axis) with a linear regression line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data frame
sequences_long &lt;- data.frame(
  sequence_nr = rep(1:5, each = 3),
  start_time = rep(1:3, times = 5),
  end_time = rep(2:4, times = 5)
)
menzerath_plot(sequences_long)
</code></pre>

<hr>
<h2 id='min_max_seq_length'>Calculate the Minimum and Maximum Length of Sequences</h2><span id='topic+min_max_seq_length'></span>

<h3>Description</h3>

<p>This function calculates the minimum and maximum length of sequences of elements, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_max_seq_length(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_max_seq_length_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2, with the minimum and maximum lengths of the sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
min_max_seq_length(sequences)
</code></pre>

<hr>
<h2 id='perform_clustering'>Perform Various Clustering Methods</h2><span id='topic+perform_clustering'></span>

<h3>Description</h3>

<p>This function performs multiple clustering methods on the input data and returns the results. The methods include K-means, hierarchical clustering, DBSCAN, Gaussian Mixture Model (GMM), spectral clustering, and affinity propagation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform_clustering(data, n_clusters = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perform_clustering_+3A_data">data</code></td>
<td>
<p>A numeric matrix or data frame where rows represent observations and columns represent features.</p>
</td></tr>
<tr><td><code id="perform_clustering_+3A_n_clusters">n_clusters</code></td>
<td>
<p>An integer specifying the number of clusters for methods that require it (e.g., K-means, hierarchical clustering). Default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- **K-means**: Performs K-means clustering with the specified number of clusters.
- **Hierarchical clustering**: Performs hierarchical clustering and cuts the dendrogram to create the specified number of clusters.
- **DBSCAN**: Applies DBSCAN clustering with predefined parameters.
- **Gaussian Mixture Model (GMM)**: Uses the Mclust package to perform GMM clustering.
- **Spectral clustering**: Uses the kernlab package to perform spectral clustering with a kernel matrix.
- **Affinity propagation**: Uses the apcluster package to perform affinity propagation clustering.
</p>


<h3>Value</h3>

<p>A list with clustering results for each method:
</p>
<table role = "presentation">
<tr><td><code>kmeans</code></td>
<td>
<p>A list containing the results of K-means clustering, including cluster assignments.</p>
</td></tr>
<tr><td><code>hierarchical</code></td>
<td>
<p>A vector of cluster assignments from hierarchical clustering.</p>
</td></tr>
<tr><td><code>dbscan</code></td>
<td>
<p>A vector of cluster assignments from DBSCAN.</p>
</td></tr>
<tr><td><code>gmm</code></td>
<td>
<p>A vector of cluster assignments from Gaussian Mixture Model (GMM).</p>
</td></tr>
<tr><td><code>spectral</code></td>
<td>
<p>A vector of cluster assignments from spectral clustering.</p>
</td></tr>
<tr><td><code>affinity_propagation</code></td>
<td>
<p>A list of clusters from affinity propagation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate sample data
data &lt;- matrix(rnorm(100), nrow = 10)

# Perform clustering
clustering_results &lt;- perform_clustering(data, n_clusters = 3)

# Access the results
clustering_results$kmeans
clustering_results$hierarchical
clustering_results$dbscan
clustering_results$gmm
clustering_results$spectral
clustering_results$affinity_propagation

</code></pre>

<hr>
<h2 id='plot_seq_length_distribution'>Plot the Distribution of Sequence Lengths</h2><span id='topic+plot_seq_length_distribution'></span>

<h3>Description</h3>

<p>This function plots the distribution of the lengths of sequences of elements, where each sequence is split by spaces. The plot includes a histogram and a vertical line indicating the mean length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_seq_length_distribution(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_seq_length_distribution_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'ggplot' object showing the distribution of sequence lengths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
plot_seq_length_distribution(sequences)
</code></pre>

<hr>
<h2 id='redundancy'>Calculate Observed and Expected Redundancy of Sequences</h2><span id='topic+redundancy'></span>

<h3>Description</h3>

<p>This function calculates the observed redundancy of sequences and compares it to expected redundancy values obtained from shuffled sequences. The redundancy is defined as the proportion of consecutive identical elements in the sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundancy(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redundancy_+3A_sequences">sequences</code></td>
<td>
<p>A vector of character strings, where each string represents a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates redundancy as the proportion of consecutive identical elements within each sequence. It then compares this observed redundancy to expected values derived from sequences where elements are shuffled either across sequences or within each sequence. The function relies on auxiliary functions 'shuffle_sequences_across' and 'shuffle_sequences_within' for generating the shuffled sequences.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>redundancy</code></td>
<td>
<p>The observed redundancy in the original sequences. This is the mean proportion of consecutive identical elements across all sequences.</p>
</td></tr>
<tr><td><code>redundancy_expected_across</code></td>
<td>
<p>The expected redundancy obtained from sequences where elements have been shuffled across the sequences.</p>
</td></tr>
<tr><td><code>redundancy_expected_within</code></td>
<td>
<p>The expected redundancy obtained from sequences where elements have been shuffled within each sequence.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example sequences
sequences &lt;- c("A A B C C", "B A A C C", "A B C C C")
# Compute redundancy
redundancy(sequences)
</code></pre>

<hr>
<h2 id='sd_seq_length'>Calculate the Standard Deviation of Sequence Lengths</h2><span id='topic+sd_seq_length'></span>

<h3>Description</h3>

<p>This function calculates the standard deviation of the lengths of sequences of elements, where each sequence is split by spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_seq_length(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_seq_length_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the standard deviation of the lengths of the sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
sd_seq_length(sequences)
</code></pre>

<hr>
<h2 id='sequence_duration_summary'>Summarize Sequence Durations</h2><span id='topic+sequence_duration_summary'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for the durations of sequences, where the duration is defined as the difference between 'end_time' and 'start_time'. If 'duration' is provided, it will be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_duration_summary(sequences, start_time, end_time, duration = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_duration_summary_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
<tr><td><code id="sequence_duration_summary_+3A_start_time">start_time</code></td>
<td>
<p>A numeric vector representing the start times of the sequences.</p>
</td></tr>
<tr><td><code id="sequence_duration_summary_+3A_end_time">end_time</code></td>
<td>
<p>A numeric vector representing the end times of the sequences.</p>
</td></tr>
<tr><td><code id="sequence_duration_summary_+3A_duration">duration</code></td>
<td>
<p>(Optional) A numeric vector representing the durations of the sequences. If 'NULL', it will be calculated as 'end_time - start_time'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>mean_seq_duration</code></td>
<td>
<p>The mean duration of the sequences.</p>
</td></tr>
<tr><td><code>sd_seq_duration</code></td>
<td>
<p>The standard deviation of the sequence durations.</p>
</td></tr>
<tr><td><code>median_seq_duration</code></td>
<td>
<p>The median duration of the sequences.</p>
</td></tr>
<tr><td><code>min_seq_duration</code></td>
<td>
<p>The minimum duration of the sequences.</p>
</td></tr>
<tr><td><code>max_seq_duration</code></td>
<td>
<p>The maximum duration of the sequences.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
start_time &lt;- c(1, 2, 3)
end_time &lt;- c(2, 4, 7)
sequence_duration_summary(sequences, start_time, end_time)
</code></pre>

<hr>
<h2 id='sequence_length_summary'>Summarize Sequence Lengths</h2><span id='topic+sequence_length_summary'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for the lengths of sequences of elements, including mean, standard deviation, median, minimum, and maximum lengths. It also counts the number of distinct elements and compares this to shuffled sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_length_summary(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_length_summary_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>mean_seq_elements</code></td>
<td>
<p>The mean length of the sequences.</p>
</td></tr>
<tr><td><code>sd_seq_elements</code></td>
<td>
<p>The standard deviation of the sequence lengths.</p>
</td></tr>
<tr><td><code>median_seq_elements</code></td>
<td>
<p>The median length of the sequences.</p>
</td></tr>
<tr><td><code>min_seq_elements</code></td>
<td>
<p>The minimum length of the sequences.</p>
</td></tr>
<tr><td><code>max_seq_elements</code></td>
<td>
<p>The maximum length of the sequences.</p>
</td></tr>
<tr><td><code>distinct_elements</code></td>
<td>
<p>The number of distinct elements across all sequences.</p>
</td></tr>
<tr><td><code>pvalue_distinct_elements</code></td>
<td>
<p>The p-value comparing the true number of distinct elements to shuffled sequences.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
sequence_length_summary(sequences)
</code></pre>

<hr>
<h2 id='sequence_length_summary_covariate'>Summarize Sequence Lengths by Covariate</h2><span id='topic+sequence_length_summary_covariate'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for the lengths of sequences of elements, grouped by a specified covariate. It includes mean, standard deviation, median, minimum, and maximum lengths, along with the number of distinct elements and the p-value comparing to shuffled sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_length_summary_covariate(sequences, covariate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_length_summary_covariate_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
<tr><td><code id="sequence_length_summary_covariate_+3A_covariate">covariate</code></td>
<td>
<p>A vector of covariates with the same length as 'sequences', used to group the sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>covariate</code></td>
<td>
<p>The value of the covariate.</p>
</td></tr>
<tr><td><code>mean_seq_elements</code></td>
<td>
<p>The mean length of sequences for this covariate value.</p>
</td></tr>
<tr><td><code>sd_seq_elements</code></td>
<td>
<p>The standard deviation of the sequence lengths for this covariate value.</p>
</td></tr>
<tr><td><code>median_seq_elements</code></td>
<td>
<p>The median length of sequences for this covariate value.</p>
</td></tr>
<tr><td><code>min_seq_elements</code></td>
<td>
<p>The minimum length of sequences for this covariate value.</p>
</td></tr>
<tr><td><code>max_seq_elements</code></td>
<td>
<p>The maximum length of sequences for this covariate value.</p>
</td></tr>
<tr><td><code>distinct_elements</code></td>
<td>
<p>The number of distinct elements for this covariate value.</p>
</td></tr>
<tr><td><code>pvalue_distinct_elements</code></td>
<td>
<p>The p-value comparing the number of distinct elements to shuffled sequences for this covariate value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
covariate &lt;- c('A', 'B', 'A')
sequence_length_summary_covariate(sequences, covariate)
</code></pre>

<hr>
<h2 id='sequence_length_summary_element'>Summarize Sequence Lengths by Element</h2><span id='topic+sequence_length_summary_element'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for the lengths of sequences containing specific distinct elements. It performs the summary for each distinct element found across the sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_length_summary_element(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequence_length_summary_element_+3A_sequences">sequences</code></td>
<td>
<p>A character vector where each element is a sequence of elements separated by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>element</code></td>
<td>
<p>The distinct element.</p>
</td></tr>
<tr><td><code>mean_seq_elements</code></td>
<td>
<p>The mean length of sequences containing the element.</p>
</td></tr>
<tr><td><code>sd_seq_elements</code></td>
<td>
<p>The standard deviation of the lengths of sequences containing the element.</p>
</td></tr>
<tr><td><code>median_seq_elements</code></td>
<td>
<p>The median length of sequences containing the element.</p>
</td></tr>
<tr><td><code>min_seq_elements</code></td>
<td>
<p>The minimum length of sequences containing the element.</p>
</td></tr>
<tr><td><code>max_seq_elements</code></td>
<td>
<p>The maximum length of sequences containing the element.</p>
</td></tr>
<tr><td><code>distinct_elements</code></td>
<td>
<p>The number of distinct elements in sequences containing the element.</p>
</td></tr>
<tr><td><code>pvalue_distinct_elements</code></td>
<td>
<p>The p-value comparing the true number of distinct elements to shuffled sequences.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c('hello world', 'hello world hello', 'hello world hello world')
sequence_length_summary_element(sequences)
</code></pre>

<hr>
<h2 id='sequences_to_long'>Convert Sequences to Long Format</h2><span id='topic+sequences_to_long'></span>

<h3>Description</h3>

<p>This function converts a data frame with sequences into long format. It expands each sequence into individual rows, optionally including start and end times and covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequences_to_long(
  sequences,
  sequence = "sequence",
  start_time = NULL,
  end_time = NULL,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequences_to_long_+3A_sequences">sequences</code></td>
<td>
<p>A data frame containing sequences.</p>
</td></tr>
<tr><td><code id="sequences_to_long_+3A_sequence">sequence</code></td>
<td>
<p>Column name with the sequences.</p>
</td></tr>
<tr><td><code id="sequences_to_long_+3A_start_time">start_time</code></td>
<td>
<p>Column name with the start time. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="sequences_to_long_+3A_end_time">end_time</code></td>
<td>
<p>Column name with the end time. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="sequences_to_long_+3A_covariates">covariates</code></td>
<td>
<p>A vector with column names of the covariates. Defaults to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in long format with sequences, start time, end time, duration, and covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- data.frame(sequence = c('A B C', 'A B', 'A C', 'B C'),
                        covariate1 = c('X', 'Y', 'X', 'Y'),
                        covariate2 = c('M', 'N', 'M', 'N'))
sequences_to_long(sequences,
                  sequence = 'sequence',
                  covariates = c('covariate1', 'covariate2'))
</code></pre>

<hr>
<h2 id='shuffle_sequences_across'>Shuffle Elements Across All Sequences</h2><span id='topic+shuffle_sequences_across'></span>

<h3>Description</h3>

<p>This function shuffles elements across all sequences, preserving the lengths of the original sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_sequences_across(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_sequences_across_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences to shuffle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of sequences with elements shuffled across all sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences &lt;- c("A B C", "D E F", "G H I")
result &lt;- shuffle_sequences_across(sequences)
print(result)
</code></pre>

<hr>
<h2 id='shuffle_sequences_within'>Shuffle Elements Within Each Sequence</h2><span id='topic+shuffle_sequences_within'></span>

<h3>Description</h3>

<p>This function shuffles the elements within each sequence independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_sequences_within(sequences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_sequences_within_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences to shuffle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of sequences with elements shuffled within each sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
sequences &lt;- c("A B C", "D E F", "G H I")
result &lt;- shuffle_sequences_within(sequences)
print(result)
</code></pre>

<hr>
<h2 id='temporal_overlap'>Temporal Overlap</h2><span id='topic+temporal_overlap'></span>

<h3>Description</h3>

<p>This function calculates the temporal overlap of elements in sequences.
It determines how much each element overlaps with other elements in the same sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_overlap(sequences_long)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temporal_overlap_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame containing sequences with columns: sequence_nr, element, start_time, and end_time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing the mean overlap elements and mean overlap proportion for each element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences_long &lt;- data.frame(
  sequence_nr = c(1, 1, 1, 2, 2),
  element = c("A", "B", "C", "A", "B"),
  start_time = c(0, 5, 10, 0, 5),
  end_time = c(5, 10, 15, 5, 10)
)
result &lt;- temporal_overlap(sequences_long)
print(result)

</code></pre>

<hr>
<h2 id='transition_chisq'>Perform a Chi-Squared Test for Transition Counts</h2><span id='topic+transition_chisq'></span>

<h3>Description</h3>

<p>This function performs a chi-squared test to determine if there are significant differences between observed and expected transition counts in sequences. It calculates the chi-squared statistic and tests the null hypothesis that transitions occur according to the expected frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_chisq(sequences, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_chisq_+3A_sequences">sequences</code></td>
<td>
<p>A vector of sequences, where each sequence is a character string with elements separated by spaces.</p>
</td></tr>
<tr><td><code id="transition_chisq_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value representing the significance level for the chi-squared test. Default is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates observed transition counts from the input sequences, computes expected transition counts based on row and column sums, and performs a chi-squared test to compare observed and expected counts. The test determines if the transitions in the sequences differ significantly from what would be expected by chance.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table role = "presentation">
<tr><td><code>significant</code></td>
<td>
<p>A logical value indicating whether the chi-squared test result is significant at the given significance level.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>A numeric value representing the p-value of the chi-squared test.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Define sequences
sequences &lt;- c('e1 e2 e3', 'e2 e1 e3', 'e3 e2 e1')

# Perform chi-squared test
transition_chisq(sequences, alpha = 0.05)
</code></pre>

<hr>
<h2 id='transition_entropy'>Calculate Transition Entropy for Sequences</h2><span id='topic+transition_entropy'></span>

<h3>Description</h3>

<p>This function calculates the transition entropy for sequences using n-grams.
It performs bootstrapping to compute entropy and expected entropy over multiple iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_entropy(sequences, ngram = 2, iterations = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_entropy_+3A_sequences">sequences</code></td>
<td>
<p>A list of sequences (character vectors) to analyze.</p>
</td></tr>
<tr><td><code id="transition_entropy_+3A_ngram">ngram</code></td>
<td>
<p>The size of the n-gram (default is 2).</p>
</td></tr>
<tr><td><code id="transition_entropy_+3A_iterations">iterations</code></td>
<td>
<p>The number of bootstrap iterations (default is 20).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with calculated entropies, expected entropies, and entropy ratios for each iteration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- unlist(list("A B C", "B C A", "C A B"))
transition_entropy(sequences, ngram = 2, iterations = 20)

</code></pre>

<hr>
<h2 id='transition_predictions'>Transition Predictions</h2><span id='topic+transition_predictions'></span>

<h3>Description</h3>

<p>This function takes sequences of elements and uses a machine learning classifier to predict the next elements in the sequence.
It supports n-gram tokenization and k-fold cross-validation. Optionally, it can upsample the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_predictions(
  sequences,
  classifier = "nb",
  ngram = 2,
  upsample = TRUE,
  k = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_predictions_+3A_sequences">sequences</code></td>
<td>
<p>A list of character strings representing sequences of elements.</p>
</td></tr>
<tr><td><code id="transition_predictions_+3A_classifier">classifier</code></td>
<td>
<p>A character string specifying the classifier to use. Options are 'nb' for Naive Bayes and 'forest' for random forest.</p>
</td></tr>
<tr><td><code id="transition_predictions_+3A_ngram">ngram</code></td>
<td>
<p>An integer specifying the number of elements to consider in the n-gram tokenization. Default is 2.</p>
</td></tr>
<tr><td><code id="transition_predictions_+3A_upsample">upsample</code></td>
<td>
<p>A logical value indicating whether to upsample the training data to balance class distribution. Default is TRUE.</p>
</td></tr>
<tr><td><code id="transition_predictions_+3A_k">k</code></td>
<td>
<p>An integer specifying the number of folds for k-fold cross-validation. Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the mean accuracy, mean null accuracy, and a data frame of prediction errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- list("a b c", "b c d", "c d e")
result &lt;- transition_predictions(sequences, classifier = 'nb', ngram = 2, upsample = TRUE, k = 5)
print(result)
</code></pre>

<hr>
<h2 id='transition_test'>Perform a Statistical Test for Transition Probabilities</h2><span id='topic+transition_test'></span>

<h3>Description</h3>

<p>This function performs a permutation test to evaluate the significance of observed transition probabilities in sequences. It compares the observed transition probabilities to those obtained from permuted sequences to determine if the observed probabilities are significantly different from what would be expected by chance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition_test(sequences, observed_probs, n_permutations = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transition_test_+3A_sequences">sequences</code></td>
<td>
<p>A character vector of sequences where each sequence is represented as a string of elements separated by spaces.</p>
</td></tr>
<tr><td><code id="transition_test_+3A_observed_probs">observed_probs</code></td>
<td>
<p>A data frame containing observed transition probabilities with columns <code>previous_element</code>, <code>element</code>, and <code>probability</code>.</p>
</td></tr>
<tr><td><code id="transition_test_+3A_n_permutations">n_permutations</code></td>
<td>
<p>An integer specifying the number of permutations to perform. Default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- **Observed Transition Probabilities**: Calculated from the input sequences.
- **Permutations**: The sequences are permuted <code>n_permutations</code> times, and transition probabilities are computed for each permutation.
- **P-Values**: Calculated as the proportion of permuted transition probabilities that are greater than or equal to the observed transition probabilities.
</p>


<h3>Value</h3>

<p>A data frame with the observed transition probabilities, expected probabilities from permutations, and p-values for each transition. The data frame contains the following columns:
</p>
<table role = "presentation">
<tr><td><code>previous_element</code></td>
<td>
<p>The element preceding the transition.</p>
</td></tr>
<tr><td><code>element</code></td>
<td>
<p>The element following the transition.</p>
</td></tr>
<tr><td><code>probability</code></td>
<td>
<p>The observed probability of the transition.</p>
</td></tr>
<tr><td><code>expected_probability</code></td>
<td>
<p>The mean probability of the transition obtained from permuted sequences.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>The p-value indicating the significance of the observed probability compared to the permuted probabilities.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example sequences
sequences &lt;- c('e1 e2 e3', 'e2 e3 e4', 'e3 e4 e1')

# Calculate observed transition probabilities
observed_probs &lt;- calculate_transition_probs(sequences)

# Perform the transition test
test_results &lt;- transition_test(sequences, observed_probs, n_permutations = 50)

# View results
head(test_results)

</code></pre>

<hr>
<h2 id='zipf_plot'>Create a Zipf's Law Plot</h2><span id='topic+zipf_plot'></span>

<h3>Description</h3>

<p>This function creates a log-log plot to visualize Zipf's law, which states that the frequency of a word is inversely proportional to its rank in the frequency table. The plot compares the observed frequency distribution of elements with the expected distribution if Zipf's law were true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipf_plot(sequences_long)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zipf_plot_+3A_sequences_long">sequences_long</code></td>
<td>
<p>A data frame containing at least one column named &lsquo;element' which represents the elements of sequences. Each element&rsquo;s frequency is used to create the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- **Observed Frequencies**: Calculated from the provided 'sequences_long' data frame.
- **Expected Frequencies**: Calculated using Zipf's law formula, where the frequency of the element is inversely proportional to its rank.
- **Plotting**: Both observed and expected frequencies are plotted on a log-log scale to compare against Zipf's law.
</p>


<h3>Value</h3>

<p>A &lsquo;ggplot' object that visualizes the observed and expected frequencies of elements according to Zipf&rsquo;s law. The plot includes:
</p>
<table role = "presentation">
<tr><td><code>Rank</code></td>
<td>
<p>The rank of each element based on its frequency, plotted on a log scale.</p>
</td></tr>
<tr><td><code>Count</code></td>
<td>
<p>The observed frequency of each element, plotted on a log scale.</p>
</td></tr>
<tr><td><code>Expected</code></td>
<td>
<p>The expected frequency of each element if Zipf's law were true, shown as a grey dashed line.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example data frame
sequences_long &lt;- data.frame(element = c('a', 'b', 'a', 'c', 'b', 'a', 'd', 'c', 'b', 'a'))

# Generate the Zipf's law plot
zipf_plot(sequences_long)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
