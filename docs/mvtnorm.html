<!DOCTYPE html><html><head><title>Help for package mvtnorm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvtnorm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvtnorm-package'>
<p>Multivariate Normal and t Distributions</p></a></li>
<li><a href='#algorithms'><p> Choice of Algorithm and Hyper Parameters</p></a></li>
<li><a href='#lpmvnorm'>
<p>Multivariate Normal Log-likelihood and Score Functions</p></a></li>
<li><a href='#ltMatrices'>
<p>Multiple Lower Triangular Matrices</p></a></li>
<li><a href='#margcond'>
<p>Marginal and Conditional Multivariate Normal Distributions</p></a></li>
<li><a href='#Mvnorm'><p>Multivariate Normal Density and Random Deviates</p></a></li>
<li><a href='#Mvt'><p>The Multivariate t Distribution</p></a></li>
<li><a href='#pmvnorm'><p> Multivariate Normal Distribution</p></a></li>
<li><a href='#pmvt'><p> Multivariate t Distribution</p></a></li>
<li><a href='#qmvnorm'><p> Quantiles of the Multivariate Normal Distribution</p></a></li>
<li><a href='#qmvt'><p> Quantiles of the Multivariate t Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multivariate Normal and t Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes multivariate normal and t probabilities, quantiles, random deviates, 
  and densities. Log-likelihoods for multivariate Gaussian models and Gaussian copulae 
  parameterised by Cholesky factors of covariance or precision matrices are implemented 
  for interval-censored and exact data, or a mix thereof. Score functions for these 
  log-likelihoods are available. A class representing multiple lower triangular matrices 
  and corresponding methods are part of this package.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>qrng, numDeriv</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mvtnorm.R-forge.R-project.org">http://mvtnorm.R-forge.R-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 11:38:16 UTC; hothorn</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Genz [aut],
  Frank Bretz [aut],
  Tetsuhisa Miwa [aut],
  Xuefei Mi [aut],
  Friedrich Leisch [ctb],
  Fabian Scheipl [ctb],
  Bjoern Bornkamp <a href="https://orcid.org/0000-0002-6294-8185"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Torsten Hothorn <a href="https://orcid.org/0000-0001-8301-0471"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Hothorn &lt;Torsten.Hothorn@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvtnorm-package'>
Multivariate Normal and t Distributions
</h2><span id='topic+mvtnorm-package'></span><span id='topic+mvtnorm'></span>

<h3>Description</h3>

<p>Computes multivariate normal and t probabilities, quantiles, random deviates, 
  and densities. Log-likelihoods for multivariate Gaussian models and Gaussian copulae 
  parameterised by Cholesky factors of covariance or precision matrices are implemented 
  for interval-censored and exact data, or a mix thereof. Score functions for these 
  log-likelihoods are available. A class representing multiple lower triangular matrices 
  and corresponding methods are part of this package.
</p>


<h3>Details</h3>

<p>Package <span class="pkg">mvtnorm</span> provides functionality for dealing with multivariate
normal and t-distributions. The package interfaces FORTRAN and
<code>C</code> code for evaluating multivariate normal probabilities written by
Alan Genz and Tetsuhisa Miwa. Functions <code><a href="#topic+pmvnorm">pmvnorm</a></code>,
<code><a href="#topic+pmvt">pmvt</a></code>, <code><a href="#topic+qmvnorm">qmvnorm</a></code>, and <code><a href="#topic+qmvt">qmvt</a></code> return
normal and t probabilities or corresponding quantiles computed by these
original implementations. Users interested in the computation of such
probabilities or quantiles, for example for multiple testing purposes,
should use this functionality.
</p>
<p>When the multivariate normal log-likelihood function, defined by the
log-probability in the discrete or interval-censored case or by the
log-density for exact real observations, or a mix thereof, shall be
computed, functions <code><a href="#topic+lpmvnorm">lpmvnorm</a></code>, <code><a href="#topic+ldmvnorm">ldmvnorm</a></code>, and
<code><a href="#topic+ldpmvnorm">ldpmvnorm</a></code> are better suited.  They rely on an independent
implementation of Genz' algorithm (for log-probabilities), can be customised
(different quasi-Monte Carlo schemes), and are a bit faster.  Most
importantly, the corresponding score functions are available through
functions <code><a href="#topic+slpmvnorm">slpmvnorm</a></code>, <code><a href="#topic+sldmvnorm">sldmvnorm</a></code>, or
<code><a href="#topic+sldpmvnorm">sldpmvnorm</a></code>, which help to speed-up parameter estimation
considerably. Users interested in this functionality should
consult the <code>lmvnorm_src</code> package vignette.
</p>


<h3>See Also</h3>

<p><code>vignette("lmvnorm_src", package = "mvtnorm")</code>
</p>

<hr>
<h2 id='algorithms'> Choice of Algorithm and Hyper Parameters </h2><span id='topic+GenzBretz'></span><span id='topic+Miwa'></span><span id='topic+TVPACK'></span>

<h3>Description</h3>

<p>Choose between three algorithms for evaluating normal (and t-)
distributions and define hyper parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenzBretz(maxpts = 25000, abseps = 0.001, releps = 0)
Miwa(steps = 128, checkCorr = TRUE, maxval = 1e3)
TVPACK(abseps = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algorithms_+3A_maxpts">maxpts</code></td>
<td>
<p>maximum number of function values as integer.  The internal
FORTRAN code always uses a minimum number depending on the dimension.
(for example 752 for three-dimensional problems).</p>
</td></tr>
<tr><td><code id="algorithms_+3A_abseps">abseps</code></td>
<td>
<p>absolute error tolerance; for <code>TVPACK</code> only used
for dimension 3.</p>
</td></tr>
<tr><td><code id="algorithms_+3A_releps">releps</code></td>
<td>
<p> relative error tolerance as double. </p>
</td></tr>
<tr><td><code id="algorithms_+3A_steps">steps</code></td>
<td>
<p>number of grid points to be evaluated; cannot be larger than
4097.</p>
</td></tr>
<tr><td><code id="algorithms_+3A_checkcorr">checkCorr</code></td>
<td>
<p>logical indicating if a check for singularity of the
correlation matrix should be performed (once per function call to
<code>pmvt()</code> or <code>pmvnorm()</code>).</p>
</td></tr>
<tr><td><code id="algorithms_+3A_maxval">maxval</code></td>
<td>
<p>replacement for <code>Inf</code> when non-orthant probabilities
involving <code>Inf</code> shall be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three algorithms available for evaluating normal
(and two algorithms for t-)
probabilities: The default is the randomized Quasi-Monte-Carlo procedure
by Genz (1992, 1993) and Genz and Bretz (2002) applicable to
arbitrary covariance structures and dimensions up to 1000.
</p>
<p>For normal probabilities, smaller dimensions (up to 20) and non-singular
covariance matrices,
the algorithm by Miwa et al. (2003) can be used as well. This algorithm can
compute orthant probabilities (<code>lower</code> being <code>-Inf</code> or
<code>upper</code> equal to <code>Inf</code>). Non-orthant probabilities are computed
from the corresponding orthant probabilities, however, infinite limits are
replaced by <code>maxval</code> along with a warning.
</p>
<p>For two- and three-dimensional problems and semi-infinite integration
region, <code>TVPACK</code> implements an interface to the methods described
by Genz (2004).
</p>


<h3>Value</h3>

<p>An object of class <code>"GenzBretz"</code>, <code>"Miwa"</code>, or <code>"TVPACK"</code>
defining hyper parameters.
</p>


<h3>References</h3>

<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities.
<em>Journal of Computational and Graphical Statistics</em>, <b>1</b>, 141&ndash;150.
</p>
<p>Genz, A. (1993). Comparison of methods for the computation of multivariate
normal probabilities. <em>Computing Science and Statistics</em>, <b>25</b>,
400&ndash;405.
</p>
<p>Genz, A. and Bretz, F. (2002), Methods for the computation of multivariate
t-probabilities. <em>Journal of Computational and Graphical Statistics</em>,
<b>11</b>, 950&ndash;971.
</p>
<p>Genz, A. (2004), Numerical computation of rectangular bivariate and
trivariate normal and t-probabilities, <em>Statistics and
Computing</em>, <b>14</b>, 251&ndash;260.
</p>
<p>Genz, A. and Bretz, F. (2009), <em>Computation of Multivariate Normal and
t Probabilities</em>. Lecture Notes in Statistics, Vol. 195. Springer-Verlag,
Heidelberg.
</p>
<p>Miwa, A., Hayter J. and Kuriki, S. (2003).
The evaluation of general non-centred orthant probabilities.
<em>Journal of the Royal Statistical Society</em>, Ser. B, 65, 223&ndash;234.
</p>
<p>Mi, X., Miwa, T. and Hothorn, T. (2009).
<code>mvtnorm</code>: New numerical algorithm for multivariate normal probabilities.
<em>The R Journal</em> <b>1</b>(1): 37&ndash;39.
<a href="https://journal.r-project.org/archive/2009-1/RJournal_2009-1_Mi+et+al.pdf">https://journal.r-project.org/archive/2009-1/RJournal_2009-1_Mi+et+al.pdf</a>
</p>

<hr>
<h2 id='lpmvnorm'>
Multivariate Normal Log-likelihood and Score Functions
</h2><span id='topic+lpmvnorm'></span><span id='topic+slpmvnorm'></span><span id='topic+ldmvnorm'></span><span id='topic+sldmvnorm'></span><span id='topic+ldpmvnorm'></span><span id='topic+sldpmvnorm'></span>

<h3>Description</h3>

<p>Computes the log-likelihood (contributions) of multiple exact or 
interval-censored observations (or a mix thereof) from multivariate 
normal distributions and evaluates corresponding score functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpmvnorm(lower, upper, mean = 0, center = NULL, chol, invchol, logLik = TRUE, 
         M = NULL, w = NULL, seed = NULL, tol = .Machine$double.eps, fast = FALSE)
slpmvnorm(lower, upper, mean = 0, center = NULL, chol, invchol, logLik = TRUE, 
          M = NULL, w = NULL, seed = NULL, tol = .Machine$double.eps, fast = FALSE)
ldmvnorm(obs, mean = 0, chol, invchol, logLik = TRUE) 
sldmvnorm(obs, mean = 0, chol, invchol, logLik = TRUE) 
ldpmvnorm(obs, lower, upper, mean = 0, chol, invchol, logLik = TRUE, ...) 
sldpmvnorm(obs, lower, upper, mean = 0, chol, invchol, logLik = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpmvnorm_+3A_lower">lower</code></td>
<td>
<p>matrix of lower limits (one column for each observation, <code class="reqn">J</code> rows).
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_upper">upper</code></td>
<td>
<p>matrix of upper limits (one column for each observation, <code class="reqn">J</code> rows).
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_obs">obs</code></td>
<td>
<p>matrix of exact observations (one column for each observation, <code class="reqn">J</code> rows).
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_mean">mean</code></td>
<td>
<p>matrix of means (one column for each observation, length is
recycled to length of <code>obs</code>, <code>lower</code> and <code>upper</code>).
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_center">center</code></td>
<td>
<p>matrix of negative rescaled means (one column for each observation, length is
recycled to length of <code>lower</code> and <code>upper</code>) as returned by
<code>cond_mvnorm(..., center = TRUE)</code>. 
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_chol">chol</code></td>
<td>
<p>Cholesky factors of covariance matrices as
<code><a href="#topic+ltMatrices">ltMatrices</a></code> object, length is recylced to length of
<code>obs</code>, <code>lower</code> and <code>upper</code>.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_invchol">invchol</code></td>
<td>
<p>Cholesky factors of precision matrices as
<code><a href="#topic+ltMatrices">ltMatrices</a></code> object, length is recylced to length of <code>lower</code> and
<code>upper</code>. Either <code>chol</code> or <code>invchol</code> must be given.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_loglik">logLik</code></td>
<td>
<p>logical, if <code>TRUE</code>, the log-likelihood is returned,
otherwise the individual contributions to the sum are returned.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_m">M</code></td>
<td>
<p>number of iterations, early stopping based on
estimated errors is NOT implemented.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_w">w</code></td>
<td>
<p>an optional matrix of weights with <code class="reqn">J - 1</code> rows. This allows to replace the default
Monte-Carlo procedure (Genz, 1992) with a quasi-Monte-Carlo approach (Genz &amp;
Bretz, 2002). Note that the same weights for evaluating the
multivariate normal probability are used for all observations when
<code>ncol(w) == M</code> is specified. If <code>ncol(w) == ncol(lower) * M</code>, each
likelihood contribution is evaluated on the corresponding sub-matrix.
If <code>w</code> is <code>NULL</code>, different uniform numbers are
drawn for each observation.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code><a href="stats.html#topic+simulate">simulate</a></code>. Only 
applied when <code>w</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_tol">tol</code></td>
<td>
<p>tolerance limit, values smaller than <code>tol</code> are interpreted
as zero.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_fast">fast</code></td>
<td>
<p>logical, if <code>TRUE</code>, a faster but less accurate version 
of <code>pnorm</code> is used internally.
</p>
</td></tr>
<tr><td><code id="lpmvnorm_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>lpmvnorm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the multivariate normal log-likelihood defined by <code>means</code> and
<code>chol</code> over boxes defined by <code>lower</code> and <code>upper</code> or for
exact observations <code>obs</code>. 
</p>
<p>Monte-Carlo (Genz, 1992, the default) and quasi-Monte-Carlo (Genz &amp; Bretz, 2002)
integration is implemented, the latter with weights obtained, for example,
from packages <span class="pkg">qrng</span> or <span class="pkg">randtoolbox</span>. It is the responsibility of
the user to ensure a meaningful lattice is used. In case of doubt, use
plain Monte-Carlo (<code>w = NULL</code>) or <code><a href="#topic+pmvnorm">pmvnorm</a></code>.
</p>
<p><code>slpmvnorm</code> computes both the individual log-likelihood contributions
and the corresponding score matrix (of dimension <code class="reqn">J \times (J + 1) / 2 \times N</code>) if
<code>chol</code> contains diagonal elements. Otherwise, the dimension is <code class="reqn">J
  \times (J - 1) / 2 \times N</code>. The scores for exact or mixed exact-interval 
observations are computed by <code>sldmvnorm</code> and <code>sldpmvnorm</code>,
respectively.
</p>
<p>More details can be found in the <code>lmvnorm_src</code> package vignette.
</p>


<h3>Value</h3>

<p>The log-likelihood (<code>logLik = TRUE</code>) or the individual contributions to the log-likelihood.
<code>slpmvnorm</code>, <code>sldmvnorm</code>, and <code>sldpmvnorm</code> return the score
matrices and, optionally (<code>logLik = TRUE</code>), the individual log-likelihood contributions
as well as scores for <code>obs</code>, <code>lower</code>, <code>upper</code>, and
<code>mean</code>.
</p>


<h3>References</h3>

<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities.
<em>Journal of Computational and Graphical Statistics</em>, <b>1</b>, 141&ndash;150.
</p>
<p>Genz, A. and Bretz, F. (2002), Methods for the computation of multivariate
t-probabilities. <em>Journal of Computational and Graphical Statistics</em>,
<b>11</b>, 950&ndash;971.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmvnorm">dmvnorm</a></code>, <code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ### five observations
  N &lt;- 5L
  ### dimension
  J &lt;- 4L

  ### lower and upper bounds, ie interval-censoring
  lwr &lt;- matrix(-runif(N * J), nrow = J)
  upr &lt;- matrix(runif(N * J), nrow = J)

  ### Cholesky factor
  (C &lt;- ltMatrices(runif(J * (J + 1) / 2), diag = TRUE))
  ### corresponding covariance matrix
  (S &lt;- as.array(Tcrossprod(C))[,,1])

  ### plain Monte-Carlo (Genz, 1992)
  w &lt;- NULL
  M &lt;- 25000
  ### quasi-Monte-Carlo (Genz &amp; Bretz, 2002, but with different weights)
  if (require("qrng")) w &lt;- t(ghalton(M * N, J - 1))

  ### log-likelihood
  lpmvnorm(lower = lwr, upper = upr, chol = C, w = w, M = M)

  ### compare with pmvnorm
  exp(lpmvnorm(lower = lwr, upper = upr, chol = C, logLik = FALSE, w = w, M = M))
  sapply(1:N, function(i) pmvnorm(lower = lwr[,i], upper = upr[,i], sigma = S))

  ### log-lik contributions and score matrix
  slpmvnorm(lower = lwr, upper = upr, chol = C, w = w, M = M, logLik = TRUE)

</code></pre>

<hr>
<h2 id='ltMatrices'>
Multiple Lower Triangular Matrices
</h2><span id='topic+ltMatrices'></span><span id='topic+Tcrossprod'></span><span id='topic+Crossprod'></span><span id='topic+diagonals'></span><span id='topic+Mult'></span><span id='topic+solve.ltMatrices'></span><span id='topic+as.array.ltMatrices'></span><span id='topic+as.array.syMatrices'></span><span id='topic+diagonals.ltMatrices'></span><span id='topic+diagonals.syMatrices'></span><span id='topic+diagonals.matrix'></span><span id='topic+diagonals+3C-'></span><span id='topic+diagonals+3C-.ltMatrices'></span><span id='topic+diagonals+3C-.syMatrices'></span><span id='topic+diagonals.integer'></span><span id='topic+Lower_tri'></span><span id='topic+chol.syMatrices'></span><span id='topic+aperm.ltMatrices'></span><span id='topic+adddiag'></span><span id='topic+chol2cov'></span><span id='topic+invchol2chol'></span><span id='topic+chol2invchol'></span><span id='topic+invchol2cov'></span><span id='topic+invchol2pre'></span><span id='topic+chol2pre'></span><span id='topic+Dchol'></span><span id='topic+invcholD'></span><span id='topic+chol2cor'></span><span id='topic+invchol2cor'></span><span id='topic+invchol2pc'></span><span id='topic+chol2pc'></span><span id='topic+vectrick'></span><span id='topic+standardize'></span><span id='topic+destandardize'></span>

<h3>Description</h3>

<p>A class representing multiple lower triangular matrices and some methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltMatrices(object, diag = FALSE, byrow = FALSE, names = TRUE)
## S3 method for class 'ltMatrices'
as.array(x, symmetric = FALSE, ...)
## S3 method for class 'syMatrices'
as.array(x, ...)
## S3 method for class 'ltMatrices'
diagonals(x, ...)
## S3 method for class 'syMatrices'
diagonals(x, ...)
## S3 method for class 'matrix'
diagonals(x, ...)
## S3 method for class 'integer'
diagonals(x, ...)
diagonals(x) &lt;- value
## S3 replacement method for class 'ltMatrices'
diagonals(x) &lt;- value
## S3 replacement method for class 'syMatrices'
diagonals(x) &lt;- value
## S3 method for class 'ltMatrices'
solve(a, b, transpose = FALSE, ...)
## S3 method for class 'syMatrices'
chol(x, ...)
## S3 method for class 'ltMatrices'
aperm(a, perm, is_chol = FALSE, ...)
Lower_tri(x, diag = FALSE, byrow = attr(x, "byrow"))
Mult(x, y, transpose = FALSE)
Tcrossprod(x, diag_only = FALSE)
Crossprod(x, diag_only = FALSE)
chol2cov(x)
invchol2chol(x)
chol2invchol(x)
invchol2cov(x)
invchol2pre(x)
chol2pre(x)
Dchol(x, D = 1 / sqrt(Tcrossprod(x, diag_only = TRUE)))
invcholD(x, D = sqrt(Tcrossprod(solve(x), diag_only = TRUE)))
chol2cor(x)
invchol2cor(x)
chol2pc(x)
invchol2pc(x)
vectrick(C, S, A, transpose = c(TRUE, TRUE))
standardize(chol, invchol)
destandardize(chol = solve(invchol), invchol, score_schol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltMatrices_+3A_object">object</code></td>
<td>
<p>a <code>matrix</code> representing the lower triagular elements of
<code class="reqn">N</code> lower triangular matrix, each of dimension <code class="reqn">J \times
                J</code>. Dimensions of <code>object</code> depend on <code>diag</code>: With
diagonal elements, <code>object</code> is a <code class="reqn">J(J+1)/2 \times N</code> matrix,
otherwise, the number of rows is <code class="reqn">J(J - 1) / 2</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_diag">diag</code></td>
<td>
<p>logical, <code>object</code> contains diagonal elements if
<code>TRUE</code>, otherwise unit diagonal elements are assumed.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_byrow">byrow</code></td>
<td>
<p>logical, <code>object</code> represents matrices in row-major order
if <code>TRUE</code> or, otherwise, in column-major order.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_names">names</code></td>
<td>
<p>logical or character vector of length <code class="reqn">J</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_symmetric">symmetric</code></td>
<td>
<p>logical, object is interpreted as a symmetric matrix if
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_diag_only">diag_only</code></td>
<td>
<p>logical, compute diagonal elements of crossproduct only
if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_x">x</code>, <code id="ltMatrices_+3A_chol">chol</code>, <code id="ltMatrices_+3A_invchol">invchol</code></td>
<td>
<p>object of class <code>ltMatrices</code> or <code>syMatrices</code> (for <code>chol</code>).
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_value">value</code></td>
<td>
<p>a matrix of diagonal elements to be assigned (of dimension <code class="reqn">J \times N</code>).
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_a">a</code></td>
<td>
<p>object of class <code>ltMatrices</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_perm">perm</code></td>
<td>
<p>a permutation of the covariance matrix corresponding to <code>a</code>.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_is_chol">is_chol</code></td>
<td>
<p>a logical indicating if <code>a</code> is the Cholesky of the
covariance (<code>chol = TRUE</code>) of the precision matrix.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_d">D</code></td>
<td>
<p>a matrix (of dimension <code class="reqn">J \times N</code>) of diagonal elements to be multiplied with.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_y">y</code></td>
<td>
<p>matrix with <code class="reqn">J</code> rows.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_b">b</code></td>
<td>
<p>matrix with <code class="reqn">J</code> rows.
</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_c">C</code></td>
<td>
<p>an object of class <code>ltMatrices</code>.</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_s">S</code></td>
<td>
<p>an object of class <code>ltMatrices</code> or a matrix with <code class="reqn">J^2</code> rows 
representing multiple <code class="reqn">J x J</code> matrices (columns of vec operators).</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_a">A</code></td>
<td>
<p>an object of class <code>ltMatrices</code>.</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_transpose">transpose</code></td>
<td>
<p>a logical of length two indicating if <code>A</code> or <code>B</code> shall be transposed in <code>vectrick</code>.
For <code>solve</code>, this argument being true computes
<code>solve(t(a), b)</code> (in absence of a <code>t()</code> method for <code>ltMatrices</code>
objects).</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_score_schol">score_schol</code></td>
<td>
<p>score matrix for a standardized <code>chol</code> object.</p>
</td></tr>
<tr><td><code id="ltMatrices_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ltMatrices</code> interprets a matrix as lower triangular elements of
multiple lower triangular matrices. The corresponding class can be used to
store such matrices efficiently. Matrix multiplications, solutions to linear
systems, explicite inverses, and crossproducts can be computed based on such
objects. Details can be found in the <code>lmvnorm_src</code> package vignette.
</p>


<h3>Value</h3>

<p>The constructor <code>ltMatrices</code> returns objects of class <code>ltMatrices</code>
with corresponding methods.
</p>


<h3>See Also</h3>

<p><code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  J &lt;- 4L
  N &lt;- 2L
  dm &lt;- paste0("d", 1:J)
  xm &lt;- paste0("x", 1:N)
  (C &lt;- ltMatrices(matrix(runif(N * J * (J + 1) / 2), 
                          ncol = N, dimnames = list(NULL, xm)), 
                   diag = TRUE, names = dm))

  ## dimensions and names
  dim(C)
  dimnames(C)
  names(C)

  ## subset
  C[,2:3]

  ## multiplication
  y &lt;- matrix(runif(N * J), nrow = J)
  Mult(C, y)

  ## solve
  solve(C)
  solve(C, y)

  ## tcrossprod
  Tcrossprod(C)

  ## convert to matrix
  as.array(solve(C[1,]))[,,1]

</code></pre>

<hr>
<h2 id='margcond'>
Marginal and Conditional Multivariate Normal Distributions
</h2><span id='topic+marg_mvnorm'></span><span id='topic+cond_mvnorm'></span>

<h3>Description</h3>

<p>Computes means and Cholesky factors of covariance or precision matrices
of multiple multivariate normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg_mvnorm(chol, invchol, which = 1L)
cond_mvnorm(chol, invchol, which_given = 1L, given, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margcond_+3A_chol">chol</code></td>
<td>
<p>Cholesky factors of covariance matrices as
<code><a href="#topic+ltMatrices">ltMatrices</a></code> object, length is recylced to length of <code>lower</code> and
<code>upper</code>.
</p>
</td></tr>
<tr><td><code id="margcond_+3A_invchol">invchol</code></td>
<td>
<p>Cholesky factors of precision matrices as
<code><a href="#topic+ltMatrices">ltMatrices</a></code> object, length is recylced to length of <code>lower</code> and
<code>upper</code>. Either <code>chol</code> or <code>invchol</code> must be given.
</p>
</td></tr>
<tr><td><code id="margcond_+3A_which">which</code></td>
<td>
<p>names or indices of elements those marginal distribution
is of interest.
</p>
</td></tr>
<tr><td><code id="margcond_+3A_which_given">which_given</code></td>
<td>
<p>names or indices of elements to condition on.
</p>
</td></tr>
<tr><td><code id="margcond_+3A_given">given</code></td>
<td>
<p>matrix of realisations to condition on (number of rows is
equal to <code>length(which)</code>, the number of 
columns corresponds to the number of matrices in <code>chol</code>
or <code>invchol</code>.
</p>
</td></tr>
<tr><td><code id="margcond_+3A_center">center</code></td>
<td>
<p>logical, if <code>TRUE</code>, the negative rescaled conditional mean is returned
(such that it can be specified as <code>center</code> argument to
<code><a href="#topic+slpmvnorm">slpmvnorm</a></code>). By default, the conditional mean is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derives parameters of the requested marginal or conditional distributions,
defined by <code>chol</code> (Cholesky factor of covariance) or <code>invchol</code>
(Cholesky factor of precision matrix) and, for conditional distributions,
the mean.
</p>
<p>More details can be found in the <code>lmvnorm_src</code> package vignette.
</p>


<h3>Value</h3>

<p>A named list.
</p>


<h3>See Also</h3>

<p><code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>

<hr>
<h2 id='Mvnorm'>Multivariate Normal Density and Random Deviates</h2><span id='topic+dmvnorm'></span><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>These functions provide the density function and a random number
generator for the multivariate normal
distribution with mean equal to <code>mean</code> and covariance matrix
<code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm(x, mean = rep(0, p), sigma = diag(p), log = FALSE, checkSymmetry = TRUE)
rmvnorm(n, mean = rep(0, nrow(sigma)), sigma = diag(length(mean)),
           method=c("eigen", "svd", "chol"), pre0.9_9994 = FALSE, 
           checkSymmetry = TRUE, rnorm = stats::rnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mvnorm_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. When <code>x</code> is a matrix, each
row is taken to be a quantile and columns correspond to the number of dimensions, 
<code>p</code>.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_mean">mean</code></td>
<td>
<p>mean vector, default is <code>rep(0, length = ncol(x))</code>.
In <code>ldmvnorm</code> or 
<code>sldmvnorm</code>, <code>mean</code> is a matrix with
observation-specific means arranged in columns.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix, default is <code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, densities d are given as log(d).</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_method">method</code></td>
<td>
<p>string specifying the matrix decomposition used to
determine the matrix root of <code>sigma</code>.  Possible methods are
eigenvalue decomposition (<code>"eigen"</code>, default),
singular value decomposition (<code>"svd"</code>), and
Cholesky decomposition (<code>"chol"</code>).  The
Cholesky is typically fastest, not by much though.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_pre0.9_9994">pre0.9_9994</code></td>
<td>
<p>logical; if <code>FALSE</code>, the output produced in mvtnorm
versions up to 0.9-9993 is reproduced. In 0.9-9994, the
output is organized such that <code>rmvnorm(10,...)</code> has the
same first ten rows as <code>rmvnorm(100, ...)</code> when called
with the same seed.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical; if <code>FALSE</code>, skip checking whether the
covariance matrix is symmetric or not. This will speed up the
computation but may cause unexpected outputs when ill-behaved
<code>sigma</code> is provided. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Mvnorm_+3A_rnorm">rnorm</code></td>
<td>
<p>a function with the same interface as
<code><a href="stats.html#topic+rnorm">rnorm</a></code>. This allows switching to other generators of
standard normal variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dmvnorm</code> computes the density function of the multivariate normal
specified by mean and the covariance matrix <code>sigma</code>. 
</p>
<p><code>rmvnorm</code> generates multivariate normal variables. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmvnorm">pmvnorm</a></code>, <code><a href="stats.html#topic+rnorm">rnorm</a></code>, <code><a href="#topic+qmvnorm">qmvnorm</a></code>,
<code>vignette("lmvnorm_src", package = "mvtnorm")</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dmvnorm(x=c(0,0))
dmvnorm(x=c(0,0), mean=c(1,1))

sigma &lt;- matrix(c(4,2,2,3), ncol=2)
x &lt;- rmvnorm(n=500, mean=c(1,2), sigma=sigma)
colMeans(x)
var(x)
dS &lt;- dmvnorm(x, sigma = sigma)

### alternative interface
C &lt;- t(chol(sigma))
(C &lt;- ltMatrices(C[lower.tri(C, diag = TRUE)], diag = TRUE))
dC &lt;- exp(ldmvnorm(obs = t(x), chol = C, logLik = FALSE))
all.equal(dS, dC)

x &lt;- rmvnorm(n=500, mean=c(1,2), sigma=sigma, method="chol")
colMeans(x)
var(x)

plot(x)
</code></pre>

<hr>
<h2 id='Mvt'>The Multivariate t Distribution</h2><span id='topic+dmvt'></span><span id='topic+rmvt'></span>

<h3>Description</h3>

<p>These functions provide information about the multivariate <code class="reqn">t</code>
distribution with non-centrality parameter (or mode) <code>delta</code>,
scale matrix <code>sigma</code> and degrees of freedom <code>df</code>.
<code>dmvt</code> gives the density and <code>rmvt</code>
generates random deviates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvt(n, sigma = diag(2), df = 1, delta = rep(0, nrow(sigma)),
     type = c("shifted", "Kshirsagar"), ...)
dmvt(x, delta = rep(0, p), sigma = diag(p), df = 1, log = TRUE,
     type = "shifted", checkSymmetry = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mvt_+3A_x">x</code></td>
<td>
<p>vector or matrix of quantiles. If <code>x</code> is a matrix, each
row is taken to be a quantile.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_delta">delta</code></td>
<td>
<p>the vector of noncentrality parameters of length n, for
<code>type = "shifted"</code> delta specifies the mode.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_sigma">sigma</code></td>
<td>
<p>scale matrix, defaults to
<code>diag(ncol(x))</code>.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_df">df</code></td>
<td>
<p>degrees of freedom. <code>df = 0</code> or <code>df = Inf</code>
corresponds to the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether densities <code class="reqn">d</code>
are given as <code class="reqn">\log(d)</code>.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_type">type</code></td>
<td>
<p>type of the noncentral multivariate <code class="reqn">t</code> distribution.
<code>type = "Kshirsagar"</code> corresponds
to formula (1.4) in Genz and Bretz (2009) (see also
Chapter 5.1 in Kotz and Nadarajah (2004)). This is the
noncentral t-distribution  needed for calculating
the power of multiple contrast tests under a normality
assumption. <code>type = "shifted"</code> corresponds to the
formula right before formula (1.4) in Genz and Bretz (2009)
(see also formula (1.1) in Kotz and Nadarajah (2004)). It
is a location shifted version of the central t-distribution.
This noncentral multivariate <code class="reqn">t</code> distribution appears for
example as the Bayesian posterior distribution
for the regression coefficients in a linear regression.
In the central case both types coincide.
Note that the defaults differ from the default
in <code><a href="#topic+pmvt">pmvt</a>()</code> (for reasons of backward
compatibility).</p>
</td></tr>
<tr><td><code id="Mvt_+3A_checksymmetry">checkSymmetry</code></td>
<td>
<p>logical; if <code>FALSE</code>, skip checking whether the
covariance matrix is symmetric or not. This will speed up the
computation but may cause unexpected outputs when ill-behaved
<code>sigma</code> is provided. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Mvt_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+rmvnorm">rmvnorm</a>()</code>,
for example <code>method</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\bm{X}</code> denotes a random vector following a <code class="reqn">t</code> distribution
with location vector <code class="reqn">\bm{0}</code> and scale matrix
<code class="reqn">\Sigma</code> (written <code class="reqn">X\sim t_\nu(\bm{0},\Sigma)</code>), the scale matrix (the argument
<code>sigma</code>) is not equal to the covariance matrix <code class="reqn">Cov(\bm{X})</code>
of <code class="reqn">\bm{X}</code>. If the degrees of freedom <code class="reqn">\nu</code> (the
argument <code>df</code>) is larger than 2, then
<code class="reqn">Cov(\bm{X})=\Sigma\nu/(\nu-2)</code>. Furthermore,
in this case the correlation matrix <code class="reqn">Cor(\bm{X})</code> equals
the correlation matrix corresponding to the scale matrix
<code class="reqn">\Sigma</code> (which can be computed with
<code><a href="stats.html#topic+cov2cor">cov2cor</a>()</code>). Note that the scale matrix is sometimes
referred to as &ldquo;dispersion matrix&rdquo;;
see McNeil, Frey, Embrechts (2005, p. 74).
</p>
<p>For <code>type = "shifted"</code> the density
</p>
<p style="text-align: center;"><code class="reqn">c(1+(x-\delta)'S^{-1}(x-\delta)/\nu)^{-(\nu+m)/2}</code>
</p>

<p>is implemented, where
</p>
<p style="text-align: center;"><code class="reqn">c = \Gamma((\nu+m)/2)/((\pi \nu)^{m/2}\Gamma(\nu/2)|S|^{1/2}),</code>
</p>

<p><code class="reqn">S</code> is a positive definite symmetric matrix (the matrix
<code>sigma</code> above), <code class="reqn">\delta</code> is the
non-centrality vector and <code class="reqn">\nu</code> are the degrees of freedom.
</p>
<p><code>df=0</code> historically leads to the multivariate normal
distribution. From a mathematical point of view, rather
<code>df=Inf</code> corresponds to the multivariate normal
distribution. This is (now) also allowed for <code>rmvt()</code> and
<code>dmvt()</code>.
</p>
<p>Note that <code>dmvt()</code> has default <code>log = TRUE</code>, whereas
<code><a href="#topic+dmvnorm">dmvnorm</a>()</code> has default <code>log = FALSE</code>.
</p>


<h3>References</h3>

<p>McNeil, A. J., Frey, R., and Embrechts, P. (2005).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmvt">pmvt</a>()</code> and <code><a href="#topic+qmvt">qmvt</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## basic evaluation
dmvt(x = c(0,0), sigma = diag(2))

## check behavior for df=0 and df=Inf
x &lt;- c(1.23, 4.56)
mu &lt;- 1:2
Sigma &lt;- diag(2)
x0 &lt;- dmvt(x, delta = mu, sigma = Sigma, df = 0) # default log = TRUE!
x8 &lt;- dmvt(x, delta = mu, sigma = Sigma, df = Inf) # default log = TRUE!
xn &lt;- dmvnorm(x, mean = mu, sigma = Sigma, log = TRUE)
stopifnot(identical(x0, x8), identical(x0, xn))

## X ~ t_3(0, diag(2))
x &lt;- rmvt(100, sigma = diag(2), df = 3) # t_3(0, diag(2)) sample
plot(x)

## X ~ t_3(mu, Sigma)
n &lt;- 1000
mu &lt;- 1:2
Sigma &lt;- matrix(c(4, 2, 2, 3), ncol=2)
set.seed(271)
x &lt;- rep(mu, each=n) + rmvt(n, sigma=Sigma, df=3)
plot(x)

## Note that the call rmvt(n, mean=mu, sigma=Sigma, df=3) does *not*
## give a valid sample from t_3(mu, Sigma)! [and thus throws an error]
try(rmvt(n, mean=mu, sigma=Sigma, df=3))

## df=Inf correctly samples from a multivariate normal distribution
set.seed(271)
x &lt;- rep(mu, each=n) + rmvt(n, sigma=Sigma, df=Inf)
set.seed(271)
x. &lt;- rmvnorm(n, mean=mu, sigma=Sigma)
stopifnot(identical(x, x.))
</code></pre>

<hr>
<h2 id='pmvnorm'> Multivariate Normal Distribution </h2><span id='topic+pmvnorm'></span>

<h3>Description</h3>

<p>Computes the distribution function of the multivariate normal
distribution for arbitrary limits and correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvnorm(lower=-Inf, upper=Inf, mean=rep(0, length(lower)),
           corr=NULL, sigma=NULL, algorithm = GenzBretz(), keepAttr=TRUE, 
           seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvnorm_+3A_lower">lower</code></td>
<td>
<p> the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_upper">upper</code></td>
<td>
<p> the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length n.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_corr">corr</code></td>
<td>
<p> the correlation matrix of dimension n.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n less than 1000. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized internally. If <code>corr</code> is given,
it is assumed that appropriate standardization was performed
by the user.  If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="#topic+GenzBretz">GenzBretz</a></code>,
<code><a href="#topic+Miwa">Miwa</a></code> or <code><a href="#topic+TVPACK">TVPACK</a></code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_keepattr">keepAttr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if
<code><a href="base.html#topic+attributes">attributes</a></code> such as <code>error</code> and <code>msg</code> should be
attached to the return value.  The default, <code>TRUE</code> is back compatible.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="pmvnorm_+3A_...">...</code></td>
<td>
<p> additional parameters (currently given to <code><a href="#topic+GenzBretz">GenzBretz</a></code> for
backward compatibility issues). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program involves the computation of
multivariate normal probabilities with arbitrary correlation matrices.
It involves both the computation of singular and nonsingular
probabilities. The implemented methodology is described in
Genz (1992, 1993) (for algorithm GenzBretz), in Miwa et al. (2003)
for algorithm Miwa (useful up to dimension 20) and Genz (2004)
for the TVPACK algorithm (which covers 2- and 3-dimensional problems
for semi-infinite integration regions).
</p>
<p>Note the default algorithm GenzBretz is randomized and hence slightly depends on
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> and that both <code>-Inf</code> and <code>+Inf</code> may
be specified in <code>lower</code> and <code>upper</code>.  For more details see
<code><a href="#topic+pmvt">pmvt</a></code>.
</p>
<p>The multivariate normal
case is treated as a special case of <code><a href="#topic+pmvt">pmvt</a></code> with <code>df=0</code> and
univariate problems are passed to <code><a href="stats.html#topic+pnorm">pnorm</a></code>.
</p>
<p>The multivariate normal density and random deviates are available using
<code><a href="#topic+dmvnorm">dmvnorm</a></code> and <code><a href="#topic+rmvnorm">rmvnorm</a></code>.
</p>
<p><code>pmvnorm</code> is based on original implementations by Alan Genz, Frank
Bretz, and Tetsuhisa Miwa developed for computing accurate approximations to
the normal integral. Users interested in computing log-likelihoods involving
such normal probabilities should consider function <code><a href="#topic+lpmvnorm">lpmvnorm</a></code>,
which is more flexible and efficient for this task and comes with the
ability to evaluate score functions.
</p>


<h3>Value</h3>

<p>The evaluated distribution function is returned, if <code>keepAttr</code> is true, with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status message(s).</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string with <code>class(algorithm)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Genz, A. (1992). Numerical computation of multivariate normal probabilities.
<em>Journal of Computational and Graphical Statistics</em>, <b>1</b>, 141&ndash;150.
</p>
<p>Genz, A. (1993). Comparison of methods for the computation of multivariate
normal probabilities. <em>Computing Science and Statistics</em>, <b>25</b>,
400&ndash;405.
</p>
<p>Genz, A. (2004), Numerical computation of rectangular bivariate and
trivariate normal and t-probabilities, <em>Statistics and
Computing</em>, <b>14</b>, 251&ndash;260.
</p>
<p>Genz, A. and Bretz, F. (2009), <em>Computation of Multivariate Normal and
t Probabilities</em>. Lecture Notes in Statistics, Vol. 195. Springer-Verlag,
Heidelberg.
</p>
<p>Miwa, T., Hayter J. and Kuriki, S. (2003).
The evaluation of general non-centred orthant probabilities.
<em>Journal of the Royal Statistical Society</em>, Ser. B, 65, 223&ndash;234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmvnorm">qmvnorm</a></code> for quantiles and <code><a href="#topic+lpmvnorm">lpmvnorm</a></code> for
log-likelihoods.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5
mean &lt;- rep(0, 5)
lower &lt;- rep(-1, 5)
upper &lt;- rep(3, 5)
corr &lt;- diag(5)
corr[lower.tri(corr)] &lt;- 0.5
corr[upper.tri(corr)] &lt;- 0.5
prob &lt;- pmvnorm(lower, upper, mean, corr)
print(prob)

stopifnot(pmvnorm(lower=-Inf, upper=3, mean=0, sigma=1) == pnorm(3))

a &lt;- pmvnorm(lower=-Inf,upper=c(.3,.5),mean=c(2,4),diag(2))

stopifnot(round(a,16) == round(prod(pnorm(c(.3,.5),c(2,4))),16))

a &lt;- pmvnorm(lower=-Inf,upper=c(.3,.5,1),mean=c(2,4,1),diag(3))

stopifnot(round(a,16) == round(prod(pnorm(c(.3,.5,1),c(2,4,1))),16))

# Example from R News paper (original by Genz, 1992):

m &lt;- 3
sigma &lt;- diag(3)
sigma[2,1] &lt;- 3/5
sigma[3,1] &lt;- 1/3
sigma[3,2] &lt;- 11/15
pmvnorm(lower=rep(-Inf, m), upper=c(1,4,2), mean=rep(0, m), corr=sigma)

# Correlation and Covariance

a &lt;- pmvnorm(lower=-Inf, upper=c(2,2), sigma = diag(2)*2)
b &lt;- pmvnorm(lower=-Inf, upper=c(2,2)/sqrt(2), corr=diag(2))
stopifnot(all.equal(round(a,5) , round(b, 5)))

</code></pre>

<hr>
<h2 id='pmvt'> Multivariate t Distribution </h2><span id='topic+pmvt'></span>

<h3>Description</h3>

<p>Computes the the distribution function of the multivariate t distribution
for arbitrary limits, degrees of freedom and correlation matrices
based on algorithms by Genz and Bretz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvt(lower=-Inf, upper=Inf, delta=rep(0, length(lower)),
     df=1, corr=NULL, sigma=NULL, algorithm = GenzBretz(),
     type = c("Kshirsagar", "shifted"), keepAttr=TRUE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvt_+3A_lower">lower</code></td>
<td>
<p> the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_upper">upper</code></td>
<td>
<p> the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_delta">delta</code></td>
<td>
<p> the vector of noncentrality parameters of length n, for
<code>type = "shifted"</code> delta specifies the mode.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_df">df</code></td>
<td>
<p> degree of freedom as integer. Normal probabilities are computed for <code>df=0</code>.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_corr">corr</code></td>
<td>
<p> the correlation matrix of dimension n.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_sigma">sigma</code></td>
<td>
<p> the scale matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized internally. If <code>corr</code> is given,
it is assumed that appropriate standardization was performed
by the user. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="pmvt_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="#topic+GenzBretz">GenzBretz</a></code> or
<code><a href="#topic+TVPACK">TVPACK</a></code> defining the hyper parameters of this algorithm.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_type">type</code></td>
<td>
<p> type of the noncentral multivariate t distribution
to be computed. The choice <code>type = "Kshirsagar"</code> corresponds
to formula (1.4) in Genz and Bretz (2009) (see also
Chapter 5.1 in Kotz and Nadarajah (2004)). This is the
noncentral t-distribution needed for calculating
the power of multiple contrast tests under a normality
assumption. <code>type = "shifted"</code> corresponds to the
formula right before formula (1.4) in Genz and Bretz (2009)
(see also formula (1.1) in Kotz and Nadarajah (2004)). It
is a location shifted version of the central
t-distribution. This noncentral multivariate t distribution appears for
example as the Bayesian posterior distribution
for the regression coefficients in a linear regression.
In the central case both types coincide.
</p>
</td></tr>
<tr><td><code id="pmvt_+3A_keepattr">keepAttr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if
<code><a href="base.html#topic+attributes">attributes</a></code> such as <code>error</code> and <code>msg</code> should be
attached to the return value.  The default, <code>TRUE</code> is back compatible.</p>
</td></tr>
<tr><td><code id="pmvt_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code><a href="stats.html#topic+simulate">simulate</a></code>. </p>
</td></tr>
<tr><td><code id="pmvt_+3A_...">...</code></td>
<td>
<p>additional parameters (currently given to <code>GenzBretz</code> for
backward compatibility issues). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function involves the computation of central and noncentral
multivariate t-probabilities with arbitrary correlation matrices.
It involves both the computation of singular and nonsingular
probabilities.  The methodology (for default <code>algorithm =
  GenzBretz()</code>) is based on randomized quasi Monte Carlo methods and
described in Genz and Bretz (1999, 2002).
<br />
Because of the randomization, the result for this algorithm (slightly)
depends on <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>.
</p>
<p>For 2- and 3-dimensional problems one can also use the <code><a href="#topic+TVPACK">TVPACK</a></code> routines
described by Genz (2004), which only handles semi-infinite integration
regions (and for <code>type = "Kshirsagar"</code> only central problems).
</p>
<p>For <code>type = "Kshirsagar"</code> and a given correlation matrix
<code>corr</code>, for short <code class="reqn">A</code>, say, (which has to be positive
semi-definite) and degrees of freedom <code class="reqn">\nu</code> the following values are
numerically evaluated
</p>
<p style="text-align: center;"><code class="reqn">I = 2^{1-\nu/2} / \Gamma(\nu/2) \int_0^\infty s^{\nu-1} \exp(-s^2/2) \Phi(s \cdot lower/\sqrt{\nu} - \delta,
  s \cdot upper/\sqrt{\nu} - \delta) \, ds </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\Phi(a,b) = (det(A)(2\pi)^m)^{-1/2} \int_a^b \exp(-x^\prime Ax/2) \, dx</code>
</p>

<p>is the multivariate normal distribution and <code class="reqn">m</code> is the number of rows of
<code class="reqn">A</code>.
</p>
<p>For <code>type = "shifted"</code>, a positive definite symmetric matrix
<code class="reqn">S</code> (which might be the correlation or the scale matrix),
mode (vector) <code class="reqn">\delta</code> and degrees of freedom <code class="reqn">\nu</code> the
following integral is evaluated:
</p>
<p style="text-align: center;"><code class="reqn">c\int_{lower_1}^{upper_1}...\int_{lower_m}^{upper_m}
  (1+(x-\delta)'S^{-1}(x-\delta)/\nu)^{-(\nu+m)/2}\, dx_1 ... dx_m,
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">c = \Gamma((\nu+m)/2)/((\pi \nu)^{m/2}\Gamma(\nu/2)|S|^{1/2}),</code>
</p>

<p>and <code class="reqn">m</code> is the number of rows of <code class="reqn">S</code>.
</p>
<p>Note that both <code>-Inf</code> and <code>+Inf</code> may be specified in
the lower and upper integral limits in order to compute one-sided
probabilities.
</p>
<p>Univariate problems are passed to <code><a href="stats.html#topic+pt">pt</a></code>.
If <code>df = 0</code>, normal probabilities are returned.
</p>


<h3>Value</h3>

<p>The evaluated distribution function is returned, if <code>keepAttr</code> is true, with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error and</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status message (a <code><a href="base.html#topic+character">character</a></code> string).</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string with <code>class(algorithm)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Genz, A. and Bretz, F. (1999), Numerical computation of multivariate
t-probabilities with application to power calculation of multiple
contrasts. <em>Journal of Statistical Computation and Simulation</em>,
<b>63</b>, 361&ndash;378.
</p>
<p>Genz, A. and Bretz, F. (2002), Methods for the computation of multivariate
t-probabilities. <em>Journal of Computational and Graphical Statistics</em>,
<b>11</b>, 950&ndash;971.
</p>
<p>Genz, A. (2004), Numerical computation of rectangular bivariate and
trivariate normal and t-probabilities, <em>Statistics and
Computing</em>, <b>14</b>, 251&ndash;260.
</p>
<p>Genz, A. and Bretz, F. (2009), <em>Computation of Multivariate Normal and
t Probabilities</em>. Lecture Notes in Statistics, Vol. 195. Springer-Verlag,
Heidelberg.
</p>
<p>S. Kotz and S. Nadarajah (2004), <em>Multivariate t Distributions and
Their Applications</em>. Cambridge University Press. Cambridge.
</p>
<p>Edwards D. and Berry, Jack J. (1987), The efficiency of simulation-based
multiple comparisons. <em>Biometrics</em>, <b>43</b>, 913&ndash;928.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qmvt">qmvt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5
lower &lt;- -1
upper &lt;- 3
df &lt;- 4
corr &lt;- diag(5)
corr[lower.tri(corr)] &lt;- 0.5
delta &lt;- rep(0, 5)
prob &lt;- pmvt(lower=lower, upper=upper, delta=delta, df=df, corr=corr)
print(prob)

pmvt(lower=-Inf, upper=3, df = 3, sigma = 1) == pt(3, 3)

# Example from R News paper (original by Edwards and Berry, 1987)

n &lt;- c(26, 24, 20, 33, 32)
V &lt;- diag(1/n)
df &lt;- 130
C &lt;- c(1,1,1,0,0,-1,0,0,1,0,0,-1,0,0,1,0,0,0,-1,-1,0,0,-1,0,0)
C &lt;- matrix(C, ncol=5)
### scale matrix
cv &lt;- C %*% tcrossprod(V, C)
### correlation matrix
cr &lt;- cov2cor(cv)
delta &lt;- rep(0,5)

myfct &lt;- function(q, alpha) {
  lower &lt;- rep(-q, ncol(cv))
  upper &lt;- rep(q, ncol(cv))
  pmvt(lower=lower, upper=upper, delta=delta, df=df,
       corr=cr, abseps=0.0001) - alpha
}

### uniroot for this simple problem
round(uniroot(myfct, lower=1, upper=5, alpha=0.95)$root, 3)

# compare pmvt and pmvnorm for large df:

a &lt;- pmvnorm(lower=-Inf, upper=1, mean=rep(0, 5), corr=diag(5))
b &lt;- pmvt(lower=-Inf, upper=1, delta=rep(0, 5), df=300,
          corr=diag(5))
a
b

stopifnot(round(a, 2) == round(b, 2))

# correlation and scale matrix

a &lt;- pmvt(lower=-Inf, upper=2, delta=rep(0,5), df=3,
          sigma = diag(5)*2)
b &lt;- pmvt(lower=-Inf, upper=2/sqrt(2), delta=rep(0,5),
          df=3, corr=diag(5))
attributes(a) &lt;- NULL
attributes(b) &lt;- NULL
a
b
stopifnot(all.equal(round(a,3) , round(b, 3)))

a &lt;- pmvt(0, 1,df=10)
attributes(a) &lt;- NULL
b &lt;- pt(1, df=10) - pt(0, df=10)
stopifnot(all.equal(round(a,10) , round(b, 10)))

</code></pre>

<hr>
<h2 id='qmvnorm'> Quantiles of the Multivariate Normal Distribution </h2><span id='topic+qmvnorm'></span>

<h3>Description</h3>

<p>Computes the equicoordinate quantile function of the multivariate normal
distribution for arbitrary correlation matrices
based on inversion of <code><a href="#topic+pmvnorm">pmvnorm</a></code>, using a stochastic root
finding algorithm described in Bornkamp (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmvnorm(p, interval = NULL, tail = c("lower.tail", "upper.tail", "both.tails"), 
        mean = 0, corr = NULL, sigma = NULL, algorithm = GenzBretz(),
        ptol = 0.001, maxiter = 500, trace = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmvnorm_+3A_p">p</code></td>
<td>
<p> probability.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_interval">interval</code></td>
<td>
<p> optional, a vector containing the end-points of the
interval to be searched. Does not need to contain the true quantile,
just used as starting values by the root-finder. If equal to NULL
a guess is used.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_tail">tail</code></td>
<td>
<p> specifies which quantiles should be computed.
<code>lower.tail</code> gives the quantile <code class="reqn">x</code> for which 
<code class="reqn">P[X \le x] = p</code>, <code>upper.tail</code> gives <code class="reqn">x</code> with 
<code class="reqn">P[X &gt; x] = p</code> and 
<code>both.tails</code> leads to <code class="reqn">x</code> 
with <code class="reqn">P[-x \le X \le x] = p</code>.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_mean">mean</code></td>
<td>
<p> the mean vector of length n. </p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_corr">corr</code></td>
<td>
<p> the correlation matrix of dimension n.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized internally. If <code>corr</code> is given,
it is assumed that appropriate standardization was performed
by the user. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix is used
for <code>sigma</code>. </p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="#topic+GenzBretz">GenzBretz</a></code>,
<code><a href="#topic+Miwa">Miwa</a></code> or <code><a href="#topic+TVPACK">TVPACK</a></code>
specifying both the algorithm to be used as well as
the associated hyper parameters.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_ptol">ptol</code>, <code id="qmvnorm_+3A_maxiter">maxiter</code>, <code id="qmvnorm_+3A_trace">trace</code></td>
<td>
<p>Parameters passed to the stochastic root-finding
algorithm. Iteration stops when the 95% confidence interval
for the predicted quantile is inside [p-ptol, p+ptol]. <code>maxiter</code> is the
maximum number of iterations for the root finding algorithm. <code>trace</code>
prints the iterations of the root finder.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="qmvnorm_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to 
<code><a href="#topic+GenzBretz">GenzBretz</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only equicoordinate quantiles are computed, i.e., the quantiles in each
dimension coincide. The result is seed dependend.
</p>


<h3>Value</h3>

<p>A list with two components: <code>quantile</code> and <code>f.quantile</code> 
give the location of the quantile and the difference between the distribution
function evaluated at the quantile and <code>p</code>. 
</p>


<h3>References</h3>

<p>Bornkamp, B. (2018). Calculating quantiles of noisy distribution
functions using local linear regressions. <em>Computational
Statistics</em>, <b>33</b>, 487&ndash;501.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmvnorm">pmvnorm</a></code>, <code><a href="#topic+qmvt">qmvt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>qmvnorm(0.95, sigma = diag(2), tail = "both")
</code></pre>

<hr>
<h2 id='qmvt'> Quantiles of the Multivariate t Distribution </h2><span id='topic+qmvt'></span>

<h3>Description</h3>

<p>Computes the equicoordinate quantile function of the multivariate t
distribution for arbitrary correlation matrices
based on inversion of <code><a href="#topic+pmvt">pmvt</a></code>, using a stochastic root
finding algorithm described in Bornkamp (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmvt(p, interval = NULL, tail = c("lower.tail", "upper.tail", "both.tails"), 
     df = 1, delta = 0, corr = NULL, sigma = NULL, algorithm = GenzBretz(),
     type = c("Kshirsagar", "shifted"), ptol = 0.001, maxiter = 500, 
     trace = FALSE, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmvt_+3A_p">p</code></td>
<td>
<p> probability.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_interval">interval</code></td>
<td>
<p> optional, a vector containing the end-points of the
interval to be searched. Does not need to contain the true quantile,
just used as starting values by the root-finder. If equal to NULL
a guess is used.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_tail">tail</code></td>
<td>
<p> specifies which quantiles should be computed.
<code>lower.tail</code> gives the quantile <code class="reqn">x</code> for which
<code class="reqn">P[X \le x] = p</code>, <code>upper.tail</code> gives <code class="reqn">x</code> with
<code class="reqn">P[X &gt; x] = p</code> and
<code>both.tails</code> leads to <code class="reqn">x</code>
with <code class="reqn">P[-x \le X \le x] = p</code>.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_delta">delta</code></td>
<td>
<p> the vector of noncentrality parameters of length n, for
<code>type = "shifted"</code> delta specifies the mode.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_df">df</code></td>
<td>
<p> degree of freedom as integer. Normal quantiles are computed
for <code>df = 0</code> or <code>df = Inf</code>.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_corr">corr</code></td>
<td>
<p> the correlation matrix of dimension n.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_sigma">sigma</code></td>
<td>
<p> the covariance matrix of dimension n. Either <code>corr</code> or
<code>sigma</code> can be specified. If <code>sigma</code> is given, the
problem is standardized internally. If <code>corr</code> is given,
it is assumed that appropriate standardization was performed
by the user. If neither <code>corr</code> nor
<code>sigma</code> is given, the identity matrix in the univariate
case (so <code>corr = 1</code>) is used for <code>corr</code>. </p>
</td></tr>
<tr><td><code id="qmvt_+3A_algorithm">algorithm</code></td>
<td>
<p> an object of class <code><a href="#topic+GenzBretz">GenzBretz</a></code> or
<code><a href="#topic+TVPACK">TVPACK</a></code> defining the
hyper parameters of this algorithm.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_type">type</code></td>
<td>
<p>type of the noncentral multivariate t distribution
to be computed. The choice <code>type = "Kshirsagar"</code> corresponds
to formula (1.4) in Genz and Bretz (2009) (see also
Chapter 5.1 in Kotz and Nadarajah (2004)) and
<code>type = "shifted"</code> corresponds to the formula before
formula (1.4) in Genz and Bretz (2009)
(see also formula (1.1) in Kotz and Nadarajah (2004)). </p>
</td></tr>
<tr><td><code id="qmvt_+3A_ptol">ptol</code>, <code id="qmvt_+3A_maxiter">maxiter</code>, <code id="qmvt_+3A_trace">trace</code></td>
<td>
<p>Parameters passed to the stochastic root-finding
algorithm. Iteration stops when the 95% confidence interval
for the predicted quantile is inside [p-ptol, p+ptol]. <code>maxiter</code> is the
maximum number of iterations for the root finding algorithm. <code>trace</code>
prints the iterations of the root finder.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator
should be initialized, see <code><a href="stats.html#topic+simulate">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="qmvt_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to
<code><a href="#topic+GenzBretz">GenzBretz</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only equicoordinate quantiles are computed, i.e., the quantiles in each
dimension coincide. The result is seed dependend.
</p>


<h3>Value</h3>

<p>A list with two components: <code>quantile</code> and <code>f.quantile</code> 
give the location of the quantile and the difference between the distribution
function evaluated at the quantile and <code>p</code>.
</p>


<h3>References</h3>

<p>Bornkamp, B. (2018). Calculating quantiles of noisy distribution
functions using local linear regressions. <em>Computational
Statistics</em>, <b>33</b>, 487&ndash;501.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmvnorm">pmvnorm</a></code>, <code><a href="#topic+qmvnorm">qmvnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## basic evaluation
qmvt(0.95, df = 16, tail = "both")

## check behavior for df=0 and df=Inf
Sigma &lt;- diag(2)
set.seed(29)
q0 &lt;- qmvt(0.95, sigma = Sigma, df = 0,   tail = "both")$quantile
set.seed(29)
q8 &lt;- qmvt(0.95, sigma = Sigma, df = Inf, tail = "both")$quantile
set.seed(29)
qn &lt;- qmvnorm(0.95, sigma = Sigma, tail = "both")$quantile
stopifnot(identical(q0, q8),
          isTRUE(all.equal(q0, qn, tol = (.Machine$double.eps)^(1/3))))

## if neither sigma nor corr are provided, corr = 1 is used internally
df &lt;- 0
set.seed(29)
qt95 &lt;- qmvt(0.95, df = df, tail = "both")$quantile
set.seed(29)
qt95.c &lt;- qmvt(0.95, df = df, corr  = 1, tail = "both")$quantile
set.seed(29)
qt95.s &lt;- qmvt(0.95, df = df, sigma = 1, tail = "both")$quantile
stopifnot(identical(qt95, qt95.c),
          identical(qt95, qt95.s))

df &lt;- 4
set.seed(29)
qt95 &lt;- qmvt(0.95, df = df, tail = "both")$quantile
set.seed(29)
qt95.c &lt;- qmvt(0.95, df = df, corr  = 1, tail = "both")$quantile
set.seed(29)
qt95.s &lt;- qmvt(0.95, df = df, sigma = 1, tail = "both")$quantile
stopifnot(identical(qt95, qt95.c),
          identical(qt95, qt95.s))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
