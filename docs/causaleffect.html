<!DOCTYPE html><html><head><title>Help for package causaleffect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {causaleffect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aux.effect'><p>Identify a causal effect using surrogate experiments</p></a></li>
<li><a href='#causal.effect'><p>Identify a causal effect</p></a></li>
<li><a href='#causaleffect-package'><p>Deriving Expressions of Joint Interventional Distributions and Transport Formulas in Causal Models</p></a></li>
<li><a href='#generalize'><p>Derive a transport formula for a causal effect between a target domain and multiple source domains with limited experiments</p></a></li>
<li><a href='#get.expression'><p>Get the expression of a probability object</p></a></li>
<li><a href='#meta.transport'><p>Derive a transport formula for a causal effect between a target domain and multiple source domains</p></a></li>
<li><a href='#parse.graphml'><p>Prepare GraphML files for internal use</p></a></li>
<li><a href='#recover'><p>Recover a causal effect from selection bias</p></a></li>
<li><a href='#surrogate.outcome'><p>Derive a formula for a causal effect using surrogate outcomes</p></a></li>
<li><a href='#transport'><p>Derive a transport formula for a causal effect between two domains</p></a></li>
<li><a href='#verma.constraints'><p>Find Verma constraints for a given graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.15</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Deriving Expressions of Joint Interventional Distributions and
Transport Formulas in Causal Models</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/santikka/causaleffect/">https://github.com/santikka/causaleffect/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for identification and transportation of causal effects. Provides a conditional causal effect identification algorithm (IDC) by Shpitser, I. and Pearl, J. (2006) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r329-uai.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r329-uai.pdf</a>, an algorithm for transportability from multiple domains with limited experiments by Bareinboim, E. and Pearl, J. (2014) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r443.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r443.pdf</a>, and a selection bias recovery algorithm by Bareinboim, E. and Tian, J. (2015) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r445.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r445.pdf</a>. All of the previously mentioned algorithms are based on a causal effect identification algorithm by Tian , J. (2002) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r309.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r309.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, XML</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Santtu Tikka <a href="https://orcid.org/0000-0003-4039-4342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santtu Tikka &lt;santtuth@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-14 08:19:06 UTC; Santtu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-14 09:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aux.effect'>Identify a causal effect using surrogate experiments</h2><span id='topic+aux.effect'></span>

<h3>Description</h3>

<p>This function returns an expression for the joint distribution of the set of variables (<code>y</code>)
given the intervention on the set of variables (<code>x</code>) using auxiliary experiments on a set (<code>z</code>) if the effect is identifiable.  Otherwise
an error is thrown describing the graphical structure that witnesses non-identifiability. </p>


<h3>Usage</h3>

<pre><code class='language-R'>aux.effect(y, x, z, G, expr = TRUE, simp = TRUE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux.effect_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_z">z</code></td>
<td>
<p>A character vector describing the additional set available for manipulation. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_g">G</code></td>
<td>
<p>An <code>igraph</code> object describing the directed acyclic graph induced by the causal model that matches the internal syntax. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="aux.effect_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the causal effect and the second to the a list describing intermediary steps taken by the algorithm. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="aux.effect_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the interventional distribution. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2012 Causal Inference by Surrogate Experiments: z-identifiability. <em>Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence</em>, 113&ndash;120.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+get.expression">get.expression</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# simplify = FALSE to allow multiple edges
f &lt;- graph.formula(W -+ Z, Z -+ X, X -+ Y, W -+ Y, # Observed edges
  W -+ Y, Y -+ W, Z -+ Y, Y -+ Z, Z -+ X, X -+ Z, simplify = FALSE)

# Here the bidirected edges are set to be unobserved in graph g
# This is denoted by giving them a description attribute with the value "U"
# The first 4 edges correspond to the observed edges, the rest are unobserved

f &lt;- set.edge.attribute(f, "description", 5:10, "U")
aux.effect(y = "Y", x = "X", z = "Z", G = f)
</code></pre>

<hr>
<h2 id='causal.effect'>Identify a causal effect</h2><span id='topic+causal.effect'></span>

<h3>Description</h3>

<p>This function returns an expression for the joint distribution of the set of variables (<code>y</code>)
given the intervention on the set of variables (<code>x</code>) conditional on (<code>z</code>) if the effect is identifiable.  Otherwise
an error is thrown describing the graphical structure that witnesses non-identifiability.  If <code>steps = TRUE</code>, returns instead
a list where the first element is the expression and the second element is a list of the intermediary steps taken by the algorithm.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>causal.effect(y, x, z = NULL, G, expr = TRUE, simp = FALSE, 
  steps = FALSE, primes = FALSE, prune = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causal.effect_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_z">z</code></td>
<td>
<p>A character vector of the conditioning variables. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_g">G</code></td>
<td>
<p>An <code>igraph</code> object describing the directed acyclic graph induced by the causal model that matches the internal syntax. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code>. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the causal effect and the second to the a list describing intermediary steps taken by the algorithm.</p>
</td></tr>
<tr><td><code id="causal.effect_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_prune">prune</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, additional steps are taken to remove variables that are not necessary for identification. </p>
</td></tr>
<tr><td><code id="causal.effect_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the interventional distribution. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Shpitser I., Pearl J. 2006 Identification of Joint Interventional Distributions in Recursive semi-Markovian Causal Models.
<em>Proceedings of the 21st National Conference on Artificial Intelligence</em>, <b>2</b>, 1219&ndash;1226. 
</p>
<p>Shpitser I., Pearl J. 2006 Identification of Conditional Interventional Distributions. 
<em>Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence</em>, 427&ndash;444. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+get.expression">get.expression</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# simplify = FALSE to allow multiple edges
g &lt;- graph.formula(x -+ y, z -+ x, z -+ y , x -+ z, z -+ x, simplify = FALSE)

# Here the bidirected edge between X and Z is set to be unobserved in graph g
# This is denoted by giving them a description attribute with the value "U"
# The edges in question are the fourth and the fifth edge
g &lt;- set.edge.attribute(graph = g, name = "description", index = c(4,5), value = "U")
causal.effect("y", "x", G = g)

# Pruning example
p &lt;- graph.formula(x -+ z_4, z_4 -+ y, z_1 -+ x, z_2 -+ z_1, 
  z_3 -+ z_2, z_3 -+ x, z_5 -+ z_1, z_5 -+ z_4, x -+ z_2, z_2 -+ x, 
  z_3 -+ z_2, z_2 -+ z_3, z_2 -+ y, y -+ z_2,
  z_4 -+ y, y -+ z_4, z_5 -+ z_4, z_4 -+ z_5, simplify = FALSE)
p &lt;- set.edge.attribute(p, "description", 9:18, "U")
causal.effect("y", "x", G = p, primes = TRUE, prune = TRUE)

# Simplification example
s &lt;- graph.formula(x -+ y, w -+ x, w -+ z, z -+ y)
causal.effect("y", "x", G = s, simp = FALSE)
causal.effect("y", "x", G = s, simp = TRUE)
</code></pre>

<hr>
<h2 id='causaleffect-package'>Deriving Expressions of Joint Interventional Distributions and Transport Formulas in Causal Models</h2><span id='topic+causaleffect-package'></span><span id='topic+causaleffect'></span>

<h3>Description</h3>

<p>Do-calculus is concerned with estimating the interventional distribution of some action from the observed
joint probability distribution of the variables in a given causal structure.
All identifiable causal effects can be derived using the rules of do-calculus, but
the rules themselves do not give any direct indication whether the effect in question is identifiable or not.
Shpitser and Pearl (2006a) constructed an algorithm for identifying joint interventional distributions in causal models, which contain unobserved variables and induce directed acyclic graphs.
A highly similar algorithm was constructed earlier by Tian (2002).
The algorithm of Shpitser and Pearl (2006a) can be seen as a repeated application of the rules of do-calculus and known properties of probabilities,
and it ultimately either derives an expression for the causal distribution or fails to identify the effect, in which case
the effect is unidentifiable. Shpitser and Pearl (2006b) also presented a generalized algorithm for identification of conditional causal effects.
causaleffect provides an implementation of this algorithm.
In addition to ordinary identifiability, implementations of several other algorithms in causal inference are provided. These include algorithms for
z-identifiability, transportability, z-transportability and meta-transportability of causal effects by Bareinboim and Pearl (2012, 2013a, 2013b, 2013c).
Recently, many of these algorithms were combined under a single algorithm by Bareinboim and Pearl (2014), which is also provided along with
an implementation of an algorithm for recovering from selection bias by Bareinboim and Tian (2015).
</p>


<h3>Graphs</h3>

<p>Every causal model and selection diagram is depicted as an igraph graph with distinct attributes and special notation. Any bidirected edge corresponding to an unobserved variable must be denoted by using two unidirected edges with a <code>description</code> attribute of value <code>"U"</code>. Here is an example describing a simple causal model with only two vertices, X and Y, and a bidirected edge between them.
</p>
<pre>
&gt; g &lt;- graph.formula(X -+ Y, Y -+ X)
&gt; g &lt;- set.edge.attribute(graph = g, 
+ name = "description", index = 1:2, value = "U")
</pre>
<p>For selection diagrams, the vertices that correspond to selection variables must have a <code>description</code> attribute of value <code>"S"</code>. Here is an example of a simple selection diagram with a selection node S pointing to a non-selection variable Y. Because S precedes Y in the &quot;-+&quot; notation, S is given index 1 in the vertex sequence.
</p>
<pre>
&gt; d &lt;- graph.formula(S -+ Y)
&gt; d &lt;- set.vertex.attribute(graph = d, 
+ name = "description", index = 1, value = "S")
</pre>


<h3>Author(s)</h3>

<p>Santtu Tikka &lt;santtuth@gmail.com&gt;</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2012 Causal Inference by Surrogate Experiments: z-identifiability. <em>Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence</em>, 113&ndash;120.
</p>
<p>Bareinboim E., Pearl J. 2013a A General Algorithm for Deciding Transportability of Experimental Results. <em>Journal of Causal Inference</em>, <b>1</b>, 107&ndash;134.
</p>
<p>Bareinboim E., Pearl J. 2013b Meta-Transportability of Causal Effects: A Formal Approach. <em>Proceedings of the 16th International Conference on Artificial Intelligence and Statistics</em>, 135&ndash;143.
</p>
<p>Bareinboim E., Pearl J. 2013c Causal Transportability with Limited Experiments. <em>Proceedings of the 27th AAAI Conference on Artificial Intelligence</em>, 95&ndash;101. 
</p>
<p>Bareinboim E., Pearl J. 2014 Transportability from Multiple Environments with Limited Experiments: Completeness Results. <em>Proceedings of the 27th Annual Conference on Neural Information Processing Systems</em>, 280&ndash;288.
</p>
<p>Bareinboim E., Tian J. 2015 Recovering Causal Effects From Selection Bias. <em>In Proceedings of the 29th AAAI Conference on Artificial Intelligence</em>, 3475&ndash;3481.
</p>
<p>Pearl J. 2009 <em>Causality: Models, Reasoning and Inference</em>, New York: Cambridge University Press. 
</p>
<p>Shpitser I., Pearl J. 2006a Identification of Joint Interventional Distributions in Recursive semi-Markovian Causal Models. <em>Proceedings of the 21st National Conference on Artificial Intelligence</em>, <b>2</b>, 1219&ndash;1226. 
</p>
<p>Shpitser I., Pearl J. 2006b Identification of Conditional Interventional Distributions. <em>Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence</em>, 427&ndash;444.
</p>
<p>Tian J. 2002 Studies in Causal Reasoning and Learning. PhD thesis, Department of Computer Science, University of California, Los Angeles.
</p>
<p>Tian, J., Pearl J. 2002 On Testable Implications of Causal Models with Hidden variables. <em>Proceedings of the Eighteenth Conference on Uncertainty in Artificial Intelligence</em>, 519&ndash;527.
</p>
<p>Tikka, S., Karvanen J. 2017 Identifying Causal Effects with the R Package causaleffect. Journal of Statistical Software, <b>76(12)</b>, 1&ndash;30.
</p>
<p>Tikka, S., Karvanen J. 2017 Simplifying Probabilistic Expressions in Causal Inference. Journal of Machine Learning Research, <b>18(36)</b>, 1&ndash;30.
</p>
<p>Tikka, S., Karvanen J. 2018 Enhancing Identification of Causal Effects by Pruning. Journal of Machine Learning Research, <b>18(194)</b>, 1&ndash;23.
</p>

<hr>
<h2 id='generalize'>Derive a transport formula for a causal effect between a target domain and multiple source domains with limited experiments</h2><span id='topic+generalize'></span>

<h3>Description</h3>

<p>This function returns an expression for the transport formula of a causal effect between a target domain and multiple source domains with limited experiments. The formula is returned for the interventional distribution of the set of variables (<code>y</code>) given the intervention on the set of variables (<code>x</code>). Available experiments are depicted by a list (<code>Z</code>) where the first element describes the elements available at the target and the rest at the sources. The multiple domains are given as a list (<code>D</code>) where the first element is the underlying causal diagram without selection variables, and the rest correspond to the selection diagrams. If the effect is non-transportable, an error is thrown describing the graphical structure that witnesses non-transportability. The vertices of any diagram in (<code>D</code>) that correspond to selection variables must have a description parameter of a single character &quot;S&quot; (shorthand for &quot;selection&quot;).  </p>


<h3>Usage</h3>

<pre><code class='language-R'>generalize(y, x, Z, D, expr = TRUE, simp = FALSE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalize_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="generalize_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="generalize_+3A_z">Z</code></td>
<td>
<p>A list of character vectors describing the available interventions at each domain. </p>
</td></tr>
<tr><td><code id="generalize_+3A_d">D</code></td>
<td>
<p>A list of <code>igraph</code> objects describing the selection diagrams in the internal syntax. </p>
</td></tr>
<tr><td><code id="generalize_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="generalize_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="generalize_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the transport formula and the second to the a list describing intermediary steps taken by the algorithm.</p>
</td></tr>
<tr><td><code id="generalize_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="generalize_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the transport formula. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2014 Transportability from Multiple Environments with Limited Experiments: Completeness Results. <em>Proceedings of the 27th Annual Conference on Neural Information Processing Systems</em>, 280&ndash;288.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aux.effect">aux.effect</a></code>, <code><a href="#topic+causal.effect">causal.effect</a></code>, <code><a href="#topic+get.expression">get.expression</a></code>, <code><a href="#topic+meta.transport">meta.transport</a></code>, <code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+recover">recover</a></code>, <code><a href="#topic+transport">transport</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# Selection diagram corresponding to the target domain (no selection variables).
# We set simplify = FALSE to allow multiple edges.
d1 &lt;-  graph.formula(Z_1 -+ X, Z_2 -+ X, X -+ Z_3, Z_3 -+ W,
 Z_3 -+ U, U -+ Y, W -+ U, Z_1 -+ Z_3, # Observed edges
 Z_1 -+ Z_2, Z_2 -+ Z_1, Z_1 -+ X, X -+ Z_1,
 Z_2 -+ Z_3, Z_3 -+ Z_2, Z_2 -+ U, U -+ Z_2,
 W -+ Y, Y -+ W, simplify = FALSE)

# Here the bidirected edges are set to be unobserved in the selection diagram d1.
# This is denoted by giving them a description attribute with the value "U".
# The first 8 edges are observed and the next 10 are unobserved.
d1 &lt;- set.edge.attribute(d1, "description", 9:18, "U")

# We can use the causal diagram d1 to create selection diagrams 
# for two source domains, a and b.
d1a &lt;- union(d1, graph.formula(S_1 -+ Z_2, S_2 -+ Z_3, S_3 -+ W))

# The variables "S_1", "S_2", and "S_3" are selection variables.
# This is denoted by giving them a description attribute with the value "S".
# The graph already has 7 vertices, so the last three depict the new ones.
d1a &lt;- set.vertex.attribute(d1a, "description", 8:10, "S")

# Selection diagram corresponding to the second 
# source domain is constructed in a similar fashion.
d1b &lt;- union(d1, graph.formula(S_1 -+ Z_1, S_2 -+ W, S_3 -+ U))
d1b &lt;- set.vertex.attribute(d1b, "description", 8:10, "S")

# We combine the diagrams as a list.
d.comb &lt;- list(d1, d1a, d1b)

# We still need the available experiments at each domain.
z &lt;- list(c("Z_1"), c("Z_2"), c("Z_1"))
# This denotes that the variable "Z_1" is available for intervention 
# in both the target domain, and the second source domain. 
# The variable "Z_2" is available for intervention in the first source domain.

generalize(y = "Y", x = "X", Z = z, D = d.comb)
</code></pre>

<hr>
<h2 id='get.expression'>Get the expression of a probability object</h2><span id='topic+get.expression'></span>

<h3>Description</h3>

<p>This function converts an object of class <code>probability</code> returned by <code>aux.effect</code>, <code>causal.effect</code>, <code>generalize</code>, <code>meta.transport</code>, <code>recover</code> or <code>transport</code> with <code>expr = FALSE</code> into a string which represents the probability distribution.  Currently only LaTeX syntax is available.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>get.expression(x, primes = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.expression_+3A_x">x</code></td>
<td>
<p>An object of class <code>probability</code> which is an internal list structure describing the interventional distribution.</p>
</td></tr>
<tr><td><code id="get.expression_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string that describes the resulting distribution in LaTeX syntax. </p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aux.effect">aux.effect</a></code>, <code><a href="#topic+causal.effect">causal.effect</a></code>, <code><a href="#topic+generalize">generalize</a></code>, <code><a href="#topic+meta.transport">meta.transport</a></code>, <code><a href="#topic+recover">recover</a></code>, <code><a href="#topic+transport">transport</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# simplify = FALSE to allow multiple edges
g &lt;- graph.formula(X -+ Y, Z -+ X, Z -+ Y , X -+ Z, Z -+ X, simplify = FALSE) 

# Here the bidirected edge between X and Z is set to be unobserved in graph g
# This is denoted by giving them a description attribute with the value "U"
# The edges in question are the fourth and the fifth edge
g &lt;- set.edge.attribute(graph = g, name = "description", index = c(4,5), value = "U") 

x &lt;- causal.effect(y = "Y", x = "X", z = NULL, G = g, expr = FALSE)
get.expression(x, primes = FALSE)
get.expression(x, primes = TRUE)
</code></pre>

<hr>
<h2 id='meta.transport'>Derive a transport formula for a causal effect between a target domain and multiple source domains</h2><span id='topic+meta.transport'></span>

<h3>Description</h3>

<p>This function returns an expression for the transport formula of a causal effect between a target domain and multiple source domains. The formula is returned for the interventional distribution of the set of variables (<code>y</code>) given the intervention on the set of variables (<code>x</code>). The multiple source domains are given as a list of selection diagrams (<code>D</code>). If the effect is non-transportable, an error is thrown describing the graphical structure that witnesses non-transportability. The vertices of any diagram in (<code>D</code>) that correspond to selection variables must have a description parameter of a single character &quot;S&quot; (shorthand for &quot;selection&quot;). </p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.transport(y, x, D, expr = TRUE, simp = TRUE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta.transport_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_d">D</code></td>
<td>
<p>A list of <code>igraph</code> objects describing the selection diagrams in the internal syntax. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="meta.transport_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the transport formula and the second to the a list describing intermediary steps taken by the algorithm. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="meta.transport_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the transport formula. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2013b Meta-Transportability of Causal Effects: A Formal Approach. <em>Proceedings of the 16th International Conference on Artificial Intelligence and
Statistics</em>, 135&ndash;143.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+get.expression">get.expression</a></code>, <code><a href="#topic+transport">transport</a></code>, <code><a href="#topic+generalize">generalize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# Selection diagram corresponding to the first source domain.
# We set simplify = FALSE to allow multiple edges.
d1 &lt;- graph.formula(X -+ Z, W_1 -+ W_2, W_2 -+ Z, 
  W_3 -+ Z, X -+ W_3, W_2 -+ X, Z -+ Y, # Observed edges
  S_1 -+ X, S_2 -+ W_2, S_3 -+ W_3, S_4 -+ Y, # Edges related to selection variables
  X -+ W_3, W_3 -+ X, X -+ W_2, W_2 -+ X, X -+ W_1, 
  W_1 -+ X, W_1 -+ Z, Z -+ W_1, simplify = FALSE)

# Here the bidirected edges are set to be unobserved in the selection diagram d1.
# This is denoted by giving them a description attribute with the value "U".
# The first 7 edges are observed and the next 4 are related to the selection variables.
# The rest of the edges are unobserved.
d1 &lt;- set.edge.attribute(d1, "description", 12:19, "U")

# The variables "S_1", "S_2", "S_3" and "S_4" are selection variables.
# This is denoted by giving them a description attribute with the value "S".
d1 &lt;- set.vertex.attribute(d1, "description", 7:10, "S")

# Selection diagram corresponding to the second 
# source domain is constructed in a similar fashion.
d2 &lt;- graph.formula(X -+ Z, W_1 -+ W_2, W_2 -+ Z, W_3 -+ Z, 
 X -+ W_3, W_2 -+ X, Z -+ Y, # Observed edges
 S_1 -+ X, S_2 -+ W_2, S_3 -+ W_1, 
 S_4 -+ Y, S_5 -+ Z, # Edges related to selection variables
 X -+ W_3, W_3 -+ X, X -+ W_2, W_2 -+ X, X -+ W_1, 
 W_1 -+ X, W_1 -+ Z, Z -+ W_1, simplify = FALSE)
d2 &lt;- set.edge.attribute(d2, "description", 13:20, "U")
d2 &lt;- set.vertex.attribute(d2, "description", 7:11, "S")

# We combine the diagrams as a list.
d.comb &lt;- list(d1, d2)
meta.transport(y = "Y", x = "X", D = d.comb)
</code></pre>

<hr>
<h2 id='parse.graphml'>Prepare GraphML files for internal use</h2><span id='topic+parse.graphml'></span>

<h3>Description</h3>

<p>This function reads GraphML files created by a graphical editor, which describe directed acyclic graphs. The R package XML is utilized to parse the contents of the files to suit the internal format used by causal inference functions. Bidirected arcs are replaced by two unobserved directed arcs, and the resulting XML file is coerced into an igraph object. This function also serves as a wrapper for files that already correspond to the internal format. Names for the nodes of the graph can be supplied or read directly from the input file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.graphml(file, format = c("standard", "internal"), 
  nodes = c(), use.names = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.graphml_+3A_file">file</code></td>
<td>
<p>The connection to read from. </p>
</td></tr>
<tr><td><code id="parse.graphml_+3A_format">format</code></td>
<td>

<p>A character constant describing how bidirected arcs are denoted in the GraphML file.
Option <code>standard</code> corresponds to bidirected arcs that are notated with a graphical parameter describing an arrow at each end of the arc or no arrows at all.
Option <code>internal</code> matches the format that <code>standard</code> graphs are coerced into. This option should be used only if all bidirected arcs in the graph are denoted by two directed arcs which have a description parameter of a single character &quot;U&quot; (shorthand for &quot;unobserved&quot;). Selection variables should have a description parameter of a single character &quot;S&quot;. 
</p>
</td></tr>
<tr><td><code id="parse.graphml_+3A_nodes">nodes</code></td>
<td>
<p>A character vector that describes the names of the nodes in the graph. This is ignored if <code>use.names</code> is <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="parse.graphml_+3A_use.names">use.names</code></td>
<td>
<p>A logical value indicating whether the names of the nodes should be read from the file or not. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class igraph that describes the causal diagram. The parsed graph can now be used by other functions of the package.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>

<hr>
<h2 id='recover'>Recover a causal effect from selection bias</h2><span id='topic+recover'></span>

<h3>Description</h3>

<p>This function attempts to recover the causal effect of the set of variables (<code>y</code>)
given the intervention on the set of variables (<code>x</code>) in graph (<code>G</code>) containing a single selection variable. Otherwise
an error is thrown describing the graphical structure that witnesses non-identifiability. The vertex of (<code>G</code>) that corresponds to the selection variable must have a description parameter of a single character &quot;S&quot; (shorthand for &quot;selection&quot;). If <code>steps = TRUE</code>, returns instead
a list where the first element is the expression and the second element is a list of the intermediary steps taken by the algorithm. </p>


<h3>Usage</h3>

<pre><code class='language-R'>recover(y, x, G, expr = TRUE, simp = TRUE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recover_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="recover_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="recover_+3A_g">G</code></td>
<td>
<p>An <code>igraph</code> object describing a causal model with a single selection variable in the internal syntax. </p>
</td></tr>
<tr><td><code id="recover_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="recover_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="recover_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the causal effect and the second to the a list describing intermediary steps taken by the algorithm. </p>
</td></tr>
<tr><td><code id="recover_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="recover_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the interventional distribution. Otherwise, a list as described in the arguments. </p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Tian J. 2015 Recovering Causal Effects From Selection Bias. <em>In Proceedings of the 29th AAAI Conference on Artificial Intelligence</em>, 3475&ndash;3481.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+get.expression">get.expression</a></code>, <code><a href="#topic+generalize">generalize</a></code>, <code><a href="#topic+meta.transport">meta.transport</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# We set simplify = FALSE to allow multiple edges.
g &lt;- graph.formula(W_1 -+ X, W_2 -+ X, X -+ Y, # Observed edges
  W_2 -+ S, # The selection variable S
  W_1 -+ W_2, W_2 -+ W_1, W_1 -+ Y, Y -+ W_1, simplify = FALSE)

# Here the bidirected edges are set to be unobserved in the selection diagram d.
# This is denoted by giving them a description attribute with the value "U".
# The first five edges are observed, the rest are unobserved.
g &lt;- set.edge.attribute(g, "description", 5:8, "U")

# The variable "S" is a selection variable. This is denoted by giving it
# a description attribute with the value "S".
g &lt;- set.vertex.attribute(g, "description", 5, "S")

recover(y = "Y", x = "X", G = g)
</code></pre>

<hr>
<h2 id='surrogate.outcome'>Derive a formula for a causal effect using surrogate outcomes</h2><span id='topic+surrogate.outcome'></span>

<h3>Description</h3>

<p>This function returns an expression for the causal effect of interest using surrogate outcomes. The formula is returned for the interventional distribution of the set of variables (<code>y</code>) given the intervention on the set of variables (<code>x</code>). Available experimental data are depicted by a list (<code>S</code>) where each element is a list with two elements, <code>Z</code> and <code>W</code>, that are character vectors describing the experiments and the outcome variables, respectively. </p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.outcome(y, x, S, G, expr = TRUE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.outcome_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_s">S</code></td>
<td>
<p>A list describing the available experimental data. </p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_g">G</code></td>
<td>
<p>An <code>igraph</code> object describing the directed acyclic graph induced by the causal model that matches the internal syntax. </p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the transport formula and the second to the a list describing intermediary steps taken by the algorithm.</p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="surrogate.outcome_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the causal effect. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2014 Transportability from Multiple Environments with Limited Experiments: Completeness Results. <em>Proceedings of the 27th Annual Conference on Neural Information Processing Systems</em>, 280&ndash;288.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+generalize">generalize</a></code>, <code><a href="#topic+causal.effect">causal.effect</a></code>, <code><a href="#topic+get.expression">get.expression</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# We set simplify = FALSE to allow multiple edges.
g &lt;-  graph.formula(W -+ X, W -+ Z, X -+ Z, Z -+ Y, # Observed edges
  X -+ Z, Z -+ X, simplify = FALSE)

# We set the bidirected edges
g &lt;- set.edge.attribute(g, "description", 5:6, "U")

# We construct the set of available experimental data
s &lt;- list(
  list(Z = c("X"), W = c("Z"))
)

surrogate.outcome(y = "Y", x = "X", S = s, G = g)
</code></pre>

<hr>
<h2 id='transport'>Derive a transport formula for a causal effect between two domains</h2><span id='topic+transport'></span>

<h3>Description</h3>

<p>This function returns an expression for the transport formula of a causal effect between two domains.  The formula is returned for the interventional distribution of the set of variables (<code>y</code>) given the intervention on the set of variables (<code>x</code>) in a selection diagram (<code>D</code>).  If the effect is non-transportable, an error  is thrown describing the graphical structure that witnesses non-transportability. The vertices of (<code>D</code>) that correspond to selection variables must have a description parameter of a single character &quot;S&quot; (shorthand for &quot;selection&quot;).  By default, every variable is available for intervention in the source. If only a subset of the variables is available, then the set (<code>z</code>) can be used to derive specific z-transportability. </p>


<h3>Usage</h3>

<pre><code class='language-R'>transport(y, x, z = NULL, D, expr = TRUE, simp = TRUE, 
  steps = FALSE, primes = FALSE, stop_on_nonid = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transport_+3A_y">y</code></td>
<td>
<p>A character vector of variables of interest given the intervention. </p>
</td></tr>
<tr><td><code id="transport_+3A_x">x</code></td>
<td>
<p>A character vector of the variables that are acted upon. </p>
</td></tr>
<tr><td><code id="transport_+3A_z">z</code></td>
<td>
<p>A character vector of variables available for intervention. NULL value corresponds to ordinary transportability. </p>
</td></tr>
<tr><td><code id="transport_+3A_d">D</code></td>
<td>
<p>An <code>igraph</code> object describing a selection diagram in the internal syntax. </p>
</td></tr>
<tr><td><code id="transport_+3A_expr">expr</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a string is returned describing the expression in LaTeX syntax. Else, a list structure is returned which can be manually parsed by the function <code>get.expression</code></p>
</td></tr>
<tr><td><code id="transport_+3A_simp">simp</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a simplification procedure is applied to the resulting probability object. d-separation and the rules of do-calculus are applied repeatedly to simplify the expression. </p>
</td></tr>
<tr><td><code id="transport_+3A_steps">steps</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, returns a list where the first element corresponds to the expression of the causal effect and the second to the a list describing intermediary steps taken by the algorithm.</p>
</td></tr>
<tr><td><code id="transport_+3A_primes">primes</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, prime symbols are appended to summation variables to make them distinct from their other instantiations. </p>
</td></tr>
<tr><td><code id="transport_+3A_stop_on_nonid">stop_on_nonid</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, an error is produced when a non-identifiable effect is discovered. Otherwise recursion continues normally. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>steps = FALSE</code>, A character string or an object of class <code>probability</code> that describes the transport formula. Otherwise, a list as described in the arguments.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Bareinboim E., Pearl J. 2013a A General Algorithm for Deciding Transportability of Experimental Results. <em>Journal of Causal Inference</em>, <b>1</b>, 107&ndash;134.
</p>
<p>Bareinboim E., Pearl J. 2013c Causal Transportability with Limited Experiments. <em>Proceedings of the 27th AAAI Conference on Artificial Intelligence</em>, 95&ndash;101. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+parse.graphml">parse.graphml</a></code>, <code><a href="#topic+get.expression">get.expression</a></code>, <code><a href="#topic+generalize">generalize</a></code>, <code><a href="#topic+meta.transport">meta.transport</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# We set simplify = FALSE to allow multiple edges.
d &lt;- graph.formula(X -+ Z, Z -+ W, W -+ V, V -+ Y, S -+ V, # Observed edges
  X -+ Z, Z -+ X, V -+ Y, Y -+ V, X -+ Y, Y -+ X, simplify = FALSE)

# Here the bidirected edges are set to be unobserved in the selection diagram d.
# This is denoted by giving them a description attribute with the value "U".
# The first five edges are observed, the rest are unobserved.
d &lt;- set.edge.attribute(d, "description", 6:11, "U")

# The variable "S" is a selection variable. This is denoted by giving it
# a description attribute with the value "S". 
d &lt;- set.vertex.attribute(d, "description", 6, "S")

transport(y = "Y", x = "X", D = d)
</code></pre>

<hr>
<h2 id='verma.constraints'>Find Verma constraints for a given graph</h2><span id='topic+verma.constraints'></span>

<h3>Description</h3>

<p>This functions computes functional constraints known as Verma constraints for a joint distribution of a given semi-Markovian causal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verma.constraints(G)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verma.constraints_+3A_g">G</code></td>
<td>
<p>An <code>igraph</code> object describing the directed acyclic graph induced by the causal model that matches the internal syntax. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists, each with five components corresponding to the functional constraint. The two equal c-factors that imply the functional independence are described by <code>lhs.cfactor</code> and <code>rhs.cfactor</code> and their expressions are given by <code>lhs.expr</code> and <code>rhs.expr</code> respectively. The independent variables are given by <code>vars</code>.</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>Tian, J., Pearl J. 2002 On Testable Implications of Causal Models with Hidden variables.
<em>Proceedings of the Eighteenth Conference on Uncertainty in Artificial Intelligence</em>, 519&ndash;527.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
