<!DOCTYPE html><html><head><title>Help for package aods3</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aods3}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#antibio'><p>Antibiotics against Shipping Fever in Calves</p></a></li>
<li><a href='#aodml'><p>ML Estimation of Generalized Linear Models for Overdispersed Count Data</p></a></li>
<li><a href='#aodql'><p>QL/MM Estimation of Generalized Linear Models for Overdispersed Count Data</p></a></li>
<li><a href='#aods3-pkg'><p>Analysis of Overdispersed Data</p></a></li>
<li><a href='#cohorts'><p>Age, Period and Cohort Effects for Vital Rates</p></a></li>
<li><a href='#dja'><p> Mortality of Djallonke Lambs in Senegal</p></a></li>
<li><a href='#drs'><p>Test of Proportion Homogeneity between Groups using Donner's and Rao-Scott's Adjustments</p></a></li>
<li><a href='#gof'><p>Test of Goodness-of-Fit of Models for Count data</p></a></li>
<li><a href='#iccbin'><p>Intra-Cluster Correlation for Clustered Binomial data</p></a></li>
<li><a href='#invlink'><p>Transformation from the Link Scale to the Observation Scale</p></a></li>
<li><a href='#link'><p>Transformation from the Observation Scale to the Link Scale</p></a></li>
<li><a href='#lizards'><p>A Comparison of Site Preferences of Two Species of Lizard</p></a></li>
<li><a href='#mice'><p>Pregnant Female Mice Experiment</p></a></li>
<li><a href='#orob1'><p>Germination Data</p></a></li>
<li><a href='#orob2'><p>Germination Data</p></a></li>
<li><a href='#rabbits'><p>Rabbits Foetuses Survival Experiment</p></a></li>
<li><a href='#rats'><p>Rats Diet Experiment</p></a></li>
<li><a href='#salmonella'><p>Salmonella Reverse Mutagenicity Assay</p></a></li>
<li><a href='#splitbin'><p>Split Grouped Data Into Individual Data</p></a></li>
<li><a href='#varbin'><p>Estimate of a Probability from Clustered Binomial Data</p></a></li>
<li><a href='#wald.test'><p>Wald Test for Model Coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.4-1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Overdispersed Data using S3 Methods</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthieu Lesnoff &lt;matthieu.lesnoff@cirad.fr&gt; and Renaud
        Lancelot &lt;renaud.lancelot@cirad.fr&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Renaud Lancelot &lt;renaud.lancelot@cirad.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, lme4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to analyse overdispersed
        counts or proportions.  These functions should be considered as
        complements to more sophisticated methods such as generalized
        estimating equations (GEE) or generalized linear mixed effect
        models (GLMM). aods3 is an S3 re-implementation of the
        deprecated S4 package aod.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-08 09:19:23 UTC; hornik</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-08 09:25:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='antibio'>Antibiotics against Shipping Fever in Calves</h2><span id='topic+antibio'></span>

<h3>Description</h3>

<p>Hypothetical drug trial to compare the effect of four antibiotics against Shipping fever in calves 
(Shoukri and Pause, 1999, Table 3.11).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(antibio)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 3 variables.
</p>

<dl>
<dt>treatment</dt><dd><p>A factor with levels <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code></p>
</dd>
<dt>n</dt><dd><p>A numeric vector: the number of treated animals within a two-week period.</p>
</dd>
<dt>m</dt><dd><p>A numeric vector: the number of deaths at the end of the two weeks.</p>
</dd>
</dl>



<h3>References</h3>

<p>Shoukri, M.M., Pause, C.A., 1999, 2nd ed. <em>Statistical methods for health sciences</em>. CRC Press, London.</p>

<hr>
<h2 id='aodml'>ML Estimation of Generalized Linear Models for Overdispersed Count Data</h2><span id='topic+aodml'></span><span id='topic+print.aodml'></span><span id='topic+summary.aodml'></span><span id='topic+print.summary.aodml'></span><span id='topic+anova.aodml'></span><span id='topic+print.anova.aodml'></span><span id='topic+fitted.aodml'></span><span id='topic+residuals.aodml'></span><span id='topic+coef.aodml'></span><span id='topic+logLik.aodml'></span><span id='topic+deviance.aodml'></span><span id='topic+df.residual.aodml'></span><span id='topic+AIC.aodml'></span><span id='topic+vcov.aodml'></span><span id='topic+predict.aodml'></span>

<h3>Description</h3>

<p>The function fits a beta-binomial (BB) or a negative binomial (NB) generalized linear model from clustered data. <br />
</p>
<p>For the BB model, data have the form {<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>}, where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of &ldquo;successes&rdquo;, and <code class="reqn">N</code> the number of clusters. The response is the proportion <code class="reqn">y = m/n.</code> 
</p>
<p>For the NB model, data can be of two types. When modeling simple counts, data have the form {<code class="reqn">m_1, m_2, ..., m_N</code>}, where <code class="reqn">m_i</code> is the number of occurences of the event under study. When modeling rates (e.g. hazard rates), data have the same form as for the BB model, where <code class="reqn">n_i</code> is the denominator of the rate for cluster <code class="reqn">i</code> (considered as an &ldquo;offset&rdquo;, i.e. a constant known value) and <code class="reqn">m_i</code> the number of occurences of the event. For both types of data, the response is the count <code class="reqn">y = m</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>  aodml(formula,
  data,
  family = c("bb", "nb"),
  link = c("logit", "cloglog", "probit"), 
	phi.formula = ~ 1,
  phi.scale = c("identity", "log", "inverse"),
  phi.start = NULL,
  fixpar = list(),
  hessian = TRUE,
  method = c("BFGS", "Nelder-Mead", "CG", "SANN"),
  control = list(maxit = 3000, trace = 0), ...)
  
  ## S3 method for class 'aodml'
print(x, ...)
  ## S3 method for class 'aodml'
summary(object, ...)
  ## S3 method for class 'aodml'
anova(object, ...)
  ## S3 method for class 'anova.aodml'
print(x, digits, ...)
  ## S3 method for class 'aodml'
fitted(object, ..., what = c("mu", "nu", "eta", "phi"))
  ## S3 method for class 'aodml'
residuals(object, ..., type = c("deviance", "pearson", "response"))
  ## S3 method for class 'aodml'
coef(object, ...)
  ## S3 method for class 'aodml'
df.residual(object, ...)
  ## S3 method for class 'aodml'
logLik(object, ...)
  ## S3 method for class 'aodml'
deviance(object, ...)
  ## S3 method for class 'aodml'
AIC(object, ..., k = 2)
  ## S3 method for class 'aodml'
vcov(object, ...)
  ## S3 method for class 'aodml'
predict(object, ..., type = c("link", "response"), se.fit = FALSE, newdata = NULL)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aodml_+3A_formula">formula</code></td>
<td>
<p>A formula for the mean <code class="reqn">\mu</code>, defining the parameter vector <code class="reqn">b</code> (see details).
</p>
<p>For the BB model, the left-hand side of the formula must be of the form 
</p>
<p><code>cbind(m, n - m) ~ ...</code>
</p>
<p>where the fitted proportion is <code>m/n</code>.
</p>
<p>For the NB model, the left-hand side of the formula must be of the form 
</p>
<p><code>m ~ ...</code>
</p>
<p>where the fitted count is <code>m</code>. To fit a rate, argument <code>offset</code> must be used in the right-hand side of the formula (see examples).</p>
</td></tr>
<tr><td><code id="aodml_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>m</code> and, optionnally, <code>n</code>) and the explanatory variable(s).</p>
</td></tr>
<tr><td><code id="aodml_+3A_family">family</code></td>
<td>
<p>Define the model which is fitted: &ldquo;bb&rdquo; for the BB model and &ldquo;nb&rdquo; for the NB model.</p>
</td></tr>
<tr><td><code id="aodml_+3A_link">link</code></td>
<td>
<p>For the BB model only. Define the link function <code class="reqn">g</code> for the mean <code class="reqn">\mu</code>: &ldquo;cloglog&rdquo;, &ldquo;logit&rdquo; (default) or &ldquo;probit&rdquo;. For the NB model, <code>link</code> is automatically set to &ldquo;log&rdquo;.</p>
</td></tr>
<tr><td><code id="aodml_+3A_phi.formula">phi.formula</code></td>
<td>
<p>A right-hand side formula to model optional heterogeneity for the over-dispersion parameter <code class="reqn">\Phi</code> (see details). Only one single factor is allowed.
</p>
<p>Default to <code>formula(~ 1)</code> (i.e. no heterogeneity).</p>
</td></tr>
<tr><td><code id="aodml_+3A_phi.scale">phi.scale</code></td>
<td>
<p>Scale on which <code class="reqn">\Phi</code> is estimated (see details): &ldquo;identity&rdquo; (default), &ldquo;log&rdquo; or &ldquo;inverse&rdquo;.</p>
</td></tr>
<tr><td><code id="aodml_+3A_phi.start">phi.start</code></td>
<td>
<p>Optional starting values for <code class="reqn">\Phi</code>. Default to 0.1.</p>
</td></tr>
<tr><td><code id="aodml_+3A_fixpar">fixpar</code></td>
<td>
<p>An optional list of 2 vectors of same length (<code class="reqn">&gt;=1</code>) to set some parameters as constant in the model.
</p>
<p>The first vector indicates which parameters are set as constant (i.e., not optimized) in the global parameter vector <code class="reqn">(b, \Phi)</code>.
</p>
<p>The second vector indicates the corresponding values. For instance,
</p>
<p><code>fixpar = list(c(4, 5), c(0, 0.1))</code>
</p>
<p>means that the 4th and 5th components of vector <code class="reqn">(b, \Phi)</code> are set to 0 and 0.1. Argument <code>fixpar</code> can be usefull, for instance, to calculate profiled log-likehoods.</p>
</td></tr>
<tr><td><code id="aodml_+3A_hessian">hessian</code></td>
<td>
<p>A logical (default to <code>TRUE</code>). If <code>FALSE</code>, the hessian and the variances-covariances matrices of the parameters are not calculated.</p>
</td></tr>
<tr><td><code id="aodml_+3A_method">method</code></td>
<td>
<p>Define the method used for the optimization (see <code><a href="stats.html#topic+optim">optim</a></code>).</p>
</td></tr>
<tr><td><code id="aodml_+3A_control">control</code></td>
<td>
<p>A list to control the optimization parameters. See <code><a href="stats.html#topic+optim">optim</a></code>. By default, the maximum number of iterations is set to 3000, and trace is set to 0 to avoid spurious warnings.</p>
</td></tr>
<tr><td><code id="aodml_+3A_object">object</code></td>
<td>
<p>An object of class <code>aodml</code></p>
</td></tr>
<tr><td><code id="aodml_+3A_x">x</code></td>
<td>
<p>An object of class <code>aodml</code></p>
</td></tr>
<tr><td><code id="aodml_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print in print.summary.aodml and print.anova.aodml.
Default to <code>max(3, getOption("digits") - 3)</code></p>
</td></tr>
<tr><td><code id="aodml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code> (e.g. argument <code>method</code> if using function <code>aodml</code>), or further objects of class <code>aodml</code> (function <code>anova.aodml</code>), or further arguments passed to <code>print.aodml</code> and <code>print.anova.aodml</code>.</p>
</td></tr>
<tr><td><code id="aodml_+3A_what">what</code></td>
<td>
<p>For function <code>fitted</code>, a character string indicating the type of fitted values to be returned: legal values are &ldquo;mu&rdquo; for the fitted response; &ldquo;nu&rdquo; for the fitted linear predictor without offset (link scale); &ldquo;eta&rdquo; for the fitted linear predictor with offset (link scale); &ldquo;phi&rdquo; for the fitted overdispersion coefficient.</p>
</td></tr>
<tr><td><code id="aodml_+3A_type">type</code></td>
<td>
<p>For function <code>residuals</code>, a character string indicating the type of residuals to be computed; legal values are &ldquo;deviance&rdquo; for the deviance's residuals, &ldquo;pearson&rdquo; for the Pearson's residuals, and &ldquo;response&rdquo; for the response. For function <code>predict</code>, a character string indicating the type of prediction to be computed; legal values are &ldquo;link&rdquo; and &ldquo;response&rdquo;.</p>
</td></tr>
<tr><td><code id="aodml_+3A_k">k</code></td>
<td>
<p>Numeric scalar for the penalty parameter used to compute the information criterion. The default value (<code class="reqn">k = 2</code>) is the regular AIC = -2 * logLik + 2 * <code class="reqn">p</code>, where <code class="reqn">p</code> is the number of model coefficients. NB: for AICc, <code class="reqn">k</code> is set to 2, and AICc = AIC + 2 * <code class="reqn">p</code> * <code class="reqn">(p + 1)</code> / <code class="reqn">(n - p - 1)</code>, with <code class="reqn">n</code> the number of observations.</p>
</td></tr>
<tr><td><code id="aodml_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical scalar indicating whether standard errors should be computed for the predicted values. Default to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aodml_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing the explanatory variables - and possibly the offset - for the values of which predictions are to be made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Beta-binomial model (BB)</b><br />
</p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n ~ Binomial(n, \lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a Beta distribution <code class="reqn">Beta(a_1, a_2)</code>. Noting <code class="reqn">B</code> the beta function, the marginal (beta-binomial) distribution of <code class="reqn">m</code> is
</p>
<p style="text-align: center;"><code class="reqn">P(m | n) = C(n, m) * B(a_1 + m, a_2 + n - m) / B(a_1, a_2)</code>
</p>

<p>Using the re-parameterization <code class="reqn">\mu = a_1 / (a_1 + a_2)</code> and <code class="reqn">\Phi = 1 / (a_1 + a_2 + 1)</code>, the marginal mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = n * \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = n * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>
</p>

<p>The response in <code>aodml</code> is <code class="reqn">y = m/n</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = g^{-1}(X * b) =  g^{-1}(\nu)</code>, where <code class="reqn">g</code> is the link function, <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> a vector of fixed effects and <code class="reqn">\nu = X * b</code> is the corresponding linear predictor. The variance is <code class="reqn">Var[y] = (1 / n) * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>.<br />
</p>
<p><b>Negative binomial model (NB)</b><br />
</p>
<p><em>&mdash;&mdash; Simple counts (model with no offset)</em><br />
</p>
<p>For a given cluster <code class="reqn">(m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">y | \lambda ~ Poisson(\lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a Gamma distribution of mean <code class="reqn">\mu</code> and shape <code class="reqn">k</code> (<code class="reqn">Var[\lambda] = \mu^2 / k</code>). Noting <code class="reqn">G</code> the gamma function, the marginal (negative binomial) distribution of <code class="reqn">m</code> is
</p>
<p style="text-align: center;"><code class="reqn">P(m) = {G(m+k) / (m! * G(k))} * (k / (k + \mu))^k * (\mu / (k + \mu))^m</code>
</p>

<p>Using the re-parameterization <code class="reqn">\Phi = 1 / k</code>, the marginal mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = \mu + \Phi * \mu^2</code>
</p>

<p>The response in <code>aodml</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b) =  exp(\nu)</code>. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br />
</p>
<p><em>&mdash;&mdash; Rates (model with offset)</em><br />
</p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n ~ Poisson(\lambda)</code>
</p>

<p>The marginal (negative binomial) distribution <code class="reqn">P(m|n)</code> is the same as for the case with no offset (<code class="reqn">= P(m)</code>). The response in <code>aodml</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b + log(n)) =  exp(\nu + log(n)) = exp(\eta)</code>, where <code class="reqn">log(n)</code> is the offset. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br />
</p>
<p><b>Other details</b><br />
</p>
<p>Argument <code>phi.scale</code> of function <code>aodml</code> enables to estimate the over-dispersion parameter under different scales.
</p>
<p>If <code>phi.scale = "identity"</code> (Default), the function estimates <code class="reqn">\Phi</code>. 
</p>
<p>If <code>phi.scale = "log"</code>, the function estimates <code class="reqn">log(\Phi)</code>.
</p>
<p>If <code>phi.scale = "inverse"</code>, the function estimates <code class="reqn">1/\Phi</code>.<br />
</p>
<p>The full parameter vector returned by <code>aodml</code>, say <code>param</code>, is equal to <code class="reqn">(b, \Phi)</code>. This vector is estimated by maximizing the log-likelihood of the marginal model using function <code>optim</code>. The estimated variances-covariances matrix of <code>param</code> is calculated by the inverse of the observed hessian matrix returned by <code>optim</code>, and is referred to as <code>varparam</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>aodml</code>, printed and summarized by various functions. Function <code>deviance.aodml</code> returns the value <code>-2 * (logL - logL_max)</code>. The &ldquo;deviance&rdquo; used in function <code>AIC.aodml</code> to calculate AIC and AICc is <code>-2 * logL</code>.</p>


<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.<br />
Griffiths, D.A., 1973. <em>Maximum likelihood estimation for the beta-binomial distribution and an application
to the household distribution of the total number of cases of disease</em>. Biometrics 29, 637-648.<br />
Lawless, J.F., 1987. <em>Negative binomial and mixed Poisson regression</em>. The Canadian Journal of Statistics, 15(3): 209-225.<br />
McCullagh, P., Nelder, J. A., 1989, 2nd ed. <em>Generalized linear models</em>. New York, USA: Chapman and Hall.<br />
Prentice, R.L., 1986. <em>Binary regression using an extended beta-binomial distribution, with discussion of
correlation induced by covariate measurement errors</em>. J.A.S.A. 81, 321-327.<br />
Williams, D.A., 1975. <em>The analysis of binary responses from toxicological experiments involving
reproduction and teratogenicity</em>. Biometrics 31, 949-952.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#------ Beta-binomial model

data(orob2)
fm1 &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb")

# summaries
fm1
summary(fm1)
coef(fm1)
vcov(fm1)
logLik(fm1)
deviance(fm1)
AIC(fm1)
gof(fm1)

# predictions
cbind(
  fitted(fm1),
  fitted(fm1, what = "nu"),
  fitted(fm1, what = "eta"),
  fitted(fm1, what = "phi")
)
predict(fm1, type = "response", se.fit = TRUE)
newdat &lt;- data.frame(seed = c("O73", "O75"))
predict(fm1, type = "response", se.fit = TRUE, newdata = newdat)

# model with heterogeneity in phi
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2,
  family = "bb", phi.formula = ~ seed)
summary(fm)
AIC(fm1, fm)

# various phi scales
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb")
fm$phi
fm$phi.scale
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb",
            phi.scale = "log")
fm$phi
fm$phi.scale
fm &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb",
            phi.scale = "inverse")
fm$phi
fm$phi.scale

### Models with coefficient(s) set as constant

# model with 1 phi coefficient, set as constant "0.02"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
  family = "bb", fixpar = list(5, 0.02))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
  family = "bb", phi.formula = ~ seed, fixpar = list(5, 1e-15))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0",
# and the mu intercept (1rst coef of vector b) set as as constant "-0.5"
fm &lt;- aodml(formula = cbind(m, n - m) ~ seed * root, data = orob2,
            family = "bb", phi.formula = ~ seed,
            fixpar = list(c(1, 5), c(-0.5, 1e-15)))
fm$param
fm$varparam
  
### Model tests

# LR tests - non-constant phi
fm0 &lt;- aodml(cbind(m, n - m) ~ 1, data = orob2, family = "bb")
fm2 &lt;- aodml(cbind(m, n - m) ~ seed + root, data = orob2, family = "bb")
fm3 &lt;- aodml(cbind(m, n - m) ~ seed * root, data = orob2, family = "bb")
anova(fm0, fm1, fm2, fm3)

# LR tests - constant phi
# phi is assumed to be estimated from fm3
fm2.bis &lt;- aodml(cbind(m, n - m) ~ seed  + root, data = orob2,
                 family = "bb", fixpar = list(4, fm3$phi))
LRstat &lt;- 2 * (logLik(fm3) - logLik(fm2.bis))  
pchisq(LRstat, df = 1, lower.tail = FALSE)  
  
# Wald test of the seed factor in fm1
wald.test(b = coef(fm3), varb = vcov(fm3), Terms = 4)

#------ Negative binomial model

### Modelling counts

data(salmonella)
fm1 &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb")
## fm1 &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb",
##              method = "Nelder-Mead")

# summaries
fm1
summary(fm1)
coef(fm1)
vcov(fm1)
logLik(fm1)
deviance(fm1)
AIC(fm1)
gof(fm1)

# predictions
cbind(
  fitted(fm1),
  fitted(fm1, what = "nu"),
  fitted(fm1, what = "eta"),
  fitted(fm1, what = "phi")
)
predict(fm1, type = "response", se.fit = TRUE)
newdat &lt;- data.frame(dose = c(20, 40))
predict(fm1, type = "response", se.fit = TRUE, newdata = newdat)

# various phi scales
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella, family = "nb")
fm$phi
fm$phi.scale
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella,
            family = "nb", phi.scale = "log")
fm$phi
fm$phi.scale
fm &lt;- aodml(m ~ log(dose + 10) + dose, data = salmonella,
            family = "nb", phi.scale = "inverse")
fm$phi
fm$phi.scale
  
# LR and Wald tests of the "log(dose + 10) + dose" factors
fm0 &lt;- aodml(m ~ 1, data = salmonella, family = "nb")
anova(fm0, fm1)
fm0.bis &lt;- aodml(m ~ 1, data = salmonella, family = "nb",
                 fixpar = list(2, fm1$phi))
LRstat &lt;- 2 * (logLik(fm1) - logLik(fm0.bis))  
pchisq(LRstat, df = 2, lower.tail = FALSE)  
wald.test(b = coef(fm1), varb = vcov(fm1), Terms = 2:3)

### Modelling a rate
  
data(dja)
# rate "m / trisk"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)),
            data = dja, family = "nb")
summary(fm)

fm &lt;- aodml(formula = m ~ group + offset(log(trisk)),
            phi.formula = ~ group, data = dja, family = "nb",
            phi.scale = "log")
summary(fm)
  
# model with 1 phi coefficient, set as constant "0.8"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
            family = "nb", phi.formula = ~1, fixpar = list(3, 0.8))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant ~ "0" in the identity scale
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
            family = "nb", phi.formula = ~ group, phi.scale = "log",
            fixpar = list(4, -15))
fm$param
fm$varparam

# model with 2 phi coefficients, with the first set as constant "0" in the identity scale,
# and the mu intercept coefficient (1rst coef of vector b) set as as constant "-0.5"
fm &lt;- aodml(formula = m ~ group + offset(log(trisk)), data = dja,
  family = "nb", phi.formula = ~ group, phi.scale = "log",
  fixpar = list(c(1, 4), c(-0.5, -15)))
fm$param
fm$varparam
</code></pre>

<hr>
<h2 id='aodql'>QL/MM Estimation of Generalized Linear Models for Overdispersed Count Data</h2><span id='topic+aodql'></span><span id='topic+anova.aodql'></span><span id='topic+coef.aodql'></span><span id='topic+deviance.aodql'></span><span id='topic+df.residual.aodql'></span><span id='topic+fitted.aodql'></span><span id='topic+logLik.aodql'></span><span id='topic+predict.aodql'></span><span id='topic+print.aodql'></span><span id='topic+residuals.aodql'></span><span id='topic+summary.aodql'></span><span id='topic+vcov.aodql'></span>

<h3>Description</h3>

<p>From clustered data, the function fits generalized linear models containing an over-dispersion parameter <code class="reqn">\Phi</code> using quasi-likelihood estimating equations for the mean <code class="reqn">\mu</code> and a moment estimator for <code class="reqn">\Phi</code>.<br />
</p>
<p>For binomial-type models, data have the form {<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>}, where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of &ldquo;successes&rdquo;, and <code class="reqn">N</code> the number of clusters. The response is the proportion <code class="reqn">y = m/n</code>. <br />
</p>
<p>For Poisson-type models, data can be of two forms. When modeling &ldquo;simple counts&rdquo;, data have the form {<code class="reqn">m_1, m_2, ..., m_N</code>}, where <code class="reqn">m_i</code> is the number of occurences of the event under study. When modeling rates (e.g. hazard rates), data have the same form as for the BB model, where <code class="reqn">n_i</code> is the denominator of the rate for cluster <code class="reqn">i</code> (considered as an &ldquo;offset&rdquo;, i.e. a constant known value) and <code class="reqn">m_i</code> the number of occurences of the event. For both forms of data, the response is the count <code class="reqn">y = m</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>  aodql(formula,
        data,
        family = c("qbin", "qpois"),
        link = c("logit", "cloglog", "probit"),
        method = c("chisq", "dev"),
        phi = NULL,
        tol = 1e-5, ...)
        
  ## S3 method for class 'aodql'
anova(object, ...)
  ## S3 method for class 'aodql'
coef(object, ...)
  ## S3 method for class 'aodql'
deviance(object, ...)
  ## S3 method for class 'aodql'
df.residual(object, ...)
  ## S3 method for class 'aodql'
fitted(object, ...)
  ## S3 method for class 'aodql'
logLik(object, ...)
  ## S3 method for class 'aodql'
predict(object, ...)
  ## S3 method for class 'aodql'
print(x, ...)
  ## S3 method for class 'aodql'
residuals(object, ...)
  ## S3 method for class 'aodql'
summary(object, ...)
  ## S3 method for class 'aodql'
vcov(object, ...)  
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aodql_+3A_formula">formula</code></td>
<td>
<p>A formula for the mean <code class="reqn">\mu</code>, defining the parameter vector <code class="reqn">b</code> (see details). For binomial-type models, the left-hand side of the formula must be of the form <code>cbind(m, n - m) ~ ...</code> where the fitted proportion is <code>m/n</code>. For Poisson-type models, the left-hand side of the formula must be of the form <code>m ~ ...</code> where the fitted count is <code>m</code>. To fit a rate, argument <code>offset</code> must be used in the right-hand side of the formula (see examples).</p>
</td></tr>
<tr><td><code id="aodql_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>m</code> and, optionnally, <code>n</code>) and the explanatory variable(s).</p>
</td></tr>
<tr><td><code id="aodql_+3A_family">family</code></td>
<td>
<p>Define the model which is fitted: &ldquo;qbin&rdquo; for binomial-type models and &ldquo;qpois&rdquo; for Poisson-type models.</p>
</td></tr>
<tr><td><code id="aodql_+3A_link">link</code></td>
<td>
<p>For binomial-type models only. Define the link function <code class="reqn">g</code> for the mean <code class="reqn">\mu</code>: &ldquo;cloglog&rdquo;, &ldquo;logit&rdquo; (default) or &ldquo;probit&rdquo;. For Poisson-type models, <code>link</code> is automatically set to &ldquo;log&rdquo;.</p>
</td></tr>
<tr><td><code id="aodql_+3A_method">method</code></td>
<td>
<p>For function <code>aodql</code>, define the statistics used for the moment estimation of <code class="reqn">phi</code>; legal values are &ldquo;chisq&rdquo; (default) for the chi-squared statistics or &ldquo;dev&rdquo; for the deviance statistics.</p>
</td></tr>  
<tr><td><code id="aodql_+3A_phi">phi</code></td>
<td>
<p>An optional value defining the over-dispersion parameter <code class="reqn">\Phi</code> if it is set as constant. Default to NULL (in that case, <code class="reqn">\Phi</code> is estimated).</p>
</td></tr>
<tr><td><code id="aodql_+3A_tol">tol</code></td>
<td>
<p>A positive scalar (default to 0.001). The algorithm stops at iteration <code class="reqn">r + 1</code> when the condition
<code class="reqn">\chi{^2}[r+1] - \chi{^2}[r] &lt;= tol</code> is met by the <code class="reqn">\chi^2</code> statistics .</p>
</td></tr>
<tr><td><code id="aodql_+3A_...">...</code></td>
<td>
<p>Further arguments to passed to the appropriate functions.</p>
</td></tr>
<tr><td><code id="aodql_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;aodql&rdquo;.</p>
</td></tr>
<tr><td><code id="aodql_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;aodql&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Binomial-type models</b><br />
</p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n \sim Binomial(n, \lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a random variable of mean <code class="reqn">E[\lambda] = \mu</code> and variance <code class="reqn">Var[\lambda] = \Phi * \mu * (1 - \mu)</code>. The marginal mean and variance of <code class="reqn">m</code> are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = n * \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = n * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>
</p>

<p>The response in <code>aodql</code> is <code class="reqn">y = m/n</code>.  The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = g^{-1}(X * b) =  g^{-1}(\nu)</code>, where <code class="reqn">g</code> is the link function, <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> a vector of fixed effects and <code class="reqn">\nu = X * b</code> is the corresponding linear predictor. The variance is <code class="reqn">Var[y] = (1 / n) * \mu * (1 - \mu) * (1 + (n - 1) * \Phi)</code>.<br /> 
</p>
<p><b>Poisson-type models</b><br />
</p>
<p><em>&mdash;&mdash; Simple counts (model with no offset)</em><br />
</p>
<p>For a given cluster <code class="reqn">(m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">y | \lambda \sim Poisson(\lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows a random distribution of mean <code class="reqn">\mu</code> and variance <code class="reqn">\Phi * \mu^2</code>. The mean and variance of the marginal distribution of <code class="reqn">m</code> are
</p>
<p style="text-align: center;"><code class="reqn">E[m] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m] = \mu + \Phi * \mu^2</code>
</p>

<p>The response in <code>aodql</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b) =  exp(\nu)</code>. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br />
</p>
<p><em>&mdash;&mdash; Rates (model with offset)</em><br />
</p>
<p>For a given cluster <code class="reqn">(n, m)</code>, the model is
</p>
<p style="text-align: center;"><code class="reqn">m | \lambda,n \sim Poisson(\lambda)</code>
</p>

<p>where <code class="reqn">\lambda</code> follows the same random distribution as for the case with no offset. The marginal mean and variance are
</p>
<p style="text-align: center;"><code class="reqn">E[m | n] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[m | n] = \mu + \Phi * \mu^2</code>
</p>

<p>The response in <code>aodql</code> is <code class="reqn">y = m</code>. The mean is <code class="reqn">E[y] = \mu</code>, defined such as <code class="reqn">\mu = exp(X * b + log(n)) =  exp(\nu + log(n)) = exp(\eta)</code>, where <code class="reqn">log(n)</code> is the offset. The variance is <code class="reqn">Var[y] = \mu + \Phi * \mu^2</code>.<br />
</p>
<p><b>Other details</b><br />
</p>
<p>Vector <code class="reqn">b</code> and parameter <code class="reqn">\Phi</code> are estimated iteratively, using procedures referred to as &quot;Model I&quot; in Williams (1982) for binomial-type models, and &quot;Procedure II&quot; in Breslow (1984) for Poisson-type models.<br />
</p>
<p>Iterations are as follows. Quasi-likelihood estimating equations (McCullagh &amp; Nelder, 1989) are used to estimate <code class="reqn">b</code> (using function <code>glm</code> and its <code>weights</code> argument), <code class="reqn">\Phi</code> being set to a constant value. Then, <code class="reqn">\Phi</code> is calculated by the moment estimator, obtained by equalizing the goodness-of-fit statistic (chi-squared <code>X2</code> or deviance <code>D</code>) of the model to its degrees of freedom.<br />
Parameter <code class="reqn">\Phi</code> can be set as constant, using argument <code>phi</code>. In that case, only <code class="reqn">b</code>  is estimated.
</p>


<h3>Value</h3>

<p>An object of class <code>aodql</code>, printed and summarized by various functions.</p>


<h3>References</h3>

<p>Breslow, N.E., 1984. <em>Extra-Poisson variation in log-linear models</em>. Appl. Statist. 33, 38-44.<br />
Moore, D.F., 1987, <em>Modelling the extraneous variance in the presence of extra-binomial variation</em>. 
Appl. Statist. 36, 8-14.<br />
Moore, D.F., Tsiatis, A., 1991. <em>Robust estimation of the variance in moment methods for extra-binomial
and extra-poisson variation</em>. Biometrics 47, 383-401.
McCullagh, P., Nelder, J. A., 1989, 2nd ed. <em>Generalized linear models</em>. New York, USA: Chapman and Hall.<br />
Williams, D.A., 1982, <em>Extra-binomial variation in logistic linear models</em>. Appl. Statist. 31, 144-148.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#------ Binomial-type models

data(orob2)
fm &lt;- aodql(cbind(m, n - m) ~ seed, data = orob2, family = "qbin")
coef(fm)
vcov(fm)
summary(fm)
# chi2 tests of the seed factor in fm
wald.test(b = coef(fm), varb = vcov(fm), Terms = 2)

# chi-2 vs. deviance statistic to estimate phi
fm1 &lt;- aodql(cbind(m, n - m) ~ seed + root, data = orob2, family = "qbin")
fm2 &lt;- aodql(cbind(m, n - m) ~ seed + root, data = orob2, family = "qbin", method = "dev")
coef(fm1)
coef(fm2)
fm1$phi
fm2$phi
vcov(fm1)
vcov(fm2)
gof(fm1)
gof(fm2)

# estimate with fixed phi
fm &lt;- aodql(cbind(m, n - m) ~ seed, data = orob2, family = "qbin", phi = 0.05)
coef(fm)
vcov(fm)
summary(fm)

#------ Poisson-type models

data(salmonella)
fm &lt;- aodql(m ~ log(dose + 10) + dose, data = salmonella, family = "qpois")
coef(fm)
vcov(fm)
summary(fm)
# chi2 tests of the "log(dose + 10) + dose" factors
wald.test(b = coef(fm), varb = vcov(fm), Terms = 2:3)

# chi-2 vs. deviance statistic to estimate phi
fm1 &lt;- aodql(m ~ log(dose + 10) + dose, data = salmonella, family = "qpois")
fm2 &lt;- aodql(m ~ log(dose + 10) + dose, data = salmonella, family = "qpois", method = "dev")
coef(fm1)
coef(fm2)
fm1$phi
fm2$phi
vcov(fm1)
vcov(fm2)
gof(fm1)
gof(fm2)

# estimate with fixed phi
fm &lt;- aodql(m ~ log(dose + 10) + dose, data = salmonella, family = "qpois", phi = 0.05)
coef(fm)
vcov(fm)
summary(fm)

# modelling a rate
data(dja)
# rate "m / trisk"
fm &lt;- aodql(formula = m ~ group + offset(log(trisk)), data = dja, family = "qpois")
summary(fm)

</code></pre>

<hr>
<h2 id='aods3-pkg'>Analysis of Overdispersed Data</h2><span id='topic+aods3-pkg'></span><span id='topic+aods3'></span>

<h3>Description</h3>

<p>This package provides functions to analyse
overdispersed counts or proportions. The functions should be considered as
complements to more sophisticated methods such as generalized
estimating equations (GEE) or generalized linear mixed effect
models (GLMM).</p>


<h3>Details</h3>

<p>Functions Index :
</p>

<table>
<tr>
 <td style="text-align: left;">
  aodml       </td><td style="text-align: left;"> ML Estimation of Generalized Linear Models for Overdispersed Count Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  aodql       </td><td style="text-align: left;"> QL/MM Estimation of Generalized Linear Models for Overdispersed Count Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  drs         </td><td style="text-align: left;"> Test of Proportion Homogeneity between Groups using Donner's and Rao-Scott's Adjustments</td>
</tr>
<tr>
 <td style="text-align: left;">
  gof         </td><td style="text-align: left;"> Test of Goodness-of-Fit of Models for Count data</td>
</tr>
<tr>
 <td style="text-align: left;">
  iccbin      </td><td style="text-align: left;"> Intra-Cluster Correlation for Clustered Binomial data</td>
</tr>
<tr>
 <td style="text-align: left;">
  invlink     </td><td style="text-align: left;"> Transformation from the Link Scale to the Observation Scale</td>
</tr>
<tr>
 <td style="text-align: left;">
  link        </td><td style="text-align: left;"> Transformation from the Observation Scale to the Link Scale</td>
</tr>
<tr>
 <td style="text-align: left;">
  splitbin    </td><td style="text-align: left;"> Split Grouped Data Into Individual Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  varbin      </td><td style="text-align: left;"> Estimate of a Probability from Clustered Binomial Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  wald.test       </td><td style="text-align: left;"> Wald Test for Model Coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Data sets Index :
</p>

<table>
<tr>
 <td style="text-align: left;">
  antibio              </td><td style="text-align: left;"> Antibiotics against Shipping Fever in Calves</td>
</tr>
<tr>
 <td style="text-align: left;">
  cohorts              </td><td style="text-align: left;"> Data set: Age, Period and Cohort Effects for Vital Rates</td>
</tr>
<tr>
 <td style="text-align: left;">
  dja                  </td><td style="text-align: left;"> Mortality of Djallonke Lambs in Senegal</td>
</tr>
<tr>
 <td style="text-align: left;">
  lizards              </td><td style="text-align: left;"> A Comparison of Site Preferences of Two Species of Lizard</td>
</tr>
<tr>
 <td style="text-align: left;">
  mice                 </td><td style="text-align: left;"> Pregnant Female Mice Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  orob1                </td><td style="text-align: left;"> Germination Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  orob2                </td><td style="text-align: left;"> Germination Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  rabbits              </td><td style="text-align: left;"> Rabbits Foetuses Survival Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  rats                 </td><td style="text-align: left;"> Rats Diet Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  salmonella           </td><td style="text-align: left;"> Salmonella Reverse Mutagenicity Assay</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Matthieu Lesnoff &lt;matthieu.lesnoff@cirad.fr&gt; and Renaud Lancelot &lt;renaud.lancelot@cirad.fr&gt;<br />
Maintainer: Renaud Lancelot &lt;renaud.lancelot@cirad.fr&gt;
</p>

<hr>
<h2 id='cohorts'>Age, Period and Cohort Effects for Vital Rates</h2><span id='topic+cohorts'></span>

<h3>Description</h3>

<p>Number of prostate cancer deaths and midperiod population for nonwhites in the USA by age and period.
The cohort index <code class="reqn">k</code> is related to age and period indices (<code class="reqn">i</code> and <code class="reqn">j</code>, respectively) by <code class="reqn">k = j + I - i</code>, where <code class="reqn">I = max(i)</code> (Holford, 1983, Table 2).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cohorts)</code></pre>


<h3>Format</h3>

<p>A data frame with 49 observations on the following 4 variables.
</p>

<dl>
<dt>period</dt><dd><p>A factor with levels <code>1935-</code>, <code>1940-</code>, ..., <code>1965-</code>.</p>
</dd>
<dt>age</dt><dd><p>A factor with levels <code>50-</code>, <code>55-</code>, ..., <code>80-</code>.</p>
</dd>
<dt>m</dt><dd><p>Numeric: the number of prostate cancer deaths.</p>
</dd>
<dt>n</dt><dd><p>Numeric: the midperiod population size.</p>
</dd>
</dl>



<h3>References</h3>

<p>Holford, T.R., 1983. <em>The estimation of age, period and cohort effects for vital rates</em>. Biometrics 39, 311-324.
</p>

<hr>
<h2 id='dja'> Mortality of Djallonke Lambs in Senegal </h2><span id='topic+dja'></span>

<h3>Description</h3>

<p>Field trial to assess the effect of ewes deworming (prevention of gastro-intestinal parasitism) on the mortality
of their offspring (age &lt; 1 year). This data set is extracted from a large database on small ruminants production
and health in Senegal (Lancelot et al., 1998). Data were collected in a sample of herds in Kolda (Upper Casamance,
Senegal) during a multi-site survey (Faugère et al., 1992). See also the references below for a presentation of the
follow-up survey (Faugère and Faugère, 1986) and a description of the farming systems (Faugère et al., 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dja)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with 2 levels: <code>CTRL</code> and <code>TREAT</code>, indicating the treatment.</p>
</dd>
<dt>village</dt><dd><p>a factor indicating the village of the herd.</p>
</dd>
<dt>herd</dt><dd><p>a factor indicating the herd.</p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the number of animals exposed to mortality.</p>
</dd>
<dt>trisk</dt><dd><p>a numeric vector: the exposition time to mortality (in year).</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of deaths.</p>
</dd>
</dl>



<h3>References</h3>

<p>Faugère, O., Faugère, B., 1986. <em>Suivi de troupeaux et contrôle des performances individuelles des petits ruminants en milieu traditionnel africain. Aspects méthodologiques.</em> Rev. Elev. Méd. vét. Pays trop., 39 (1): 29-40.<br />
Faugère, O., Dockès, A.-C., Perrot, C., Faugère, B., 1990. <em>L'élevage traditionnel des petits ruminants
au Sénégal. I. Pratiques de conduite et d'exploitation des animaux chez les éleveurs de la région de Kolda.</em> Revue
Elev. Méd. vét. Pays trop. 43: 249-259.<br />
Faugère, O., Tillard, E., Faugère, B., 1992. <em>Prophylaxie chez les petits ruminants au Sénégal : régionalisation d'une politique nationale de protection sanitaire</em>. In: B. Rey, S. H. B. Lebbie, L. Reynolds (Ed.), First biennial conference of the African Small Ruminant Research Network, ILCA, 1990, ILRAD, Nairobi, pp. 307-314.<br />
Lancelot, R., Faye, B., Juanès, X., Ndiaye, M., Pérochon, L., Tillard, E., 1998. <em>La base de données BAOBAB: un outil pour modéliser la production et la santé des petits ruminants dans les systèmes d'élevage traditionnels au Sénégal.</em> Revue Elev. Méd. vét. Pays trop., 51 (2): 135-146.<br />
</p>

<hr>
<h2 id='drs'>Test of Proportion Homogeneity between Groups using Donner's and Rao-Scott's Adjustments</h2><span id='topic+drs'></span><span id='topic+print.drs'></span>

<h3>Description</h3>

<p>The function  tests the homogeneity of probabilities between <code class="reqn">J</code> groups (H_0: <code class="reqn">\mu_1 = \mu_2 = ... = \mu_J</code>) from clustered binomial data {<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>}, where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of &ldquo;successes&rdquo; (proportions are <code class="reqn">y = m/n</code>), and <code class="reqn">N</code> the number of clusters. The function uses adjusted chi-squared statistics, with either the correction proposed by proposed by Donner (1989) or the correction proposed by Rao and Scott (1993).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  drs(formula, data, type = c("d", "rs"), C = NULL, pooled = FALSE)
  
  ## S3 method for class 'drs'
print(x, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drs_+3A_formula">formula</code></td>
<td>
<p>An formula where the left-hand side is a matrix of the form <code>cbind(m, n-m)</code> (the modelled proportion is <code class="reqn">m / n</code>). The right-hand side must specify a single grouping variable.</p>
</td></tr>
<tr><td><code id="drs_+3A_type">type</code></td>
<td>
<p>A character string: either &ldquo;d&rdquo; for the Donner's test and &ldquo;rs&rdquo; for the Rao and Scott's test.</p>
</td></tr>
<tr><td><code id="drs_+3A_data">data</code></td>
<td>
<p>A data frame containing <code>n</code>, <code>m</code>) and the grouping variable.</p>
</td></tr>
<tr><td><code id="drs_+3A_c">C</code></td>
<td>
<p>An optional vector of a priori <code class="reqn">J</code> cluster correction factors used for the Donner's test or design effects factors used for the Rao-Scott's test. If C is set no NULL (default), it is calculated internally (see details).</p>
</td></tr>
<tr><td><code id="drs_+3A_pooled">pooled</code></td>
<td>
<p>Logical indicating if a pooled design effect is estimated over the <code class="reqn">J</code> groups for the  Rao-Scott's test (see details). Default to FALSE.</p>
</td></tr>
<tr><td><code id="drs_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;drf&rdquo;.</p>
</td></tr>
<tr><td><code id="drs_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Donner's test</b><br />
The chi-squared statistic is adjusted with the correction factor <code class="reqn">C_j</code> computed in each group <code class="reqn">j</code>. The test statistic is given by:
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_{j} ( (m_j - n_j * \mu)^2 / (C_j * n_j * \mu * (1 - \mu)) )</code>
</p>

<p>where <code class="reqn">\mu = \sum_{j} (m_j) / \sum_{j} (n_j)</code> and <code class="reqn">C_j = 1 + (n_{A,j} - 1) * \rho</code>. <code class="reqn">n_{A,j}</code> is a scalar depending on the cluster sizes, and <code class="reqn">\rho</code> is the ANOVA estimate of the intra-cluster correlation assumed common across groups (see Donner, 1989 or Donner et al., 1994). The statistic is compared to a chi-squared distribution with <code class="reqn">J - 1</code> degrees of freedom. Fixed correction factors <code class="reqn">C_j</code> can be specified with the argument <code>C</code>.<br />
</p>
<p><b>Rao ans Scott's test</b><br />
The method uses design effects and &ldquo;effective&rdquo; sample sizes. The design effect <code class="reqn">C_j</code> in each group <code class="reqn">j</code> is estimated by <code class="reqn">C_j = v_{ratio,j} / v_{bin,j}</code>, where <code class="reqn">v_{ratio,j}</code> is the variance of the ratio estimate of the probability in group <code class="reqn">i</code> (Cochran, 1999, p. 32 and p. 66) and <code class="reqn">v_{bin,j}</code> is the standard binomial variance. The <code class="reqn">C_j</code> are used  to compute the effective sample sizes <code class="reqn">n_{adj,j} = n_j / C_j</code>, the effective numbers of successes <code class="reqn">m_{adj,j} = m_j / C_j</code> in each group <code class="reqn">j</code>, and the overall effective proportion <code class="reqn">mu_adj = \sum_{j} m_{adj,j} / \sum_{j} C_j</code>. The test statistic is obtained by substituting these quantities in the usual chi-squared statistic, yielding:
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_{j} ( (m_{adj,j} - n_{adj,j} * muadj)^2 / (n_{adj,j} * muadj * (1 - muadj)) )</code>
</p>

<p>which is compared to a chi-squared distribution with <code class="reqn">J - 1</code> degrees of freedom.<br />
A pooled design effect over the <code class="reqn">J</code> groups is estimated if argument <code>pooled = TRUE</code> (see Rao and Scott, 1993, Eq. 6). Fixed design effects <code class="reqn">C_j</code> can be specified with the argument <code>C</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>drs</code>, printed with <code>print.drs</code>.</p>


<h3>References</h3>

<p>Donner, A., 1989. <em>Statistical methods in ophthalmology: an adjusted chi-squared approach</em>. Biometrics 45, 605-611.<br />
Donner, A., 1993. <em>The comparison of proportions in the presence of litter effects</em>. Prev. Vet. Med. 18, 17-26.<br />
Donner, A., Eliasziw, M., Klar, N., 1994. <em>A comparison of methods for testing homogeneity of proportions in teratologic studies</em>. Stat. Med. 13, 1253-1264.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dja)
# Donner
drs(formula = cbind(m, n - m) ~ group, data = dja, type = "d")
# Rao and Scott
drs(formula = cbind(m, n - m) ~ group, type = "rs", data = dja)
drs(formula = cbind(m, n - m) ~ group, type = "rs", data = dja, pooled = TRUE)
# standard chi2 test
drs(formula = cbind(m, n - m) ~ group, data = dja, type = "d", C = c(1:1))
drs(formula = cbind(m, n - m) ~ group, data = dja, type = "rs", C = c(1:1))
</code></pre>

<hr>
<h2 id='gof'>Test of Goodness-of-Fit of Models for Count data</h2><span id='topic+gof'></span><span id='topic+gof.default'></span><span id='topic+print.gof'></span>

<h3>Description</h3>

<p>The function returns a chi-squared test of goodness of fit for models of class <code>glm</code>, <code>aodml</code> or <code>aodql</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gof(object)
  gof.default(object)
  
  ## S3 method for class 'gof'
print(x, ..., digits =  max(3, getOption("digits") - 3))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>An object of class <code>glm</code>, <code>aodml</code> or <code>aodquasi</code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>An object of class <code>gof</code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_digits">digits</code></td>
<td>
<p>A numerical scalar indicating the number of digits to be printed after the decimal place.</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>gof</code> calculates the deviance <code class="reqn">D</code> and the Pearson chi-squared <code class="reqn">X^2</code> statistics for the model under consideration. Let <code class="reqn">y</code> be the observed response, and <code class="reqn">E[y] = \mu</code> and <code class="reqn">Var[y]</code> its mean and variance estimated from the model, statistic <code class="reqn">X^2</code> is calculated by:
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_{i}( (y_i - \mu)^2/Var[y_i] )</code>
</p>

<p>Assuming that the data length is <code class="reqn">N</code> and the number of the parameters in the model is <code class="reqn">p</code>, eqnD and eqnX^2 are compared to a chi-squared distribution with <code class="reqn">N-p</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of class <code>gof</code>, printed with <code>print.gof</code>.</p>


<h3>References</h3>

<p>Agresti, A. <em>Categorical data analysis</em>. Wiley, 1990.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+chisq.test">chisq.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orob2)
fm1 &lt;- glm(cbind(m, n - m) ~ seed, data = orob2, family = binomial)
fm2 &lt;- aodml(cbind(m, n - m) ~ seed, data = orob2, family = "bb")
gof(fm1)
gof(fm2)
</code></pre>

<hr>
<h2 id='iccbin'>Intra-Cluster Correlation for Clustered Binomial data</h2><span id='topic+iccbin'></span><span id='topic+print.iccbin'></span>

<h3>Description</h3>

<p>The function estimates the intraclass correlation <code class="reqn">\rho</code> from clustered binomial data:
</p>
<p>{<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>},
</p>
<p>where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of &ldquo;successes&rdquo; (proportions are <code class="reqn">y = m/n</code>), and <code class="reqn">N</code> the number of clusters. The function uses a one-way random effect model. Three estimates, corresponding to methods referred to as &ldquo;A&rdquo;, &ldquo;B&rdquo; and &ldquo;C&rdquo; in Goldstein et al. (2002), can be returned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  iccbin(n, m, method = c("A", "B", "C"), nAGQ = 1, M = 1000)
  
  ## S3 method for class 'iccbin'
print(x, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iccbin_+3A_n">n</code></td>
<td>
<p>A vector of the sizes of the clusters.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_m">m</code></td>
<td>
<p>A vector of the numbers of successes (proportions are eqny = m / n).</p>
</td></tr>
<tr><td><code id="iccbin_+3A_method">method</code></td>
<td>
<p>A character (&ldquo;A&rdquo;, &ldquo;B&rdquo; or &ldquo;C&rdquo;) defining the calculation method. See Details.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_nagq">nAGQ</code></td>
<td>
<p>Same as in function <code>glmer</code> of package <span class="pkg">lme4</span>. Only for methods &ldquo;A&rdquo; and &ldquo;B&rdquo;. Default to 1.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_m">M</code></td>
<td>
<p>Number of Monte Carlo (MC) replicates used in method &ldquo;B&rdquo;. Default to 1000.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;iccbin&rdquo;.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_...">...</code></td>
<td>
<p>Further arguments to ba passed to &ldquo;print&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before computations, the clustered data are split to binary &ldquo;0/1&rdquo; observations <code class="reqn">y_{ij}</code> (observation <code class="reqn">j</code> in cluster <code class="reqn">i</code>). The methods of calculation are described in Goldstein et al. (2002).<br /><br />
</p>
<p>Methods &quot;A&quot; and &quot;B&quot; use the 1-way logistic binomial-Gaussian model
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} | \mu_{ij} \sim Bernoulli(\mu_{ij})</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(\mu_{ij}) = b_0 + u_i,</code>
</p>

<p>where <code class="reqn">b_0</code> is a constant and <code class="reqn">u_i</code> a cluster random effect with <code class="reqn">u_i \sim N(0, s^2_u)</code>. The ML estimate of the variance component <code class="reqn">s^2_u</code> is calculated with the function <code>glmer</code> of package <span class="pkg">lme4</span>. The intra-class correlation <code class="reqn">\rho = Corr[y_{ij}, y_{ik}]</code> is then calculated from a first-order model linearization around <code class="reqn">E[u_i]=0</code> in method &ldquo;A&rdquo;, and with Monte Carlo simulations in method &ldquo;B&rdquo;.<br /><br />
</p>
<p>Method &quot;C&quot; provides the common ANOVA (moment) estimate of <code class="reqn">\rho</code>. For details, see for instance Donner (1986), Searle et al. (1992) or Ukoumunne (2002).
</p>


<h3>Value</h3>

<p>An object of class <code>iccbin</code>, printed with <code>print.iccbin</code>.</p>


<h3>References</h3>

<p>Donner A., 1986, <em>A review of inference procedures for the intraclass correlation coefficient in the one-way random effects model</em>. International Statistical Review 54, 67-82.<br />
Searle, S.R., Casella, G., McCulloch, C.E., 1992. <em>Variance components</em>. Wiley, New York.<br />
Ukoumunne, O. C., 2002. <em>A comparison of confidence interval methods for the intraclass correlation coefficient in cluster randomized trials</em>. Statistics in Medicine 21, 3757-3774.<br />
Golstein, H., Browne, H., Rasbash, J., 2002. <em>Partitioning variation in multilevel models</em>.  Understanding Statistics 1(4), 223-231.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+glmer">glmer</a></code><br /></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rats)
z &lt;- rats[rats$group == "TREAT", ]
# A: glmm (model linearization)
iccbin(z$n, z$m, method = "A")
iccbin(z$n, z$m, method = "A", nAGQ = 10)
# B: glmm (Monte Carlo)
iccbin(z$n, z$m, method = "B")
iccbin(z$n, z$m, method = "B", nAGQ = 10, M = 1500)
# C: lmm (ANOVA moments)
iccbin(z$n, z$m, method = "C")

## Not run: 
  # Example of CI calculation with nonparametric bootstrap
  require(boot)
  foo &lt;- function(X, ind) {
    n &lt;- X$n[ind]
    m &lt;- X$m[ind]
    iccbin(n = n, m = m, method = "C")$rho
    }
  res &lt;- boot(data = z[, c("n", "m")], statistic = foo, R = 500, sim = "ordinary", stype = "i")
  res
  boot.ci(res, conf = 0.95, type = "basic")
  
## End(Not run)
  
</code></pre>

<hr>
<h2 id='invlink'>Transformation from the Link Scale to the Observation Scale</h2><span id='topic+invlink'></span>

<h3>Description</h3>

<p>The function transforms a variable from the link scale to the observation scale (probability or count).</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlink(x, type = c("cloglog", "log", "logit", "probit"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invlink_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
<tr><td><code id="invlink_+3A_type">type</code></td>
<td>
<p>A character string: &ldquo;cloglog&rdquo;, &ldquo;log&rdquo;, &ldquo;logit&rdquo; or &ldquo;probit&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clog-log: <code class="reqn">1 - exp(-exp(x))</code><br />
log: <code class="reqn">exp(x)</code><br />
logit: <code class="reqn">exp(x) / (1 + exp(x))</code><br />
probit: <code class="reqn">pnorm(x)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+link">link</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5, 5, length = 100)
plot(x, invlink(x, type = "logit"), type = "l", lwd = 2, ylab = "Probability")
lines(x, invlink(x, type = "cloglog"), lty = 2, lwd = 2)
grid(col = "black")
legend(-5, 1, legend = c("alogit(x)", "acloglog(x)"), lty = c(1, 2), bg = "white")
</code></pre>

<hr>
<h2 id='link'>Transformation from the Observation Scale to the Link Scale</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>The function transforms a variable from the observation scale (probability or count) to the link scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(x, type = c("cloglog", "log", "logit", "probit"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
<tr><td><code id="link_+3A_type">type</code></td>
<td>
<p>A character string: &ldquo;cloglog&rdquo;, &ldquo;log&rdquo;, &ldquo;logit&rdquo; or &ldquo;probit&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clog-log: <code class="reqn">log(-log(1 - x ))</code><br />
log: <code class="reqn">log(x)</code><br />
logit: <code class="reqn">log(x / (1 - x))</code><br />
probit: <code class="reqn">qnorm(x)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invlink">invlink</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(.001, .999, length = 100)
plot(x, link(x, type = "logit"), type = "l", lwd = 2, ylab = "link(proba.)")
lines(x, link(x, type = "cloglog"), lty = 2, lwd = 2)
grid(col = "black")
legend(0, 6, legend = c("logit(x)", "cloglog(x)"), lty = c(1, 2), bg = "white")
</code></pre>

<hr>
<h2 id='lizards'>A Comparison of Site Preferences of Two Species of Lizard</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>&ldquo;These data describe the daytime habits of two species of lizards, <em>grahami</em> and <em>opalinus</em>. 
They were collected by observing occupied sites or perches and recording the appropriate description, namely 
species involved, time of the day, height and diameter of the perch and whether the site was sunny or shaded. 
Time of the day is recorded as early, mid-day or late.&rdquo; (McCullagh and Nelder, 1989, p.129).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizards)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 6 variables.
</p>

<dl>
<dt>Site</dt><dd><p>A factor with levels <code>Sun</code> and <code>Shade</code>.</p>
</dd>
<dt>Diameter</dt><dd><p>A factor with levels <code>D &lt;= 2</code> and <code>D &gt; 2</code> (inches). </p>
</dd>
<dt>Height</dt><dd><p>A factor with levels <code>H &lt; 5</code> and <code>H &gt;= 5</code> (feet).</p>
</dd>
<dt>Time</dt><dd><p>A factor with levels <code>Early</code>, <code>Mid-day</code> and <code>Late</code>.</p>
</dd>
<dt>grahami</dt><dd><p>A numeric vector giving the observed sample size for <em>grahami</em> lizards.</p>
</dd>
<dt>opalinus</dt><dd><p>A numeric vector giving the observed sample size for <em>opalinus</em> lizards.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were originally published in Fienberg (1970).</p>


<h3>Source</h3>

<p>McCullagh, P., Nelder, J. A., 1989, 2nd ed. <em>Generalized linear models</em>. New York, USA: Chapman and Hall.</p>


<h3>References</h3>

<p>Fienberg, S.E., 1970. <em>The analysis of multidimensional contingency tables</em>. Ecology 51: 419-433.</p>

<hr>
<h2 id='mice'>Pregnant Female Mice Experiment</h2><span id='topic+mice'></span>

<h3>Description</h3>

<p>Unpublished laboratory data on the proportion of affected foetuses in two groups (control and treatment) of 10 
pregnant female mice (Kupper and Haseman, 1978, p. 75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mice)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with levels <code>CTRL</code> and <code>TREAT</code></p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the total number of foetuses.</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of affected foetuses.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kupper, L.L., Haseman, J.K., 1978. <em>The use of a correlated binomial model for the analysis of a certain 
toxicological experiments.</em> Biometrics 34, 69-76.
</p>

<hr>
<h2 id='orob1'>Germination Data</h2><span id='topic+orob1'></span>

<h3>Description</h3>

<p>Data describing the germination for seed <em>Orobanche cernua</em> cultivated in three dilutions of a bean root extract (Crowder, 1978, Table 1). The mean proportions of the three groups are 0.142, 0.872 and 0.842, and the overall mean is 0.614.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orob1)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 3 variables.
</p>

<dl>
<dt>dilution</dt><dd><p>a factor with 3 levels: <code>1/1</code>, <code>1/25</code> and <code>1/625</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>n</dt><dd><p>a numeric vector: the number of seeds exposed to germination.</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of seeds which actually germinated.</p>
</dd>
</dl>



<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.
</p>

<hr>
<h2 id='orob2'>Germination Data</h2><span id='topic+orob2'></span>

<h3>Description</h3>

<p>A 2 x 2 factorial experiment comparing 2 types of seed and 2 root extracts (Crowder, 1978, Table 3). There are 5 or 6 replicates in each of the 4 treatment groups, and each replicate comprises a number of seeds varying between 4 and 81. The response variable is the proportion of seeds germinating in each replicate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orob2)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables.
</p>

<dl>
<dt>seed</dt><dd><p>a factor with 2 levels: <code>O73</code> and <code>O75</code>.</p>
</dd>
<dt>root</dt><dd><p>a factor with 2 levels <code>BEAN</code> and <code>CUCUMBER</code>.</p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the number of seeds exposed to germination.</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of seeds which actually germinated.</p>
</dd>
</dl>



<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.
</p>

<hr>
<h2 id='rabbits'>Rabbits Foetuses Survival Experiment</h2><span id='topic+rabbits'></span>

<h3>Description</h3>

<p>Experimental data for analyzing the effect of an increasing dose of a compound on the proportion of live foetuses affected (Paul, 1982, Table 1). Four treatment-groups were considered: control &ldquo;C&rdquo;, low dose &ldquo;L&rdquo;, medium dose &ldquo;M&rdquo; and high dose &ldquo;H&rdquo;. The animal species used in the experiment was banded Dutch rabbit.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rabbits)</code></pre>


<h3>Format</h3>

<p>A data frame with 84 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with levels <code>C</code>, <code>H</code>, <code>L</code> and <code>M</code></p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the total number of foetuses.</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of affected foetuses.</p>
</dd>
</dl>



<h3>References</h3>

<p>Paul, S.R., 1982. <em>Analysis of proportions of affected foetuses in teratological experiments.</em> 
Biometrics 38, 361-370.
</p>

<hr>
<h2 id='rats'>Rats Diet Experiment</h2><span id='topic+rats'></span>

<h3>Description</h3>

<p>&ldquo;Weil (1970) in Table 1 gives the results from an experiment comprising two treatments. One group of 16 pregnant female rats was fed a control diet during pregnancy and lactation, the diet of a second group of 16 pregnant females was treated with a chemical. For each litter the number <code class="reqn">n</code> of pups alive at 4 days and the number <code class="reqn">x</code> of pups that survived the 21 day lactation period were recorded.&rdquo; (Williams, 1975, p. 951).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rats)</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>A factor with levels <code>CTRL</code> and <code>TREAT</code></p>
</dd>
<dt>n</dt><dd><p>A numeric vector: the number of pups alive at 4 days.</p>
</dd>
<dt>m</dt><dd><p>A numeric vector: the number of pups that survived the 21 day lactation.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Williams, D.A., 1975. <em>The analysis of binary responses from toxicological experiments
involving reproduction and teratogenicity</em>. Biometrics 31, 949-952.
</p>


<h3>References</h3>

<p>Weil, C.S., 1970. <em>Selection of the valid number of sampling units and a consideration of their combination in toxicological studies involving reproduction, teratogenesis or carcinogenesis</em>. Fd. Cosmet. Toxicol. 8, 177-182.
</p>

<hr>
<h2 id='salmonella'>Salmonella Reverse Mutagenicity Assay</h2><span id='topic+salmonella'></span>

<h3>Description</h3>

<p>&ldquo;Data for our third example were compiled by Margolin et al. (1981) from an Ames <em>Salmonella</em>
reverse mutagenicity assay. Table 1 shows the number of revertant colonies observed on each of 3 replicate 
plates tested at each of 6 dose levels of quinoline.&rdquo; (Breslow, 1984, Table 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salmonella)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 2 variables.
</p>

<dl>
<dt>dose</dt><dd><p>a numeric vector: the dose level of quinoline (microgram per plate).</p>
</dd>
<dt>m</dt><dd><p>a numeric vector: the number of revertant colonies of TA98 <em>Salmonella</em>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Breslow, N.E., 1984. <em>Extra-Poisson variation in log-linear models</em>. Applied Statistics 33(1), 38-44.</p>


<h3>References</h3>

<p>Margolin, B.H., Kaplan, N., Zeiger, E., 1981. <em>Statistical analysis of the Ames <b>Salmonella</b> / microsome test</em>. Proc. Natl Acad. Sci. USA 76, 3779-3783.
</p>

<hr>
<h2 id='splitbin'>Split Grouped Data Into Individual Data</h2><span id='topic+splitbin'></span>

<h3>Description</h3>

<p>The function splits grouped binomial data and optional covariates to individual binary data. Two types of grouped data are managed by <code>splitbin</code>:
</p>

<ul>
<li><p> Grouped data with weights;
</p>
</li>
<li><p> Grouped data of form <code>cbind(success, failure)</code>.
</p>
</li></ul>

<p>When weights, successes or failures involve non-integer numbers, these numbers are rounded (using <code>round()</code>) before splitting.</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitbin(formula, data, id = "idbin")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitbin_+3A_formula">formula</code></td>
<td>
<p>A formula. The left-hand side describes the grouped data. The right-hand side describes the covariates. See examples for syntax.</p>
</td></tr>
<tr><td><code id="splitbin_+3A_data">data</code></td>
<td>
<p>A data frame where all the variables described in <code>formula</code> are found.</p>
</td></tr>
<tr><td><code id="splitbin_+3A_id">id</code></td>
<td>
<p>An optional character string naming the identifier (= grouping factor). Default to &ldquo;idbin&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame built according to the formula and function used in the call.</p>


<h3>Examples</h3>

<pre><code class='language-R'># grouped data with weights
z &lt;- data.frame(
    m = c(0, 1, 0, 1),
    f1 = c("A", "A", "B", "B"),
    f2 = c("C", "D", "C", "D"),
    n = c(4, 2, 1, 3)
    )
z
splitbin(formula = n ~ f1, data = z)$tab
splitbin(formula = n ~ f1 + f2 + m , data = z)$tab

# grouped data of form "cbind(success, failure)"
z &lt;- data.frame(
    m = c(4, 1),
    n = c(5, 3),
    f1 = c("A", "B"),
    f2 = c("C", "D")
    )
z
splitbin(formula = cbind(m, n - m) ~ 1, data = z)$tab
splitbin(formula = cbind(m, n - m) ~ f1 + f2, data = z)$tab
splitbin(formula = cbind(m, n - m) ~ f1 + f2, data = z)$tab
</code></pre>

<hr>
<h2 id='varbin'>Estimate of a Probability from Clustered Binomial Data</h2><span id='topic+varbin'></span><span id='topic+print.varbin'></span>

<h3>Description</h3>

<p>The function estimates a probability and its variance from clustered binomial data
</p>
<p>{<code class="reqn">(n_1, m_1), (n_2, m_2), ..., (n_N, m_N)</code>},
</p>
<p>where <code class="reqn">n_i</code> is the size of cluster <code class="reqn">i</code>, <code class="reqn">m_i</code> the number of &ldquo;successes&rdquo; (proportions are <code class="reqn">y = m/n</code>), and <code class="reqn">N</code> the number of clusters. Confidence intervals are calculated using a normal approximation, which might be inappropriate when the probability is close to 0 or 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  varbin(n, m, alpha = 0.05, R = 5000)
  
  ## S3 method for class 'varbin'
print(x, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varbin_+3A_n">n</code></td>
<td>
<p>A vector of the sizes of the clusters.</p>
</td></tr>
<tr><td><code id="varbin_+3A_m">m</code></td>
<td>
<p>A vector of the numbers of successes (proportions are eqny = m / n).</p>
</td></tr>
<tr><td><code id="varbin_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the confidence intervals. Default to 0.05, providing 95% CI's.</p>
</td></tr>
<tr><td><code id="varbin_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates to compute bootstrap mean and variance. Default to 5000.</p>
</td></tr>
<tr><td><code id="varbin_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;varbin&rdquo;.</p>
</td></tr>
<tr><td><code id="varbin_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to &ldquo;print&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Five methods are used for the estimations. Let us consider <code class="reqn">N</code> clusters of sizes <code class="reqn">n_1, \ldots, n_N</code> with observed count responses <code class="reqn">m_1, \ldots, m_N</code>. We note <code class="reqn">y_i = m_i/n_i (i = 1, \ldots, N)</code> the observed proportions. The underlying assumption is that the probability, say <code class="reqn">mu</code>, is homogeneous across the clusters.
</p>
<p><b>Binomial method:</b> the probability estimate and its variance are calculated by
</p>
<p><code class="reqn">\mu = (sum_{i} (m_i)) / (sum_{i} (n_i))</code> (ratio estimate) and
</p>
<p><code class="reqn">\mu * (1 - \mu) / (sum_{i} (n_i) - 1)</code>, respectively.
</p>
<p><b>Ratio method:</b> the probability <code class="reqn">\mu</code> is estimated as for the binomial method (ratio estimate). The one-stage cluster sampling formula is used to calculate the variance of <code class="reqn">\mu</code> (see Cochran, 1999, p. 32 and p. 66).
</p>
<p><b>Arithmetic method:</b> the probability is estimated by <code class="reqn">\mu = sum_{i} (y_i) / N</code>. The variance of <code class="reqn">\mu</code> is estimated by <code class="reqn">sum_{i} (y_i - \mu)^2 / (N * (N - 1))</code>.
</p>
<p><b>Jackknife method:</b> the probability is estimated by <code class="reqn">\mu</code> defined by the arithmetic mean of the pseudovalues <code class="reqn">y_{v,i}</code>. The variance is estimated  by <code class="reqn">sum_{i} (y_{v,i} - \mu)^2 / (N * (N - 1))</code> (Gladen, 1977, Paul, 1982).
</p>
<p><b>Bootstrap method:</b> <code class="reqn">R</code> samples of clusters of size <code class="reqn">N</code> are drawn with equal probability from the initial sample <code class="reqn">(y_1, \ldots , y_N)</code> (Efron and Tibshirani, 1993). The bootstrap estimate <code class="reqn">\mu</code> and its estimated variance  are the arithmetic mean and the empirical variance (computed with denominator <code class="reqn">R - 1</code>) of the <code class="reqn">R</code> binomial ratio estimates, respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>varbin</code>, printed with <code>print.varbin</code>.</p>


<h3>References</h3>

<p>Cochran, W.G., 1999, 3th ed. <em>Sampling techniques</em>. Wiley, New York.<br />
Efron, B., Tibshirani, R., 1993. <em>An introduction to the bootstrap</em>. Chapman and Hall, London.<br />
Gladen, B., 1977. <em>The use of the jackknife to estimate proportions from toxicological data in the presence 
of litter effects</em>. JASA 74(366), 278-283.<br />
Paul, S.R., 1982. <em>Analysis of proportions of affected foetuses in teratological experiments</em>. 
Biometrics 38, 361-370.
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rabbits)
z &lt;- rabbits[rabbits$group == "M", ]
varbin(z$n, z$m)
by(rabbits,
	list(group = rabbits$group),
  function(x) varbin(n = x$n, m = x$m, R = 1000))
</code></pre>

<hr>
<h2 id='wald.test'>Wald Test for Model Coefficients</h2><span id='topic+wald.test'></span><span id='topic+print.wald.test'></span>

<h3>Description</h3>

<p>The function returns a Wald chi-squared test or a <code class="reqn">F</code> test for a vector of model coefficients (possibly of length one), given its variance-covariance matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wald.test(b, varb, Terms = NULL, L = NULL, H0 = NULL,  df = NULL, verbose = FALSE, ...)
  
  ## S3 method for class 'wald.test'
print(x, ..., digits = max(3, getOption("digits") - 3))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald.test_+3A_b">b</code></td>
<td>

<p>A vector of coefficients with their var-cov matrix <code>varb</code>. Coefficients <code>b</code> and var-cov matrix are usually extracted using appropriate <code>coef</code> and <code>vcov</code> functions.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_varb">varb</code></td>
<td>

<p>A var-cov matrix of coefficients <code>b</code> (see above).
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_terms">Terms</code></td>
<td>

<p>An optional integer vector specifying which coefficients should be <em>jointly</em> tested, using a Wald chi-squared test or a<code class="reqn">F</code> test. The elements of <code>varb</code> correspond to the columns or rows of the var-cov matrix given in <code>varb</code>. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_l">L</code></td>
<td>

<p>An optional matrix conformable to <code>b</code>, such as its product with <code>b</code> i.e., <code>L %*% b</code> gives the linear combinations of the coefficients to be tested. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_h0">H0</code></td>
<td>

<p>A numeric vector giving the null hypothesis <code class="reqn">H_0</code> for the test. It must be as long as <code>Terms</code> or must have the same number of columns as <code>L</code>. Default to 0 for all the coefficients to be tested.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_df">df</code></td>
<td>

<p>A numeric vector giving the degrees of freedom to be used in an <code class="reqn">F</code> test, i.e. the degrees of freedom of the residuals of the model from which <code>b</code> and <code>varb</code> were fitted. Default to NULL, for no <code class="reqn">F</code> test. See the section <b>Details</b> for more information.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_verbose">verbose</code></td>
<td>

<p>A logical scalar controlling the amount of output information. The default is <code>FALSE</code>, providing minimum output.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;wald.test&rdquo;</p>
</td></tr>
<tr><td><code id="wald.test_+3A_digits">digits</code></td>
<td>
<p>A numeric scalar indicating the number of digits to be kept after the decimal place.</p>
</td></tr>
<tr><td><code id="wald.test_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>print</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumption is that the coefficients follow asymptotically a multivariate normal distribution with mean equal to the model coefficients <code>b</code> and variance equal to their var-cov matrix <code>varb</code>.<br /><br />
</p>
<p>One (and only one) of <code>Terms</code> or <code>L</code> must be given. When <code>L</code> is given, it must have the same number of columns as the length of <code>b</code>, and the same number of rows as the number of linear combinations of coefficients.<br /><br />
</p>
<p>When <code>df</code> is given, the chi-squared Wald statistic is divided by <code>m</code>, the number of linear combinations of coefficients to be tested (i.e., <code>length(Terms)</code> or <code>nrow(L)</code>). Under the null hypothesis <code class="reqn">H_0</code>, this new statistic follows an <code class="reqn">F(m, df)</code> distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>wald.test</code>, printed with <code>print.wald.test</code>.</p>


<h3>References</h3>

<p>Diggle, P.J., Liang, K.-Y., Zeger, S.L., 1994. <em>Analysis of longitudinal data</em>. Oxford, Clarendon Press, 253 p.<br />
Draper, N.R., Smith, H., 1998. <em>Applied Regression Analysis</em>. New York, John Wiley &amp; Sons, Inc., 706 p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(orob2)
fm &lt;- aodql(cbind(m, n - m) ~ seed * root, data = orob2, family = "qbin")
# Wald chi2 test for the effect of root
wald.test(b = coef(fm), varb = vcov(fm), Terms = 3:4)
L &lt;- matrix(c(0, 0, 1, 0, 0, 0, 0, 1), nrow = 2, byrow = TRUE)
wald.test(b = coef(fm), varb = vcov(fm), L = L)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
