<!DOCTYPE html><html><head><title>Help for package GALLO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GALLO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoStopCluster'><p>Sub-function to auto-stop the clusters created for parallel processes</p></a></li>
<li><a href='#find_genes_qtls_around_markers'><p>Search genes and QTLs around candidate regions</p></a></li>
<li><a href='#find_markers_genes'><p>Function to annotate markers and the respective p-values within genes</p></a></li>
<li><a href='#gene_pval'><p>Estimate a gene-level p-value using Weighted Z-score approach and Meta-analysis with LD correlation coefficients approach</p></a></li>
<li><a href='#gffQTLs'><p>A gff example for QTL annotation</p></a></li>
<li><a href='#Global'><p>Global variables</p></a></li>
<li><a href='#gtfGenes'><p>A gtf example for gene annotation</p></a></li>
<li><a href='#import_gff_gtf'><p>Import .gtf and .gff files to be used during gene and QTL annotation, respectively</p></a></li>
<li><a href='#inferCut'><p>Compute the eigenvalues for the linkage disequilibrium (LD) matrix and use as input for PCA_Meff function to compute the effective number of markers</p></a></li>
<li><a href='#meta_LD'><p>unction to perform Meta-Analysis with LD Correlation Coefficients</p></a></li>
<li><a href='#NetCen'><p>Compute the centrality metrics for the nodes composing the network generated by the NetVis function</p></a></li>
<li><a href='#NetVis'><p>Create a dynamic network representing the relationship between two groups of variables</p></a></li>
<li><a href='#Nmarkers_SimpleM'><p>Estimate the number of effective markers in a chromosome based on an adapted version of the simpleM methodology</p></a></li>
<li><a href='#Nseg_chr'><p>Estimate the number of independent segments in a chromosome based on the effective population size</p></a></li>
<li><a href='#overlapping_among_groups'><p>Overlapping between grouping factors</p></a></li>
<li><a href='#PCA_Meff'><p>Compute Meff statistic based on PCA to determine the number of effective markers</p></a></li>
<li><a href='#PleioChiTest'><p>Compute a multi-trait test statistic for pleiotropic effects using summary statistics from association tests</p></a></li>
<li><a href='#plot_overlapping'><p>Plot overlapping between data and grouping factors</p></a></li>
<li><a href='#plot_qtl_info'><p>Plot QTLs information from the find_genes_qtls_around_markers output</p></a></li>
<li><a href='#qtl_enrich'><p>Performs a QTL enrichment analysis based on a hypergeometric test for each QTL class</p></a></li>
<li><a href='#QTLenrich_plot'><p>Plot enrichment results for QTL enrichment analysis</p></a></li>
<li><a href='#QTLmarkers'><p>Candidate markers identified by GWAS associated with fertility traits in cattle</p></a></li>
<li><a href='#QTLwindows'><p>Candidate windows identified by GWAS associated with fertility traits in cattle</p></a></li>
<li><a href='#relationship_plot'><p>Plot relationship between data and grouping factors</p></a></li>
<li><a href='#splitQTL_comment'><p>Sub-function to split comment column from QTL output</p></a></li>
<li><a href='#sub_genes_markers'><p>Sub-function to search genes around candidate markers</p></a></li>
<li><a href='#sub_genes_windows'><p>Sub-function to search genes around candidate markers</p></a></li>
<li><a href='#sub_qtl_markers'><p>Sub-function to search QTLs around candidate markers</p></a></li>
<li><a href='#sub_qtl_windows'><p>Sub-function to search QTLs around candidate markers</p></a></li>
<li><a href='#sub_qtlEnrich_chrom'><p>Performs a QTL enrichment analysis based in a Bootstrap simulation for each QTL class using the QTL information per chromosome</p></a></li>
<li><a href='#sub_qtlEnrich_geno'><p>Performs a QTL enrichment analysis based in a Bootstrap simulation for each QTL class using the QTL information across the whole genome</p></a></li>
<li><a href='#WZ_ld'><p>Function to perform Weighted Z-score Approach with LD Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Genomic Annotation in Livestock for Positional Candidate LOci</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>The accurate annotation of genes and Quantitative Trait Loci (QTLs) located within candidate markers and/or regions (haplotypes, windows, CNVs, etc) is a crucial step the most common genomic analyses performed in livestock, such as Genome-Wide Association Studies or transcriptomics. The Genomic Annotation in Livestock for positional candidate LOci (GALLO) is an R package designed to provide an intuitive and straightforward environment to annotate positional candidate genes and QTLs from high-throughput genetic studies in livestock. Moreover, GALLO allows the graphical visualization of gene and QTL annotation results, data comparison among different grouping factors (e.g., methods, breeds, tissues, statistical models, studies, etc.), and QTL enrichment in different livestock species including cattle, pigs, sheep, and chicken, among others.</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/pablobio/GALLO&amp;gt;">https://github.com/pablobio/GALLO&gt;</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Software</td>
</tr>
<tr>
<td>Imports:</td>
<td>circlize, data.table, doParallel, dplyr, ggplot2, graphics,
grDevices, foreach, lattice , parallel, RColorBrewer,
rtracklayer, stats, stringr, unbalhaar, utils, DT, webshot,
igraph, visNetwork</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Hmisc, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 09:18:49 UTC; Usuario</td>
</tr>
<tr>
<td>Author:</td>
<td>Pablo Fonseca [aut, cre],
  Aroa Suarez-Vega [aut],
  Gabriele Marras [aut],
  Angela Cánovas [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pablo Fonseca &lt;pfonseca@uoguelph.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoStopCluster'>Sub-function to auto-stop the clusters created for parallel processes</h2><span id='topic+autoStopCluster'></span>

<h3>Description</h3>

<p>Sub-function to auto-stop the clusters created for parallel processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoStopCluster(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoStopCluster_+3A_cl">cl</code></td>
<td>
<p>The cluster created by the makePSOCKcluster function</p>
</td></tr>
</table>

<hr>
<h2 id='find_genes_qtls_around_markers'>Search genes and QTLs around candidate regions</h2><span id='topic+find_genes_qtls_around_markers'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and or regions (haplotypes, CNVs, windows, etc.) and search for genes or QTLs in a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_genes_qtls_around_markers(
  db_file,
  marker_file,
  method = c("gene", "qtl"),
  marker = c("snp", "haplotype"),
  interval = 0,
  nThreads = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_genes_qtls_around_markers_+3A_db_file">db_file</code></td>
<td>
<p>The data frame obtained using the import_gff_gtf() function</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_marker_file">marker_file</code></td>
<td>
<p>The file with the SNP or haplotype positions. Detail: For SNP files, the columns “CHR” and “BP” with the chromosome and base pair position, respectively, are mandatory. For the haplotype, the following columns are mandatory: “CHR”, “BP1” and “BP2”</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_method">method</code></td>
<td>
<p>“gene” or “qtl”</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_marker">marker</code></td>
<td>
<p>&quot;snp&quot; or &quot;haplotype&quot;</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_interval">interval</code></td>
<td>
<p>The interval in base pair which can be included upstream and downstream from the markers or haplotype coordinates.</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_nthreads">nThreads</code></td>
<td>
<p>Number of threads to be used</p>
</td></tr>
<tr><td><code id="find_genes_qtls_around_markers_+3A_verbose">verbose</code></td>
<td>
<p>Logical value defining if messages should of not be printed during the analysis (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the genes or QTLs mapped within the specified intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gffQTLs)
out.qtls&lt;-find_genes_qtls_around_markers(db_file=gffQTLs, marker_file=QTLmarkers,
method = "qtl", marker = "snp",
interval = 500000, nThreads = 1)
</code></pre>

<hr>
<h2 id='find_markers_genes'>Function to annotate markers and the respective p-values within genes</h2><span id='topic+find_markers_genes'></span>

<h3>Description</h3>

<p>Function to annotate markers and the respective p-values within genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_markers_genes(db_file, marker_file, int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_markers_genes_+3A_db_file">db_file</code></td>
<td>
<p>A data frame obtained from the import_gff_gtf containing the gtf information</p>
</td></tr>
<tr><td><code id="find_markers_genes_+3A_marker_file">marker_file</code></td>
<td>
<p>A data frame with the results of the association test performed for each marker</p>
</td></tr>
<tr><td><code id="find_markers_genes_+3A_int">int</code></td>
<td>
<p>The interval (in base pairs) used to annotated markers downstream and upstream from the genes coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the markers mapped within the selected interval for each gene in the annotation file
</p>

<hr>
<h2 id='gene_pval'>Estimate a gene-level p-value using Weighted Z-score approach and Meta-analysis with LD correlation coefficients approach</h2><span id='topic+gene_pval'></span>

<h3>Description</h3>

<p>Estimate a gene-level p-value using Weighted Z-score approach and Meta-analysis with LD correlation coefficients approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_pval(data, db_file, marker_ld, interval, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_pval_+3A_data">data</code></td>
<td>
<p>A data frame with the results of the association test performed for each marker</p>
</td></tr>
<tr><td><code id="gene_pval_+3A_db_file">db_file</code></td>
<td>
<p>A data frame obtained from the import_gff_gtf containing the gtf information</p>
</td></tr>
<tr><td><code id="gene_pval_+3A_marker_ld">marker_ld</code></td>
<td>
<p>A data frame containing the pairwise linkage disequilibrium between markers in a chromosome</p>
</td></tr>
<tr><td><code id="gene_pval_+3A_interval">interval</code></td>
<td>
<p>The interval (in base pairs) used to annotated markers downstream and upstream from the genes coordinates</p>
</td></tr>
<tr><td><code id="gene_pval_+3A_p">p</code></td>
<td>
<p>The name of the column containing the P-values for each marker</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a table with p-values from a association test, a gtf file file the gene coordinates in the same assembly used to map the variants used in the association study, and a data frame with pairwise linkage disequilibrium (LD) values between markers. This analysis must be performed for each chromosome individually. The data frame with the results of the association study must have three mandatory columns names as CHR, BP and SNP containing the chromosome, base pair position and marker name, respectively. The gtf file must be imported by the import_gff_gtf() function from GALLO or can be customized by the user, since it has the same columns names. The LD table must contain three mandatory columns, SNP_A, SNP_B and R. where, the first two columns must contain the marker names and the third column, the LD value between these markers. This dtaa frame can be obtained using PLINK or any other software which computes pairwise LD between markers in the same chromosome. In the absence of LD values between any two SNPs in the data frame, a LD equal zero is assumed
</p>


<h3>Value</h3>

<p>A data frame with the gene level p-values obtained using the Weighted Z-score approach (P_WZ_ld) and Meta-analysis with LD correlation coefficients approach (P_meta_LD)
</p>

<hr>
<h2 id='gffQTLs'>A gff example for QTL annotation</h2><span id='topic+gffQTLs'></span>

<h3>Description</h3>

<p>Data from the Animal QTLdb comprasing the bovine QTL annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gffQTLs)
</code></pre>


<h3>Format</h3>

<p>A data frame with 111742 rows and 6 variables:
</p>

<ul>
<li><p> chr: Chromosome
</p>
</li>
<li><p> database: The database which the QTL information was retrieved
</p>
</li>
<li><p> QTL_type: The class of each QTL annotated in the database
</p>
</li>
<li><p> start_pos: Start position in the genome for each QTL
</p>
</li>
<li><p> end_pos: End position in the genome for each QTL
</p>
</li>
<li><p> extra_info: Additional information about the QTLs, such as QTL ID, Name, PUBMED ID, mapping type, among others
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(gffQTLs)
</code></pre>

<hr>
<h2 id='Global'>Global variables</h2><span id='topic+Global'></span>

<h3>Description</h3>

<p>Global variables
</p>

<hr>
<h2 id='gtfGenes'>A gtf example for gene annotation</h2><span id='topic+gtfGenes'></span>

<h3>Description</h3>

<p>Data from the Ensembl comprasing the gene annotation for the bovine genome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gtfGenes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 24616 rows and 8 variables:
</p>

<ul>
<li><p> chr: Chromosome
</p>
</li>
<li><p> start_pos: Start position in the genome for each geme
</p>
</li>
<li><p> end_pos: End position in the genome for each gene
</p>
</li>
<li><p> width Gene length
</p>
</li>
<li><p> strand Strand which the gene is mapped (+ or -)
</p>
</li>
<li><p> gene_id Ensemble gene ID
</p>
</li>
<li><p> gene_name Gene symbol
</p>
</li>
<li><p> gene_biotype Gene biotype
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(gtfGenes)
</code></pre>

<hr>
<h2 id='import_gff_gtf'>Import .gtf and .gff files to be used during gene and QTL annotation, respectively</h2><span id='topic+import_gff_gtf'></span>

<h3>Description</h3>

<p>Takes a .gft or .gff file and import into a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_gff_gtf(db_file, file_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_gff_gtf_+3A_db_file">db_file</code></td>
<td>
<p>File with the gene mapping or QTL information. For gene mapping, a .gtf file  from Ensembl database must be used. For the QTL search, a .gff file from Animal QTlLdb must be used. Both files must use the same reference annotation used in the original study</p>
</td></tr>
<tr><td><code id="import_gff_gtf_+3A_file_type">file_type</code></td>
<td>
<p>&quot;gtf&quot; or &quot;gff&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the gtf or gtf content
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gffpath &lt;- system.file("extdata", "example.gff", package="GALLO")

qtl.inp &lt;- import_gff_gtf(db_file=gffpath,file_type="gff")
</code></pre>

<hr>
<h2 id='inferCut'>Compute the eigenvalues for the linkage disequilibrium (LD) matrix and use as input for PCA_Meff function to compute the effective number of markers</h2><span id='topic+inferCut'></span>

<h3>Description</h3>

<p>Compute the eigenvalues for the linkage disequilibrium (LD) matrix and use as input for PCA_Meff function to compute the effective number of markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferCut(mat.r, cut.off)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferCut_+3A_mat.r">mat.r</code></td>
<td>
<p>A matrix composed by the LD between markers</p>
</td></tr>
<tr><td><code id="inferCut_+3A_cut.off">cut.off</code></td>
<td>
<p>The threshold for percentage of the sum of the variances explained by the markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The effective number of markers identified by the SimpleM approach
</p>

<hr>
<h2 id='meta_LD'>unction to perform Meta-Analysis with LD Correlation Coefficients</h2><span id='topic+meta_LD'></span>

<h3>Description</h3>

<p>unction to perform Meta-Analysis with LD Correlation Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_LD(marker_ld, marker_pvalues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta_LD_+3A_marker_ld">marker_ld</code></td>
<td>
<p>A dataframe containing the pairwise linkage disequilibrium between markers in a chromosome</p>
</td></tr>
<tr><td><code id="meta_LD_+3A_marker_pvalues">marker_pvalues</code></td>
<td>
<p>A vector with the p-values for the SNPs annotated within each gene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of p-values for each gene annotated within the defined coordinates
</p>

<hr>
<h2 id='NetCen'>Compute the centrality metrics for the nodes composing the network generated by the NetVis function</h2><span id='topic+NetCen'></span>

<h3>Description</h3>

<p>Compute the centrality metrics for the nodes composing the network generated by the NetVis function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetCen(data, g1, g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetCen_+3A_data">data</code></td>
<td>
<p>A data frame containing the relationship between the two groups to be represented in the network</p>
</td></tr>
<tr><td><code id="NetCen_+3A_g1">g1</code></td>
<td>
<p>Name of the column containing the labels of the first group that will be used to create the network</p>
</td></tr>
<tr><td><code id="NetCen_+3A_g2">g2</code></td>
<td>
<p>Name of the column containing the labels of the second group that will be used to create the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the following centrality metrics for each node that composed the network: Degree (The number of edges incident to the node), Betweenness (The fraction of shortest paths between pairs of nodes that pass through the node), Closeness (The inverse of the sum of the shortest path distances from the node to all other nodes), and Eigenvector Centrality (The centrality measure based on the eigenvector of the adjacency matrix).
</p>


<h3>Value</h3>

<p>A data frame with the centrality metrics for each node in the network.
</p>

<hr>
<h2 id='NetVis'>Create a dynamic network representing the relationship between two groups of variables</h2><span id='topic+NetVis'></span>

<h3>Description</h3>

<p>Create a dynamic network representing the relationship between two groups of variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetVis(
  data,
  g1,
  g2,
  col1 = "aquamarine",
  col2 = "red",
  edge_col = "gray",
  remove_label = NULL,
  node_size = c(15, 40),
  font_size = 45,
  edge_width = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetVis_+3A_data">data</code></td>
<td>
<p>A data frame containing the relationship between the two groups to be represented in the network</p>
</td></tr>
<tr><td><code id="NetVis_+3A_g1">g1</code></td>
<td>
<p>Name of the column containing the labels of the first group that will be used to create the network</p>
</td></tr>
<tr><td><code id="NetVis_+3A_g2">g2</code></td>
<td>
<p>Name of the column containing the labels of the second group that will be used to create the network</p>
</td></tr>
<tr><td><code id="NetVis_+3A_col1">col1</code></td>
<td>
<p>Color of the nodes that will represent the first group represented in the network. The default value is aquamarine</p>
</td></tr>
<tr><td><code id="NetVis_+3A_col2">col2</code></td>
<td>
<p>Color of the nodes that will represent the second group represented in the network The default value is red</p>
</td></tr>
<tr><td><code id="NetVis_+3A_edge_col">edge_col</code></td>
<td>
<p>Color of the edges that will connect the nodes in the network. The default value is gray</p>
</td></tr>
<tr><td><code id="NetVis_+3A_remove_label">remove_label</code></td>
<td>
<p>If is required to omit the labels for some of the groups, this argument receives the column name informed  the g1 or g2 arguments. The default value is NULL</p>
</td></tr>
<tr><td><code id="NetVis_+3A_node_size">node_size</code></td>
<td>
<p>A vector with the node sizes to represent g1 and g2. The defaul values are 15 and 40, respectively</p>
</td></tr>
<tr><td><code id="NetVis_+3A_font_size">font_size</code></td>
<td>
<p>The size of the font of the labels of each node (The default value is 45)</p>
</td></tr>
<tr><td><code id="NetVis_+3A_edge_width">edge_width</code></td>
<td>
<p>The width of the edges connecting the nodes in the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a dynamic network, using visNetwork, representing the connection between two groups. For example, the output from the find_genes_qtls_around_markers() function can be used here to represent the connections between markers and QTLs. Another option is to combine the data frames with both gene and QTL annotation around markers to reprsent the connections between genes and QTLs.
</p>


<h3>Value</h3>

<p>A dynamic network representing the connection between two groups.
</p>

<hr>
<h2 id='Nmarkers_SimpleM'>Estimate the number of effective markers in a chromosome based on an adapted version of the simpleM methodology</h2><span id='topic+Nmarkers_SimpleM'></span>

<h3>Description</h3>

<p>Estimate the number of effective markers in a chromosome based on an adapted version of the simpleM methodology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nmarkers_SimpleM(ld.file, PCA_cutoff = 0.995)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nmarkers_SimpleM_+3A_ld.file">ld.file</code></td>
<td>
<p>A data frame with the pairwise linkage disequilibrium (LD) values for a chromosome. The column names SNP_A, SNP_B, and R are mandatory, where the SNP_A and SNP_B contained the markers names and the R column the LD values between the two markers.</p>
</td></tr>
<tr><td><code id="Nmarkers_SimpleM_+3A_pca_cutoff">PCA_cutoff</code></td>
<td>
<p>A cutoff for the total of the variance explained by the markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimate the effective number of markers in a chromosome using adapted version of the simpleM methodology described in Gao et al. (2008). The function use as input a data frame composed by three mandatory columns (SNP_A, SNP_B, and R). This data frame can be obtained using PLINK or any other software to compute LD between markers. Additionally, a threshold for percentage of the sum of the variances explained by the markers must be provided. The number of effective markers identified by this approach can be used in multiple testing corrections, such as Bonferroni.
</p>


<h3>Value</h3>

<p>The effective number of markers identified by the SimpleM approach
</p>


<h3>References</h3>

<p>Gao et al. (2008) Genet Epidemiol, Volume 32, Issue 4, Pages 361-369.
(<a href="https://doi.org/10.1002/gepi.20310">doi:10.1002/gepi.20310</a>)
</p>

<hr>
<h2 id='Nseg_chr'>Estimate the number of independent segments in a chromosome based on the effective population size</h2><span id='topic+Nseg_chr'></span>

<h3>Description</h3>

<p>Estimate the number of independent segments in a chromosome based on the effective population size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nseg_chr(chr.table, chr_length, Ne)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nseg_chr_+3A_chr.table">chr.table</code></td>
<td>
<p>A table containing the chromosomes and the chromosomal length (in centiMorgans).</p>
</td></tr>
<tr><td><code id="Nseg_chr_+3A_chr_length">chr_length</code></td>
<td>
<p>The name of the column where the length of the chromosomes are informed.</p>
</td></tr>
<tr><td><code id="Nseg_chr_+3A_ne">Ne</code></td>
<td>
<p>The effective population size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a adapted version of the formula proposed by Goddard et al. (2011) to estimate the independent number of segments in a chromosome based on the effective population size.
</p>


<h3>Value</h3>

<p>A data frame with the effevtive number of segments in each chromosome.
</p>


<h3>References</h3>

<p>Goddard et al. (2011) Journal of animal breeding and genetics, Volume 128, Issue 6, Pages 409-421.
(<a href="https://doi.org/10.1111/j.1439-0388.2011.00964.x">doi:10.1111/j.1439-0388.2011.00964.x</a>)
</p>

<hr>
<h2 id='overlapping_among_groups'>Overlapping between grouping factors</h2><span id='topic+overlapping_among_groups'></span>

<h3>Description</h3>

<p>Takes a dataframe with a column of genes, QTLs (or other data) and a grouping column and create some matrices with the overlapping information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapping_among_groups(file, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapping_among_groups_+3A_file">file</code></td>
<td>
<p>A dataframe with the data and grouping factor</p>
</td></tr>
<tr><td><code id="overlapping_among_groups_+3A_x">x</code></td>
<td>
<p>The grouping factor to be compared</p>
</td></tr>
<tr><td><code id="overlapping_among_groups_+3A_y">y</code></td>
<td>
<p>The data to be compared among the levels of the grouping factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three matrices: 1) A matrix with the number of overlapping data; 2) A matrix with the percentage of overlapping; 3) A matrix with the combination of the two previous one
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gtfGenes)
genes.out &lt;- find_genes_qtls_around_markers(db_file=gtfGenes,
marker_file=QTLmarkers,method="gene",
marker="snp",interval=100000, nThreads=1)
overlapping.out&lt;-overlapping_among_groups(
file=genes.out,x="Reference",y="gene_id")
</code></pre>

<hr>
<h2 id='PCA_Meff'>Compute Meff statistic based on PCA to determine the number of effective markers</h2><span id='topic+PCA_Meff'></span>

<h3>Description</h3>

<p>Compute Meff statistic based on PCA to determine the number of effective markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA_Meff(eigenV, cut.off)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_Meff_+3A_eigenv">eigenV</code></td>
<td>
<p>The eigenvalues obtained from the linkage disequilibrium matrix</p>
</td></tr>
<tr><td><code id="PCA_Meff_+3A_cut.off">cut.off</code></td>
<td>
<p>The threshold for percentage of the sum of the variances explained by the markers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The effective number of markers identified by the SimpleM approach
</p>

<hr>
<h2 id='PleioChiTest'>Compute a multi-trait test statistic for pleiotropic effects using summary statistics from association tests</h2><span id='topic+PleioChiTest'></span>

<h3>Description</h3>

<p>Compute a multi-trait test statistic for pleiotropic effects using summary statistics from association tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PleioChiTest(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PleioChiTest_+3A_data">data</code></td>
<td>
<p>A data frame with the first column containing the SNP name and the remaining columns the signed t-values obtained for each marker in the association studies individually performed for each trait.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests a null hypothesis stating that each SNP does not affect any of the traits included in the input file. The method applied here is an implementation of the statistic proposed at Bolormaa et al. (2014) and is approximately distributed as a chi-squared with n degrees of freedom, where n is equal the number of traits included in the input file.
</p>


<h3>Value</h3>

<p>A data frame with the multi-trait chi-squared statistics and the correspondent p-value obtained for each SNP.
</p>


<h3>References</h3>

<p>Bolormaa et al. (2014) Plos Genetics, Volume 10, Issue 3, e1004198.
(<a href="https://doi.org/10.1371/journal.pgen.1004198">doi:10.1371/journal.pgen.1004198</a>)
</p>

<hr>
<h2 id='plot_overlapping'>Plot overlapping between data and grouping factors</h2><span id='topic+plot_overlapping'></span>

<h3>Description</h3>

<p>Takes the output from overlapping_among_groups function and creates a heatmap with the overlapping between groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_overlapping(overlapping_matrix, nmatrix, ntext, group, labelcex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_overlapping_+3A_overlapping_matrix">overlapping_matrix</code></td>
<td>
<p>The object obtained in overlapping_amoung_groups function</p>
</td></tr>
<tr><td><code id="plot_overlapping_+3A_nmatrix">nmatrix</code></td>
<td>
<p>An interger from 1 to 3 indicating which matrix will be used to plot the overlapping, where: 1) A matrix with the number of overllaping data; 2) A matrix with the percentage of overlapping; 3) A matrix with the combination of the two previous one</p>
</td></tr>
<tr><td><code id="plot_overlapping_+3A_ntext">ntext</code></td>
<td>
<p>An interger from 1 to 3 indicating which matrix will be used as the text matrix for the heatmap, where: 1) A matrix with the number of overllaping data; 2) A matrix with the percentage of overlapping; 3) A matrix with the combination of the two previous one</p>
</td></tr>
<tr><td><code id="plot_overlapping_+3A_group">group</code></td>
<td>
<p>A vector with the size of groups. This vector will be plotted as row and column names in the heatmap</p>
</td></tr>
<tr><td><code id="plot_overlapping_+3A_labelcex">labelcex</code></td>
<td>
<p>A numeric value indicating the size of the row and column labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap with the overlapping between groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gtfGenes)
genes.out &lt;- find_genes_qtls_around_markers(
db_file=gtfGenes, marker_file=QTLmarkers,
method="gene", marker="snp",interval=100000,
nThreads=1)

overlapping.out&lt;-overlapping_among_groups(
file=genes.out,x="Reference",y="gene_id")
plot_overlapping(overlapping.out,
nmatrix=2,ntext=2,
group=unique(genes.out$Reference))
</code></pre>

<hr>
<h2 id='plot_qtl_info'>Plot QTLs information from the find_genes_qtls_around_markers output</h2><span id='topic+plot_qtl_info'></span>

<h3>Description</h3>

<p>Takes the output from find_genes_qtls_around_markers and create plots for the frequency of each QTL type and trait
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_qtl_info(
  qtl_file,
  qtl_plot = c("qtl_type", "qtl_name"),
  n = "all",
  qtl_class = NULL,
  horiz = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_qtl_info_+3A_qtl_file">qtl_file</code></td>
<td>
<p>The output from find_genes_qtls_around_markers function</p>
</td></tr>
<tr><td><code id="plot_qtl_info_+3A_qtl_plot">qtl_plot</code></td>
<td>
<p>&quot;qtl_type&quot; or&quot;qtl_name&quot;</p>
</td></tr>
<tr><td><code id="plot_qtl_info_+3A_n">n</code></td>
<td>
<p>Number of QTLs to be plotted when the qtl_name option is selected</p>
</td></tr>
<tr><td><code id="plot_qtl_info_+3A_qtl_class">qtl_class</code></td>
<td>
<p>Class of QTLs to be plotted when the qtl_name option is selected</p>
</td></tr>
<tr><td><code id="plot_qtl_info_+3A_horiz">horiz</code></td>
<td>
<p>The legend of the pie plot for the qtl_type should be plotted vertically or horizontally. The default is FALSE. Therefore, the legend is plotted vertically.</p>
</td></tr>
<tr><td><code id="plot_qtl_info_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to/from other methods. For the default method these can include further arguments (such as axes, asp and main) and graphical parameters (see par) which are passed to plot.window(), title() and axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the requested information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gffQTLs)

out.qtls&lt;-find_genes_qtls_around_markers(db_file=gffQTLs,
marker_file=QTLmarkers, method = "qtl",
marker = "snp", interval = 500000,
nThreads = 1)

plot_qtl_info(out.qtls, qtl_plot = "qtl_type", cex=2)
</code></pre>

<hr>
<h2 id='qtl_enrich'>Performs a QTL enrichment analysis based on a hypergeometric test for each QTL class</h2><span id='topic+qtl_enrich'></span>

<h3>Description</h3>

<p>Takes the output from find_genes_qtls_around_markers and run a QTL enrichment analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl_enrich(
  qtl_db,
  qtl_file,
  qtl_type = c("QTL_type", "Name"),
  enrich_type = c("genome", "chromosome"),
  chr.subset = NULL,
  nThreads = NULL,
  padj = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtl_enrich_+3A_qtl_db">qtl_db</code></td>
<td>
<p>The object obtained using the import_gff_gtf() function</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_qtl_file">qtl_file</code></td>
<td>
<p>The output from find_genes_qtls_around_markers function</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_qtl_type">qtl_type</code></td>
<td>
<p>A character indicating which type of enrichment will be performed. QTL_type indicates that the enrichment processes will be performed for the QTL classes, while Name indicates that the enrichment analysis will be performed for each trait individually</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_enrich_type">enrich_type</code></td>
<td>
<p>A character indicating if the enrichment analysis will be performed for all the chromosomes (&quot;genome&quot;) or for a subset of chromosomes (&quot;chromosome). If the &quot;genome&quot; option is selected, the results reported are the merge of all chromosomes</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_chr.subset">chr.subset</code></td>
<td>
<p>If enrich_type equal &quot;chromosome&quot;, it is possible to define a subset of chromosomes to be analyzed. The default is equal NULL. Therefore, all the chromosomes will be analyzed</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_nthreads">nThreads</code></td>
<td>
<p>The number of threads to be used.</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_padj">padj</code></td>
<td>
<p>The algorithm for multiple testing correction to be adopted (&quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="qtl_enrich_+3A_verbose">verbose</code></td>
<td>
<p>Logical value defining if messages should of not be printed during the analysis (default=TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simple bias of investigation for some traits (such as milk production related traits in the QTL database for cattle) may result in a larger proportion of records in the database. Consequently, the simple investigation of the proportion of each QTL type might not be totally useful. In order to reduce the impact of this bias, a QTL enrichment analysis can be performed. The QTL enrichment analysis performed by GALLO package is based in a hypergeometric test using the number of annoatted QTLs within the candidate regions and the total number of the same QTL in the QTL database.
</p>


<h3>Value</h3>

<p>A data frame with the p-value for the enrichment result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gffQTLs)
out.qtls&lt;-find_genes_qtls_around_markers(
db_file=gffQTLs,marker_file=QTLmarkers,
method = "qtl",marker = "snp",
interval = 500000, nThreads = 1)

out.enrich&lt;-qtl_enrich(qtl_db=gffQTLs,
qtl_file=out.qtls, qtl_type = "Name",
enrich_type = "chromosome",chr.subset = NULL,
padj = "fdr",nThreads = 1)
</code></pre>

<hr>
<h2 id='QTLenrich_plot'>Plot enrichment results for QTL enrichment analysis</h2><span id='topic+QTLenrich_plot'></span>

<h3>Description</h3>

<p>Takes the output from qtl_enrich function and creates a bubble plot with enrichment results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTLenrich_plot(qtl_enrich, x, pval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTLenrich_plot_+3A_qtl_enrich">qtl_enrich</code></td>
<td>
<p>The output from qtl_enrich function</p>
</td></tr>
<tr><td><code id="QTLenrich_plot_+3A_x">x</code></td>
<td>
<p>Id column to be used from the qtl_enrich output</p>
</td></tr>
<tr><td><code id="QTLenrich_plot_+3A_pval">pval</code></td>
<td>
<p>P-value to be used in the plot. The name informed to this argument must match the p-value column name in the enrichment table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the QTL enrichment results
</p>

<hr>
<h2 id='QTLmarkers'>Candidate markers identified by GWAS associated with fertility traits in cattle</h2><span id='topic+QTLmarkers'></span>

<h3>Description</h3>

<p>Data from a systematic review which evaluated 18 articles regarding genome-wide association studies for male fertility traits in beef and dairy cattle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(QTLmarkers)
</code></pre>


<h3>Format</h3>

<p>A data frame with 141 rows and 7 variables:
</p>

<ul>
<li><p> Associated.marker: Significantly associated marker
</p>
</li>
<li><p> SNP.reference: The rs ID when available
</p>
</li>
<li><p> Trait: Trait associated
</p>
</li>
<li><p> CHR: Chromosome
</p>
</li>
<li><p> BP: Chromosomal position in base pairs (bovine reference assembly UMD3.1)
</p>
</li>
<li><p> Breed: Breed used in the study
</p>
</li>
<li><p> Reference: Study which the markers were retrieved
</p>
</li></ul>



<h3>References</h3>

<p>Fonseca et al. (2018) Journal of Animal Science, Volume 96, Issue 12, December 2018, Pages 4978-4999.
(<a href="https://doi.org/10.1093/jas/sky382">doi:10.1093/jas/sky382</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
</code></pre>

<hr>
<h2 id='QTLwindows'>Candidate windows identified by GWAS associated with fertility traits in cattle</h2><span id='topic+QTLwindows'></span>

<h3>Description</h3>

<p>Data from a systematic review which evaluated 18 articles regarding genomw-wide association studies for male fertility traits in beef and dairy cattle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(QTLwindows)
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 8 variables:
</p>

<ul>
<li><p> First.marker.in.the.window: First marker mapped in the candidate window
</p>
</li>
<li><p> Last.marker.in.the.window: Last marker mapped in the candidate window
</p>
</li>
<li><p> Trait: Trait associated
</p>
</li>
<li><p> CHR: Chromosome
</p>
</li>
<li><p> BP1: Chromosomal position in base pairs for the first marker mapped in the candidate window(bovine reference assembly UMD3.1)
</p>
</li>
<li><p> BP1: Chromosomal position in base pairs for the last marker mapped in the candidate window (bovine reference assembly UMD3.1)
</p>
</li>
<li><p> Breed: Breed used in the study
</p>
</li>
<li><p> Reference: Study which the markers were retrieved
</p>
</li></ul>



<h3>References</h3>

<p>Fonseca et al. (2018) Journal of Animal Science, Volume 96, Issue 12, December 2018, Pages 4978-4999.
(<a href="https://doi.org/10.1093/jas/sky382">doi:10.1093/jas/sky382</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLwindows)
</code></pre>

<hr>
<h2 id='relationship_plot'>Plot relationship between data and grouping factors</h2><span id='topic+relationship_plot'></span>

<h3>Description</h3>

<p>Takes the output from find_genes_qtls_around_markers function and creates a chord plot with the relationship between groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relationship_plot(
  qtl_file,
  x,
  y,
  grid.col = "gray60",
  degree = 90,
  canvas.xlim = c(-2, 2),
  canvas.ylim = c(-2, 2),
  cex,
  gap
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relationship_plot_+3A_qtl_file">qtl_file</code></td>
<td>
<p>The output from find_genes_qtls_around_markers function</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_x">x</code></td>
<td>
<p>The first grouping factor, to be plotted in the left hand side of the chord plot</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_y">y</code></td>
<td>
<p>The second grouping factor, to be plotted in the left hand side of the chord plot</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_grid.col">grid.col</code></td>
<td>
<p>A character with the grid color for the chord plot or a vector with different colors to be used in the grid colors. Note that when a color vector is provided, the length of this vector must be equal the number of sectors in the chord plot</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_degree">degree</code></td>
<td>
<p>A numeric value corresponding to the starting degree from which the circle begins to draw. Note this degree is always reverse-clockwise</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_canvas.xlim">canvas.xlim</code></td>
<td>
<p>The coordinate for the canvas in the x-axis. By default is c(-1,1)</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_canvas.ylim">canvas.ylim</code></td>
<td>
<p>The coordinate for the canvas in the y-axis. By default is c(-1,1)</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_cex">cex</code></td>
<td>
<p>The size of the labels to be printed in the plot</p>
</td></tr>
<tr><td><code id="relationship_plot_+3A_gap">gap</code></td>
<td>
<p>A numeric value corresponding to the gap between the chord sectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A chords relating x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(QTLmarkers)
data(gffQTLs)
out.qtls&lt;-find_genes_qtls_around_markers(
db_file=gffQTLs, marker_file=QTLmarkers,
method = "qtl", marker = "snp",
interval = 500000, nThreads = 1)

out.enrich&lt;-qtl_enrich(qtl_db=gffQTLs,
qtl_file=out.qtls, qtl_type = "Name",
enrich_type = "chromosome",
chr.subset = NULL, padj = "fdr",nThreads = 1)

out.enrich$ID&lt;-paste(out.enrich$QTL," - ",
"CHR",out.enrich$CHR,sep="")

out.enrich.filtered&lt;-out.enrich[which(out.enrich$adj.pval&lt;0.05),]

out.qtls$ID&lt;-paste(out.qtls$Name," - ",
"CHR",out.qtls$CHR,sep="")

out.enrich.filtered&lt;-out.enrich.filtered[order(out.enrich.filtered$adj.pval),]

out.qtls.filtered&lt;-out.qtls[which(out.qtls$ID%in%out.enrich.filtered$ID[1:10]),]

out.qtls.filtered[which(out.qtls.filtered$Reference==
"Feugang et al. (2010)"), "color_ref"]&lt;-"purple"

out.qtls.filtered[which(out.qtls.filtered$Reference==
"Buzanskas et al. (2017)"),"color_ref"]&lt;-"pink"

color.grid&lt;-c(rep("black",length(unique(out.qtls.filtered$Abbrev))),
unique(out.qtls.filtered$color_ref))

names(color.grid)&lt;-c(unique(out.qtls.filtered$Abbrev),
unique(out.qtls.filtered$Reference))

relationship_plot(qtl_file=out.qtls.filtered,
x="Abbrev", y="Reference",cex=1,gap=5,
degree = 90, canvas.xlim = c(-5, 5),
canvas.ylim = c(-3, 3), grid.col = color.grid)
</code></pre>

<hr>
<h2 id='splitQTL_comment'>Sub-function to split comment column from QTL output</h2><span id='topic+splitQTL_comment'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and search for genes a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitQTL_comment(output.final)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitQTL_comment_+3A_output.final">output.final</code></td>
<td>
<p>Output from QTL annotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the extra_info column content, from the gff file, broken in several additional columns
</p>

<hr>
<h2 id='sub_genes_markers'>Sub-function to search genes around candidate markers</h2><span id='topic+sub_genes_markers'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and search for genes a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_genes_markers(chr_list, db_file, marker_file, nThreads = NULL, int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_genes_markers_+3A_chr_list">chr_list</code></td>
<td>
<p>&quot;Object with the chromosomes to be analyzed&quot;</p>
</td></tr>
<tr><td><code id="sub_genes_markers_+3A_db_file">db_file</code></td>
<td>
<p>Data frame with the information from .gtf file</p>
</td></tr>
<tr><td><code id="sub_genes_markers_+3A_marker_file">marker_file</code></td>
<td>
<p>Data frame with the information from the candidate regions file</p>
</td></tr>
<tr><td><code id="sub_genes_markers_+3A_nthreads">nThreads</code></td>
<td>
<p>The number of threads to be used</p>
</td></tr>
<tr><td><code id="sub_genes_markers_+3A_int">int</code></td>
<td>
<p>The interval in base pair</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the genes or QTLs mapped within the specified intervals
</p>

<hr>
<h2 id='sub_genes_windows'>Sub-function to search genes around candidate markers</h2><span id='topic+sub_genes_windows'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and search for genes a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_genes_windows(chr_list, db_file, marker_file, nThreads = NULL, int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_genes_windows_+3A_chr_list">chr_list</code></td>
<td>
<p>&quot;Object with the chromosomes to be analyzed&quot;</p>
</td></tr>
<tr><td><code id="sub_genes_windows_+3A_db_file">db_file</code></td>
<td>
<p>Data frame with the information from .gtf file</p>
</td></tr>
<tr><td><code id="sub_genes_windows_+3A_marker_file">marker_file</code></td>
<td>
<p>Data frame with the information from the candidate regions file</p>
</td></tr>
<tr><td><code id="sub_genes_windows_+3A_nthreads">nThreads</code></td>
<td>
<p>The number of threads to be used</p>
</td></tr>
<tr><td><code id="sub_genes_windows_+3A_int">int</code></td>
<td>
<p>The interval in base pair</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the genes or QTLs mapped within the specified intervals
</p>

<hr>
<h2 id='sub_qtl_markers'>Sub-function to search QTLs around candidate markers</h2><span id='topic+sub_qtl_markers'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and search for genes a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_qtl_markers(chr_list, db_file, marker_file, nThreads = NULL, int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_qtl_markers_+3A_chr_list">chr_list</code></td>
<td>
<p>&quot;Object with the chromosomes to be analyzed&quot;</p>
</td></tr>
<tr><td><code id="sub_qtl_markers_+3A_db_file">db_file</code></td>
<td>
<p>Data frame with the information from .gff file</p>
</td></tr>
<tr><td><code id="sub_qtl_markers_+3A_marker_file">marker_file</code></td>
<td>
<p>Data frame with the information from the candidate regions file</p>
</td></tr>
<tr><td><code id="sub_qtl_markers_+3A_nthreads">nThreads</code></td>
<td>
<p>The number of threads to be used</p>
</td></tr>
<tr><td><code id="sub_qtl_markers_+3A_int">int</code></td>
<td>
<p>The interval in base pair</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the QTLs mapped within the specified intervals
</p>

<hr>
<h2 id='sub_qtl_windows'>Sub-function to search QTLs around candidate markers</h2><span id='topic+sub_qtl_windows'></span>

<h3>Description</h3>

<p>Takes a list of candidate markers and search for genes a determined interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_qtl_windows(chr_list, db_file, marker_file, nThreads = NULL, int = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_qtl_windows_+3A_chr_list">chr_list</code></td>
<td>
<p>&quot;Object with the chromosomes to be analyzed&quot;</p>
</td></tr>
<tr><td><code id="sub_qtl_windows_+3A_db_file">db_file</code></td>
<td>
<p>Data frame with the information from .gff file</p>
</td></tr>
<tr><td><code id="sub_qtl_windows_+3A_marker_file">marker_file</code></td>
<td>
<p>Data frame with the information from the candidate regions file</p>
</td></tr>
<tr><td><code id="sub_qtl_windows_+3A_nthreads">nThreads</code></td>
<td>
<p>The number of threads to be used</p>
</td></tr>
<tr><td><code id="sub_qtl_windows_+3A_int">int</code></td>
<td>
<p>The interval in base pair</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the QTLs mapped within the specified intervals
</p>

<hr>
<h2 id='sub_qtlEnrich_chrom'>Performs a QTL enrichment analysis based in a Bootstrap simulation for each QTL class using the QTL information per chromosome</h2><span id='topic+sub_qtlEnrich_chrom'></span><span id='topic+sub_qtlEnrich_chom'></span>

<h3>Description</h3>

<p>Takes the output from find_genes_qtls_around_markers and run a QTL enrichment analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_qtlEnrich_chom(
  qtl_file,
  qtl_type,
  qtl.file.types,
  table.qtl.class,
  padj,
  qtl_db,
  search_qtl,
  nThreads
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_qtl_file">qtl_file</code></td>
<td>
<p>The output from find_genes_qtls_around_markers function</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_qtl_type">qtl_type</code></td>
<td>
<p>A string indicating with QTL enrichment will be performed: &quot;QTL_type&quot; or &quot;Name&quot;</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_qtl.file.types">qtl.file.types</code></td>
<td>
<p>A vector with the observed QTL classes</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_table.qtl.class">table.qtl.class</code></td>
<td>
<p>An frequency table for the number of each QTL in each chromosome</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_qtl_db">qtl_db</code></td>
<td>
<p>The QTL annotation database</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_search_qtl">search_qtl</code></td>
<td>
<p>The column to perform the QTL searching in counting from the QTL annotation database</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_chrom_+3A_nthreads">nThreads</code></td>
<td>
<p>Number of threads for parallel processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the p-value for th enrichment result
</p>

<hr>
<h2 id='sub_qtlEnrich_geno'>Performs a QTL enrichment analysis based in a Bootstrap simulation for each QTL class using the QTL information across the whole genome</h2><span id='topic+sub_qtlEnrich_geno'></span>

<h3>Description</h3>

<p>Takes the output from find_genes_qtls_around_markers and run a QTL enrichment analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_qtlEnrich_geno(
  qtl_file,
  qtl_type,
  qtl.file.types,
  table.qtl.class,
  padj,
  qtl_db,
  search_qtl,
  nThreads
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_qtlEnrich_geno_+3A_qtl_file">qtl_file</code></td>
<td>
<p>The output from find_genes_qtls_around_markers function</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_qtl_type">qtl_type</code></td>
<td>
<p>A string indicating with QTL enrichment will be performed: &quot;QTL_type&quot; or &quot;Name&quot;</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_qtl.file.types">qtl.file.types</code></td>
<td>
<p>A vector with the observed QTL classes</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_table.qtl.class">table.qtl.class</code></td>
<td>
<p>An frequency table for the number of each QTL in each chromosome</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_qtl_db">qtl_db</code></td>
<td>
<p>The QTL annotation database</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_search_qtl">search_qtl</code></td>
<td>
<p>The column to perform the QTL searching in counting from the QTL annotation database</p>
</td></tr>
<tr><td><code id="sub_qtlEnrich_geno_+3A_nthreads">nThreads</code></td>
<td>
<p>Number of threads for parallel processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the p-value for th enrichment result
</p>

<hr>
<h2 id='WZ_ld'>Function to perform Weighted Z-score Approach with LD Information</h2><span id='topic+WZ_ld'></span>

<h3>Description</h3>

<p>Function to perform Weighted Z-score Approach with LD Information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WZ_ld(marker_ld, marker_pvalues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WZ_ld_+3A_marker_ld">marker_ld</code></td>
<td>
<p>A data frame containing the pairwise linkage disequilibrium between markers in a chromosome</p>
</td></tr>
<tr><td><code id="WZ_ld_+3A_marker_pvalues">marker_pvalues</code></td>
<td>
<p>A vector with the p-values for the SNPs annotated within each gene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of p-values for each gene annotated within the defined coordinates
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
