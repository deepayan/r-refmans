<!DOCTYPE html><html><head><title>Help for package ungroup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ungroup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ungroup'><p>ungroup: Penalized Composite Link Model for Efficient Estimation of Smooth Distributions from Coarsely Binned Data</p></a></li>
<li><a href='#AIC.pclm'><p>PCLM Akaike Information Criterion</p></a></li>
<li><a href='#AIC.pclm2D'><p>PCLM-2D Akaike Information Criterion</p></a></li>
<li><a href='#BIC.pclm'><p>PCLM Bayes Information Criterion</p></a></li>
<li><a href='#BIC.pclm2D'><p>PCLM-2D Akaike Information Criterion</p></a></li>
<li><a href='#build_B_spline_basis'><p>Construct B-spline basis</p>
This is an internal function which constructs B-spline basis to be used in
pclm estimation</a></li>
<li><a href='#build_C_matrix'><p>Build Composition Matrices</p></a></li>
<li><a href='#build_P_matrix'><p>Construct Penalty Matrix</p></a></li>
<li><a href='#compute_standard_errors'><p>Compute Standard Errors and Confidence Intervals</p></a></li>
<li><a href='#control.pclm'><p>Auxiliary for Controlling <code>pclm</code> Fitting</p></a></li>
<li><a href='#control.pclm2D'><p>Auxiliary for Controlling <code>pclm2D</code> Fitting</p></a></li>
<li><a href='#create.artificial.bin'><p>Create an additional bin with a small value at the end.</p>
Improves convergence.</a></li>
<li><a href='#delete.artificial.bin'><p>Delete from results the last group added artificially in pclm and pclm2D</p></a></li>
<li><a href='#frac'><p>Extract Fractional Part of a Number</p></a></li>
<li><a href='#map.bins'><p>Map groups and borders</p></a></li>
<li><a href='#MortSmooth_bbase'><p>Construct B-spline basis</p></a></li>
<li><a href='#MortSmooth_tpower'><p>Truncated p-th Power Function</p></a></li>
<li><a href='#ofun'><p>Objective function</p></a></li>
<li><a href='#optimize_par'><p>Optimize Smoothing Parameters</p>
This function optimize searches of <code>lambda, kr</code> and <code>deg</code>.
See <code>control.pclm</code> to see what is their meaning.
The optimization process works in steps. Simultaneous optimization was
tested and found inefficient.</a></li>
<li><a href='#pclm'><p>Univariate Penalized Composite Link Model (PCLM)</p></a></li>
<li><a href='#pclm.confidence'><p>Compute Confidence Intervals for PCLM output</p></a></li>
<li><a href='#pclm.confidence.dx'><p>Compute Confidence Intervals for estimated distribution</p></a></li>
<li><a href='#pclm.confidence.mx'><p>Compute Confidence Intervals for estimated hazard</p></a></li>
<li><a href='#pclm.fit'><p>Fit PCLM Models</p></a></li>
<li><a href='#pclm.input.check'><p>Validate input values</p></a></li>
<li><a href='#pclm2D'><p>Two-Dimensional Penalized Composite Link Model (PCLM-2D)</p></a></li>
<li><a href='#plot.pclm'><p>Generic Plot for pclm Class</p></a></li>
<li><a href='#plot.pclm2D'><p>Generic Plot for pclm2D Class</p></a></li>
<li><a href='#print.pclm'><p>Print for pclm method</p></a></li>
<li><a href='#print.pclm2D'><p>Print method for pclm2D</p></a></li>
<li><a href='#print.summary.pclm'><p>Print for summary.pclm method</p></a></li>
<li><a href='#print.summary.pclm2D'><p>Print method for summary.pclm2D</p></a></li>
<li><a href='#print.ungroup.data'><p>Print function for <code>ungroup.data</code></p></a></li>
<li><a href='#residuals.pclm'><p>Extract PCLM Deviance Residuals</p></a></li>
<li><a href='#residuals.pclm2D'><p>Extract PCLM-2D Deviance Residuals</p></a></li>
<li><a href='#seqlast'><p>Sequence function with last value</p></a></li>
<li><a href='#suggest.valid.out.step'><p>Suggest values of <code>out.step</code> that do not</p>
require an adjustment of <code>nlast</code></a></li>
<li><a href='#summary.pclm'><p>Summary for pclm method</p></a></li>
<li><a href='#summary.pclm2D'><p>Summary method for pclm2D</p>
Generic function used to produce result summaries of the results produced
by <code>pclm2D</code>.</a></li>
<li><a href='#ungroup.data'><p>Test Dataset in the Package</p></a></li>
<li><a href='#validate.nlast'><p>Check if <code>nlast</code> needs to be adjusted in order to accommodate</p>
<code>out.step</code></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Penalized Composite Link Model for Efficient Estimation of
Smooth Distributions from Coarsely Binned Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Versatile method for ungrouping histograms (binned count data) 
 assuming that counts are Poisson distributed and that the underlying sequence 
 on a fine grid to be estimated is smooth. The method is based on the composite 
 link model and estimation is achieved by maximizing a penalized likelihood. 
 Smooth detailed sequences of counts and rates are so estimated from the binned 
 counts. Ungrouping binned data can be desirable for many reasons: Bins can be 
 too coarse to allow for accurate analysis; comparisons can be hindered when 
 different grouping approaches are used in different histograms; and the last 
 interval is often wide and open-ended and, thus, covers a lot of information 
 in the tail area. Age-at-death distributions grouped in age classes and 
 abridged life tables are examples of binned data. Because of modest assumptions, 
 the approach is suitable for many demographic and epidemiological applications. 
 For a detailed description of the method and applications see 
 Rizzi et al. (2015) &lt;<a href="https://doi.org/10.1093%2Faje%2Fkwv020">doi:10.1093/aje/kwv020</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbapply (&ge; 1.3), Rcpp (&ge; 0.12.0), Rdpack (&ge; 0.8), Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MortalityLaws (&ge; 1.5.0), knitr (&ge; 1.20), rmarkdown (&ge;
1.10), testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mpascariu/ungroup">https://github.com/mpascariu/ungroup</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mpascariu/ungroup/issues">https://github.com/mpascariu/ungroup/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 15:00:04 UTC; mpascariu</td>
</tr>
<tr>
<td>Author:</td>
<td>Marius D. Pascariu
    <a href="https://orcid.org/0000-0002-2568-6489"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Silvia Rizzi [aut],
  Jonas Schoeley <a href="https://orcid.org/0000-0002-3340-8518"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Maciej J. Danko <a href="https://orcid.org/0000-0002-7924-9022"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marius D. Pascariu &lt;rpascariu@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ungroup'>ungroup: Penalized Composite Link Model for Efficient Estimation of Smooth Distributions from Coarsely Binned Data</h2><span id='topic+ungroup-package'></span><span id='topic+ungroup'></span>

<h3>Description</h3>

<p>Versatile method for ungrouping histograms (binned count data) assuming that counts are Poisson distributed and that the underlying sequence on a fine grid to be estimated is smooth. The method is based on the composite link model and estimation is achieved by maximizing a penalized likelihood. Smooth detailed sequences of counts and rates are so estimated from the binned counts. Ungrouping binned data can be desirable for many reasons: Bins can be too coarse to allow for accurate analysis; comparisons can be hindered when different grouping approaches are used in different histograms; and the last interval is often wide and open-ended and, thus, covers a lot of information in the tail area. Age-at-death distributions grouped in age classes and abridged life tables are examples of binned data. Because of modest assumptions, the approach is suitable for many demographic and epidemiological applications. For a detailed description of the method and applications see Rizzi et al. (2015) <a href="https://doi.org/10.1093/aje/kwv020">doi:10.1093/aje/kwv020</a>.
</p>


<h3>Details</h3>

<p>To learn more about the package, start with the vignettes:
<code>browseVignettes(package = "ungroup")</code>

</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marius D. Pascariu <a href="mailto:rpascariu@outlook.com">rpascariu@outlook.com</a> (<a href="https://orcid.org/0000-0002-2568-6489">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Silvia Rizzi <a href="mailto:srizzi@health.sdu.dk">srizzi@health.sdu.dk</a>
</p>
</li>
<li><p> Jonas Schoeley (<a href="https://orcid.org/0000-0002-3340-8518">ORCID</a>)
</p>
</li>
<li><p> Maciej J. Danko <a href="mailto:Danko@demogr.mpg.de">Danko@demogr.mpg.de</a> (<a href="https://orcid.org/0000-0002-7924-9022">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Currie ID, Durban M, Eilers PH (2004).
&ldquo;Smoothing and forecasting mortality rates.&rdquo;
<em>Statistical modelling</em>, <b>4</b>(4), 279&ndash;298.<br /><br /> Eilers PH (2007).
&ldquo;Ill-posed problems with counts, the composite link model and penalized likelihood.&rdquo;
<em>Statistical Modelling</em>, <b>7</b>(3), 239-254.
<a href="https://doi.org/10.1177/1471082X0700700302">doi:10.1177/1471082X0700700302</a>.<br /><br /> Hastie TJ, Tibshirani RJ (1990).
&ldquo;Generalized additive models.&rdquo;
<em>Monographs on Statistics and Applied Probability</em>, <b>43</b>.<br /><br /> Human Mortality Database (2018).
&ldquo;University of California, Berkeley (USA), and Max Planck Institute for Demographic Research (Germany). Data downloaded on 17/01/2018.&rdquo;
<a href="https://www.mortality.org">https://www.mortality.org</a>.<br /><br /> Pascariu MD (2018).
<em>MortalityLaws: Parametric Mortality Models, Life Tables and HMD</em>.
R package version 1.6.0, <a href="https://github.com/mpascariu/MortalityLaws">https://github.com/mpascariu/MortalityLaws</a>.<br /><br /> Rizzi S, Gampe J, Eilers PHC (2015).
&ldquo;Efficient Estimation of Smooth Distributions From Coarsely Grouped Data.&rdquo;
<em>American Journal of Epidemiology</em>, <b>182</b>(2), 138-147.
<a href="https://doi.org/10.1093/aje/kwv020">doi:10.1093/aje/kwv020</a>.<br /><br /> Rizzi S, Halekoh U, Thinggaard M, Engholm G, Christensen N, Johannesen TB, Lindahl-Jacobsen R (2019).
&ldquo;How to estimate mortality trends from grouped vital statistics.&rdquo;
<em>International Journal of Epidemiology</em>, <b>48</b>(2), 571&ndash;582.
<a href="https://doi.org/10.1093/ije/dyy183">doi:10.1093/ije/dyy183</a>.<br /><br /> Rizzi S, Thinggaard M, Engholm G, Christensen N, Johannesen TB, Vaupel JW, Lindahl-Jacobsen R (2016).
&ldquo;Comparison of non-parametric methods for ungrouping coarsely aggregated data.&rdquo;
<em>BMC medical research methodology</em>, <b>16</b>(1), 59.
<a href="https://doi.org/10.1186/s12874-016-0157-8">doi:10.1186/s12874-016-0157-8</a>.<br /><br /> Thompson R, Baker RJ (1981).
&ldquo;Composite link functions in generalized linear models.&rdquo;
<em>Applied Statistics</em>, 125&ndash;131.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mpascariu/ungroup">https://github.com/mpascariu/ungroup</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mpascariu/ungroup/issues">https://github.com/mpascariu/ungroup/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AIC.pclm'>PCLM Akaike Information Criterion</h2><span id='topic+AIC.pclm'></span>

<h3>Description</h3>

<p>Generic function calculating Akaike's &lsquo;An Information Criterion&rsquo; for
one or several fitted model objects for which a log-likelihood value
can be obtained, according to the formula
<code class="reqn">-2 \mbox{log-likelihood} + k n_{par}</code>,
where <code class="reqn">n_{par}</code> represents the number of parameters in the
fitted model, and <code class="reqn">k = 2</code> for the usual AIC, or
<code class="reqn">k = \log(n)</code>
(<code class="reqn">n</code> being the number of observations) for the so-called BIC or SBC
(Schwarz's Bayesian criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.pclm_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.pclm_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.pclm_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same data,
the smaller the AIC or BIC, the better the fit.
</p>
<p>The theory of AIC requires that the log-likelihood has been maximized:
whereas AIC can be computed for models not fitted by maximum
likelihood, their AIC values should not be compared.
</p>
<p>Examples of models not &lsquo;fitted to the same data&rsquo; are where the
response is transformed (accelerated-life models are fitted to
log-times) and where contingency tables have been used to summarize
data.
</p>
<p>These are generic functions (with S4 generics defined in package
<span class="pkg">stats4</span>): however methods should be defined for the
log-likelihood function <code><a href="stats.html#topic+logLik">logLik</a></code> rather than these
functions: the action of their default methods is to call <code>logLik</code>
on all the supplied objects and assemble the results.  Note that in
several common cases <code><a href="stats.html#topic+logLik">logLik</a></code> does not return the value at
the MLE: see its help page.
</p>
<p>The log-likelihood and hence the AIC/BIC is only defined up to an
additive constant.  Different constants have conventionally been used
for different purposes and so <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> and <code>AIC</code>
may give different values (and do for models of class <code>"lm"</code>: see
the help for <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>).  Particular care is needed
when comparing fits of different classes (with, for example, a
comparison of a Poisson and gamma GLM being meaningless since one has
a discrete response, the other continuous).
</p>
<p><code>BIC</code> is defined as
<code>AIC(object, ..., k = log(nobs(object)))</code>.
This needs the number of observations to be known: the default method
looks first for a <code>"nobs"</code> attribute on the return value from the
<code><a href="stats.html#topic+logLik">logLik</a></code> method, then tries the <code><a href="stats.html#topic+nobs">nobs</a></code>
generic, and if neither succeed returns BIC as <code>NA</code>.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC (or BIC, or ..., depending on <code>k</code>).
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows
corresponding to the objects and columns representing the number of
parameters in the model (<code>df</code>) and the AIC or BIC.
</p>


<h3>References</h3>

<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986).
<em>Akaike Information Criterion Statistics</em>.
D. Reidel Publishing Company.
</p>

<hr>
<h2 id='AIC.pclm2D'>PCLM-2D Akaike Information Criterion</h2><span id='topic+AIC.pclm2D'></span>

<h3>Description</h3>

<p>Generic function calculating Akaike's &lsquo;An Information Criterion&rsquo; for
one or several fitted model objects for which a log-likelihood value
can be obtained, according to the formula
<code class="reqn">-2 \mbox{log-likelihood} + k n_{par}</code>,
where <code class="reqn">n_{par}</code> represents the number of parameters in the
fitted model, and <code class="reqn">k = 2</code> for the usual AIC, or
<code class="reqn">k = \log(n)</code>
(<code class="reqn">n</code> being the number of observations) for the so-called BIC or SBC
(Schwarz's Bayesian criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.pclm2D_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="AIC.pclm2D_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC.pclm2D_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same data,
the smaller the AIC or BIC, the better the fit.
</p>
<p>The theory of AIC requires that the log-likelihood has been maximized:
whereas AIC can be computed for models not fitted by maximum
likelihood, their AIC values should not be compared.
</p>
<p>Examples of models not &lsquo;fitted to the same data&rsquo; are where the
response is transformed (accelerated-life models are fitted to
log-times) and where contingency tables have been used to summarize
data.
</p>
<p>These are generic functions (with S4 generics defined in package
<span class="pkg">stats4</span>): however methods should be defined for the
log-likelihood function <code><a href="stats.html#topic+logLik">logLik</a></code> rather than these
functions: the action of their default methods is to call <code>logLik</code>
on all the supplied objects and assemble the results.  Note that in
several common cases <code><a href="stats.html#topic+logLik">logLik</a></code> does not return the value at
the MLE: see its help page.
</p>
<p>The log-likelihood and hence the AIC/BIC is only defined up to an
additive constant.  Different constants have conventionally been used
for different purposes and so <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> and <code>AIC</code>
may give different values (and do for models of class <code>"lm"</code>: see
the help for <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>).  Particular care is needed
when comparing fits of different classes (with, for example, a
comparison of a Poisson and gamma GLM being meaningless since one has
a discrete response, the other continuous).
</p>
<p><code>BIC</code> is defined as
<code>AIC(object, ..., k = log(nobs(object)))</code>.
This needs the number of observations to be known: the default method
looks first for a <code>"nobs"</code> attribute on the return value from the
<code><a href="stats.html#topic+logLik">logLik</a></code> method, then tries the <code><a href="stats.html#topic+nobs">nobs</a></code>
generic, and if neither succeed returns BIC as <code>NA</code>.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC (or BIC, or ..., depending on <code>k</code>).
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows
corresponding to the objects and columns representing the number of
parameters in the model (<code>df</code>) and the AIC or BIC.
</p>


<h3>References</h3>

<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986).
<em>Akaike Information Criterion Statistics</em>.
D. Reidel Publishing Company.
</p>

<hr>
<h2 id='BIC.pclm'>PCLM Bayes Information Criterion</h2><span id='topic+BIC.pclm'></span>

<h3>Description</h3>

<p>Generic function calculating Akaike's &lsquo;An Information Criterion&rsquo; for
one or several fitted model objects for which a log-likelihood value
can be obtained, according to the formula
<code class="reqn">-2 \mbox{log-likelihood} + k n_{par}</code>,
where <code class="reqn">n_{par}</code> represents the number of parameters in the
fitted model, and <code class="reqn">k = 2</code> for the usual AIC, or
<code class="reqn">k = \log(n)</code>
(<code class="reqn">n</code> being the number of observations) for the so-called BIC or SBC
(Schwarz's Bayesian criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.pclm_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.pclm_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same data,
the smaller the AIC or BIC, the better the fit.
</p>
<p>The theory of AIC requires that the log-likelihood has been maximized:
whereas AIC can be computed for models not fitted by maximum
likelihood, their AIC values should not be compared.
</p>
<p>Examples of models not &lsquo;fitted to the same data&rsquo; are where the
response is transformed (accelerated-life models are fitted to
log-times) and where contingency tables have been used to summarize
data.
</p>
<p>These are generic functions (with S4 generics defined in package
<span class="pkg">stats4</span>): however methods should be defined for the
log-likelihood function <code><a href="stats.html#topic+logLik">logLik</a></code> rather than these
functions: the action of their default methods is to call <code>logLik</code>
on all the supplied objects and assemble the results.  Note that in
several common cases <code><a href="stats.html#topic+logLik">logLik</a></code> does not return the value at
the MLE: see its help page.
</p>
<p>The log-likelihood and hence the AIC/BIC is only defined up to an
additive constant.  Different constants have conventionally been used
for different purposes and so <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> and <code>AIC</code>
may give different values (and do for models of class <code>"lm"</code>: see
the help for <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>).  Particular care is needed
when comparing fits of different classes (with, for example, a
comparison of a Poisson and gamma GLM being meaningless since one has
a discrete response, the other continuous).
</p>
<p><code>BIC</code> is defined as
<code>AIC(object, ..., k = log(nobs(object)))</code>.
This needs the number of observations to be known: the default method
looks first for a <code>"nobs"</code> attribute on the return value from the
<code><a href="stats.html#topic+logLik">logLik</a></code> method, then tries the <code><a href="stats.html#topic+nobs">nobs</a></code>
generic, and if neither succeed returns BIC as <code>NA</code>.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC (or BIC, or ..., depending on <code>k</code>).
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows
corresponding to the objects and columns representing the number of
parameters in the model (<code>df</code>) and the AIC or BIC.
</p>


<h3>References</h3>

<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986).
<em>Akaike Information Criterion Statistics</em>.
D. Reidel Publishing Company.
</p>

<hr>
<h2 id='BIC.pclm2D'>PCLM-2D Akaike Information Criterion</h2><span id='topic+BIC.pclm2D'></span>

<h3>Description</h3>

<p>Generic function calculating Akaike's &lsquo;An Information Criterion&rsquo; for
one or several fitted model objects for which a log-likelihood value
can be obtained, according to the formula
<code class="reqn">-2 \mbox{log-likelihood} + k n_{par}</code>,
where <code class="reqn">n_{par}</code> represents the number of parameters in the
fitted model, and <code class="reqn">k = 2</code> for the usual AIC, or
<code class="reqn">k = \log(n)</code>
(<code class="reqn">n</code> being the number of observations) for the so-called BIC or SBC
(Schwarz's Bayesian criterion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
BIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.pclm2D_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="BIC.pclm2D_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="BIC.pclm2D_+3A_k">k</code></td>
<td>
<p>numeric, the <em>penalty</em> per parameter to be used; the
default <code>k = 2</code> is the classical AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same data,
the smaller the AIC or BIC, the better the fit.
</p>
<p>The theory of AIC requires that the log-likelihood has been maximized:
whereas AIC can be computed for models not fitted by maximum
likelihood, their AIC values should not be compared.
</p>
<p>Examples of models not &lsquo;fitted to the same data&rsquo; are where the
response is transformed (accelerated-life models are fitted to
log-times) and where contingency tables have been used to summarize
data.
</p>
<p>These are generic functions (with S4 generics defined in package
<span class="pkg">stats4</span>): however methods should be defined for the
log-likelihood function <code><a href="stats.html#topic+logLik">logLik</a></code> rather than these
functions: the action of their default methods is to call <code>logLik</code>
on all the supplied objects and assemble the results.  Note that in
several common cases <code><a href="stats.html#topic+logLik">logLik</a></code> does not return the value at
the MLE: see its help page.
</p>
<p>The log-likelihood and hence the AIC/BIC is only defined up to an
additive constant.  Different constants have conventionally been used
for different purposes and so <code><a href="stats.html#topic+extractAIC">extractAIC</a></code> and <code>AIC</code>
may give different values (and do for models of class <code>"lm"</code>: see
the help for <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>).  Particular care is needed
when comparing fits of different classes (with, for example, a
comparison of a Poisson and gamma GLM being meaningless since one has
a discrete response, the other continuous).
</p>
<p><code>BIC</code> is defined as
<code>AIC(object, ..., k = log(nobs(object)))</code>.
This needs the number of observations to be known: the default method
looks first for a <code>"nobs"</code> attribute on the return value from the
<code><a href="stats.html#topic+logLik">logLik</a></code> method, then tries the <code><a href="stats.html#topic+nobs">nobs</a></code>
generic, and if neither succeed returns BIC as <code>NA</code>.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value with the corresponding
AIC (or BIC, or ..., depending on <code>k</code>).
</p>
<p>If multiple objects are provided, a <code>data.frame</code> with rows
corresponding to the objects and columns representing the number of
parameters in the model (<code>df</code>) and the AIC or BIC.
</p>


<h3>References</h3>

<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986).
<em>Akaike Information Criterion Statistics</em>.
D. Reidel Publishing Company.
</p>

<hr>
<h2 id='build_B_spline_basis'>Construct B-spline basis
This is an internal function which constructs B-spline basis to be used in 
pclm estimation</h2><span id='topic+build_B_spline_basis'></span>

<h3>Description</h3>

<p>Construct B-spline basis
This is an internal function which constructs B-spline basis to be used in 
pclm estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_B_spline_basis(X, Y, kr, deg, diff, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_B_spline_basis_+3A_x">X</code></td>
<td>
<p>vector with ages</p>
</td></tr>
<tr><td><code id="build_B_spline_basis_+3A_y">Y</code></td>
<td>
<p>vector with years</p>
</td></tr>
<tr><td><code id="build_B_spline_basis_+3A_kr">kr</code></td>
<td>
<p>Knot ratio. Number of internal intervals used for defining 1 knot in 
B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.</p>
</td></tr>
<tr><td><code id="build_B_spline_basis_+3A_deg">deg</code></td>
<td>
<p>Degree of the splines needed to create equally-spaced B-splines 
basis over an abscissa of data.</p>
</td></tr>
<tr><td><code id="build_B_spline_basis_+3A_diff">diff</code></td>
<td>
<p>An integer indicating the order of differences of the components 
of PCLM coefficients. Default value: 2.</p>
</td></tr>
<tr><td><code id="build_B_spline_basis_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>
</p>

<hr>
<h2 id='build_C_matrix'>Build Composition Matrices</h2><span id='topic+build_C_matrix'></span>

<h3>Description</h3>

<p>Build Composition Matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_C_matrix(x, y, nlast, offset, out.step, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_C_matrix_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="build_C_matrix_+3A_y">y</code></td>
<td>
<p>Vector with counts to be ungrouped. It must have the same dimension 
as <code>x</code>.</p>
</td></tr>
<tr><td><code id="build_C_matrix_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="build_C_matrix_+3A_offset">offset</code></td>
<td>
<p>Optional offset term to calculate smooth mortality rates. 
A vector of the same length as x and y. See 
Rizzi et al. (2015) for further details.</p>
</td></tr>
<tr><td><code id="build_C_matrix_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
<tr><td><code id="build_C_matrix_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='build_P_matrix'>Construct Penalty Matrix</h2><span id='topic+build_P_matrix'></span>

<h3>Description</h3>

<p>Construct Penalty Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_P_matrix(BA, BY, lambda, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_P_matrix_+3A_ba">BA</code></td>
<td>
<p>B-spline basis object for age axis</p>
</td></tr>
<tr><td><code id="build_P_matrix_+3A_by">BY</code></td>
<td>
<p>B-spline basis object for year axis</p>
</td></tr>
<tr><td><code id="build_P_matrix_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.</p>
</td></tr>
<tr><td><code id="build_P_matrix_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='compute_standard_errors'>Compute Standard Errors and Confidence Intervals</h2><span id='topic+compute_standard_errors'></span>

<h3>Description</h3>

<p>Compute Standard Errors and Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_standard_errors(B, QmQ, QmQP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_standard_errors_+3A_b">B</code></td>
<td>
<p>B-spline basis matrix</p>
</td></tr>
<tr><td><code id="compute_standard_errors_+3A_qmq">QmQ</code></td>
<td>
<p>Object generated by pclm.fit</p>
</td></tr>
<tr><td><code id="compute_standard_errors_+3A_qmqp">QmQP</code></td>
<td>
<p>Object generated by pclm.fit</p>
</td></tr>
</table>

<hr>
<h2 id='control.pclm'>Auxiliary for Controlling <code>pclm</code> Fitting</h2><span id='topic+control.pclm'></span>

<h3>Description</h3>

<p>Auxiliary for Controlling <code>pclm</code> Fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.pclm(lambda     = NA,
             kr         = 2,
             deg        = 3,
             int.lambda = c(0.1, 1e+5),
             diff       = 2,
             opt.method = c("BIC", "AIC"),
             max.iter   = 1e+3,
             tol        = 1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.pclm_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_kr">kr</code></td>
<td>
<p>Knot ratio. Number of internal intervals used for defining 1 knot in 
B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_deg">deg</code></td>
<td>
<p>Degree of the splines needed to create equally-spaced B-splines 
basis over an abscissa of data.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_int.lambda">int.lambda</code></td>
<td>
<p>If <code>lambda</code> is optimized an interval to be searched 
needs to be specified. Format: vector containing the end-points.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_diff">diff</code></td>
<td>
<p>An integer indicating the order of differences of the components 
of PCLM coefficients. Default value: 2.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_opt.method">opt.method</code></td>
<td>
<p>Selection criterion of the model.
Possible values are <code>"AIC"</code> and <code>"BIC"</code>. Default: <code>"BIC"</code>.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations used in fitting procedure.</p>
</td></tr>
<tr><td><code id="control.pclm_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance in PCLM fitting procedure. Default: 0.1% i.e. 
the estimated aggregate bins should be in the 0.1% error margin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with exactly eight control parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pclm">pclm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control.pclm()
</code></pre>

<hr>
<h2 id='control.pclm2D'>Auxiliary for Controlling <code>pclm2D</code> Fitting</h2><span id='topic+control.pclm2D'></span>

<h3>Description</h3>

<p>Auxiliary for Controlling <code>pclm2D</code> Fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.pclm2D(lambda     = c(1, 1),
               kr         = 7,
               deg        = 3,
               int.lambda = c(0.1, 1e+3),
               diff       = 2,
               opt.method = c("BIC", "AIC"),
               max.iter   = 1e+3,
               tol        = 1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.pclm2D_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_kr">kr</code></td>
<td>
<p>Knot ratio. Number of internal intervals used for defining 1 knot in 
B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_deg">deg</code></td>
<td>
<p>Degree of the splines needed to create equally-spaced B-splines 
basis over an abscissa of data.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_int.lambda">int.lambda</code></td>
<td>
<p>If <code>lambda</code> is optimized an interval to be searched 
needs to be specified. Format: vector containing the end-points.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_diff">diff</code></td>
<td>
<p>An integer indicating the order of differences of the components 
of PCLM coefficients. Default value: 2.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_opt.method">opt.method</code></td>
<td>
<p>Selection criterion of the model.
Possible values are <code>"AIC"</code> and <code>"BIC"</code>. Default: <code>"BIC"</code>.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations used in fitting procedure.</p>
</td></tr>
<tr><td><code id="control.pclm2D_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance in PCLM fitting procedure. Default: 0.1% i.e. 
the estimated aggregate bins should be in the 0.1% error margin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with exactly eight control parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pclm2D">pclm2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control.pclm2D()
</code></pre>

<hr>
<h2 id='create.artificial.bin'>Create an additional bin with a small value at the end. 
Improves convergence.</h2><span id='topic+create.artificial.bin'></span>

<h3>Description</h3>

<p>Create an additional bin with a small value at the end. 
Improves convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.artificial.bin(i, vy = 1, vo = 1.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.artificial.bin_+3A_i">i</code></td>
<td>
<p>A list of input values corresponding to pclm or pclm2D;</p>
</td></tr>
<tr><td><code id="create.artificial.bin_+3A_vy">vy</code></td>
<td>
<p>Numerical value of the bin created for <code>y</code> input;</p>
</td></tr>
<tr><td><code id="create.artificial.bin_+3A_vo">vo</code></td>
<td>
<p>Numerical values of the bin created for <code>offset</code> input 
(if the case).</p>
</td></tr>
</table>

<hr>
<h2 id='delete.artificial.bin'>Delete from results the last group added artificially in pclm and pclm2D</h2><span id='topic+delete.artificial.bin'></span>

<h3>Description</h3>

<p>Delete from results the last group added artificially in pclm and pclm2D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.artificial.bin(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.artificial.bin_+3A_m">M</code></td>
<td>
<p>A pclm.fit object</p>
</td></tr>
</table>

<hr>
<h2 id='frac'>Extract Fractional Part of a Number</h2><span id='topic+frac'></span>

<h3>Description</h3>

<p>Extract Fractional Part of a Number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frac(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frac_+3A_x">x</code></td>
<td>
<p>A numeric value, vector or matrix</p>
</td></tr>
</table>

<hr>
<h2 id='map.bins'>Map groups and borders</h2><span id='topic+map.bins'></span>

<h3>Description</h3>

<p>We assume no missing values between the bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.bins(x, nlast, out.step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.bins_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="map.bins_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="map.bins_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
</table>

<hr>
<h2 id='MortSmooth_bbase'>Construct B-spline basis</h2><span id='topic+MortSmooth_bbase'></span>

<h3>Description</h3>

<p>This is an internal function of package MortalitySmooth which creates 
equally-spaced B-splines basis over an abscissa of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MortSmooth_bbase(x, xl, xr, ndx, deg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MortSmooth_bbase_+3A_x">x</code></td>
<td>
<p>vector for the abscissa of data;</p>
</td></tr>
<tr><td><code id="MortSmooth_bbase_+3A_xl">xl</code></td>
<td>
<p>left boundary;</p>
</td></tr>
<tr><td><code id="MortSmooth_bbase_+3A_xr">xr</code></td>
<td>
<p>right boundary;</p>
</td></tr>
<tr><td><code id="MortSmooth_bbase_+3A_ndx">ndx</code></td>
<td>
<p>number of internal knots minus one or number of internal intervals;</p>
</td></tr>
<tr><td><code id="MortSmooth_bbase_+3A_deg">deg</code></td>
<td>
<p>degree of the splines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reproduce an algorithm presented by Eilers and Marx 
(2010) using differences of truncated power functions 
(see MortSmooth_tpower). The final matrix has a single B-spline for each 
of the [ndx + deg] columns. The number of rows is equal to the length of x.
</p>
<p>The function differs from bs in the package splines since it automatically 
constructed B-splines with identical shape. This would allow a simple 
interpretation of coefficients and application of simple differencing.
</p>


<h3>Value</h3>

<p>A matrix containing equally-spaced B-splines of degree deg along 
x for each column.
</p>


<h3>Author(s)</h3>

<p>Carlo G Camarda
</p>

<hr>
<h2 id='MortSmooth_tpower'>Truncated p-th Power Function</h2><span id='topic+MortSmooth_tpower'></span>

<h3>Description</h3>

<p>This is an internal function of package MortalitySmooth which constructs a 
truncated p-th power function along an abscissa within the function 
MortSmooth_bbase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MortSmooth_tpower(x, tt, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MortSmooth_tpower_+3A_x">x</code></td>
<td>
<p>for the abscissa of data;</p>
</td></tr>
<tr><td><code id="MortSmooth_tpower_+3A_tt">tt</code></td>
<td>
<p>vector of truncation points;</p>
</td></tr>
<tr><td><code id="MortSmooth_tpower_+3A_p">p</code></td>
<td>
<p>degree of the power</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function used in MortSmooth_bbase. 
The vector t contains the knots. The simplest system of truncated power 
functions uses p = 0 and it consists of step functions with jumps of size 1 
at the truncation points t.
</p>


<h3>Author(s)</h3>

<p>Carlo G Camarda
</p>

<hr>
<h2 id='ofun'>Objective function</h2><span id='topic+ofun'></span>

<h3>Description</h3>

<p>Objective function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ofun(L, I, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ofun_+3A_l">L</code></td>
<td>
<p>lambda.hat</p>
</td></tr>
<tr><td><code id="ofun_+3A_i">I</code></td>
<td>
<p>Input object from pclm function</p>
</td></tr>
<tr><td><code id="ofun_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='optimize_par'>Optimize Smoothing Parameters
This function optimize searches of <code>lambda, kr</code> and <code>deg</code>. 
See <code><a href="#topic+control.pclm">control.pclm</a></code> to see what is their meaning. 
The optimization process works in steps. Simultaneous optimization was 
tested and found inefficient.</h2><span id='topic+optimize_par'></span>

<h3>Description</h3>

<p>Optimize Smoothing Parameters
This function optimize searches of <code>lambda, kr</code> and <code>deg</code>. 
See <code><a href="#topic+control.pclm">control.pclm</a></code> to see what is their meaning. 
The optimization process works in steps. Simultaneous optimization was 
tested and found inefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_par(I, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_par_+3A_i">I</code></td>
<td>
<p>Input object from pclm function</p>
</td></tr>
<tr><td><code id="optimize_par_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='pclm'>Univariate Penalized Composite Link Model (PCLM)</h2><span id='topic+pclm'></span>

<h3>Description</h3>

<p>Fit univariate penalized composite link model (PCLM) to ungroup binned 
count data, e.g. age-at-death distributions grouped in age classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm(
  x,
  y,
  nlast,
  offset = NULL,
  out.step = 1,
  ci.level = 95,
  verbose = FALSE,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_y">y</code></td>
<td>
<p>Vector with counts to be ungrouped. It must have the same dimension 
as <code>x</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="pclm_+3A_offset">offset</code></td>
<td>
<p>Optional offset term to calculate smooth mortality rates. 
A vector of the same length as x and y. See 
Rizzi et al. (2015) for further details.</p>
</td></tr>
<tr><td><code id="pclm_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
<tr><td><code id="pclm_+3A_ci.level">ci.level</code></td>
<td>
<p>Level of significance for computing confidence intervals. 
Default: <code>95</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Indicates whether a progress bar should be 
shown or not.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pclm_+3A_control">control</code></td>
<td>
<p>List with additional parameters: </p>

<ul>
<li><p><code>lambda</code> &ndash; Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.
</p>
</li>
<li><p>kr &ndash; Knot ratio. Number of internal intervals used for defining 
1 knot in B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.
</p>
</li>
<li><p><code>deg</code> &ndash; Degree of the splines needed to create equally-spaced 
B-splines basis over an abscissa of data.
</p>
</li>
<li><p><code>int.lambda</code> &ndash; If <code>lambda</code> is optimized an interval to be 
searched needs to be specified. Format: vector containing the end-points.
</p>
</li>
<li><p><code>diff</code> &ndash; An integer indicating the order of differences of the 
components of PCLM coefficients.
</p>
</li>
<li><p><code>opt.method</code> &ndash; Selection criterion of the model.
Possible values are <code>"AIC"</code> and <code>"BIC"</code>.
</p>
</li>
<li><p><code>max.iter</code> &ndash; Maximal number of iterations used in fitting 
procedure.
</p>
</li>
<li><p><code>tol</code> &ndash; Relative tolerance in PCLM fitting procedure.</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The PCLM method is based on the composite link model, which extends 
standard generalized linear models. It implements the idea that the observed 
counts, interpreted as realizations from Poisson distributions, are indirect 
observations of a finer (ungrouped) but latent sequence. This latent sequence 
represents the distribution of expected means on a fine resolution and has 
to be estimated from the aggregated data. Estimates are obtained by 
maximizing a penalized likelihood. This maximization is performed efficiently 
by a version of the iteratively reweighted least-squares algorithm. Optimal 
values of the smoothing parameter are chosen by minimizing Bayesian or 
Akaike's Information Criterion.
</p>


<h3>Value</h3>

<p>The output is a list with the following components:
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p> A list with arguments provided in input. Saved for 
convenience.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> The fitted values of the PCLM model.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p> Confidence intervals around fitted values.</p>
</td></tr>
<tr><td><code>goodness.of.fit</code></td>
<td>
<p> A list containing goodness of fit measures: 
standard errors, AIC and BIC.</p>
</td></tr> 
<tr><td><code>smoothPar</code></td>
<td>
<p> Estimated smoothing parameters: <code>lambda, kr</code> 
and <code>deg</code>.</p>
</td></tr>
<tr><td><code>bins.definition</code></td>
<td>
<p> Additional values to identify the bins limits and 
location in input and output objects.</p>
</td></tr>
<tr><td><code>deep</code></td>
<td>
<p> A list of objects created in the fitting process. Useful 
in diagnosis of possible issues.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> An unevaluated function call, that is, an unevaluated 
expression which consists of the named function applied to the given 
arguments.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rizzi S, Gampe J, Eilers PHC (2015).
&ldquo;Efficient Estimation of Smooth Distributions From Coarsely Grouped Data.&rdquo;
<em>American Journal of Epidemiology</em>, <b>182</b>(2), 138-147.
<a href="https://doi.org/10.1093/aje/kwv020">doi:10.1093/aje/kwv020</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.pclm">control.pclm</a></code>
<code><a href="#topic+plot.pclm">plot.pclm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data  
x &lt;- c(0, 1, seq(5, 85, by = 5))
y &lt;- c(294, 66, 32, 44, 170, 284, 287, 293, 361, 600, 998, 
       1572, 2529, 4637, 6161, 7369, 10481, 15293, 39016)
offset &lt;- c(114, 440, 509, 492, 628, 618, 576, 580, 634, 657, 
            631, 584, 573, 619, 530, 384, 303, 245, 249) * 1000
nlast &lt;- 26 # the size of the last interval

# Example 1 ----------------------
M1 &lt;- pclm(x, y, nlast)
ls(M1)
summary(M1)
fitted(M1)
plot(M1)

# Example 2 ----------------------
# ungroup even in smaller intervals
M2 &lt;- pclm(x, y, nlast, out.step = 0.5)
head(fitted(M1))
plot(M1, type = "s")
# Note, in example 1 we are estimating intervals of length 1. In example 2 
# we are estimating intervals of length 0.5 using the same aggregate data.

# Example 3 ----------------------
# Do not optimise smoothing parameters; choose your own. Faster.
M3 &lt;- pclm(x, y, nlast, out.step = 0.5, 
           control = list(lambda = 100, kr = 10, deg = 10))
plot(M3)

summary(M2)
summary(M3) # not the smallest BIC here, but sometimes is not important.

# Example 4 -----------------------
# Grouped x &amp; grouped offset (estimate death rates)
M4 &lt;- pclm(x, y, nlast, offset)
plot(M4, type = "s")

# Example 5 -----------------------
# Grouped x &amp; ungrouped offset (estimate death rates)

ungroupped_Ex &lt;- pclm(x, y = offset, nlast, offset = NULL)$fitted # ungroupped offset data

M5 &lt;- pclm(x, y, nlast, offset = ungroupped_Ex)
</code></pre>

<hr>
<h2 id='pclm.confidence'>Compute Confidence Intervals for PCLM output</h2><span id='topic+pclm.confidence'></span>

<h3>Description</h3>

<p>Compute Confidence Intervals for PCLM output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm.confidence(fit, out.step, y, SE, ci.level, type, offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm.confidence_+3A_fit">fit</code></td>
<td>
<p>Fitted values from pclm.fit</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_y">y</code></td>
<td>
<p>Vector with counts to be ungrouped. It must have the same dimension 
as <code>x</code>.</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_se">SE</code></td>
<td>
<p>Standard Errors</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_ci.level">ci.level</code></td>
<td>
<p>Level of significance for computing confidence intervals. 
Default: <code>95</code>.</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
<tr><td><code id="pclm.confidence_+3A_offset">offset</code></td>
<td>
<p>Optional offset term to calculate smooth mortality rates. 
A vector of the same length as x and y. See 
Rizzi et al. (2015) for further details.</p>
</td></tr>
</table>

<hr>
<h2 id='pclm.confidence.dx'>Compute Confidence Intervals for estimated distribution</h2><span id='topic+pclm.confidence.dx'></span>

<h3>Description</h3>

<p>Compute Confidence Intervals for estimated distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm.confidence.dx(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm.confidence.dx_+3A_x">X</code></td>
<td>
<p>List of inputs from pclm.confidence function</p>
</td></tr>
</table>

<hr>
<h2 id='pclm.confidence.mx'>Compute Confidence Intervals for estimated hazard</h2><span id='topic+pclm.confidence.mx'></span>

<h3>Description</h3>

<p>Compute Confidence Intervals for estimated hazard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm.confidence.mx(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm.confidence.mx_+3A_x">X</code></td>
<td>
<p>List of inputs from pclm.confidence function</p>
</td></tr>
</table>

<hr>
<h2 id='pclm.fit'>Fit PCLM Models</h2><span id='topic+pclm.fit'></span>

<h3>Description</h3>

<p>This is an internal function used to estimate PCLM model. It is used by 
<code><a href="#topic+pclm">pclm</a></code> and <code><a href="#topic+pclm2D">pclm2D</a></code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm.fit(
  x,
  y,
  nlast,
  offset,
  out.step,
  verbose,
  lambda,
  kr,
  deg,
  diff,
  max.iter,
  tol,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm.fit_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_y">y</code></td>
<td>
<p>Vector with counts to be ungrouped. It must have the same dimension 
as <code>x</code>.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_offset">offset</code></td>
<td>
<p>Optional offset term to calculate smooth mortality rates. 
A vector of the same length as x and y. See 
Rizzi et al. (2015) for further details.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Indicates whether a progress bar should be 
shown or not.
Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_kr">kr</code></td>
<td>
<p>Knot ratio. Number of internal intervals used for defining 1 knot in 
B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_deg">deg</code></td>
<td>
<p>Degree of the splines needed to create equally-spaced B-splines 
basis over an abscissa of data.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_diff">diff</code></td>
<td>
<p>An integer indicating the order of differences of the components 
of PCLM coefficients. Default value: 2.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations used in fitting procedure.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance in PCLM fitting procedure. Default: 0.1% i.e. 
the estimated aggregate bins should be in the 0.1% error margin.</p>
</td></tr>
<tr><td><code id="pclm.fit_+3A_type">type</code></td>
<td>
<p>Type of PCLM model. Options: <code>"1D", "2D"</code> for 
univariate and two-dimensional model respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='pclm.input.check'>Validate input values</h2><span id='topic+pclm.input.check'></span>

<h3>Description</h3>

<p>Validate input values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm.input.check(X, pclm.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm.input.check_+3A_x">X</code></td>
<td>
<p>A list with input arguments provided in <code><a href="#topic+pclm">pclm</a></code> function</p>
</td></tr>
</table>

<hr>
<h2 id='pclm2D'>Two-Dimensional Penalized Composite Link Model (PCLM-2D)</h2><span id='topic+pclm2D'></span>

<h3>Description</h3>

<p>Fit two-dimensional penalized composite link model (PCLM-2D), 
e.g. simultaneous ungrouping of age-at-death distributions grouped in age 
classes for adjacent years. The PCLM can be extended to a two-dimensional 
regression problem. This is particularly suitable for mortality analysis 
when mortality surfaces are to be estimated to capture both age-specific 
trajectories of coarsely grouped distributions and time trends 
(Rizzi et al. 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclm2D(
  x,
  y,
  nlast,
  offset = NULL,
  out.step = 1,
  ci.level = 95,
  verbose = TRUE,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclm2D_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_y">y</code></td>
<td>
<p><code>data.frame</code> with counts to be ungrouped. The number of rows 
should be equal with the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_offset">offset</code></td>
<td>
<p>Optional offset term to calculate smooth mortality rates. 
A vector of the same length as x and y. See 
Rizzi et al. (2015) for further details.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_ci.level">ci.level</code></td>
<td>
<p>Level of significance for computing confidence intervals. 
Default: <code>95</code>.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. Indicates whether a progress bar should be 
shown or not. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pclm2D_+3A_control">control</code></td>
<td>
<p>List with additional parameters: </p>

<ul>
<li><p><code>lambda</code> &ndash; Smoothing parameter to be used in pclm estimation.
If <code>lambda = NA</code> an algorithm will find the optimal values.
</p>
</li>
<li><p>kr &ndash; Knot ratio. Number of internal intervals used for defining 
1 knot in B-spline basis construction. See <code><a href="#topic+MortSmooth_bbase">MortSmooth_bbase</a></code>.
</p>
</li>
<li><p><code>deg</code> &ndash; Degree of the splines needed to create equally-spaced 
B-splines basis over an abscissa of data.
</p>
</li>
<li><p><code>int.lambda</code> &ndash; If <code>lambda</code> is optimized an interval to be 
searched needs to be specified. Format: vector containing the end-points.
</p>
</li>
<li><p><code>diff</code> &ndash; An integer indicating the order of differences of the 
components of PCLM coefficients.
</p>
</li>
<li><p><code>opt.method</code> &ndash; Selection criterion of the model.
Possible values are <code>"AIC"</code> and <code>"BIC"</code>.
</p>
</li>
<li><p><code>max.iter</code> &ndash; Maximal number of iterations used in fitting 
procedure.
</p>
</li>
<li><p><code>tol</code> &ndash; Relative tolerance in PCLM fitting procedure.</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a list with the following components:
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p> A list with arguments provided in input. Saved for 
convenience.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> The fitted values of the PCLM model.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p> Confidence intervals around fitted values.</p>
</td></tr>
<tr><td><code>goodness.of.fit</code></td>
<td>
<p> A list containing goodness of fit measures: 
standard errors, AIC and BIC.</p>
</td></tr> 
<tr><td><code>smoothPar</code></td>
<td>
<p> Estimated smoothing parameters: <code>lambda, kr</code> 
and <code>deg</code>.</p>
</td></tr>
<tr><td><code>bins.definition</code></td>
<td>
<p> Additional values to identify the bins limits and 
location in input and output objects.</p>
</td></tr>
<tr><td><code>deep</code></td>
<td>
<p> A list of objects created in the fitting process. Useful 
in diagnosis of possible issues.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> An unevaluated function call, that is, an unevaluated 
expression which consists of the named function applied to the given 
arguments.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rizzi S, Gampe J, Eilers PHC (2015).
&ldquo;Efficient Estimation of Smooth Distributions From Coarsely Grouped Data.&rdquo;
<em>American Journal of Epidemiology</em>, <b>182</b>(2), 138-147.
<a href="https://doi.org/10.1093/aje/kwv020">doi:10.1093/aje/kwv020</a>.<br /><br /> Rizzi S, Halekoh U, Thinggaard M, Engholm G, Christensen N, Johannesen TB, Lindahl-Jacobsen R (2019).
&ldquo;How to estimate mortality trends from grouped vital statistics.&rdquo;
<em>International Journal of Epidemiology</em>, <b>48</b>(2), 571&ndash;582.
<a href="https://doi.org/10.1093/ije/dyy183">doi:10.1093/ije/dyy183</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.pclm2D">control.pclm2D</a></code>
<code><a href="#topic+plot.pclm2D">plot.pclm2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Input data
Dx &lt;- ungroup.data$Dx
Ex &lt;- ungroup.data$Ex

# Aggregate data to be ungrouped in the examples below
# Select a 10y data frame
x      &lt;- c(0, 1, seq(5, 85, by = 5))
nlast  &lt;- 26
n      &lt;- c(diff(x), nlast)
group  &lt;- rep(x, n)
y      &lt;- aggregate(Dx, by = list(group), FUN = "sum")[, 2:10]
offset &lt;- aggregate(Ex, by = list(group), FUN = "sum")[, 2:10]

# Example 1 ---------------------- 
# Fit model and ungroup data using PCLM-2D
P1 &lt;- pclm2D(x, y, nlast)
summary(P1)

# Plot fitted values
plot(P1)

# Plot input data
plot(P1, "observed")

# NOTE: pclm2D does not search for optimal smoothing parameters by default
# (like pclm does) because it is more time consuming. If optimization is 
# required set lambda = c(NA, NA):

P1 &lt;- pclm2D(x, y, nlast, control = list(lambda = c(NA, NA)))

# Example 2 ---------------------- 
# Ungroup and build a mortality surface
P2 &lt;- pclm2D(x, y, nlast, offset)
summary(P2)

plot(P2, type = "observed")
plot(P2, type = "fitted")
plot(P2, type = "fitted", colors = c("blue", "red"))
</code></pre>

<hr>
<h2 id='plot.pclm'>Generic Plot for pclm Class</h2><span id='topic+plot.pclm'></span>

<h3>Description</h3>

<p>Generic Plot for pclm Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
plot(x, xlab, ylab, ylim, type, lwd, col, legend, legend.position, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pclm_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+pclm">pclm</a></code></p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to a description of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to a description of <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired. 
The following values are possible, for details, see plot: &quot;p&quot; for points, 
&quot;l&quot; for lines, &quot;b&quot; for both points and lines, &quot;c&quot; for empty points joined 
by lines, &quot;o&quot; for overplotted points and lines, &quot;s&quot; and &quot;S&quot; for stair 
steps and &quot;h&quot; for histogram-like vertical lines. Finally, &quot;n&quot; does not 
produce any points or lines.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_lwd">lwd</code></td>
<td>
<p>Line width, a positive number, defaulting to 2.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_col">col</code></td>
<td>
<p>Three colours to be used in the plot for observed values, 
fitted values and confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_legend">legend</code></td>
<td>
<p>a character or <a href="base.html#topic+expression">expression</a> vector
of length <code class="reqn">\ge 1</code> to appear in the legend.  Other
objects will be coerced by <code><a href="grDevices.html#topic+as.graphicsAnnot">as.graphicsAnnot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_legend.position">legend.position</code></td>
<td>
<p>Legend position, or the x and y co-ordinates to be 
used to position the legend.</p>
</td></tr>
<tr><td><code id="plot.pclm_+3A_...">...</code></td>
<td>
<p>other graphical parameters (see <a href="graphics.html#topic+par">par</a> for more details).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pclm">pclm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See complete examples in pclm help page
</code></pre>

<hr>
<h2 id='plot.pclm2D'>Generic Plot for pclm2D Class</h2><span id='topic+plot.pclm2D'></span>

<h3>Description</h3>

<p>The generic plot for a <code>pclm2D</code> object is constructed using 
<code><a href="graphics.html#topic+persp">persp</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
plot(
  x,
  type = c("fitted", "observed"),
  colors = c("#b6e3db", "#e5d9c2", "#b5ba61", "#725428"),
  nbcol = 25,
  xlab = "x",
  ylab = "y",
  zlab = "values",
  phi = 30,
  theta = 210,
  border = "grey50",
  ticktype = "simple",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pclm2D_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+pclm2D">pclm2D</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_type">type</code></td>
<td>
<p>chart type. Defines which data are plotted, <code>"fitted"</code> 
values or <code>"observed"</code> input data. Default: <code>"fitted"</code>.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_colors">colors</code></td>
<td>
<p>colors to interpolate; must be a valid argument to
<code><a href="grDevices.html#topic+col2rgb">col2rgb</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_nbcol">nbcol</code></td>
<td>
<p>dimension of the color palette. Number of colors. Default: 25.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_xlab">xlab</code>, <code id="plot.pclm2D_+3A_ylab">ylab</code>, <code id="plot.pclm2D_+3A_zlab">zlab</code></td>
<td>
<p>titles for the axes.  N.B. These must be
character strings; expressions are not accepted.  Numbers will be
coerced to character strings.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_theta">theta</code>, <code id="plot.pclm2D_+3A_phi">phi</code></td>
<td>
<p>angles defining the viewing direction.
<code>theta</code> gives the azimuthal direction and <code>phi</code>
the colatitude.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_border">border</code></td>
<td>
<p>the color of the line drawn around the surface facets.
The default, <code>NULL</code>, corresponds to <code>par("fg")</code>.
A value of <code>NA</code> will disable the drawing of borders: this is
sometimes useful when the surface is shaded.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_ticktype">ticktype</code></td>
<td>
<p>character: <code>"simple"</code> draws just an arrow
parallel to the axis to indicate direction of increase;
<code>"detailed"</code> draws normal ticks as per 2D plots.</p>
</td></tr>
<tr><td><code id="plot.pclm2D_+3A_...">...</code></td>
<td>
<p>any other argument to be passed to 
<code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pclm2D">pclm2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See complete examples in pclm2D help page
</code></pre>

<hr>
<h2 id='print.pclm'>Print for pclm method</h2><span id='topic+print.pclm'></span>

<h3>Description</h3>

<p>Print for pclm method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pclm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"pclm"</code></p>
</td></tr>
<tr><td><code id="print.pclm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.pclm2D'>Print method for pclm2D</h2><span id='topic+print.pclm2D'></span>

<h3>Description</h3>

<p>Print method for pclm2D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pclm2D_+3A_x">x</code></td>
<td>
<p>An object of class <code>"pclm2D"</code></p>
</td></tr>
<tr><td><code id="print.pclm2D_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.pclm'>Print for summary.pclm method</h2><span id='topic+print.summary.pclm'></span>

<h3>Description</h3>

<p>Print for summary.pclm method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pclm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pclm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.pclm"</code></p>
</td></tr>
<tr><td><code id="print.summary.pclm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.pclm2D'>Print method for summary.pclm2D</h2><span id='topic+print.summary.pclm2D'></span>

<h3>Description</h3>

<p>Print method for summary.pclm2D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pclm2D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pclm2D_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summary.pclm2D"</code></p>
</td></tr>
<tr><td><code id="print.summary.pclm2D_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.ungroup.data'>Print function for <code>ungroup.data</code></h2><span id='topic+print.ungroup.data'></span>

<h3>Description</h3>

<p>Print function for <code>ungroup.data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ungroup.data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ungroup.data_+3A_x">x</code></td>
<td>
<p>An <code>ungroup.data</code> object</p>
</td></tr>
<tr><td><code id="print.ungroup.data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.pclm'>Extract PCLM Deviance Residuals</h2><span id='topic+residuals.pclm'></span>

<h3>Description</h3>

<p>Extract PCLM Deviance Residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.pclm_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.pclm_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals extracted from the object <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 1, seq(5, 85, by = 5))
y &lt;- c(294, 66, 32, 44, 170, 284, 287, 293, 361, 600, 998, 
       1572, 2529, 4637, 6161, 7369, 10481, 15293, 39016)
M1 &lt;- pclm(x, y, nlast = 26)

residuals(M1)
</code></pre>

<hr>
<h2 id='residuals.pclm2D'>Extract PCLM-2D Deviance Residuals</h2><span id='topic+residuals.pclm2D'></span>

<h3>Description</h3>

<p>Extract PCLM-2D Deviance Residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.pclm2D_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model residuals is
meaningful.</p>
</td></tr>
<tr><td><code id="residuals.pclm2D_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals extracted from the object <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Dx &lt;- ungroup.data$Dx
Ex &lt;- ungroup.data$Ex

# Aggregate data to ungroup it in the example below
x      &lt;- c(0, 1, seq(5, 85, by = 5))
nlast  &lt;- 26
n      &lt;- c(diff(x), nlast)
group  &lt;- rep(x, n)
y      &lt;- aggregate(Dx, by = list(group), FUN = "sum")[, -1]

# Example
P1 &lt;- pclm2D(x, y, nlast)

residuals(P1)
</code></pre>

<hr>
<h2 id='seqlast'>Sequence function with last value</h2><span id='topic+seqlast'></span>

<h3>Description</h3>

<p>Sequence function with last value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqlast(from, to, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqlast_+3A_from">from</code>, <code id="seqlast_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end values of the
sequence.  Of length <code>1</code> unless just <code>from</code> is supplied as
an unnamed argument.</p>
</td></tr>
<tr><td><code id="seqlast_+3A_by">by</code></td>
<td>
<p>number: increment of the sequence.</p>
</td></tr>
</table>

<hr>
<h2 id='suggest.valid.out.step'>Suggest values of <code>out.step</code> that do not 
require an adjustment of <code>nlast</code></h2><span id='topic+suggest.valid.out.step'></span>

<h3>Description</h3>

<p>Suggest values of <code>out.step</code> that do not 
require an adjustment of <code>nlast</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest.valid.out.step(len, increment = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suggest.valid.out.step_+3A_len">len</code></td>
<td>
<p>Interval length</p>
</td></tr>
<tr><td><code id="suggest.valid.out.step_+3A_increment">increment</code></td>
<td>
<p>Increment</p>
</td></tr>
</table>

<hr>
<h2 id='summary.pclm'>Summary for pclm method</h2><span id='topic+summary.pclm'></span>

<h3>Description</h3>

<p>Summary for pclm method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pclm_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.pclm_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.pclm2D'>Summary method for pclm2D
Generic function used to produce result summaries of the results produced 
by <code><a href="#topic+pclm2D">pclm2D</a></code>.</h2><span id='topic+summary.pclm2D'></span>

<h3>Description</h3>

<p>Summary method for pclm2D
Generic function used to produce result summaries of the results produced 
by <code><a href="#topic+pclm2D">pclm2D</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pclm2D'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pclm2D_+3A_object">object</code></td>
<td>
<p>an object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.pclm2D_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>

<hr>
<h2 id='ungroup.data'>Test Dataset in the Package</h2><span id='topic+ungroup.data'></span>

<h3>Description</h3>

<p>Dataset containing death counts (Dx) and exposures (Ex)  by age for a 
certain population between 1980 and 2014. The data-set is provided for 
testing purposes only and might be altered and outdated. Download actual 
demographic data free of charge from Human Mortality Database (2018). 
Once a username and a password is created on the 
<a href="https://www.mortality.org">website</a> the 
<a href="https://CRAN.R-project.org/package=MortalityLaws">
MortalityLaws</a> R package can be used to extract data in R format.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>ungroup.data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ungroup.data</code> of length 2.
</p>


<h3>Source</h3>

<p><a href="https://www.mortality.org">Human Mortality Database</a>
</p>


<h3>References</h3>

<p>Human Mortality Database (2018).
&ldquo;University of California, Berkeley (USA), and Max Planck Institute for Demographic Research (Germany). Data downloaded on 17/01/2018.&rdquo;
<a href="https://www.mortality.org">https://www.mortality.org</a>.<br /><br /> Pascariu MD (2018).
<em>MortalityLaws: Parametric Mortality Models, Life Tables and HMD</em>.
R package version 1.6.0, <a href="https://github.com/mpascariu/MortalityLaws">https://github.com/mpascariu/MortalityLaws</a>.
</p>


<h3>See Also</h3>

<p><code><a href="MortalityLaws.html#topic+ReadHMD">ReadHMD</a></code>
</p>

<hr>
<h2 id='validate.nlast'>Check if <code>nlast</code> needs to be adjusted in order to accommodate 
<code>out.step</code></h2><span id='topic+validate.nlast'></span>

<h3>Description</h3>

<p>Check if <code>nlast</code> needs to be adjusted in order to accommodate 
<code>out.step</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.nlast(x, nlast, out.step)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.nlast_+3A_x">x</code></td>
<td>
<p>Vector containing the starting values of the input intervals/bins.
For example: if we have 3 bins <code>[0,5), [5,10) and [10, 15)</code>,
<code>x</code> will be defined by the vector: <code>c(0, 5, 10)</code>.</p>
</td></tr>
<tr><td><code id="validate.nlast_+3A_nlast">nlast</code></td>
<td>
<p>Length of the last interval. In the example above <code>nlast</code> 
would be 5.</p>
</td></tr>
<tr><td><code id="validate.nlast_+3A_out.step">out.step</code></td>
<td>
<p>Length of estimated intervals in output. 
Values between 0.1 and 1 are accepted. Default: 1.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
