<!DOCTYPE html><html><head><title>Help for package Epi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Epi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='# hivDK '><p> hivDK: seroconversion in a cohort of Danish men</p></a></li>
<li><a href='#AaJ.Lexis'><p>The Aalen-Johansen estimator of state probabilities from a</p>
multistate <code>Lexis</code> object.</a></li>
<li><a href='#addCov.Lexis'>
<p>Add covariates (typically clinical measurements) taken at known times</p>
to a Lexis object.</a></li>
<li><a href='#addDrug.Lexis'>
<p>Expand a Lexis object with information of drug exposure based on</p>
purchase dates and -amounts</a></li>
<li><a href='#apc.fit'>
<p>Fit an Age-Period-Cohort model to tabular data.</p></a></li>
<li><a href='#apc.frame'>
<p>Produce an empty frame for display of parameter-estimates from</p>
Age-Period-Cohort-models.</a></li>
<li><a href='#apc.LCa'><p>Fit Age-Period-Cohort models and Lee-Carter models with effects</p>
modeled by natural splines.</a></li>
<li><a href='#apc.lines'>
<p>Plot APC-estimates in an APC-frame.</p></a></li>
<li><a href='#B.dk'><p>Births in Denmark by year and month of birth and sex</p></a></li>
<li><a href='#bdendo'><p>A case-control study of endometrial cancer</p></a></li>
<li><a href='#births'><p>Births in a London Hospital</p></a></li>
<li><a href='#blcaIT'><p>Bladder cancer mortality in Italian males</p></a></li>
<li><a href='#bootLexis'>
<p>Create a bootstrap sample of persons (as identified by <code>lex.id</code>) from a Lexis object</p></a></li>
<li><a href='#boxes.MS'>
<p>Draw boxes and arrows for illustration of multistate models.</p></a></li>
<li><a href='#BrCa'><p>Clinical status,</p>
relapse, metastasis and death in 2982 women with breast cancer.</a></li>
<li><a href='#brv'><p>Bereavement in an elderly cohort</p></a></li>
<li><a href='#cal.yr'>
<p>Functions to convert character, factor and various date objects into a number,</p>
and vice versa.</a></li>
<li><a href='#cbind.Lexis'><p>Combining a Lexis objects with data frames or other Lexis objects</p></a></li>
<li><a href='#ccwc'><p>Generate a nested case-control study</p></a></li>
<li><a href='#ci.Crisk'>
<p>Compute cumulative risks and expected sojourn times from models for</p>
cause-specific rates.</a></li>
<li><a href='#ci.cum'><p> Compute cumulative sum of estimates.</p></a></li>
<li><a href='#ci.lin'>
<p>Compute linear functions of parameters with standard errors and</p>
confidence limits, optionally transforming to a different scale.</a></li>
<li><a href='#ci.pd'>
<p>Compute confidence limits for a difference of two independent proportions.</p></a></li>
<li><a href='#clogistic'><p>Conditional logistic regression</p></a></li>
<li><a href='#contr.cum'>
<p>Contrast matrices</p></a></li>
<li><a href='#crr.Lexis'><p>Fit a competing risks regression model (Fine-Gray model) using a</p>
Lexis object)</a></li>
<li><a href='#cutLexis'>
<p>Cut follow-up at a specified date for each person.</p></a></li>
<li><a href='#detrend'><p> Projection of a model matrix on the orthogonal</p>
complement of a trend or curvature.</a></li>
<li><a href='#diet'><p>Diet and heart data</p></a></li>
<li><a href='#DMconv'><p>Conversion to diabetes</p></a></li>
<li><a href='#DMepi'><p>Epidemiological rates for diabetes in Denmark 1996&ndash;2015</p></a></li>
<li><a href='#DMlate'>
<p>The Danish National Diabetes Register.</p></a></li>
<li><a href='#effx'><p>Function to calculate effects</p></a></li>
<li><a href='#effx.match'><p>Function to calculate effects for individually matched case-control studies</p></a></li>
<li><a href='#entry.Lexis'><p>Time series and other methods for Lexis objects</p></a></li>
<li><a href='#Epi'><p>Epi: Functions for manipulation and statistical analysis of epidemiological data</p></a></li>
<li><a href='#erl'><p>Compute survival functions from rates and expected residual</p>
lifetime in an illness-death model as well as years of life lost to disease.</a></li>
<li><a href='#ewrates'><p>Rates of lung and nasal cancer mortality, and total mortality.</p></a></li>
<li><a href='#expand.data'>
<p>Function to expand data for regression analysis of interval censored</p>
data.</a></li>
<li><a href='#fit.add'>
<p>Fit an addive excess risk model to interval censored data.</p></a></li>
<li><a href='#fit.baseline'>
<p>Fit a piecewise contsnt intesity model for interval censored data.</p></a></li>
<li><a href='#fit.mult'>
<p>Fits a multiplicative relative risk model to interval censored data.</p></a></li>
<li><a href='#float'><p>Calculate floated variances</p></a></li>
<li><a href='#foreign.Lexis'><p>Create a data structures suitable for use with packages <code>mstate</code> or <code>etm</code>.</p></a></li>
<li><a href='#ftrend'><p>Fit a floating trend to a factor in generalized linear model</p></a></li>
<li><a href='#gen.exp'>
<p>Generate covariates for drug-exposure follow-up from drug purchase records.</p></a></li>
<li><a href='#gmortDK'><p>Population mortality rates for Denmark in 5-years age groups.</p></a></li>
<li><a href='#harm'><p>Create a basis of harmonic functions.</p></a></li>
<li><a href='#Icens'>
<p>Fits a regression model to interval censored data.</p></a></li>
<li><a href='#in.span'>
<p>Is <code>x</code> in the column span of matrix <code>A</code> and what columns are</p>
linearly dependent?</a></li>
<li><a href='#LCa.fit'>
<p>Fit Lee-Carter-type models for rates to arbitrarily shaped observations</p>
of rates in a Lexis diagram.</a></li>
<li><a href='#lep'><p>An unmatched case-control study of leprosy incidence</p></a></li>
<li><a href='#Lexis'><p>Create a Lexis object of follow-up</p></a></li>
<li><a href='#Lexis.diagram'><p>Plot a Lexis diagram</p></a></li>
<li><a href='#Lexis.lines'><p>Draw life lines in a Lexis diagram.</p></a></li>
<li><a href='#Lexis2msm'><p>Convert a Lexis obejct to a data set suitable for input to the</p>
<code>msm:msm</code> function.</a></li>
<li><a href='#lgrep'>
<p>Convenience versions of grep</p></a></li>
<li><a href='#Life.lines'>
<p>Compute dates/ages for life lines in a Lexis diagram</p></a></li>
<li><a href='#lls'><p>Functions to manage and explore the workspace</p></a></li>
<li><a href='#lungDK'><p>Male lung cancer incidence in Denmark</p></a></li>
<li><a href='#M.dk'><p>Mortality in Denmark 1974 ff.</p></a></li>
<li><a href='#mat2pol'><p>Plot columns of a matrix as stacked areas.</p></a></li>
<li><a href='#matshade'>
<p>Plot confidence intervals as shaded areas around lines.</p></a></li>
<li><a href='#mcutLexis'>
<p>Cut follow-up at multiple event dates and keep track of order of events</p></a></li>
<li><a href='#merge.Lexis'><p>Merge a Lexis object with a data frame</p></a></li>
<li><a href='#mh'>
<p>Mantel-Haenszel analyses of cohort and case-control studies</p></a></li>
<li><a href='#mod.Lexis'><p>Fit intensity models to follow-up data in Lexis objects</p></a></li>
<li><a href='#mortDK'><p>Population mortality rates for Denmark in 1-year age-classes.</p></a></li>
<li><a href='#N.dk'><p>Population size in Denmark</p></a></li>
<li><a href='#N2Y'>
<p>Create risk time (&quot;Person-Years&quot;) in Lexis triangles from population count data.</p></a></li>
<li><a href='#NArray'><p>Set up an array of NAs, solely from the list of dimnames</p></a></li>
<li><a href='#ncut'>
<p>Function to group a variable in intervals.</p></a></li>
<li><a href='#nice'><p>Nice breakpoints</p></a></li>
<li><a href='#nickel'><p>A Cohort of Nickel Smelters in South Wales</p></a></li>
<li><a href='#Ns'>
<p>Natural splines - (cubic splines linear beyond outermost knots) with</p>
convenient specification of knots and possibility of centering,
detrending and clamping.</a></li>
<li><a href='#occup'><p> A small occupational cohort</p></a></li>
<li><a href='#pc.lines'>
<p>Plot period and cohort effects in an APC-frame.</p></a></li>
<li><a href='#pctab'><p>Create percentages in a table</p></a></li>
<li><a href='#plot.apc'><p>Plot the estimates from a fitted Age-Period-Cohort model</p></a></li>
<li><a href='#plot.Lexis'><p>Lexis diagrams</p></a></li>
<li><a href='#plotCIF'><p>Plotting Aalen-Johansen curves for competing events</p></a></li>
<li><a href='#plotEst'>
<p>Plot estimates with confidence limits (forest plot)</p></a></li>
<li><a href='#plotevent'><p> Plot Equivalence Classes</p></a></li>
<li><a href='#poisreg'><p>Family Object for Poisson Regression</p></a></li>
<li><a href='#pr'><p>Diabetes prevance as of 2010-01-01 in Denmark</p></a></li>
<li><a href='#projection.ip'><p> Projection of columns of a matrix.</p></a></li>
<li><a href='#rateplot'>
<p>Functions to plot rates from a table classified by age and</p>
calendar time (period)</a></li>
<li><a href='#rcutLexis'>
<p>A function to cut follow-up at intermediate event times.</p></a></li>
<li><a href='#Relevel'><p>Reorder and combine levels of a factor</p></a></li>
<li><a href='#rm.tr'>
<p>Remove transitions from a Lexis object.</p></a></li>
<li><a href='#ROC'><p>Function to compute and draw ROC-curves.</p></a></li>
<li><a href='#S.typh'><p>Salmonella Typhimurium outbreak 1996 in Denmark.</p></a></li>
<li><a href='#simLexis'><p>Simulate a Lexis object representing follow-up in a multistate</p>
model.</a></li>
<li><a href='#splitLexis'><p>Split follow-up time in a Lexis object</p></a></li>
<li><a href='#stack.Lexis'>
<p>Functions to facilitate analysis of multistate models.</p></a></li>
<li><a href='#stat.table'><p>Tables of summary statistics</p></a></li>
<li><a href='#stattable.funs'><p>Special functions for use in stat.table</p></a></li>
<li><a href='#steno2'>
<p>Clinical trial: Steno2 baseline and follow-up.</p></a></li>
<li><a href='#subset.Lexis'><p>Subsetting Lexis (and stacked.Lexis) objects</p></a></li>
<li><a href='#summary.Lexis'>
<p>Summarize transitions and risk time from a Lexis object</p></a></li>
<li><a href='#Termplot'>
<p>A wrapper for <code>termplot</code> that optionally (but by default)</p>
exponentiates terms, and plot them on a common log-scale. Also scales
x-axes to the same physical scale.</a></li>
<li><a href='#testisDK'><p>Testis cancer incidence in Denmark, 1943&ndash;1996</p></a></li>
<li><a href='#thoro'><p>Thorotrast Study</p></a></li>
<li><a href='#timeBand'><p>Extract time band data from a split Lexis object</p></a></li>
<li><a href='#timeScales'><p>The time scales of a Lexis object</p></a></li>
<li><a href='#transform.Lexis'><p>Transform a Lexis (or stacked.Lexis) object</p></a></li>
<li><a href='#twoby2'><p>Analysis of a two by two table</p></a></li>
<li><a href='#Y.dk'><p>Population risk time in Denmark</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.47.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis in Epidemiology</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>cmprsk, etm, splines, MASS, survival, plyr, dplyr, Matrix,
numDeriv, data.table, zoo, mgcv, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mstate, nlme, lme4, demography, popEpi, tidyr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for demographic and epidemiological analysis in
  the Lexis diagram, i.e. register and cohort follow-up data. In
  particular representation, manipulation, rate estimation and
  simulation for multistate data - the Lexis suite of functions, which
  includes interfaces to 'mstate', 'etm' and 'cmprsk' packages.
  Contains functions for Age-Period-Cohort and Lee-Carter modeling and
  a function for interval censored data and some useful functions for
  tabulation and plotting, as well as a number of epidemiological data
  sets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://bendixcarstensen.com/Epi/">http://bendixcarstensen.com/Epi/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-25 05:45:38 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Bendix Carstensen [aut, cre],
  Martyn Plummer [aut],
  Esa Laara [ctb],
  Michael Hills [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bendix Carstensen &lt;b@bxc.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-25 06:21:00 UTC</td>
</tr>
</table>
<hr>
<h2 id='+20hivDK+20'> hivDK: seroconversion in a cohort of Danish men</h2><span id='topic+hivDK'></span>

<h3>Description</h3>

<p>Data from a survey of HIV-positivity of a cohort of Danish
men followed by regular tests from 1983 to 1989.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(hivDK)
  </code></pre>


<h3>Format</h3>

<p>A data frame with 297 observations on the following 7 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>ID of the person</p>
</dd>
<dt><code>entry</code></dt><dd><p>Date of entry to the study. Date variable.</p>
</dd>
<dt><code>well</code></dt><dd><p>Date last seen seronegative. Date variable.</p>
</dd>
<dt><code>ill</code></dt><dd><p>Date first seen seroconverted. Date variable.</p>
</dd>
<dt><code>bth</code></dt><dd><p>Year of birth minus 1950.</p>
</dd>
<dt><code>pyr</code></dt><dd><p>Annual number of sexual partners.</p>
</dd>
<dt><code>us</code></dt><dd><p>Indicator of wheter the person has visited the USA.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mads Melbye, Statens Seruminstitut.
</p>


<h3>References</h3>

<p>Becker N.G. and Melbye M.: Use of a log-linear model to
compute the empirical survival curve from interval-censored data,
with application to data on tests for HIV-positivity, Australian
Journal of Statistics, 33, 125&ndash;133, 1990.
</p>
<p>Melbye M., Biggar R.J., Ebbesen P., Sarngadharan M.G., Weiss
S.H., Gallo R.C. and Blattner W.A.: Seroepidemiology of HTLV-III
antibody in Danish homosexual men: prevalence, transmission and
disease outcome. British Medical Journal, 289, 573&ndash;575, 1984.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(hivDK)
  str(hivDK) 
  </code></pre>

<hr>
<h2 id='AaJ.Lexis'>The Aalen-Johansen estimator of state probabilities from a
multistate <code>Lexis</code> object.
</h2><span id='topic+AaJ.Lexis'></span>

<h3>Description</h3>

<p>The Aalen-Johansen estimator is computed on the basis of a
<code><a href="#topic+Lexis">Lexis</a></code> multistate object along a given time scale. The
function is merely a wrapper for the <code><a href="survival.html#topic+survfit">survfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
AaJ(Lx,
               formula = ~ 1,
             timeScale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AaJ.Lexis_+3A_lx">Lx</code></td>
<td>
<p>A <code>Lexis</code> object. The starting state must be the first
among <code>levels(Lx)</code>.
</p>
</td></tr>
<tr><td><code id="AaJ.Lexis_+3A_formula">formula</code></td>
<td>
<p>A one-sided formula passed on to <code>survfit</code>.
</p>
</td></tr>
<tr><td><code id="AaJ.Lexis_+3A_timescale">timeScale</code></td>
<td>
<p>Chararter or integer, selecting one of the timescales
of the <code>Lexis</code> object.
</p>
</td></tr>
<tr><td><code id="AaJ.Lexis_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>survfitms</code> &mdash; see
<code><a href="survival.html#topic+survfit">survfit</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>
<code><a href="#topic+ci.Crisk">ci.Crisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
str(DMlate)
dml &lt;- Lexis(entry = list(Per = dodm,
                          Age = dodm-dobth,
                        DMdur = 0 ),
              exit = list(Per = dox),
       exit.status = factor(!is.na(dodth),
                            labels = c("DM","Dead")),
              data = DMlate )

# Cut the follow-up at insulin start
dmi &lt;- cutLexis(dml,
                cut = dml$doins,
          new.state = "Ins",
        split.state = TRUE)
summary( dmi )
ms &lt;- AaJ.Lexis(dmi, timeScale = "DMdur")
class(ms)
ms$states
head(ms$pstate)
</code></pre>

<hr>
<h2 id='addCov.Lexis'>
Add covariates (typically clinical measurements) taken at known times
to a Lexis object. 
</h2><span id='topic+addCov.Lexis'></span>

<h3>Description</h3>

<p>When follow-up in a multistate model is represented in a
<code><a href="#topic+Lexis">Lexis</a></code> object we may want to add information on
covariates, for example clinical measurements, obtained at different
times. This function cuts the follow-up time (see
<code><a href="#topic+cutLexis">cutLexis</a></code>) at the times of measurement and carries the
measurements forward in time to the next measurement occasion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
addCov(Lx,
                     clin,
                timescale = 1,
                    exnam,
                      tfc = "tfc", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCov.Lexis_+3A_lx">Lx</code></td>
<td>

<p>A Lexis object with follow-up of a cohort.  
</p>
</td></tr>
<tr><td><code id="addCov.Lexis_+3A_clin">clin</code></td>
<td>

<p>A data frame with covariates to add (typically clinical
measurements). Must contain a variable <code>lex.id</code> identifying the
persons represented in <code>Lx</code>, as well as a variable with the
same name as one of the <code><a href="#topic+timeScales">timeScales</a></code> in <code>Lx</code>,
identifying the time at which covariates are measured.
</p>
<p>The times must be unique within each person; if not records with
duplicate times are discarded, and a warning issued. This is done
using <code>duplicated</code>, so not very well-defined, it is advisable
that you do this by yourself.
</p>
</td></tr>
<tr><td><code id="addCov.Lexis_+3A_timescale">timescale</code></td>
<td>

<p>Numerical or character. Number or name of a timescale in
<code>Lx</code>. The <code>clin</code> data frame must have a variable of this
name indicating the time at which the covariate measurements were
taken.
</p>
</td></tr>
<tr><td><code id="addCov.Lexis_+3A_exnam">exnam</code></td>
<td>

<p>Character. Name of the variable in <code>clin</code> with the examination
names (such as <code>wave1</code>, <code>wave2</code> etc.). Values may not be
repeated within person and cannot be equal to any of
<code>levels(Lx)</code>. Will be carried over to the resulting 
<code>Lexis</code> object. If there is no such variable in <code>clin</code> it
will be constructed; if the argument is omitted, a variable called
<code>exnam</code> with values <code>ex1</code>, <code>ex2</code> etc. will be
constructed.
</p>
</td></tr>
<tr><td><code id="addCov.Lexis_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="addCov.Lexis_+3A_tfc">tfc</code></td>
<td>
      
<p>Character (<code>t</code>ime <code>f</code>rom last <code>c</code>linical visit). Name
of the variable in the result which will contain the time since the
most recent covariate date. It will be included among the timescales
of the resulting Lexis object.
</p>
<p>If the argument is omitted a variable called <code>tfc</code> will be
constructed. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Lexis</code> object representing the same follow-up as <code>Lx</code>, 
with cuts added at the times of examination, and covariate
measurements added for all records representing follow-up after the
most recent time of measurement.
</p>
<p>Also <code>tfc</code> is added as a time scale, it is however not a proper
timescale since it is reset at every clinical examination. Therefor
the value of the <code>timeSince</code> attribute is set to &quot;X&quot; in order
to distinguish it from other proper time scales that either have an
empty string or the name of a state.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>,
<code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- structure( list( id = c("A", "B", "C"),
                      birth = c("1952-07-14", "1954-04-01", "1987-06-10"),
                      entry = c("1965-08-04", "1972-09-08", "1991-12-23"),
                       exit = c("1997-06-27", "1995-05-23", "1998-07-24"),
                       fail = c(1, 0, 1) ),
                     .Names = c("id", "birth", "entry", "exit", "fail"),
                  row.names = c("1", "2", "3"),
                      class = "data.frame" )

# Convert the character dates into numerical variables (fractional years)
xcoh$bt &lt;- cal.yr( xcoh$birth )
xcoh$en &lt;- cal.yr( xcoh$entry )
xcoh$ex &lt;- cal.yr( xcoh$exit  )

# Define as Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis( entry = list( per=en ),
                exit = list( per=ex, age=ex-bt ),
         exit.status = factor( fail, 0:1, c("Alive","Dead") ),
                data = xcoh )
str( Lcoh )
Lx &lt;- Lcoh[,1:7]

# Data frame with clinical examination data, date of examination in per
clin &lt;- data.frame(lex.id = c(1,1,3,2),
                      per = cal.yr(c("1977-4-7",
                                     "1971-7-1",
                                     "1996-2-15",
                                     "1990-7-3")),
                       bp = c(120,140,160,157),
                     chol = c(5,7,8,9),
                     xnam = c("X2","X1","X1","X2") )
Lx
clin
str(Lx)
str(clin)

# Different behavours when using exnam explicitly
addCov.Lexis( Lx, clin[,-5] )
addCov.Lexis( Lx, clin, exnam="xnam" )

# Works with time split BEFORE
Lb &lt;- addCov.Lexis(splitLexis(Lx,
                              time.scale="age",
                              breaks=seq(0,80,5) ),
                   clin,
                   exnam="clX" )
Lb
# and also AFTER
La &lt;- splitLexis(addCov.Lexis( Lx,
                             clin,
                            exnam = "xnam" ),
                 breaks=seq(0,80,5),
                 time.scale="age" )
La
La$tfc == Lb$tfc
La$age == Lb$age
str(La)
str(Lb)
</code></pre>

<hr>
<h2 id='addDrug.Lexis'>
Expand a Lexis object with information of drug exposure based on
purchase dates and -amounts
</h2><span id='topic+addDrug.Lexis'></span><span id='topic+coarse.Lexis'></span>

<h3>Description</h3>

  
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object will contain information on follow-up for a
cohort of persons through time, each record containing information of
one time interval, including the time at the beginning of each
interval. If information on drug purchase is known for the persons via
<code>lex.id</code> in a list of data frames, <code>addDrug.Lexis</code> will expand
the <code>Lexis</code> object by cutting at all drug purchase dates, and
compute the exposure status for any number of drugs, and add these as
variables.
</p>
<p>In some circumstances the result is a Lexis object with a very large
number of very small follow-up intervals. The function
<code>coarse.Lexis</code> combines consecutive follow-up intervals using the
covariates from the first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDrug.Lexis(Lx,  # Lexis object
            pdat,  # list of data frames with drug purchase information
             amt = "amt", # name of the variable with purchased amount
             dpt = "dpt", # name of the variable with amount consumed per time
             apt = NULL,  # old name for dpt
          method = "ext", # method use to compute exposure 
            maxt = NULL,  # max duration for a purchase when using "fix"
           grace = 0,     # grace  period to be added
            tnam = setdiff(names(pdat[[1]]), c("lex.id", amt))[1],
                          # name of the time variable from Lx
          prefix = TRUE,  # should drug names prefix variable names 
          sepfix = ".",   # what should the separator be when forming prefix/suffix
         verbose = TRUE, ...)
coarse.Lexis(Lx, lim, keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDrug.Lexis_+3A_lx">Lx</code></td>
<td>
<p>A <code>Lexis</code> object.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_pdat">pdat</code></td>
<td>
<p>Named list of data frames with drug <code>p</code>urchase <code>dat</code>a.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_amt">amt</code></td>
<td>
<p>Name of the variable in the data frames in <code>pdat</code> with
the purchased <code>am</code>oun<code>t</code>.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_dpt">dpt</code></td>
<td>
<p>Name of the variable in the data frames in <code>pdat</code> with
the consumed <code>d</code>ose <code>p</code>er <code>t</code>ime. Must be given in
units of units of <code>amt</code> per units of <code>lex.dur</code> in <code>Lx</code>.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_apt">apt</code></td>
<td>
<p>Name previously used for <code>dpt</code>. Will disappear in next
version.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_method">method</code></td>
<td>
<p>Character. One of <code>"ext"</code> (default), <code>"dos"</code>
or  <code>"fix"</code>, for a description, see details.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_maxt">maxt</code></td>
<td>
<p>Numerical. Maximal duration for a purchase when using
<code>method="fix"</code>, same units as <code>lex.dur</code>.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_grace">grace</code></td>
<td>
<p>Numeric. Grace period to be added after last time of
computed drug coverage to define end of exposure, same units as
<code>lex.dur</code>. 
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_tnam">tnam</code></td>
<td>
<p>Character. Name of the timescale used in the data frames
in <code>pdat</code>. 
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_prefix">prefix</code></td>
<td>
<p>Logical. Should the names of <code>pdat</code> be used as
prefix for the 4 generated exposure variables for each drug. If false
the names of <code>pdat</code> will be used as suffix.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_sepfix">sepfix</code></td>
<td>
<p>Character, used to separate the <code>prefix</code> and the
name of the generated type of variable.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should the function tell you about the choices
you made?
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_lim">lim</code></td>
<td>
<p>Numeric vector of length 2. Consecutive follow-up intervals
are combined if the first has <code>lex.dur</code> &lt; <code>lim[1]</code>, and the
sum of <code>lex.dur</code> in the two intervals is smaller than
<code>lim[2]</code>. If a scalar i given, <code>c(lim,3*lim)</code> is used.
</p>
</td></tr>
<tr><td><code id="addDrug.Lexis_+3A_keep">keep</code></td>
<td>
<p>Logical of length 1 or <code>nrow(Lx)</code> that points to
records that cannot be combined with preceding records.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function internally uses <code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code> to attach
exposure status for several drugs (dispensed medicine) to follow-up in a
<code>Lexis</code> object. Once that is done, the exposure measures are
calculated at each time.
</p>
<p>There is one input data frame per type of drug, each with variables
<code>lex.id</code>, <code>amt</code>, a timescale variable and possibly a variable
<code>dpt</code>.
</p>
<p>Three different methods for computing drug exposures from dates and
amounts of purchases are supported via the argument <code>method</code>.
</p>
 
<ul>
<li> <p><code>"ext"</code>: Extrapolation: the first drug purchase is assumed
consumed over the interval to the second purchase. Exposure
for subsequent purchases are assumed to last as long as it would have if
consumed at a speed corresponding to the previous purchase being
consumed over the time span between the previous and current purchase,
plus a period of length <code>grace</code>.
</p>
</li>
<li> <p><code>"dos"</code>: Dosage: assumes that each purchase lasts
<code>amt</code>/<code>dpt</code> plus <code>grace</code>.
</p>
</li>
<li> <p><code>"fix"</code>: Fixed time: assumes that each purchase lasts
<code>maxt</code>.
</p>
</li></ul>
 
<p>So for each purchase we have defined an end of coverage (expiry
date). If next purchase is before this, we assume that the amount
purchased is consumed over the period between the two purchases,
otherwise over the period to the end of coverage. So the only difference
between the methods is the determination of the coverage for each
purchase.
</p>
<p>Based on this, for each date in the resulting <code><a href="#topic+Lexis">Lexis</a></code> four
exposure variables are computed, see next section.
</p>


<h3>Value</h3>

  
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object with the same risk time, states and events
as <code>Lx</code>. The follow-up for each person has been cut at the purchase
times of each of the drugs, as well as at the expiry times for each drug
coverage. Further, for each drug (i.e. the data frame in the <code>pdat</code>
list) the name of the <code>pdat</code> component determines the prefix for
the 4 variables that will be added. Supposing this is <code>AA</code> for a
given drug, then 4 new variables will be:
</p>

<ul>
<li> <p><code>AA.ex</code>: logical; is the person exposed in this interval
</p>
</li>
<li> <p><code>AA.tf</code>: numeric: time since first purchase, same units as
<code>lex.dur</code> 
</p>
</li>
<li> <p><code>AA.ct</code>: numeric: cumulative time on the drug, same units
as <code>lex.dur</code> 
</p>
</li>
<li> <p><code>AA.cd</code>: numeric: cumulative dose of the drug, same units
as <code>amt</code> 
</p>
</li></ul>

<p>So if <code>pdat</code> is a list of length 3 with names <code>c("a","b","c")</code>
the function will add variables
<code>a.ex, a.tf, a.ct, a.cd,
      b.ex, b.tf, b.ct, b.cd,
      c.ex, c.tf, c.ct, c.cd</code>
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.exp">gen.exp</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+rcutLexis">rcutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Follow-up of 2 persons
clear()
fu &lt;- data.frame(doe = c(2006, 2008),
                 dox = c(2015, 2018),
                 dob = c(1950, 1951),
                 xst = factor(c("A","D")))
Lx &lt;- Lexis(entry = list(per = doe,
                         age = doe- dob),
             exit = list(per = dox),
      exit.status = xst,
             data = fu)
Lx &lt;- subset(Lx, select = -c(doe, dob, dox, xst))

# split FU in 1 year intervals
Sx &lt;- splitLexis(Lx, "per", breaks = seq(1990, 2020, 1.0))

# drug purchases, one data frame for each drug 
ra &lt;- data.frame(per = c(2007 + runif(12,0,10)),
                 amt = sample(2:4, 12, r = TRUE),
              lex.id = sample(1:2, 12, r = TRUE))
ra &lt;- ra[order(ra$lex.id, ra$per),]

rb &lt;- data.frame(per = c(2009 + runif(10, 0, 10)),
                 amt = sample(round(2:4/3,1), 10, r = TRUE),
              lex.id = sample(1:2, 10, r = TRUE))
rb &lt;- rb[order(rb$lex.id, rb$per),]

# put in a named list
pdat &lt;- list(A = ra, B = rb)
pdat

ex1 &lt;- addDrug.Lexis(Sx, pdat, method = "ext") # default
summary(ex1)
# collapsing some of the smaller intervals with the next
summary(coarse.Lexis(ex1, c(0.2,0.5)))

ex2 &lt;- addDrug.Lexis(Sx, pdat, method = "ext", grace = 0.2)
dos &lt;- addDrug.Lexis(Sx, pdat, method = "dos", dpt = 6)
fix &lt;- addDrug.Lexis(Sx, pdat, method = "fix", maxt = 1)
</code></pre>

<hr>
<h2 id='apc.fit'>
Fit an Age-Period-Cohort model to tabular data.
</h2><span id='topic+apc.fit'></span>

<h3>Description</h3>

<p>Fits the classical five models to tabulated rate data (cases,
person-years) classified by two of age, period, cohort:
Age, Age-drift, Age-Period, Age-Cohort and Age-Period-Cohort. There are no
assumptions about the age, period or cohort classes being of the same
length, or that tabulation should be only by two of the variables.
Only requires that mean age and period for each tabulation unit is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.fit( data,
            A,
            P,
            D,
            Y,
        ref.c,
        ref.p,
          dist = c("poisson","binomial"),
         model = c("ns","bs","ls","factor"),
       dr.extr = "Y",
          parm = c("ACP","APC","AdCP","AdPC","Ad-P-C","Ad-C-P","AC-P","AP-C"),
          npar = c( A=5, P=5, C=5 ),
         scale = 1,
         alpha = 0.05,
     print.AOV = TRUE )
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apc.fit_+3A_data">data</code></td>
<td>
<p>Data frame with (at least) variables, <code>A</code> (age),
<code>P</code> (period), <code>D</code> (cases, deaths) and <code>Y</code>
(person-years). Cohort (date of birth) is computed as <code>P-A</code>.
If this argument is given the arguments <code>A</code>, <code>P</code>,
<code>D</code> and <code>Y</code> are ignored.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_a">A</code></td>
<td>
<p>Age; numerical vector with mean age at diagnosis for each unit.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_p">P</code></td>
<td>
<p>Period; numerical vector with mean date of diagnosis for each
unit.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_d">D</code></td>
<td>
<p>Cases, deaths; numerical vector.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_y">Y</code></td>
<td>
<p>Person-years; numerical vector. Also used as denominator for binomial
data, see the <code>dist</code> argument.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_ref.c">ref.c</code></td>
<td>
<p>Reference cohort, numerical. Defaults to median date of
birth among cases. If used with <code>parm="AdCP"</code> or <code>parm="AdPC"</code>,
the residual cohort effects will be 1 at <code>ref.c</code></p>
</td></tr>
<tr><td><code id="apc.fit_+3A_ref.p">ref.p</code></td>
<td>
<p>Reference period, numerical. Defaults to median date of
diagnosis among cases.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_dist">dist</code></td>
<td>
<p>Distribution (or more precisely: Likelihood) used for modeling.
if a binomial model us used, <code>Y</code> is assumed to be the
denominator; <code>"binomial"</code> gives a binomial model with logit
link. The Age-effects returned are converted to the
probability scale, Period and Cohort effects are still odds-ratios.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_model">model</code></td>
<td>
<p>Type of model (covariate effects) fitted:
</p>

<ul>
<li> <p><code>ns</code> fits a model with natural splines for each of
the terms, with <code>npar</code> parameters for the terms.
</p>
</li>
<li> <p><code>bs</code> fits a model with B-splines for each of
the terms, with <code>npar</code> parameters for the terms.
</p>
</li>
<li> <p><code>ls</code> fits a model with linear splines.
</p>
</li>
<li> <p><code>factor</code> fits a factor model with one parameter
per value of <code>A</code>, <code>P</code> and <code>P-A</code>. <code>npar</code>
is ignored in this case. 
</p>
</li></ul>

</td></tr>
<tr><td><code id="apc.fit_+3A_dr.extr">dr.extr</code></td>
<td>
<p>Character or numeric.	
How the drift parameter should be extracted from the
age-period-cohort model. Specifies the inner product used for
definition of orthogonality of the period / cohort effects to the
linear effects &mdash; in terms of a diagonal matrix.
</p>
<p><code>"Y"</code> (default) uses the no. person-time, <code>Y</code>,
corresponding to the observed information about the square root of
the rate.
</p>
<p><code>"R"</code> or <code>"L"</code> uses <code>Y*Y/D</code> corresponding to the
observed information about the rate (usually termed &quot;lambda&quot;, hence
the &quot;<code>L</code>&quot;). 
</p>
<p><code>"D"</code> or <code>"T"</code> uses the no. events as the weight in the
inner product, corresponding to the information about the log-rate
(usually termed &quot;theta&quot;, hence the &quot;<code>T</code>&quot;).
</p>
<p>If given <code>"n"</code> (naive) (well, in fact any other character value) will
induce the use of the standard inner product putting equal weight on
all units in the dataset.
</p>
<p>If <code>dr.extr</code> is a numeric vector this is used as the diagonal
of the matrix inducing the inner product. 
</p>
<p>If <code>dr.extr</code> is a numeric scalar, <code>D + dr.extr*Y</code> is used
as the diagonal of the matrix inducing the inner product. This
family of inner products are the only ones that meet the
split-observation invariance criterion.
</p>
<p>The setting of this parameter has no effect on the fit of the model,
it only influences the parametrization returned in the <code>Age</code>,
<code>Per</code> and <code>Coh</code> elements of the resulting list.
</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_parm">parm</code></td>
<td>
<p>Character. Indicates the parametrization of the effects.
The first four refer to the ML-fit of the Age-Period-Cohort model,
the last four give Age-effects from a smaller model and residuals
relative to this. If one of the latter is chosen, the argument
<code>dr.extr</code> is ignored. Possible values for <code>parm</code> are:
</p>

<ul>
<li> <p><code>"ACP"</code>: ML-estimates. Age-effects as rates for the
reference cohort. Cohort effects as RR relative to the reference
cohort. Period effects constrained to be 0 on average with 0 slope.
</p>
</li>
<li> <p><code>"APC"</code>: ML-estimates. Age-effects as rates for the
reference period. Period effects as RR relative to the reference
period. Cohort effects constrained to be 0 on average with 0 slope.
</p>
</li>
<li> <p><code>"AdCP"</code>: ML-estimates. Age-effects as rates for the
reference cohort. Cohort and period effects constrained to be 0 on
average with 0 slope. In this case returned effects do not
multiply to the fitted rates, the drift is missing and needs to be
included to produce the fitted values.
</p>
</li>
<li> <p><code>"AdPC"</code>: ML-estimates. Age-effects as rates for the
reference period. Cohort and period effects constrained to be 0 on
average with 0 slope. In this case returned effects do not
multiply to the fitted rates, the drift is missing and needs to be
included to produce the fitted values.
</p>
</li>
<li> <p><code>"Ad-C-P"</code>: Age effects are rates for the reference
cohort in the Age-drift model (cohort drift). Cohort effects are from the model
with cohort alone, using log(fitted values) from the Age-drift
model as offset. Period effects are from the model with period
alone using log(fitted values) from the cohort model as offset.
</p>
</li>
<li> <p><code>"Ad-P-C"</code>: Age effects are rates for the reference
period in the Age-drift model (period drift). Period effects are from the model
with period alone, using log(fitted values) from the Age-drift
model as offset. Cohort effects are from the model with cohort
alone using log(fitted values) from the period model as offset.
</p>
</li>
<li> <p><code>"AC-P"</code>: Age effects are rates for the reference
cohort in the Age-Cohort model, cohort effects are RR relative to
the reference cohort. Period effects are from the model
with period alone, using log(fitted values) from the Age-Cohort
model as offset.
</p>
</li>
<li> <p><code>"AP-C"</code>: Age effects are rates for the reference
period in the Age-Period model, period effects are RR relative to
the reference period. Cohort effects are from the model
with cohort alone, using log(fitted values) from the Age-Period
model as offset.
</p>
</li></ul>
 </td></tr>
<tr><td><code id="apc.fit_+3A_npar">npar</code></td>
<td>
<p>The number of parameters/knots to use for each of the terms in
the model. If it is vector of length 3, the numbers are taken as the
no. of knots for Age, Period and Cohort, respectively. Unless it has
a names attribute with values &quot;A&quot;, &quot;P&quot; and &quot;C&quot; in which case these
will be used. The knots chosen are the quantiles
<code>(1:nk-0.5)/nk</code> of the events (i.e. of <code>rep(A,D)</code> and
similarly for <code>P</code> and <code>C</code>).
</p>
<p><code>npar</code> may also be a named list of three numerical vectors with
names &quot;A&quot;, &quot;P&quot; and &quot;C&quot;, in which case these taken as the knots for
the age, period and cohort effect, the smallest and largest element in
each vector are used as the boundary knots.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_alpha">alpha</code></td>
<td>
<p>The significance level. Estimates are given with
(1-<code>alpha</code>) confidence limits.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_scale">scale</code></td>
<td>
<p>numeric(1), factor multiplied to the rate estimates before output.</p>
</td></tr>
<tr><td><code id="apc.fit_+3A_print.aov">print.AOV</code></td>
<td>
<p>Should the analysis of deviance table for the models
be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each record in the input data frame represents a subset of a Lexis
diagram. The subsets need not be of equal length on the age and
period axes, in fact there are no restrictions on the shape of
these; they could be Lexis triangles for example. The requirement is
that <code>A</code> and <code>P</code> are coded with the mean age and calendar
time of observation in the subset. This is essential since <code>A</code>
and <code>P</code> are used as quantitative variables in the models.
</p>
<p>This approach is different from to the vast majority of the uses of
APC-models in the literature where a factor model is used for age,
period and cohort effects. The latter can be obtained by using
<code>model="factor"</code>. Note however that the cohort factor is defined
from <code>A</code> and <code>P</code>, so that it is not possible in this
framework to replicate the Boyle-Robertson fallacy.
</p>


<h3>Value</h3>

<p>An object of class &quot;apc&quot; (recognized by <code><a href="#topic+apc.plot">apc.plot</a></code> and
<code><a href="#topic+apc.lines">apc.lines</a></code>) &mdash; a list with components:
</p>
<table>
<tr><td><code>Type</code></td>
<td>
<p>Text describing the model and parametrization returned.</p>
</td></tr>
<tr><td><code>Model</code></td>
<td>
<p>The model object(s) on which the parametrization is based.</p>
</td></tr>
<tr><td><code>Age</code></td>
<td>
<p>Matrix with 4 columns: <code>A.pt</code> with the ages (equals
<code>unique(A)</code>) and three columns giving the estimated rates with
c.i.s.</p>
</td></tr>
<tr><td><code>Per</code></td>
<td>
<p>Matrix with 4 columns: <code>P.pt</code> with the dates of
diagnosis (equals <code>unique(P)</code>) and three columns giving the
estimated RRs with c.i.s.</p>
</td></tr>
<tr><td><code>Coh</code></td>
<td>
<p>Matrix with 4 columns: <code>C.pt</code> with the dates of birth
(equals <code>unique(P-A)</code>) and three columns giving the estimated
RRs with c.i.s.</p>
</td></tr>
<tr><td><code>Drift</code></td>
<td>
<p>A 3 column matrix with drift-estimates and c.i.s: The
first row is the ML-estimate of the drift (as defined by
<code>drift</code>), the second row is the estimate from the Age-drift
model. The first row name indicates which type of inner product were
used for projections. For the sequential parametrizations, only the
latter is given.</p>
</td></tr>
<tr><td><code>Ref</code></td>
<td>
<p>Numerical vector of length 2 with reference period and cohort.
If ref.p or ref.c was not supplied the corresponding element is NA.</p>
</td></tr>
<tr><td><code>Anova</code></td>
<td>
<p>Analysis of deviance table comparing the five classical
models.</p>
</td></tr>
<tr><td><code>Knots</code></td>
<td>
<p>If <code>model</code> is one of <code>"ns"</code> or <code>"bs"</code>, a list
with three components: <code>Age</code>, <code>Per</code>, <code>Coh</code>, each one a
vector of knots. The max and the min of the vectors are the boundary knots.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>References</h3>

<p>The considerations behind the parametrizations used in this function
are given in detail in:
B. Carstensen: Age-Period-Cohort models for the Lexis diagram.
Statistics in Medicine, 10; 26(15):3018-45, 2007.
</p>
<p>Various links to course material etc. is available through
<a href="http://bendixcarstensen.com/APC/">http://bendixcarstensen.com/APC/</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.frame">apc.frame</a></code>,
<code><a href="#topic+apc.lines">apc.lines</a></code>,
<code><a href="#topic+apc.plot">apc.plot</a></code>,
<code><a href="#topic+LCa.fit">LCa.fit</a></code>,
<code><a href="#topic+apc.LCa">apc.LCa</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library( Epi )
data(lungDK)

# Taylor a dataframe that meets the requirements for variable names
exd &lt;- lungDK[,c("Ax","Px","D","Y")]
names(exd)[1:2] &lt;- c("A","P")

# Three different ways of parametrizing the APC-model, ML
ex.1 &lt;- apc.fit( exd, npar=7, model="ns", dr.extr="1", parm="ACP", scale=10^5 )
ex.D &lt;- apc.fit( exd, npar=7, model="ns", dr.extr="D", parm="ACP", scale=10^5 )
ex.Y &lt;- apc.fit( exd, npar=7, model="ns", dr.extr="Y", parm="ACP", scale=10^5 )

# Sequential fit, first AC, then P given AC.
ex.S &lt;- apc.fit( exd, npar=7, model="ns", parm="AC-P", scale=10^5 )

# Show the estimated drifts
ex.1[["Drift"]]
ex.D[["Drift"]]
ex.Y[["Drift"]]
ex.S[["Drift"]]

# Plot the effects
lt &lt;- c("solid","22")[c(1,1,2)]
apc.plot( ex.1, lty=c(1,1,3) )
apc.lines( ex.D, col="red", lty=c(1,1,3) )
apc.lines( ex.Y, col="limegreen", lty=c(1,1,3) )
apc.lines( ex.S, col="blue", lty=c(1,1,3) )
</code></pre>

<hr>
<h2 id='apc.frame'>
Produce an empty frame for display of parameter-estimates from
Age-Period-Cohort-models.
</h2><span id='topic+apc.frame'></span>

<h3>Description</h3>

<p>A plot is generated where both the age-scale and the cohort/period
scale is on the x-axis. The left vertical axis will be a logarithmic
rate scale referring to age-effects and the right a logarithmic
rate-ratio scale of the same relative extent as the left referring to
the cohort and period effects (rate ratios).
</p>
<p>Only an empty plot frame is generated. Curves or points must be added
with <code>points</code>, <code>lines</code> or the special utility function
<code><a href="#topic+apc.lines">apc.lines</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  apc.frame( a.lab,
            cp.lab,
             r.lab,
            rr.lab = r.lab / rr.ref,
            rr.ref = r.lab[length(r.lab)/2],
             a.tic = a.lab,
            cp.tic = cp.lab,
             r.tic = r.lab,
            rr.tic = r.tic / rr.ref,
           tic.fac = 1.3,
             a.txt = "Age",
            cp.txt = "Calendar time",
             r.txt = "Rate per 100,000 person-years",
            rr.txt = "Rate ratio",
          ref.line = TRUE,
               gap = diff(range(c(a.lab, a.tic)))/10,
          col.grid = gray(0.85),
             sides = c(1,2,4) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apc.frame_+3A_a.lab">a.lab</code></td>
<td>
<p>Numerical vector of labels for the age-axis.</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_cp.lab">cp.lab</code></td>
<td>
<p>Numerical vector of labels for the cohort-period axis.</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_r.lab">r.lab</code></td>
<td>
<p>Numerical vector of labels for the rate-axis (left vertical)</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_rr.lab">rr.lab</code></td>
<td>
<p>Numerical vector of labels for the RR-axis (right vertical)</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_rr.ref">rr.ref</code></td>
<td>
<p>At what level of the rate scale is the RR=1 to be.</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_a.tic">a.tic</code></td>
<td>
<p>Location of additional tick marks on the age-scale</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_cp.tic">cp.tic</code></td>
<td>
<p>Location of additional tick marks on the cohort-period-scale</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_r.tic">r.tic</code></td>
<td>
<p>Location of additional tick marks on the rate-scale</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_rr.tic">rr.tic</code></td>
<td>
<p>Location of additional tick marks on the RR-axis.</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_tic.fac">tic.fac</code></td>
<td>
<p>Factor with which to diminish intermediate tick marks</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_a.txt">a.txt</code></td>
<td>
<p>Text for the age-axis (left part of horizontal axis).</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_cp.txt">cp.txt</code></td>
<td>
<p>Text for the cohort/period axis (right part of
horizontal axis).</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_r.txt">r.txt</code></td>
<td>
<p>Text for the rate axis (left vertical axis).</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_rr.txt">rr.txt</code></td>
<td>
<p>Text for the rate-ratio axis (right vertical axis)</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_ref.line">ref.line</code></td>
<td>
<p>Logical. Should a reference line at RR=1 be drawn at the
calendar time part of the plot?</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_gap">gap</code></td>
<td>
<p>Gap between the age-scale and the cohort-period scale</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_col.grid">col.grid</code></td>
<td>
<p>Colour of the grid put in the plot.</p>
</td></tr>
<tr><td><code id="apc.frame_+3A_sides">sides</code></td>
<td>
<p>Numerical vector indicating on which sides axes should
be drawn and annotated. This option is aimed for multi-panel
displays where axes only are put on the outer plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces an empty plot frame for display of results
from an age-period-cohort model, with age-specific rates in the left
side of the frame and cohort and period rate-ratio parameters in the
right side of the frame. There is a gap of <code>gap</code> between the
age-axis and the calendar time axis, vertical grid lines at
<code>c(a.lab,a.tic,cp.lab,cp.tic)</code>, and horizontal grid lines at
<code>c(r.lab,r.tic)</code>.
</p>
<p>The function returns a numerical vector of
length 2, with names <code>c("cp.offset","RR.fac")</code>. The y-axis for
the plot will be a rate scale for the age-effects, and the x-axis will
be the age-scale. The cohort and period effects are plotted by
subtracting the first element (named <code>"cp.offset"</code>) of the returned result
form the cohort/period, and multiplying  the rate-ratios by the second
element of the returned result (named <code>"RR.fac"</code>).
</p>


<h3>Value</h3>

<p>A numerical vector of length two, with names
<code>c("cp.offset","RR.fac")</code>. The first is the offset for the cohort
period-axis, the second the multiplication factor for the rate-ratio
scale.
</p>
<p>Side-effect: A plot with axes and grid lines but no points or curves.
Moreover, the option <code>apc.frame.par</code> is given the value
<code>c("cp.offset","RR.fac")</code>, which is recognized by <code><a href="#topic+apc.plot">apc.plot</a></code>
and <code><a href="#topic+apc.lines">apc.lines</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Age-Period-Cohort models for the Lexis
diagram. Statistics in Medicine, 26: 3018-3045, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.lines">apc.lines</a>,<a href="#topic+apc.fit">apc.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par( mar=c(4,4,1,4) )
res &lt;-
apc.frame( a.lab=seq(30,90,20), cp.lab=seq(1880,2000,30), r.lab=c(1,2,5,10,20,50),
           a.tic=seq(30,90,10), cp.tic=seq(1880,2000,10), r.tic=c(1:10,1:5*10),
           gap=27 )
res
# What are the axes actually?
par(c("usr","xlog","ylog"))
# How to plot in the age-part: a point at (50,10)
points( 50, 10, pch=16, cex=2, col="blue" )
# How to plot in the cohort-period-part: a point at (1960,0.3)
points( 1960-res[1], 0.3*res[2], pch=16, cex=2, col="red" )
# or referring to the period-cohort part of the plot 
pc.points( 1960, 0.3, pch=16, cex=1, col="green" )
</code></pre>

<hr>
<h2 id='apc.LCa'>Fit Age-Period-Cohort models and Lee-Carter models with effects
modeled by natural splines.
</h2><span id='topic+apc.LCa'></span><span id='topic+show.apc.LCa'></span>

<h3>Description</h3>

<p><code>apc.LCa</code> fits an Age-Period-Cohort model and sub-models (using
<code><a href="#topic+apc.fit">apc.fit</a></code>) as well as Lee-Carter models (using
<code><a href="#topic+LCa.fit">LCa.fit</a></code>). <code>show.apc.LCa</code> plots the models in little
boxes with their residual deviance with arrows showing their
relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apc.LCa( data,
  keep.models = FALSE,
          ... )
show.apc.LCa( x,
       dev.scale = TRUE,
             top = "Ad", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apc.LCa_+3A_data">data</code></td>
<td>
<p>A data frame that must have columns <code>A</code>, <code>P</code>,
<code>D</code> and <code>Y</code>, see e.g. <code><a href="#topic+apc.fit">apc.fit</a></code>
</p>
</td></tr>
<tr><td><code id="apc.LCa_+3A_keep.models">keep.models</code></td>
<td>
<p>Logical. Should the <code>apc</code> object and the 5
<code>LCa</code> objects be returned too?
</p>
</td></tr>
<tr><td><code id="apc.LCa_+3A_...">...</code></td>
<td>
<p>Further parameters passed on to <code><a href="#topic+LCa.fit">LCa.fit</a></code> or
<code><a href="#topic+boxes.matrix">boxes.matrix</a></code>. 
</p>
</td></tr>
<tr><td><code id="apc.LCa_+3A_x">x</code></td>
<td>
<p>The result from a call to <code>apc.LCa</code>.</p>
</td></tr>
<tr><td><code id="apc.LCa_+3A_dev.scale">dev.scale</code></td>
<td>
<p>Should the vertical position of the boxes with the
models be scales relative to the deviance between the Age-drift
model and the extended Lee-Carter model?</p>
</td></tr>
<tr><td><code id="apc.LCa_+3A_top">top</code></td>
<td>
<p>The model presented at the top of the plot of boxes
(together with any other model with larger deviance) when
vertical position is scaled by deviances. Only &quot;Ad&quot;, &quot;AP&quot;, &quot;AC&quot;,
&quot;APa&quot; or &quot;ACa&quot; will make sense.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>apc.LCa</code> fits all 9 models (well, 10) available as
extension and sub-models of the APC-model and compares them by
returning deviance and residual df.
</p>


<h3>Value</h3>

<p>A 9 by 2 matrix classified by model and deviance/df; optionally
(if <code>models=TRUE</code>) a list with the matrix as <code>dev</code>, <code>apc</code>, an
<code>apc</code> object (from <code><a href="#topic+apc.fit">apc.fit</a></code>), and <code>LCa</code>, a list
with 5 <code>LCa</code> objects (from <code><a href="#topic+LCa.fit">LCa.fit</a></code>). 
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+apc.fit">apc.fit</a></code>, <code><a href="#topic+LCa.fit">LCa.fit</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library( Epi )
clear()
# Danish lung cancer incidence in 5x5x5 Lexis triangles
data( lungDK )
lc &lt;- subset( lungDK, Ax&gt;40 )[,c("Ax","Px","D","Y")]
names( lc )[1:2] &lt;- c("A","P")
head( lc )

al &lt;- apc.LCa( lc, npar=c(9,6,6,6,10), keep.models=TRUE, maxit=500, eps=10e-3 )
show.apc.LCa( al, dev=TRUE )

# Danish mortality data
## Not run: 
data( M.dk )
mdk &lt;- subset( M.dk, sex==1 )[,c("A","P","D","Y")]
head( mdk )

al &lt;- apc.LCa( mdk, npar=c(15,15,20,6,6), maxit=50, eps=10e-3,
               quiet=FALSE, VC=FALSE )
show.apc.LCa( al, dev=FALSE )
show.apc.LCa( al, dev=TRUE )
show.apc.LCa( al, top="AP" )

# Fit a reasonable model to Danish mortality data and plot results
mAPa &lt;- LCa.fit( mdk, model="APa", npar=c(15,15,20,6,6), c.ref=1930,
                 a.ref=70, quiet=FALSE, maxit=250 )
par( mfrow=c(1,3) )
plot( mAPa ) 
## End(Not run)
</code></pre>

<hr>
<h2 id='apc.lines'>
Plot APC-estimates in an APC-frame.
</h2><span id='topic+lines.apc'></span><span id='topic+apc.lines'></span>

<h3>Description</h3>

<p>When an APC-frame has been produced by <code><a href="#topic+apc.frame">apc.frame</a></code>, this
function draws a set of estimates from an APC-fit in the frame. An
optional drift parameter can be added to the period parameters and
subtracted from the cohort and age parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'apc'
lines( x, P, C,
        scale = c("log","ln","rates","inc","RR"),
    frame.par = options()[["apc.frame.par"]],
        drift = 0,
           c0 = median( C[,1] ),
           a0 = median( A[,1] ),
           p0 = c0 + a0,
           ci = rep( FALSE, 3 ),
          lwd = c(3,1,1),
          lty = 1,
          col = "black",
         type = "l",
        knots = FALSE,
        shade = FALSE,
          ... )
 apc.lines( x, P, C,
        scale = c("log","ln","rates","inc","RR"),
    frame.par = options()[["apc.frame.par"]],
        drift = 0,
           c0 = median( C[,1] ),
           a0 = median( A[,1] ),
           p0 = c0 + a0,
           ci = rep( FALSE, 3 ),
          lwd = c(3,1,1),
          lty = 1,
          col = "black",
         type = "l",
        knots = FALSE,
        shade = FALSE,
          ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apc.lines_+3A_x">x</code></td>
<td>
<p>If an <code>apc</code>-object, (see <code><a href="#topic+apc.fit">apc.fit</a></code>), then
the arguments <code>P</code>, <code>C</code>, <code>c0</code>, <code>a0</code> and <code>p0</code>
are ignored, and the estimates from <code>x</code> plotted.
</p>
<p>Can also be a 4-column matrix with columns age, age-specific
rates, lower and upper c.i., in which case period and cohort effects
are taken from the arguments <code>P</code> and <code>C</code>.
</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_p">P</code></td>
<td>
<p>Period effects. Rate-ratios. Same form as for the age-effects.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_c">C</code></td>
<td>
<p>Cohort effects. Rate-ratios. Same form as for the age-effects.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_scale">scale</code></td>
<td>
<p>Are effects given on a log-scale? Character variable, one
of <code>"log"</code>, <code>"ln"</code>, <code>"rates"</code>, <code>"inc"</code>,
<code>"RR"</code>. If <code>"log"</code> or <code>"ln"</code> it is assumed that
effects are log(rates) and log(RRs) otherwise the actual effects are
assumed given in <code>A</code>, <code>P</code> and <code>C</code>. If <code>A</code> is of
class <code>apc</code>, it is assumed to be <code>"rates"</code>.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_frame.par">frame.par</code></td>
<td>
<p>2-element vector with the cohort-period offset and
RR multiplicator. This will typically be the result from the call of
<code><a href="#topic+apc.frame">apc.frame</a></code>. See this for details.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_drift">drift</code></td>
<td>
<p>The drift parameter to be added to the period effect. If
<code>scale="log"</code> this is assumed to be on the log-scale, otherwise
it is assumed to be a multiplicative factor per unit of the first
columns of  <code>A</code>, <code>P</code> and <code>C</code> </p>
</td></tr>
<tr><td><code id="apc.lines_+3A_c0">c0</code></td>
<td>
<p>The cohort where the drift is assumed to be 0; the subtracted
drift effect is <code>drift*(C[,1]-c0)</code>.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_a0">a0</code></td>
<td>
<p>The age where the drift is assumed to be 0.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_p0">p0</code></td>
<td>
<p>The period where the drift is assumed to be 0.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_ci">ci</code></td>
<td>
<p>Should confidence interval be drawn. Logical or
character. If character, any occurrence of <code>"a"</code> or <code>"A"</code>
produces confidence intervals for the age-effect. Similarly for
period and cohort.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_lwd">lwd</code></td>
<td>
<p>Line widths for estimates, lower and upper confidence limits.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_lty">lty</code></td>
<td>
<p>Linetypes for the three effects.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_col">col</code></td>
<td>
<p>Colours for the three effects.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_type">type</code></td>
<td>
<p>What type of lines / points should be used.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_knots">knots</code></td>
<td>
<p>Should knots from the model be shown?</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_shade">shade</code></td>
<td>
<p>Should confidence intervals be plotted as shaded areas?
If true, the setting of <code>ci</code> is ignored.</p>
</td></tr>
<tr><td><code id="apc.lines_+3A_...">...</code></td>
<td>
<p>Further parameters to be transmitted to <code>points</code>
<code>lines</code>, <code>matpoints</code> or <code>matlines</code> used
for plotting the three sets of curves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no difference between the functions <code>apc.lines</code> and
<code>lines.apc</code>, except the the latter is the <code>lines</code> method
for <code>apc</code> objects.
</p>
<p>The drawing of three effects in an APC-frame is a rather trivial task,
and the main purpose of the utility is to provide a function that
easily adds the functionality of adding a drift so that several sets
of lines can be easily produced in the same frame.
</p>


<h3>Value</h3>

<p><code>apc.lines</code> returns (invisibly) a list of three matrices of the
effects plotted.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.frame">apc.frame</a></code>, <code><a href="#topic+pc.lines">pc.lines</a></code>, <code><a href="#topic+apc.fit">apc.fit</a></code>, <code><a href="#topic+apc.plot">apc.plot</a></code>
</p>

<hr>
<h2 id='B.dk'>Births in Denmark by year and month of birth and sex</h2><span id='topic+B.dk'></span>

<h3>Description</h3>

<p>The number of live births as entered from printed publications from
Statistics Denmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(B.dk)</code></pre>


<h3>Format</h3>

<p>A data frame with 1248 observations on the following 4 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>Year of birth</p>
</dd>
<dt><code>month</code></dt><dd><p>Month of birth</p>
</dd>
<dt><code>m</code></dt><dd><p>Number of male births</p>
</dd>
<dt><code>f</code></dt><dd><p>Number of female births</p>
</dd>
</dl>



<h3>Details</h3>

<p>Division of births by month and sex is only avaialble for the years 1957&ndash;69
and 2002ff. For the remaining period, the total no. births in each month is
divided between the sexes so that the fraction of boys is equal to the overall
fraction for the years where the sex information is available.
</p>
<p>There is a break in the series at 1920, when Sonderjylland was joined to Denmark.
</p>


<h3>Source</h3>

<p>Statistiske Undersogelser nr. 19: Befolkningsudvikling og sundhedsforhold
1901-60, Copenhagen 1966.
Befolkningens bevaegelser 1957.
Befolkningens bevaegelser 1958.
...
Befolkningens bevaegelser 2003.
Befolkningens bevaegelser 2004.
Vital Statistics 2005.
Vital Statistics 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( B.dk )
str( B.dk )
attach( B.dk )
# Plot the no of births and the M/F-ratio
par( las=1, mar=c(4,4,2,4) )
matplot( year+(month-0.5)/12,
         cbind( m, f ),
         bty="n", col=c("blue","red"), lty=1, lwd=1, type="l",
         ylim=c(0,5000),
         xlab="Date of birth", ylab="" )
usr &lt;- par()$usr
mtext( "Monthly no. births in Denmark", side=3, adj=0, at=usr[1], line=1/1.6 )
text( usr[1:2] %*% cbind(c(19,1),c(19,1))/20,
      usr[3:4] %*% cbind(c(1,19),c(2,18))/20, c("Boys","Girls"), col=c("blue","red"), adj=0 ) 
lines( year+(month-0.5)/12, (m/(m+f)-0.5)*30000, lwd=1 )
axis( side=4, at=(seq(0.505,0.525,0.005)-0.5)*30000, labels=c("","","","",""), tcl=-0.3 )
axis( side=4, at=(50:53/100-0.5)*30000, labels=50:53, tcl=-0.5 )
axis( side=4, at=(0.54-0.5)*30000, labels="% boys", tick=FALSE, mgp=c(3,0.1,0) )
abline( v=1920, col=gray(0.8) )
</code></pre>

<hr>
<h2 id='bdendo'>A case-control study of endometrial cancer</h2><span id='topic+bdendo'></span><span id='topic+bdendo11'></span>

<h3>Description</h3>

<p>The <code>bdendo</code> data frame has 315 rows and 13 columns,
<code>bdendo11</code> 126 rows.  These data concern a study in which each case
of endometrial cancer was matched with 4 controls. <code>bdendo11</code> is a
1:1 mathed subset of <code>bdendo</code>. Matching was by date of birth
(within one year), marital status, and residence.
</p>


<h3>Format</h3>

<p>These data frames have the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>set</code>: </td><td style="text-align: left;"> Case-control set: a numeric vector  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>d</code>: </td><td style="text-align: left;"> Case or control: a numeric vector (1=case, 0=control) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>gall</code>: </td><td style="text-align: left;"> Gall bladder disease: a factor with levels
                  <code>No</code> 
                  <code>Yes</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>hyp</code>: </td><td style="text-align: left;"> Hypertension: a factor with levels
                 <code>No</code> 
                 <code>Yes</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>ob</code>: </td><td style="text-align: left;"> Obesity: a factor with levels
                <code>No</code> 
                <code>Yes</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>est</code>: </td><td style="text-align: left;"> A factor with levels
                 <code>No</code> 
                 <code>Yes</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dur</code>: </td><td style="text-align: left;"> Duration of conjugated oestrogen therapy: a factor with levels
                 <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>non</code>: </td><td style="text-align: left;"> Use of non oestrogen drugs: a factor with levels
                 <code>No</code> 
                 <code>Yes</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>duration</code>: </td><td style="text-align: left;"> Months of oestrogen therapy: a numeric vector.  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>age</code>: </td><td style="text-align: left;"> A numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>cest</code>: </td><td style="text-align: left;"> Conjugated oestrogen dose: a factor with levels
<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>agegrp</code>: </td><td style="text-align: left;"> A factor with levels
                    <code>55-59</code> 
                    <code>60-64</code> 
                    <code>65-69</code> 
                    <code>70-74</code> 
                    <code>75-79</code> 
                    <code>80-84</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>age3</code>: </td><td style="text-align: left;"> a factor with levels
                  <code>&lt;64</code> 
                  <code>65-74</code> 
                  <code>75+</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Breslow NE, and Day N, Statistical Methods in Cancer Research. Volume
I: The Analysis of Case-Control Studies. IARC Scientific
Publications, IARC:Lyon, 1980.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bdendo)
str(bdendo)
</code></pre>

<hr>
<h2 id='births'>Births in a London Hospital</h2><span id='topic+births'></span>

<h3>Description</h3>

<p>Data from 500 singleton births in a London Hospital
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(births)</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 8 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>id</code>: </td><td style="text-align: left;"> Identity number for mother and baby. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>bweight</code>: </td><td style="text-align: left;"> Birth weight of baby. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>lowbw</code>: </td><td style="text-align: left;"> Indicator for birth weight less than 2500 g. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>gestwks</code>: </td><td style="text-align: left;"> Gestation period. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>preterm</code>: </td><td style="text-align: left;"> Indicator for gestation period less than 37 weeks. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>matage</code>: </td><td style="text-align: left;"> Maternal age. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>hyp</code>: </td><td style="text-align: left;"> Indicator for maternal hypertension. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>sex</code>: </td><td style="text-align: left;"> Sex of baby: 1:Male, 2:Female. </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Anonymous
</p>


<h3>References</h3>

<p>Michael Hills and Bianca De Stavola (2002). A Short Introduction to
Stata 8 for Biostatistics, Timberlake Consultants Ltd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(births)
</code></pre>

<hr>
<h2 id='blcaIT'>Bladder cancer mortality in Italian males</h2><span id='topic+blcaIT'></span>

<h3>Description</h3>

<p>Number of deaths from bladder cancer and person-years in the Italian
male population 1955&ndash;1979, in ages 25&ndash;79.
</p>


<h3>Format</h3>

<p>A data frame with 55 observations on the following 4 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>age</code>:    </td><td style="text-align: left;"> Age at death. Left endpoint of age class </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>period</code>: </td><td style="text-align: left;"> Period of death. Left endpoint of period </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>D</code>:      </td><td style="text-align: left;"> Number of deaths </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Y</code>:      </td><td style="text-align: left;"> Number of person-years.
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>data(blcaIT)
</code></pre>

<hr>
<h2 id='bootLexis'>
Create a bootstrap sample of persons (as identified by <code>lex.id</code>) from a Lexis object 
</h2><span id='topic+nid'></span><span id='topic+nid.Lexis'></span><span id='topic+bootLexis'></span>

<h3>Description</h3>

<p><code>lex.id</code> is the person identifier in a <code><a href="#topic+Lexis">Lexis</a></code>
object. This is used to sample persons from a Lexis object. If a person
is sampled, all records from this persons is transported to the
bootstrap sample. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nid( Lx, ... )
## S3 method for class 'Lexis'
nid( Lx, by=NULL, ... )
bootLexis( Lx, size = NULL, by = NULL, replace=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootLexis_+3A_lx">Lx</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="bootLexis_+3A_...">...</code></td>
<td>
<p>Parameters passed on to other methods.</p>
</td></tr>
<tr><td><code id="bootLexis_+3A_size">size</code></td>
<td>
<p>Numeric. How many persons should be sampled from the
<code>Lexis</code> object. Defaults to the number of persons in the
<code>Lx</code>, or, if <code>by</code> is given, to the number of persons in
each level of <code>by</code>. If <code>by</code> is given, <code>size</code> can have length
<code>length(unique(by))</code>, to indicate how many are sampled from
each level of <code>by</code>.</p>
</td></tr>  
<tr><td><code id="bootLexis_+3A_by">by</code></td>
<td>
<p>Character. Name of a variable (converted to factor) in the
<code>Lexis</code> object.
</p>
<p>Bootstrap sampling is done within each level of by.
</p>
<p>Calculation of the number of persons (<code>lex.id</code>) is done within
each level of <code>by</code>, and a vector returned.
</p>
</td></tr>
<tr><td><code id="bootLexis_+3A_replace">replace</code></td>
<td>
<p>Should persons be sampled by replacement? Default is
<code>TRUE</code>. Setting <code>replace</code> to <code>FALSE</code> enables
selecting a random subset of persons from the Lexis object.</p>
</td></tr>
</table>


<h3>Value</h3>

  
<p><code>bootLexis</code> returns a Lexis object of the same structure as the
input, with <em>persons</em> bootstrapped. The variable <code>lex.id</code>
in the resulting <code>Lexis</code> object has values 1,2,... The original
values of <code>lex.id</code> from <code>Lx</code> are stored in the variable
<code>old.id</code>.
</p>
<p><code>nid</code> counts the number of persons in a Lexis object, possibly by
<code>by</code>. If <code>by</code> is given, a named vector is returned.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Relevel.Lexis">Relevel.Lexis</a></code>,<code><a href="#topic+subset.Lexis">subset.Lexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- data.frame( id = c("A", "B", "C"),
                 birth = c("1952-07-14", "1954-04-01", "1987-06-10"),
                 entry = c("1965-08-04", "1972-09-08", "1991-12-23"),
                  exit = c("1997-06-27", "1995-05-23", "1998-07-24"),
                  fail = c(1, 0, 1),
                   sex = c("M","F","M") )
# Convert to calendar years
for( i in 2:4 ) xcoh[,i] &lt;- cal.yr(xcoh[,i])
xcoh
Lcoh &lt;- Lexis( entry = list( per=entry ),
                exit = list( per=exit, age=exit-birth ),
         exit.status = fail,
                data = xcoh )
Lx &lt;- Lcoh[sample(1:3,10,replace=TRUE),]
Lx$per &lt;- Lx$per + runif(10,0,10)
Lx$lex.id &lt;- 1:10
Lx &lt;- splitLexis( Lx, breaks=0:10*10, "age" )
Lx
nid( Lx )
nid( Lx, by="sex" )
Lb &lt;- bootLexis( Lx )
head( Lb )
nid( bootLexis( Lx, size=7 ) )
Li &lt;- bootLexis( Lx, by="id" ) # superfluous
summary( Lx )
summary( Li )
L2 &lt;- bootLexis( Lx, by="sex", size=c(2,5) )
nid( L2, by="sex" )
summary( L2 )
</code></pre>

<hr>
<h2 id='boxes.MS'>
Draw boxes and arrows for illustration of multistate models.
</h2><span id='topic+tbox'></span><span id='topic+dbox'></span><span id='topic+fillarr'></span><span id='topic+boxarr'></span><span id='topic+boxes'></span><span id='topic+boxes.Lexis'></span><span id='topic+boxes.matrix'></span><span id='topic+boxes.MS'></span>

<h3>Description</h3>

<p>Boxes can be drawn with text (<code>tbox</code>) or a cross (<code>dbox</code>),
and arrows pointing between the boxes (<code>boxarr</code>) can be drawn
automatically not overlapping the boxes. The <code>boxes</code> method for
<code><a href="#topic+Lexis">Lexis</a></code> objects generates displays of states with
person-years and transitions with events or rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   tbox( txt, x, y, wd, ht,
         font=2, lwd=2,
         col.txt=par("fg"),
         col.border=par("fg"),
         col.bg="transparent" )
   dbox( x, y, wd, ht=wd,
         font=2, lwd=2, cwd=5,
         col.cross=par("fg"),
         col.border=par("fg"),
         col.bg="transparent"  )
   boxarr( b1, b2, offset=FALSE, pos=0.45, ... )
## S3 method for class 'Lexis'
boxes( obj,
                    boxpos = FALSE,
                     wmult = 1.20,
                     hmult = 1.20 + 0.85*(!show.Y),
                       cex = 1.40,
                    show   = inherits( obj, "Lexis" ),
                    show.Y = show,
                   scale.Y = 1,
                  digits.Y = 1,
                   show.BE = FALSE,
                    BE.sep = c("","","          ",""),
                    show.D = show,
                   scale.D = FALSE,
                  digits.D = as.numeric(as.logical(scale.D)),
                    show.R = show &amp; is.numeric(scale.R),
                   scale.R = 1,
                  digits.R = as.numeric(as.logical(scale.R)),
                    DR.sep = if( show.D ) c("\n(",")") else c("",""),
                     eq.wd = TRUE,
                     eq.ht = TRUE,
                        wd,
                        ht,
                    subset = NULL,
                   exclude = NULL,
                      font = 1,
                       lwd = 2,
                   col.txt = par("fg"),
                col.border = col.txt,
                    col.bg = "transparent",
                   col.arr = par("fg"),
                   lwd.arr = lwd,
                  font.arr = font,
                   pos.arr = 0.45,
                   txt.arr = NULL,
               col.txt.arr = col.arr,
                offset.arr = 2,
                             ... )
## S3 method for class 'matrix'
boxes( obj, ... )
## S3 method for class 'MS'
boxes( obj, sub.st, sub.tr, cex=1.5, ... )
   fillarr( x1, y1, x2, y2, gap=2, fr=0.8,
            angle=17, lwd=2, length=par("pin")[1]/30, ... )
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxes.MS_+3A_txt">txt</code></td>
<td>
<p>Text to be placed inside the box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_x">x</code></td>
<td>
<p>x-coordinate of center of box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_y">y</code></td>
<td>
<p>y-coordinate of center of box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_wd">wd</code></td>
<td>
<p>width of boxes in percentage of the plot width.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_ht">ht</code></td>
<td>
<p>height of boxes in percentage of the plot height.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_font">font</code></td>
<td>
<p>Font for the text. Defaults to 2 (=bold).</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the box borders.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.txt">col.txt</code></td>
<td>
<p>Color for the text in boxes.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.border">col.border</code></td>
<td>
<p>Color of the box border.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.bg">col.bg</code></td>
<td>
<p>Background color for the interior of the box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to the call of other functions.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_cwd">cwd</code></td>
<td>
<p>Width of the lines in the cross.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.cross">col.cross</code></td>
<td>
<p>Color of the cross.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_b1">b1</code></td>
<td>
<p>Coordinates of the &quot;from&quot; box. A vector with 4 components,
<code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_b2">b2</code></td>
<td>
<p>Coordinates of the &quot;to&quot; box; like <code>b1</code>.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_offset">offset</code></td>
<td>
<p>Logical. Should the arrow be offset a bit to the left.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_pos">pos</code></td>
<td>
<p>Numerical between 0 and 1, determines the position of the point
on the arrow which is returned.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object or a transition matrix; that
is a square matrix indexed by state in both dimensions, and the
<code class="reqn">(i,j)</code>th entry different from <code>NA</code> if a transition <code class="reqn">i</code>
to <code class="reqn">j</code> can occur. If <code>show.D=TRUE</code>, the arrows between
states are annotated by these numbers. If <code>show.Y=TRUE</code>, the
boxes representing states are annotated by the numbers in the
diagonal of <code>obj</code>.
</p>
<p>For <code>boxes.matrix</code> <code>obj</code> is a matrix and for
<code>boxes.MS</code>, <code>obj</code> is an <code>MS.boxes</code> object (see below).</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_boxpos">boxpos</code></td>
<td>
<p>If <code>TRUE</code> the boxes are positioned  equidistantly on a
circle, if <code>FALSE</code> (the default) you are queried to
click on the screen for the positions. This argument can also
be a named list with elements <code>x</code> and
<code>y</code>, both numerical vectors, giving the centers of
the boxes. These must be numbers between 0 and 100
indicating percentages of the display in the two directions.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_wmult">wmult</code></td>
<td>
<p>Multiplier for the width of the box relative to the width of the
text in the box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_hmult">hmult</code></td>
<td>
<p>Multiplier for the height of the box relative to the height of the
text in the box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_cex">cex</code></td>
<td>
<p>Character expansion for text in the box.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_show">show</code></td>
<td>
<p>Should person-years and transitions be put in the plot.
Ignored if <code>obj</code> is not a <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_show.y">show.Y</code></td>
<td>
<p>If logical: Should person-years be put in the boxes.
If numeric: Numbers to put in boxes.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_scale.y">scale.Y</code></td>
<td>
<p>What scale should be used for annotation of person-years.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_digits.y">digits.Y</code></td>
<td>
<p>How many digits after the decimal point should be used for the
person-years.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_show.be">show.BE</code></td>
<td>
<p>Logical. Should number of persons beginning
resp. ending follow up in each state be shown? If given as character
&quot;nz&quot; or &quot;noz&quot; the numbers will be shown, but zeros omitted.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_be.sep">BE.sep</code></td>
<td>
<p>Character vector of length 4, used for annotation of the
number of persons beginning and ending in each state: 1st element
precedes no. beginning, 2nd trails it, 3rd precedes the no. ending
(defaults to 8 spaces), and the 4th trails the no. ending.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_show.d">show.D</code></td>
<td>
<p>Should no. transitions be put alongside the arrows.
Ignored if <code>obj</code> is not a <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_scale.d">scale.D</code></td>
<td>
<p>Synonymous with <code>scale.R</code>, retained for compatibility.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_digits.d">digits.D</code></td>
<td>
<p>Synonymous with <code>digits.R</code>, retained for compatibility.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_show.r">show.R</code></td>
<td>
<p>Should the transition rates be shown on the arrows?</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_scale.r">scale.R</code></td>
<td>
<p>If this a scalar, rates instead of no. transitions are printed
at the arrows, scaled by <code>scale.R</code>.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_digits.r">digits.R</code></td>
<td>
<p>How many digits after the decimal point should be used for the
rates.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_dr.sep">DR.sep</code></td>
<td>
<p>Character vector of length 2. If rates are shown, the
first element is inserted before and the second after the rate.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_eq.wd">eq.wd</code></td>
<td>
<p>Should boxes all have the same width?</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_eq.ht">eq.ht</code></td>
<td>
<p>Should boxes all have the same height?</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_subset">subset</code></td>
<td>
<p>Draw only boxes and arrows for a subset of the states.
Can be given either as a numerical vector or character
vector state names.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_exclude">exclude</code></td>
<td>
<p>Exclude states from the plot. The complementary of <code>subset</code>.
Ignored if <code>subset</code> is given.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.arr">col.arr</code></td>
<td>
<p>Color of the arrows between boxes.
A vector of character strings, the arrows are referred to as the
row-wise sequence of non-NA elements of the transition matrix.
Thus the first ones refer to the transitions out of state 1, in
order of states.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_lwd.arr">lwd.arr</code></td>
<td>
<p>Line widths of the arrows.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_font.arr">font.arr</code></td>
<td>
<p>Font of the text annotation the arrows.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_pos.arr">pos.arr</code></td>
<td>
<p>Numerical between 0 and 1, determines the position on
the arrows where the text is written.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_txt.arr">txt.arr</code></td>
<td>
<p>Text put on the arrows.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_col.txt.arr">col.txt.arr</code></td>
<td>
<p>Colors for text on the arrows.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_offset.arr">offset.arr</code></td>
<td>
<p>The amount offset between arrows representing
two-way transitions, that is where there are arrows both ways
between two boxes.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_sub.st">sub.st</code></td>
<td>
<p>Subset of the states to be drawn.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_sub.tr">sub.tr</code></td>
<td>
<p>Subset of the transitions to be drawn.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_x1">x1</code></td>
<td>
<p>x-coordinate of the starting point.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_y1">y1</code></td>
<td>
<p>y-coordinate of the starting point.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_x2">x2</code></td>
<td>
<p>x-coordinate of the end point.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_y2">y2</code></td>
<td>
<p>y-coordinate of the end point.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_gap">gap</code></td>
<td>
<p>Length of the gap between the box and the ends of the arrows.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_fr">fr</code></td>
<td>
<p>Length of the arrow as the fraction of the distance between the
boxes. Ignored unless given explicitly, in which case any value
given for <code>gap</code> is ignored.</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_angle">angle</code></td>
<td>
<p>What angle should the arrow-head have?</p>
</td></tr>
<tr><td><code id="boxes.MS_+3A_length">length</code></td>
<td>
<p>Length of the arrow head in inches. Defaults to 1/30 of the
physical width of the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed to facilitate the drawing of multistate
models, mainly by automatic calculation of the arrows between boxes.
</p>
<p><code>tbox</code> draws a box with centered text, and returns a vector of
location, height and width of the box. This is used when drawing
arrows between boxes. <code>dbox</code> draws a box with a cross,
symbolizing a death state. <code>boxarr</code> draws an arrow between two
boxes, making sure it does not intersect the boxes. Only straight
lines are drawn.
</p>
<p><code>boxes.Lexis</code> takes as input a Lexis object sets up an empty plot
area (with axes 0 to 100 in both directions) and if
<code>boxpos=FALSE</code> (the default) prompts you to click on the
locations for the state boxes, and then draws arrows implied by the
actual transitions in the <code>Lexis</code> object. The default is to
annotate the transitions with the number of transitions.
</p>
<p>A transition matrix can also be supplied, in which case the row/column
names are used as state names, diagonal elements taken as
person-years, and off-diagonal elements as number of transitions.
This also works for <code>boxes.matrix</code>.
</p>
<p>Optionally returns the R-code reproducing the plot in a file, which
can be useful if you want to produce exactly the same plot with
differing arrow colors etc.
</p>
<p><code>boxarr</code> draws an arrow between two boxes, on the line connecting
the two box centers. The <code>offset</code> argument is used to offset the
arrow a bit to the left (as seen in the direction of the arrow) on order
to accommodate arrows both ways between boxes. <code>boxarr</code> returns a named
list with elements <code>x</code>, <code>y</code> and <code>d</code>, where the two former
give the location of a point on the arrow used for printing (see argument
<code>pos</code>) and the latter is a unit vector in the
direction of the arrow, which is used by <code>boxes.Lexis</code> to
position the annotation of arrows with the number of transitions.
</p>
<p><code>boxes.MS</code> re-draws what <code>boxes.Lexis</code> has done based on the
object of class <code>MS</code> produced by <code>boxes.Lexis</code>. The point
being that the <code>MS</code> object is easily modifiable, and thus it is a
machinery to make variations of the plot with different color
annotations etc.
</p>
<p><code>fill.arr</code> is just a utility drawing nicer arrows than the default
<code><a href="graphics.html#topic+arrows">arrows</a></code> command, basically by using filled arrow-heads; called
by <code>boxarr</code>.
</p>


<h3>Value</h3>

<p>The functions <code>tbox</code> and <code>dbox</code> return the location and
dimension of the boxes, <code>c(x,y,w,h)</code>, which are designed to be used
as input to the <code>boxarr</code> function.
</p>
<p>The <code>boxarr</code> function returns the coordinates (as a named
list with names <code>x</code> and <code>y</code>) of a point on the
arrow, designated to be used for annotation of the arrow.
</p>
<p>The function <code>boxes.Lexis</code> returns an <code>MS</code> object, a list with
five elements: 1) <code>Boxes</code> - a data frame with one row
per box and columns
<code>xx</code>,
<code>yy</code>,
<code>wd</code>,
<code>ht</code>,
<code>font</code>,
<code>lwd</code>,
<code>col.txt</code>,
<code>col.border</code> and
<code>col.bg</code>,
2) an object <code>State.names</code> with names of states (possibly an
expression, hence not possible to include as a column in <code>Boxes</code>),
3) a matrix <code>Tmat</code>, the transition matrix, 4) a data
frame, <code>Arrows</code> with one row per transition and columns:
<code>lwd.arr</code>,
<code>col.arr</code>,
<code>pos.arr</code>,
<code>col.txt.arr</code>,
<code>font.arr</code> and
<code>offset.arr</code> and
5) an object <code>Arrowtext</code> with names of states (possibly an
expression, hence not possible to include as a column in
<code>Arrows</code>)
</p>
<p>An <code>MS</code> object is used as input to
<code>boxes.MS</code>, the primary use is to modify selected entries in
the <code>MS</code> object first, e.g. colors, or supply
sub-setting arguments in order to produce displays that have the
same structure, but with different colors etc.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="#topic+tmat.Lexis">tmat.Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par( mar=c(0,0,0,0), cex=1.5 )
plot( NA,
      bty="n",
      xlim=0:1*100, ylim=0:1*100, xaxt="n", yaxt="n", xlab="", ylab="" )
bw  &lt;- tbox( "Well"    , 10, 60, 22, 10, col.txt="blue" )
bo  &lt;- tbox( "other Ca", 45, 80, 22, 10, col.txt="gray" )
bc  &lt;- tbox( "Ca"      , 45, 60, 22, 10, col.txt="red" )
bd  &lt;- tbox( "DM"      , 45, 40, 22, 10, col.txt="blue" )
bcd &lt;- tbox( "Ca + DM" , 80, 60, 22, 10, col.txt="gray" )
bdc &lt;- tbox( "DM + Ca" , 80, 40, 22, 10, col.txt="red" )
      boxarr( bw, bo , col=gray(0.7), lwd=3 )
# Note the argument adj= can takes values outside (0,1)
text( boxarr( bw, bc , col="blue", lwd=3 ),
      expression( lambda[Well] ), col="blue", adj=c(1,-0.2), cex=0.8 )
      boxarr( bw, bd , col=gray(0.7) , lwd=3 )
      boxarr( bc, bcd, col=gray(0.7) , lwd=3 )
text( boxarr( bd, bdc, col="blue", lwd=3 ),
      expression( lambda[DM] ), col="blue", adj=c(1.1,-0.2), cex=0.8 )

# Set up a transition matrix allowing recovery
tm &lt;- rbind( c(NA,1,1), c(1,NA,1), c(NA,NA,NA) )
rownames(tm) &lt;- colnames(tm) &lt;- c("Cancer","Recurrence","Dead")
tm
boxes.matrix( tm, boxpos=TRUE )

# Illustrate texting of arrows
boxes.Lexis( tm, boxpos=TRUE, txt.arr=c("en","to","tre","fire") )
zz &lt;- boxes( tm, boxpos=TRUE, txt.arr=c(expression(lambda[C]),
                                        expression(mu[C]),
                                        "recovery",
                                        expression(mu[R]) ) )

# Change color of a box
zz$Boxes[3,c("col.bg","col.border")] &lt;- "green"
boxes( zz )

# Set up a Lexis object
data(DMlate)
str(DMlate)
dml &lt;- Lexis( entry=list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit=list(Per=dox),
        exit.status=factor(!is.na(dodth),labels=c("DM","Dead")),
               data=DMlate[1:1000,] )

# Cut follow-up at Insulin
dmi &lt;- cutLexis( dml, cut=dml$doins, new.state="Ins", pre="DM" )
summary( dmi )
boxes( dmi, boxpos=TRUE )
boxes( dmi, boxpos=TRUE, show.BE=TRUE )
boxes( dmi, boxpos=TRUE, show.BE="nz" )
boxes( dmi, boxpos=TRUE, show.BE="nz", BE.sep=c("In:","      Out:","") )

# Set up a bogus recovery date just to illustrate two-way transitions
dmi$dorec &lt;- dmi$doins + runif(nrow(dmi),0.5,10)
dmi$dorec[dmi$dorec&gt;dmi$dox] &lt;- NA
dmR &lt;- cutLexis( dmi, cut=dmi$dorec, new.state="DM", pre="Ins" )
summary( dmR )
boxes( dmR, boxpos=TRUE )
boxes( dmR, boxpos=TRUE, show.D=FALSE )
boxes( dmR, boxpos=TRUE, show.D=FALSE, show.Y=FALSE )
boxes( dmR, boxpos=TRUE, scale.R=1000 )
MSobj &lt;- boxes( dmR, boxpos=TRUE, scale.R=1000, show.D=FALSE )
MSobj &lt;- boxes( dmR, boxpos=TRUE, scale.R=1000, DR.sep=c(" (",")") )
class( MSobj )
boxes( MSobj )
MSobj$Boxes[1,c("col.txt","col.border")] &lt;- "red"
MSobj$Arrows[1:2,"col.arr"] &lt;- "red"
boxes( MSobj )
    </code></pre>

<hr>
<h2 id='BrCa'>Clinical status,
relapse, metastasis and death in 2982 women with breast cancer.
</h2><span id='topic+BrCa'></span>

<h3>Description</h3>

<p>This dataset is a transformation of the example dataset used by Crowther
and Lambert in their multistate paper.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BrCa)</code></pre>


<h3>Format</h3>

<p>A data frame with 2982 observations on the following 17 variables:
</p>

<dl>
<dt><code>pid</code></dt><dd><p>Person-id; numeric</p>
</dd>
<dt><code>year</code></dt><dd><p>Calendar year of diagnosis</p>
</dd>
<dt><code>age</code></dt><dd><p>Age at diagnosis</p>
</dd>
<dt><code>meno</code></dt><dd><p>Menopausal status; a factor with levels <code>pre</code> <code>post</code></p>
</dd>
<dt><code>size</code></dt><dd><p>Tumour size; a factor with levels <code>&lt;=20 mm</code> <code>&gt;20-50 mm</code> <code>&gt;50 mm</code></p>
</dd>
<dt><code>grade</code></dt><dd><p>Tumour grade; a factor with levels <code>2</code> <code>3</code></p>
</dd>
<dt><code>nodes</code></dt><dd><p>Number of positive lymph nodes, a numeric vector</p>
</dd>
<dt><code>pr</code></dt><dd><p>Progesteron receptor level</p>
</dd>
<dt><code>pr.tr</code></dt><dd><p>Transformed progesteron level</p>
</dd>
<dt><code>er</code></dt><dd><p>Estrogen receptor level</p>
</dd>
<dt><code>hormon</code></dt><dd><p>Hormon therapy at diagnosis; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>chemo</code></dt><dd><p>Chemotherapy treatment; a factor with levels <code>no</code> <code>yes</code></p>
</dd>
<dt><code>tor</code></dt><dd><p>Time of relapse, years since diagnosis</p>
</dd>
<dt><code>tom</code></dt><dd><p>Time of metastasis, years since diagnosis</p>
</dd>
<dt><code>tod</code></dt><dd><p>Time of death, years since diagnosis</p>
</dd>
<dt><code>tox</code></dt><dd><p>Time of exit from study, years since diagnosis</p>
</dd>
<dt><code>xst</code></dt><dd><p>Vital status at exit; a factor with levels <code>Alive</code> <code>Dead</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset has been modified to contain the times (since diagnosis) of the events of
interest, to comply with the usual structure of data.
</p>


<h3>Source</h3>

<p>The original data were extracted from:
<a href="http://fmwww.bc.edu/repec/bocode/m/multistate_example.dta">http://fmwww.bc.edu/repec/bocode/m/multistate_example.dta</a>, this
is modified representation of the same amount of information.
</p>


<h3>References</h3>

<p>The data were used as example in the paper by Crowther and
Lambert: Parametric multistate survival models: Flexible
modelling allowing transition-specific distributions with application
to estimating clinically useful measures of effect differences; Stat
Med 36 (29), pp 4719-4742, 2017. (No, it is not the paper, just the
title.) 
</p>
<p>A parallel analysis using the <code><a href="#topic+Lexis">Lexis</a></code> machinery is available
as: <a href="http://bendixcarstensen.com/AdvCoh/papers/bcMS.pdf">http://bendixcarstensen.com/AdvCoh/papers/bcMS.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BrCa)
</code></pre>

<hr>
<h2 id='brv'>Bereavement in an elderly cohort</h2><span id='topic+brv'></span>

<h3>Description</h3>

<p>The <code>brv</code> data frame has 399 rows and 11 columns.
The data concern the possible effect of marital bereavement on
subsequent mortality. They arose from a survey of the physical and
mental health of a cohort of 75-year-olds in one large general
practice. These data concern mortality up to 1 January, 1990 (although
further follow-up has now taken place).
</p>
<p>Subjects included all lived with a living spouse when they entered the
study. There are three distinct groups of such subjects: (1) those in
which both members of the couple were over 75 and therefore included in
the cohort, (2) those whose spouse was below 75 (and was not, therefore,
part of the main cohort study), and (3) those living in larger
households (that is, not just with their spouse).
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>
  
<dl>
<dt><code>id</code></dt><dd><p>subject identifier, a numeric vector</p>
</dd>
<dt><code>couple</code></dt><dd><p>couple identifier, a numeric vector</p>
</dd>
<dt><code>dob</code></dt><dd><p>date of birth, a date</p>
</dd>
<dt><code>doe</code></dt><dd><p>date of entry into follow-up study, a date</p>
</dd>
<dt><code>dox</code></dt><dd><p>date of exit from follow-up study, a date</p>
</dd>
<dt><code>dosp</code></dt><dd><p>date of death of spouse, a date (if the spouse was still alive
at the end of follow-up,this was coded to January 1, 2000)</p>
</dd>
<dt><code>fail</code></dt><dd><p>status at end of follow-up,
a numeric vector (0=alive,1=dead)</p>
</dd>
<dt><code>group</code></dt><dd><p>see Description, a numeric vector</p>
</dd>
<dt><code>disab</code></dt><dd><p>disability score, a numeric vector</p>
</dd>
<dt><code>health</code></dt><dd><p>perceived health status score, a numeric vector</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels
<code>Male</code> and
<code>Female</code> </p>
</dd>
</dl>



<h3>Source</h3>

<p>Jagger C, and Sutton CJ, Death after Marital Bereavement. Statistics in
Medicine, 10:395-404, 1991. (Data supplied by Carol Jagger).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brv)
</code></pre>

<hr>
<h2 id='cal.yr'>
Functions to convert character, factor and various date objects into a number,
and vice versa.
</h2><span id='topic+cal.yr'></span><span id='topic+as.Date.cal.yr'></span>

<h3>Description</h3>

<p>Dates are converted to a numerical value, giving the calendar year as
a fractional number. 1 January 1970 is converted to 1970.0, and other
dates are converted by assuming that years are all 365.25 days long,
so inaccuracies may arise, for example, 1 Jan 2000 is converted to
1999.999. Differences between converted values will be 1/365.25 of the
difference between corresponding <code><a href="base.html#topic+Date">Date</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cal.yr( x, format="%Y-%m-%d", wh=NULL )
  ## S3 method for class 'cal.yr'
as.Date( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal.yr_+3A_x">x</code></td>
<td>
<p>A factor or character vector, representing a date in format
<code>format</code>, or an object of class
<code><a href="base.html#topic+Date">Date</a></code>,
<code><a href="base.html#topic+POSIXlt">POSIXlt</a></code>,
<code><a href="base.html#topic+POSIXct">POSIXct</a></code>,
<code><a href="base.html#topic+date">date</a></code>,
<code>dates</code> or
<code>chron</code> (the latter two requires the <code>chron</code> package).
If <code>x</code> is a data frame, all variables in the data-frame
which are of one the classes mentioned are converted to class <code>cal.yr</code>.
See arguemt <code>wh</code>, though.</p>
</td></tr>
<tr><td><code id="cal.yr_+3A_format">format</code></td>
<td>
<p>Format of the date values if <code>x</code> is factor or character.
If this argument is supplied and <code>x</code> is a datafame, all
character variables are converted to class <code>cal.yr</code>.
Factors in the dataframe will be ignored.</p>
</td></tr>
<tr><td><code id="cal.yr_+3A_wh">wh</code></td>
<td>
<p>Indices of the variables to convert if <code>x</code> is a data frame.
Can be either a numerical or character vector.</p>
</td></tr>
<tr><td><code id="cal.yr_+3A_...">...</code></td>
<td>
<p>Arguments passed on from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cal.yr</code> returns a numerical vector of the same length as
<code>x</code>, of class <code>c("cal.yr","numeric")</code>. If <code>x</code> is a data frame
a dataframe with some of the columns converted to class <code>"cal.yr"</code> is
returned.
</p>
<p><code>as.Date.cal.yr</code> returns a <code><a href="base.html#topic+Date">Date</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center &amp; Dept. of Biostatistics,
University of Copenhagen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>,
<code><a href="base.html#topic+Date">Date</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Character vector of dates:
 birth &lt;- c("14/07/1852","01/04/1954","10/06/1987","16/05/1990",
            "12/11/1980","01/01/1997","01/01/1998","01/01/1999")
 # Proper conversion to class "Date":
 birth.dat &lt;- as.Date( birth, format="%d/%m/%Y" )
 # Converson of character to class "cal.yr"
 bt.yr &lt;- cal.yr( birth, format="%d/%m/%Y" )
 # Back to class "Date":
 bt.dat &lt;- as.Date( bt.yr )
 # Numerical calculation of days since 1.1.1970:
 days &lt;- Days &lt;- (bt.yr-1970)*365.25
 # Blunt assignment of class:
 class( Days ) &lt;- "Date"
 # Then data.frame() to get readable output of results:
 data.frame( birth, birth.dat, bt.yr, bt.dat, days, Days, round(Days) )
</code></pre>

<hr>
<h2 id='cbind.Lexis'>Combining a Lexis objects with data frames or other Lexis objects 
</h2><span id='topic+cbind.Lexis'></span><span id='topic+rbind.Lexis'></span>

<h3>Description</h3>

<p>A Lexis object may be combined side-by-side with
data frames. Or several Lexis objects may stacked, possibly increasing
the number of states and time scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
cbind(...)
## S3 method for class 'Lexis'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.Lexis_+3A_...">...</code></td>
<td>
<p>For <code>cbind</code> a sequence of data frames or vectors of
which exactly one has class <code>Lexis</code>. For <code>rbind</code> a sequence
of Lexis objects, supposedly representing follow-up in the same
population.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments to <code>rbind.Lexis</code> must all be <code><a href="#topic+Lexis">Lexis</a></code>
objects; except for possible NULL objects. The timescales in the
resulting object will be the union of all timescales present in all
arguments. Values of timescales not present in a contributing Lexis
object will be set to <code>NA</code>. The <code>breaks</code> for a given time
scale will be <code>NULL</code> if the <code>breaks</code> of the same time scale
from two contributing Lexis objects are different.
</p>
<p>The arguments to <code>cbind.Lexis</code> must consist of at most one Lexis
object, so the method is intended for amending a Lexis object with
extra columns without losing the Lexis-specific attributes.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object. <code>rbind</code> renders a <code>Lexis</code>
object with timescales equal to the union of timescales in the
arguments supplied. Values of a given timescale are set to <code>NA</code>
for rows corresponding to supplied objects. <code>cbind</code> basically
just adds columns to an existing Lexis object.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset.Lexis">subset.Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- structure( list( id = c("A", "B", "C"),
                      birth = c("14/07/1952", "01/04/1954", "10/06/1987"),
                      entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                       exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                       fail = c(1, 0, 1) ),
                     .Names = c("id", "birth", "entry", "exit", "fail"),
                  row.names = c("1", "2", "3"),
                      class = "data.frame" )

# Convert the character dates into numerical variables (fractional years)
xcoh &lt;- cal.yr( xcoh, format="%d/%m/%Y", wh=2:4 )
# See how it looks
xcoh
str( xcoh )

# Define as Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis( entry = list( per=entry ),
                exit = list( per=exit, age=exit-birth ),
         exit.status = fail,
                data = xcoh )
Lcoh
cbind( Lcoh, zz=3:5 )

# Lexis object wit time since entry time scale
Dcoh &lt;- Lexis( entry = list( per=entry, tfe=0 ),
                exit = list( per=exit ),
         exit.status = fail,
                data = xcoh )
# A bit meningless to combie these two, really...
rbind( Dcoh, Lcoh )

# Split different places
sL &lt;- splitLexis( Lcoh, time.scale="age", breaks=0:20*5 )
sD &lt;- splitLexis( Dcoh, time.scale="tfe", breaks=0:50*2 )
sDL &lt;- rbind( sD, sL )
</code></pre>

<hr>
<h2 id='ccwc'>Generate a nested case-control study</h2><span id='topic+ccwc'></span>

<h3>Description</h3>

<p>Given the basic outcome variables for a cohort study: the time of entry
to the cohort, the time of exit and the reason for exit (&quot;failure&quot; or
&quot;censoring&quot;), this function computes risk sets and generates a matched
case-control study in which each case is compared with a set of controls
randomly sampled from the appropriate risk set. Other variables may be
matched when selecting controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccwc( entry=0, exit, fail, origin=0, controls=1, match=list(),
      include=list(), data=NULL, silent=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccwc_+3A_entry">entry</code></td>
<td>

<p>Time of entry to follow-up
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_exit">exit</code></td>
<td>

<p>Time of exit from follow-up
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_fail">fail</code></td>
<td>

<p>Status on exit (1=Fail, 0=Censored)
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_origin">origin</code></td>
<td>

<p>Origin of analysis time scale
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_controls">controls</code></td>
<td>

<p>The number of controls to be selected for each case
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_match">match</code></td>
<td>

<p>List of categorical variables on which to match cases and controls
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_include">include</code></td>
<td>

<p>List of other variables to be carried across into the case-control
study
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_data">data</code></td>
<td>

<p>Data frame in which to look for input variables
</p>
</td></tr>
<tr><td><code id="ccwc_+3A_silent">silent</code></td>
<td>

<p>If FALSE, echos a . to the screen for each case-control set
created; otherwise produces no output.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The case-control study, as a  dataframe containing:
</p>
<table>
<tr><td><code>Set</code></td>
<td>

<p>case-control set number
</p>
</td></tr>
<tr><td><code>Map</code></td>
<td>

<p>row number of record in input dataframe
</p>
</td></tr>
<tr><td><code>Time</code></td>
<td>

<p>failure time of the case in this set
</p>
</td></tr>
<tr><td><code>Fail</code></td>
<td>

<p>failure status (1=case, 0=control)
</p>
</td></tr>
</table>
<p>These are followed by the matching variables, and finally by the
variables in the <code>include</code> list
</p>


<h3>Author(s)</h3>

<p>David Clayton
</p>


<h3>References</h3>

<p>Clayton and Hills, Statistical Models in Epidemiology, Oxford
University Press, Oxford:1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# For the diet and heart dataset, create a nested case-control study
# using the age scale and matching on job
#
data(diet)
dietcc &lt;- ccwc( doe, dox, chd, origin=dob, controls=2, data=diet,
                include=energy, match=job)
</code></pre>

<hr>
<h2 id='ci.Crisk'>
Compute cumulative risks and expected sojourn times from models for
cause-specific rates.  
</h2><span id='topic+ci.Crisk'></span>

<h3>Description</h3>

<p>Consider a list of parametric models for rates of competing events, such
as different causes of death, A, B, C, say. From estimates of the
cause-specific rates we can compute 1) the cumulative risk of being in
each state ('Surv' (=no event) and A, B and C) at different times, 2)
the stacked cumulative rates such as A, A+C, A+C+Surv and 3) the
expected (truncated) sojourn times in each state up to each time point.
</p>
<p>This can be done by simple numerical integration using estimates from
models for the cause specific rates. But the standard errors of the
results are analytically intractable.
</p>
<p>The function <code>ci.Crisk</code> computes estimates with confidence
intervals using simulated samples from the parameter vectors of supplied
model objects. Some call this a parametric bootstrap.
</p>
<p>The times and other covariates determining the cause-specific rates must
be supplied in a data frame which will be used for predicting rates for
all transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.Crisk(mods,
           nd,
         tnam = names(nd)[1],
           nB = 1000,
         perm = length(mods):0 + 1,
        alpha = 0.05, 
      sim.res = 'none')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.Crisk_+3A_mods">mods</code></td>
<td>
<p>A named list of <code>glm</code>/<code>gam</code> model objects
representing the cause-specific rates. If the list is not named the
function will crash. The names will be used as names for the states
(competing risks), while the state without any event will be called
&quot;<code>Surv</code>&quot;.
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_nd">nd</code></td>
<td>
<p>A data frame of prediction points and covariates to be used
on all models supplied in <code>mods</code>. 
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_tnam">tnam</code></td>
<td>
<p>Name of the column in <code>nd</code> which is the time scale.It
must represent endpoints of equidistant intervals.
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_nb">nB</code></td>
<td>
<p>Scalar. The number of simulations from the (posterior)
distribution of the model parameters to be used in computing
confidence limits.  
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_perm">perm</code></td>
<td>
<p>Numerical vector of length <code>length(mods)+1</code> indicating
the order in which states are to be stacked. The <code>'Surv'</code> state
is taken to be the first, the remaining in the reverse order supplied
in the <code>mods</code> argument. The default is therefore to stack with
the survival as the first, which may not be what you normally want.   
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_alpha">alpha</code></td>
<td>
<p>numeric. 1 minus the confidence level used in calculating
the c.i.s 
</p>
</td></tr>
<tr><td><code id="ci.Crisk_+3A_sim.res">sim.res</code></td>
<td>
<p>Character. What simulation samples should be
returned. If <code>'none'</code> (the default) the function returns a list
of 3 arrays (see under 'value'). If <code>'rates'</code> it returns an
array of dimension <code>nrow(nd)</code> x <code>length(mod)</code> x <code>nB</code>
of bootstrap samples of the rates. If <code>'crisk'</code> it returns an
array of dimension <code>nrow(nd)</code> x <code>length(mod)+1</code> x
<code>nB</code> of bootstrap samples of the cumulative rates.  Only the
first letter matters, regardless of whether it is in upper lower
case.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>If <code>sim.res='none'</code> a named list with 4 components, the first 3
are 3-way arrays classified by time, state and estimate/confidence
interval:  
</p>

<ul>
<li> <p><code>Crisk</code> Cumulative risks for the <code>length(mods)</code>
events <em>and</em> the survival
</p>
</li>
<li> <p><code>Srisk</code> Stacked versions of the cumulative risks
</p>
</li>
<li> <p><code>Stime</code> Sojourn times in each states
</p>
</li>
<li> <p><code>time</code> Endpoints of intervals. It is just the numerical
version of the names of the first dimension of the three arrays
</p>
</li></ul>

<p>All three arrays have (almost) the same dimensions:
</p>

<ul>
<li><p> time, named as <code>tnam</code>; endpoints of intervals. Length
<code>nrow(nd)</code>.
</p>
</li>
<li> <p><code>cause</code>. The arrays <code>Crisk</code> and <code>Stime</code> have
values &quot;<code>Surv</code>&quot; plus the names of the list <code>mods</code> (first
argument). <code>Srisk</code> has length <code>length(mod)</code>, with each
level representing a cumulative sum of cumulative risks, in order
indicated by the <code>perm</code> argument.
</p>
</li>
<li><p> Unnamed, <code>ci.50%</code>, <code>ci.2.5%</code>, <code>ci.97.5%</code>
representing quantiles of the quantities derived from the bootstrap
samples. If <code>alpha</code> is different from 0.05, names are of course
different.
</p>
</li></ul>

<p>If <code>sim.res='rates'</code> the function returns bootstrap samples of
rates for each cause as an array
classified by time, cause and bootstrap sample.
</p>
<p>If <code>sim.res='crisk'</code> the function returns bootstrap samples of
cumulative risks for each cause (including survival) as an array
classified by time, state (= causes + surv) and bootstrap sample.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2pol">mat2pol</a></code>
<code><a href="#topic+simLexis">simLexis</a></code>
<code><a href="#topic+plotCIF">plotCIF</a></code>
<code><a href="#topic+ci.surv">ci.surv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Epi)
data(DMlate)

# A Lexis object for survival
Ldm &lt;- Lexis(entry = list( per = dodm,
                           age = dodm-dobth, 
                           tfd = 0 ),
              exit = list( per = dox ),
       exit.status = factor( !is.na(dodth), labels = c("DM","Dead") ),
              data = DMlate[sample(1:nrow(DMlate),1000),] )
summary(Ldm, timeScales = TRUE)

# Cut at OAD and Ins times
Mdm &lt;- mcutLexis(Ldm,
                  wh = c('dooad','doins'),
          new.states = c('OAD','Ins'),
          seq.states = FALSE,
                ties = TRUE)
summary(Mdm$lex.dur)

# restrict to DM state and split
Sdm &lt;- splitLexis(factorize(subset(Mdm, lex.Cst == "DM")),
                  time.scale = "tfd",
                  breaks = seq(0,20,1/12))
summary(Sdm)
summary(Relevel(Sdm, c(1, 4, 2, 3)))

boxes(Relevel(Sdm, c(1, 4, 2, 3)), 
      boxpos = list(x = c(15, 85, 80, 15),
                    y = c(85, 85, 20, 15)),
      scale.R = 100)

# glm models for the cause-specific rates
system.time(
mD &lt;- glm.Lexis(Sdm, ~ Ns(tfd, knots=0:6*2), to = 'Dead') )
system.time(
mO &lt;- glm.Lexis(Sdm, ~ Ns(tfd, knots=0:6*2), to = 'OAD' ) )
system.time(
mI &lt;- glm.Lexis(Sdm, ~ Ns(tfd, knots=0:6*2), to = 'Ins' ) )

# intervals for calculation of predicted rates
int &lt;- 1 / 100
nd &lt;- data.frame(tfd = seq(0, 10, int)) # not the same as the split, 
                                        # and totally unrelated to it

# cumulaive risks with confidence intervals
# (too few timepoints, too few simluations)
system.time(
res &lt;- ci.Crisk(list(OAD = mO, 
                     Ins = mI, 
                    Dead = mD),
                            nd = data.frame(tfd = 0:100 / 10),
                            nB = 100,
                          perm = 4:1))
str(res)
</code></pre>

<hr>
<h2 id='ci.cum'> Compute cumulative sum of estimates. </h2><span id='topic+ci.cum'></span><span id='topic+ci.surv'></span>

<h3>Description</h3>

<p>Computes the cumulative sum of parameter functions and the
standard error of it. Used for computing the cumulative rate, or the
survival function based on a <code>glm</code> with parametric baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.cum( obj,
    ctr.mat = NULL,
     subset = NULL,
       intl = NULL,
      alpha = 0.05,
        Exp = TRUE,
     ci.Exp = FALSE,
     sample = FALSE )
ci.surv( obj,
    ctr.mat = NULL,
     subset = NULL,
       intl = NULL,
      alpha = 0.05,
        Exp = TRUE,
     sample = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.cum_+3A_obj">obj</code></td>
<td>
<p>A model object (of class <code>lm</code>, <code>glm</code>. </p>
</td></tr>
<tr><td><code id="ci.cum_+3A_ctr.mat">ctr.mat</code></td>
<td>
<p>Matrix or data frame.
</p>
<p>If <code>ctr.mat</code> is a matrix, it should be a contrast matrix to be
multiplied to the parameter vector, i.e. the desired linear function of
the parameters.
</p>
<p>If it is a data frame it should have columns corresponding to a
prediction data frame for <code>obj</code>, see details for
<code><a href="#topic+ci.lin">ci.lin</a></code>.</p>
</td></tr>
<tr><td><code id="ci.cum_+3A_subset">subset</code></td>
<td>
<p> Subset of the parameters of the model to which a matrix
<code>ctr.mat</code> should be applied. </p>
</td></tr>
<tr><td><code id="ci.cum_+3A_intl">intl</code></td>
<td>
<p> Interval length for the cumulation. Either a constant or a
numerical vector of length <code>nrow(ctr.mat)</code>. If omitted taken as
the difference between the two first elments if the first column in
<code>ctr.mat</code>, assuming that that holds the time scale. A note is
issued in this case.</p>
</td></tr> 
<tr><td><code id="ci.cum_+3A_alpha">alpha</code></td>
<td>
<p>Significance level used when computing confidence limits.</p>
</td></tr>
<tr><td><code id="ci.cum_+3A_exp">Exp</code></td>
<td>
<p>Should the parameter function be exponentiated before it is
cumulated?</p>
</td></tr>
<tr><td><code id="ci.cum_+3A_ci.exp">ci.Exp</code></td>
<td>
<p>Should the confidence limits for the cumulative rate be
computed on the log-scale, thus ensuring that exp(-cum.rate) is always
in [0,1]?</p>
</td></tr>
<tr><td><code id="ci.cum_+3A_sample">sample</code></td>
<td>
<p>Should a sample of the original parameters be used to
compute a cumulative rate?</p>
</td></tr>  </table>


<h3>Details</h3>

<p>The purpose of <code>ci.cum</code> is to the compute cumulative rate
(integrated intensity) at a set of points based on a model for the
rates. <code>ctr.mat</code> is a matrix which, when premultiplied to the
parameters of the model returns the (log)rates at a set of equidistant
time points. If log-rates are returned from the prediction method for
the model, the they should be exponentiated before cumulated, and the
variances computed accordingly. Since the primary use is for log-linear
Poisson models the <code>Exp</code> parameter defaults to TRUE.
</p>
<p>Each row in the object supplied via <code>ctr.mat</code> is assumed to
represent a midpoint of an interval. <code>ci.cum</code> will then return the
cumulative rates at the <em>end</em> of these intervals. <code>ci.surv</code>
will return the survival probability at the <em>start</em> of each of
these intervals, assuming the the first interval starts at 0 - the first
row of the result is <code>c(1,1,1)</code>.
</p>
<p>The <code>ci.Exp</code> argument ensures that the confidence intervals for the
cumulative rates are always positive, so that exp(-cum.rate) is always
in [0,1].
</p>


<h3>Value</h3>

<p>A matrix with 3 columns: Estimate, lower and upper c.i.  If
<code>sample</code> is TRUE, a single sampled vector is returned, if
<code>sample</code> is numeric a matrix with <code>sample</code> columns is
returned, each column a cumulative rate based on a random sample from
the distribution of the parameter estimates.
</p>
<p><code>ci.surv</code> returns a 3 column matrix with estimate, lower and
upper confidence bounds for the survival function.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ci.lin">ci.lin</a></code>, <code><a href="#topic+ci.pred">ci.pred</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Packages required for this example
library( splines )
library( survival )
data( lung )
par( mfrow=c(1,2) )

# Plot the Kaplan-meier-estimator
plot( survfit( Surv( time, status==2 ) ~ 1, data=lung ) )

# Declare data as Lexis
lungL &lt;- Lexis(exit = list(tfd=time),
               exit.status = (status == 2) * 1,
               data = lung)
summary(lungL)

# Split the follow-up every 10 days
sL &lt;- splitLexis(lungL, "tfd", breaks=seq(0,1100,10))
summary(sL)

# Fit a Poisson model with a natural spline for the effect of time (left
# end points of intervals are used as covariate)
mp &lt;- glm(cbind(lex.Xst == 1, lex.dur)
          ~ Ns(tfd,knots = c(0, 50, 100, 200, 400, 700)),
          family = poisreg,
            data = sL)

# mp is now a model for the rates along the time scale tfd
# prediction data frame for select time points on this time scale
nd &lt;- data.frame(tfd = seq(5,995,10)) # *midpoints* of intervals
Lambda &lt;- ci.cum ( mp, nd, intl=10 )
surv   &lt;- ci.surv( mp, nd, intl=10 )

# Put the estimated survival function on top of the KM-estimator
# recall the ci.surv return the survival at *start* of intervals
matshade(nd$tfd - 5, surv, col = "Red", alpha = 0.15)

# Extract and plot the fitted intensity function
lambda &lt;- ci.pred(mp, nd) * 365.25 # mortality 
matshade(nd$tfd, lambda, log = "y", ylim = c(0.2, 5), plot = TRUE,
          xlab = "Time since diagnosis",
          ylab = "Mortality per year")

# same thing works with gam from mgcv
library(mgcv)
mg &lt;- gam(cbind(lex.Xst == 1, lex.dur) ~ s(tfd), family = poisreg, data=sL )
matshade(nd$tfd - 5, ci.surv(mg, nd, intl=10), plot=TRUE,
         xlab = "Days since diagnosis", ylab="P(survival)")
matshade(nd$tfd  , ci.pred(mg, nd) * 365.25, plot=TRUE, log="y",
         xlab = "Days since diagnosis", ylab="Mortality per 1 py")
</code></pre>

<hr>
<h2 id='ci.lin'>
Compute linear functions of parameters with standard errors and
confidence limits, optionally transforming to a different scale.
</h2><span id='topic+ci.lin'></span><span id='topic+ci.mat'></span><span id='topic+ci.exp'></span><span id='topic+ci.pred'></span><span id='topic+ci.ratio'></span><span id='topic+Wald'></span>

<h3>Description</h3>

<p>For a given model object the function computes a linear function of
the parameters and the corresponding standard errors, p-values and
confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.lin( obj,
    ctr.mat = NULL,
     subset = NULL,
     subint = NULL,
      xvars = NULL,
      diffs = FALSE,
       fnam = !diffs,
       vcov = FALSE,
      alpha = 0.05,
         df = Inf,
        Exp = FALSE,
     sample = FALSE )
ci.exp( ..., Exp = TRUE, pval = FALSE )
Wald( obj, H0=0, ... )
ci.mat( alpha = 0.05, df = Inf )
ci.pred( obj, newdata,
         Exp = NULL,
       alpha = 0.05 )
ci.ratio( r1, r2,
         se1 = NULL,
         se2 = NULL,
      log.tr = !is.null(se1) &amp; !is.null(se2),
       alpha = 0.05,
        pval = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.lin_+3A_obj">obj</code></td>
<td>
<p>A model object (in general of class <code>glm</code>, but for
<code>ci.lin</code> and <code>ci.exp</code> it may also be of class
<code>lm</code>,
<code>coxph</code>,
<code>survreg</code>,
<code>clogistic</code>,
<code>cch</code>,
<code>lme</code>,
<code>mer</code>,
<code>lmerMod</code>,
<code>gls</code>,
<code>nls</code>,
<code>gnlm</code>,
<code>MIresult</code>,
<code>mipo</code>,
<code>polr</code>,
or <code>rq</code>).
</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_ctr.mat">ctr.mat</code></td>
<td>
<p>Matrix, data frame or list (of two or four data frames).
</p>
<p>If <code>ctr.mat</code> is a matrix, it should be a contrast matrix to be
multiplied to the parameter vector, i.e. the desired linear function
of the parameters.
</p>
<p>If it is a data frame it should have columns corresponding to a
prediction frame, see details.
</p>
<p>If it is a list, it must contain two or four data frames that are
(possibly partial) prediction frames for <code>obj</code>, see argument
<code>xvars</code> and details.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_xvars">xvars</code></td>
<td>
<p>Character vector. If quantitative variables in the model
are omitted from data frames supplied in a list to <code>ctr.mat</code>,
they should be listed here. Omitted factors need not be mentioned
here.</p>
</td></tr>  
<tr><td><code id="ci.lin_+3A_subset">subset</code></td>
<td>
<p>The subset of the parameters to be used. If given as a
character vector, the elements are in turn matched against the
parameter names (using <code>grep</code>) to find the subset. Repeat
parameters may result from using a character vector. This is
considered a facility.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_subint">subint</code></td>
<td>
<p>Character. <code>sub</code>set selection, but where each
element of the character vector is used to
select a subset of parameters and only the <code>int</code>ersection
of these is returned.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_diffs">diffs</code></td>
<td>
<p>If TRUE, all differences between parameters
in the subset are computed, and the <code>subset</code> argumnt is
required. The argument <code>ctr.mat</code> is ignored. If <code>obj</code>
inherits from <code>lm</code>, and <code>subset</code> is given as a string
<code>subset</code> is used to search among the factors in the model and
differences of all factor levels for the first match are shown.
If <code>subset</code> does not match any of the factors in the model, all
pairwise differences between parameters matching are returned.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_fnam">fnam</code></td>
<td>
<p>Should the common part of the parameter names be included
with the annotation of contrasts? Ignored if <code>diffs==T</code>. If a
string is supplied this will be prefixed to the labels.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_vcov">vcov</code></td>
<td>
<p>Should the covariance matrix of the set of parameters be
returned? If this is set, <code>Exp</code> is ignored. See details.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the confidence intervals.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_df">df</code></td>
<td>
<p>Integer. Number of degrees of freedom in the t-distribution used
to compute the quantiles used to construct the confidence intervals.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_exp">Exp</code></td>
<td>
<p>For <code>ci.lin</code>, if <code>TRUE</code> columns 5:6 are replaced
with exp( columns 1,5,6 ). For <code>ci.exp</code>, if <code>FALSE</code>, the
untransformed parameters are returned. For <code>ci.pred</code> it
indicates whether the predictions should be exponentiated - the
default (<code>Exp=NULL</code>) is to make a prediction with a Wald CI on
the scale of the linear predictor and back-transform it by the
inverse link function; if <code>FALSE</code>, the prediction on the link
scale is returned.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_sample">sample</code></td>
<td>
<p>Logical or numerical. If <code>TRUE</code> or numerical a
sample of size <code>as.numeric(sample)</code> is drawn from the
multivariate normal with mean equal to the (<code>subset</code> defined)
coefficients and variance equal to the estimated variance-covariance
of these. These are then transformed by <code>ctr.mat</code> and
returned.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_pval">pval</code></td>
<td>
<p>Logical. Should a column of P-values be included with the
estimates and confidence intervals output by <code>ci.exp</code>.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_h0">H0</code></td>
<td>
<p>Numeric. The null values for the selected/transformed
parameters to be tested by a Wald test. Must have the same length as
the selected parameter vector.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_...">...</code></td>
<td>
<p>Parameters passed on to <code>ci.lin</code>.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_newdata">newdata</code></td>
<td>
<p>Data frame of covariates where prediction is made.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_r1">r1</code>, <code id="ci.lin_+3A_r2">r2</code></td>
<td>
<p>Estimates of rates in two independent groups, with
confidence limits. Can be either 3-column matrices or data frames
with estimates and confindece intervals or 2 two column structures
with confidence limits. Only the confidence limits</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_se1">se1</code>, <code id="ci.lin_+3A_se2">se2</code></td>
<td>
<p>Standard errors of log-rates in the two groups. If
given, it is assumed that <code>r1</code> and <code>r2</code> represent
log-rates.</p>
</td></tr>
<tr><td><code id="ci.lin_+3A_log.tr">log.tr</code></td>
<td>
<p>Logical, if true, it is assumed that <code>r1</code> and
<code>r2</code> represent log-rates with confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ci.lin</code> returns a matrix with number of rows and row names as
<code>ctr.mat</code>. The columns are Estimate, Std.Err, z, P, 2.5% and
97.5% (or according to the value of <code>alpha</code>).  If
<code>vcov=TRUE</code> a list of length 2 with components <code>coef</code> (a
vector), the desired functional of the parameters and <code>vcov</code> (a
square matrix), the variance covariance matrix of this, is returned
but not printed. If <code>Exp==TRUE</code> the confidence intervals for the
parameters are replaced with three columns: exp(estimate,c.i.).
</p>
<p><code>ci.exp</code> returns only the exponentiated parameter estimates with
confidence intervals. It is merely a wrapper for <code>ci.lin</code>,
fishing out the last 3 columns from <code>ci.lin(...,Exp=TRUE)</code>. If
you just want the estimates and confidence limits, but not
exponentiated, use <code>ci.exp(...,Exp=FALSE)</code>.
</p>
<p>If <code>ctr.mat</code> is a data frame, the model matrix corresponding to
this is constructed and supplied. This is only supported for objects
of class <code>lm</code>, <code>glm</code>, <code>gam</code> and <code>coxph</code>.
</p>
<p>So the default behaviour will be to produce the same as
<code>ci.pred</code>, apparently superfluous. The purpose of this is to
allow the use of the arguments <code>vcov</code> that produces the
variance-covariance matrix of the predictions, and <code>sample</code> that
produces a sample of predictions using sampling from the multivariate
normal with mean equal to parameters and variance equal to the
hessian.
</p>
<p>If <code>ctr.mat</code> is a list of two data frames, the difference of the
predictions from using the first versus the last (on the linear
predictor scale) as newdata arguments to <code>predict.glm</code> is
computed. Columns that would be identical in the two data frames can
be omitted (see below), but names of numerical variables omitted must
be supplied in a character vector <code>xvars</code>. Factors omitted need
not be named.  If categorical variables are entered in the model as
character and not factors, the model will work, but the calculation of
the differences in predictions may crash.
</p>
<p>If the second data frame has only one row, this is replicated to match
the number of rows in the first. This facility is primarily aimed at
teasing out RRs that are non-linear functions of a quantitative
variable without setting up contrast matrices using the same code as
in the model. Note however if splines are used with computed knots
stored in a vector such as <code>Ns(x,knots=kk)</code> then the <code>kk</code>
must be available in the (global) environment; it will not be found
inside the model object. In practical terms it means that if you save
model objects for later prediction you should save the knots used in
the spline setups too.
</p>
<p>If <code>ctr.mat</code> is a list of four data frames, the difference of the
difference of predictions from using the first and second versus
difference of predictions from using the third and fourth is computed.
Simply <code>(pr1-pr2) - (pr3-pr4)</code> with obvious notation. Useful to
derive esoteric interaction effects.
</p>
<p>Finally, only arguments <code>Exp</code>, <code>vcov</code>, <code>alpha</code> and
<code>sample</code> from <code>ci.lin</code> are honored when <code>ctr.mat</code> is a
data frame or a list of two data frames.
</p>
<p>You can leave out variables (columns) from the two data frames that
would be identical, basically variables not relevant for the
calculation of the contrast. In many cases <code>ci.lin</code> (really
<code>Epi:::ci.dfr</code>) can figure out the names of the omitted columns,
but occasionally you will have to supply the names of the omitted
variables in the <code>xvars</code> argument. Factors omitted need not be
listed in <code>xvars</code>, although no harm is done doing so.
</p>
<p><code>Wald</code> computes a Wald test for a subset of (possibly linear
combinations of) parameters being equal to the vector of null
values as given by <code>H0</code>. The selection of the subset of
parameters is the same as for <code>ci.lin</code>. Using the <code>ctr.mat</code>
argument makes it possible to do a Wald test for equality of
parameters. <code>Wald</code> returns a named numerical vector of length 3,
with names <code>Chisq</code>, <code>d.f.</code> and <code>P</code>.
</p>
<p><code>ci.mat</code> returns a 2 by 3 matrix with rows <code>c(1,0,0)</code> and
<code>c(0,-1,1)*1.96</code>, devised to post-multiply to a p by 2 matrix with
columns of estimates and standard errors, so as to produce a p by 3 matrix
of estimates and confidence limits. Used internally in <code>ci.lin</code> and
<code>ci.cum</code>.
The 1.96 is replaced by the appropriate quantile from the normal or
t-distribution when arguments <code>alpha</code> and/or <code>df</code> are given.
</p>
<p><code>ci.pred</code> returns a 3-column matrix with estimates and upper and
lower confidence intervals as columns. This is just a convenience
wrapper for <code>predict.glm(obj,se.fit=TRUE)</code> which returns a rather
unhandy structure. The prediction with c.i. is made in the <code>link</code>
scale, and by default transformed by the inverse link, since the most
common use for this is for multiplicative Poisson or binomial models
with either log or logit link.
</p>
<p><code>ci.ratio</code> returns the rate-ratio of two independent set of
rates given with confidence intervals or s.e.s. If <code>se1</code> and
<code>se2</code> are given and <code>log.tr=FALSE</code> it is assumed that
<code>r1</code> and <code>r2</code> are rates and <code>se1</code> and <code>se2</code> are
standard errors of the log-rates.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a> &amp; Michael Hills
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+ci.cum">ci.cum</a></code> for a function computing
cumulative sums of (functions of) parameter estimates, and
<code><a href="#topic+ci.surv">ci.surv</a></code> for a function computing confidence intervals
for survival functions based on smoothed rates. The example code for
<code><a href="#topic+matshade">matshade</a></code> has an application of predicting a rate-ratio
using a list of two prediction frame in the <code>ctr.mat</code> argument.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bogus data:
f &lt;- factor( sample( letters[1:5], 200, replace=TRUE ) )
g &lt;- factor( sample( letters[1:3], 200, replace=TRUE ) )
x &lt;- rnorm( 200 )
y &lt;- 7 + as.integer( f ) * 3 + 2 * x + 1.7 * rnorm( 200 )

# Fit a simple model:
mm &lt;- lm( y ~ x + f + g )
ci.lin( mm )
ci.lin( mm, subset=3:6, diff=TRUE, fnam=FALSE )
ci.lin( mm, subset=3:6, diff=TRUE, fnam=TRUE )
ci.lin( mm, subset="f", diff=TRUE, fnam="f levels:" )
print( ci.lin( mm, subset="g", diff=TRUE, fnam="gee!:", vcov=TRUE ) )

# Use character defined subset to get ALL contrasts:
ci.lin( mm, subset="f", diff=TRUE )

# Suppose the x-effect differs across levels of g:
mi &lt;- update( mm, . ~ . + g:x )
ci.lin( mi )
# RR a vs. b by x:
nda &lt;- data.frame( x=-3:3, g="a", f="b" )
ndb &lt;- data.frame( x=-3:3, g="b", f="b" )
# 
ci.lin( mi, list(nda,ndb) )
# Same result if f column is omitted because "f" columns are identical
ci.lin( mi, list(nda[,-3],ndb[,-3]) )
# However, crashes if knots in spline is supplied, and non-factor omitted
xk &lt;- -1:1
xi &lt;- c(-0.5,0.5)
ww &lt;- rnorm(200)
mi &lt;- update( mm, . ~ . -x + ww + Ns(x,knots=xk) + g:Ns(x,knots=xi) )
# Will crash 
try( cbind( nda$x, ci.lin( mi, list(nda,ndb) ) ) )
# Must specify num vars (not factors) omitted from nda, ndb
cbind( nda$x, ci.lin( mi, list(nda,ndb), xvars="ww" ) )

# A Wald test of whether the g-parameters are 0
Wald( mm, subset="g" )
# Wald test of whether the three first f-parameters are equal:
( CM &lt;- rbind( c(1,-1,0,0), c(1,0,-1,0)) )
Wald( mm, subset="f", ctr.mat=CM )
# or alternatively
( CM &lt;- rbind( c(1,-1,0,0), c(0,1,-1,0)) )
Wald( mm, subset="f", ctr.mat=CM )

# Confidence intervals for ratio of rates
# Rates and ci supplied, but only the range (lower and upper ci) is used
ci.ratio( cbind(10,8,12.5), cbind(5,4,6.25) )
ci.ratio( cbind(8,12.5), cbind(4,6.25) )

# Beware of the offset when making predictions with ci.pred and ci.exp
## Not run: 
library( mgcv )
data( mortDK )
m.arg  &lt;- glm( dt ~ age , offset=log(risk) , family=poisson, data=mortDK )
m.form &lt;- glm( dt ~ age + offset(log(risk)), family=poisson, data=mortDK )
a.arg  &lt;- gam( dt ~ age , offset=log(risk) , family=poisson, data=mortDK )
a.form &lt;- gam( dt ~ age + offset(log(risk)), family=poisson, data=mortDK )

nd &lt;- data.frame( age=60:65, risk=100 )
round( ci.pred( m.arg , nd ), 4 )
round( ci.pred( m.form, nd ), 4 )
round( ci.exp ( m.arg , nd ), 4 )
round( ci.exp ( m.form, nd ), 4 )
round( ci.pred( a.arg , nd ), 4 )
round( ci.pred( a.form, nd ), 4 )
round( ci.exp ( a.arg , nd ), 4 )
round( ci.exp ( a.form, nd ), 4 )

nd &lt;- data.frame( age=60:65 )
try( ci.pred( m.arg , nd ) )
try( ci.pred( m.form, nd ) )
try( ci.exp ( m.arg , nd ) )
try( ci.exp ( m.form, nd ) )
try( ci.pred( a.arg , nd ) )
try( ci.pred( a.form, nd ) )
try( ci.exp ( a.arg , nd ) )
try( ci.exp ( a.form, nd ) )

## End(Not run)
# The offset may be given as an argument (offset=log(risk))
# or as a term (+offset(log)), and depending on whether we are using a
# glm or a gam Poisson model and whether we use ci.pred or ci.exp to
# predict rates the offset is either used or ignored and either
# required or not; the state of affairs can be summarized as:
#
#                     offset
#                     -------------------------------------
#                     usage                 required?
#                     ------------------    ---------------                      
# function  model     argument   term       argument   term
# ---------------------------------------------------------
# ci.pred   glm       used       used       yes        yes
#           gam       ignored    used       no         yes
#  		      
# ci.exp    glm       ignored    ignored    no         yes
#           gam       ignored    ignored    no         yes
# ---------------------------------------------------------
</code></pre>

<hr>
<h2 id='ci.pd'>
Compute confidence limits for a difference of two independent proportions.
</h2><span id='topic+ci.pd'></span>

<h3>Description</h3>

<p>The usual formula for the c.i. of at difference of proportions is
inaccurate. Newcombe has compared 11 methods and method 10 in his
paper looks like a winner. It is implemented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.pd(aa, bb=NULL, cc=NULL, dd=NULL,
     method = "Nc",
      alpha = 0.05, conf.level=0.95,
     digits = 3,
      print = TRUE,
detail.labs = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.pd_+3A_aa">aa</code></td>
<td>
<p>Numeric vector of successes in sample 1. Can also be a
matrix or array (see details).</p>
</td></tr> 
<tr><td><code id="ci.pd_+3A_bb">bb</code></td>
<td>
<p>Successes in sample 2.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_cc">cc</code></td>
<td>
<p>Failures in sample 1.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_dd">dd</code></td>
<td>
<p>Failures in sample 2.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_method">method</code></td>
<td>
<p>Method to use for calculation of confidence interval, see
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_print">print</code></td>
<td>
<p>Should an account of the two by two table be printed.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_digits">digits</code></td>
<td>
<p>How many digits should the result be rounded to if printed.</p>
</td></tr>
<tr><td><code id="ci.pd_+3A_detail.labs">detail.labs</code></td>
<td>
<p>Should the computing of probability differences be
reported in the labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements method 10 from Newcombe(1998) (method=&quot;Nc&quot;) or from
Agresti &amp; Caffo(2000) (method=&quot;AC&quot;).
</p>
<p><code>aa</code>, <code>bb</code>, <code>cc</code> and <code>dd</code> can be vectors.
If <code>aa</code> is a matrix, the elements <code>[1:2,1:2]</code> are used, with
successes <code>aa[,1:2]</code>. If <code>aa</code> is a three-way table or array,
the elements <code>aa[1:2,1:2,]</code> are used.
</p>


<h3>Value</h3>

<p>A matrix with three columns: probability difference, lower and upper
limit. The number of rows equals the length of the vectors  <code>aa</code>,
<code>bb</code>, <code>cc</code> and <code>dd</code> or, if <code>aa</code> is a 3-way matrix,
<code>dim(aa)[3]</code>.   
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Esa Laara.
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>References</h3>

<p>RG Newcombe: Interval estimation for the difference between
independent proportions. Comparison of eleven methods. Statistics in
Medicine, 17, pp. 873-890, 1998.
</p>
<p>A Agresti &amp; B Caffo: Simple and effective confidence intervals for
proportions and differences of proportions result from adding two
successes and two failures. The American Statistician,
54(4), pp. 280-288, 2000.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twoby2">twoby2</a></code>, <code><a href="stats.html#topic+binom.test">binom.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( a &lt;- matrix( sample( 10:40, 4 ), 2, 2 ) )
ci.pd( a )
twoby2( t(a) )
prop.test( t(a) )
( A &lt;- array( sample( 10:40, 20 ), dim=c(2,2,5) ) )
ci.pd( A )
ci.pd( A, detail.labs=TRUE, digits=3 )
</code></pre>

<hr>
<h2 id='clogistic'>Conditional logistic regression</h2><span id='topic+clogistic'></span>

<h3>Description</h3>

<p>Estimates a logistic regression model by maximizing the conditional
likelihood.  The conditional likelihood calculations are exact, and
scale efficiently to strata with large numbers of cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clogistic(formula, strata, data, subset, na.action, init,
model = TRUE, x = FALSE, y = TRUE, contrasts = NULL,
iter.max=20, eps=1e-6, toler.chol = sqrt(.Machine$double.eps)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clogistic_+3A_formula">formula</code></td>
<td>
<p>Model formula</p>
</td></tr>
<tr><td><code id="clogistic_+3A_strata">strata</code></td>
<td>
<p>Factor describing membership of strata for conditioning</p>
</td></tr>
<tr><td><code id="clogistic_+3A_data">data</code></td>
<td>
<p>data frame containing the variables in the formula and
strata arguments</p>
</td></tr>
<tr><td><code id="clogistic_+3A_subset">subset</code></td>
<td>
<p>subset of records to use</p>
</td></tr>
<tr><td><code id="clogistic_+3A_na.action">na.action</code></td>
<td>
<p>missing value handling</p>
</td></tr>
<tr><td><code id="clogistic_+3A_init">init</code></td>
<td>
<p>initial values</p>
</td></tr>
<tr><td><code id="clogistic_+3A_model">model</code></td>
<td>

<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value</p>
</td></tr>
<tr><td><code id="clogistic_+3A_x">x</code>, <code id="clogistic_+3A_y">y</code></td>
<td>

<p>logical values indicating whether the response vector and model
matrix used in the fitting process should be returned as components
of the returned value.
</p>
</td></tr>
<tr><td><code id="clogistic_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>
</p>
</td></tr>
<tr><td><code id="clogistic_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="clogistic_+3A_eps">eps</code></td>
<td>

<p>Convergence tolerance.  Iteration continues until the relative
change in the conditional log likelihood is less than <code>eps</code>.
Must be positive.
</p>
</td></tr>
<tr><td><code id="clogistic_+3A_toler.chol">toler.chol</code></td>
<td>

<p>Tolerance used for detection of a singularity during a Cholesky
decomposition of the variance matrix. This is used to detect
redundant predictor variables. Must be less than <code>eps</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"clogistic"</code>. This is a list containing
the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>

<p>the estimates of the log-odds ratio parameters.  If the model is
over-determined there will be missing values in the vector corresponding
to the redundant columns in the model matrix.
</p>
</td></tr>
<tr><td><code>var</code></td>
<td>

<p>the variance matrix of the coefficients.  Rows and columns corresponding to 
any missing coefficients are set to zero. 
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>a vector of length 2 containing the log-likelihood with the initial
values and with the final values of the coefficients. 
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>number of iterations used. 
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>number of observations used. Observations may be dropped
either because they are missing, or because they belong to a
homogeneous stratum. For more details on which observations were
used, see <code>informative</code> below.
</p>
</td></tr>
<tr><td><code>informative</code></td>
<td>

<p>if <code>model=TRUE</code>, a logical vector of length equal to the number
of rows in the model frame.  This indicates whether an observation
is informative. Strata that are homogeneous with respect to either
the outcome variable or the predictor variables are uninformative,
in the sense that they can be removed without modifying the
estimates or standard errors. If <code>model=FALSE</code>, this is NULL.
</p>
</td></tr>
</table>
<p>The output will also contain the following, for documentation see the
<code>glm</code> object: <code>terms</code>, <code>formula</code>,
<code>call</code>,  <code>contrasts</code>, <code>xlevels</code>, and, optionally,
<code>x</code>, <code>y</code>, and/or <code>frame</code>. 
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(bdendo)
  clogistic(d ~ cest + dur, strata=set, data=bdendo)
</code></pre>

<hr>
<h2 id='contr.cum'>
Contrast matrices
</h2><span id='topic+contr.cum'></span><span id='topic+contr.2nd'></span><span id='topic+contr.diff'></span><span id='topic+contr.orth'></span>

<h3>Description</h3>

<p>Return a matrix of contrasts for factor coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  contr.cum(n)
  contr.diff(n)
  contr.2nd(n)
  contr.orth(n) 
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.cum_+3A_n">n</code></td>
<td>
<p>A vector of levels for a factor, or the number of levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used for creating contrast matrices for use in
fitting regression models. The columns of the
resulting matrices contain contrasts which can be used for coding a
factor with <code>n</code> levels.
</p>
<p><code>contr.cum</code> gives a coding corresponding to successive differences
between factor levels.
</p>
<p><code>contr.diff</code> gives a coding that correspond to the cumulative sum
of the value for each level. This is not meaningful in a model where the
intercept is included, therefore <code>n</code> columns ia always returned.
</p>
<p><code>contr.2nd</code> gives contrasts corresponding to 2nd order differences
between factor levels. Returns a matrix with <code>n-2</code> columns.
</p>
<p><code>contr.orth</code> gives a matrix with <code>n-2</code> columns, which are
mutually orthogonal and orthogonal to the matrix <code>cbind(1,1:n)</code>
</p>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>k</code> columns, with
<code>k</code>=<code>n</code> for <code>contr.diff</code>
<code>k</code>=<code>n-1</code> for <code>contr.cum</code>
<code>k</code>=<code>n-2</code> for <code>contr.2nd</code> and  <code>contr.orth</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contr.cum(6)
contr.2nd(6)
contr.diff(6)
contr.orth(6)
  </code></pre>

<hr>
<h2 id='crr.Lexis'>Fit a competing risks regression model (Fine-Gray model) using a
Lexis object)
</h2><span id='topic+crr.Lexis'></span>

<h3>Description</h3>

<p>Fits a competing risks regression model using a <code><a href="#topic+Lexis">Lexis</a></code>
object assuming that every person enters at time 0 and exits at time
<code>lex.dur</code>. Thus is only meaningful for Lexis objects with one record
per person, (so far).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crr.Lexis( obj, mod, quiet=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crr.Lexis_+3A_obj">obj</code></td>
<td>
<p>A Lexis object; variables in <code>mod</code> are taken from this.</p>
</td></tr>
<tr><td><code id="crr.Lexis_+3A_mod">mod</code></td>
<td>
<p>Formula, with the l.h.s. a character constant equal to a
level of <code>obj$lex.Xst</code>, and the r.h.s. a model formula
interpreted in <code>obj</code>.</p>
</td></tr>
<tr><td><code id="crr.Lexis_+3A_quiet">quiet</code></td>
<td>
<p>Logical indicating whether a brief summary should be printed.</p>
</td></tr>
<tr><td><code id="crr.Lexis_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="cmprsk.html#topic+crr">crr</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a simple wrapper for <code>crr</code>, allowing a
formula-specification of the model (which allows specifications of
covariates on the fly), and utilizing the structure of Lexis
objects to simplify specification of the outcome. Prints a summary of
the levels used as event, competing events and censoring.
</p>
<p>By the structure of the <code><a href="#topic+Lexis">Lexis</a></code> object it is not necessary
to indicate what the censoring code or competing events are, that is
automatically derived from the <code>Lexis</code> object.
</p>
<p>Currently only one state is allowed as l.h.s. (response) in <code>mod</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="cmprsk.html#topic+crr">crr</a></code> object (which is a list), with two extra
elements in the list, <code>model.Lexis</code> - the model formula supplied,
and <code>transitions</code> - a table of transitions and censorings showing
which transition was analysed and which were taken as competing events.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a> </p>


<h3>See Also</h3>

<p><code><a href="cmprsk.html#topic+crr">crr</a></code>, <code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Thorotrats patients, different histological types of liver cancer
# Load thorotrast data, and restrict to exposed
data(thoro)
tht &lt;- thoro[thoro$contrast==1,]
# Define exitdate as the date of livercancer
tht$dox &lt;- pmin( tht$liverdat, tht$exitdat, na.rm=TRUE )
tht &lt;- subset( tht, dox &gt; injecdat )
# Convert to calendar years in dates
tht &lt;- cal.yr( tht )

# Set up a Lexis object with three subtypes of liver cancer and death
tht.L &lt;- Lexis( entry = list( per = injecdat,
                              tfi = 0 ),
                 exit = list( per = dox ),
          exit.status = factor( 1*hepcc+2*chola+3*hmang+
                                4*(hepcc+chola+hmang==0 &amp; exitstat==1),
                                labels=c("No cancer","hepcc","chola","hmang","Dead") ),
                 data = tht )
summary( tht.L )

# Show the transitions
boxes( tht.L, boxpos=list(x=c(20,rep(80,3),30),
                          y=c(60,90,60,30,10) ),
              show.BE="nz", scale.R=1000 )

# Fit a model for the Hepatocellular Carcinoma as outcome
# - note that you can create a variable on the fly:
library( cmprsk )
hepcc &lt;- crr.Lexis( tht.L, "hepcc" ~ volume + I(injecdat-1940) )
hepcc$model.Lexis
hepcc$transitions

# Models for the three other outcomes:
chola &lt;- crr.Lexis( tht.L, "chola" ~ volume + I(injecdat-1940) )
hmang &lt;- crr.Lexis( tht.L, "hmang" ~ volume + I(injecdat-1940) )
dead  &lt;- crr.Lexis( tht.L, "Dead"  ~ volume + I(injecdat-1940) )

# Compare the effects
# NOTE: This is not necessarily a joint model for all transitions.
zz &lt;- rbind( ci.exp(hepcc),
             ci.exp(chola),
             ci.exp(hmang),
             ci.exp(dead) )
zz &lt;- cbind( zz[c(1,3,5,7)  ,],
             zz[c(1,3,5,7)+1,] )
rownames( zz ) &lt;- c("hepcc","chola","hmang","dead")
colnames( zz )[c(1,4)] &lt;- rownames( ci.exp(chola) )
round( zz, 3 )
</code></pre>

<hr>
<h2 id='cutLexis'>
Cut follow-up at a specified date for each person.
</h2><span id='topic+cutLexis'></span><span id='topic+countLexis'></span>

<h3>Description</h3>

<p>Follow-up intervals in a Lexis object are divided into two
sub-intervals: one before and one after an intermediate event.  The
intermediate event may denote a change of state, in which case the
entry and exit status variables in the split Lexis object are
modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutLexis( data, cut, timescale = 1,
                     new.state = nlevels(data$lex.Cst)+1,
                     new.scale = FALSE,
                  split.states = FALSE,
                   progressive = FALSE,
              precursor.states = transient(data),
                         count = FALSE )
countLexis( data, cut, timescale = 1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutLexis_+3A_data">data</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_cut">cut</code></td>
<td>
<p>A numeric vector with the times of the intermediate event.
If a time is missing (<code>NA</code>) then the event is assumed to occur
at time <code>Inf</code>. <code>cut</code> can also be a dataframe, see details.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_timescale">timescale</code></td>
<td>
<p>The timescale that <code>cut</code> refers to. Numeric or character.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_new.state">new.state</code></td>
<td>
<p>The state to which a transition occur at time
<code>cut</code>. It may be a single value, which is then applied to all
rows of <code>data</code>, or a vector with a separate value for each row</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_new.scale">new.scale</code></td>
<td>
<p>Name of the timescale defined as &quot;time since entry to
new.state&quot;. If <code>TRUE</code> a name for the new scale is constructed.
See details.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_split.states">split.states</code></td>
<td>
<p>Should states that are not precursor states be split
according to whether the intermediate event has occurred.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_progressive">progressive</code></td>
<td>
<p>a logical flag that determines the changes to exit
status. See details.</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_precursor.states">precursor.states</code></td>
<td>
<p>an optional vector of states to be considered
as &quot;less severe&quot; than <code>new.state</code>. See Details below</p>
</td></tr>
<tr><td><code id="cutLexis_+3A_count">count</code></td>
<td>
<p>logical indicating whether the <code>countLexis</code> options should
be used. Specifying <code>count=TRUE</code> amounts to calling <code>countLexis</code>,
in which case the arguments <code>new.state</code>, <code>progressive</code> and
<code>precursor.states</code> will be ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cutLexis</code> function allows a number of different ways
of specifying the cutpoints and of modifying the status variable.
</p>
<p>If the <code>cut</code> argument is a dataframe it must have columns <code>lex.id</code>,
<code>cut</code> and <code>new.state</code>. The values of <code>lex.id</code> must be unique.
In this case it is assumed that each row represents a cutpoint (on the
timescale indicated in the argument <code>timescale</code>). This cutpoint will
be applied to all records in <code>data</code> with the corresponding <code>lex.id</code>.
This makes it possible to apply <code>cutLexis</code> to a split <code>Lexis</code> object.
</p>
<p>If a <code>new.state</code> argument is supplied, the status variable is
only modified at the time of the cut point. However, it is often
useful to modify the status variable after the cutpoint when an
important event occurs. There are three distinct ways of doing this.
</p>
<p>If the <code>progressive=TRUE</code> argument is given, then a &quot;progressive&quot;
model is assumed, in which the status can either remain the same or
increase during follow-up, but never decrease. This assumes that the
state variables <code>lex.Cst</code> and <code>lex.Xst</code> are either numeric or
ordered factors. In this case, if
<code>new.state=X</code>, then any exit status with a value less than
<code>X</code> is replaced with <code>X</code>. The Lexis object
must already be progressive, so that there are no rows for which the
exit status is less than the entry status. If <code>lex.Cst</code> and
<code>lex.Xst</code> are factors they must be ordered factors if
<code>progressive=TRUE</code> is given.
</p>
<p>As an alternative to the <code>progressive</code> argument, an explicit
vector of precursor states, that are considered less severe than the
new state, may be given. If <code>new.state=X</code> and
<code>precursor.states=c(Y,Z)</code> then any exit status of <code>Y</code> or
<code>Z</code> in the second interval is replaced with <code>X</code> and all
other values for the exit status are retained.
</p>
<p>The <code>countLexis</code> function is a variant of <code>cutLexis</code> when
the cutpoint marks a recurrent event, and the status variable is used
to count the number of events that have occurred. Times given in <code>cut</code>
represent times of new events. Splitting with
<code>countLexis</code> increases the status variable by 1. If the current
status is <code>X</code> and the exit status is <code>Y</code> before cutting,
then after cutting the entry status is <code>X</code>, <code>X+1</code> for
the first and second intervals, respectively, and the exit status is
<code>X+1</code>, <code>Y+1</code> respectively. Moreover the values of the status
is increased by 1 for all intervals for all intervals after the cut
for the person in question. Hence, a call to <code>countLexis</code> is
needed for as many times as the person with most events. But also it
is immaterial in what order the cutpoints are entered.
</p>


<h3>Value</h3>

<p>A <code>Lexis</code> object, for which each follow-up interval containing
the cutpoint is split in two: one before and one after the
cutpoint. Any record representing follow up after the cutpoint has its
value of <code>lex.Cst</code> updated to the new state. An extra time-scale
is added; the time since the event at <code>cut</code>. This time scake will
be<code>NA</code> for any follow-up prior to the intermediate event.
</p>
<p>The function <code>tsNA20</code> will replace all missing values in
timescales with 0. This is commonly meeded when timescales defined as
time since entry into an intermediate state are used in modeling. But
you do not want to do that permanently in the cut data frame.
</p>


<h3>Note</h3>

<p>The <code>cutLexis</code> function superficially resembles the
<code>splitLexis</code> function. However, the <code>splitLexis</code> function
splits on a vector of common cut-points for all rows of the Lexis
object, whereas the <code>cutLexis</code> function splits on a single time
point, which may be distinct for each row, modifies the status
variables, adds a new timescale and updates the attribute
&quot;time.since&quot;. This attribute is a character vector of the same length
as the &quot;time.scales&quot; attribute, whose value is '&quot;&quot;' if the
corresponding timescale is defined for any piece of follow-up, and if
the corresponding time scale is defined by say
<code>cutLexis(obj,new.state="A",new.scale=TRUE)</code>, it has the value
&quot;A&quot;.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:b@bxc.dk">b@bxc.dk</a>,
Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+rcutLexis">rcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>,
<code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+summary.Lexis">summary.Lexis</a></code>,
<code><a href="#topic+timeSince">timeSince</a></code>,
<code><a href="#topic+boxes.Lexis">boxes.Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small artificial example
xx &lt;- Lexis( entry=list(age=c(17,24,33,29),per=c(1920,1933,1930,1929)),
             duration=c(23,57,12,15), exit.status=c(1,2,1,2) )
xx
cut &lt;- c(33,47,29,50)
cutLexis(xx, cut, new.state=3, precursor=1)
cutLexis(xx, cut, new.state=3, precursor=2)
cutLexis(xx, cut, new.state=3, precursor=1:2)
# The same as the last example
cutLexis(xx, cut, new.state=3)

# The same example with a factor status variable
yy &lt;- Lexis(entry = list(age=c(17,24,33,29),per=c(1920,1933,1930,1929)),
            duration = c(23,57,12,15),
            entry.status = factor(rep("alpha",4),
            levels=c("alpha","beta","gamma")),
            exit.status = factor(c("alpha","beta","alpha","beta"),
            levels=c("alpha","beta","gamma")))

cutLexis(yy,c(33,47,29,50),precursor="alpha",new.state="gamma")
cutLexis(yy,c(33,47,29,50),precursor=c("alpha","beta"),new.state="aleph")

## Using a dataframe as cut argument
rl &lt;- data.frame( lex.id=1:3, cut=c(19,53,26), timescale="age", new.state=3 )
rl
cutLexis( xx, rl )
cutLexis( xx, rl, precursor=1 )
cutLexis( xx, rl, precursor=0:2 )

## It is immaterial in what order splitting and cutting is done
xs &lt;- splitLexis( xx, breaks=seq(0,100,10), time.scale="age" )
xs
xsC &lt;- cutLexis(xs, rl, precursor=0 )

xC &lt;- cutLexis( xx, rl, pre=0 )
xC
xCs &lt;- splitLexis( xC, breaks=seq(0,100,10), time.scale="age" )
xCs
str(xCs)
</code></pre>

<hr>
<h2 id='detrend'> Projection of a model matrix on the orthogonal
complement of a trend or curvature.</h2><span id='topic+detrend'></span><span id='topic+decurve'></span>

<h3>Description</h3>

<p>The columns of a model matrix <code>M</code> is projected on the
orthogonal complement to the matrix <code>(1,t)</code>,
resp. <code>(1,t,t^2)</code>.
</p>
<p>Orthogonality is w.r.t. an inner product defined by the positive
definite matrix matrix <code>diag(weight)</code>. Non-diagonal matrices
defining the inner product is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  detrend( M, t, weight = rep(1, nrow(M)) )
  decurve( M, t, weight = rep(1, nrow(M)) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_+3A_m">M</code></td>
<td>
<p>A model matrix.</p>
</td></tr>
<tr><td><code id="detrend_+3A_t">t</code></td>
<td>
<p>The trend defining a subspace. A numerical vector of length
<code>nrow(M)</code>.</p>
</td></tr>
<tr><td><code id="detrend_+3A_weight">weight</code></td>
<td>
<p> Weights defining the inner product of vectors <code>x</code>
and <code>y</code> as <code>sum(x*w*y)</code>.
A numerical vector of length <code>nrow(M)</code>, defaults to a vector of
<code>1</code>s. Must be all non-negative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are intended to be used in construction of particular
parametrizations of age-period-cohort models. 
</p>


<h3>Value</h3>

<p><code>detrend</code> returns full-rank matrix with columns orthogonal to
<code>(1,t)</code>;
<code>decurve</code> returns full-rank matrix with columns orthogonal to
<code>(1,t,t^2)</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center Copenhagen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>, with essential help from Peter Dalgaard.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+projection.ip">projection.ip</a></code> </p>

<hr>
<h2 id='diet'>Diet and heart data</h2><span id='topic+diet'></span>

<h3>Description</h3>

<p>The <code>diet</code> data frame has 337 rows and 14 columns.
The data concern a subsample of subjects drawn from larger cohort
studies of the incidence of coronary heart disease (CHD). These subjects
had all completed a 7-day weighed dietary survey while taking part in
validation studies of dietary questionnaire methods. Upon the closure of
the MRC Social Medicine Unit, from where these studies were directed, it
was found that 46 CHD events had occurred in this group, thus allowing a
serendipitous study of the relationship between diet and the incidence
of CHD. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>id</code>: </td><td style="text-align: left;"> subject identifier, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>doe</code>: </td><td style="text-align: left;"> date of entry into follow-up study, a
                 <code><a href="base.html#topic+Date">Date</a></code> variable. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dox</code>: </td><td style="text-align: left;"> date of exit from the follow-up study, a
                 <code><a href="base.html#topic+Date">Date</a></code> variable. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dob</code>: </td><td style="text-align: left;"> date of birth, a
                 <code><a href="base.html#topic+Date">Date</a></code> variable. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>y</code>: </td><td style="text-align: left;"> number of years at risk, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>fail</code>: </td><td style="text-align: left;"> status on exit, a numeric vector (codes 1, 3 and
13 represent CHD events) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>job</code>: </td><td style="text-align: left;"> occupation, a factor with levels
                 <code>Driver</code> 
                 <code>Conductor</code> 
                 <code>Bank worker</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>month</code>: </td><td style="text-align: left;"> month of dietary survey, a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>energy</code>: </td><td style="text-align: left;"> total energy intake (kCal per day/100), a numeric
vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>height</code>: </td><td style="text-align: left;"> (cm), a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>weight</code>: </td><td style="text-align: left;"> (kg), a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>fat</code>: </td><td style="text-align: left;">   fat intake (10 g/day), a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>fibre</code>: </td><td style="text-align: left;"> dietary fibre intake (10 g/day), a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>energy.grp</code>: </td><td style="text-align: left;"> high daily energy intake, a factor with levels
<code>&lt;=2750 KCal</code>
<code>&gt;2750 KCal</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>chd</code>: </td><td style="text-align: left;"> CHD event, a numeric vector (1=CHD event, 0=no event) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>The data are described and used extensively by Clayton and Hills,
Statistical Models in Epidemiology, Oxford University Press,
Oxford:1993. They were rescued from destruction by David Clayton and
reentered from paper printouts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diet)
# Illustrate the follow-up in a Lexis diagram
Lexis.diagram( age=c(30,75), date=c(1965,1990),
               entry.date=cal.yr(doe), exit.date=cal.yr(dox), birth.date=cal.yr(dob), 
               fail=(fail&gt;0), pch.fail=c(NA,16), col.fail=c(NA,"red"), cex.fail=1.0,
               data=diet )

</code></pre>

<hr>
<h2 id='DMconv'>Conversion to diabetes</h2><span id='topic+DMconv'></span>

<h3>Description</h3>

<p>Data from a randomized intervention study (&quot;Addition&quot;) where persons with
prediabetic conditions are followed up for conversion to diabetes (DM).
Conversion dates are interval censored.
Original data are not published yet, so id-numbers have been changed and
all dates have been randomly perturbed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DMconv)</code></pre>


<h3>Format</h3>

<p>A data frame with 1519 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Person identifier</p>
</dd>
<dt><code>doe</code></dt><dd><p>Date of entry, i.e. first visit.</p>
</dd>
<dt><code>dlw</code></dt><dd><p>Date last seen well, i.e. last visit without DM.</p>
</dd>
<dt><code>dfi</code></dt><dd><p>Date first seen ill, i.e. first visit with DM.</p>
</dd>
<dt><code>gtol</code></dt><dd><p>Glucose tolerance. Factor with levels:
1=&quot;IFG&quot; (impaired fasting glucose), 2=&quot;IGT&quot; (impaired glucose tolerance).</p>
</dd>
<dt><code>grp</code></dt><dd><p>Randomization. Factor with levels:
1=&quot;Intervention&quot;, 2=&quot;Control&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Signe Saetre Rasmussen, Steno Diabetes Center. The Addition Study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMconv)
str(DMconv)
head(DMconv)
</code></pre>

<hr>
<h2 id='DMepi'>Epidemiological rates for diabetes in Denmark 1996&ndash;2015</h2><span id='topic+DMepi'></span>

<h3>Description</h3>

<p>Register based counts and person-years for incidence of
diabetes and mortality with and without diabetes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DMepi")</code></pre>


<h3>Format</h3>

<p>A data frame with 4200 observations on the following 8 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>M</code>, <code>F</code></p>
</dd>
<dt><code>A</code></dt><dd><p>Age class, 0&ndash;99</p>
</dd>
<dt><code>P</code></dt><dd><p>Calendar year, 1996&ndash;2016</p>
</dd>
<dt><code>X</code></dt><dd><p>Number of new diagnoses of diabetes among persons without diabetes</p>
</dd>
<dt><code>D.nD</code></dt><dd><p>Number of deaths among persons without diabetes</p>
</dd>	   
<dt><code>Y.nD</code></dt><dd><p>Person-years among persons without diabetes</p>
</dd>
<dt><code>D.DM</code></dt><dd><p>Number of deaths among persons with diabetes</p>
</dd>	   
<dt><code>Y.DM</code></dt><dd><p>Person-years among persons with diabetes</p>
</dd>
</dl>



<h3>Details</h3>

<p>Based on registers of the Danish population. Only included for
illustrative purposes. Cannot be used as scientifically validated
data, since small numbers are randomly permuted between units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMepi)
# Total deaths and person-years in the Danish population
ftable( addmargins( xtabs( cbind( Deaths=D.nD+D.DM,
                                    PYrs=Y.nD+Y.DM ) ~ P + sex,
                           data=DMepi ),
                    2 ),
        row.vars = 1 )
# Deaths and person-years in the population of diabetes patients
round(
ftable( addmargins( xtabs( cbind( Deaths=D.DM,
                                    PYrs=Y.DM ) ~ P + sex,
                           data=DMepi ),
                    2 ),
        row.vars = 1 ) )

# Model for age-specific incidence rates;
inc &lt;- glm( X ~ sex + Ns( A, knots=seq(30,80,10) ) + P,
                offset = log(Y.nD),
                family = poisson,
                  data = DMepi )

# Predict for men and women separately in 2010:
ndm &lt;- data.frame( sex="M", A=20:90, P=2010, Y.nD=1000 )
ndf &lt;- data.frame( sex="F", A=20:90, P=2010, Y.nD=1000 )
prM &lt;- ci.pred( inc, ndm )
prF &lt;- ci.pred( inc, ndf )
matplot( ndm$A, cbind(prM,prF),
         type="l", lty=1, lwd=c(3,1,1),
         col=rep(c("blue","red"),each=3),
         log="y", xlab="Age", ylab="DM incidence per 1000 PY" )

# This is a proportional hazards model - add sex-age interaction
int &lt;- update( inc, . ~ . + sex:Ns( A, knots=seq(30,80,10) ) )
prM &lt;- ci.pred( int, ndm )
prF &lt;- ci.pred( int, ndf )
matplot( ndm$A, cbind(prM,prF),
         type="l", lty=1, lwd=c(3,1,1),
         col=rep(c("blue","red"),each=3),
         log="y", xlab="Age", ylab="DM incidence per 1000 PY" )

# The rate-ratio is teased out using the ci.exp:
RRp &lt;- ci.exp( inc, list(ndm,ndf) )
RRi &lt;- ci.exp( int, list(ndm,ndf) )

# and added to the plot
matlines( ndm$A, cbind(RRi,RRp),
          type="l", lty=1, lwd=c(3,1,1), col=gray(rep(c(0.3,0.7),each=3)) )
abline(h=1)
axis(side=4)
mtext( "Male/Female IRR", side=4, line=2 )
</code></pre>

<hr>
<h2 id='DMlate'>
The Danish National Diabetes Register.
</h2><span id='topic+DMlate'></span><span id='topic+DMrand'></span>

<h3>Description</h3>

<p>These two datasets each contain a random sample of 10,000 persons from
the Danish National Diabetes Register. <code>DMrand</code> is a random sample
from the register, whereas <code>DMlate</code> is a random sample among those
with date of diagnosis after 1.1.1995. All dates are radomly jittered by
adding a U(-7,7) (days).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DMrand)
       data(DMlate)</code></pre>


<h3>Format</h3>

<p>A data frame with 10000 observations on the following 7 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Sex, a factor with levels <code>M</code> <code>F</code></p>
</dd>
<dt><code>dobth</code></dt><dd><p>Date of birth</p>
</dd>
<dt><code>dodm</code></dt><dd><p>Date of inclusion in the register</p>
</dd>
<dt><code>dodth</code></dt><dd><p>Date of death</p>
</dd>
<dt><code>dooad</code></dt><dd><p>Date of 2nd prescription of OAD</p>
</dd>
<dt><code>doins</code></dt><dd><p>Date of 2nd insulin prescription</p>
</dd>
<dt><code>dox</code></dt><dd><p>Date of exit from follow-up.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All dates are given in fractions of years, so 1998.000
corresponds to 1 January 1998 and 1998.997 to 31 December 1998.
</p>
<p>All dates are randomly perturbed by a small amount, so no real
persons have any of the combinations of the 6 dates in the
dataset. But results derived from the data will be quite close to
those that would be obtained if the entire 'real' diabetes register
were used.
</p>


<h3>Source</h3>

<p>Danish National Board of Health.
</p>


<h3>References</h3>

<p>B Carstensen, JK Kristensen, P Ottosen and K Borch-Johnsen:
The Danish National Diabetes Register: Trends in incidence, prevalence and
mortality, Diabetologia, 51, pp 2187&ndash;2196, 2008.
</p>
<p>In partucular see the appendix at the end of the paper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
str(DMlate)
dml &lt;- Lexis( entry=list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit=list(Per=dox),
        exit.status=factor(!is.na(dodth),labels=c("DM","Dead")),
               data=DMlate )

# Cut the follow-up at insulin start, and introduce a new timescale,
# and split non-precursor states
system.time(
dmi &lt;- cutLexis( dml, cut = dml$doins,
                      pre = "DM",
                new.state = "Ins",
                new.scale = "t.Ins",
             split.states = TRUE ) )
summary( dmi )
</code></pre>

<hr>
<h2 id='effx'>Function to calculate effects</h2><span id='topic+effx'></span>

<h3>Description</h3>

<p>The function calculates the effects of an exposure on a response,
possibly stratified by a stratifying variable, and/or controlled for one
or more confounding variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effx( response, type = "metric",
	         fup = NULL,
	    exposure,
	      strata = NULL,
	     control = NULL,
             weights = NULL,
                 eff = NULL,
	       alpha = 0.05,
	        base = 1,
	      digits = 3,
	        data = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effx_+3A_response">response</code></td>
<td>
<p>The <code>response</code> variable - must be numeric or
logical. If logical, <code>TRUE</code> is considered the outcome.</p>
</td></tr>
<tr><td><code id="effx_+3A_type">type</code></td>
<td>
<p>The type of response<code>type</code> - must be one of &quot;metric&quot;,
&quot;binary&quot;, &quot;failure&quot;, or &quot;count&quot;</p>
</td></tr>
<tr><td><code id="effx_+3A_fup">fup</code></td>
<td>
<p>The <code>fup</code> variable contains the follow-up time for a
failure response. This must be numeric.</p>
</td></tr>
<tr><td><code id="effx_+3A_exposure">exposure</code></td>
<td>
<p>The <code>exposure</code> variable can be numeric or a factor</p>
</td></tr>
<tr><td><code id="effx_+3A_strata">strata</code></td>
<td>
<p>The <code>strata</code> stratifying variable - must be a factor</p>
</td></tr>
<tr><td><code id="effx_+3A_control">control</code></td>
<td>
<p>The <code>control</code> variable(s) (confounders) - these are
passed as a list if there are more than one.</p>
</td></tr>
<tr><td><code id="effx_+3A_weights">weights</code></td>
<td>
<p>Frequency weights for binary response only</p>
</td></tr>
<tr><td><code id="effx_+3A_eff">eff</code></td>
<td>
<p>How should effects be measured. If <code>response</code> is
binomial, the default is &quot;OR&quot; (odds-ratio) with &quot;RR&quot; (relative risk)
as an option. If <code>response</code> is failure, the default is &quot;RR&quot;
(rate-ratio) with &quot;RD&quot; (rate difference) as an option.</p>
</td></tr>
<tr><td><code id="effx_+3A_base">base</code></td>
<td>
<p>Baseline for the effects of a categorical exposure, either a
number or a name of the level. Defaults to 1</p>
</td></tr>
<tr><td><code id="effx_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits for the effects, default 3</p>
</td></tr>
<tr><td><code id="effx_+3A_alpha">alpha</code></td>
<td>
<p>1 - confidence level</p>
</td></tr>
<tr><td><code id="effx_+3A_data">data</code></td>
<td>
<p><code>data</code> refers to the data used to evaluate the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for glm. Effects are calculated as
differences in means for a metric response, odds ratios/relative risks
for a binary response, and rate ratios/rate differences for a failure
or count response.
</p>
<p>The k-1 effects for a categorical exposure with k levels are relative
to a baseline which, by default, is the first level. The effect of a
metric (quantitative) exposure is calculated per unit of exposure.
</p>
<p>The exposure variable can be numeric or a factor, but if it is an
ordered factor the order will be ignored.</p>


<h3>Value</h3>



<table>
<tr><td><code>comp1</code></td>
<td>
<p>Effects of exposure</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Tests of significance</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Michael Hills (*1934-Jun-07, +2021-Jan-07)</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Epi)
data(births)
births$hyp &lt;- factor(births$hyp,labels=c("normal","hyper"))
births$sex &lt;- factor(births$sex,labels=c("M","F"))

# bweight is the birth weight of the baby in gms, and is a metric
# response (the default)

# effect of hypertension on birth weight
effx(bweight,exposure=hyp,data=births)
# effect of hypertension on birth weight stratified by sex
effx(bweight,exposure=hyp,strata=sex,data=births)
# effect of hypertension on birth weight controlled for sex
effx(bweight,exposure=hyp,control=sex,data=births)

print( options('na.action') )
# effect of gestation time on birth weight
effx(bweight,exposure=gestwks,data=births)
# effect of gestation time on birth weight stratified by sex
effx(bweight,exposure=gestwks,strata=sex,data=births)
# effect of gestation time on birth weight controlled for sex
effx(bweight,exposure=gestwks,control=sex,data=births)

# lowbw is a binary response coded 1 for low birth weight and 0 otherwise
# effect of hypertension on low birth weight
effx(lowbw,type="binary",exposure=hyp,data=births)
effx(lowbw,type="binary",exposure=hyp,eff="RR",data=births)
</code></pre>

<hr>
<h2 id='effx.match'>Function to calculate effects for individually matched case-control studies</h2><span id='topic+effx.match'></span>

<h3>Description</h3>

<p>The function calculates the effects of an exposure on a response,
possibly stratified by a stratifying variable, and/or controlled for one
or more confounding variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effx.match(response,
exposure,
match,
strata=NULL,
control=NULL,
base=1,
digits=3,
alpha=0.05,
data=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effx.match_+3A_response">response</code></td>
<td>
<p>The <code>response</code> variable - must be numeric</p>
</td></tr>
<tr><td><code id="effx.match_+3A_exposure">exposure</code></td>
<td>
<p>The <code>exposure</code> variable can be numeric or a factor</p>
</td></tr>
<tr><td><code id="effx.match_+3A_match">match</code></td>
<td>
<p>The variable which identifies the matched sets</p>
</td></tr>
<tr><td><code id="effx.match_+3A_strata">strata</code></td>
<td>
<p>The <code>strata</code> stratifying variable - must be a factor</p>
</td></tr>
<tr><td><code id="effx.match_+3A_control">control</code></td>
<td>
<p> The <code>control</code> variable(s). These are passed as a
list if there are more than one of them.</p>
</td></tr> 
<tr><td><code id="effx.match_+3A_base">base</code></td>
<td>
<p>Baseline for the effects of a categorical exposure, default 1</p>
</td></tr>
<tr><td><code id="effx.match_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits for the effects, default 3</p>
</td></tr>
<tr><td><code id="effx.match_+3A_alpha">alpha</code></td>
<td>
<p>1 - confidence level</p>
</td></tr>
<tr><td><code id="effx.match_+3A_data">data</code></td>
<td>
<p><code>data</code> refers to the data used to evaluate the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effects are calculated odds ratios.
The function is a wrapper for clogit, from the survival package.
The k-1 effects for a categorical  exposure with k levels are relative 
to a baseline which, by default, is the first level. The effect of a metric (quantitative) 
exposure is calculated per unit of exposure.
The exposure variable can be numeric or a factor, but if it is an ordered factor the order will be ignored.
</p>


<h3>Value</h3>



<table>
<tr><td><code>comp1</code></td>
<td>
<p>Effects of exposure</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Tests of significance</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Michael Hills</p>


<h3>References</h3>

<p> www.mhills.pwp.blueyonder.co.uk </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Epi)
library(survival)
data(bdendo)

# d is the case-control variable, set is the matching variable.
# The variable est is a factor and refers to estrogen use (no,yes)
# The variable hyp is a factor with 2 levels and refers to hypertension (no, yes)
# effect of est on the odds of being a case
effx.match(d,exposure=est,match=set,data=bdendo)
# effect of est on the odds of being a case, stratified by hyp
effx.match(d,exposure=est,match=set,strata=hyp,data=bdendo)
# effect of est on the odds of being a case, controlled for hyp
effx.match(d,exposure=est,match=set,control=hyp,data=bdendo)
</code></pre>

<hr>
<h2 id='entry.Lexis'>Time series and other methods for Lexis objects</h2><span id='topic+entry'></span><span id='topic+exit'></span><span id='topic+status'></span><span id='topic+dur'></span><span id='topic+transient'></span><span id='topic+absorbing'></span><span id='topic+before'></span><span id='topic+preceding'></span><span id='topic+after'></span><span id='topic+succeeding'></span>

<h3>Description</h3>

<p>Extract the entry time, exit time, status or duration of follow-up from a
<code>Lexis</code> object. Classify states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>     entry(x, time.scale = NULL, by.id=FALSE)
      exit(x, time.scale = NULL, by.id=FALSE)
    status(x, at="exit"        , by.id=FALSE)
       dur(x,                    by.id=FALSE)
 transient(x)
 absorbing(x)
 preceding(x, states)
    before(x, states)
succeeding(x, states)
     after(x, states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entry.Lexis_+3A_x">x</code></td>
<td>
<p>an object of class <code>Lexis</code>.</p>
</td></tr>
<tr><td><code id="entry.Lexis_+3A_time.scale">time.scale</code></td>
<td>
<p>a string or integer indicating the time scale. If
omitted, all times scales are used.</p>
</td></tr>
<tr><td><code id="entry.Lexis_+3A_by.id">by.id</code></td>
<td>
<p>Logical, if <code>TRUE</code>, only one record per unique value
of <code>lex.id</code> is returned; either the first, the last, or for
<code>dur</code>, the sum of <code>lex.dur</code>. If <code>TRUE</code>, the returned
object have the <code>lex.id</code> as (row)names attribute.</p>
</td></tr>
<tr><td><code id="entry.Lexis_+3A_at">at</code></td>
<td>
<p>string indicating the time point(s) at which status is to be
measured. Possible values are &quot;exit&quot; or &quot;entry&quot;.</p>
</td></tr>
<tr><td><code id="entry.Lexis_+3A_states">states</code></td>
<td>
<p>Character vector of states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>entry</code> and <code>exit</code> functions return a vector of
entry times and exit times, respectively, on the requested time
scale. If multiple time scales are requested, a matrix is
returned.
</p>
<p>The <code>status</code> function returns a vector giving the status at
&quot;<code>at</code>&quot; (either '<code>entry</code>' or '<code>exit</code>') and <code>dur</code>
returns a vector with the lengths of the follow-up intervals.
</p>
<p><code>entry</code>, <code>exit</code>, <code>status</code> and <code>dur</code> return vectors
of length <code>nrow(x)</code> if <code>by.id=FALSE</code>; if <code>by.id=TRUE</code> a
vector of length <code>length(unique(lex.id))</code>.
</p>
<p>The functions <code>transient</code> and <code>absorbing</code> return character
vectors of the transient, resp. absorbing states in <code>x</code>. These
are necessarily disjoint but the union may be a proper subset of
<code>levels(x)</code>, since the latter may have levels that are never
assumed by either <code>lex.Cst</code> or <code>lex.Xst</code>.
</p>
<p><code>preceding</code> returns a character vector with names of the states
of the Lexis object <code>x</code> from which one of the states in
<code>states</code> can be reached directly - the preceding
states. <code>before</code> is just a synonym for <code>preceding</code>.
</p>
<p><code>succeeding</code> returns a character vector with names of the states
of the Lexis object <code>x</code> that can be reached directly from one of
the states in <code>states</code>. <code>after</code> is just a synonym for
<code>succeeding</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer &amp; Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code></p>

<hr>
<h2 id='Epi'>Epi: Functions for manipulation and statistical analysis of epidemiological data</h2><span id='topic+Epi'></span><span id='topic+Epi-package'></span>

<h3>Description</h3>

<p><span class="pkg">Epi</span> has grown out of the course 'Statistical Practise in
Epidemiology with R' <a href="http://bendixcarstensen.com/SPE/">http://bendixcarstensen.com/SPE/</a>.
</p>
<p>The major contributions from this course have been the
<code><a href="#topic+stat.table">stat.table</a></code> function for advanced tabulation and summary,
and the functions for representation and the <code><a href="#topic+Lexis">Lexis</a></code>
function(s) for manipulation of multistate data with multiple time
scales.
</p>


<h3>Details</h3>

<p>Click on the <code>Index</code> link below the line to access
vignettes (tutorial documents) and an alphabetic list of the functions
in <code>Epi</code>.</p>

<hr>
<h2 id='erl'>Compute survival functions from rates and expected residual
lifetime in an illness-death model as well as years of life lost to disease.
</h2><span id='topic+surv1'></span><span id='topic+surv2'></span><span id='topic+erl1'></span><span id='topic+erl'></span><span id='topic+yll'></span>

<h3>Description</h3>

<p>These functions compute survival functions from a set of mortality and
disease incidence rates in an illness-death model. Expected residual
life time can be computed under various scenarios by the <code>erl</code>
function, and areas between survival functions can be computed under
various scenarios by the <code>yll</code> function. Rates are assumed
supplied for equidistant intervals of length <code>int</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  surv1( int, mu ,                age.in = 0, A = NULL )
   erl1( int, mu ,                age.in = 0 ) 
  surv2( int, muW, muD, lam,      age.in = 0, A = NULL )
    erl( int, muW, muD, lam=NULL, age.in = 0, A = NULL,
         immune = is.null(lam), yll=TRUE, note=TRUE )
    yll( int, muW, muD, lam=NULL, age.in = 0, A = NULL,
         immune = is.null(lam), note=TRUE )
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erl_+3A_int">int</code></td>
<td>

<p>Scalar. Length of intervals that rates refer to.    
</p>
</td></tr>
<tr><td><code id="erl_+3A_mu">mu</code></td>
<td>

<p>Numeric vector of mortality rates at midpoints of intervals of length <code>int</code>
</p>
</td></tr>
<tr><td><code id="erl_+3A_muw">muW</code></td>
<td>

<p>Numeric vector of mortality rates among persons in the &quot;Well&quot; state  at
midpoints of intervals of length <code>int</code>. Left endpoint of first
interval is <code>age.in</code>. 
</p>
</td></tr>
<tr><td><code id="erl_+3A_mud">muD</code></td>
<td>

<p>Numeric vector of mortality rates among persons in the &quot;Diseased&quot; state
at midpoints of intervals of length <code>int</code>.  Left endpoint of first
interval is <code>age.in</code>. 
</p>
</td></tr>
<tr><td><code id="erl_+3A_lam">lam</code></td>
<td>

<p>Numeric vector of disease incidence rates among persons in the &quot;Well&quot; state
at midpoints of intervals of length <code>int</code>. Left endpoint of first
interval is <code>age.in</code>. 
</p>
</td></tr>
<tr><td><code id="erl_+3A_age.in">age.in</code></td>
<td>

<p>Scalar indicating the age at the left endpoint of the first interval. 
</p>
</td></tr>
<tr><td><code id="erl_+3A_a">A</code></td>
<td>

<p>Numeric vector of conditioning ages for calculation of survival
functions.   
</p>
</td></tr>
<tr><td><code id="erl_+3A_immune">immune</code></td>
<td>

<p>Logical. Should the years of life lost to the disease be computed
using assumptions that non-diseased individuals are immune to the
disease (<code>lam</code>=0) and that their mortality is yet still <code>muW</code>.
</p>
</td></tr>
<tr><td><code id="erl_+3A_note">note</code></td>
<td>

<p>Logical. Should a warning of silly assumptions be printed?
</p>
</td></tr>
<tr><td><code id="erl_+3A_yll">yll</code></td>
<td>

<p>Logical. Should years of life lost be included in the result?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mortality rates given are supposed to refer to the ages
<code>age.in+(i-1/2)*int</code>, <code>i=1,2,3,...</code>.
</p>
<p>The units in which <code>int</code> is given must correspond to the units in
which the rates <code>mu</code>, <code>muW</code>, <code>muD</code> and <code>lam</code> are
given. Thus if <code>int</code> is given in years, the rates must be given
in the unit of events per year.
</p>
<p>The ages in which the survival curves are computed are from
<code>age.in</code> and then at the end of <code>length(muW)</code>
(<code>length(mu)</code>) intervals each of length <code>int</code>.
</p>
<p>The <code>age.in</code> argument is merely a device to account for rates
only available from a given age. It has two effects, one is that
labeling of the interval endpoint is offset by this quantity, thus
starting at <code>age.in</code>, and the other that the conditioning ages
given in the argument <code>A</code> will refer to the ages defined by this.
</p>
<p>The <code>immune</code> argument is <code>FALSE</code> whenever the disease
incidence rates are supplied. If set to <code>TRUE</code>, the years of life
lost is computed under the assumption that individuals without the
disease at a given age are immune to the disease in the sense that the
disease incidence rate is 0, so transitions to the diseased state
(with presumably higher mortality rates) are assumed not to
occur. This is a slightly peculiar assumption (but presumably the most
used in the epidemiological literature) and the resulting object is
therefore given an attribute, <code>NOTE</code>, that point this out.
</p>
<p>If however <code>muW</code> is the total mortality in the population
(including the diseased) the result is a good approximation to the
correct YLL.
</p>
<p>The default of the <code>surv2</code> function is to take the possibility of
disease into account.</p>


<h3>Value</h3>

<p><code>surv1</code> and <code>surv2</code> return a matrix whose first column
is the ages at the ends of the 
intervals, thus with <code>length(mu)+1</code> rows. The following columns
are the survival functions (since <code>age.in</code>), and conditional on
survival till ages as indicated in <code>A</code>, thus a matrix with
<code>length(A)+2</code> columns. Columns are labeled with the actual
conditioning ages; if <code>A</code> contains values that are not among the
endpoints of the intervals used, the nearest smaller interval border
is used as conditioning age, and columns are named accordingly.
</p>
<p><code>surv1</code> returns the survival function for a simple model with one
type of death, occurring at intensity <code>mu</code>.
</p>
<p><code>surv2</code> returns the survival function for a person in the &quot;Well&quot;
state of an illness-death model, taking into account that the person
may move to the &quot;Diseased&quot; state, thus requiring all three transition
rates to be specified. The conditional survival functions are
conditional on being in the &quot;Well&quot; state at ages given in <code>A</code>.
</p>
<p><code>erl1</code> returns a three column matrix with columns <code>age</code>,
<code>surv</code> (survival function) and <code>erl</code> (expected residual life
time) with <code>length(mu)+1</code> rows. 
</p>
<p><code>erl</code> returns a two column matrix, columns labeled &quot;Well&quot; and
&quot;Dis&quot;, and with row-labels <code>A</code>. The entries are the expected
residual life times given survival to <code>A</code>. If <code>yll=TRUE</code> the
difference between the columns is added as a
third column, labeled &quot;YLL&quot;.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ci.cum">ci.cum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library( Epi )
data( DMlate )
# Naive Lexis object
Lx &lt;- Lexis( entry = list( age = dodm-dobth ),
              exit = list( age = dox -dobth ),
       exit.status = factor( !is.na(dodth), labels=c("DM","Dead") ),
              data = DMlate )
# Cut follow-up at insulin inception
Lc &lt;- cutLexis( Lx, cut = Lx$doins-Lx$dob,
              new.state = "DM/ins",
       precursor.states = "DM" )
summary( Lc )
# Split in small age intervals
Sc &lt;- splitLexis( Lc, breaks=seq(0,120,2) )
summary( Sc )

# Overview of object
boxes( Sc, boxpos=TRUE, show.BE=TRUE, scale.R=100 )

# Knots for splines
a.kn &lt;- 2:9*10

# Mortality among DM
mW &lt;- glm( lex.Xst=="Dead" ~ Ns( age, knots=a.kn ),
           offset = log(lex.dur),
           family = poisson,
             data = subset(Sc,lex.Cst=="DM") )

# Mortality among insulin treated
mI &lt;- update( mW, data = subset(Sc,lex.Cst=="DM/ins") )

# Total motality
mT &lt;- update( mW, data = Sc )

# Incidence of insulin inception
lI &lt;- update( mW, lex.Xst=="DM/ins" ~ . )

# From these we can now derive the fitted rates in intervals of 1 year's
# length. In real applications you would use much smaller interval like
# 1 month:
# int &lt;- 1/12 
int &lt;- 1

# Prediction frame to return rates in units of cases per 1 year
# - we start at age 40 since rates of insulin inception are largely
# indeterminate before age 40
nd &lt;- data.frame( age = seq( 40+int, 110, int ) - int/2,
              lex.dur = 1 )
muW &lt;- predict( mW, newdata = nd, type = "response" )
muD &lt;- predict( mI, newdata = nd, type = "response" )
lam &lt;- predict( lI, newdata = nd, type = "response" )

# Compute the survival function, and the conditional from ages 50 resp. 70
s1 &lt;- surv1( int, muD, age.in=40, A=c(50,70) )
round( s1, 3 )

s2 &lt;- surv2( int, muW, muD, lam, age.in=40, A=c(50,70) )
round( s2, 3 )

# How much is YLL overrated by ignoring insulin incidence?
round( YLL &lt;- cbind(
yll( int, muW, muD, lam, A = 41:90, age.in = 40 ),
yll( int, muW, muD, lam, A = 41:90, age.in = 40, immune=TRUE ) ), 2 )[seq(1,51,10),]

par( mar=c(3,3,1,1), mgp=c(3,1,0)/1.6, bty="n", las=1 )
matplot( 40:90, YLL,
         type="l", lty=1, lwd=3,
         ylim=c(0,10), yaxs="i", xlab="Age" )
</code></pre>

<hr>
<h2 id='ewrates'>Rates of lung and nasal cancer mortality, and total mortality.</h2><span id='topic+ewrates'></span>

<h3>Description</h3>

<p>England and Wales mortality rates from lung cancer, nasal cancer,
and all causes 1936 - 1980. The 1936 rates are repeated as 1931 rates in
order to accomodate follow up for the <code><a href="#topic+nickel">nickel</a></code> study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ewrates)</code></pre>


<h3>Format</h3>

<p>A data frame with 150 observations on the following 5 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>id</code>: </td><td style="text-align: left;"> Subject identifier (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>year</code>  </td><td style="text-align: left;"> Calendar period, 1931: 1931--35, 1936: 1936--40,
    ... </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>age</code>   </td><td style="text-align: left;"> Age class: 10: 10--14, 15:15--19, ...  </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>lung</code>  </td><td style="text-align: left;"> Lung cancer mortality rate per 1,000,000 py. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>nasal</code> </td><td style="text-align: left;"> Nasal cancer mortality rate per 1,000,000 py. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>other</code> </td><td style="text-align: left;"> All cause mortality rate per 1,000,000 py.
</td>
</tr>

</table>



<h3>Source</h3>

<p>From Breslow and Day, Vol II, Appendix IX.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ewrates)
str(ewrates)
</code></pre>

<hr>
<h2 id='expand.data'>
Function to expand data for regression analysis of interval censored
data.
</h2><span id='topic+expand.data'></span>

<h3>Description</h3>

<p>This is a utility function.
</p>
<p>The original records with <code>first.well</code>, <code>last.well</code> and
<code>first.ill</code> are
expanded to multiple records; several for each interval where the
person is known to be well and one where the person is known to fail.
At the same time columns for the covariates needed to estimate rates
and the response variable are generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.data(fu, formula, breaks, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.data_+3A_fu">fu</code></td>
<td>
<p>A 3-column matrix with <code>first.well</code>, <code>last.well</code> and
<code>first.ill</code> in each row.</p>
</td></tr>
<tr><td><code id="expand.data_+3A_formula">formula</code></td>
<td>
<p>Model fromula, used to derive the model matrix.</p>
</td></tr>
<tr><td><code id="expand.data_+3A_breaks">breaks</code></td>
<td>
<p>Defines the intervals in which the baseline rate is
assumed constant. All follow-up before the first and after the
last break is discarded.</p>
</td></tr>
<tr><td><code id="expand.data_+3A_data">data</code></td>
<td>
<p>Datafrem in which <code>fu</code> and <code>formula</code> is interpreted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three components
</p>
<table>
<tr><td><code>rates.frame</code></td>
<td>
<p>Dataframe of covariates for estimation of the
baseline rates &mdash; one per interval defined by <code>breaks</code>.</p>
</td></tr>
<tr><td><code>cov.frame</code></td>
<td>
<p>Dataframe for estimation of the covariate effects. A
data-framed version of the designmatrix from <code>formula</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>
</p>


<h3>References</h3>

<p>B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Icens">Icens</a></code>
<code><a href="#topic+fit.mult">fit.mult</a></code>
<code><a href="#topic+fit.add">fit.add</a></code>
</p>

<hr>
<h2 id='fit.add'>
Fit an addive excess risk model to interval censored data.
</h2><span id='topic+fit.add'></span>

<h3>Description</h3>

<p>Utility function.
</p>
<p>The model fitted assumes a piecewise constant intensity for the
baseline, and that the covariates act additively on the rate scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fit.add( y, rates.frame, cov.frame, start )
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.add_+3A_y">y</code></td>
<td>
<p>Binary vector of outcomes</p>
</td></tr>
<tr><td><code id="fit.add_+3A_rates.frame">rates.frame</code></td>
<td>
<p>Dataframe expanded from the original data by
<code><a href="#topic+expand.data">expand.data</a></code>, cooresponding to covariates for the rate
parameters.</p>
</td></tr>
<tr><td><code id="fit.add_+3A_cov.frame">cov.frame</code></td>
<td>
<p> do., but covariates corresponding to the
<code>formula</code> argument of <code><a href="#topic+Icens">Icens</a></code></p>
</td></tr> 
<tr><td><code id="fit.add_+3A_start">start</code></td>
<td>
<p>Starting values for the rate parameters. If not supplied,
then starting values are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one component:
</p>
<table>
<tr><td><code>rates</code></td>
<td>
<p>A glm object from a binomial model with log-link function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>
</p>


<h3>References</h3>

<p>B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.
</p>
<p>CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Icens">Icens</a></code>
<code><a href="#topic+fit.mult">fit.mult</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data( HIV.dk ) 
  </code></pre>

<hr>
<h2 id='fit.baseline'>
Fit a piecewise contsnt intesity model for interval censored data.
</h2><span id='topic+fit.baseline'></span>

<h3>Description</h3>

<p>Utility function
</p>
<p>Fits a binomial model with logaritmic link, with <code>y</code> as outcome
and covariates in <code>rates.frame</code> to estimate rates in the
inttervals between <code>breaks</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.baseline( y, rates.frame, start )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.baseline_+3A_y">y</code></td>
<td>
<p>Binary vector of outcomes</p>
</td></tr>
<tr><td><code id="fit.baseline_+3A_rates.frame">rates.frame</code></td>
<td>
<p>Dataframe expanded from the original data by
<code><a href="#topic+expand.data">expand.data</a></code></p>
</td></tr> 
<tr><td><code id="fit.baseline_+3A_start">start</code></td>
<td>
<p>Starting values for the rate parameters. If not supplied,
then starting values are generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+glm">glm</a></code> object, with binomial error and logaritmic link.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.add">fit.add</a></code>
<code><a href="#topic+fit.mult">fit.mult</a></code>
</p>

<hr>
<h2 id='fit.mult'>
Fits a multiplicative relative risk model to interval censored data.
</h2><span id='topic+fit.mult'></span>

<h3>Description</h3>

<p>Utility function.
</p>
<p>The model fitted assumes a piecewise constant baseline rate in
intervals specified by the argument <code>breaks</code>, and a
multiplicative relative risk function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fit.mult( y, rates.frame, cov.frame, start )
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.mult_+3A_y">y</code></td>
<td>
<p>Binary vector of outcomes</p>
</td></tr>
<tr><td><code id="fit.mult_+3A_rates.frame">rates.frame</code></td>
<td>
<p>Dataframe expanded from the original data by
<code><a href="#topic+expand.data">expand.data</a></code>, cooresponding to covariates for the rate
parameters.</p>
</td></tr>
<tr><td><code id="fit.mult_+3A_cov.frame">cov.frame</code></td>
<td>
<p> do., but covariates corresponding to the
<code>formula</code> argument of <code><a href="#topic+Icens">Icens</a></code></p>
</td></tr> 
<tr><td><code id="fit.mult_+3A_start">start</code></td>
<td>
<p>Starting values for the rate parameters. If not supplied,
then starting values are generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by alternating between two generalized linear
models where one estimates the underlying rates in the intervals, and
the other estimates the log-relative risks.
</p>


<h3>Value</h3>

<p>A list with three components:
</p>
<table>
<tr><td><code>rates</code></td>
<td>
<p>A glm object from a binomial model with log-link,
estimating the baseline rates.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>A glm object from a binomial model with complementary
log-log link, estimating the log-rate-ratios</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Nuber of iterations, a scalar</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>,
Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a> </p>


<h3>References</h3>

<p>B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.
</p>
<p>CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Icens">Icens</a></code>
<code><a href="#topic+fit.add">fit.add</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data( HIV.dk ) 
  </code></pre>

<hr>
<h2 id='float'>Calculate floated variances</h2><span id='topic+float'></span><span id='topic+print.floated'></span>

<h3>Description</h3>

<p>Given a fitted  model object, the <code>float()</code> function calculates
floating variances (a.k.a. quasi-variances) for a given factor in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>float(object, factor, iter.max=50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="float_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="float_+3A_factor">factor</code></td>
<td>
<p>character string giving the name of the factor of
interest. If this is not given, the first factor in the model is used.</p>
</td></tr>
<tr><td><code id="float_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations for EM algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>float()</code> function implements the &quot;floating absolute risk&quot;
proposal of Easton, Peto and Babiker (1992). This is an alternative way
of presenting parameter estimates for factors in regression models,
which avoids some of the difficulties of treatment contrasts. It was
originally designed for epidemiological studies of relative risk, but
the idea is widely applicable.
</p>
<p>Treatment contrasts are not orthogonal. Consequently, the variances of
treatment contrast estimates may be inflated by a poor choice of
reference level, and the correlations between them may also be high.
The <code>float()</code> function associates each level of the factor with a
&quot;floating&quot; variance (or quasi-variance), including the reference
level.  Floating variances are not real variances, but they can be
used to calculate the variance error of contrast by treating each
level as independent.
</p>
<p>Plummer (2003) showed that floating variances can be derived from a
covariance structure model applied to the variance-covariance matrix
of the contrast estimates. This model can be fitted by minimizing the
Kullback-Leibler information divergence between the true distribution
of the parameter estimates and the simplified distribution given by
the covariance structure model. Fitting is done using the EM
algorithm.
</p>
<p>In order to check the goodness-of-fit of the floating variance model,
the <code>float()</code> function compares the standard errors predicted by
the model with the standard errors derived from the true
variance-covariance matrix of the parameter contrasts. The maximum and
minimum ratios between true and model-based standard errors are
calculated over all possible contrasts. These should be within 5
percent, or the use of the floating variances may lead to invalid
confidence intervals.
</p>


<h3>Value</h3>

<p>An object of class <code>floated</code>. This is a list with the following
components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>A vector of coefficients. These are the same as the
treatment contrasts but the reference level is present with
coefficient 0.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>A vector of floating (or quasi-) variances</p>
</td></tr>
<tr><td><code>limits</code></td>
<td>
<p>The bounds on the accuracy of standard errors over all
possible contrasts</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Menezes(1999) and Firth and Menezes (2004) take a slightly different
approach to this problem, using a pseudo-likelihood approach to fit
the quasi-variance model. Their work is implemented in the package
qvcalc.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Easton DF, Peto J and Babiker GAG (1991) Floating absolute risk: An
alternative to relative risk in survival and case control analysis
avoiding an arbitrary reference group. <em>Statistics in Medicine</em>,
<b>10</b>, 1025-1035.
</p>
<p>Firth D and Mezezes RX (2004)  Quasi-variances.
<em>Biometrika</em> <b>91</b>, 65-80.
</p>
<p>Menezes RX(1999)  More useful standard errors for group and factor
effects in generalized linear models.  <em>D.Phil. Thesis</em>,
Department of Statistics, University of Oxford.
</p>
<p>Plummer M (2003) Improved estimates of floating absolute risk,
<em>Statistics in Medicine</em>, <b>23</b>, 93-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ftrend">ftrend</a></code>, <code>qvcalc</code></p>

<hr>
<h2 id='foreign.Lexis'>Create a data structures suitable for use with packages <code>mstate</code> or <code>etm</code>.
</h2><span id='topic+msdata'></span><span id='topic+msdata.Lexis'></span><span id='topic+etm'></span><span id='topic+etm.Lexis'></span>

<h3>Description</h3>

<p>The <code>mstate</code> package requires input in the form of a stacked
dataset with specific variable names. This is provided by
<code>msdata.Lexis</code>. The resulting dataframe contains the same
information as the result of a call to <code><a href="#topic+stack.Lexis">stack.Lexis</a></code>.
</p>
<p>The <code>etm</code> package requires input (almost) in the form of a
<code>Lexis</code> object, but with specific column names etc. This is
provided by <code>etm.Lexis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msdata(obj, ...)
## S3 method for class 'Lexis'
msdata(obj,
                time.scale = timeScales(obj)[1],
                       ... )
## S3 method for class 'Lexis'
etm( data,
               time.scale = timeScales(data)[1],
                cens.name = "cens",
                        s = 0,
                        t = "last",
               covariance = TRUE,
                 delta.na = TRUE,
                      ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreign.Lexis_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_time.scale">time.scale</code></td>
<td>
<p>Name or number of timescale in the <code>Lexis</code>
object.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_cens.name">cens.name</code></td>
<td>
<p>Name of the code for censoring used by <code>etm</code>. It
is only necessary to change this if one of the states in the
<code>Lexis</code> object has name &quot;<code>cens</code>&quot;.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_s">s</code></td>
<td>
<p>Passed on to <code>etm</code>.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_t">t</code></td>
<td>
<p>Passed on to <code>etm</code>.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_covariance">covariance</code></td>
<td>
<p>Passed on to <code>etm</code>.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_delta.na">delta.na</code></td>
<td>
<p>Passed on to <code>etm</code>.</p>
</td></tr>
<tr><td><code id="foreign.Lexis_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>msdata.Lexis</code> returns a dataframe with the <code>Lexis</code> specific
variables stripped, and with the following added: <code>id</code>,
<code>Tstart</code>, <code>Tstop</code>, <code>from</code>, <code>to</code>, <code>trans</code>,
<code>status</code>, which are used in the <code>mstate</code> package.
</p>
<p><code>etm.Lexis</code> transforms the <code>Lexis</code> object into a dataframe
suitable for analysis by the function <code>etm</code> from the <code>etm</code>
package, and actually calls this function, so returns an object of
class <code>etm</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stack.Lexis">stack.Lexis</a></code>,
<code><a href="mstate.html#topic+msprep">msprep</a></code>,
<code><a href="etm.html#topic+etm">etm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
str(DMlate)
dml &lt;- Lexis( entry = list(Per=dodm,Age=dodm-dobth,DMdur=0),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate[1:1000,] )
dmi &lt;- cutLexis( dml, cut=dml$doins, new.state="Ins", pre="DM" )
summary( dmi )

# Use the interface to the mstate package
if( require(mstate) )
{
ms.dmi &lt;- msdata.Lexis( dmi )
# Check that all the transitions and person-years got across.
with( ms.dmi, rbind( table(status,trans),
                     tapply(Tstop-Tstart,trans,sum) ) )
}

# Use the etm package directly with a Lexis object
if( require(etm) )
{
dmi &lt;- subset(dmi,lex.id&lt;1000)
etm.D &lt;- etm.Lexis( dmi, time.scale=3 )
str( etm.D )
plot( etm.D, col=rainbow(5), lwd=2, lty=1, xlab="DM duration" )
}
</code></pre>

<hr>
<h2 id='ftrend'>Fit a floating trend to a factor in generalized linear model</h2><span id='topic+ftrend'></span>

<h3>Description</h3>

<p>Fits a &quot;floating trend&quot; model to the given factor in a glm in a generalized
linear model by centering covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftrend(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftrend_+3A_object">object</code></td>
<td>
<p>fitted <code>lm</code> or <code>glm</code> object. The model must not have an intercept term</p>
</td></tr>
<tr><td><code id="ftrend_+3A_...">...</code></td>
<td>
<p>arguments to the <code>nlm</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ftrend()</code> calculates &quot;floating trend&quot; estimates for factors in
generalized linear models.  This is an alternative to treatment
contrasts suggested by Greenland et al. (1999).  If a regression model
is fitted with no intercept term, then contrasts are  not used for the
first factor in the model. Instead, there is one parameter  for each
level of this factor.  However, the interpretation of these
parameters,  and their variance-covariance matrix, depends on the
numerical coding used for the  covariates. If an arbitrary constant is
added to the covariate values, then   the variance matrix is changed.
</p>
<p>The <code>ftrend()</code> function takes the fitted model and works out an optimal
constant to add to the covariate values so that the covariance matrix is
approximately diagonal.  The parameter estimates can then be treated as
approximately independent, thus simplifying their presentation. This is
particularly useful for graphical display of dose-response relationships
(hence the name).
</p>
<p>Greenland et al. (1999) originally suggested centring the covariates so that
their weighted mean, using the fitted weights from the model, is zero.  This
heuristic criterion is improved upon by <code>ftrend()</code> which uses the same
minimum information divergence criterion as used by Plummer (2003) for
floating variance calculations. <code>ftrend()</code> calls <code>nlm()</code> to
do the minimization and will pass optional arguments to control it.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>coefficients for model with adjusted covariates.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Variance-covariance matrix of adjusted coefficients.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The &quot;floating trend&quot; method is an alternative to the &quot;floating
absolute risk&quot; method, which is implemented in the function
<code>float()</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Greenland S, Michels KB, Robins JM, Poole C and Willet WC (1999)
Presenting statistical uncertainty in trends and dose-response relations,
<em>American Journal of Epidemiology</em>, <b>149</b>, 1077-1086.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+float">float</a></code></p>

<hr>
<h2 id='gen.exp'>
Generate covariates for drug-exposure follow-up from drug purchase records.
</h2><span id='topic+gen.exp'></span>

<h3>Description</h3>

<p>From records of drug purchase and possibly known treatment intensity,
the time since first drug use and cumulative dose at prespecified times
is computed. Optionally, lagged exposures are computed too,
i.e. cumulative exposure a prespecified time ago.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.exp( purchase, id="id", dop="dop", amt="amt", dpt="dpt",
               fu, doe="doe", dox="dox",
           breaks,
          use.dpt = ( dpt %in% names(purchase) ),
         push.max = Inf,
          rm.dose = FALSE,
             lags = NULL,
          lag.dec = 1,
          lag.pre = "lag.",
         pred.win = Inf )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.exp_+3A_purchase">purchase</code></td>
<td>
<p>Data frame with columns <code>id</code>-person id,
<code>dop</code> - <code>d</code>ate <code>o</code>f <code>p</code>urchase, <code>amt</code> -
<code>am</code>oun<code>t</code> purchased, and optionally <code>dpt</code> -
(<code>d</code>ose <code>p</code>er <code>t</code>ime) (&quot;defined daily dose&quot;, DDD,
that is), how much is assumed to be ingested per unit time. The
units used for <code>dpt</code> is assumed to be units of <code>amt</code> per
units of <code>dop</code>.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_id">id</code></td>
<td>
<p>Character. Name of the id variable in the data frame.</p>
</td></tr>
<tr><td><code id="gen.exp_+3A_dop">dop</code></td>
<td>
<p>Character. Name of the <code>d</code>ate <code>o</code>f
<code>p</code>urchase variable in the data frame.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_amt">amt</code></td>
<td>
<p>Character. Name of the <code>am</code>oun<code>t</code> purchased
variable in the data frame.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_dpt">dpt</code></td>
<td>
<p>Character. Name of the <code>d</code>ose-<code>p</code>er-<code>t</code>ime
variable in the data frame.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_fu">fu</code></td>
<td>
<p>Data frame with <code>f</code>ollow-<code>u</code>p period for each
person, the person id variable must have the same name as in the
<code>purchase</code> data frame.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_doe">doe</code></td>
<td>
<p>Character. Name of the <code>d</code>ate <code>o</code>f <code>e</code>ntry
variable.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_dox">dox</code></td>
<td>
<p>Character. Name of the <code>d</code>ate <code>o</code>f e<code>x</code>it
variable.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_breaks">breaks</code></td>
<td>
<p>Numerical vector of dates at which the time since first
exposure, cumulative dose etc. are computed.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_use.dpt">use.dpt</code></td>
<td>
<p>Logical: should we use information on dose per time.</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_push.max">push.max</code></td>
<td>
<p>Numerical. How much can purchases maximally be pushed
forward in time. See details.</p>
</td></tr>
<tr><td><code id="gen.exp_+3A_rm.dose">rm.dose</code></td>
<td>
<p>Logical. Should the dose from omitted period of
exposure (due to the setting of <code>push.max</code>) be ignored. If
<code>FALSE</code>, the cumulative dose will be the cumulation of the
actually purchased amounts, regardless of how far the inception
dates have been pushed.</p>
</td></tr>
<tr><td><code id="gen.exp_+3A_lags">lags</code></td>
<td>
<p>Numerical vector of lag-times used in computing lagged
cumulative doses.</p>
</td></tr>
<tr><td><code id="gen.exp_+3A_lag.dec">lag.dec</code></td>
<td>
<p>How many decimals to use in the construction of names
for the lagged exposure variables</p>
</td></tr> 
<tr><td><code id="gen.exp_+3A_lag.pre">lag.pre</code></td>
<td>
<p>Character string used for prefixing names of lagged
exposure variables. Aimed to facilitate the use of <code>gen.exp</code>
for different drugs with the aim of merging information.</p>
</td></tr>
<tr><td><code id="gen.exp_+3A_pred.win">pred.win</code></td>
<td>
<p>The length of the window used for constructing the
average dose per time used to compute the duration of the last
purchase. Only used when <code>use.dpt=FALSE</code>. The default value
<code>Inf</code> corresponds to using the time between first and last
purchase of drug as the interval for computing average consumption
per time, and thus the termination of use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intention of this function is to generate covariates for a
particular drug for the entire follow-up of each person. The reason
that the follow-up prior to first drug purchase and post-exposure is
included is that the covariates must be defined for all follow-up for
each person in order to be useful for analysis of disease outcomes.
</p>
<p>The functionality is described in terms of calendar time as underlying
time scale, because this will normally be the time scale for drug
purchases and for entry and exit for persons. In principle the
variables termed as dates might equally well refer to say the age
scale, but this would then have to be true <em>both</em> for the
purchase data, the follow-up data and the <code>breaks</code> argument.  
</p>
<p>Drug purchase records (in <code>purchase</code>) are used to construct
measures of drug exposure at prespecified timepoints (in
<code>breaks</code>) in follow-up intervals (in <code>fu</code>). Each person may
have more than one follow-up interval. They should be disjoint, but
this is not checked.
</p>
<p>If <code>use.dpt</code> is <code>TRUE</code> then the dose per time information is
used to compute the exposure interval associated with each purchase.
Exposure intervals are stacked, that is each interval is put after any
previous. This means that the start of exposure to a given purchase
can be pushed into the future. The parameter <code>push.max</code> indicates
the maximally tolerated push. If this is reached by a person, the
assumption is that some of the purchased drug may not be counted in
the exposure calculations &mdash; see <code>rm.dose</code>.
</p>
<p>The <code>dpt</code> can either be a constant, basically translating each
purchased amount into exposure time the same way for all persons, or
it can be a vector with different treatment intensities for each
purchase. In any case the cumulative dose is computed taking
<code>dpt</code> into account, unless <code>rm.dose</code> is <code>FALSE</code> in
which case the actual purchased amount is cumulated. The latter is
slightly counter-intuitive because we are using the <code>dpt</code> to push
the intervals, and then disregard it when computing the cumulative
dose. The counter argument is that if the limit <code>push.max</code> is
reached, the actual dosage may be larger than indicated the
<code>dpt</code>, and is essentially what this allows for.
</p>
<p>If <code>use.dpt</code> is <code>FALSE</code> then the exposure from one purchase
is assumed to stretch over the time to the next purchase, so we are
effectively allowing different dosing rates (dose per time) between
purchases. Formally this approach conditions on the future, because
the rate of consumption (the accumulation of cumulative exposure) is
computed based on knowledge of when next purchase is made. Moreover,
with this approach, periods of non-exposure does not exist, except
after the last purchase where the future consumption rate is taken to
be the average over the period of use (or a period of length
<code>pred.win</code>), and hence defines a date of cessation of drug.
</p>
<p>Finally, if <code>use.dpt</code> is <code>FALSE</code>, at least two purchase
records are required to compute the measures. Therefore persons with
only one drug purchase record are ignored in calculations.
</p>


<h3>Value</h3>

<p>A data frame with one record per person and follow-up date
(<code>breaks</code>). Date of entry and date of exit are included too; but
only follow-up in the intersetion of <code>range(breaks)</code> and
<code>range(fu$doe,fu$dox)</code> is output.
</p>

<dl>
<dt><code>id</code></dt><dd><p>person id.</p>
</dd>
<dt><code>dof</code></dt><dd><p>date of follow up, i.e. start of interval. Apart
from possibly the first interval for each person, this will assume
values in the set of the values in <code>breaks</code>. All other variables
refer to status as of this date.</p>
</dd>
<dt><code>dur</code></dt><dd><p>the length (<code>dur</code>ation) of interval.</p>
</dd>
<dt><code>tfi</code></dt><dd><p><code>t</code>ime <code>f</code>rom first <code>i</code>nitiation of drug.</p>
</dd>
<dt><code>off</code></dt><dd><p>Logical, indicating whether the person is
<code>off</code> drug. So it is <code>FALSE</code> if the person is exposed at <code>dof</code>.</p>
</dd> 
<dt><code>doff</code></dt><dd><p><code>d</code>ate of latest transition to <code>off</code>
drug. Note that tis defined also at dates after drug exposure has been
resumed.</p>
</dd>
<dt><code>tfc</code></dt><dd><p><code>t</code>ime <code>f</code>rom latest <code>c</code>essation of drug.</p>
</dd>
<dt><code>ctim</code></dt><dd><p><code>c</code>umulative <code>tim</code>e on the drug.</p>
</dd>
<dt><code>cdos</code></dt><dd><p><code>c</code>umulative <code>dos</code>e.</p>
</dd>
<dt><code>ldos</code></dt><dd><p>suffixed with one value per element in
<code>lags</code>, the latter giving the cumulative doses <code>lags</code> before
<code>dof</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>.  The development of
this function was supported partly through a grant from the EFSD
(European Foundation for the Study of Diabetes)</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>, 
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example data for drug purchases in 3 persons --- dates (dop) are
# measured in years, amount purchased (amt) in no. pills and dose per
# time (dpt) consequently given in units of pills/year. Note we also
# include a person (id=4) with one purchase record only.
n &lt;- c( 10, 18, 8, 1 )
hole &lt;- rep(0,n[2])
hole[10] &lt;- 2 # to create a hole of 2 years in purchase dates
# dates of drug purchase
dop &lt;- c( 1995.278+cumsum(sample(1:4/10,n[1],replace=TRUE)),
          1992.351+cumsum(sample(1:4/10,n[2],replace=TRUE)+hole),
          1997.320+cumsum(sample(1:4/10,n[3],replace=TRUE)),
          1996.470 )
# purchased amounts mesured in no. pills
amt &lt;- sample( 1:3*50 , sum(n), replace=TRUE )
# prescribed dosage therefore necessarily as pills per year 
dpt &lt;- sample( 4:1*365, sum(n), replace=TRUE )
# collect to purchase data frame
dfr &lt;- data.frame( id = rep(1:4,n),
                  dop,
                  amt = amt,
                  dpt = dpt )
head( dfr, 3 )

# a simple dataframe for follow-up periods for these 4 persons
fu &lt;- data.frame( id = 1:4,
                 doe = c(1995,1992,1996,1997)+1:4/4,
                 dox = c(2001,2003,2002,2010)+1:4/5 )
fu

# Note that the following use of gen.exp relies on the fact that the
# purchase dataframe dfr has variable names "id", "dop", "amt" and
# "dpt"" and the follow-up data frame fu has variable names "id",
# "doe" and "dox"

# 1: using the dosage information
dposx &lt;- gen.exp( dfr,
                   fu = fu,
              use.dpt = TRUE,
               breaks = seq(1990,2015,0.5),
                 lags = 2:4/4,
              lag.pre = "l_" )
format( dposx, digits=5 )

# 2: ignoring the dosage information,
#    hence person 4 with only one purchase is omitted
xposx &lt;- gen.exp( dfr,
                   fu = fu,
              use.dpt = FALSE,
               breaks = seq(1990,2015,0.5),
                 lags = 2:3/5 )
format( xposx, digits=5 )

# It is possible to have disjoint follow-up periods for the same person:
fu &lt;- fu[c(1,2,2,3),]
fu$dox[2] &lt;- 1996.2
fu$doe[3] &lt;- 1998.3
fu

# Note that drug purchase information for the period not at risk *is* used
dposx &lt;- gen.exp( dfr,
                   fu = fu,
              use.dpt = TRUE,
               breaks = seq(1990,2015,0.1),
                 lags = 2:4/4 )
format( dposx, digits=5 )
</code></pre>

<hr>
<h2 id='gmortDK'>Population mortality rates for Denmark in 5-years age groups.</h2><span id='topic+gmortDK'></span>

<h3>Description</h3>

<p>The <code>gmortDK</code> data frame has 418 rows and 21 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>agr</code>: </td><td style="text-align: left;"> Age group, 0:0--4, 5:5--9,..., 90:90+. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>per</code>: </td><td style="text-align: left;"> Calendar period, 38: 1938--42, 43: 1943--47, ..., 88:1988-92. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>sex</code>: </td><td style="text-align: left;"> Sex, 1: male, 2: female. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>risk</code>: </td><td style="text-align: left;"> Number of person-years in the Danish population. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dt</code>: </td><td style="text-align: left;"> Number of deaths. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>rt</code>: </td><td style="text-align: left;"> Overall mortality rate in cases per 1000 person-years, i.e.
<code>rt=1000*dt/risk</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
           </td><td style="text-align: left;"> Cause-specific mortality rates in cases per 1000 person-years: </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r1</code>: </td><td style="text-align: left;"> Infections </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r2</code>: </td><td style="text-align: left;"> Cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r3</code>: </td><td style="text-align: left;"> Tumors, benign, unspecific nature. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r4</code>: </td><td style="text-align: left;"> Endocrine, metabolic. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r5</code>: </td><td style="text-align: left;"> Blood. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r6</code>: </td><td style="text-align: left;"> Nervous system, psychiatric. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r7</code>: </td><td style="text-align: left;"> Cerebrovascular. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r8</code>: </td><td style="text-align: left;"> Cardiac. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r9</code>: </td><td style="text-align: left;"> Respiratory diseases, excl. cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r10</code>: </td><td style="text-align: left;"> Liver, excl. cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r11</code>: </td><td style="text-align: left;"> Digestive, other. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r12</code>: </td><td style="text-align: left;"> Genitourinary. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r13</code>: </td><td style="text-align: left;"> Ill-defined symptoms. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r14</code>: </td><td style="text-align: left;"> All other, natural. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r15</code>: </td><td style="text-align: left;"> Violent. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Statistics Denmark, National board of health provided original data. 
Michael Andersson grouped the causes of death.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thoro">thoro</a></code>, <code><a href="#topic+mortDK">mortDK</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmortDK)
</code></pre>

<hr>
<h2 id='harm'>Create a basis of harmonic functions.
</h2><span id='topic+harm'></span>

<h3>Description</h3>

<p>Returns a matrix of harmonic functions usable for modeling
periodic effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harm(x, ord=1, per=1, verbose=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harm_+3A_x">x</code></td>
<td>
<p>A numeric variable.
</p>
</td></tr>
<tr><td><code id="harm_+3A_ord">ord</code></td>
<td>
<p>Integer, the order of the harmonic.
</p>
</td></tr>
<tr><td><code id="harm_+3A_per">per</code></td>
<td>
<p>Numeric, the length of the period on the <code>x</code> scale.
</p>
</td></tr>
<tr><td><code id="harm_+3A_verbose">verbose</code></td>
<td>
<p>Logical: shall I tell what I do with dates?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns are constructed under the assumption that the periodic function
has period <code>per</code> on the <code>x</code> scale. Thus, the first columns
is defined as <code>sin(2*pi*x/per)</code>, <code>cos(2*pi*x/per)</code>,
<code>sin(4*pi*x/per)</code> etc.
</p>
<p>Since <code>sin</code> and <code>cos</code> are periodic functions there is no
requirement that <code>x</code> be in any particular range.
</p>


<h3>Value</h3>

<p>A matrix with <code>nrow(x)</code> rows and
2*<code>deg</code> columns and columnnames
<code>sin1</code>, <code>cos1</code>,
<code>sin2</code>, <code>cos2</code> etc.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-1,1,0.01)
head( harm(x,ord=2) )
matplot( x, harm(x,ord=2), type="l", lty=1, lwd=3 )
</code></pre>

<hr>
<h2 id='Icens'>
Fits a regression model to interval censored data.
</h2><span id='topic+Icens'></span><span id='topic+print.Icens'></span>

<h3>Description</h3>

   
<p>The models fitted assumes a piecewise constant baseline rate in
intervals specified by the argument <code>breaks</code>, and for the
covariates either a multiplicative relative risk function (default) or
an additive excess risk function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Icens( first.well, last.well, first.ill,
         formula, model.type=c("MRR","AER"), breaks,
         boot=FALSE, alpha=0.05, keep.sample=FALSE,
         data )
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Icens_+3A_first.well">first.well</code></td>
<td>
<p>Time of entry to the study, i.e. the time first seen
without event. Numerical vector.</p>
</td></tr>
<tr><td><code id="Icens_+3A_last.well">last.well</code></td>
<td>
<p>Time last seen without event. Numerical vector.</p>
</td></tr>
<tr><td><code id="Icens_+3A_first.ill">first.ill</code></td>
<td>
<p>Time first seen with event. Numerical vector.</p>
</td></tr>
<tr><td><code id="Icens_+3A_formula">formula</code></td>
<td>
<p>Model formula for the log relative risk.</p>
</td></tr>
<tr><td><code id="Icens_+3A_model.type">model.type</code></td>
<td>
<p>Which model should be fitted.</p>
</td></tr>
<tr><td><code id="Icens_+3A_breaks">breaks</code></td>
<td>
<p>Breakpoints between intervals in which the underlying
timescale is assumed constant. Any observation outside the range of
<code>breaks</code> is discarded.</p>
</td></tr>
<tr><td><code id="Icens_+3A_boot">boot</code></td>
<td>
<p>Should bootstrap be performed to produce confidence
intervals for parameters. If a number is given this will be the
number of bootsrap samples. The default is 1000.</p>
</td></tr>
<tr><td><code id="Icens_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level.</p>
</td></tr>
<tr><td><code id="Icens_+3A_keep.sample">keep.sample</code></td>
<td>
<p>Should the bootstrap sample of the parameter values
be returned?</p>
</td></tr> 
<tr><td><code id="Icens_+3A_data">data</code></td>
<td>
<p>Data frame in which the times and formula are interpreted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is fitted by calling either <code><a href="#topic+fit.mult">fit.mult</a></code> or
<code><a href="#topic+fit.add">fit.add</a></code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"Icens"</code>: a list with three components:
</p>
<table>
<tr><td><code>rates</code></td>
<td>
<p>A glm object from a binomial model with log-link,
estimating the baseline rates, and the excess risk if <code>"AER"</code>
is specfied.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>A glm object from a binomial model with complementary
log-log link, estimating the log-rate-ratios. Only if <code>"MRR"</code>
is specfied.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>Nuber of iterations, a scalar</p>
</td></tr>
<tr><td><code>boot.ci</code></td>
<td>
<p>If <code>boot=TRUE</code>, a 3-column matrix with estimates
and 1-<code>alpha</code> confidence intervals for the parameters in the model.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A matrix of the parameterestimates from the
bootstrapping. Rows refer to parameters, columns to bootstrap samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>,
Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a> </p>


<h3>References</h3>

<p>B Carstensen: Regression models for interval censored
survival data: application to HIV infection in Danish homosexual
men. Statistics in Medicine, 15(20):2177-2189, 1996.
</p>
<p>CP Farrington: Interval censored survival data: a generalized linear
modelling approach. Statistics in Medicine, 15(3):283-292, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.add">fit.add</a></code>
<code><a href="#topic+fit.mult">fit.mult</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( hivDK )
# Convert the dates to fractional years so that rates are
# expressed in cases per year
for( i in 2:4 ) hivDK[,i] &lt;- cal.yr( hivDK[,i] )

m.RR &lt;- Icens( entry, well, ill,
               model="MRR", formula=~pyr+us, breaks=seq(1980,1990,5),
               data=hivDK)
# Currently the MRR model returns a list with 2 glm objects.
round( ci.lin( m.RR$rates ), 4 )
round( ci.lin( m.RR$cov, Exp=TRUE ), 4 )
# There is actually a print method:
print( m.RR )

m.ER &lt;- Icens( entry, well, ill,
               model="AER", formula=~pyr+us, breaks=seq(1980,1990,5),
               data=hivDK)
# There is actually a print method:
print( m.ER )
  </code></pre>

<hr>
<h2 id='in.span'>
Is <code>x</code> in the column span of matrix <code>A</code> and what columns are
linearly dependent?
</h2><span id='topic+in.span'></span><span id='topic+inSpan'></span><span id='topic+id.span'></span><span id='topic+idSpan'></span><span id='topic+thinCol'></span>

<h3>Description</h3>

<p>The function <code>in.span</code> checks if the vector <code>x</code> (or
columns of the matrix <code>x</code>) is in the column span of the matrix
<code>A</code>. If desired, it returns the coefficient matrix <code>B</code> so that
<code>AB=x</code>. The function <code>thinCol</code> removes linearly dependent
columns an returns a matrix of full rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.span( A,
         x,
      coef = FALSE,
       tol = 1e-08 )
inSpan( A, x, coef=FALSE, tol=1e-08 )
id.span( A, B, tol=1e-08 )
idSpan( A, B, tol=1e-08 )
thinCol( A, tol = 1e-06, col.num = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.span_+3A_a">A</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="in.span_+3A_b">B</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="in.span_+3A_x">x</code></td>
<td>
<p>A vector or matrix. <code>length(x)</code> (or <code>nrow(x)</code>) must
be equal to <code>nrow(A)</code>.</p>
</td></tr> 
<tr><td><code id="in.span_+3A_coef">coef</code></td>
<td>
<p>Logical. Should the coefficient matrix (<code>k</code>) be
returned, so that <code>Ak=x</code>?</p>
</td></tr>
<tr><td><code id="in.span_+3A_tol">tol</code></td>
<td>
<p>Tolerance for identity of matrices in check
(<code>in.span</code>) or QR decomposition (<code>thinCol</code>)</p>
</td></tr>
<tr><td><code id="in.span_+3A_col.num">col.num</code></td>
<td>
<p>Logical. Should the positions of dependent columns be
returned instead of the full-rank matrix?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+thinCol">thinCol</a></code> is mainly a workhorse in
<code><a href="#topic+detrend">detrend</a></code>, but made available because of its general
usefulness. 
</p>
<p><code>in.span</code> and <code>inSpan</code> are just different names for the same
to accommodate different naming schools.
</p>
<p><code>in.span</code> (<code>inSpan</code>) is handy in checking whether different
parametrizations of a model are identical in the sense of spanning the
same linear space. Equivalent to checking whether fitted values under
different parametrizations are identical, but has the further use of
checking if subspaces of models are equivalent. The function
simply checks if the regression of (columns of) <code>x</code> on the
columns of <code>A</code> produces residuals that are all 0.
</p>
<p><code>id.span</code> (equivalent to <code>idSpan</code>) checks whether two
matrices have the same column span.  
</p>


<h3>Value</h3>

<p><code>in.span</code> returns a logical: is <code>x</code> is in
<code>span(A)</code>? If <code>coef=TRUE</code> it returns a matrix <code>k</code> so
that <code>Ak=x</code>. <code>k</code> is not necessarily unique (A may not have
full rank).
</p>
<p><code>id.span</code> returns a logical: is <code>span(A)</code> the same as
<code>span(B)</code>? 
</p>
<p><code>thinCol</code> returns a matrix of full rank, formed from <code>A</code> by
deleting columns linearly dependent on other. If <code>col.num=TRUE</code>
(one possible set of) positions of columns forming a full rank basis
for the column space of <code>A</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a> with essential
help from Lars Jorge Diaz and Peter Dalgaard.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+det">det</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrices and vectors, x in span(A), z (hopefully) not
A &lt;- matrix(round(rnorm(15)*20),5,3)
B &lt;- matrix(round(rnorm(15)*20),5,3)
B &lt;- cbind( B, B%*%c(3,4,2) )
x &lt;- A %*% c(3,4,2)
z &lt;- 5:9

# how they look
data.frame( A=A, x=x, z=z, B=B )

# vectors in span(A)?
in.span(A,x)
in.span(x,A)
in.span(A,x,coef=TRUE)

in.span(A,z)
in.span(A,z,coef=TRUE)

# Do matrices span the same space ?
in.span( A, B )
in.span( B, A )

# B is not in span of a subspace of B columns, but vice versa
( M &lt;- matrix( rnorm(8)*7, 4, 2 ) )
in.span( B%*%M, B )
in.span( B, B%*%M )
id.span( B, B%*%M )

# But not unique for singular matrices:
( xx &lt;- in.span( B, B%*%M, coef=TRUE ) )
cbind( B%*%M, B%*%xx )
cbind( xx, M )

# Easier for full rank matrices:
( K &lt;- matrix( rnorm(9)*7, 3, 3 ) )
in.span( A%*%K, A )
in.span( A, A%*%K )
id.span( A, A%*%K )
in.span( A, A%*%K, coef=TRUE )
</code></pre>

<hr>
<h2 id='LCa.fit'>
Fit Lee-Carter-type models for rates to arbitrarily shaped observations
of rates in a Lexis diagram. 
</h2><span id='topic+LCa.fit'></span><span id='topic+print.LCa'></span><span id='topic+summary.LCa'></span><span id='topic+plot.LCa'></span><span id='topic+predict.LCa'></span>

<h3>Description</h3>

<p>The Lee-Carter model is originally defined as a model for rates
observed in A-sets (age by period) of a Lexis diagram, as
log(rate(x,t)) = a(x) + b(x)k(t), using one parameter per age(x) and
period(t). This function uses natural splines for a(), b() and k(),
placing knots for each effect such that the number of events is the
same between knots. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCa.fit( data, A, P, D, Y,
         model = "APa",    # or one of "ACa", "APaC", "APCa" or "APaCa" 
         a.ref,            # age reference for the interactions
        pi.ref = a.ref,    # age reference for the period interaction
        ci.ref = a.ref,    # age reference for the cohort interaction
         p.ref,            # period reference for the interaction
         c.ref,            # cohort reference for the interactions
          npar = c(a = 6,  # no. knots for main age-effect
                   p = 6,  # no. knots for period-effect
                   c = 6,  # no. knots for cohort-effect
                  pi = 6,  # no. knots for age in the period interaction
                  ci = 6), # no. knots for age in the cohort interaction
            VC = TRUE,     # numerical calculation of the Hessian?
         alpha = 0.05,     # 1 minus confidence level
           eps = 1e-6,     # convergence criterion
         maxit = 100,      # max. no iterations
         quiet = TRUE )    # cut the crap
## S3 method for class 'LCa'
print( x, ... )
## S3 method for class 'LCa'
summary( object, show.est=FALSE, ... )
## S3 method for class 'LCa'
plot( x, ... )
## S3 method for class 'LCa'
predict( object, newdata,
                        alpha = 0.05,
                        level = 1-alpha,
                          sim = ( "vcov" %in% names(object) ),
                          ... )
      </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LCa.fit_+3A_data">data</code></td>
<td>

<p>A data frame. Must have columns <code>A</code>(age), <code>P</code>(period, that is
calendar time), <code>D</code>(no. of events) and <code>Y</code>(person-time,
exposure). Alternatively these four quantities can be given as
separate vectors:
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_a">A</code></td>
<td>

<p>Vector of ages (midpoint of observation).
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_p">P</code></td>
<td>

<p>Vector of period (midpoint of observation).
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_d">D</code></td>
<td>

<p>Vector of no. of events.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_y">Y</code></td>
<td>

<p>Vector of person-time. Demographers would say &quot;exposure&quot;, bewildering epidemiologists.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_a.ref">a.ref</code></td>
<td>

<p>Reference age for the age-interaction term(s) <code>pi(x)</code> and/or
<code>pi(x)</code>, where <code>pi(a.ref)=1</code> and <code>ci(a.ref)=1</code>.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_pi.ref">pi.ref</code></td>
<td>

<p>Same, but specifically for the interaction with period.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_ci.ref">ci.ref</code></td>
<td>

<p>Same, but specifically for the interaction with cohort.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_p.ref">p.ref</code></td>
<td>

<p>Reference period for the time-interaction term <code>kp(t)</code> where <code>kp(p.ref)=0</code>.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_c.ref">c.ref</code></td>
<td>

<p>Reference period for the time-interaction term <code>kp(t)</code> where <code>kc(c.ref)=0</code>.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_model">model</code></td>
<td>

<p>Character, either <code>"APa"</code> which is the classical Lee-Carter model
for log-rates, other possibilities are <code>"ACa"</code>, <code>"APCa"</code>,
<code>"APaC"</code> or <code>"APaCa"</code>, see details.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_npar">npar</code></td>
<td>

<p>A (possibly named) vector or list, with either the number of knots or
the actual vectors of knots for each term. If unnamed, components are
taken to be in the order (a,b,t), if the model is &quot;APaCa&quot; in the order
(a,p,c,pi,ci).  If a vector, the three integers indicate the number of
knots for each term; these will be placed so that there is an equal
number of events (<code>D</code>) between each, and half as many below the
first and above the last knot. If <code>npar</code> is a list of scalars the
behavior is the same. If <code>npar</code> is a list of vectors, these are
taken as the knots for the natural splines. See details for naming
convention. 
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_vc">VC</code></td>
<td>

<p>Logical. Should the variance-covariance matrix of the parameters be
computed by numerical differentiation? See details.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_alpha">alpha</code></td>
<td>

<p>1 minus the confidence level used when calculating
confidence intervals for estimates in <code>LCa.fit</code> and for
predictions by <code>predict.LCa</code>.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_eps">eps</code></td>
<td>

<p>Convergence criterion for the deviance, we use the the relative
difference between deviance from the two models fitted.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_maxit">maxit</code></td>
<td>

<p>Maximal number of iterations.
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_quiet">quiet</code></td>
<td>

<p>Shall I shut up or talk extensively to you about iteration progression etc.?
</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_object">object</code></td>
<td>
<p>An <code>LCa</code> object, see under &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_show.est">show.est</code></td>
<td>
<p>Logical. Should the estimates be printed?</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_x">x</code></td>
<td>
<p>An <code>LCa</code> object, see under &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_newdata">newdata</code></td>
<td>
<p>Prediction data frame, must have columns <code>A</code> and
<code>P</code>. Any <code>Y</code> column is ignored, predictions are given in
units of the <code>Y</code> supplied for the call that generated the
<code>LCa</code> object.</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_sim">sim</code></td>
<td>
<p>Logical or numeric. If <code>TRUE</code>, prediction c.i.s will be
based on 1000 simulations from the posterior parameters. If numeric,
it will be based on that number of simulations.</p>
</td></tr>
<tr><td><code id="LCa.fit_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to the method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lee-Carter model is non-linear in age and time so does not fit
in the classical glm-Poisson framework. But for fixed <code>b(x)</code> it
is a glm, and also for fixed <code>a(x)</code>, <code>k(t)</code>. The function
alternately fits the two versions until the same fit is produced (same
deviance).
</p>
<p>The multiplicative age by period term could equally well have been a
multiplicative age by cohort or even both. Thus the most extensive
model has 5 continuous functions:
</p>
<p style="text-align: center;"><code class="reqn">\log(\lambda(a,p)) = f(a) + b_p(a)k_p(p) + b_c(a)k_c(p-a)</code>
</p>

<p>Each of these is fitted by a natural spline, with knots placed at the
quantiles of the events along the age (a), calendar time (p) respective
cohort (p-a) scales. Alternatively the knots can be specified explicitly
in the argument <code>npar</code> as a named list, where
<code>a</code> refers to <code class="reqn">f(a)</code>,
<code>p</code> refers to <code class="reqn">k_p(p)</code>,
<code>c</code> refers to <code class="reqn">k_c(p-a)</code>,
<code>pi</code> (<code>p</code>eriod codeinteraction) refers to <code class="reqn">b_p(a)</code>
and
<code>ci</code> (<code>c</code>ohort <code>i</code>nteraction) refers to <code class="reqn">b_c(p-a)</code>.
</p>
<p>The naming convention for the models is a capital <code>P</code> and/or
<code>C</code> if the effect is in the model followed by a lower case
<code>a</code> if there is an interaction with age. Thus there are 5 different
models that can be fitted: <code>APa</code>, <code>ACa</code>, <code>APaC</code>  <code>APCa</code>
and <code>APaCa</code>.
</p>
<p>The standard errors of the parameters from the two separate model fits
in the iterations are however wrong; they are conditional on a subset
of the parameters having a fixed value. However, analytic calculation
of the Hessian is a bit of a nightmare, so this is done numerically
using the <code>hessian</code> function from the <code>numDeriv</code> package if
<code>VC=TRUE</code>.
</p>
<p>The coefficients and the variance-covariance matrix of these are used
in <code>predict.LCa</code> for a parametric bootstrap (that is, a
simulation from a multivariate normal with mean equal to the parameter
estimates and variance as the estimated variance-covariance) to get
confidence intervals for the predictions if <code>sim</code> is <code>TRUE</code>
&mdash; which it is by default if they are part of the object.
</p>
<p>The <code>plot</code> for <code>LCa</code> objects merely produces between 3 and 5
panels showing each of the terms in the model. These are mainly for
preliminary inspection; real reporting of the effects should use
proper relative scaling of the effects.</p>


<h3>Value</h3>

<p><code>LCa.fit</code> returns an object of class <code>LCa</code> (smooth
effects <code>L</code>ee-<code>Ca</code>rter model); it is a list with the
following components:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>Character, either <code>APa</code>, <code>ACa</code>, <code>APaC</code>,
<code>APCa</code> or <code>APaCa</code>, indicating the variable(s) interacting
with age.</p>
</td></tr> 
<tr><td><code>ax</code></td>
<td>
<p>3-column matrix of age-effects, c.i. from the age-time
model. Row names are the unique occurring ages in the
dataset. Estimates are rates.</p>
</td></tr>  
<tr><td><code>pi</code></td>
<td>
<p>3-column matrix of age-period interaction effects, c.i. from the age
model. Row names are the actually occurring ages in the
dataset. Estimates are multipliers of the log-RRs in <code>kp</code>,
centered at 1 at <code>pi.ref</code>.</p>
</td></tr>
<tr><td><code>kp</code></td>
<td>
<p>3-column matrix of period-effects, with c.i.s from the
age-time model. Row names are the actually occurring times in the 
dataset. Estimates are rate-ratios centered at 1 at <code>p.ref</code>.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>3-column matrix of age-cohort interaction effects, c.i. from the age
model. Row names are the actually occurring ages in the
dataset. Estimates are multipliers of the log-RRs in <code>kc</code>,
centered at 1 at <code>ci.ref</code>.</p>
</td></tr>
<tr><td><code>kc</code></td>
<td>
<p>3-column matrix of cohort-effects, with c.i.s from the age-time
model. Row names are the actually occurring times in the
dataset. Estimates are rate-ratios centered at 1 at <code>c.ref</code>.</p>
</td></tr>
<tr><td><code>mod.at</code></td>
<td>
<p><code>glm</code> object with the final age-time model &mdash; estimates
the terms <code>ax</code>, <code>kp</code>, <code>kc</code>. Gives
the same fit as the <code>mod.b</code> model after convergence.</p>
</td></tr>
<tr><td><code>mod.b</code></td>
<td>
<p><code>glm</code> object with the final age model &mdash; estimates
the terms <code>pi</code>, <code>ci</code>. Gives
the same fit as the <code>mod.at</code> model after convergence.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>All coefficients from both models, in the order <code>ax</code>,
<code>kp</code>, <code>kc</code>, <code>pi</code>, <code>ci</code>. Only present if
<code>LCa.fit</code> were called with <code>VC=TRUE</code> (the default).</p>
</td></tr> 
<tr><td><code>vcov</code></td>
<td>
<p>Variance-covariance matrix of coefficients from both
models, in the same order as in the <code>coef</code>. Only present if
<code>LCa.fit</code> were called with <code>VC=TRUE</code>.</p>
</td></tr> 
<tr><td><code>knots</code></td>
<td>
<p>List of vectors of knots used in for the age, period and
cohort effects.</p>
</td></tr>
<tr><td><code>refs</code></td>
<td>
<p>List of reference points used for the age, period and
cohort terms in the interactions.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations used to reach convergence.</p>
</td></tr>
</table>
<p><code>plot.LCa</code> plots the estimated effects in separate panels,
using a log-scale for the baseline rates (<code>ax</code>) and the time-RR
(<code>kt</code>). For the <code>APaCa</code> model 5 panels are plotted.
</p>
<p><code>summary.LCa</code> returns (invisibly) a matrix with the parameters
from the models and a column of the conditional se.s and additionally
of the se.s derived from the numerically computed Hessian (if
<code>LCa.fit</code> were called with <code>VC=TRUE</code>.)
</p>
<p><code>predict.LCa</code> returns a matrix with one row per row in
<code>newdata</code>. If <code>LCa.fit</code> were called with <code>VC=TRUE</code>
there will be 3 columns, namely prediction (1st column) and c.i.s
based on a simulation of parameters from a multivariate normal with
mean <code>coef</code> and variance <code>vcov</code> using the median and
<code>alpha</code>/2 quantiles from the <code>sim</code> simulations.  If
<code>LCa.fit</code> were called with <code>VC=FALSE</code> there will be 6
columns, namely estimates and c.i.s from age-time model
(<code>mod.at</code>), and from the age-interaction model (<code>mod.b</code>),
both using conditional variances, and therefore likely with too narrow
confidence limits.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>
<p>This function was conceived while teaching a course on APC models at
the Max Planck Institute of Demographic Research (MPIDR,
<a href="https://www.demogr.mpg.de/en/">https://www.demogr.mpg.de/en/</a>) in Rostock in May 2016
(<a href="http://bendixcarstensen.com/APC/MPIDR-2016/">http://bendixcarstensen.com/APC/MPIDR-2016/</a>), and finished
during a week long research stay there, kindly sponsored by the MPIDR.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.fit">apc.fit</a></code>,
<code><a href="#topic+apc.LCa">apc.LCa</a></code>,
<code><a href="demography.html#topic+lca">lca</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library( Epi )
# Load the testis cancer data by Lexis triangles
data( testisDK )
tc &lt;- subset( testisDK, A&gt;14 &amp; A&lt;60 )
head( tc )

# We want to see rates per 100,000 PY
tc$Y &lt;- tc$Y / 10^5

# Fit the Lee-Carter model with age-period interaction (default)
LCa.tc &lt;- LCa.fit( tc, model="ACa", a.ref=30, p.ref=1980, quiet=FALSE, eps=10e-4, maxit=50 )

LCa.tc
summary( LCa.tc )

# Inspect what we got
names( LCa.tc )

# show the estimated effects
par( mfrow=c(1,3) )
plot( LCa.tc )

# Prediction data frame for ages 15 to 60 for two time points: 
nd &lt;- data.frame( A=15:60 )
# LCa predictions
p70 &lt;- predict.LCa( LCa.tc, newdata=cbind(nd,P=1970), sim=1000 )
p90 &lt;- predict.LCa( LCa.tc, newdata=cbind(nd,P=1990), sim=1000 )

# Inspect the curves from the parametric bootstrap (simulation):
par( mfrow=c(1,1) )
head( cbind(p70,p90) )
matplot( nd$A, cbind(p70,p90), type="l", lwd=c(6,3,3), lty=c(1,3,3),
         col=rep( 2:3, each=3 ), log="y",
         ylab="Testis cancer incidence per 100,000 PY in 1970 resp. 1990", xlab="Age" )
</code></pre>

<hr>
<h2 id='lep'>An unmatched case-control study of leprosy incidence</h2><span id='topic+lep'></span>

<h3>Description</h3>

<p>The <code>lep</code> data frame has 1370 rows and 7 columns. This was an
unmatched case-control study in which incident cases of leprosy in a
region of N. Malawi were compared with population controls. 
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>id</code>: </td><td style="text-align: left;"> subject identifier: a numeric vector </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>d</code>: </td><td style="text-align: left;"> case/control status: a numeric vector (1=case, 0=control) </td>
</tr>
<tr>
 <td style="text-align: right;">

<code>age</code>: </td><td style="text-align: left;"> a factor with levels
<code>5-9</code> 
<code>10-14</code> 
<code>15-19</code> 
<code>20-24</code> 
<code>25-29</code> 
<code>30-44</code> 
<code>45+</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">

<code>sex</code>: </td><td style="text-align: left;"> a factor with levels
<code>male</code>,  
<code>female</code>  </td>
</tr>
<tr>
 <td style="text-align: right;"> 

<code>bcg</code>: </td><td style="text-align: left;"> presence of vaccine scar, a factor with levels
<code>no</code> 
<code>yes</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">

<code>school</code>: </td><td style="text-align: left;"> schooling, a factor with levels
<code>none</code> 
<code>1-5yrs</code> 
<code>6-8yrs</code> 
<code>sec/tert</code> </td>
</tr>
<tr>
 <td style="text-align: right;">

<code>house</code>: </td><td style="text-align: left;"> housing, a factor with levels
<code>brick</code> 
<code>sunbrick</code> 
<code>wattle</code> 
<code>temp</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>The study is described in more detail in Clayton and Hills, Statistical
Models in Epidemiology, Oxford University Press, Oxford:1993.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lep)
</code></pre>

<hr>
<h2 id='Lexis'>Create a Lexis object of follow-up</h2><span id='topic+Lexis'></span><span id='topic+print.Lexis'></span>

<h3>Description</h3>

<p>Create an object of class <code>Lexis</code> to represent follow-up in
multiple states on multiple time scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lexis( entry,
        exit,
    duration,
entry.status = 0,
 exit.status = 0,
          id,
        data,
       merge = TRUE,
      states,
       notes = TRUE,
         tol = .Machine$double.eps^0.5,
keep.dropped = FALSE)
## S3 method for class 'Lexis'
print(x, ...,
                      td = 2,
                      nd = 3,
                    rnam = FALSE,
                     org = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lexis_+3A_entry">entry</code></td>
<td>
<p>a named list of entry times. Each element of the list is
a numeric variable representing the entry time on the named time
scale. The name of the elements of the list will appear as names of
variables designated as timescales in the resulting object. All time
scales must have the same units (e.g. years). 
The names of the timescales must be different from any column name in
<code>data</code>.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_exit">exit</code></td>
<td>
<p>a named list of exit times.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_duration">duration</code></td>
<td>
<p>a numeric vector giving the duration of follow-up.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_entry.status">entry.status</code></td>
<td>
<p>a vector or a factor giving the status at
entry</p>
</td></tr>
<tr><td><code id="Lexis_+3A_exit.status">exit.status</code></td>
<td>
<p>a vector or factor giving status at exit. Any
change in status during follow-up is assumed to take place exactly
at the exit time.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_id">id</code></td>
<td>
<p>a vector giving a unique identity value for each person
represented in the Lexis object. Defaults to <code>1:nrow(data)</code></p>
</td></tr>
<tr><td><code id="Lexis_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment containing
the variables. If  not found in <code>data</code>, the variables are
taken from the environment from which <code>Lexis</code> was called.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_merge">merge</code></td>
<td>
<p>a logical flag. If <code>TRUE</code> then the <code>data</code>
argument will be coerced to a data frame and then merged with
the resulting <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_states">states</code></td>
<td>
<p>A vector of labels for the states. If given, the state
variables <code>lex.Cst</code> and <code>lex.Xst</code> are returned as factors with
identical levels attributes equal to <code>states</code>.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_notes">notes</code></td>
<td>
<p>Logical. Should notes on entry states and time be given.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for follow-up time. Rows with duration
less than this value are automatically dropped.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_keep.dropped">keep.dropped</code></td>
<td>
<p>Logical. Should dropped rows from <code>data</code> be
saved as an attribute with the object for inspection?</p>
</td></tr>
<tr><td><code id="Lexis_+3A_x">x</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_td">td</code></td>
<td>
<p>Number of digits after the decimal separator used for
timescales and <code>lex.dur</code> when printing</p>
</td></tr>
<tr><td><code id="Lexis_+3A_nd">nd</code></td>
<td>
<p>Number of digits after the decimal separator used for other
numerical variables in the <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="Lexis_+3A_rnam">rnam</code></td>
<td>
<p>Logical, should row names be printed?</p>
</td></tr>
<tr><td><code id="Lexis_+3A_org">org</code></td>
<td>
<p>Logical, should columns be printed in the original order?</p>
</td></tr>
<tr><td><code id="Lexis_+3A_...">...</code></td>
<td>
<p>Other parameters passed on to <code>print.data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis of long-term population-based follow-up studies typically
requires multiple time scales to be taken into account, such as
age, calender time, or time since an event. A <code>Lexis</code> object is
a data frame with additional attributes that allows these multiple time
dimensions of follow-up to be managed.
</p>
<p>Separate variables for current end exit state allows representation of
multistate data.
</p>
<p>Lexis objects are named after the German demographer Wilhelm
Lexis (1837-1914), who is credited with the invention of the
&quot;Lexis diagram&quot; for representing population dynamics simultaneously
by several timescales in the book
&quot;Einleitung in die Theorie der Bevolkerungsstatistik&quot; from 1875. 
</p>
<p>The <code>Lexis</code> function can create a minimal <code>Lexis</code> object
with only those variables required to define the follow-up history in
each row. Additional variables can be merged into the <code>Lexis</code>
object using the <code>merge</code> method for <code>Lexis</code> objects. The
latter is the default.
</p>
<p>The <code>print</code> method prints the time-scale variables and other
numerical variables rounded, possibly differently. Reorders columns so
the Lexis-specific variables comes first. Returns (invisibly) a character
vector with the (re)ordering of the columns in the object, even if
<code>org = TRUE</code> is set.
</p>
<p>There are also <code>merge</code>, <code>subset</code>, <code>transform</code> and many
other methods for <code>Lexis</code> objects. They work as the corresponding
methods for data-frames but ensures that the result is a <code>Lexis</code>
object.
</p>


<h3>Value</h3>

<p>An object of class <code>Lexis</code>. This is represented as a data frame
with a column for each time scale (with names equal to the union of
the names of <code>entry</code> and <code>exit</code>), and additional columns with the
following names:
</p>
<table>
<tr><td><code>lex.id</code></td>
<td>
<p>Identification of the persons.</p>
</td></tr>
<tr><td><code>lex.dur</code></td>
<td>
<p>Duration of follow-up.</p>
</td></tr>
<tr><td><code>lex.Cst</code></td>
<td>
<p>Entry status (<code>C</code>urrent <code>st</code>ate),
i.e. the state in which the follow up takes place.</p>
</td></tr>
<tr><td><code>lex.Xst</code></td>
<td>
<p>Exit status (e<code>X</code>it <code>st</code>ate),
i.e. that state taken up after <code>dur</code> in <code>lex.Cst</code>.</p>
</td></tr>
</table>
<p>If <code>merge=TRUE</code> (the default) then the <code>Lexis</code> object will
also contain all variables from the <code>data</code> argument.
</p>


<h3>Note</h3>

<p>Only two of the three arguments <code>entry</code>, <code>exit</code> and
<code>duration</code> need to be given.  If the third parameter is missing,
it is imputed.
</p>
<p><code>entry</code>, <code>exit</code> must be numeric, using  <code><a href="base.html#topic+Date">Date</a></code>
variables will cause some of the utilities to crash. Transformation by
<code><a href="#topic+cal.yr">cal.yr</a></code> is recommended.
</p>
<p>If only either <code>exit</code> or <code>duration</code> are supplied it is
assumed that <code>entry</code> is 0. This is only meaningful (and therefore
checked) if there is only one timescale.
</p>
<p>If any of <code>entry.status</code> or <code>exit.status</code> are of mode character,
they will both be converted to factors.
</p>
<p>If <code>entry.status</code> is not given, then its class is automatically
set to that of <code>exit.status</code>. If <code>exit.status</code> is a
character or factor, the value of <code>entry.status</code> is set to the
first level. This may be highly undesirable, and therefore noted. For
example, if <code>exit.status</code> is character the first level will be
the first in the alphabetical ordering; slightly unfortunate if values
are <code>c("Well","Diseased")</code>. If <code>exit.status</code> is logical, the
value of <code>entry.status</code> set to <code>FALSE</code>. If
<code>exit.status</code> is numeric, the value of <code>entry.status</code> set to
0.
</p>
<p>If <code>entry.status</code> or <code>exit.status</code> are factors or character,
the corresponding state variables in the returned <code>Lexis</code> object,
<code>lex.Cst</code> and <code>lex.Xst</code> will be (unordered) factors with
identical set of levels, namely the union of the levels of
<code>entry.status</code> and <code>exit.status</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer with contributions from Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Lexis">plot.Lexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>,
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+rcutLexis">rcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,



<code><a href="#topic+merge.Lexis">merge.Lexis</a></code>,
<code><a href="#topic+subset.Lexis">subset.Lexis</a></code>,
<code><a href="#topic+cbind.Lexis">cbind.Lexis</a></code>,
<code><a href="#topic+rbind.Lexis">rbind.Lexis</a></code>,
<code><a href="#topic+transform.Lexis">transform.Lexis</a></code>,
<code><a href="#topic+summary.Lexis">summary.Lexis</a></code>,
<code><a href="#topic+timeScales">timeScales</a></code>,
<code><a href="#topic+timeBand">timeBand</a></code>,
<code><a href="#topic+entry">entry</a></code>,
<code><a href="#topic+exit">exit</a></code>,
<code><a href="#topic+transient">transient</a></code>,
<code><a href="#topic+absorbing">absorbing</a></code>,
<code><a href="#topic+dur">dur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- structure(list( id = c("A", "B", "C"),
                     birth = c("14/07/1952", "01/04/1954", "10/06/1987"),
                     entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                      exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                      fail = c(1, 0, 1) ),
                    .Names = c("id", "birth", "entry", "exit", "fail"),
                 row.names = c("1", "2", "3"),
                     class = "data.frame")

# Convert the character dates into numerical variables (fractional years)
xcoh &lt;- cal.yr(xcoh, format="%d/%m/%Y", wh=2:4)
# xcoh &lt;- cal.yr(xcoh, format="%d/%m/%Y", wh=2:4)

# See how it looks
xcoh
str( xcoh )

# Define a Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis(entry = list(per = entry ),
               exit = list(per = exit,
                           age = exit - birth),
        exit.status = fail,
               data = xcoh)

# Using character states may have undesired effects:
xcoh$Fail &lt;- c("Dead","Well","Dead")
xcoh
L1 &lt;- Lexis(entry = list(per = entry),
             exit = list(per = exit,
                         age = exit - birth),
      exit.status = Fail,
             data = xcoh)
L1
# people start being dead!

# ...unless you order the levels sensibly
xcoh$Fail &lt;- factor(xcoh$Fail, levels = c("Well", "Dead"))
L2 &lt;- Lexis(entry = list(per = entry),
             exit = list(per = exit,
                         age = exit - birth),
      exit.status = Fail,
             data = xcoh)
L2
# behaviour of print method:
L2[,1:6]
L2[,6:1]
print(L2[,6:1], org=TRUE)
(print(L2[,-3]))
</code></pre>

<hr>
<h2 id='Lexis.diagram'>Plot a Lexis diagram</h2><span id='topic+Lexis.diagram'></span>

<h3>Description</h3>

<p>Draws a Lexis diagram, optionally with life lines from a cohort, and
with lifelines of a cohort if supplied. Intended for presentation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lexis.diagram( age = c( 0, 60), 
              alab = "Age",
              date = c( 1940, 2000 ),
              dlab = "Calendar time",
               int = 5,
           lab.int = 2*int, 
          col.life = "black",
          lwd.life = 2,
          age.grid = TRUE,
         date.grid = TRUE,
          coh.grid = FALSE,
          col.grid = gray(0.7),
          lwd.grid = 1,     
               las = 1,
        entry.date = NA,
         entry.age = NA,
         exit.date = NA,
          exit.age = NA,
         risk.time = NA,
        birth.date = NA,
              fail = NA,
          cex.fail = 1.1, 
          pch.fail = c(NA,16),
          col.fail = rep( col.life, 2 ),
              data = NULL, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lexis.diagram_+3A_age">age</code></td>
<td>
<p>Numerical vector of length 2, giving the age-range for the diagram</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_alab">alab</code></td>
<td>
<p>Label on the age-axis.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_date">date</code></td>
<td>
<p>Numerical vector of length 2, giving the calendar
time-range for the diagram</p>
</td></tr> 
<tr><td><code id="Lexis.diagram_+3A_dlab">dlab</code></td>
<td>
<p>label on the calendar time axis.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_int">int</code></td>
<td>
<p>The interval between grid lines in the diagram. If a
vector of length two is given, the first value will be used for
spacing of age-grid and the second for spacing of the date grid.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_lab.int">lab.int</code></td>
<td>
<p>The interval between labelling of the grids.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_col.life">col.life</code></td>
<td>
<p>Colour of the life lines.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_lwd.life">lwd.life</code></td>
<td>
<p>Width of the life lines.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_age.grid">age.grid</code></td>
<td>
<p>Should grid lines be drawn for age?</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_date.grid">date.grid</code></td>
<td>
<p>Should grid lines be drawn for date?</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_coh.grid">coh.grid</code></td>
<td>
<p>Should grid lines be drawn for birth cohorts (diagonals)?</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_col.grid">col.grid</code></td>
<td>
<p>Colour of the grid lines.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_lwd.grid">lwd.grid</code></td>
<td>
<p>Width of the grid lines.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_las">las</code></td>
<td>
<p>How are the axis labels plotted?</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_entry.date">entry.date</code>, <code id="Lexis.diagram_+3A_entry.age">entry.age</code>, <code id="Lexis.diagram_+3A_exit.date">exit.date</code>, <code id="Lexis.diagram_+3A_exit.age">exit.age</code>, <code id="Lexis.diagram_+3A_risk.time">risk.time</code>, <code id="Lexis.diagram_+3A_birth.date">birth.date</code></td>
<td>
<p>Numerical vectors defining lifelines to be plotted
in the diagram. At least three must be given to produce lines.
Not all subsets of three will suffice, the given subset has to 
define life lines.
If insufficient data is given, no life
lines are produced.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_fail">fail</code></td>
<td>
<p>Logical of event status at exit for the persons whose 
life lines are plotted.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_pch.fail">pch.fail</code></td>
<td>
<p>Symbols at the end of the life lines for censorings
(<code>fail==0</code>) and failures (<code>fail != 0</code>).</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_cex.fail">cex.fail</code></td>
<td>
<p>Expansion of the status marks at the end of life lines.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_col.fail">col.fail</code></td>
<td>
<p>Character vector of length 2 giving the colour of the
failure marks for censorings and failures respectively.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_data">data</code></td>
<td>
<p>Dataframe in which to interpret the arguments.</p>
</td></tr>
<tr><td><code id="Lexis.diagram_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to the initial call to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default unit for supplied variables are (calendar) years.
If any of the variables <code>entry.date</code>, <code>exit.date</code> or
<code>birth.date</code> are of class &quot;<code>Date</code>&quot; or if any of the variables
<code>entry.age</code>, <code>exit.age</code> or <code>risk.time</code> are of class
&quot;<code>difftime</code>&quot;, they will be converted to calendar years, and plotted
correctly in the diagram. The returned dataframe will then have colums of
classes &quot;<code>Date</code>&quot; and  &quot;<code>difftime</code>&quot;.
</p>


<h3>Value</h3>

<p>If sufficient information on lifelines is given, a data frame with
one row per person and columns with entry ages and dates, birth date,
risk time and status filled in.
</p>
<p>Side effect: a plot of a Lexis diagram is produced with the life lines
in it is produced. This will be the main reason for using the
function. If the primary aim is to illustrate follow-up of a cohort, then
it is better to represent the follow-up in a <code><a href="#topic+Lexis">Lexis</a></code> object, and
use the generic <code><a href="#topic+plot.Lexis">plot.Lexis</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Life.lines">Life.lines</a></code>,
<code><a href="#topic+Lexis.lines">Lexis.lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lexis.diagram( entry.age = c(3,30,45),
               risk.time = c(25,5,14),
              birth.date = c(1970,1931,1925.7),
                    fail = c(TRUE,TRUE,FALSE) )
LL &lt;- Lexis.diagram( entry.age = sample( 0:50, 17, replace=TRUE ),
                     risk.time = sample( 5:40, 17, r=TRUE),
                    birth.date = sample( 1910:1980, 17, r=TRUE ),
          		  fail = sample( 0:1, 17, r=TRUE ), 
	              cex.fail = 1.1,
	              lwd.life = 2 )
# Identify the persons' entry and exits
text( LL$exit.date, LL$exit.age, paste(1:nrow(LL)), col="red", font=2, adj=c(0,1) )
text( LL$entry.date, LL$entry.age, paste(1:nrow(LL)), col="blue", font=2, adj=c(1,0) )
data( nickel )
attach( nickel )
LL &lt;- Lexis.diagram( age=c(10,100), date=c(1900,1990), 
	             entry.age=age1st, exit.age=ageout, birth.date=dob, 
		     fail=(icd %in% c(162,163)), lwd.life=1,
		     cex.fail=0.8, col.fail=c("green","red") )
abline( v=1934, col="blue" )
nickel[1:10,]
LL[1:10,]
</code></pre>

<hr>
<h2 id='Lexis.lines'>Draw life lines in a Lexis diagram.</h2><span id='topic+Lexis.lines'></span>

<h3>Description</h3>

<p>Add life lines to a Lexis diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lexis.lines( entry.date = NA,
              exit.date = NA,
             birth.date = NA,
              entry.age = NA,
               exit.age = NA,
              risk.time = NA,
               col.life = "black",
               lwd.life = 2,
                   fail = NA,
               cex.fail = 1,
               pch.fail = c(NA, 16),
               col.fail = col.life,
                   data = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lexis.lines_+3A_entry.date">entry.date</code>, <code id="Lexis.lines_+3A_entry.age">entry.age</code>, <code id="Lexis.lines_+3A_exit.date">exit.date</code>, <code id="Lexis.lines_+3A_exit.age">exit.age</code>, <code id="Lexis.lines_+3A_risk.time">risk.time</code>, <code id="Lexis.lines_+3A_birth.date">birth.date</code></td>
<td>
<p>Numerical vectors defining lifelines to be plotted
in the diagram. At least three must be given to produce lines.
Not all subsets of three will suffice, the given subset has to 
define life lines. If insufficient data is given, no life
lines are produced.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_col.life">col.life</code></td>
<td>
<p>Colour of the life lines.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_lwd.life">lwd.life</code></td>
<td>
<p>Width of the life lines.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_fail">fail</code></td>
<td>
<p>Logical of event status at exit for the persons whose 
life lines are plotted.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_cex.fail">cex.fail</code></td>
<td>
<p>The size of the status marks at the end of life lines.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_pch.fail">pch.fail</code></td>
<td>
<p>The status marks at the end of the life lines.</p>
</td></tr>
<tr><td><code id="Lexis.lines_+3A_col.fail">col.fail</code></td>
<td>
<p>Colour of the marks for censorings and failures
respectively.</p>
</td></tr> 
<tr><td><code id="Lexis.lines_+3A_data">data</code></td>
<td>
<p>Data frame in which to interpret values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If sufficient information on lifelines is given, a data frame with one
row per person and columns with entry ages and dates, birth date, risk
time and status filled in.
</p>
<p>Side effect: Life lines are added to an existing Lexis
diagram. Lexis.lines adds life lines to an existing plot. 
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis.diagram">Lexis.diagram</a></code>,
<code><a href="#topic+Life.lines">Life.lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lexis.diagram( entry.age = c(3,30,45),
               risk.time = c(25,5,14),
              birth.date = c(1970,1931,1925.7),
                    fail = c(TRUE,TRUE,FALSE) )
Lexis.lines( entry.age = sample( 0:50, 100, replace=TRUE ),
             risk.time = sample( 5:40, 100, r=TRUE),
            birth.date = sample( 1910:1980, 100, r=TRUE ),
                  fail = sample(0:1,100,r=TRUE),
              cex.fail = 0.5,
              lwd.life = 1 )
</code></pre>

<hr>
<h2 id='Lexis2msm'>Convert a Lexis obejct to a data set suitable for input to the
<code>msm:msm</code> function.</h2><span id='topic+Lexis2msm'></span>

<h3>Description</h3>

<p>The number of records in the resulting dataset will have a
number of records that is normally <code>nrec(Lx) + <a href="#topic+nid">nid</a>(Lx)</code>, that is
one extra record for each person. If there are 'holes' in persons'
follow-up, each hole will also generate an extra record in the result. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lexis2msm(Lx,
       state = "state",
     verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lexis2msm_+3A_lx">Lx</code></td>
<td>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object.
</p>
</td></tr>
<tr><td><code id="Lexis2msm_+3A_state">state</code></td>
<td>

<p>Character; the name of the state variable in the result.
</p>
</td></tr>
<tr><td><code id="Lexis2msm_+3A_verbose">verbose</code></td>
<td>

<p>If true, you will be reminded what the function did.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>msmLexis</code> with the timescales preserved and <code>lex.id</code>
preserved but with other <code>lex.</code> variables removed. 
</p>
<p>Has more records than the original <code>Lexis</code> object
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(mcutLexis)
# we now have the Lexis object L3:
summary(L3)

# data frame for use with msm
msm3 &lt;- Lexis2msm(L3)

# see the difference 
subset(  L3, lex.id %in% 1:3)
subset(msm3, lex.id %in% 1:3)
timeScales(msm3)
</code></pre>

<hr>
<h2 id='lgrep'>
Convenience versions of grep
</h2><span id='topic+fgrep'></span><span id='topic+ngrep'></span><span id='topic+lgrep'></span>

<h3>Description</h3>

<p>Often you want the elements of a vector (or its names or levels) that
meet a certain pattern. But <code>grep</code> only gives you the position, so
these functions are designed to give you that. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgrep( pattern, x, ... )
ngrep( pattern, x, ... )
lgrep( pattern, x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgrep_+3A_pattern">pattern</code></td>
<td>
<p>Pattern searched for.</p>
</td></tr>
<tr><td><code id="lgrep_+3A_x">x</code></td>
<td>
<p>Object where <code>pattern</code> is searched. Or in whose <code>names</code>
or <code>levels</code> attributes <code>pattern</code> is sought.</p>
</td></tr>
<tr><td><code id="lgrep_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Elements of the input <code>x</code> (<code>fgrep</code>) or its names
attribute (<code>ngrep</code>) or levels attribute (<code>lgrep</code>).
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- factor( ll &lt;- paste( sample( letters[1:3], 20, replace=TRUE ),
                           sample( letters[1:3], 20, replace=TRUE ), sep="" ) )
ff
fgrep( "a", ff )
fgrep( "a", ll )
ngrep( "a", ff )
lgrep( "a", ff )
lgrep( "a", ff, invert=TRUE )
</code></pre>

<hr>
<h2 id='Life.lines'>
Compute dates/ages for life lines in a Lexis diagram
</h2><span id='topic+Life.lines'></span>

<h3>Description</h3>

<p>Fills out the missing information for follow up of persons in a Lexis
diagram if sufficient information is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Life.lines( entry.date = NA,
             exit.date = NA,
            birth.date = NA,
             entry.age = NA,
              exit.age = NA,
             risk.time = NA )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Life.lines_+3A_entry.date">entry.date</code>, <code id="Life.lines_+3A_exit.date">exit.date</code>, <code id="Life.lines_+3A_birth.date">birth.date</code>, <code id="Life.lines_+3A_entry.age">entry.age</code>, <code id="Life.lines_+3A_exit.age">exit.age</code>, <code id="Life.lines_+3A_risk.time">risk.time</code></td>
<td>
<p>Vectors defining lifelines to be plotted 
in the diagram. At least three must be given to produce a result.
Not all subsets of three will suffice, the given subset has to 
define life lines. If insufficient data is given, nothing is
returned and a warning is given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with variables <code>entry.date</code>, <code>entry.age</code>,
<code>exit.date</code>, <code>exit.age</code>, <code>risk.time</code>,
<code>birth.date</code>, with all entries computed for each person. If any
of <code>entry.date</code>, <code>exit.date</code> or <code>birth.date</code> are of
class <code>Date</code> or if any of <code>entry.age</code>, <code>exit.age</code> or
<code>risk.time</code> are of class <code>difftime</code> the date variables will
be of class  <code>Date</code> and the other three of class
<code>difftime</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis.diagram">Lexis.diagram</a></code>,
<code><a href="#topic+Lexis.lines">Lexis.lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( Life.lines( entry.age = c(3,30,45),
              risk.time = c(25,5,14),
             birth.date = c(1970,1931,1925.7) ) )

# Draw a Lexis diagram
Lexis.diagram()

# Compute entry and exit age and date.
( LL &lt;-  Life.lines( entry.age = c(3,30,45),
                     risk.time = c(25,5,14),
                    birth.date = c(1970,1931,1925.7) ) )
segments( LL[,1], LL[,2], LL[,3], LL[,4] ) # Plot the life lines.

# Compute entry and exit age and date, supplying a date variable
bd &lt;- ( c(1970,1931,1925.7) - 1970 ) * 365.25
class( bd ) &lt;- "Date"
( Life.lines( entry.age = c(3,30,45),
              risk.time = c(25,5,14),
             birth.date = bd ) )
</code></pre>

<hr>
<h2 id='lls'>Functions to manage and explore the workspace
</h2><span id='topic+lls'></span><span id='topic+clear'></span>

<h3>Description</h3>

<p>These functions help you to find out what has gone wrong and to
start afresh if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lls(pos = 1, pat = "", all=FALSE, print=TRUE )
clear()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lls_+3A_pos">pos</code></td>
<td>
<p>Numeric. What position in the search path do you want listed.</p>
</td></tr>
<tr><td><code id="lls_+3A_pat">pat</code></td>
<td>
<p>Character. List only objects that have this string in their name.</p>
</td></tr>
<tr><td><code id="lls_+3A_all">all</code></td>
<td>
<p>Logical. Should invisible objects be printed too -
see <code><a href="base.html#topic+ls">ls</a></code> to which this argument is passed.</p>
</td></tr>
<tr><td><code id="lls_+3A_print">print</code></td>
<td>
<p>Logical. Should the result be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lls</code> is designed to give a quick overview of the name, mode, class
and dimension of the object in your workspace. They may not always be what you
think they are.
</p>
<p><code>clear</code> clears all your objects from workspace, and all attached objects
too &mdash; it only leaves the loaded packages in the search path; thus allowing a
fresh start without closing and restarting R.
</p>


<h3>Value</h3>

<p><code>lls</code> returns a data frame with four character variables:
codename,
codemode,
codeclass and
codesize and one row per object in the workspace (if <code>pos=1</code>).
<code>size</code> is either the length or the dimension of the object.
The data frame is by default printed with left-justified columns.
</p>


<h3>Author(s)</h3>

<p><code>lls</code>: Unknown. Modified by Bendix Carstensen from a long
forgotten snatch.
</p>
<p><code>clear</code>: Michael Hills / David Clayton.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
y &lt;- rbinom(10, 1, 0.5)
m1 &lt;- glm( y ~ x, family=binomial )
M &lt;- matrix( 1:20, 4, 5 )
.M &lt;- M
dfr &lt;- data.frame(x,y)
attach( dfr )
lls()
search()
clear()
search()
lls()
lls(all=TRUE)
</code></pre>

<hr>
<h2 id='lungDK'>Male lung cancer incidence in Denmark</h2><span id='topic+lungDK'></span>

<h3>Description</h3>

<p>Male lung cancer cases and population riks time in Denmark, for the
period 1943&ndash;1992 in ages 40&ndash;89.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lungDK)</code></pre>


<h3>Format</h3>

<p>A data frame with 220 observations on the following 9 variables.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>A5</code>: </td><td style="text-align: left;"> Left end point of the age interval, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>P5</code>: </td><td style="text-align: left;"> Left enpoint of the period interval, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>C5</code>: </td><td style="text-align: left;"> Left enpoint of the birth cohort interval, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>up</code>: </td><td style="text-align: left;"> Indicator of upper trianges of each age by period
      rectangle in the Lexis diagram. (<code>up=(P5-A5-C5)/5</code>). </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Ax</code>: </td><td style="text-align: left;"> The mean age of diagnois (at risk) in the triangle. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Px</code>: </td><td style="text-align: left;"> The mean date of diagnosis (at risk) in the triangle. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Cx</code>: </td><td style="text-align: left;"> The mean date of birth in the triangle, a numeric vector. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>D</code>: </td><td style="text-align: left;"> Number of diagnosed cases of male lung cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Y</code>: </td><td style="text-align: left;"> Risk time in the male population, person-years. </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p> Cases and person-years are tabulated by age and date of
diagnosis (period) as well as date of birth (cohort) in 5-year
classes. Each observation in the dataframe correponds to a triangle in
a Lexis diagram. Triangles are classified by age and date of
diagnosis, period of diagnosis and date of birth, all in 5-year
groupings. 
</p>


<h3>Source</h3>

<p>The Danish Cancer Registry and Statistics Denmark.
</p>


<h3>References</h3>

<p>For a more thorough exposition of statistical inference in the Lexis
diagram, see: B. Carstensen: Age-Period-Cohort models for the Lexis
diagram. Statistics in Medicine, 26: 3018-3045, 2007.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( lungDK )
# Draw a Lexis diagram and show the number of cases in it.
attach( lungDK )
Lexis.diagram( age=c(40,90), date=c(1943,1993), coh.grid=TRUE )
text( Px, Ax, paste( D ), cex=0.7 )
</code></pre>

<hr>
<h2 id='M.dk'>Mortality in Denmark 1974 ff.</h2><span id='topic+M.dk'></span>

<h3>Description</h3>

<p>Mortality in one-year classes of age (0-98,99+) and period (1974 ff.) in Denmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(M.dk)</code></pre>


<h3>Format</h3>

<p>A data frame with 6400 observations on the following 6 variables.
</p>

<dl>
<dt><code>A</code></dt><dd><p>Age-class, 0-98, 99:99+</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex. 1:males, 2:females</p>
</dd>
<dt><code>P</code></dt><dd><p>Period (year) of death</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of deaths</p>
</dd>
<dt><code>Y</code></dt><dd><p>Number of person-years</p>
</dd>
<dt><code>rate</code></dt><dd><p>Mortality rate per 1000 person-years</p>
</dd>
</dl>



<h3>Details</h3>

<p>Deaths in ages over 100 are in the class labelled 99. Risk time is
computed by tabulation of the risk time in <code><a href="#topic+Y.dk">Y.dk</a></code>, except
for the class 99+ where the average of the population size in ages
99+ at the first and last date of the year is used.</p>


<h3>Source</h3>

<p><a href="http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF">http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(M.dk)
str(M.dk)

zz &lt;- xtabs( rate ~ sex+A+P, data=M.dk )
zz[zz==0] &lt;- NA # 0s makes log-scale plots crash
par(mfrow=c(1,2), mar=c(0,0,0,0), oma=c(3,3,1,1), mgp=c(3,1,0)/1.6 )
for( i in 1:2 )
{
matplot( dimnames(zz)[[2]], zz[i,,],
         lty=1, lwd=1, col=rev(heat.colors(37)),
         log="y", type="l", ylim=range(zz,na.rm=TRUE),
         ylab="", xlab="", yaxt="n" )
text( 0, max(zz,na.rm=TRUE), c("M","F")[i], font=2, adj=0:1, cex=2, col="gray" )
if( i==1 ) axis( side=2, las=1 )
}
mtext( side=1, "Age", line=2, outer=TRUE )
mtext( side=2, "Mortality rate", line=2, outer=TRUE )
</code></pre>

<hr>
<h2 id='mat2pol'>Plot columns of a matrix as stacked areas.
</h2><span id='topic+mat2pol'></span>

<h3>Description</h3>

<p><code>mat</code>rix to <code>pol</code>ygon: Plot columns of a matrix
as stacked areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2pol( pm,
       perm = 1:ncol(pm),
          x = as.numeric(rownames(pm)),
        col = rainbow(ncol(pm)),
         yl = 0:1,
     append = FALSE,
        ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2pol_+3A_pm">pm</code></td>
<td>
<p>Numerical matrix.</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_perm">perm</code></td>
<td>
<p>integer vector of length <code>ncol(pm)</code>, used to permute
the columns of <code>pm</code>.</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_x">x</code></td>
<td>
<p>Numeric. The x-axis of the plot.</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_col">col</code></td>
<td>
<p>Colors of the areas.</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_yl">yl</code></td>
<td>
<p>y-axis limits.</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_append">append</code></td>
<td>
<p>Logical. Should the polygons be added to an exiating plot</p>
</td></tr>
<tr><td><code id="mat2pol_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is originally intended to plot stacked
probabilities, hence the default of <code>0:1</code> for the y-axis.
</p>


<h3>Value</h3>

<p>A matrix of <code>ncol(pm)+1</code> columns with the first equal to 0,
and the remaining the cumulative sum of the columns of
<code>pm[perm]</code>.  
</p>
<p>The function is called for its side effect - the stacked polygons.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- cbind( sort(runif(10)), sort(runif(10)), sort(runif(10)) )
pm &lt;- sweep( M, 1, apply(M,1,sum), "/" )
mat2pol( pm )
</code></pre>

<hr>
<h2 id='matshade'>
Plot confidence intervals as shaded areas around lines.
</h2><span id='topic+matshade'></span>

<h3>Description</h3>

<p>Uses an x-vector and a matrix of 3*N columns with estimates and ci.s
to produce the lines of estimates and confidence intervals as shaded
areas in transparent colours around the lines of the estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matshade( x, y, lty = 1,
          col = 1:(ncol(y)/3), col.shade=col, alpha=0.15,
         plot = dev.cur()==1,
          ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matshade_+3A_x">x</code></td>
<td>
<p>Numerical vector. Unlike <code><a href="graphics.html#topic+matplot">matplot</a></code> this can only be a vector.
</p>
</td></tr>
<tr><td><code id="matshade_+3A_y">y</code></td>
<td>
<p>A matrix with 3*N columns &mdash; representing estimates and
confidence bounds for N curves. Order of columns are assumed to be
(est,lo,hi,est,lo,hi...) (or (est,hi,lo...))
</p>
</td></tr>
<tr><td><code id="matshade_+3A_lty">lty</code></td>
<td>
<p>Line types for the curves.
</p>
</td></tr>
<tr><td><code id="matshade_+3A_col">col</code></td>
<td>
<p>Color(s) of the estimated curves.
</p>
</td></tr>
<tr><td><code id="matshade_+3A_col.shade">col.shade</code></td>
<td>
<p>Color(s) of the shaded areas. These are the colors
that are made transparent by the <code>alpha</code> factor. Defaults to
the same colors as the lines.
</p>
</td></tr>
<tr><td><code id="matshade_+3A_alpha">alpha</code></td>
<td>
<p>Number in [0,1] indicating the transparency of the colors for
the confidence intervals. Larger values makes the shades
darker. Can be a vector which then applies to the curves in turn.
</p>
</td></tr>
<tr><td><code id="matshade_+3A_plot">plot</code></td>
<td>
<p>Logical. Should a new plot frame be started? If no device
is active, the default is to start one, and plot all <code>y</code>s versus
x in transparent color. On the rare occasion a device is open, but
no plot have been called you will get an error telling that plot.new
has not been called yet, in which case you should explicitly set
<code>plot</code> to <code>TRUE</code>. 
</p>
</td></tr>  
<tr><td><code id="matshade_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="graphics.html#topic+matplot">matplot</a></code> (if
<code>plot=TRUE</code>) and <code><a href="graphics.html#topic+matlines">matlines</a></code> for use when plotting
the lines. Note that <code>lwd=0</code> will cause lines to be omitted and
only the shades be plotted. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All shaded areas are plotted first, the curves added
afterwards, so that lines are not 'overshadowed'.
</p>
<p>If there are NAs in <code>x</code> or <code>y</code> there will be separate shaded
areas for each non-<code>NA</code> sequence. Applies separately to each set
of confidence bands in <code>y</code>. 
</p>
<p>Note that if you repeat the same command, you will get the curves
and the shaded areas overplotted in the same frame, so the effect is to
have the shades darker, because the transparent colors are plotted on
top of those from the first command.
</p>


<h3>Value</h3>

<p>NULL. Used for its side effects.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc.matshade">pc.matshade</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Follow-up data of Danish DM patients
data( DMlate )
mL &lt;- Lexis( entry=list(age=dodm-dobth,per=dodm),
              exit=list(per=dox),
       exit.status=factor(!is.na(dodth),labels=c("Alive","Dead")),
              data=DMlate )
# Split follow-up and model by splines
sL &lt;- splitLexis( mL, breaks=0:100, time.scale="age")
## Not run: 
# the same thing with popEpi
sL &lt;- splitMulti( mL, age=0:100 )    
        
## End(Not run)
# Mortality rates separately for M and F:
mort &lt;- glm( (lex.Xst=="Dead") ~ sex*Ns(age,knots=c(15,3:8*10)),
             offset = log(lex.dur),
             family = poisson,
               data = sL )
## Not run: 
# The counterpart with gam
library( mgcv )
mort &lt;- gam( (lex.Xst=="Dead") ~ s(age,by=sex) + sex,
             offset = log(lex.dur),
             family = poisson,
               data = sL )
       
## End(Not run)
# predict rates (per 1000 PY) for men and women
ndM &lt;- data.frame( age=10:90, sex="M", lex.dur=1 )
ndF &lt;- data.frame( age=10:90, sex="F", lex.dur=1 )
# gam objects ignores the offset in prediction so
# lex.dur=1000 in prediction frame wll not work.
prM &lt;- ci.pred( mort, ndM )*1000
prF &lt;- ci.pred( mort, ndF )*1000
# predict rate-ratio
MFr &lt;- ci.exp( mort, ctr.mat=list(ndM,ndF) )
# plot lines with shaded confidence limits
# for illustration we make a holes for the RRs:
MFr[40:45,2] &lt;- NA
MFr[44:49,1] &lt;- NA
matshade( ndM$age, cbind( MFr, prF, prM ), col=c(1,2,4), lwd=3,
          log="y", xlab="Age", ylab="Mortality per 1000 PY (and RR)" )
abline( h=1 )
</code></pre>

<hr>
<h2 id='mcutLexis'>
Cut follow-up at multiple event dates and keep track of order of events 
</h2><span id='topic+mcutLexis'></span>

<h3>Description</h3>

<p>A generalization of <code><a href="#topic+cutLexis">cutLexis</a></code> to the case where different
events may occur in any order (but at most once for each).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcutLexis( L0, timescale = 1, wh,
              new.states = NULL,
        precursor.states = transient(L0),
              seq.states = TRUE,
              new.scales = NULL,
            ties.resolve = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcutLexis_+3A_l0">L0</code></td>
<td>
<p>A Lexis object.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_timescale">timescale</code></td>
<td>
<p>Which time scale do the variables in <code>L0[,wh]</code>
refer to. Can be character or integer.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_wh">wh</code></td>
<td>
<p>Which variables contain the event dates. Character or
integer vector</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_new.states">new.states</code></td>
<td>
<p>Names of the events forming new states. If
<code>NULL</code> equal to the variable names from <code>wh</code>.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_precursor.states">precursor.states</code></td>
<td>
<p>Which states are precursor states. See
<code><a href="#topic+cutLexis">cutLexis</a></code> for definition of precursor states.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_seq.states">seq.states</code></td>
<td>
<p>Should the sequence of events be kept track of? That
is, should A-B be considered different from B-A. If <code>FALSE</code>,
the state with combined preceding events A and B will be called
A+B (alphabetically sorted).
</p>
<p>May also be supplied as character: <code>s</code> - sequence, keep
track of sequence of states occupied (same as <code>TRUE</code>), <code>u</code>
- unordered, keep track only of states visited (same as
<code>FALSE</code>) or <code>l</code>, <code>c</code> - last or current state, only
record the latest state visited. If given as character, only the
first letter converted to lower case is used.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_new.scales">new.scales</code></td>
<td>
<p>Should we construct new time scales indicating the
time since each of the event occurrences.</p>
</td></tr>
<tr><td><code id="mcutLexis_+3A_ties.resolve">ties.resolve</code></td>
<td>
<p>Should tied event times be resolved by adding
random noise to tied event dates. If <code>FALSE</code> the function will
not accept that two events occur at the same time for a person
(ties). If <code>TRUE</code> a random quantity in the range
<code>c(-1,1)/100</code> will be added to all event times in all records
with at least one tie. If <code>ties.resolve</code> is numeric a random
quantity in the range <code>c(-1,1)*ties.resolve</code> will be added to
all event times in all records with at least one tie.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object with extra states created by
occurrence of a number of intermediate events.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+rcutLexis">rcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,
<code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A dataframe of times
set.seed(563248)
dd &lt;- data.frame( id = 1:30,
                 doN = round(runif(30,-30, 0),1),
                 doE = round(runif(30,  0,20),1),
                 doX = round(runif(30, 50,60),1),
                 doD = round(runif(30, 50,60),1),
                 # these are the event times
                 doA = c(NA,21,NA,27,35,NA,52, 5,43,80,
                         NA,22,56,28,53,NA,51, 5,43,80,
                         NA,23,NA,33,51,NA,55, 5,43,80),
                 doB = c(NA,20,NA,53,27,NA, 5,52,34,83,
                         NA,20,23,37,35,NA,52, 8,33,NA,
                         25,NA,37,40,NA,NA,15,23,36,61) )

# set up a Lexis object with time from entry to death/exit
Lx &lt;- Lexis( entry = list(time=doE,
                           age=doE-doN),
              exit = list(time=pmin(doX,doD)),
       exit.status = factor(doD&lt;doX,labels=c("OK","D")),
              data = dd )
summary( Lx )

# cut the follow-up at dates doA and doB
L2 &lt;- mcutLexis( Lx, "time", wh=c("doA","doB"),
                 new.states = c("A","B"),
           precursor.states = "OK",
                 seq.states = TRUE,
                 new.scales = c("tfA","tfB") )
summary( L2 )
L2

# show the states
boxes( L2, boxpos=list(x=c(10,60,50,90,50,90),
                       y=c(50,50,90,90,10,10)),
           scale.R=100, show.BE=TRUE, DR.sep=c(" (",")"))


L3 &lt;- mcutLexis( Lx, "time", wh=c("doA","doB"),
                 new.states = c("A","B"),
           precursor.states = "OK",
                 seq.states = FALSE,
                 new.scales = c("tfA","tfB") )
summary( L3 )
boxes( L3, boxpos=list(x=c(10,50,50,90,50),
                       y=c(50,50,90,50,10)),
           show.R=FALSE, show.BE=TRUE )
</code></pre>

<hr>
<h2 id='merge.Lexis'>Merge a Lexis object with a data frame</h2><span id='topic+merge.Lexis'></span>

<h3>Description</h3>

<p>Merge additional variables from a data frame into a Lexis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
merge(x, y, id, by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.Lexis_+3A_x">x</code></td>
<td>
<p>an object of class <code>Lexis</code></p>
</td></tr>
<tr><td><code id="merge.Lexis_+3A_y">y</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="merge.Lexis_+3A_id">id</code></td>
<td>
<p>the name of the variable in <code>y</code> to use for matching
against the variable <code>lex.id</code> in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="merge.Lexis_+3A_by">by</code></td>
<td>
<p>if matching is not done by id, a vector of variable names
common to both <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="merge.Lexis_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>merge.data.frame</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>Lexis</code> object can be considered as an augmented data frame
in which some variables are time-dependent variables representing
follow-up. The <code>Lexis</code> function produces a minimal object
containing only these time-dependent variables.  Additional variables
may be added to a <code>Lexis</code> object using the <code>merge</code> method.
</p>


<h3>Value</h3>

<p>A <code>Lexis</code> object with additional columns taken from the
merged data frame.
</p>


<h3>Note</h3>

<p>The variable given as the <code>by.y</code> argument must not contain
any duplicate values in the data frame <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code>, <code><a href="#topic+subset.Lexis">subset.Lexis</a></code></p>

<hr>
<h2 id='mh'>
Mantel-Haenszel analyses of cohort and case-control studies
</h2><span id='topic+mh'></span>

<h3>Description</h3>

<p>This function carries out Mantel-Haenszel comparisons in tabulated data 
derived from both cohort and case-control studies. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mh(cases, denom, compare=1, levels=c(1, 2), by=NULL,
     cohort=!is.integer(denom), confidence=0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mh_+3A_cases">cases</code></td>
<td>

<p>the table of case frequencies (a multiway array).
</p>
</td></tr>
<tr><td><code id="mh_+3A_denom">denom</code></td>
<td>

<p>the denominator table. For cohort studies this should be a table of 
person-years observation, while for case-control studies it should be a 
table of control frequencies. 
</p>
</td></tr>
<tr><td><code id="mh_+3A_compare">compare</code></td>
<td>

<p>the dimension of the table which defines the comparison groups (can be 
referred to either by number or by name). The default is the first 
dimension of the table.
</p>
</td></tr>
<tr><td><code id="mh_+3A_levels">levels</code></td>
<td>

<p>a vector identifying (either by number or by name) the two groups to be 
compared. The default is the first two levels of the selected dimension.
</p>
</td></tr>
<tr><td><code id="mh_+3A_by">by</code></td>
<td>

<p>the dimensions not to be collapsed in the Mantel-Haenszel computations. 
Thus, this argument defines the structure of the resulting tables of
estimates and tests.  
</p>
</td></tr>
<tr><td><code id="mh_+3A_cohort">cohort</code></td>
<td>

<p>an indicator  whether the data derive from a cohort or a case-control 
study. If the denominator table is stored as an integer, a case-control
study is assumed.
</p>
</td></tr>
<tr><td><code id="mh_+3A_confidence">confidence</code></td>
<td>

<p>the approximate coverage probability for the confidence intervals to be 
computed.
</p>
</td></tr></table>


<h3>Details</h3>

<p>Multiway tables of data
are accepted and any two levels of any dimension can be chosen as defining
the comparison groups. The rate (odds) ratio estimates and the associated
significance tests may be collapsed over all the remaining dimensions of the 
table, or over selected dimensions only, so that tables of estimates and 
tests are computed.
</p>


<h3>Value</h3>

<p>A list giving tables of rate (odds) ratio estimates, their standard errors 
(on a log scale), lower and upper confidence limits, chi-squared tests 
(1 degree of freedom) and the corresponding p-values. The result list also 
includes numerator and denominator of the Mantel-Haenszel estimates (q, r), 
and score test statistics and score variance (u, v).
</p>


<h3>Side Effects</h3>

<p>None
</p>


<h3>References</h3>

<p>Clayton, D. and Hills, M. : Statistical Models in Epidemiology, Oxford 
University Press (1993). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If d and y are 3-way tables of cases and person-years 
# observation formed by tabulation by two confounders 
# (named "C1" and "C2") an exposure of interest ("E"), 
# the following command will calculate an overall 
# Mantel-Haenszel comparison of the first two exposure 
# groups.
#
# Generate some bogus data
dnam &lt;- list( E=c("low","medium","high"), C1=letters[1:2], C2=LETTERS[1:4] )
d &lt;- array( sample( 2:80, 24),
            dimnames=dnam, dim=sapply( dnam, length ) )
y &lt;- array( abs( rnorm( 24, 227, 50 ) ),
            dimnames=dnam, dim=sapply( dnam, length ) )
mh(d, y, compare="E")
#
# Or, if exposure levels named "low" and "high" are to be 
# compared and these are not the first two levels of E :
#
mh(d, y, compare="E", levels=c("low", "high"))
#
# If we wish to carry out an analysis which controls for C1, 
# but examines the results at each level of C2:
#
mh(d, y, compare="E", by="C2")
#
# It is also possible to look at rate ratios for every 
# combination of C1 and C2 :
#
mh(d, y, compare="E", by=c("C1", "C2"))
#
# If dimensions and levels of the table are unnamed, they must 
# be referred to by number.
#
</code></pre>

<hr>
<h2 id='mod.Lexis'>Fit intensity models to follow-up data in Lexis objects  
</h2><span id='topic+glm.Lexis'></span><span id='topic+gam.Lexis'></span><span id='topic+coxph.Lexis'></span>

<h3>Description</h3>

<p>Modeling intensities based on Lexis objects, exploiting the structure of the
Lexis objects where the events and risk time have predefined
representations. This allows a simpler syntax than the
traditional explicit modeling using <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>
and <code><a href="survival.html#topic+coxph">coxph</a></code>. Requires that <code>lex.Cst</code> and <code>lex.Xst</code>
are defined as factors.
</p>
<p>But it is just a set of wrappers fro
<code>glm</code>, <code>gam</code> and <code>coxph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  glm.Lexis( Lx,         # Lexis object	
        formula,         # ~ model	
           from = preceding(Lx,to), # 'from' states
             to = absorbing(Lx)   , # 'to' states
         paired = FALSE, # only the pairwise
           link = "log", # link function
          scale = 1,     # scaling of PY
        verbose = TRUE,  # report what is done?
            ... )        # further arguments to glm
  gam.Lexis( Lx,         # Lexis object	
        formula,         # ~ model	
           from = preceding(Lx,to), # 'from' states
             to = absorbing(Lx)   , # 'to' states	
         paired = FALSE, # only the pairwise
           link = "log", # link function
          scale = 1,     # scaling of PY
        verbose = TRUE,  # report what is done?
            ... )        # further arguments to gam
coxph.Lexis( Lx,         # Lexis object	
        formula,         # timescale ~ model	
           from = preceding(Lx,to), # 'from' states
             to = absorbing(Lx)   , # 'to' states	
         paired = FALSE, # only the pairwise
        verbose = TRUE,  # report what is done?
            ... )        # further arguments to coxph
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.Lexis_+3A_lx">Lx</code></td>
<td>
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object representing cohort follow-up.
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_formula">formula</code></td>
<td>
<p>Model formula describing the model for the
intensity(-ies). For <code>glm</code> and <code>gam</code>, the formula should be
one-sided; for <code>coxph</code> the formula should be two-sided and have
the name of the time-scale used for baseline hazard as the l.h.s.
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_from">from</code></td>
<td>
<p>Character vector of states <b>from</b> which transitions
are considered. May also be an integer vector in which case the
reference will be to the position of levels of
<code>lex.Cst</code>. Defaults to the collection of transient states
immediately preceding the absorbing states. 
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_to">to</code></td>
<td>
<p>Character vector of states <b>to</b> which a transition is
considered an event. May also be an integer vector in which case the
reference will be to the position of levels of <code>lex.Xst</code>.
Defaults to the set of absorbing states.  
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_paired">paired</code></td>
<td>
<p>Logical. Should the states mentioned in <code>to</code>,
rep. <code>from</code> be taken as pairs, indicating the only transitions
modeled. If <code>FALSE</code> all transitions from any of the states in
<code>from</code> to any states in <code>to</code> are modeled.
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_link">link</code></td>
<td>
<p>Character; name of the link function used, allowed values
are <code>'log'</code> (the default), <code>'identity'</code> and <code>'sqrt'</code>,
see the family <code><a href="#topic+poisreg">poisreg</a></code>. 
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_scale">scale</code></td>
<td>
<p>Scalar. <code>lex.dur</code> is divided by this number before 
analysis, so that you can get resulting rates on a scale of your wish. 
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_verbose">verbose</code></td>
<td>
<p>Print information on the states modeled?
</p>
</td></tr>
<tr><td><code id="mod.Lexis_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>glm</code>, <code>glm</code> or
<code>coxph</code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>glm</code> and <code>gam</code> models are fitted using the family
<code><a href="#topic+poisreg">poisreg</a></code> which is a bit faster than the traditional
<code>poisson</code> family. The response variable for this family is a
two-column vector of events and person-time respectively, so the
predictions, for example using <code><a href="#topic+ci.pred">ci.pred</a></code> does not require
<code>lex.dur</code> (and would ignore this) as variable in the
<code>newdata</code>. <code>ci.pred</code> will return the estimated rates in
units of the <code>lex.dur</code> in the <code>Lexis</code> object, scaled by
<code>scale</code>, which has a default value of 1.
</p>
<p>The default is to model all transitions into any absorbing state by
the same model (how wise is that??). If only <code>from</code> is given,
<code>to</code> is set to all states reachable from <code>from</code>, which may
be a really goofy model and if so a warning is issued. If only
<code>to</code> is given, <code>from</code> is set to the collection of states
from which <code>to</code> can be reached directly &mdash; see
<code><a href="#topic+preceding">preceding</a></code> and its cousins. This convention means that if
you have a <code><a href="#topic+Lexis">Lexis</a></code> object representing a simple survival
analysis, with states, say, &quot;alive&quot; and &quot;dead&quot;, you can dispense with
the <code>from</code> and <code>to</code> arguments.
</p>
<p>Occasionally you only want to model a subset of the possible
transitions from states in <code>from</code> to states in <code>to</code>, in
which case you specify <code>from</code> and <code>to</code> as character vectors
of the same length and set <code>paired=TRUE</code>. Then only transitions
<code>from[i]</code> to <code>to[i]</code>, <code>i</code>=1,2,... will be modeled.
</p>
<p>There is no working <code>update</code> functions for these objects (yet). 
</p>
<p>Strictly speaking, it is a bit counter-intuitive to have the time-scale
on the l.h.s. of the formula for the <code>coxph</code> since the time scale
is also a predictor of the occurrence rate. On the other hand, calling
<code>coxph</code> directly would also entail having the name of the time
scale in the <code>Surv</code> object on the l.h.s. of the formula. So the
inconsistency is merely carried over from <code>coxph</code>.
</p>


<h3>Value</h3>

<p><code>glm.Lexis</code> returns a <code><a href="stats.html#topic+glm">glm</a></code> object, which is
also of class <code>glm.lex</code>,
<code>gam.Lexis</code> returns a <code><a href="mgcv.html#topic+gam">gam</a></code> object, which is
also of class <code>gam.lex</code>, and
<code>coxph.Lexis</code> returns a <code><a href="survival.html#topic+coxph">coxph</a></code> object, which is
also of class <code>coxph.lex</code>. These extra class attributes are meant
to facilitate the (still pending) implementation of an <code>update</code> function.
</p>
<p>The returned objects all have an extra attribute, <code>Lexis</code> which
is a list with entries
<code>data</code>, the name of the <code>Lexis</code> object modeled (note that it
is <em>not</em> the object, only the name of it, which may not be portable);
<code>trans</code>, a character vector of transitions modeled;
<code>formula</code>, the model formula; and
<code>scale</code>, the scaling applied to <code>lex.dur</code> before modeling. 
</p>
<p>Only the <code>glm</code> and <code>gam</code> objects have the <code>scale</code> element
in the list; a scalar indicating the scaling of <code>lex.dur</code> before
modeling. Note that the formula component of the <code>Lexis</code>
attribute of a <code>coxph</code> object is a
two-sided formula with the baseline time scale as the l.h.s.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,
<code><a href="#topic+absorbing">absorbing</a></code>,
<code><a href="#topic+transient">transient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library( Epi )
library( survival )
data( DMlate )

# Lexis object of total follow-up
mL &lt;- Lexis( entry = list(age=dodm-dobth,per=dodm),
              exit = list(per=dox),
       exit.status = factor(!is.na(dodth),labels=c("Alive","Dead")),
              data = DMlate )

# Cut follow-up at start of insulin use
cL &lt;- cutLexis( mL, cut = mL$doins,
              timescale = "per",
              new.state = "Ins",
       precursor.states = "Alive" )

# Split follow-up on age-axis
system.time( sL &lt;- splitLexis( cL, breaks=0:25*4, time.scale="age") )
# ( consider splitMulti from the popEpi package )
summary( sL )

# glm models for rates based on the time-split dataset by insulin and sex

# Proportional hazards model with insulin as time-dependent variable
# - uses the defaul of modeling all transitions from both transient
# states ("Alive" and "Ins") to the absorbing state ("Dead"). 
mt &lt;- glm.Lexis( sL, ~ sex + lex.Cst + Ns(age,knots=c(15,3:8*10)) )

# prediction of mortality rates from "Alive" with and without PH assumption
nA &lt;- data.frame( age=40:70, sex="M", lex.Cst="Alive" )
nI &lt;- data.frame( age=40:70, sex="M", lex.Cst="Ins" )
matshade( nA$age, cbind( ci.pred(mt,nA),
                         ci.pred(mt,nI) )*1000, plot=TRUE,
          lwd=3, lty=1, log="y", col=c("black","blue","red"),
          xlab="Age", ylab="Mortality per 1000 PY" )
 
# gam models may take some time to run so we leave it out
## Not run: 
mt.gam &lt;- gam.Lexis( sL, ~ sex + lex.Cst + s(age), to="Dead",
                     scale=1000 )
        
## End(Not run)

# Fit a Cox model for mortality with age as baseline time scale and
# insulin (lex.Cst) as time-dependent covariate 
mt.cox &lt;- coxph.Lexis( sL, age ~ sex + lex.Cst, c("Alive","Ins"), "Dead" )

# Pretty much the same results for regression paramters as the glm:
  ci.exp( mt    , subset="ex" )
# ci.exp( mt.gam, subset="ex" )
  ci.exp( mt.cox, subset="ex" )
</code></pre>

<hr>
<h2 id='mortDK'>Population mortality rates for Denmark in 1-year age-classes.</h2><span id='topic+mortDK'></span>

<h3>Description</h3>

<p>The <code>mortDK</code> data frame has 1820 rows and 21 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>age</code>: </td><td style="text-align: left;"> Age class, 0--89, 90:90+. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>per</code>: </td><td style="text-align: left;"> Calendar period, 38: 1938--42, 43: 1943--47, ..., 88:1988-92. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>sex</code>: </td><td style="text-align: left;"> Sex, 1: male, 2: female. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>risk</code>: </td><td style="text-align: left;"> Number of person-years in the Danish population. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dt</code>: </td><td style="text-align: left;"> Number of deaths. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>rt</code>: </td><td style="text-align: left;"> Overall mortality rate in cases per 1000 person-years, i.e.
<code>rt=1000*dt/risk</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
           </td><td style="text-align: left;"> Cause-specific mortality rates in cases per 1000 person-years: </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r1</code>: </td><td style="text-align: left;"> Infections </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r2</code>: </td><td style="text-align: left;"> Cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r3</code>: </td><td style="text-align: left;"> Tumors, benign, unspecific nature. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r4</code>: </td><td style="text-align: left;"> Endocrine, metabolic. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r5</code>: </td><td style="text-align: left;"> Blood. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r6</code>: </td><td style="text-align: left;"> Nervous system, psychiatric. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r7</code>: </td><td style="text-align: left;"> Cerebrovascular. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r8</code>: </td><td style="text-align: left;"> Cardiac. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r9</code>: </td><td style="text-align: left;"> Respiratory diseases, excl. cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r10</code>: </td><td style="text-align: left;"> Liver, excl. cancer. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r11</code>: </td><td style="text-align: left;"> Digestive, other. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r12</code>: </td><td style="text-align: left;"> Genitourinary. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r13</code>: </td><td style="text-align: left;"> Ill-defined symptoms. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r14</code>: </td><td style="text-align: left;"> All other, natural. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>r15</code>: </td><td style="text-align: left;"> Violent. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Statistics Denmark, National board of health provided original data. 
Michael Andersson grouped the causes of death.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thoro">thoro</a></code>, <code><a href="#topic+gmortDK">gmortDK</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mortDK)
</code></pre>

<hr>
<h2 id='N.dk'>Population size in Denmark</h2><span id='topic+N.dk'></span>

<h3>Description</h3>

<p>The population size at 1st January in ages 0-99.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(N.dk)</code></pre>


<h3>Format</h3>

<p>A data frame with 7200 observations on the following 4 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Sex, 1:males, 2:females</p>
</dd>
<dt><code>A</code></dt><dd><p>Age. 0:0, 1:1, ..., 98:98, 99:99+</p>
</dd>
<dt><code>P</code></dt><dd><p>Year</p>
</dd>
<dt><code>N</code></dt><dd><p>Number of persons alive at 1st January year <code>P</code></p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF">http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(N.dk)
str(N.dk)
with(N.dk,addmargins(tapply(N,list(P,sex),sum),2))
with(subset(N.dk,P==max(P)),addmargins(tapply(N,list(A,sex),sum)))
</code></pre>

<hr>
<h2 id='N2Y'>
Create risk time (&quot;Person-Years&quot;) in Lexis triangles from population count data.
</h2><span id='topic+N2Y'></span>

<h3>Description</h3>

<p>Data on population size at equidistant dates and age-classes are
used to estimate person-time at risk in Lexis-triangles, i.e. classes
classified by age, period AND cohort (date of birth). Only works for
data where age-classes have the same width as the period-intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N2Y( A, P, N,
     data = NULL,
     return.dfr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N2Y_+3A_a">A</code></td>
<td>
<p>Name of the age-variable, which should be numeric,
corresponding to the left endpoints of the age intervals.</p>
</td></tr>
<tr><td><code id="N2Y_+3A_p">P</code></td>
<td>
<p>Name of the period-variable, which should be numeric,
corresponding to the date of population count.</p>
</td></tr>
<tr><td><code id="N2Y_+3A_n">N</code></td>
<td>
<p>The population size at date <code>P</code> in age class <code>A</code>.</p>
</td></tr>
<tr><td><code id="N2Y_+3A_data">data</code></td>
<td>
<p>A data frame in which arguments are interpreted.</p>
</td></tr>
<tr><td><code id="N2Y_+3A_return.dfr">return.dfr</code></td>
<td>
<p>Logical. Should the results be returned as a data frame
(default <code>TRUE</code>) or as a table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the risk time from the population figures is
done as described in: B. Carstensen: Age-Period-Cohort models for the
Lexis diagram. Statistics in Medicine, 26: 3018-3045, 2007.
</p>
<p>The number of periods in the result is one less than the number
of dates (<code>nP=length(table(P))</code>) in the input, so the number of
distinct values is <code>2*(nP-1)</code>, because the <code>P</code> in the output
is coded differently for upper and lower Lexis triangles.
</p>
<p>The number of age-classes is the same as in the input
(<code>nA=length(table(A))</code>), so the number of distinct values is
<code>2*nA</code>, because the <code>A</code> in the output is coded differently
for upper and lower Lexis triangles.
</p>
<p>In the paper &quot;Age-Period-Cohort models for the Lexis diagram&quot; I
suggest that the risk time in the lower triangles in the first
age-class and in the upper triangles in the last age-class are
computed so that the total risk time in the age-class corresponds to
the average of the two population figures for the age-class at either
end of a period multiplied with the period length. This is the method
used.
</p>


<h3>Value</h3>

<p>A data frame with variables <code>A</code>, <code>P</code> and <code>Y</code>,
representing the mean age and period in the Lexis triangles and the
person-time in them, respectively. The person-time is in units of the
distance between population count dates.
</p>
<p>If <code>return.dfr=FALSE</code> a three-way table classified by the left end
point of the age-classes and the periods and a factor <code>wh</code> taking
the values <code>up</code> and <code>lo</code> corresponding to upper (early
cohort) and lower (late cohort) Lexis triangles.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>References</h3>

<p>B. Carstensen: Age-Period-Cohort models for the
Lexis diagram. Statistics in Medicine, 26: 3018-3045, 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitLexis">splitLexis</a></code>, <code><a href="#topic+apc.fit">apc.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Danish population at 1 Jan each year by sex and age
data( N.dk )
# An illustrative subset
( Nx &lt;- subset( N.dk, sex==1 &amp; A&lt;5 &amp; P&lt;1975 ) )
# Show the data in tabular form
xtabs( N ~ A + P, data=Nx )
# Lexis triangles as data frame
Nt &lt;- N2Y( data=Nx, return.dfr=TRUE )
xtabs( Y ~ round(A,2) + round(P,2), data=Nt )
# Lexis triangles as a 3-dim array
ftable( N2Y( data=Nx, return.dfr=FALSE ) )

# Calculation of PY for persons born 1970 in 1972
( N.1.1972 &lt;- subset( Nx, A==1 &amp; P==1972)$N )
( N.2.1973 &lt;- subset( Nx, A==2 &amp; P==1973)$N )
N.1.1972/3 + N.2.1973/6
N.1.1972/6 + N.2.1973/3
# These numbers can be found in the following plot:

# Blue numbers are population size at 1 January
# Red numbers are the computed person-years in Lexis triangles:
Lexis.diagram(age=c(0,5), date=c(1970,1975), int=1, coh.grid=TRUE )
with( Nx, text(P,A+0.5,paste(N),srt=90,col="blue") )
with( Nt, text(P,A,formatC(Y,format="f",digits=1),col="red") )
text( 1970.5, 2, "Population count 1 January", srt=90, col="blue")
text( 1974.5, 2, "Person-\nyears", col="red")
</code></pre>

<hr>
<h2 id='NArray'>Set up an array of NAs, solely from the list of dimnames
</h2><span id='topic+NArray'></span><span id='topic+ZArray'></span>

<h3>Description</h3>

<p>Defines an array of NAs, solely from the list of dimnames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NArray( x, cells=NA )
ZArray( x, cells=0 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NArray_+3A_x">x</code></td>
<td>
<p>A (possibly named) list to be used as dimnames for the
resulting array</p>
</td></tr>
<tr><td><code id="NArray_+3A_cells">cells</code></td>
<td>
<p>Value(s) to fill the array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple useful way of defining arrays to be used for
collection of results. The point is that everything is defined from
the named list, so in the process of defining what you want to
collect, there is only one place in the program to edit. It's just a
wrapper for <code>array</code>. <code>ZArray</code> is just a wrapper for
<code>NArray</code> with a different default.
</p>


<h3>Value</h3>

<p>An array with <code>dimnames</code> attribute <code>x</code>, and all values
equal to <code>cells</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ftable(
NArray( list(Aye = c("Yes", "Si", "Oui"),
             Bee = c("Hum", "Buzz"),
             Sea = c("White", "Black", "Red", "Dead") ) ) )
</code></pre>

<hr>
<h2 id='ncut'>
Function to group a variable in intervals.</h2><span id='topic+ncut'></span>

<h3>Description</h3>

<p>Cuts a continuous variable in intervals. As opposed to <code>cut</code>
which returns a factor, <code>ncut</code> returns a numeric variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncut(x, breaks, type="left" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncut_+3A_x">x</code></td>
<td>
<p>A numerical vector.</p>
</td></tr>
<tr><td><code id="ncut_+3A_breaks">breaks</code></td>
<td>
<p>Vector of breakpoints. <code>NA</code> will results for values
below <code>min(breaks)</code> if <code>type="left"</code>, for values
above <code>max(breaks)</code> if <code>type="right"</code> and for values
outside <code>range(breaks)</code> if <code>type="mid"</code></p>
</td></tr>
<tr><td><code id="ncut_+3A_type">type</code></td>
<td>
<p>Character: one of <code>c("left","right","mid")</code>,
indicating whether the left, right or midpoint of the intervals
defined in breaks is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the base function <code>findInterval</code>.
</p>


<h3>Value</h3>

<p>A numerical vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center, <a href="mailto:b@bxc.dk">b@bxc.dk</a>,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>, with essential input
from Martyn Plummer, <a href="mailto:martyn.plummer@r-project.org">martyn.plummer@r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>br &lt;- c(-2,0,1,2.5)
x &lt;- c( rnorm( 10 ), br, -3, 3 )
cbind( x, l=ncut( x, breaks=br, type="l" ),
          m=ncut( x, breaks=br, type="m" ),
          r=ncut( x, breaks=br, type="r" ) )[order(x),]
x &lt;- rnorm( 200 )
plot( x, ncut( x, breaks=br, type="l" ), pch=16, col="blue", ylim=range(x) )
abline( 0, 1 )
abline( v=br )
points( x, ncut( x, breaks=br, type="r" ), pch=16, col="red" )
points( x, ncut( x, breaks=br, type="m" ), pch=16, col="green" )
</code></pre>

<hr>
<h2 id='nice'>Nice breakpoints</h2><span id='topic+nice'></span>

<h3>Description</h3>

<p>The function calls <code><a href="base.html#topic+pretty">pretty</a></code>
for linear scale. For a log-scale nice are computed using a set of
specified number in a decade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice(x, log = F, lpos = c(1, 2, 5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nice_+3A_x">x</code></td>
<td>
<p>Numerical vector to</p>
</td></tr>
<tr><td><code id="nice_+3A_log">log</code></td>
<td>
<p>Logical. Is the scale logartimic?</p>
</td></tr>
<tr><td><code id="nice_+3A_lpos">lpos</code></td>
<td>
<p>Numeric. Numbers between 1 and 10 giving the desired
breakpoints in this interval.</p>
</td></tr>
<tr><td><code id="nice_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>pretty</code> if <code>log</code>=FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of breakpoints.</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a></p>


<h3>See Also</h3>

<p>pretty</p>


<h3>Examples</h3>

<pre><code class='language-R'>nice( exp( rnorm( 100 ) ), log=TRUE )
</code></pre>

<hr>
<h2 id='nickel'>A Cohort of Nickel Smelters in South Wales</h2><span id='topic+nickel'></span>

<h3>Description</h3>

<p>The <code>nickel</code> data frame has 679 rows and 7 columns.
The data concern a cohort of nickel smelting workers in South Wales and
are taken from Breslow and Day, Volume 2. For comparison purposes,
England and Wales mortality rates (per 1,000,000 per annum)
from lung cancer (ICDs 162 and 163),
nasal cancer (ICD 160), and all causes, by age group and calendar period, are
supplied in the dataset <code><a href="#topic+ewrates">ewrates</a></code>.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>id</code>: </td><td style="text-align: left;"> Subject identifier (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>icd</code>: </td><td style="text-align: left;"> ICD cause of death if dead, 0 otherwise (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>exposure</code>: </td><td style="text-align: left;"> Exposure index for workplace (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dob</code>: </td><td style="text-align: left;"> Date of birth (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>age1st</code>: </td><td style="text-align: left;"> Age at first exposure (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>agein</code>: </td><td style="text-align: left;"> Age at start of follow-up (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>ageout</code>: </td><td style="text-align: left;"> Age at end of follow-up (numeric) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Breslow NE, and Day N, Statistical Methods in Cancer Research. Volume
II: The Design and Analysis of Cohort Studies. IARC Scientific
Publications, IARC:Lyon, 1987.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nickel)
str(nickel)
</code></pre>

<hr>
<h2 id='Ns'>
Natural splines - (cubic splines linear beyond outermost knots) with
convenient specification of knots and possibility of centering,
detrending and clamping.
</h2><span id='topic+Ns'></span>

<h3>Description</h3>

<p>This function is partly for convenient specification of natural splines
in practical modeling. The convention used is to take the smallest
and the largest of the supplied knots as boundary knots. It also has
the option of centering the effects provided at a chosen reference
point as well as projecting the columns on the orthogonal space to
that spanned by the intercept and the linear effect of the variable,
and finally fixing slopes beyond boundary knots (clamping).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ns( x, ref = NULL, df = NULL,
                knots = NULL,
            intercept = FALSE,
       Boundary.knots = NULL,
                fixsl = c(FALSE,FALSE),
              detrend = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ns_+3A_x">x</code></td>
<td>
<p>A variable.</p>
</td></tr>
<tr><td><code id="Ns_+3A_ref">ref</code></td>
<td>
<p>Scalar. Reference point on the <code>x</code>-scale, where the
resulting effect will be 0.</p>
</td></tr>
<tr><td><code id="Ns_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="Ns_+3A_knots">knots</code></td>
<td>
<p>knots to be used both as boundary and internal knots. If
<code>Boundary.knots</code> are given, this will be taken as the set of
internal knots.</p>
</td></tr>
<tr><td><code id="Ns_+3A_intercept">intercept</code></td>
<td>
<p>Should the intercept be included in the resulting
basis? Ignored if any of <code>ref</code> or <code>detrend</code> is given.</p>
</td></tr>
<tr><td><code id="Ns_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>The boundary knots beyond which the spline is
linear. Defaults to the minimum and maximum of <code>knots</code>.</p>
</td></tr>
<tr><td><code id="Ns_+3A_fixsl">fixsl</code></td>
<td>
<p>Specification of whether slopes beyond outer knots should
be fixed to 0. <code>FALSE</code> correponds to no restriction; a curve with 0
slope beyond the upper knot is obtained using
<code>c(FALSE,TRUE)</code>. Ignored if <code>!(detrend==FALSE)</code>.</p>
</td></tr>
<tr><td><code id="Ns_+3A_detrend">detrend</code></td>
<td>
<p>If <code>TRUE</code>, the columns of the spline basis will be
projected to the orthogonal of <code>cbind(1,x)</code>. Optionally
<code>detrend</code> can be given as a vector of non-negative numbers og
length <code>length(x)</code>, used
to define an inner product as <code>diag(detrend)</code> for projection on
the orthogonal to <code>cbind(1,x)</code>. The default is projection
w.r.t. the inner product defined by the identity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension c(length(x),df) where either <code>df</code> was
supplied or if <code>knots</code> were supplied, <code>df = length(knots) -
    1 + intercept</code>. <code>Ns</code> returns a spline basis which is centered at
<code>ref</code>. <code>Ns</code> with the argument <code>detrend=TRUE</code> returns a
spline basis which is orthogonal to <code>cbind(1,x)</code> with respect to
the inner product defined by the positive definite matrix
<code>diag(detrend)</code> (an assumption which is checked). Note the latter
is data dependent and therefore making predictions
with a <code>newdata</code> argument will be senseless.
</p>


<h3>Note</h3>

<p>The need for this function is primarily from analysis of rates in
epidemiology and demography, where the dataset are time-split records
of follow-up, and the range of data therefore rarely is of any
interest (let alone meaningful).
</p>
<p>In Poisson modeling of rates based on time-split records one should
aim at having the same number of <em>events</em> between knots, rather
than the same number of observations. 
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen <a href="mailto:b@bxc.dk">b@bxc.dk</a>,
Lars Jorge D\'iaz, Steno Diabetes Center Copenhagen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(splines)
require(stats)
require(graphics)

ns( women$height, df = 3)
Ns( women$height, knots=c(63,59,71,67) )

# Gives the same results as ns:
summary( lm(weight ~ ns(height, df = 3), data = women) )
summary( lm(weight ~ Ns(height, df = 3), data = women) )

# Get the diabetes data and set up as Lexis object
data(DMlate)
DMlate &lt;- DMlate[sample(1:nrow(DMlate),500),]
dml &lt;- Lexis( entry = list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate )

# Split follow-up in 1-year age intervals
dms &lt;- splitLexis( dml, time.scale="Age", breaks=0:100 )
summary( dms )

# Model  age-specific rates using Ns with 6 knots
# and period-specific RRs around 2000 with 4 knots
# with the same number of deaths between each pair of knots
n.kn &lt;- 6
( a.kn &lt;- with( subset(dms,lex.Xst=="Dead"),
                quantile( Age+lex.dur, probs=(1:n.kn-0.5)/n.kn ) ) )
n.kn &lt;- 4
( p.kn &lt;- with( subset( dms, lex.Xst=="Dead" ),
                quantile( Per+lex.dur, probs=(1:n.kn-0.5)/n.kn ) ) )
m1 &lt;- glm( lex.Xst=="Dead" ~ Ns( Age, kn=a.kn ) +
                             Ns( Per, kn=p.kn, ref=2000 ),
           offset = log( lex.dur ),
           family = poisson,
             data = dms )

# Plot estimated age-mortality curve for the year 2005 and knots chosen:
nd &lt;- data.frame( Age=seq(40,100,0.1), Per=2005, lex.dur=1000 )
par( mfrow=c(1,2) )
matplot( nd$Age, ci.pred( m1, newdata=nd ),
         type="l", lwd=c(3,1,1), lty=1, col="black", log="y",
         ylab="Mortality rates per 1000 PY", xlab="Age (years)", las=1, ylim=c(1,1000) )
rug( a.kn, lwd=2 )

# Clamped Age effect to the right of rightmost knot.
m1.c &lt;- glm( lex.Xst=="Dead" ~ Ns( Age, kn=a.kn, fixsl=c(FALSE,TRUE) ) +
                               Ns( Per, kn=p.kn, ref=2000 ),
             offset = log( lex.dur ),
             family = poisson,
               data = dms )

# Plot estimated age-mortality curve for the year 2005 and knots chosen.
matplot( nd$Age, ci.pred( m1.c, newdata=nd ),
         type="l", lwd=c(3,1,1), lty=1, col="black", log="y",
         ylab="Mortality rates per 1000 PY", xlab="Age (years)", las=1, ylim=c(1,1000) )
rug( a.kn, lwd=2 )

par( mfrow=c(1,1) )

# Including a linear Age effect of 0.05 to the right of rightmost knot.
m1.l &lt;- glm( lex.Xst=="Dead" ~ Ns( Age, kn=a.kn, fixsl=c(FALSE,TRUE) ) +
                               Ns( Per, kn=p.kn, ref=2000 ),
             offset = log( lex.dur ) + pmax( Age, max( a.kn ) ) * 0.05,
             family = poisson,
               data = dms )

# Plot estimated age-mortality curve for the year 2005 and knots chosen.
nd &lt;- data.frame(Age=40:100,Per=2005,lex.dur=1000)
matplot( nd$Age, ci.pred( m1.l, newdata=nd ),
         type="l", lwd=c(3,1,1), lty=1, col="black", log="y",
         ylab="Mortality rates per 1000 PY", xlab="Age (years)", las=1, ylim=c(1,1000) )
rug( a.kn, lwd=2 )
</code></pre>

<hr>
<h2 id='occup'> A small occupational cohort </h2><span id='topic+occup'></span>

<h3>Description</h3>

<p>This is the data that is behind the illustrative Lexis
diagram in Breslow &amp; Day's book on case-control studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(occup)</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 4 variables.
</p>

<dl>
<dt><code>AoE</code></dt><dd><p>a numeric vector, Age at Entry</p>
</dd>
<dt><code>DoE</code></dt><dd><p>a numeric vector, Date of entry</p>
</dd>
<dt><code>DoX</code></dt><dd><p>a numeric vector, Date of eXit</p>
</dd>
<dt><code>Xst</code></dt><dd><p>eXit status <code>D</code>-event, <code>W</code>-withdrawal,
<code>X</code>-censoring</p>
</dd>
</dl>



<h3>References</h3>

<p>Breslow &amp; Day: Statistical Methods in Cancer Research, vol 1:
The analysis of case-control studies, figure 2.2, p. 48.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(occup)
lx &lt;- Lexis( entry = list( per=DoE, age=AoE ),
              exit = list( per=DoX ),
      entry.status = "W",
       exit.status = Xst,
              data = occup )
plot( lx )
# Split follow-up in 5-year classes
sx &lt;- splitLexis( lx, seq(1940,1960,5), "per" )
sx &lt;- splitLexis( sx, seq(  40,  60,5), "age" )
plot( sx )

# Plot with a bit more paraphernalia and a device to get
# the years on the same physical scale on both axes
ypi &lt;- 2.5 # Years per inch
dev.new( height=15/ypi+1, width=20/ypi+1 ) # add an inch in each direction for
par( mai=c(3,3,1,1)/4, mgp=c(3,1,0)/1.6 )  # the margins set in inches by mai=
plot(sx,las=1,col="black",lty.grid=1,lwd=2,type="l",
     xlim=c(1940,1960),ylim=c(40,55),xaxs="i",yaxs="i",yaxt="n",
     xlab="Calendar year", ylab="Age (years)")
axis( side=2, at=seq(40,55,5), las=1 )
points(sx,pch=c(NA,16)[(sx$lex.Xst=="D")+1] )
box()
# Annotation with the person-years
PY.ann.Lexis( sx, cex=0.8 )
</code></pre>

<hr>
<h2 id='pc.lines'>
Plot period and cohort effects in an APC-frame.
</h2><span id='topic+pc.points'></span><span id='topic+pc.lines'></span><span id='topic+pc.matpoints'></span><span id='topic+pc.matlines'></span><span id='topic+pc.matshade'></span><span id='topic+cp.points'></span><span id='topic+cp.lines'></span><span id='topic+cp.matpoints'></span><span id='topic+cp.matlines'></span><span id='topic+cp.matshade'></span>

<h3>Description</h3>

<p>When an APC-frame has been produced by <code><a href="#topic+apc.frame">apc.frame</a></code>, this
function draws curves or points in the period/cohort part of the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pc.points( x, y, ... )
  pc.lines( x, y, ... )
  pc.matpoints( x, y, ... )
  pc.matlines( x, y, ... )
  pc.matshade( x, y, ... )
  cp.points( x, y, ... )
  cp.lines( x, y, ... )
  cp.matpoints( x, y, ... )
  cp.matlines( x, y, ... )
  cp.matshade( x, y, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pc.lines_+3A_x">x</code></td>
<td>
<p>vector of <code>x</code>-coordinates.</p>
</td></tr>
<tr><td><code id="pc.lines_+3A_y">y</code></td>
<td>
<p>vector or matrix of <code>y</code>-coordinates.</p>
</td></tr>
<tr><td><code id="pc.lines_+3A_...">...</code></td>
<td>
<p>Further parameters to be transmitted to points, lines,
matpoints, matlines or matshade used for plotting curves in the
calendar time realm of a graph generated by <code><a href="#topic+apc.frame">apc.frame</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the Age-part of the frame is referred to by its real
coordinates plotting in the calendar time part requires translation
and scaling to put things correctly there, that is done by the
functions <code>pc.points</code> etc.
</p>
<p>The functions <code>cp.points</code> etc. are just synonyms for these, in
recognition of the fact that you can never remember whether it is &quot;pc&quot;
or &quot;cp&quot;.
</p>


<h3>Value</h3>

<p>The functions return nothing.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center Copenhagen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.frame">apc.frame</a></code>, <code><a href="#topic+apc.fit">apc.fit</a></code>, <code><a href="#topic+plot.apc">plot.apc</a></code>, <code><a href="#topic+lines.apc">lines.apc</a></code>
</p>

<hr>
<h2 id='pctab'>Create percentages in a table</h2><span id='topic+pctab'></span>

<h3>Description</h3>

<p>Computes percentages and a margin of totals along a given margin of a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pctab(TT, margin = length(dim(TT)), dec=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pctab_+3A_tt">TT</code></td>
<td>
<p>A table or array object</p>
</td></tr>
<tr><td><code id="pctab_+3A_margin">margin</code></td>
<td>
<p>Which margin should be the the total?</p>
</td></tr>
<tr><td><code id="pctab_+3A_dec">dec</code></td>
<td>
<p>How many decimals should be printed? If 0 or <code>FALSE</code>
nothing is printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of percentages, where all dimensions except the one specified <code>margin</code>
has two extra levels named &quot;All&quot; (where all entries are 100) and &quot;N&quot;.
The function prints the table with <code>dec</code> decimals.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+addmargins">addmargins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Aye &lt;- sample( c("Yes","Si","Oui"), 177, replace=TRUE )
Bee &lt;- sample( c("Hum","Buzz"), 177, replace=TRUE )
Sea &lt;- sample( c("White","Black","Red","Dead"), 177, replace=TRUE )
A &lt;- table( Aye, Bee, Sea )
A
ftable( pctab( A ) )
ftable( pctab( addmargins( A, 1 ), 3 ) )
round( ftable( pctab( addmargins( A, 1 ), 3 ), row.vars=3 ), 1)
</code></pre>

<hr>
<h2 id='plot.apc'>Plot the estimates from a fitted Age-Period-Cohort model</h2><span id='topic+plot.apc'></span><span id='topic+apc.plot'></span>

<h3>Description</h3>

<p>This function plots the estimates created by <code><a href="#topic+apc.fit">apc.fit</a></code> in a single
graph. It just calls <code><a href="#topic+apc.frame">apc.frame</a></code> after computing some sensible
values of the parameters, and subsequently plots the estimates using
<code><a href="#topic+apc.lines">apc.lines</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'apc'
plot( x, r.txt="Rate", ...)
          apc.plot( x, r.txt="Rate", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.apc_+3A_x">x</code></td>
<td>
<p> An object of class <code>apc</code>. </p>
</td></tr>
<tr><td><code id="plot.apc_+3A_r.txt">r.txt</code></td>
<td>
<p> The text to put on the vertical rate axis. </p>
</td></tr>
<tr><td><code id="plot.apc_+3A_...">...</code></td>
<td>
<p> Additional arguments passed on to <code><a href="#topic+apc.lines">apc.lines</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.apc</code> is just a wrapper for <code>apc.plot</code>.</p>


<h3>Value</h3>

<p>A numerical vector of length two, with names
<code>c("cp.offset","RR.fac")</code>. The first is the offset for the cohort
period-axis, the second the multiplication factor for the rate-ratio
scale. Therefore, if you want to plot at <code>(x,y)</code> in the right panel,
use <code>(x-res["cp.offset"],y/res["RR.fac"])</code>
<code>=(x-res[1],y/res[2])</code>.
This vector should be supplied for the parameter <code>frame.par</code> to
<code><a href="#topic+apc.lines">apc.lines</a></code> if more sets of estimates is plotted in the
same graph, however see <code><a href="#topic+cp.points">cp.points</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.lines">apc.lines</a></code>, <code><a href="#topic+lines.apc">lines.apc</a></code>,
<code><a href="#topic+apc.frame">apc.frame</a></code>, <code><a href="#topic+apc.fit">apc.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( lungDK )
apc1 &lt;- apc.fit( transform( lungDK,
                            A = Ax, P = Px, Y = Y/10^5 ),
                 ref.c = 1920 )
fp &lt;- apc.plot( apc1 )
apc.lines( apc1, frame.par=fp, drift=1.01, col="red" )
for( i in 1:11 )
  apc.lines( apc1, frame.par=fp, drift=1+(i-6)/100, col=rainbow(12)[i] )
</code></pre>

<hr>
<h2 id='plot.Lexis'>Lexis diagrams</h2><span id='topic+plot.Lexis'></span><span id='topic+points.Lexis'></span><span id='topic+lines.Lexis'></span><span id='topic+PY.ann'></span><span id='topic+PY.ann.Lexis'></span>

<h3>Description</h3>

<p>The follow-up histories represented by a Lexis object can be plotted
using one or two dimensions.  The two dimensional plot is a Lexis
diagram showing follow-up time simultaneously on two time scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
plot(x=Lexis( entry=list(Date=1900,Age=0), exit=list(Age=0) ),
                     time.scale = NULL, type="l", breaks="lightgray", ...)
## S3 method for class 'Lexis'
points(x, time.scale = options()[["Lexis.time.scale"]] , ...)
## S3 method for class 'Lexis'
lines(x, time.scale = options()[["Lexis.time.scale"]], ...)
## S3 method for class 'Lexis'
PY.ann(x, time.scale = options()[["Lexis.time.scale"]], digits=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Lexis_+3A_x">x</code></td>
<td>
<p>An object of class <code>Lexis</code>. The default is a bogus <code>Lexis</code>
object, so that <code>plot.Lexis</code> can be called without the first
argument and still produce a(n empty) Lexis diagram. Unless arguments
<code>xlim</code> and <code>ylim</code> are given in this case the diagram is
looking pretty daft.</p>
</td></tr>
<tr><td><code id="plot.Lexis_+3A_time.scale">time.scale</code></td>
<td>
<p>A vector of length 1 or 2 giving the time scales to
be plotted either by name or numerical order</p>
</td></tr>
<tr><td><code id="plot.Lexis_+3A_type">type</code></td>
<td>
<p>Character indication what to draw: &quot;n&quot; nothing (just set up the
diagram), &quot;l&quot; - liefelines, &quot;p&quot; - endpoints of follow-up, &quot;b&quot; - both
lifelines and endpoints.</p>
</td></tr>
<tr><td><code id="plot.Lexis_+3A_breaks">breaks</code></td>
<td>
<p>a string giving the colour of grid lines to be drawn
when plotting a split Lexis object. Grid lines can be suppressed by
supplying the value <code>NULL</code> to the <code>breaks</code> argument</p>
</td></tr>
<tr><td><code id="plot.Lexis_+3A_digits">digits</code></td>
<td>
<p>Numerical. How many digits after the demimal points should be
when plotting the person-years.</p>
</td></tr>
<tr><td><code id="plot.Lexis_+3A_...">...</code></td>
<td>
<p>Further graphical parameters to be passed to the plotting
methods.
</p>
<p>Grids can be drawn (behind the life lines) using the following
parameters in <code>plot</code>: 
</p>

<ul>
<li> <p><code>grid</code> If logical, a background grid is set up
using the axis ticks. If a list, the first component is used as
positions for the vertical lines and the last as positions for the
horizontal. If a nunerical vector, grids on both axes are set up
using the distance between the numbers.
</p>
</li>
<li> <p><code>col.grid="lightgray"</code> Color of the background grid.
</p>
</li>
<li> <p><code>lty.grid=2</code> Line type for the grid.
</p>
</li>
<li> <p><code>coh.grid=FALSE</code> Should a 45 degree grid be plotted?</p>
</li></ul>

</td></tr> </table>


<h3>Details</h3>

<p>The plot method for <code>Lexis</code> objects traces &ldquo;life lines&rdquo; from
the start to the end of follow-up.  The <code>points</code> method plots
points at the end of the life lines.
</p>
<p>If <code>time.scale</code> is of length 1, the life lines are drawn
horizontally, with the time scale on the X axis and the id value on the Y
axis. If <code>time.scale</code> is of length 2, a Lexis diagram is
produced, with diagonal life lines plotted against both time scales
simultaneously.
</p>
<p>If <code>lex</code> has been split along one of the time axes by a call to
<code>splitLexis</code>, then vertical or horizontal grid lines are plotted
(on top of the life lines) at the break points.
</p>
<p><code>PY.ann</code> writes the length of each (segment of) life line at the middle
of the line. Not advisable to use with large cohorts. Another example is
in the example file for <code><a href="#topic+occup">occup</a></code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>, <code><a href="#topic+splitLexis">splitLexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- structure( list( id = c("A", "B", "C"),
                      birth = c("14/07/1952", "01/04/1957", "10/06/1987"),
                      entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                       exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                       fail = c(1, 0, 1) ),
                     .Names = c("id", "birth", "entry", "exit", "fail"),
                  row.names = c("1", "2", "3"),
                      class = "data.frame" )

# Convert the character dates into numerical variables (fractional years)
xcoh$bt &lt;- cal.yr( xcoh$birth, format="%d/%m/%Y" )
xcoh$en &lt;- cal.yr( xcoh$entry, format="%d/%m/%Y" )
xcoh$ex &lt;- cal.yr( xcoh$exit , format="%d/%m/%Y" )

# See how it looks
xcoh

# Define as Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis( entry = list( per=en ),
                exit = list( per=ex, age=ex-bt ),
         exit.status = fail,
                data = xcoh )

# Default plot of follow-up
plot( Lcoh )
# Show follow-up time
PY.ann( Lcoh )

# Show exit status
plot( Lcoh, type="b" )
# Same but failures only
plot( Lcoh, type="b", pch=c(NA,16)[Lcoh$fail+1] )

# With a grid and deaths as endpoints
plot( Lcoh, grid=0:10*10, col="black" )
points( Lcoh, pch=c(NA,16)[Lcoh$lex.Xst+1] )
# With a lot of bells and whistles:
plot( Lcoh, grid=0:20*5, col="black", xaxs="i", yaxs="i",
      xlim=c(1960,2010), ylim=c(0,50), lwd=3, las=1 )
points( Lcoh, pch=c(NA,16)[Lcoh$lex.Xst+1], col="red", cex=1.5 )
</code></pre>

<hr>
<h2 id='plotCIF'>Plotting Aalen-Johansen curves for competing events
</h2><span id='topic+plotCIF'></span><span id='topic+stackedCIF'></span>

<h3>Description</h3>

<p>Function <code>plotCIF</code> plots, for one or more groups, the
cumulative incidence curves for a selected event out of two or more
competing events. Function <code>stackedCIF</code> plots, for one group or
population, the cumulative incidence curves for two or more competing
events such that the cumulative incidences are stacked upon each
other. The CIFs are are estimated by the Aalen-Johansen method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit'
 plotCIF( x, event = 1,
              xlab = "Time",
              ylab = "Cumulative incidence",
              ylim = c(0, 1),
               lty = 1,
               col = "black", ... )

## S3 method for class 'survfit'
stackedCIF( x, group = 1,
                 col = "black",
                fill = "white",
                ylim = c(0,1),
                xlab = "Time",
                ylab = "Cumulative incidence", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCIF_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="survival.html#topic+survfit">survfit</a></code>, the <code>type</code> of
<code>event</code> in <code>Surv()</code> being &quot;<code>mstate</code>&quot;; the first level
of the event factor represents censoring and the remaining ones the
alternative competing events. 
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_event">event</code></td>
<td>
<p>Determines the event for which the cumulative incidence
curve is plotted by <code>plotCIF</code>.
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_group">group</code></td>
<td>
<p>An integer showing the selected level of a possible
grouping factor appearing in the model formula in <code>survfit</code> when
plotting by <code>stackedCIF</code> 
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_col">col</code></td>
<td>
<p>A vector specifying the plotting color(s) of the curve(s) for
the different groups in <code><a href="#topic+plotCIF">plotCIF</a></code>&ndash; default: all &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_fill">fill</code></td>
<td>
<p>A vector indicating the colours to be used for shading the
areas pertinent to the separate outcomes in <code><a href="#topic+stackedCIF">stackedCIF</a></code>
- default: all <code>"white"</code>.
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_xlab">xlab</code></td>
<td>
<p>Label for the $x$-axis.
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_ylab">ylab</code></td>
<td>
<p>Label for the $y$-axis.
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the $y$-axis.
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_lty">lty</code></td>
<td>
<p>A vector specifying the line type(s) of the curve(s) for
the different groups - default: all 1 (=solid). 
</p>
</td></tr>
<tr><td><code id="plotCIF_+3A_...">...</code></td>
<td>
<p>Further graphical parameters to be passed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order in which the curves with <code><a href="#topic+stackedCIF">stackedCIF</a></code> are piled
upon each other is the same as the ordering of the values or levels of
the competing events in the pertinent event variable. The ordering can
be changed by permuting the levels as desired using function
<code>Relevel</code>, after which <code>survfit</code> is called with the relevelled
<code>event</code> variable in <code>Surv()</code>
</p>


<h3>Value</h3>

<p>No value is returned but a plot is produced as a side-effect.
</p>


<h3>Note</h3>

<p>Aalen-Johansen curves for competing events in several groups can also
be plotted by function <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> of the survival
library as well as by some functions in other packages covering analysis
of time-to-event data.</p>


<h3>Author(s)</h3>

<p>Esa L\&quot;a\&quot;ar\&quot;a, <a href="mailto:esa.laara@oulu.fi">esa.laara@oulu.fi</a>
</p>


<h3>References</h3>

<p>Putter, H., Fiocco, M., Geskus, R.B. (2007). 
Tutorial in biostatistics: competing risks and multi-state models. 
Statistics in Medicine, 26: 2389&ndash;2430.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survfit">survfit</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)   #  requires version 2.39-4 or later
head(mgus1)
#  Aalen-Johansen estimates of CIF are plotted by sex for two 
#  competing events: (1) progression (pcm), and (2) death, in 
#  a cohort of patients with monoclonal gammopathy.

#  The data are actually covering transitions from pcm to death, too,
#  for those entering the state of pcm. Such patients have two rows
#  in the data frame, and in their 2nd row the 'start' time is 
#  the time to pcm (in days). 

#  In our analysis we shall only include those time intervals with value 0
#  for variable 'start'. Thus, the relevant follow-up time is represented 
#  by variable 'stop' (days). For convenience, days are converted to years.

fitCI &lt;- survfit(Surv(stop/365.25, event, type="mstate") ~ sex,
              data= subset(mgus1, start==0) )
par(mfrow=c(1,2))
plotCIF(fitCI, event = 1, col = c("red", "blue"),
  main = "Progression", xlab="Time (years)" )
text( 38, 0.15, "Men", pos = 2)
text( 38, 0.4, "Women", pos = 2)
plotCIF(fitCI, event = 2, col = c("red", "blue"), 
  main = "Death", xlab="Time (years)" )
text( 38, 0.8, "Men", pos = 2)
text( 38, 0.5, "Women", pos = 2)

par(mfrow=c(1,2))
stackedCIF(fitCI, group = 1, colour = c("gray80", "gray90"),
  main = "Women", xlab="Time (years)" )	
text( 36, 0.15, "PCM", pos = 2)
text( 36, 0.6, "Death", pos = 2)
stackedCIF(fitCI, group = 2, colour = c("gray80", "gray90"), 
  main = "Men", xlab="Time (years)" )
text( 39, 0.10, "PCM", pos = 2)
text( 39, 0.6, "Death", pos = 2)	
</code></pre>

<hr>
<h2 id='plotEst'>
Plot estimates with confidence limits (forest plot)
</h2><span id='topic+plotEst'></span><span id='topic+pointsEst'></span><span id='topic+linesEst'></span>

<h3>Description</h3>

<p>Plots parameter estimates with confidence intervals, annotated with
parameter names. A dot is plotted at the estimate and a horizontal
line extending from the lower to the upper limit is superimposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEst( ests,
            y = dim(ests)[1]:1,
          txt = rownames(ests),
       txtpos = y,
         ylim = range(y)-c(0.5,0),
         xlab = "",
         xtic = nice(ests[!is.na(ests)], log = xlog),
         xlim = range( xtic ),
         xlog = FALSE,
          pch = 16,
          cex = 1,
          lwd = 2,
          col = "black",
      col.txt = "black",
     font.txt = 1,
    col.lines = col,
   col.points = col,
         vref = NULL,
         grid = FALSE,
     col.grid = gray(0.9),
  restore.par = TRUE,
          ... )

linesEst( ests, y = dim(ests)[1]:1, pch = 16, cex = 1, lwd = 2,
          col="black", col.lines=col, col.points=col, ... )

pointsEst( ests, y = dim(ests)[1]:1, pch = 16, cex = 1, lwd = 2,
          col="black", col.lines=col, col.points=col, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEst_+3A_ests">ests</code></td>
<td>
<p>Matrix with three columns: Estimate, lower limit, upper
limit. If a model object is supplied, <code><a href="#topic+ci.lin">ci.lin</a></code> is
invoked for this object first.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_y">y</code></td>
<td>
<p>Vertical position of the lines.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_txt">txt</code></td>
<td>
<p>Annotation of the estimates. Either a character vector or
an expression vector.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_txtpos">txtpos</code></td>
<td>
<p>Vertical position of the text. Defaults to <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_ylim">ylim</code></td>
<td>
<p>Extent of the vertical axis.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_xlab">xlab</code></td>
<td>
<p>Annotation of the horizontal axis.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_xtic">xtic</code></td>
<td>
<p>Location of tickmarks on the x-axis.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_xlim">xlim</code></td>
<td>
<p>Extent of the x-axis.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_xlog">xlog</code></td>
<td>
<p>Should the x-axis be logarithmic?</p>
</td></tr>
<tr><td><code id="plotEst_+3A_pch">pch</code></td>
<td>
<p>What symbol should be used?</p>
</td></tr>
<tr><td><code id="plotEst_+3A_cex">cex</code></td>
<td>
<p>Expansion of the symbol.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_col">col</code></td>
<td>
<p>Colour of the points and lines.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_col.txt">col.txt</code></td>
<td>
<p>Colour of the text annotating the estimates.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_font.txt">font.txt</code></td>
<td>
<p>Font for the text annotating the estimates.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_col.lines">col.lines</code></td>
<td>
<p>Colour of the lines.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_col.points">col.points</code></td>
<td>
<p>Colour of the symbol.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_lwd">lwd</code></td>
<td>
<p>Thickness of the lines.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_vref">vref</code></td>
<td>
<p>Where should vertical reference line(s) be drawn?</p>
</td></tr>
<tr><td><code id="plotEst_+3A_grid">grid</code></td>
<td>
<p>If TRUE, vertical gridlines are drawn at the
tickmarks. If a numerical vector is given vertical lines are drawn
at <code>grid</code>.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_col.grid">col.grid</code></td>
<td>
<p>Colour of the vertical gridlines</p>
</td></tr>
<tr><td><code id="plotEst_+3A_restore.par">restore.par</code></td>
<td>
<p>Should the graphics parameters be restored? If set
to <code>FALSE</code> the coordinate system will still be available for
additional plotting, and <code>par("mai")</code> will still have the very
large value set in order to make room for the labelling of the
estimates.</p>
</td></tr>
<tr><td><code id="plotEst_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>ci.lin</code> when a model object is
supplied as <code>ests</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotEst</code> makes a news plot, whereas <code>linesEst</code> and
<code>pointsEst</code> (identical functions) adds to an existing plot.
</p>
<p>If a model object of class <code>"glm"</code>, <code>"coxph"</code>, <code>"clogistic"</code> or
<code>"gnlm"</code> is supplied the argument <code>xlog</code> defaults to
<code>TRUE</code>, and exponentiated estimates are extracted by default.
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen,
<a href="mailto:b@bxc.dk">b@bxc.dk</a>,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a></p>


<h3>See Also</h3>

<p>ci.lin
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bogus data and a linear model
f &lt;- factor( sample( letters[1:5], 100, replace=TRUE ) )
x &lt;- rnorm( 100 )
y &lt;- 5 + 2 * as.integer( f ) + 0.8 * x + rnorm(100) * 2
m1 &lt;- lm( y ~ f )

# Produce some confidence intervals for contrast to first level
( cf &lt;- ci.lin( m1, subset=-1 )[,-(2:4)] )

# Plots with increasing amounts of bells and whistles
par( mfcol=c(3,2), mar=c(3,3,2,1) )
plotEst( cf )
plotEst( cf, grid=TRUE, cex=2, lwd=3 )
plotEst( cf, grid=TRUE, cex=2, col.points="red", col.lines="green" )
plotEst( cf, grid=TRUE, cex=2, col.points="red", col.lines="green",
             xlog=TRUE, xtic=c(1:8), xlim=c(0.8,6) )
rownames( cf )[1] &lt;- "Contrast to fa:\n fb"
plotEst( cf, grid=TRUE, cex=2, col.points=rainbow(4),
                                col.lines=rainbow(4), vref=1 )
#
etxt &lt;- expression("Plain text, qouted",
                   "combined with maths:"*sqrt(a)*phi[c],
                   f^d*"  Hb"*A[1][c],
                   eff^e*"  kg/"*m^2)
plotEst( cf, txt=etxt, grid=TRUE, cex=2, col.points=rainbow(4),
                                         col.lines =rainbow(4), vref=1 )
  </code></pre>

<hr>
<h2 id='plotevent'> Plot Equivalence Classes </h2><span id='topic+plotevent'></span>

<h3>Description</h3>

<p>For interval censored data, segments of times between last.well and first.ill are plotted for each conversion in the data. It also plots the equivalence classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotevent(last.well, first.ill, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotevent_+3A_last.well">last.well</code></td>
<td>
<p> Time at which the individuals are
last seen negative for the event </p>
</td></tr>
<tr><td><code id="plotevent_+3A_first.ill">first.ill</code></td>
<td>
<p> Time at which the individuals are
first seen positive for the event </p>
</td></tr>
<tr><td><code id="plotevent_+3A_data">data</code></td>
<td>
<p> Data with a transversal shape </p>
</td></tr>
</table>


<h3>Details</h3>

<p>last.well and first.ill should be written as character in the function.
</p>


<h3>Value</h3>

<p>Graph
</p>


<h3>Author(s)</h3>

<p>Delphine Maucort-Boulch, Bendix Carstensen, Martyn Plummer
</p>


<h3>References</h3>

 
<p>Carstensen B. Regression models for interval censored survival data:
application to HIV infection in Danish homosexual men.Stat Med. 1996 Oct
30;15(20):2177-89. 
</p>
<p>Lindsey JC, Ryan LM. Tutorial in biostatistics methods for
interval-censored data.Stat Med. 1998 Jan 30;17(2):219-38. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Icens">Icens</a></code>
</p>

<hr>
<h2 id='poisreg'>Family Object for Poisson Regression</h2><span id='topic+poisreg'></span>

<h3>Description</h3>

<p>The <code>poisreg</code> family allows Poisson regression models to be
fitted using the <code>glm</code> function.
</p>
<p>In a Poisson regression model, we assume that the data arise from a
Poisson process. We observe D disease events in follow up time Y and
wish to estimate the incidence rate, which is assumed to be constant
during the follow-up period for any individual. The incidence rate
varies between individuals according to the predictor variables and
the link function in the model specification.
</p>
<p>When using the <code>poisreg</code> family in the <code>glm</code> function, the
response should be specified as a two-column matrix with the first
column giving the number of events (D) and the second column giving
the observation time (Y). This is similar to the <code>binomial</code>
family for which a two-column outcome can be used representing the
number of successes and the number of failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisreg(link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisreg_+3A_link">link</code></td>
<td>
<p>a specification for the model link function.  The
<code>poisreg</code> family accepts the links <code>identity</code>,
<code>log</code> and <code>inverse</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"family"</code>.  See <code><a href="stats.html#topic+family">family</a></code>
for details.
</p>
<p>The family name, represented by the element <code>"family"</code> in the
returned object, is <code>"poisson"</code> and not <code>"poisreg"</code>. This is
necessary to prevent the <code>summary.glm</code> function from estimating
an overdispersion parameter (which should be fixed at 1) and therefore
giving incorrect standard errors for the estimates.
</p>


<h3>Note</h3>

<p>When using the log link, Poisson regression can also be carried out
using the <code>poisson</code> family by including the log follow-up time
<code>log(Y)</code> as an offset. However this approach does not generalize
to other link functions. The <code>poisreg</code> family allows more general
link functions including additive risk models with <code>poisreg(link
    = "identity")</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+family">family</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Estimate incidence rate of diabetes in Denmark (1996-2015) by
  ## age and sex
  data(DMepi)
  DMepi$agegrp &lt;- cut(DMepi$A, seq(from=0, to=100, by=5))
  inc.diab &lt;- glm(cbind(X, Y.nD) ~ -1 + agegrp + sex, family=poisreg,
                  data=DMepi)
  ## The coefficients for agegrp are log incidence rates for men in each
  ## age group. The coefficient for sex is the log of the female:male
  ## incidence rate ratio.
  summary(inc.diab)

  ## Smooth function with non-constant M/F RR:
  requireNamespace("mgcv")
  library( mgcv )
  gam.diab &lt;- gam( cbind(X, Y.nD) ~ s(A,by=sex) + sex,
                   family=poisreg,
                   data=DMepi)

  ## There is no need/use for Y.nD in prediction data frames:
  nM &lt;- data.frame( A=20:90, sex="M" )
  nF &lt;- data.frame( A=20:90, sex="F" )

  ## Rates are returned in units of (1 year)^-1, so we must scale the
  ## rates by hand: 
  matshade( nM$A, cbind( ci.pred(gam.diab,     nM    )*1000,
                         ci.pred(gam.diab,        nF )*1000,
                         ci.exp( gam.diab,list(nM,nF)) ),
            plot=TRUE, col=c("blue","red","black"),
            log="y", xlab="Age", ylab="DM incidence rates per 1000     /     M vs. F RR" )
  abline(h=1)
</code></pre>

<hr>
<h2 id='pr'>Diabetes prevance as of 2010-01-01 in Denmark
</h2><span id='topic+pr'></span>

<h3>Description</h3>

<p>Diabetes prevalence as of 2010-01-01 in Denmark in 1-year age classes by sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("pr")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 4 variables.
</p>

<dl>
<dt><code>A</code></dt><dd><p>Numeric, age, 0-99</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex, a factor with levels <code>M</code> <code>F</code></p>
</dd>
<dt><code>X</code></dt><dd><p>Number of diabetes patients</p>
</dd>
<dt><code>N</code></dt><dd><p>Population size</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(pr)
str(pr)
</code></pre>

<hr>
<h2 id='projection.ip'> Projection of columns of a matrix. </h2><span id='topic+projection.ip'></span>

<h3>Description</h3>

<p>Projects the columns of the matrix <code>M</code> on the space spanned by the
columns of the matrix <code>X</code>, with respect to the inner product
defined by <code>weight</code>: <code>&lt;x|y&gt;=sum(x*w*y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection.ip(X, M, orth = FALSE, weight = rep(1, nrow(X)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection.ip_+3A_x">X</code></td>
<td>
<p> Matrix defining the space to project onto. </p>
</td></tr>
<tr><td><code id="projection.ip_+3A_m">M</code></td>
<td>
<p> Matrix of columns to be projected. Must have the same number
of rows as <code>X</code>. </p>
</td></tr>
<tr><td><code id="projection.ip_+3A_orth">orth</code></td>
<td>
<p> Should the projection be on the orthogonal complement to
<code>span(X)</code>? </p>
</td></tr>
<tr><td><code id="projection.ip_+3A_weight">weight</code></td>
<td>
<p> Weights defining the inner product. Numerical vector of
length <code>nrow(X)</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of full rank with columns in <code>span(X)</code>
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>, with help from Peter Dalgaard.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+detrend">detrend</a></code> </p>

<hr>
<h2 id='rateplot'>
Functions to plot rates from a table classified by age and
calendar time (period)
</h2><span id='topic+rateplot'></span><span id='topic+Aplot'></span><span id='topic+Pplot'></span><span id='topic+Cplot'></span>

<h3>Description</h3>

  
<p>Produces plots of rates versus age, connected within period or cohort
(<code>Aplot</code>), rates versus period connected within age-groups
(<code>Pplot</code>) and rates and rates versus date of birth cohort
(<code>Cplot</code>). <code>rateplot</code> is a wrapper for these, allowing
to produce the four classical displays with a single call. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rateplot( rates,
          which = c("ap","ac","pa","ca"),
            age = as.numeric( dimnames( rates )[[1]] ),
            per = as.numeric( dimnames( rates )[[2]] ),
           grid = FALSE,
         a.grid = grid,
         p.grid = grid,
         c.grid = grid,
          ygrid = grid,
       col.grid = gray( 0.9 ),
          a.lim = range( age, na.rm=TRUE ) + c(0,diff( range( age ) )/30),
          p.lim = range( per, na.rm=TRUE ) + c(0,diff( range( age ) )/30),
          c.lim = NULL, 
           ylim = range( rates[rates&gt;0], na.rm=TRUE ),
             at = NULL,
         labels = paste( at ),
          a.lab = "Age at diagnosis",
          p.lab = "Date of diagnosis",
          c.lab = "Date of birth",
           ylab = "Rates",
           type = "l",
            lwd = 2,
            lty = 1,
         log.ax = "y",
            las = 1,
            ann = FALSE,
          a.ann = ann,
          p.ann = ann,
          c.ann = ann,
          xannx = 1/20,
        cex.ann = 0.8,
         a.thin = seq( 1, length( age ), 2 ),
         p.thin = seq( 1, length( per ), 2 ),
         c.thin = seq( 2, length( age ) + length( per ) - 1, 2 ),
            col = par( "fg" ),
          a.col = col,
          p.col = col,
          c.col = col,
            ... )

Aplot( rates, age = as.numeric( dimnames( rates )[[1]] ),
       per = as.numeric( dimnames( rates )[[2]] ), grid = FALSE,
       a.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       a.lim = range( age, na.rm=TRUE ), ylim = range( rates[rates&gt;0], na.rm=TRUE ),
       at = NULL, labels = paste( at ), a.lab = names( dimnames( rates ) )[1],
       ylab = deparse( substitute( rates ) ), type = "l", lwd = 2, lty = 1,
       col = par( "fg" ), log.ax = "y", las = 1, c.col = col, p.col = col,
       c.ann = FALSE, p.ann = FALSE, xannx = 1/20, cex.ann = 0.8,
       c.thin = seq( 2, length( age ) + length( per ) - 1, 2 ),
       p.thin = seq( 1, length( per ), 2 ), p.lines = TRUE,
       c.lines = !p.lines, ... )

Pplot( rates, age = as.numeric( dimnames( rates )[[1]] ),
       per = as.numeric( dimnames( rates )[[2]] ), grid = FALSE,
       p.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       p.lim = range( per, na.rm=TRUE ) + c(0,diff(range(per))/30),
       ylim = range( rates[rates&gt;0], na.rm=TRUE ), p.lab = names( dimnames( rates ) )[2],
       ylab = deparse( substitute( rates ) ), at = NULL, labels = paste( at ),
       type = "l", lwd = 2, lty = 1, col = par( "fg" ), log.ax = "y",
       las = 1, ann = FALSE, cex.ann = 0.8, xannx = 1/20,
       a.thin = seq( 1, length( age ), 2 ), ... )

Cplot( rates, age = as.numeric( rownames( rates ) ),
       per = as.numeric( colnames( rates ) ), grid = FALSE,
       c.grid = grid, ygrid = grid, col.grid = gray( 0.9 ),
       c.lim = NULL, ylim = range( rates[rates&gt;0], na.rm=TRUE ),
       at = NULL, labels = paste( at ), c.lab = names( dimnames( rates ) )[2],
       ylab = deparse( substitute( rates ) ), type = "l", lwd = 2, lty = 1,
       col = par( "fg" ), log.ax = "y", las = 1, xannx = 1/20, ann = FALSE,
       cex.ann = 0.8, a.thin = seq( 1, length( age ), 2 ), ...  )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rateplot_+3A_rates">rates</code></td>
<td>
<p>A two-dimensional table (or array) with rates to be plotted. It is
assumed that the first dimension is age and the second is period.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_which">which</code></td>
<td>
<p>A character vector with elements from
<code>c("ap","ac","apc","pa","ca")</code>, indication which plots should
be produced. One plot per element is produced. The first letter
indicates the x-axis of the plot, the remaining which groups
should be connected, i.e. <code>"pa"</code> will plot rates versus
period and connect age-classes, and <code>"apc"</code> will plot rates
versus age, and connect both periods and cohorts.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_age">age</code></td>
<td>
<p>Numerical vector giving the means of the
age-classes. Defaults to the rownames of <code>rates</code> as numeric.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_per">per</code></td>
<td>
<p>Numerical vector giving the means of the periods. Defaults
to the columnnames of <code>rates</code> as numeric.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_grid">grid</code></td>
<td>
<p>Logical indicating whether a background grid should be drawn.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.grid">a.grid</code></td>
<td>
<p>Logical indicating whether a background grid on the
age-axis should be drawn. If numerical it indicates the
age-coordinates of the grid.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.grid">p.grid</code></td>
<td>
<p>do. for the period.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.grid">c.grid</code></td>
<td>
<p>do. for the cohort.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_ygrid">ygrid</code></td>
<td>
<p>do. for the rate-dimension.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_col.grid">col.grid</code></td>
<td>
<p>The colour of the grid.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.lim">a.lim</code></td>
<td>
<p>Range for the age-axis.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.lim">p.lim</code></td>
<td>
<p>Range for the period-axis.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.lim">c.lim</code></td>
<td>
<p>Range for the cohort-axis.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_ylim">ylim</code></td>
<td>
<p>Range for the y-axis (rates).</p>
</td></tr>
<tr><td><code id="rateplot_+3A_at">at</code></td>
<td>
<p>Position of labels on the y-axis (rates).</p>
</td></tr>
<tr><td><code id="rateplot_+3A_labels">labels</code></td>
<td>
<p>Labels to put on the y-axis (rates).</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.lab">a.lab</code></td>
<td>
<p>Text on the age-axis. Defaults to &quot;Age&quot;.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.lab">p.lab</code></td>
<td>
<p>Text on the period-axis. Defaults to &quot;Date of diagnosis&quot;.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.lab">c.lab</code></td>
<td>
<p>Text on the cohort-axis. Defaults to &quot;Date of birth&quot;.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_ylab">ylab</code></td>
<td>
<p>Text on the rate-axis. Defaults to the name of the rate-table.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_type">type</code></td>
<td>
<p>How should the curves be plotted. Defaults to <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_lwd">lwd</code></td>
<td>
<p>Width of the lines. Defaults to 2.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_lty">lty</code></td>
<td>
<p>Which type of lines should be used. Defaults to 1, a solid line.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_log.ax">log.ax</code></td>
<td>
<p>Character with letters from <code>"apcyr"</code>, indicating
which axes should be logarithmic. <code>"y"</code> and <code>"r"</code> both
refer to the rate scale. Defaults to <code>"y"</code>.</p>
</td></tr> 
<tr><td><code id="rateplot_+3A_las">las</code></td>
<td>
<p>see <code>par</code>.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_ann">ann</code></td>
<td>
<p>Should the curves be annotated?</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.ann">a.ann</code></td>
<td>
<p>Logical indicating whether age-curves should be annotated.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.ann">p.ann</code></td>
<td>
<p>do. for period-curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.ann">c.ann</code></td>
<td>
<p>do. for cohort-curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_xannx">xannx</code></td>
<td>
<p>The fraction that the x-axis is expanded when curves are annotated.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_cex.ann">cex.ann</code></td>
<td>
<p>Expansion factor for characters annotating curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.thin">a.thin</code></td>
<td>
<p>Vector of integers indicating which of the age-classes
should be labelled.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.thin">p.thin</code></td>
<td>
<p>do. for the periods.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.thin">c.thin</code></td>
<td>
<p>do. for the cohorts.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_col">col</code></td>
<td>
<p>Colours for the curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_a.col">a.col</code></td>
<td>
<p>Colours for the age-curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.col">p.col</code></td>
<td>
<p>do. for the period-curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.col">c.col</code></td>
<td>
<p>do. for the cohort-curves.</p>
</td></tr>
<tr><td><code id="rateplot_+3A_p.lines">p.lines</code></td>
<td>
<p>Should rates from the same period be connected?</p>
</td></tr>
<tr><td><code id="rateplot_+3A_c.lines">c.lines</code></td>
<td>
<p>Should rates from the same cohort be connected?</p>
</td></tr>
<tr><td><code id="rateplot_+3A_...">...</code></td>
<td>
<p>Additional arguments pssed on to <code>matlines</code> when
plotting the curves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero values of the rates are ignored. They are neiter in the plot nor in
the calculation of the axis ranges.
</p>


<h3>Value</h3>

<p><code>NULL</code>. The function is used for its side-effect, the plot.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apc.frame">apc.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( blcaIT )
attach(blcaIT)

# Table of rates:
bl.rate &lt;- tapply( D, list(age,period), sum ) /
           tapply( Y, list(age,period), sum )
bl.rate

# The four classical plots:
par( mfrow=c(2,2) )
rateplot( bl.rate*10^6 )

# The labels on the vertical axis could be nicer:
rateplot( bl.rate*10^6, at=10^(-1:3), labels=c(0.1,1,10,100,1000) ) 

# More bells an whistles
par( mfrow=c(1,3), mar=c(3,3,1,1), oma=c(0,3,0,0), mgp=c(3,1,0)/1.6 )
rateplot( bl.rate*10^6, ylab="", ann=TRUE, which=c("AC","PA","CA"),
                      at=10^(-1:3), labels=c(0.1,1,10,100,1000),
                      col=topo.colors(11), cex.ann=1.2 ) 
</code></pre>

<hr>
<h2 id='rcutLexis'>
A function to cut follow-up at intermediate event times.
</h2><span id='topic+rcutLexis'></span>

<h3>Description</h3>

<p>Cuts follow-up at intermediate event times, multiple events per person
are allowed, as well as recurrences of the sme type of event. The
resulting states only refer to the last assumed state, unlike the result
from <code><a href="#topic+mcutLexis">mcutLexis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcutLexis( Lx, cut,
    timescale = 1,
    precursor.states = transient(Lx))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcutLexis_+3A_lx">Lx</code></td>
<td>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object to be amended,.
</p>
</td></tr>
<tr><td><code id="rcutLexis_+3A_cut">cut</code></td>
<td>

<p>A data frame with columns <code>lex.id</code>, <code>cut</code> (event times) and
<code>new.state</code> (event type, character)
</p>
</td></tr>
<tr><td><code id="rcutLexis_+3A_timescale">timescale</code></td>
<td>

<p>What time scale do values in <code>cut$cut</code> refer to. Numeric or character.
</p>
</td></tr>
<tr><td><code id="rcutLexis_+3A_precursor.states">precursor.states</code></td>
<td>
<p>an optional vector of states to be considered
as &quot;less severe&quot; than <code>new.state</code>. See Details in the
documentation of <code><a href="#topic+cutLexis">cutLexis</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object with follow-up cut at the event
times supplied in <code>cut</code></p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+addCov.Lexis">addCov.Lexis</a></code>,
<code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(lex.id = rep(c(3, 7), c(3, 5)))
df$new.state &lt;- sample(LETTERS[2:4], 8, r = TRUE) 
df$cut &lt;- round(runif(8) * 100) + 1
df

Lx &lt;- Lexis( exit = list(time=c(89, 97)),
               id = c(3, 7),
      exit.status = factor(c("A", "X")) )
Lx 
rcutLexis(Lx, df, pre = "A")
        </code></pre>

<hr>
<h2 id='Relevel'>Reorder and combine levels of a factor</h2><span id='topic+Relevel'></span><span id='topic+Relevel.factor'></span>

<h3>Description</h3>

<p>The levels of a factor are re-ordered so that the levels specified by
<code>ref</code> appear first and remaining levels are moved down. This is
useful for <code>contr.treatment</code> contrasts which take the first level
as the reference. Factor levels may also be combined; two possibilities for
specifying this are supported: hard coding or table look-up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor'
Relevel( x, ref, first = TRUE, collapse="+",
                 xlevels=TRUE, nogroup=TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Relevel_+3A_x">x</code></td>
<td>
<p>A(n unordered) factor</p>
</td></tr>
<tr><td><code id="Relevel_+3A_ref">ref</code></td>
<td>
<p>Vector, list or data frame, array, matrix or table.
</p>
<p>If <code>ref</code> is a vector (integer or character), it is assumed it
contains the names or numbers of levels to be the first ones; non
mentioned levels are kept.
</p>
<p>If <code>ref</code> is a list (but not a data frame), factor levels
mentioned in each list element are combined. If the list is named
the names are used as new factor levels, otherwise new level names
are constructed from the old.
</p>
<p>If <code>ref</code> is a data frame or 2-dimensional array, matrix or
table, the first column is assumed to have unique levels of <code>x</code>
and the second to have groupings of this, respectively.
</p>
</td></tr>
<tr><td><code id="Relevel_+3A_first">first</code></td>
<td>
<p>Should the levels mentioned in <code>ref</code> (if it is a
list) come before those not?</p>
</td></tr> 
<tr><td><code id="Relevel_+3A_collapse">collapse</code></td>
<td>
<p>String used when constructing names for combined
factor levels.</p>
</td></tr> 
<tr><td><code id="Relevel_+3A_xlevels">xlevels</code></td>
<td>
<p>Logical. Should all levels in the 2nd column of
<code>ref</code> be maintained as levels of the result, or (if
<code>FALSE</code>) only the actually occurring.</p>
</td></tr>
<tr><td><code id="Relevel_+3A_nogroup">nogroup</code></td>
<td>
<p>Logical. Should levels present in the input but not in
the 1st column of <code>ref</code> be maintained as levels after the
grouping? If <code>FALSE</code>, NAs will be returned for such elements.</p>
</td></tr>
<tr><td><code id="Relevel_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The facility where <code>ref</code> is a two-column matrix mimics the
SAS-facility of formats where a dataset can be used to construct a
format &mdash; SAS format is the grouping tool for variable
values.
</p>
<p>If <code>ref</code> is a two-column object and <code>ref[,2]</code> is a factor
<code>Relevel</code> will preserve the order of levels from <code>ref[,2]</code>.  
</p>


<h3>Value</h3>

<p>An unordered factor, where levels of <code>x</code> have been reordered
and/or collapsed.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>, Lars Jorge Diaz</p>


<h3>See Also</h3>

<p><code><a href="#topic+Relevel.Lexis">Relevel.Lexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Grouping using a list (hard coding)
#
ff &lt;- factor(sample(letters[1:5], 100, replace = TRUE))
table( ff, Relevel(ff, list( AB = 1:2, "Dee" = 4, c(3,5))))
table( ff, Relevel(ff,
                   list( 5:4, Z = c("c", "a") ),
                   coll = "-und-",
                   first = FALSE ) )

## Grouping using a two-column matrix as input:
## A factor with levels to be grouped together
ff &lt;- factor(c("Bear","Bear","Crocodile","Snake","Crocodile","Bear"))
ff
## A grouping table
(gg &lt;- data.frame(Animal = c("Bear","Whale","Crocodile","Snake","Eagle"),
                   Class = c("Mammal","Mammal","Reptile","Reptile","Bird")))
str(gg)
Relevel(ff, gg, xlevels = FALSE)
Relevel(ff, gg )
Relevel(ff, gg[c(1:5,5:1),])

## This crashes with an error
(GG &lt;- rbind( gg, c("Bear","Reptile")))
try(Relevel(ff, GG))

ff &lt;- factor(c(as.character(ff), "Jellyfish", "Spider"))
Relevel(ff, gg)
# excludes non-occupied levels
Relevel(ff, gg, xlevels = FALSE)
# If you do not want unknown animals classified, this returns NAs:
Relevel(ff, gg, nogroup = FALSE)
# Both
Relevel(ff, gg, nogroup = FALSE, xlevels = FALSE) 
</code></pre>

<hr>
<h2 id='rm.tr'>
Remove transitions from a Lexis object.
</h2><span id='topic+rm.tr'></span>

<h3>Description</h3>

<p>Sometimes certain transitions are not of interest. This function removes
these and assigns the risk time in the target state of the transitions
to the originating state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.tr(obj, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.tr_+3A_obj">obj</code></td>
<td>

<p>A <code>Lexis</code> object.
</p>
</td></tr>
<tr><td><code id="rm.tr_+3A_from">from</code></td>
<td>

<p>Character; name of the state from which the transition to be purged
originates. Must be a valid state name for <code>obj</code>.
</p>
</td></tr>
<tr><td><code id="rm.tr_+3A_to">to</code></td>
<td>

<p>Character; name of the state to which the transition to be purged
targets. Must be a valid state name for <code>obj</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes all transitions from <code>from</code> to <code>to</code>, and
assigns all risk time in the <code>to</code> state after the transition
(<code>lex.dur</code>) to the <code>from</code> state. This is only done for risk
time in <code>to</code> occurring directly after <code>from</code>. Risk time in
<code>to</code> occurring after a transition from states different from
<code>from</code> is not affected. Transitions from <code>to</code> to another
state, <code>other</code>, say, will be changed to transitions from
<code>from</code> to <code>other</code>. 
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Lexis">Lexis</a></code> object with the indicated transition removed.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Relevel">Relevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
dml &lt;- Lexis( entry = list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate )

# A small subset for illustration
dml &lt;- subset( dml, lex.id %in% c(13,15,20,28,40) )

# Cut the follow-up at start of insulin therapy
dmi &lt;- cutLexis( dml, cut = dml$doins,
                      pre = "DM",
                new.state = "Ins" )[,1:10]

# How does it look?
dmi

# Remove all transitions DM -&gt; Ins
rm.tr( dmi, "DM", "Ins" )
</code></pre>

<hr>
<h2 id='ROC'>Function to compute and draw ROC-curves.</h2><span id='topic+ROC'></span>

<h3>Description</h3>

<p>Computes sensitivity, specificity and positive and negative predictive
values for a test based on dichotomizing along the variable
<code>test</code>, for prediction of <code>stat</code>. Plots curves of these and a ROC-curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROC( test = NULL,
     stat = NULL,
     form = NULL,
     plot = c("sp", "ROC"),
       PS = is.null(test),
       PV = TRUE,
       MX = TRUE,
       MI = TRUE,
      AUC = TRUE,
     grid = seq(0,100,10),
 col.grid = gray( 0.9 ),
     cuts = NULL,
      lwd = 2,
     data = parent.frame(),
      ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROC_+3A_test">test</code></td>
<td>
<p> Numerical variable used for prediction. </p>
</td></tr>
<tr><td><code id="ROC_+3A_stat">stat</code></td>
<td>
<p> Logical variable of true status. </p>
</td></tr>
<tr><td><code id="ROC_+3A_form">form</code></td>
<td>
<p> Formula used in a logistic regression. If this is given,
<code>test</code> and <code>stat</code> are ignored. If not given then
both <code>test</code> and <code>stat</code> must be supplied. </p>
</td></tr>
<tr><td><code id="ROC_+3A_plot">plot</code></td>
<td>
<p> Character variable. If &quot;sp&quot;, the a plot of sensitivity,
specificity and predictive values against test is produced, if &quot;ROC&quot; a
ROC-curve is plotted. Both may be given.</p>
</td></tr>
<tr><td><code id="ROC_+3A_ps">PS</code></td>
<td>
<p>logical, if TRUE the x-axis in the
plot &quot;ps&quot;-plot is the the predicted probability for
<code>stat</code>==TRUE, otherwise it is the scale of <code>test</code> if this
is given otherwise the scale of the linear predictor from the
logistic regression.</p>
</td></tr>
<tr><td><code id="ROC_+3A_pv">PV</code></td>
<td>
<p>Should sensitivity, specificity and
predictive values at the optimal cutpoint be given on the ROC plot? </p>
</td></tr>
<tr><td><code id="ROC_+3A_mx">MX</code></td>
<td>
<p>Should the &ldquo;optimal cutpoint&rdquo; (i.e. where sens+spec is
maximal) be indicated on the ROC curve?</p>
</td></tr>
<tr><td><code id="ROC_+3A_mi">MI</code></td>
<td>
<p>Should model summary from the logistic
regression model be printed in the plot?</p>
</td></tr>
<tr><td><code id="ROC_+3A_auc">AUC</code></td>
<td>
<p>Should the area under the curve (AUC) be printed in the ROC
plot?</p>
</td></tr>
<tr><td><code id="ROC_+3A_grid">grid</code></td>
<td>
<p>Numeric or logical. If FALSE no background grid is
drawn. Otherwise a grid is drawn on both axes at <code>grid</code> percent.</p>
</td></tr>
<tr><td><code id="ROC_+3A_col.grid">col.grid</code></td>
<td>
<p>Colour of the grid lines drawn.</p>
</td></tr>
<tr><td><code id="ROC_+3A_cuts">cuts</code></td>
<td>
<p>Points on the test-scale to be annotated on the
ROC-curve. </p>
</td></tr>
<tr><td><code id="ROC_+3A_lwd">lwd</code></td>
<td>
<p>Thickness of the curves</p>
</td></tr>
<tr><td><code id="ROC_+3A_data">data</code></td>
<td>
<p>Data frame in which to interpret the variables.</p>
</td></tr>
<tr><td><code id="ROC_+3A_...">...</code></td>
<td>
<p>Additional arguments for the plotting of the
ROC-curve. Passed on to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an alternative to a <code>test</code> and a <code>status</code> variable, a
model formula may given, in which case the the linear predictor is the
test variable and the response is taken as the true status variable.
The test used to derive  sensitivity, specificity, PV+ and PV- as a
function of <code class="reqn">x</code> is <code>test</code><code class="reqn">\geq x</code> as a predictor of
<code>stat</code>=TRUE.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>dataframe with variables <code>sens</code>, <code>spec</code>,
<code>pvp</code>, <code>pvn</code> and name of the test variable. The latter is
the unique values of test or linear predictor from the logistic
regression in ascending order with -Inf prepended. Since the
sensitivity is defined as <code class="reqn">P(test&gt;x)|status=TRUE</code>, the first row
has <code>sens</code> equal to 1 and <code>spec</code> equal to 0, corresponding
to drawing the ROC curve from the upper right to the lower left corner.</p>
</td></tr>
<tr><td><code>lr</code></td>
<td>
<p>glm object with the logistic regression result used for
construction of the ROC curve</p>
</td></tr>
</table>
<p>0, 1 or 2 plots are produced according to the setting of <code>plot</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, Steno Diabetes Center &amp; University of
Copenhagen,
<a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm( 100 )
z &lt;- rnorm( 100 )
w &lt;- rnorm( 100 )
tigol &lt;- function( x ) 1 - ( 1 + exp( x ) )^(-1)
y &lt;- rbinom( 100, 1, tigol( 0.3 + 3*x + 5*z + 7*w ) )
ROC( form = y ~ x + z, plot="ROC" )
</code></pre>

<hr>
<h2 id='S.typh'>Salmonella Typhimurium outbreak 1996 in Denmark.</h2><span id='topic+S.typh'></span>

<h3>Description</h3>

<p>Matched case-control study of food poisoning.
</p>


<h3>Format</h3>

<p>A data frame with 136 observations on the following 15 variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>id</code>: </td><td style="text-align: left;"> Person identification </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>set</code>: </td><td style="text-align: left;"> Matched set indicator </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>case</code>: </td><td style="text-align: left;"> Case-control status (1:case, 0:control </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>age</code>: </td><td style="text-align: left;"> Age of individual </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>sex</code>: </td><td style="text-align: left;"> Sex of individual (1:male, 2:female) </td>
</tr>
<tr>
 <td style="text-align: right;"> 
    <code>abroad</code>: </td><td style="text-align: left;"> Within the last two weeks visited abroad (1:yes, 0:no) </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>beef</code>: </td><td style="text-align: left;"> Within the last two weeks eaten beef </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>pork</code>: </td><td style="text-align: left;"> Within the last two weeks eaten pork </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>veal</code>: </td><td style="text-align: left;"> Within the last two weeks eaten veal </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>poultry</code>: </td><td style="text-align: left;"> Within the last two weeks eaten poultry </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>liverp</code>: </td><td style="text-align: left;"> Within the last two weeks eaten liverpaste </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>veg</code>: </td><td style="text-align: left;"> Within the last two weeks eaten vegetables </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>fruit</code>: </td><td style="text-align: left;"> Within the last two weeks eaten fruit </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>egg</code>: </td><td style="text-align: left;"> Within the last two weeks eaten eggs </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>plant7</code>: </td><td style="text-align: left;"> Within the last two weeks eaten meat from plant no. 7 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>In the fall of 1996 an unusually large number of Salmonella
Typhimurium cases were recorded in Fyn county in Denmark. The Danish
Zoonosis Centre set up a matched case-control study to find the
sources. Cases and two age-, sex- and residency-matched controls were
telephone interviewed about their food intake during the last two
weeks.
</p>
<p>The participants were asked at which retailer(s) they had purchased
meat. Retailers were independently of this linked to meat processing
plants, and thus participants were linked to meat processing
plants. This way persons could be linked to (amongst other) plant no 7.</p>


<h3>Source</h3>

<p>Tine Hald.
</p>


<h3>References</h3>

<p>Molbak K and Hald T: Salmonella Typhimurium outbreak in late summer
1996. A Case-control study. (In Danish:
Salmonella typhimurium udbrud paa Fyn sensommeren
1996. En case-kontrol undersogelse.) Ugeskrift for Laeger.,
159(36):5372-7, 1997.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(S.typh)
</code></pre>

<hr>
<h2 id='simLexis'>Simulate a Lexis object representing follow-up in a multistate
model.</h2><span id='topic+simLexis'></span><span id='topic+nState'></span><span id='topic+pState'></span><span id='topic+plot.pState'></span><span id='topic+lines.pState'></span>

<h3>Description</h3>

<p>Based on a (pre-)<code>Lexis</code> object representing persons
at given states and times, and full specification of transition
intensities between states in the form of models for the transition
rates, this function simulates transition times and -types for persons
and returns a <code>Lexis</code> object representing the simulated
cohort. The simulation scheme accommodates multiple timescales,
including time since entry into an intermediate state, and accepts
fitted Poisson models, Cox-models or just a function as specification
of rates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLexis( Tr, init,
           N = 1,
      lex.id,
     t.range = 20,
       n.int = 101,
    time.pts = seq(0,t.range,length.out=n.int) )
nState( obj, at, from, time.scale = 1 )
pState( nSt, perm = 1:ncol(nSt) )
## S3 method for class 'pState'
plot( x,
                     col = rainbow(ncol(x)),
                  border = "transparent",
                    xlab = "Time",
                    ylim = 0:1,
                    ylab = "Probability", ... )
## S3 method for class 'pState'
lines( x,
                      col = rainbow(ncol(x)),
                   border = "transparent", ... )
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simLexis_+3A_tr">Tr</code></td>
<td>
<p>A named list of named lists. The names of the list are names
of the transient states in the model. Each list element is again a
named list. The names of the elements of this inner list are the
names of the states reachable from the state with name equal to the
list. Elements of the intter lists represent transitions. See details.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_init">init</code></td>
<td>
<p>A (pre-)<code><a href="#topic+Lexis">Lexis</a></code> object representing the initial
state of the persons whose trajectories through the multiple states
we want to simulate. Must have attributes &quot;time.scales&quot; and &quot;time.since&quot; &mdash; see
details. Duplicate values of <code>lex.id</code> are not sensible and not
accepted.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_n">N</code></td>
<td>
<p>Numeric. How many persons should be simulated. <code>N</code>
persons with covariate configuration of each row in <code>init</code>
will be simulated. Either a scalar or a vector of length <code>nrow(init)</code>.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_lex.id">lex.id</code></td>
<td>
<p>Vector of ids of the simulated persons. Useful when
simulating in chunks.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_t.range">t.range</code></td>
<td>
<p>Numerical scalar. The range of time over which to
compute the cumulative rates when simulating. Simulted times
beyond this will result in an obervation censored at <code>t.range</code>
after entry.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_n.int">n.int</code></td>
<td>
<p>Number of intervals to use when computing (cumulative) rates.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_time.pts">time.pts</code></td>
<td>
<p>Numerical vector of times since start. Cumulative
rates for transitions are computed at these times after stater and
entry state. Simulation is only done till time <code>max(time.pts)</code>
after start, where persons are censored. Must start with 0.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_obj">obj</code></td>
<td>
<p>A <code>Lexis</code> object.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_from">from</code></td>
<td>
<p>The point on the time scale <code>time.scale</code> from which
we start counting.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_time.scale">time.scale</code></td>
<td>
<p>The timescale to which <code>from</code> refer.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_at">at</code></td>
<td>
<p>Time points (after <code>from</code>) where the number of persons
in each state is to be computed.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_nst">nSt</code></td>
<td>
<p>A table obtained by <code>nState</code>.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_perm">perm</code></td>
<td>
<p>A permutation of columns used before cumulating row-wise
and taking percentages.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_x">x</code></td>
<td>
<p>An object of class <code>pState</code>, e.g. created by <code>pState</code>.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_col">col</code></td>
<td>
<p>Colors for filling the areas between curves.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_border">border</code></td>
<td>
<p>Colors for outline of the areas between curves.</p>
</td></tr>
<tr><td><code id="simLexis_+3A_xlab">xlab</code></td>
<td>
<p>Label on x-axis</p>
</td></tr>
<tr><td><code id="simLexis_+3A_ylim">ylim</code></td>
<td>
<p>Limits on y-axis</p>
</td></tr>
<tr><td><code id="simLexis_+3A_ylab">ylab</code></td>
<td>
<p>Label on y-axis</p>
</td></tr>
<tr><td><code id="simLexis_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation command <code>simLexis</code> is not defined as a
method for <code>Lexis</code> objects, because the input is not a
<code>Lexis</code> object, the <code>Lexis</code>-like object is merely
representing a prevalent population and a specification of which
variables that are timescales. The variables <code>lex.dur</code> and
<code>lex.Xst</code> are ignored (and overwritten) if present. The core
input is the list <code>Tr</code> giving the transitions.
</p>
<p>The components of <code>Tr</code> represents the transition intensities
between states. The transition from state <code>A</code> to <code>B</code>, say,
is assumed stored in <code>Tr$A$B</code>. Thus names of the elements of
<code>Tr</code> are names of transient states, and the names of the elements
of each these are the names of states reachable from the corresponding
transient state.
</p>
<p>The transition intensities are assumed modelled by either a glm with
Poisson family or a Cox-model. In both cases the timescale(s) in the
model must be using the names fo the timescales in a Lexis object
representng the follow-up in a cohort, and the risk time must be taken
from the variable <code>lex.dur</code> &mdash; see the example.
</p>
<p>Alternatively, an element in <code>Tr</code> could be a function
that from a data frame produces transition rates, or specifically
cumulative transition rates over intervals of length <code>lex.dur</code>.
</p>
<p>The pre-<code>Lexis</code> object <code>init</code> must contain values of all
variables used in any of the objects in <code>Tr</code>, as well as all
timescales - even those not used in the models. Moreover, the
attributes <code>time.scales</code> and <code>time.since</code> must be
present. The attribute <code>time.since</code> is a character vector of the
same length as <code>time.scales</code> and an element has value <code>"A"</code>
if the corresponding time scale is defined as
&quot;time since entry into state <code>A</code>&quot;, otherwise the value is
<code>""</code>. If not present it will be set to a vector of <code>""</code>s,
which is only OK if no time scales are defined as time since entry to
a state.
</p>
<p>Note that the variables pre-<code>Lexis</code> object <code>init</code> must have
the same mode and class as in the dataset used for fitting the models
&mdash; hence the indexing of rows by brackets in the assignment of values used in
the example below - this way the variables have their attributes
preserved; using <code>init[,"var"] &lt;-</code> or <code>init$var &lt;-</code> replaces
the variable, whereas  <code>init[1:4,"var"] &lt;-</code> or
<code>init$var[1:4] &lt;-</code> replaces values only and prevents you from
entering non-existing factor levels etc.
</p>
<p>The function <code><a href="#topic+Lexis">Lexis</a></code> automatically generates an attribute
<code>time.since</code>, and <code><a href="#topic+cutLexis">cutLexis</a></code> updates it when new time
scales are defined. Hence, the simplest way of defining a initial
pre-<code>Lexis</code> object representing a current state of a (set of) persons
to be followed through a multistate model is to take <code>NULL</code> rows
of an existing Lexis object (normally the one used for estimation),
and so ensuring that all relevant attributes and state levels are
properly defined. See the example code.
</p>
<p>The prevalence function <code>nState</code> computes the distribution of
individuals in different states at prespecified times. Only sensible
for a simulated <code>Lexis</code> object. The function <code>pState</code> takes
a matrix as output by <code>nState</code> and computes the row-wise
cumulative probabilities across states, and leaves an object of class
<code>pState</code>, suitable for plotting.
</p>


<h3>Value</h3>

<p><code>simLexis</code> returns a <code><a href="#topic+Lexis">Lexis</a></code> object representing
the experience of a population starting as <code>init</code> followed
through the states according to the transitions in <code>Tr</code>.
</p>
<p>The function <code>nState</code> returns a table of persons classified by
states at each of the times in <code>at</code>. Note that this function can
easily produce meaningless results, for example if applied to a
<code>Lexis</code> object not created by simulation. If you apply it to a
<code>Lexis</code> object generated by <code>simLexis</code>, you must make sure
that you start (<code>from</code>) the point where you started the
simulation on the correct timescale, and you will get funny results if
you try to tabulate beyond the censoring time for the simulation.
The resulting object has class <code>"table"</code>.
</p>
<p>The result from using <code>pState</code> on the result from <code>nState</code>
has class <code>c("pState","matrix")</code>.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+splitLexis">splitLexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
dml &lt;- Lexis( entry = list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate[runif(nrow(DMlate))&lt;0.1,] )
# Split follow-up at insulin, introduce a new timescale,
# and split non-precursor states
dmi &lt;- cutLexis( dml, cut = dml$doins,
                      pre = "DM",
                new.state = "Ins",
                new.scale = "t.Ins",
             split.states = TRUE )
# Split the follow in 1-year intervals for modelling
Si &lt;- splitLexis( dmi, 0:30/2, "DMdur" )
# Define knots
nk &lt;- 4
( ai.kn &lt;- with( subset(Si,lex.Xst=="Ins"),
                 quantile( Age+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( ad.kn &lt;- with( subset(Si,lex.Xst=="Dead"),
                 quantile( Age+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( di.kn &lt;- with( subset(Si,lex.Xst=="Ins"),
                 quantile( DMdur+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( dd.kn &lt;- with( subset(Si,lex.Xst=="Dead"),
                 quantile( DMdur+lex.dur, probs=(1:nk-0.5)/nk ) ) )
( td.kn &lt;- with( subset(Si,lex.Xst=="Dead(Ins)"),
                 quantile( t.Ins+lex.dur, probs=(1:nk-0.5)/nk ) ) )

# Fit Poisson models to transition rates
library( splines )
DM.Ins &lt;- glm( (lex.Xst=="Ins") ~ Ns( Age  , knots=ai.kn ) +
                                  Ns( DMdur, knots=di.kn ) +
                                  I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="DM") )
DM.Dead &lt;- glm( (lex.Xst=="Dead") ~ Ns( Age  , knots=ad.kn ) +
                                    Ns( DMdur, knots=dd.kn ) +
                                    I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="DM") )
Ins.Dead &lt;- glm( (lex.Xst=="Dead(Ins)") ~ Ns( Age  , knots=ad.kn ) +
                                          Ns( DMdur, knots=dd.kn ) +
                                          Ns( t.Ins, knots=td.kn ) +
                                          I(Per-2000) + sex,
               family=poisson, offset=log(lex.dur),
               data = subset(Si,lex.Cst=="Ins") )

# Stuff the models into an object representing the transitions
Tr &lt;- list( "DM" = list( "Ins"       = DM.Ins,
                         "Dead"      = DM.Dead  ),
           "Ins" = list( "Dead(Ins)" = Ins.Dead ) )
lapply( Tr, names )

# Define an initial object - note the subsetting that ensures that
# all attributes are carried over
ini &lt;- Si[1,1:9][-1,]
ini[1:2,"lex.Cst"] &lt;- "DM"
ini[1:2,"Per"] &lt;- 1995
ini[1:2,"Age"] &lt;- 60
ini[1:2,"DMdur"] &lt;- 5
ini[1:2,"sex"] &lt;- c("M","F")
str(ini)

# Simulate 200 of each sex using the estimated models in Tr
simL &lt;- simLexis( Tr, ini, time.pts=seq(0,11,0.5), N=200 )
summary( simL )

# Find the number of persons in each state at a set of times.
# Note that the times are shirter than the time-span simulated.
nSt &lt;- nState( subset(simL,sex=="M"),
               at=seq(0,10,0.1), from=1995, time.scale="Per" )
nSt

# Show the cumulative prevalences in a different order than that of the
# state-level ordering and plot them using all defaults
pp &lt;- pState( nSt, perm=c(1,2,4,3) )
head( pp )
plot( pp )

# A more useful set-up of the graph
clr &lt;- c("orange2","forestgreen")
par( las=1 )
plot( pp, col=clr[c(2,1,1,2)] )
lines( as.numeric(rownames(pp)), pp[,2], lwd=2 )
mtext( "60 year old male, diagnosed 1995", side=3, line=2.5, adj=0 )
mtext( "Survival curve", side=3, line=1.5, adj=0 )
mtext( "DM, no insulin   DM, Insulin", side=3, line=0.5, adj=0, col=clr[1] )
mtext( "DM, no insulin", side=3, line=0.5, adj=0, col=clr[2] )
axis( side=4 )

# Using a Cox-model for the mortality rates assuming the two mortality
# rates to be proportional:
# When we fit a Cox-model, lex.dur must be used in the Surv() function,
# and the I() constrction must be used when specifying intermediate
# states as covariates, since factors with levels not present in the
# data will create NAs in the parameter vector returned by coxph, which
# in return will crash the simulation machinery.
library( survival )
Cox.Dead &lt;- coxph( Surv( DMdur, DMdur+lex.dur,
                         lex.Xst %in% c("Dead(Ins)","Dead")) ~
                   Ns( Age-DMdur, knots=ad.kn ) +
                   I(lex.Cst=="Ins") +
                   I(Per-2000) + sex,
               data = Si )
Cr &lt;- list( "DM" = list( "Ins"       = DM.Ins,
                         "Dead"      = Cox.Dead  ),
           "Ins" = list( "Dead(Ins)" = Cox.Dead ) )
simL &lt;- simLexis( Cr, ini, time.pts=seq(0,11,0.2), N=200 )
summary( simL )
nSt &lt;- nState( subset(simL,sex=="M"),
               at=seq(0,10,0.2), from=1995, time.scale="Per" )
pp &lt;- pState( nSt, perm=c(1,2,4,3) )
plot( pp )
</code></pre>

<hr>
<h2 id='splitLexis'>Split follow-up time in a Lexis object</h2><span id='topic+splitLexis'></span>

<h3>Description</h3>

<p>The <code>splitLexis</code> function divides each row of a <code>Lexis</code>
object into disjoint follow-up intervals according to the supplied
break points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitLexis(lex, breaks, time.scale, tol=.Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitLexis_+3A_lex">lex</code></td>
<td>
<p>an object of class <code>Lexis</code></p>
</td></tr>
<tr><td><code id="splitLexis_+3A_breaks">breaks</code></td>
<td>
<p>a vector of break points</p>
</td></tr>
<tr><td><code id="splitLexis_+3A_time.scale">time.scale</code></td>
<td>
<p>the name or number of the time scale to be split</p>
</td></tr>
<tr><td><code id="splitLexis_+3A_tol">tol</code></td>
<td>
<p>numeric value &gt;= 0. Intervals shorter than this value are
dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Lexis</code> with multiple rows for each row of
the argument <code>lex</code>. Each row of the new <code>Lexis</code> object
contains the part of the follow-up interval that falls inside one of
the time bands defined by the break points.
</p>
<p>The variables representing the various time scales, are appropriately
updated in the new <code>Lexis</code> object. The entry and exit status
variables are also updated according to the rule that the entry status
is retained until the end of follow-up. All other variables are
considered to represent variables that are constant in time, and so
are replicated across all rows having the same id value.
</p>


<h3>Note</h3>

<p>The <code>splitLexis()</code> function divides follow-up time into intervals
using breakpoints that are common to all rows of the <code>Lexis</code> object.
To split a <code>Lexis</code> object by break points that are unique to each
row, use the <code>cut.Lexis</code> function.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeBand">timeBand</a></code>,
<code><a href="#topic+cutLexis">cutLexis</a></code>,
<code><a href="#topic+mcutLexis">mcutLexis</a></code>,
<code><a href="#topic+summary.Lexis">summary.Lexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># A small bogus cohort
xcoh &lt;- structure( list( id = c("A", "B", "C"),
                      birth = c("14/07/1952", "01/04/1954", "10/06/1987"),
                      entry = c("04/08/1965", "08/09/1972", "23/12/1991"),
                       exit = c("27/06/1997", "23/05/1995", "24/07/1998"),
                       fail = c(1, 0, 1) ),
                     .Names = c("id", "birth", "entry", "exit", "fail"),
                  row.names = c("1", "2", "3"),
                      class = "data.frame" )

# Convert the character dates into numerical variables (fractional years)
xcoh$bt &lt;- cal.yr( xcoh$birth, format="%d/%m/%Y" )
xcoh$en &lt;- cal.yr( xcoh$entry, format="%d/%m/%Y" )
xcoh$ex &lt;- cal.yr( xcoh$exit , format="%d/%m/%Y" )

# See how it looks
xcoh

# Define as Lexis object with timescales calendar time and age
Lcoh &lt;- Lexis( entry = list( per=en ),
                exit = list( per=ex, age=ex-bt ),
         exit.status = fail,
                data = xcoh )

# Default plot of follow-up
plot( Lcoh )

# With a grid and deaths as endpoints
plot( Lcoh, grid=0:10*10, col="black" )
points( Lcoh, pch=c(NA,16)[Lcoh$lex.Xst+1] )

# With a lot of bells and whistles:
plot( Lcoh, grid=0:20*5, col="black", xaxs="i", yaxs="i",
      xlim=c(1960,2010), ylim=c(0,50), lwd=3, las=1 )
points( Lcoh, pch=c(NA,16)[Lcoh$lex.Xst+1], col="red", cex=1.5 )

# Split time along two time-axes
( x2 &lt;- splitLexis( Lcoh, breaks = seq(1900,2000,5), time.scale="per") )
( x2 &lt;- splitLexis( x2, breaks = seq(0,80,5), time.scale="age" ) )
str( x2 )

# Tabulate the cases and the person-years
summary( x2 )
tapply( status(x2,"exit")==1, list( timeBand(x2,"age","left"),
                                    timeBand(x2,"per","left") ), sum )
tapply( dur(x2),  list( timeBand(x2,"age","left"),
                        timeBand(x2,"per","left") ), sum )
</code></pre>

<hr>
<h2 id='stack.Lexis'>
Functions to facilitate analysis of multistate models.
</h2><span id='topic+stack.Lexis'></span><span id='topic+tmat'></span><span id='topic+tmat.Lexis'></span>

<h3>Description</h3>

<p><code>stack.Lexis</code> produces a stacked object suited for analysis of
several transition intensities simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
stack(x, ...)
tmat( x, ... )
## S3 method for class 'Lexis'
tmat(x, Y=FALSE, mode = "numeric", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack.Lexis_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+Lexis">Lexis</a></code> object.</p>
</td></tr>
<tr><td><code id="stack.Lexis_+3A_y">Y</code></td>
<td>
<p>Logical. Should the risk time be put in the diagonal? This is
a facility which is used by <code><a href="#topic+boxes.Lexis">boxes.Lexis</a></code>.</p>
</td></tr>
<tr><td><code id="stack.Lexis_+3A_mode">mode</code></td>
<td>
<p>Should the matrix be returned as a numeric matrix with
<code>NA</code>s at unused places or (<code>mode="logical"</code>) as a logical
matrix with <code>FALSE</code> on the diagonal.</p>
</td></tr>
<tr><td><code id="stack.Lexis_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tmat.Lexis</code> returns a square transition matrix, classified by the
levels of <code>lex.Cst</code> and <code>lex.Xst</code>, for every transition
occurring the entry is the number of transitions occurring and <code>NA</code>
in all oter entries. If <code>Y=TRUE</code>, the diagonal will contain the
risk time in each of the states.
</p>
<p><code>stack.Lexis</code> returns a dataframe to be used for analysis of
multistate data when all transitions are modelled together, for example
if some parameters are required to be the same for different transitions.
The dataframe has class <code>stacked.Lexis</code>, and inherits the
attributes <code>time.scales</code> and <code>breaks</code> from the <code>Lexis</code>
object, and so function <code><a href="#topic+timeBand">timeBand</a></code> applies to a
<code>stacked.Lexis</code> object too.
</p>
<p>The dataframe has same variables as the original <code>Lexis</code> object,
but with each record duplicated as many times as there are possible
exits from the current state, <code>lex.Cst</code>. Two variables are added:
<code>lex.Fail</code>, an indicator of wheter an event for the transition
named in the factor <code>lex.Tr</code> has occurred or not. <code>lex.Tr</code> is
a factor with levels made up of combinations of the levels of
<code>lex.Cst</code> and <code>lex.Xst</code> that do occur together in <code>x</code>,
joined by a &quot;<code>-&gt;</code>&quot;.</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="mailto:b@bxc.dk">b@bxc.dk</a>, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitLexis">splitLexis</a></code>
<code><a href="#topic+cutLexis">cutLexis</a></code>
<code><a href="#topic+Lexis">Lexis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DMlate)
str(DMlate)
dml &lt;- Lexis( entry=list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit=list(Per=dox),
        exit.status=factor(!is.na(dodth),labels=c("DM","Dead")),
               data=DMlate )
dmi &lt;- cutLexis( dml, cut=dml$doins, new.state="Ins", pre="DM" )
summary( dmi )
ls.dmi &lt;- stack( dmi )
str( ls.dmi )
# Check that all the transitions and person-years got across.
with( ls.dmi, rbind( table(lex.Fail,lex.Tr),
                     tapply(lex.dur,lex.Tr,sum) ) )
</code></pre>

<hr>
<h2 id='stat.table'>Tables of summary statistics</h2><span id='topic+stat.table'></span><span id='topic+print.stat.table'></span>

<h3>Description</h3>

<p><code>stat.table</code> creates tabular summaries of the data, using a
limited set of functions. A list of index variables is used
to cross-classify summary statistics. It does NOT work inside <code>with()</code>!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat.table(index, contents = count(), data, margins = FALSE)
## S3 method for class 'stat.table'
print(x, width=7, digits,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat.table_+3A_index">index</code></td>
<td>
<p>A factor, or list of factors, used for cross-classification.
If the list is named, then the names will be used when printing the
table. This feature can be used to give informative labels to the
variables.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_contents">contents</code></td>
<td>
<p>A function call, or list of function calls. Only a
limited set of functions may be called (See Details below).  If the
list is named, then the names will be used when printing the table.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables to be
tabulated. If this is omitted, the variables will be searched for in the
calling environment.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_margins">margins</code></td>
<td>
<p>a logical scalar or vector indicating which  marginal
tables are to be calculated.  If a vector, it should be the same
length as the <code>index</code> argument: values corresponding to
<code>TRUE</code> will be retained in marginal tables.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_x">x</code></td>
<td>
<p>an object of class <code>stat.table</code>.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_width">width</code></td>
<td>
<p>a scalar giving the minimum column width when printing.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_digits">digits</code></td>
<td>
<p>a scalar, or named vector, giving the number
of digits to print after the decimal point. If a named vector is used,
the names should correspond to one of the permitted functions (See
Details below) and all results obtained with that function will be
printed with the same precision.</p>
</td></tr>
<tr><td><code id="stat.table_+3A_...">...</code></td>
<td>
<p>further arguments passed to other print methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>tapply</code>, with some enhancements:
multiple summaries of multiple variables may be mixed in the
same table; marginal tables may be calculated; columns and rows may
be given informative labels; pretty printing may be controlled by the
associated print method.
</p>
<p>This function is not a replacement for <code>tapply</code> as it also has
some limitations.  The only functions that may be used in the
<code>contents</code> argument  are: <code><a href="#topic+count">count</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>, <code><a href="base.html#topic+sum">sum</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="stats.html#topic+median">median</a></code>, <code><a href="stats.html#topic+IQR">IQR</a></code>,
<code><a href="base.html#topic+max">max</a></code>, <code><a href="base.html#topic+min">min</a></code>, <code><a href="#topic+ratio">ratio</a></code>, 
<code><a href="#topic+percent">percent</a></code>, and <code><a href="stats.html#topic+sd">sd</a></code>.
</p>
<p>The <code>count()</code> function, which is the default, simply creates a
contingency table of counts.  The other functions are applied to
each cell created by combinations of the <code>index</code> variables.
</p>


<h3>Value</h3>

<p>An object of class <code>stat.table</code>, which is a multi-dimensional
array. A print method is available to create formatted one-way and
two-way tables.
</p>


<h3>Note</h3>

<p>The permitted functions in the contents list 
are defined inside <code>stat.table</code>.  They have the same interface as
the functions callable from the command line, except for two
differences. If there is an argument <code>na.rm</code> then its default
value is always <code>TRUE</code>. A second difference is that the
<code>quantile</code> function can only produce a single quantile in each call.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="base.html#topic+tapply">tapply</a></code>,
<code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>,
<code><a href="base.html#topic+sum">sum</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="stats.html#topic+median">median</a></code>, <code><a href="stats.html#topic+IQR">IQR</a></code>,
<code><a href="base.html#topic+max">max</a></code>, <code><a href="base.html#topic+min">min</a></code>, <code><a href="#topic+ratio">ratio</a></code>,
<code><a href="#topic+percent">percent</a></code>, <code><a href="#topic+count">count</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warpbreaks)
# A one-way table
stat.table(tension,list(count(),mean(breaks)),data=warpbreaks)
# The same table with informative labels
stat.table(index=list("Tension level"=tension),list(N=count(),
           "mean number of breaks"=mean(breaks)),data=warpbreaks)

# A two-way table
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks)  
# The same table with margins over tension, but not wool
stat.table(index=list(tension,wool),mean(breaks),data=warpbreaks,
           margins=c(TRUE, FALSE))

# A table of column percentages
stat.table(list(tension,wool), percent(tension), data=warpbreaks)
# Cell percentages, with margins
stat.table(list(tension,wool),percent(tension,wool), margin=TRUE,
           data=warpbreaks)

# A table with multiple statistics
# Note how each statistic has its own default precision
a &lt;- stat.table(index=list(wool,tension),
                contents=list(count(),mean(breaks),percent (wool)),
                data=warpbreaks)
print(a)
# Print the percentages rounded to the nearest integer
print(a, digits=c(percent=0))

</code></pre>

<hr>
<h2 id='stattable.funs'>Special functions for use in stat.table</h2><span id='topic+count'></span><span id='topic+percent'></span><span id='topic+ratio'></span>

<h3>Description</h3>

<p>These functions may be used as <code>contents</code> arguments to the
function <code>stat.table</code>. They are defined internally in
<code>stat.table</code> and have no independent existence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(id)
ratio(d,y,scale=1, na.rm=TRUE)
percent(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stattable.funs_+3A_id">id</code></td>
<td>
<p>numeric vector in which identical values identify the
same individual.</p>
</td></tr>
<tr><td><code id="stattable.funs_+3A_d">d</code>, <code id="stattable.funs_+3A_y">y</code></td>
<td>
<p>numeric vectors of equal length (<code>d</code> for Deaths,
<code>y</code> for person-Years)</p>
</td></tr>
<tr><td><code id="stattable.funs_+3A_scale">scale</code></td>
<td>
<p>a scalar giving a value by which the ratio should be
multiplied</p>
</td></tr>
<tr><td><code id="stattable.funs_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should
be stripped before computation proceeds.</p>
</td></tr>
<tr><td><code id="stattable.funs_+3A_...">...</code></td>
<td>
<p>a list of variables taken from the <code>index</code> argument
to <code><a href="#topic+stat.table">stat.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>When used as a <code>contents</code> argument to <code>stat.table</code>, these
functions create the following tables:
</p>
<table>
<tr><td><code>count</code></td>
<td>
<p>If given without argument (<code>count()</code>) it
returns a contingency table of counts. If given an <code>id</code>
argument it returns a table of the number of different values of
<code>id</code> in each cell, i.e. how many persons contribute in each
cell.</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>returns a table of values
<code>scale * sum(d)/sum(y)</code></p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>returns a table of percentages of the
classifying variables. Variables that are in the <code>index</code>
argument to <code>stat.table</code> but not in the call to
<code>percent</code> are used to define strata, within which the
percentages add up to 100.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat.table">stat.table</a></code></p>

<hr>
<h2 id='steno2'>
Clinical trial: Steno2 baseline and follow-up. 
</h2><span id='topic+steno2'></span><span id='topic+st2clin'></span><span id='topic+st2alb'></span>

<h3>Description</h3>

<p>Steno-2 was a clinical trial conducted at Steno Diabetes Center
1993-2001. The intervention was intensified treatment versus
conventional treatment of diabetes patients with micro-albuminuria. The
datsets here concern the extended follow-up of the trial population till
2015. Three files are provided: <code>steno2</code> with one record per
person, <code>st2clin</code> with one record per clinical visit and
<code>st2alb</code> with one record per transition between states of
albuminuria.
</p>
<p>These dataset are entirely simulated, but designed to give
approximately the same results as the original.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("steno2")
       data("st2clin")
       data("st2alb")
</code></pre>


<h3>Format</h3>

<p><code>steno2</code> is a data frame with 160 observations on the following 14
variables: 
</p>

<dl>
<dt><code>id</code></dt><dd><p>person id, numeric</p>
</dd>
<dt><code>allo</code></dt><dd><p>Original trial allocation, a factor with levels
<code>Int</code> <code>Conv</code></p>
</dd> 
<dt><code>sex</code></dt><dd><p>Sex, a factor with levels <code>F</code> <code>M</code></p>
</dd>
<dt><code>baseCVD</code></dt><dd><p>0/1 indicator of preexisting CVD at baseline</p>
</dd>
<dt><code>deathCVD</code></dt><dd><p>0/1 indicator whether cause of death was CVD</p>
</dd>
<dt><code>doBth</code></dt><dd><p>Date of birth, a Date</p>
</dd>
<dt><code>doDM</code></dt><dd><p>Date of diabetes diagnosis, a Date</p>
</dd>
<dt><code>doBase</code></dt><dd><p>Date of entry to study, a Date</p>
</dd>
<dt><code>doCVD1</code></dt><dd><p>Date of 1st CVD event, a Date</p>
</dd>
<dt><code>doCVD2</code></dt><dd><p>Date of 2nd CVD event, a Date</p>
</dd>
<dt><code>doCVD3</code></dt><dd><p>Date of 3rd CVD event, a Date</p>
</dd>
<dt><code>doESRD</code></dt><dd><p>Date of end stage renal disease, a Date</p>
</dd>
<dt><code>doEnd</code></dt><dd><p>Date of exit from follow-up, a Date</p>
</dd>
<dt><code>doDth</code></dt><dd><p>Date of death, a Date</p>
</dd>
</dl>

<p><code>st2clin</code> is data frame with 750 observations on clinical
measurements at different clinical visits:
</p>

<dl>
<dt><code>id</code></dt><dd><p>person id, numeric</p>
</dd>
<dt><code>doV</code></dt><dd><p>Date of clinical visit, a Date</p>
</dd>
<dt><code>a1c</code></dt><dd><p>Glycosylated hemoglobin, mmol/mol</p>
</dd>
<dt><code>chol</code></dt><dd><p>Total cholesterol, mg/mol</p>
</dd>
<dt><code>crea</code></dt><dd><p>Creatinine, mg/mol</p>
</dd>
</dl>

<p><code>st2alb</code> is data frame with 307 observations of changes in
complication (albuminuria) state
</p>

<dl>
<dt><code>id</code></dt><dd><p>person id, numeric</p>
</dd>
<dt><code>doTr</code></dt><dd><p>Date of transition, a Date</p>
</dd>
<dt><code>state</code></dt><dd><p>State of albuminuria, factor with levels
<code>Norm</code>, <code>Mic</code>, <code>Mac</code>. All persons
begin in the state <code>Mic</code>ro-albuminuria.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The data are not the original; all values of measurements and dates
have been randomly perturbed, to prevent identifiability of
individuals. Analysis of these data will give only (very)
approximately the same results as in the published article, and only
some of the aspects of data are included.
</p>


<h3>References</h3>

<p>P. Gaede, J. Oellgaard, B. Carstensen, P. Rossing, H. Lund-Andersen,
H. H. Parving &amp; O. Pedersen: Years of life gained by multifactorial
intervention in patients with type 2 diabetes mellitus and
microalbuminuria: 21 years follow-up on the Steno-2
randomised trial. Diabetologia (2016), 59, pp 2298-2307
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(steno2)
data(st2alb)
L2 &lt;- Lexis( entry = list(per = doBase,
                          age = doBase - doBth),
              exit = list(per = doEnd),
       exit.status = factor(deathCVD + !is.na(doDth),
                            labels=c("Mic","D(oth)","D(CVD)")),
                id = id,
              data = cal.yr(steno2) )
summary(L2)
#
# Cut at intermediate transitions
cut2 &lt;- data.frame(lex.id = st2alb$id,
                      cut = cal.yr(st2alb$do),
                new.state = st2alb$state)
L3 &lt;- rcutLexis(L2, cut2)
summary(L3)
#
# no direct transitions Mic &lt;-&gt; Mac allowed, so put a cut in between:
dd &lt;- subset(L3, (lex.Cst == "Mac" &amp; lex.Xst =="Norm") |
                 (lex.Cst =="Norm" &amp; lex.Xst == "Mac"))
# artificial visits to the middle state Mic: 
cut3 &lt;- data.frame( lex.id = dd$lex.id,
                       cut = dd$per + dd$lex.dur/2,
                 new.state = "Mic")
L4 &lt;- rcutLexis(L3, cut3)
summary(L4)
#
# Show all transitions
boxes(L4, boxpos = list(x = c(15,15,15,85,85),
                        y = c(50,15,85,25,75)),
          show.BE = TRUE, scale.R = 1000,
          cex=0.8, pos.arr=0.7, font=1, font.arr=1)
</code></pre>

<hr>
<h2 id='subset.Lexis'>Subsetting Lexis (and stacked.Lexis) objects</h2><span id='topic+subset.Lexis'></span><span id='topic++5B.Lexis'></span><span id='topic+subset.stacked.Lexis'></span>

<h3>Description</h3>

<p>Return subsets of Lexis objects which meet conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
subset(x, ...)
## S3 method for class 'Lexis'
x[...]
## S3 method for class 'stacked.Lexis'
subset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.Lexis_+3A_x">x</code></td>
<td>
<p>an object of class <code>Lexis</code></p>
</td></tr>
<tr><td><code id="subset.Lexis_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to
<code>subset.data.frame</code>. This will normally be some logical
expression selecting a subset of the rows. For details see
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subset method for <code>Lexis</code> objects works exactly as the method
for data frames. So does the &quot;[&quot; method. The special methods are needed in
order to propagate the Lexis-specific attributes.
</p>
<p>The method for <code>stacked.Lexis</code> objects also shrinks the set of
levels for <code>lex.Cst</code> and <code>lex.Xst</code> to those actually
occurring in the resulting data frame.
</p>


<h3>Value</h3>

<p>A <code>Lexis</code> object with selected rows and columns.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+merge.Lexis">merge.Lexis</a></code>,
<code><a href="#topic+bootLexis">bootLexis</a></code></p>

<hr>
<h2 id='summary.Lexis'>
Summarize transitions and risk time from a Lexis object
</h2><span id='topic+summary.Lexis'></span><span id='topic+print.summary.Lexis'></span>

<h3>Description</h3>

<p>A two-way table of records and transitions classified by states
(<code>lex.Cst</code> and <code>lex.Xst</code>), as well the risk time in each state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'Lexis'
summary(object, simplify = TRUE, scale = 1, by = NULL,
                          Rates = FALSE, timeScales = FALSE, ...)
  ## S3 method for class 'summary.Lexis'
print(x, ..., digits = 2)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Lexis_+3A_object">object</code></td>
<td>
<p>A Lexis object.</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_simplify">simplify</code></td>
<td>
<p>Should rows with 0 follow-up time be dropped?</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_scale">scale</code></td>
<td>
<p>Scaling factor for the rates. The calculated rates are
multiplied by this number.</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_by">by</code></td>
<td>
<p>Character vector of name(s) of variable(s) in
<code>object</code>. Used to give a separate summaries for subsets of
<code>object</code>. If longer than than 1, the interaction between that
variables is used to stratify the summary. It is also possible to
supply a vector of length <code>nrow(object)</code>, and the distinct
values of this will be used to stratify the summary.</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_rates">Rates</code></td>
<td>
<p>Should a component with transition rates be returned (and
printed) too?</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_timescales">timeScales</code></td>
<td>
<p>Should the names of the timescales and the indication
of since which entry also be given?</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_x">x</code></td>
<td>
<p>A <code>Lexis</code> or <code>summary.Lexis</code> object.</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_digits">digits</code></td>
<td>
<p>Number of digits after the decimal separator used when
printing the summary.</p>
</td></tr>
<tr><td><code id="summary.Lexis_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.Lexis</code>, a list with two components,
<code>Transitions</code> and <code>Rates</code>, each one a matrix with rows
classified by states where persons spent time, and columns classified
by states to which persons transit. The <code>Transitions</code> contains
number of transitions and has 4 extra columns with number of records,
total number of events, total risk time and number of person
contributing attached.  The <code>Rates</code> contains the transitions
rates.
</p>
<p>If the argument <code>Rates</code> is FALSE (the default), then only the
first component of the list is returned.
</p>


<h3>Author(s)</h3>

<p>Bendix Carstensen, <a href="http://bendixcarstensen.com">http://bendixcarstensen.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( nickel )
# Lung cancer deaths and other deaths are coded 1 and 2
nic &lt;- Lexis( data = nickel,
             entry = list(age = agein),
              exit = list(age = ageout,cal = ageout+dob,tfh = ageout-age1st),
       exit.status = factor( (icd &gt; 0) + (icd %in% c(162,163)),
                           labels = c("Alive","Other","Lung") ) )
str( nic )
head( nic )
summary( nic )
# More detailed summary, by exposure level
summary( nic, by = nic$exposure&gt;5, Rates = TRUE, scale = 100 )
</code></pre>

<hr>
<h2 id='Termplot'>
A wrapper for <code>termplot</code> that optionally (but by default)
exponentiates terms, and plot them on a common log-scale. Also scales
x-axes to the same physical scale.
</h2><span id='topic+Termplot'></span>

<h3>Description</h3>

<p>The function uses <code><a href="stats.html#topic+termplot">termplot</a></code> to extract terms from a model
with, say, spline, terms, including the standard errors, computes
confidence intervals and transform these to the rate / rate-ratio
scale. Thus the default use is for models on the log-scale such as
Poisson-regression models. The function produces a plot with panels
side-by-side, one panel per term, and returns the 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Termplot( obj,
           plot = TRUE,
           xlab = NULL,
           ylab = NULL,
            xeq = TRUE,
           yshr = 1,
          alpha = 0.05,
          terms = NULL,
         max.pt = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Termplot_+3A_obj">obj</code></td>
<td>
<p>An object with a <code>terms</code>-method &mdash; for details the
the documentation for <code><a href="stats.html#topic+termplot">termplot</a></code>. </p>
</td></tr>
<tr><td><code id="Termplot_+3A_plot">plot</code></td>
<td>
<p>Should a plot be produced?</p>
</td></tr>
<tr><td><code id="Termplot_+3A_xlab">xlab</code></td>
<td>
<p>Labels for the <code>x</code>-axes. Defaults to the names of the terms.</p>
</td></tr>
<tr><td><code id="Termplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the <code>x</code>-axes. Defaults to blank.</p>
</td></tr>
<tr><td><code id="Termplot_+3A_xeq">xeq</code></td>
<td>
<p>Should the units all all plots have the same physical scale
for the <code>x</code>-axes).</p>
</td></tr>
<tr><td><code id="Termplot_+3A_yshr">yshr</code></td>
<td>
<p>Shrinking of <code>y</code>-axis. By default, the <code>y</code>-axes
have an extent that accommodates the entire range of confidence
intervals. This is a shrinking parameter for the <code>y</code>-axes,
setting it to less than 1 will lose a bit of the confidence limits
on some of the panels.</p>
</td></tr>
<tr><td><code id="Termplot_+3A_alpha">alpha</code></td>
<td>
<p>1 minus the confidence level for computing confidence
intervals</p>
</td></tr>
<tr><td><code id="Termplot_+3A_terms">terms</code></td>
<td>
<p>Which terms should be reported. Passed on to
<code><a href="stats.html#topic+termplot">termplot</a></code> and eventually <code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code id="Termplot_+3A_max.pt">max.pt</code></td>
<td>
<p>The maximal number of points in which to report the
terms. If <code>NULL</code> all unique points from the analysis dataset
are reported for each term (this is a feature of <code><a href="stats.html#topic+termplot">termplot</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one component per term in the model object <code>obj</code>,
each component is a 4-column matrix with $x$ as the first column, and
3 columns with estimae and lower and upper confidence limit.
</p>


<h3>Author(s)</h3>

<p>Bendix Cartensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ns">Ns</a></code>, <code>termplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the diabetes data and set up as Lexis object
data(DMlate)
DMlate &lt;- DMlate[sample(1:nrow(DMlate),500),]
dml &lt;- Lexis( entry = list(Per=dodm, Age=dodm-dobth, DMdur=0 ),
               exit = list(Per=dox),
        exit.status = factor(!is.na(dodth),labels=c("DM","Dead")),
               data = DMlate )

# Split in 1-year age intervals
dms &lt;- splitLexis( dml, time.scale="Age", breaks=0:100 )

# Model with 6 knots for both age and period
n.kn &lt;- 6
# Model age-specific rates with period referenced to 2004
( a.kn &lt;- with( subset(dms,lex.Xst=="Dead"),
                quantile( Age+lex.dur, probs=(1:n.kn-0.5)/n.kn ) ) )
( p.kn &lt;- with( subset(dms,lex.Xst=="Dead"),
                quantile( Per+lex.dur, probs=(1:n.kn-0.5)/n.kn ) ) )
m2 &lt;- glm( lex.Xst=="Dead" ~ -1 +
                             Ns( Age, kn=a.kn, intercept=TRUE ) +
                             Ns( Per, kn=p.kn, ref=2004 ),
           offset = log( lex.dur ), family=poisson, data=dms )

# Finally we can plot the two effects:
Termplot( m2, yshr=0.9 )
</code></pre>

<hr>
<h2 id='testisDK'>Testis cancer incidence in Denmark, 1943&ndash;1996
</h2><span id='topic+testisDK'></span>

<h3>Description</h3>

<p>Number of testiscancer cases and male person-years in the
Danish population 1943&ndash;1996</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testisDK)</code></pre>


<h3>Format</h3>

<p>A data frame with 4860 observations on the following 4 variables.
</p>

<dl>
<dt><code>A</code></dt><dd><p>Age class, 0,1,2,...,89</p>
</dd>
<dt><code>P</code></dt><dd><p>Year, 1943,...,1996</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of testis cancer cases</p>
</dd>
<dt><code>Y</code></dt><dd><p>Person years</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Danish Cancer Registry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testisDK)
head(testisDK)
</code></pre>

<hr>
<h2 id='thoro'>Thorotrast Study</h2><span id='topic+thoro'></span>

<h3>Description</h3>

<p>The <code>thoro</code> data frame has 2470 rows and 14 columns.
Each row represents one patient that have had cerebral angiography (X-ray of
the brain) with an injected contrast medium, either Thorotrast or
another one (the controls).
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identification of person.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex, 1: male / 2: female.</p>
</dd>
<dt><code>birthdat</code></dt><dd><p>Date of birth, <code>Date</code> variable.</p>
</dd>
<dt><code>contrast</code></dt><dd><p>Group, 1: Thorotrast / 2: Control.</p>
</dd>
<dt><code>injecdat</code></dt><dd><p>Date of contrast injection, <code>Date</code> variable.</p>
</dd>
<dt><code>volume</code></dt><dd><p>Injected volume of Thorotrast in ml. Control
patients have a 0 in this variable.</p>
</dd>
<dt><code>exitdat</code></dt><dd><p>Date of exit from the study, <code>Date</code> variable.</p>
</dd>
<dt><code>exitstat</code></dt><dd><p>Status at exit, 1: dead / 2: alive,
censored at closing of study, 20 February 1992 / 3:
censored alive at some earlier date.</p>
</dd>
<dt><code>cause</code></dt><dd><p>Cause of death. See causes in the helpfile for
<code><a href="#topic+gmortDK">gmortDK</a></code>.</p>
</dd>
<dt><code>liverdat</code></dt><dd><p>Date of liver cancer diagnosis, <code>Date</code> variable.</p>
</dd>
<dt><code>liver</code></dt><dd><p>Indicator of liver cancer diagnosis. Not all livercancers
are histologically verified, hence
<code>liver &gt;= hepcc + chola + hmang</code></p>
</dd>
<dt><code>hepcc</code></dt><dd><p>Hepatocellular carcinoma at <code>liverdat</code>.</p>
</dd>
<dt><code>chola</code></dt><dd><p>Cholangiocellular carcinoma at <code>liverdat</code>.</p>
</dd>
<dt><code>hmang</code></dt><dd><p>Haemangisarcoma carcinoma at <code>liverdat</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>M Andersson, M Vyberg, J Visfeldt, B Carstensen &amp; HH Storm:
Primary liver tumours among Danish patients exposed to Thorotrast.
Radiation Research, 137, pp. 262&ndash;273, 1994.
</p>
<p>M Andersson, B Carstensen HH Storm: Mortality and cancer
incidence after cerebral angiography. Radiation Research, 142,
pp. 305&ndash;320, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mortDK">mortDK</a></code>, <code><a href="#topic+gmortDK">gmortDK</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(thoro)
str(thoro)
</code></pre>

<hr>
<h2 id='timeBand'>Extract time band data from a split Lexis object</h2><span id='topic+timeBand'></span><span id='topic+breaks'></span>

<h3>Description</h3>

<p>The break points of a <code>Lexis</code> object (created by a call to
<code>splitLexis</code>) divide the follow-up intervals into time bands
along a given time scale. The <code>breaks</code> function returns
the break points, for a given time scale, and the <code>timeBand</code>
classifies each row (=follow-up interval) into one of the time bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeBand(lex, time.scale, type="integer")
breaks(lex, time.scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeBand_+3A_lex">lex</code></td>
<td>
<p>an object of class <code>Lexis</code></p>
</td></tr>
<tr><td><code id="timeBand_+3A_time.scale">time.scale</code></td>
<td>
<p>a character or integer vector of length 1
identifying the time scale of interest</p>
</td></tr>
<tr><td><code id="timeBand_+3A_type">type</code></td>
<td>
<p>a string that determines how the time bands are labelled.
See Details below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time bands may be labelled in various ways according to the
<code>type</code> argument. The permitted values of the <code>type</code>
argument, and the corresponding return values are:
</p>

<dl>
<dt>&quot;integer&quot;</dt><dd><p>a numeric vector with integer codes starting from 0.</p>
</dd>
<dt>&quot;factor&quot;</dt><dd><p>a factor (unordered) with labels &quot;(left,right]&quot;</p>
</dd>
<dt>&quot;left&quot;</dt><dd><p>the left-hand limit of the time band</p>
</dd>
<dt>&quot;middle&quot;</dt><dd><p>the midpoint of the time band</p>
</dd>
<dt>&quot;right&quot;</dt><dd><p>the right-hand limit of the time band</p>
</dd>
</dl>



<h3>Value</h3>

<p>The <code>breaks</code> function returns a vector of break points
for the <code>Lexis</code> object, or NULL if no break points have been
defined by a call to <code>splitLexis</code>.  The <code>timeBand</code>
function returns a numeric vector or factor, depending on the value
of the <code>type</code> argument.
</p>


<h3>Note</h3>

<p>A newly created <code>Lexis</code> object has no break points defined.
In this case, <code>breaks</code> will return NULL, and
<code>timeBand</code> will a vector of zeros.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diet)
diet &lt;- cal.yr(diet)
diet.lex &lt;- Lexis(entry=list(period=doe),
                   exit=list(period=dox, age=dox-dob),
            exit.status=chd,
                   data=diet)
diet.split &lt;- splitLexis(diet.lex, breaks=seq(40,70,5), "age" )
age.left &lt;- timeBand(diet.split, "age", "left")
table(age.left)
age.fact &lt;- timeBand(diet.split, "age", "factor")
table(age.fact)
age.mid &lt;- timeBand(diet.split, "age", "mid")
table(age.mid)
</code></pre>

<hr>
<h2 id='timeScales'>The time scales of a Lexis object</h2><span id='topic+timeScales'></span><span id='topic+timeSince'></span><span id='topic+tsNA20'></span>

<h3>Description</h3>

<p>Functions to get the names and type of the time scales of a
<code>Lexis</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeScales(x)
timeSince(x)
tsNA20( x, all.scales=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeScales_+3A_x">x</code></td>
<td>
<p>an object of class <code>Lexis</code>.</p>
</td></tr>
<tr><td><code id="timeScales_+3A_all.scales">all.scales</code></td>
<td>
<p>Should NAs in all timescales be replaced by 0? If
<code>FALSE</code> (the default) only timescales defined as time since
entry to a state get <code>NA</code>s replaced by 0s</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>timeScales</code> returns a character vector containing the names of
the variables in <code>x</code> that represent the time scales. Extracted
from the <code>time.scales</code> attribute of the object.
</p>
<p><code>timeSince</code> returns a named character vector, the names being the
names of the timescales and the content being the names of the states
to which the corresponding timescale is defined as time since
entry. For those time scales that are not defined as such an empty
string is used. Hence, if none of the timescales are defined as time
since entry to a state <code>timeSince</code> will return a vector of empty
strings.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer, Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>, <code><a href="#topic+splitLexis">splitLexis</a></code></p>

<hr>
<h2 id='transform.Lexis'>Transform a Lexis (or stacked.Lexis) object</h2><span id='topic+transform.Lexis'></span><span id='topic+Relevel.Lexis'></span><span id='topic+transform.stacked.Lexis'></span><span id='topic+factorize'></span><span id='topic+factorize.Lexis'></span><span id='topic+levels.Lexis'></span><span id='topic+order.Lexis'></span><span id='topic+orderLexis'></span><span id='topic+sortLexis'></span>

<h3>Description</h3>

<p>Modify a Lexis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lexis'
factorize(x, ..., verbose = FALSE)
## S3 method for class 'Lexis'
Relevel(x, ref, ...)
## S3 method for class 'Lexis'
levels(x)
## S3 method for class 'Lexis'
transform(`_data`, ...)
## S3 method for class 'stacked.Lexis'
transform(`_data`, ...)
 order.Lexis(x)
  orderLexis(x)
   sortLexis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.Lexis_+3A__data">_data</code></td>
<td>
<p>an object of class <code>Lexis</code>.</p>
</td></tr>
<tr><td><code id="transform.Lexis_+3A_x">x</code></td>
<td>
<p>an object of class <code>Lexis</code>.</p>
</td></tr>
<tr><td><code id="transform.Lexis_+3A_ref">ref</code></td>
<td>
<p>New names (or order) of the factor levels (states) for
<code>lex.Cst</code> 
and <code>lex.Xst</code>. Can be a list, in which case some levels are
collapsed, see the documentation for <code><a href="#topic+Relevel">Relevel</a></code>. No
sanity check for the latter type of operation is undertaken.</p>
</td></tr>
<tr><td><code id="transform.Lexis_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="base.html#topic+transform.data.frame">transform.data.frame</a></code>, <code><a href="#topic+Relevel.factor">Relevel.factor</a></code>.</p>
</td></tr>
<tr><td><code id="transform.Lexis_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should a list of new levels be printed?</p>
</td></tr>

</table>


<h3>Details</h3>

<p>The transform method for <code>Lexis</code> objects works exactly as the
method for data frames, but keeps the <code>Lexis</code> attributes.
</p>
<p><code>factorize</code> transforms the variables
<code>lex.Cst</code> and <code>lex.Xst</code> to factors with identical sets of
levels.
</p>
<p><code>Relevel</code> does the same as <code><a href="#topic+Relevel.factor">Relevel.factor</a></code>, but for
both the factors <code>lex.Cst</code> and <code>lex.Xst</code> in <code>x</code>.
<code>lex.Cst</code> and <code>lex.Xst</code> must be factors with the same
levels. They can be made so by <code>factorize</code>.
</p>
<p>If <code>ref</code> is an integer or character vector, the levels of
<code>lex.Cst</code> and <code>lex.Xst</code> are permuted to match the order of
<code>ref</code>. 
</p>
<p>If <code>ref</code> is <code>NULL</code>, as when for example the argument is
not passed to the function, the returned object have levels of
<code>lex.Cst</code>, <code>lex.Xst</code> (and for <code>stacked.Lexis</code> objects
<code>lex.Tr</code>) shaved down to the actually occurring values; that is,
empty levels are discarded.
</p>
<p><code>order.Lexis</code> returns the order of the rows in a Lexis object to sort
it by ()<code>lex.id</code>,<code>ts</code>), where <code>ts</code> is a timescale in
the Lexis object with no <code>NA</code>s. <code>orderLexis</code> is just a synonym.
</p>
<p><code>sortLexis</code> returns the Lexis object sorted by
(<code>lex.id</code>, <code>ts</code>) where <code>ts</code> is one of the
<code><a href="#topic+timeScales">timeScales</a></code> with no <code>NA</code>s.   
</p>


<h3>Value</h3>

<p>A transformed <code>Lexis</code> object.
</p>
<p>The function <code>levels</code> returns the names of the states (levels of
the factors <code>lex.Cst</code> and <code>lex.Xst</code>.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer, Bendix Carstensen</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lexis">Lexis</a></code>,
<code><a href="#topic+merge.Lexis">merge.Lexis</a></code>,
<code><a href="#topic+subset.Lexis">subset.Lexis</a></code>,
<code><a href="#topic+subset.stacked.Lexis">subset.stacked.Lexis</a></code>,
<code><a href="#topic+Relevel">Relevel</a></code>,
<code><a href="#topic+transient">transient</a></code>,
<code><a href="#topic+absorbing">absorbing</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data( nickel )
nic &lt;- Lexis( data = nickel,
                id = id,
             entry = list(age = agein),
              exit = list(age = ageout,
                          cal = ageout+dob,
                          tfh = ageout-age1st),
# Lung cancer deaths end as 2 and other deaths as 1
       exit.status = factor((icd &gt; 0) + (icd %in% c(162,163)),
                            labels = c("Alive","Dead","Lung") ) )
str( nic )
levels( nic )
nit &lt;- transform( nic, cumex = exposure * (agein - age1st) )
str( nit )

# It is still a Lexis object!
summary(nic)

# change order of levels
nix &lt;- Relevel(nic, c("Alive", "Lung", "Dead"))
summary(nix)

# change names of levels 
niw &lt;- Relevel(nix, list("Alive" = 1, "Pulm" = "Lung", "Mort" = "Dead"))
summary(niw)
boxes(niw, boxpos = TRUE)

# combine levels
niz &lt;- Relevel(niw, list("Alive", c("Pulm", "Mort")), coll=" \n&amp; ")
summary(niz)
par( new = TRUE )
boxes(niz, boxpos = TRUE)

#stack Lexis object
siw &lt;- stack(niw)
str(siw)
</code></pre>

<hr>
<h2 id='twoby2'>Analysis of a two by two table</h2><span id='topic+twoby2'></span>

<h3>Description</h3>

<p>Computes the usual measures of association in a 2 by 2 table with
confidence intervals. Also produces asymtotic and exact tests. Assumes
that comparison of probability of the first column level between
levels of the row variable is of interest. Output requires that the
input matrix has meaningful row and column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoby2(exposure, outcome,
       alpha = 0.05, print = TRUE, dec = 4,
       conf.level = 1-alpha, F.lim = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoby2_+3A_exposure">exposure</code></td>
<td>
<p>If a table the analysis is based on the first two rows
and first two columns of this. If a variable, this variable is
tabulated against</p>
</td></tr> 
<tr><td><code id="twoby2_+3A_outcome">outcome</code></td>
<td>
<p>as the second variable</p>
</td></tr>
<tr><td><code id="twoby2_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="twoby2_+3A_print">print</code></td>
<td>
<p>Should the results be printed?</p>
</td></tr>
<tr><td><code id="twoby2_+3A_dec">dec</code></td>
<td>
<p>Number of decimals in the printout.</p>
</td></tr>
<tr><td><code id="twoby2_+3A_conf.level">conf.level</code></td>
<td>
<p>1-<code>alpha</code></p>
</td></tr>
<tr><td><code id="twoby2_+3A_f.lim">F.lim</code></td>
<td>
<p>If the table total exceeds <code>F.lim</code>, Fisher's exact
test is not computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>table</code></td>
<td>
<p>The analysed 2 x 2 table augmented with probabilities and
confidence intervals. The confidence intervals for the probabilities
are computed using the normal approximation to the
log-odds. Confidence intervals for the difference of proportions are
computed using method 10 from Newcombe, Stat.Med. 1998, 17, pp.873
ff.</p>
</td></tr>
<tr><td><code>measures</code></td>
<td>
<p>A table of Odds-ratios and relative risk with
confidence intervals.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Exact p-value for the null hypothesis of OR=1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mark Myatt. Modified by Bendix Carstensen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Treat &lt;- sample(c("A","B"), 50, rep=TRUE )
Resp &lt;- c("Yes","No")[1+rbinom(50,1,0.3+0.2*(Treat=="A"))]
twoby2( Treat, Resp )                 
twoby2( table( Treat, Resp )[,2:1] ) # Comparison the other way round
</code></pre>

<hr>
<h2 id='Y.dk'>Population risk time in Denmark</h2><span id='topic+Y.dk'></span>

<h3>Description</h3>

<p>Risk time (person-years) in the Danish population, classified by sex,
age, period and date of birth in 1-year classes. This corresponds to
triangles in a Lexis diagram. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Y.dk)</code></pre>


<h3>Format</h3>

<p>A data frame with 13860 observations on the following 6 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Sex. 1:males, 2:females</p>
</dd>
<dt><code>A</code></dt><dd><p>One-year age class</p>
</dd>
<dt><code>P</code></dt><dd><p>Period</p>
</dd>
<dt><code>C</code></dt><dd><p>Birth cohort</p>
</dd>
<dt><code>Y</code></dt><dd><p>Person-years</p>
</dd>
<dt><code>upper</code></dt><dd><p>Indicator of upper triangle in the Lexis diagram</p>
</dd>
</dl>



<h3>Details</h3>

<p>The risk time is computed from the population size figures in
<code><a href="#topic+N.dk">N.dk</a></code>, using the formulae devised in:
B. Carstensen: Age-period-cohort models for the Lexis diagram.
Statistics in Medicine, 10; 26(15):3018-45, 2007.
</p>


<h3>Source</h3>

<p><a href="http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF">http://www.statistikbanken.dk/statbank5a/SelectTable/omrade0.asp?SubjectCode=02&amp;PLanguage=1&amp;ShowNews=OFF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Y.dk)
str(Y.dk)
# Compute mean age, period for the triangles
attach( Y.dk )
age &lt;- A + (1+upper)/3
per &lt;- P + (2-upper)/3
# Plot a Lexis diagram
library( Epi )
Lexis.diagram( age=c(0,10), date=c(1990,2000), coh.grid=TRUE, int=1 )
box()
# Print the person-years for males there
text( per[sex==1], age[sex==1],
      formatC( Y[sex==1]/1000, format="f", digits=1 ) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
