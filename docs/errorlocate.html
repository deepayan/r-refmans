<!DOCTYPE html><html lang="en"><head><title>Help for package errorlocate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {errorlocate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#errorlocate-package'><p>Find errors in data given a set of validation rules.</p></a></li>
<li><a href='#add_noise'><p>Add (a small amount of) noise</p></a></li>
<li><a href='#cat_as_mip_rules'><p>get categorical rules as mip_rules</p></a></li>
<li><a href='#cat_coefficients'><p>Get coefficient matrix from categorical rules</p></a></li>
<li><a href='#ErrorLocalizer-class'><p>Base class for class locate errors based on rules and data</p></a></li>
<li><a href='#errorlocation-class'><p>Error location object</p></a></li>
<li><a href='#errors_removed'><p>Get location of removed errors from a 'cleaned' data set</p></a></li>
<li><a href='#expand_weights'><p>Create a weight matrix</p></a></li>
<li><a href='#expect_values'><p>expect values</p></a></li>
<li><a href='#FHLocalizer-class'><p>Feligi-Holt Errorlocalizer</p></a></li>
<li><a href='#inspect_mip'><p>inspect the mip problem formulation</p></a></li>
<li><a href='#is_categorical'><p>Check if rules are categorical</p></a></li>
<li><a href='#is_conditional'><p>Check if rules are conditional rules</p></a></li>
<li><a href='#is_linear'><p>Check which rules are linear rules.</p></a></li>
<li><a href='#locate_errors'><p>Find errors in data</p></a></li>
<li><a href='#mip_rule'><p>Create a rule used by mip</p></a></li>
<li><a href='#MipRules-class'><p>Create a mip object from a validator object</p></a></li>
<li><a href='#replace_errors'><p>Replace erroneous fields with NA or a suggested value</p></a></li>
<li><a href='#translate_mip_lp'><p>translate linear rules into an lp problem</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Locate Errors with Validation Rules</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Errors in data can be located and removed using validation rules from package 
   'validate'. See also Van der Loo and De Jonge (2018) &lt;<a href="https://doi.org/10.1002%2F9781118897126">doi:10.1002/9781118897126</a>&gt;,
   chapter 7.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/data-cleaning/errorlocate">https://github.com/data-cleaning/errorlocate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/data-cleaning/errorlocate/issues">https://github.com/data-cleaning/errorlocate/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>validate</td>
</tr>
<tr>
<td>Imports:</td>
<td>lpSolveAPI, methods, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MipRules.R' 'addnoise.R' 'categorical.R' 'conditional.R'
'dnf.R' 'errorlocalizer.R' 'errorlocate-package.r'
'errorlocation.R' 'expand_weights.R' 'expr_manip.R'
'inspect_mip.R' 'linear.R' 'locate-errors.R' 'log_extract.R'
'mip_lpsolve.R' 'mip_rule.R' 'replace-errors.R' 'soft-rule.R'
'utils.R' 'values.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-30 20:16:40 UTC; edwindj</td>
</tr>
<tr>
<td>Author:</td>
<td>Edwin de Jonge <a href="https://orcid.org/0000-0002-6580-4718"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mark van der Loo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edwin de Jonge &lt;edwindjonge@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-30 20:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='errorlocate-package'>Find errors in data given a set of validation rules.</h2><span id='topic+errorlocate'></span><span id='topic+errorlocate-package'></span>

<h3>Description</h3>

<p>Find errors in data given a set of validation rules.
The <code>errorlocate</code> helps to identify obvious errors in raw datasets.
</p>


<h3>Details</h3>

<p>It works in tandem with the package <code><a href="validate.html#topic+validate">validate()</a></code>.
With <code>validate</code> you formulate data validation rules to which the data must comply.
For example:
</p>
<p>&quot;age cannot be negative&quot;: <code>age &gt;= 0</code>
</p>
<p>While <code>validate</code> can identify if a record is valid or not, it does not identify
which of the variables are responsible for the invalidation. This may seem a simple task,
but is actually quite tricky:  a set of validation rules form a web
of dependent variables: changing the value of an invalid record to repair for rule 1, may invalidate
the record for rule 2.
</p>
<p>Errorlocate provides a small framework for record based error detection and implements the Felligi Holt
algorithm. This algorithm assumes there is no other information available then the values of a record
and a set of validation rules. The algorithm minimizes the (weighted) number of values that need
to be adjusted to remove the invalidation.
</p>
<p>The <code>errorlocate</code> package translates the validation and error localization problem into
a mixed integer problem and uses a mip solver to find a solution.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Edwin de Jonge <a href="mailto:edwindjonge@gmail.com">edwindjonge@gmail.com</a> (<a href="https://orcid.org/0000-0002-6580-4718">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mark van der Loo <a href="mailto:mark.vanderloo@gmail.com">mark.vanderloo@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>T. De Waal (2003) Processing of Erroneous and Unsafe Data. PhD thesis, University of Rotterdam.
</p>
<p>Van der Loo, M., de Jonge, E, Data Cleaning With Applications in R
</p>
<p>E. De Jonge and Van der Loo, M. (2012) Error localization as a mixed-integer program in
editrules.
</p>
<p>lp_solve and Kjell Konis. (2011). lpSolveAPI: R Interface for
lp_solve version 5.5.2.0. R package version 5.5.2.0-5.
http://CRAN.R-project.org/package=lpSolveAPI
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/data-cleaning/errorlocate">https://github.com/data-cleaning/errorlocate</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/data-cleaning/errorlocate/issues">https://github.com/data-cleaning/errorlocate/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_noise'>Add (a small amount of) noise</h2><span id='topic+add_noise'></span>

<h3>Description</h3>

<p>Utility function to add some small positive noise to weights.
This is mainly done to randomly choose between solutions
of equal weight. Without adding noise to weights lp solvers may return
an identical solution over and over while there are multiple solutions of equal weight.
The generated noise is positive to prevent that weights will be zero or negative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise(x, max_delta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_noise_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector or matrix. When <code>x</code> is a matrix, the function
will be applied to each row of the matrix.</p>
</td></tr>
<tr><td><code id="add_noise_+3A_max_delta">max_delta</code></td>
<td>
<p>when supplied noise will be drawn from <code style="white-space: pre;">&#8288;[0,max_delta]&#8288;</code>
otherwise see details</p>
</td></tr>
<tr><td><code id="add_noise_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When no <code>max_delta</code> is supplied, add_noise will use the minimum difference
larger than zero divided by the <code>length(x)</code>.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector/matrix with noise applied.
</p>

<hr>
<h2 id='cat_as_mip_rules'>get categorical rules as mip_rules</h2><span id='topic+cat_as_mip_rules'></span>

<h3>Description</h3>

<p>get categorical rules as mip_rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_as_mip_rules(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_as_mip_rules_+3A_x">x</code></td>
<td>
<p>expressionset object</p>
</td></tr>
<tr><td><code id="cat_as_mip_rules_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of mip_rule
</p>

<hr>
<h2 id='cat_coefficients'>Get coefficient matrix from categorical rules</h2><span id='topic+cat_coefficients'></span>

<h3>Description</h3>

<p>Get coefficient matrix from categorical edits, similar to
linear_coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_coefficients(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_coefficients_+3A_x">x</code></td>
<td>
<p>validator object</p>
</td></tr>
<tr><td><code id="cat_coefficients_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='ErrorLocalizer-class'>Base class for class locate errors based on rules and data</h2><span id='topic+ErrorLocalizer-class'></span>

<h3>Description</h3>

<p>ErrorLocalizer can be used as a base class to implement a new error localization algorithm.
The derived class must implement two methods: <code>initialize</code>, which is called
before any error localization is done and <code>locate</code> which operates upon data. The
extra parameter <code>...</code> can used to supply algorithmic specific parameters.
</p>

<hr>
<h2 id='errorlocation-class'>Error location object</h2><span id='topic+errorlocation-class'></span><span id='topic+create_errorlocation'></span>

<h3>Description</h3>

<p>Errorlocation contains the result of a error detection.
Errors can record based or variable based.
</p>

<ul>
<li><p> A record based error is restricted within one observation.
<code><a href="#topic+errorlocate">errorlocate()</a></code> using the Felligi Holt algorithm assumes errors are record based.
</p>
</li>
<li><p> A variable based error is a flaw in  uni- or multivariate
distribution. To correct this error multiple observations or the aggregated number should be adjusted.
</p>
</li></ul>



<h3>Details</h3>

<p>Current implementation assumes that errors are record based. The error locations can be retrieved
using the method <code><a href="validate.html#topic+values">values()</a></code> and are a matrix of
rows and columns, with the same dimensions are the <code>data.frame</code> that was checked.
For errors that are purely column based, or dataset based, errorlocations will return a matrix with all
rows or cells set to <code>TRUE</code>.
The <code><a href="validate.html#topic+values">values()</a></code> return <code>NA</code> for missing values.
</p>


<h3>Fields</h3>


<ul>
<li> <p><code style="white-space: pre;">&#8288;$errors&#8288;</code>: <code>matrix</code> indicating which values are erronuous (<code>TRUE</code>),
missing (<code>NA</code>) or valid (<code>FALSE</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$weight&#8288;</code>: The total weight per record. A weight of 0 means no errors were detected.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$status&#8288;</code>: The <a href="lpSolveAPI.html#topic+solve.lpExtPtr">status</a> of the mip solver for this record.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$duration&#8288;</code>: The number of seconds for processing each record.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other error finding: 
<code><a href="#topic+errors_removed">errors_removed</a>()</code>,
<code><a href="#topic+expand_weights">expand_weights</a>()</code>,
<code><a href="#topic+locate_errors">locate_errors</a>()</code>,
<code><a href="#topic+replace_errors">replace_errors</a>()</code>
</p>

<hr>
<h2 id='errors_removed'>Get location of removed errors from a 'cleaned' data set</h2><span id='topic+errors_removed'></span>

<h3>Description</h3>

<p><code>errors_removed</code> retrieves the errors detected by <code><a href="#topic+replace_errors">replace_errors()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errors_removed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errors_removed_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> that was checked for errors</p>
</td></tr>
<tr><td><code id="errors_removed_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+errorlocation-class">errorlocation-class()</a></code> object
</p>


<h3>See Also</h3>

<p>Other error finding: 
<code><a href="#topic+errorlocation-class">errorlocation-class</a></code>,
<code><a href="#topic+expand_weights">expand_weights</a>()</code>,
<code><a href="#topic+locate_errors">locate_errors</a>()</code>,
<code><a href="#topic+replace_errors">replace_errors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rules &lt;- validator( profit + cost == turnover
              , cost - 0.6*turnover &gt;= 0
              , cost&gt;= 0
              , turnover &gt;= 0
)
data &lt;- data.frame(profit=755, cost=125, turnover=200)

data_no_error &lt;- replace_errors(data,rules)

# faulty data was replaced with NA
data_no_error

errors_removed(data_no_error)

# a bit more control, you can supply the result of locate_errors
# to replace_errors, which is a good thing, otherwise replace_errors will call
# locate_errors internally.
error_locations &lt;- locate_errors(data, rules)
replace_errors(data, error_locations)
</code></pre>

<hr>
<h2 id='expand_weights'>Create a weight matrix</h2><span id='topic+expand_weights'></span>

<h3>Description</h3>

<p>Expands a weight specification into a weight matrix to be used
by <code>locate_errors</code> and <code>replace_errors</code>. Weights allow for &quot;guiding&quot; the
errorlocalization process, so that less reliable values/variables with less
weight are selected first. See details on the specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_weights(dat, weight = NULL, as.data.frame = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_weights_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> the data to be checked</p>
</td></tr>
<tr><td><code id="expand_weights_+3A_weight">weight</code></td>
<td>
<p>weight specification, see details.</p>
</td></tr>
<tr><td><code id="expand_weights_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>if <code>TRUE</code> a <code>data.frame</code> will be returned.</p>
</td></tr>
<tr><td><code id="expand_weights_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If weight fine tuning is needed,
a possible scenario is to generate a weight <code>data.frame</code> using <code>expand_weights</code> and
adjust it before executing <code><a href="#topic+locate_errors">locate_errors()</a></code> or <code><a href="#topic+replace_errors">replace_errors()</a></code>.
The following specifications for <code>weight</code> are supported:
</p>

<ul>
<li> <p><code>NULL</code>: generates a weight matrix with <code>1</code>'s
</p>
</li>
<li><p> a named <code>numeric</code>, unmentioned columns will have weight 1
</p>
</li>
<li><p> a unnamed <code>numeric</code> with a length equal to <code>ncol(dat)</code>
</p>
</li>
<li><p> a <code>data.frame</code> with same number of rows as <code>dat</code>
</p>
</li>
<li><p> a <code>matrix</code> with same number of rows as <code>dat</code>
</p>
</li>
<li> <p><code>Inf</code>, <code>NA</code> weights will be interpreted as that those variables must not be
changed and are fixated. <code>Inf</code> weights perform much better than setting a weight
to a large number.
</p>
</li></ul>



<h3>Value</h3>

<p><code>matrix</code> or <code>data.frame</code> of same dimensions as <code>dat</code>
</p>


<h3>See Also</h3>

<p>Other error finding: 
<code><a href="#topic+errorlocation-class">errorlocation-class</a></code>,
<code><a href="#topic+errors_removed">errors_removed</a>()</code>,
<code><a href="#topic+locate_errors">locate_errors</a>()</code>,
<code><a href="#topic+replace_errors">replace_errors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- read.csv(text=
"age,country
  49,     NL
  23,     DE
", strip.white=TRUE)

weight &lt;- c(age = 2, country = 1)
expand_weights(dat, weight)

weight &lt;- c(2, 1)
expand_weights(dat, weight, as.data.frame = TRUE)

# works too
weight &lt;- c(country=5)
expand_weights(dat, weight)

# specify a per row weight for country
weight &lt;- data.frame(country=c(1,5))
expand_weights(dat, weight)

# country should not be changed!
weight &lt;- c(country = Inf)
expand_weights(dat, weight)
</code></pre>

<hr>
<h2 id='expect_values'>expect values</h2><span id='topic+expect_values'></span>

<h3>Description</h3>

<p>expect values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_values(values, weights, delta_names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expect_values_+3A_values">values</code></td>
<td>
<p>named list of values.</p>
</td></tr>
<tr><td><code id="expect_values_+3A_weights">weights</code></td>
<td>
<p>named numeric of equal length as values.</p>
</td></tr>
<tr><td><code id="expect_values_+3A_delta_names">delta_names</code></td>
<td>
<p>alternative names for binary variables. (used for log)</p>
</td></tr>
<tr><td><code id="expect_values_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='FHLocalizer-class'>Feligi-Holt Errorlocalizer</h2><span id='topic+FHLocalizer-class'></span><span id='topic+fh_localizer'></span>

<h3>Description</h3>

<p>Implementation of the Feligi-Holt algorithm using the <code>ErrorLocalizer</code> base class.
Given a set of validation rules and a dataset the Feligi-Holt algorithm finds for each record
the smallest (weighted) combination of variables that are erroneous (if any).
</p>


<h3>Note</h3>

<p>Most users do not need this class and can use <code><a href="#topic+locate_errors">locate_errors()</a></code>.
</p>
<p><code>errorlocalizer</code> implements feligi holt using a MIP-solver. For problems in which
coefficients of the validation rules or the data are too different, you should consider scaling
the data.
</p>

<hr>
<h2 id='inspect_mip'>inspect the mip problem formulation</h2><span id='topic+inspect_mip'></span>

<h3>Description</h3>

<p>Utility function to inspect the mip problem for a record. <code>inspect_mip</code> can
be used as a &quot;drop-in&quot; replacement for <code><a href="#topic+locate_errors">locate_errors()</a></code>, but works on the
first record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect_mip(data, x, weight, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspect_mip_+3A_data">data</code></td>
<td>
<p>data to be checked</p>
</td></tr>
<tr><td><code id="inspect_mip_+3A_x">x</code></td>
<td>
<p>validation rules or errorlocalizer object to be used for finding
possible errors.</p>
</td></tr>
<tr><td><code id="inspect_mip_+3A_weight">weight</code></td>
<td>
<p><code>numeric</code> optional weight specification to be used in the
error localization (see <code><a href="#topic+expand_weights">expand_weights()</a></code>).</p>
</td></tr>
<tr><td><code id="inspect_mip_+3A_...">...</code></td>
<td>
<p>optional parameters that are passed to <code><a href="lpSolveAPI.html#topic+lp.control">lpSolveAPI::lp.control()</a></code> (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It may sometimes be handy to find out what is happening exactly with a record.
See the example section for finding out what to do with inspect_mip. See
<code>vignette("inspect_mip")</code> for more details.
</p>


<h3>See Also</h3>

<p>Other Mixed Integer Problem: 
<code><a href="#topic+MipRules-class">MipRules-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rules &lt;- validator(x &gt; 1)
data &lt;- list(x = 0)
weight &lt;- c(x = 1)

mip &lt;- inspect_mip(data, rules)
print(mip)

# inspect the lp problem (prior to solving it with lpsolveAPI)
lp &lt;- mip$to_lp()
print(lp)

# for large problems write the lp problem to disk for inspection
# lpSolveAPI::write.lp(lp, "my_problem.lp")

# solve the mip system / find a solution
res &lt;- mip$execute()
names(res)

# lpSolveAPI status of finding a solution
res$s

# lp problem after solving (often simplified version of first lp)
res$lp

# records that are deemed "faulty"
res$errors

# values of variables used in the mip formulation. Also contains a valid solution
# for "faulty" variables
res$values

# see the derived mip rules and objective function, used in the construction of
# lp problem
mip$mip_rules()
mip$objective
</code></pre>

<hr>
<h2 id='is_categorical'>Check if rules are categorical</h2><span id='topic+is_categorical'></span>

<h3>Description</h3>

<p>Check if rules are categorical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_categorical(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_categorical_+3A_x">x</code></td>
<td>
<p>validator or expression object</p>
</td></tr>
<tr><td><code id="is_categorical_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>#' @note <code>errorlocate</code> supports linear,
categorical and conditional rules to be used in finding errors. Other rule types
are ignored during error finding.
</p>


<h3>Value</h3>

<p>logical indicating which rules are purely categorical/logical
</p>


<h3>See Also</h3>

<p>Other rule type: 
<code><a href="#topic+is_conditional">is_conditional</a>()</code>,
<code><a href="#topic+is_linear">is_linear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- validator( A %in% c("a1", "a2")
              , B %in% c("b1", "b2")
              , if (A == "a1") B == "b1"
              , y &gt; x
              )

is_categorical(v)
</code></pre>

<hr>
<h2 id='is_conditional'>Check if rules are conditional rules</h2><span id='topic+is_conditional'></span>

<h3>Description</h3>

<p>Check if rules are conditional rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_conditional(rules, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_conditional_+3A_rules">rules</code></td>
<td>
<p>validator object containing validation rules</p>
</td></tr>
<tr><td><code id="is_conditional_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating which rules are conditional
</p>


<h3>Note</h3>

<p><code>errorlocate</code> supports linear,
categorical and conditional rules to be used in finding errors. Other rule types
are ignored during error finding.
</p>


<h3>See Also</h3>

<p>Other rule type: 
<code><a href="#topic+is_categorical">is_categorical</a>()</code>,
<code><a href="#topic+is_linear">is_linear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- validator( A %in% c("a1", "a2")
              , B %in% c("b1", "b2")
              , if (A == "a1")  x &gt; 1 # conditional
              , if (y &gt; 0) x &gt;= 0 # conditional
              , if (A == "a1") B == "b1" # categorical
              )

is_conditional(v)
</code></pre>

<hr>
<h2 id='is_linear'>Check which rules are linear rules.</h2><span id='topic+is_linear'></span>

<h3>Description</h3>

<p>Check which rules are linear rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_linear(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_linear_+3A_x">x</code></td>
<td>
<p><code><a href="validate.html#topic+validator">validator()</a></code> object containing data validation rules</p>
</td></tr>
<tr><td><code id="is_linear_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> indicating which rules are (purely) linear.
</p>


<h3>Note</h3>

<p><code>errorlocate</code> supports linear,
categorical and conditional rules to be used in finding errors. Other rule types
are ignored during error finding.
</p>


<h3>See Also</h3>

<p>Other rule type: 
<code><a href="#topic+is_categorical">is_categorical</a>()</code>,
<code><a href="#topic+is_conditional">is_conditional</a>()</code>
</p>

<hr>
<h2 id='locate_errors'>Find errors in data</h2><span id='topic+locate_errors'></span><span id='topic+locate_errors+2Cdata.frame+2Cvalidator-method'></span><span id='topic+locate_errors+2Cdata.frame+2CErrorLocalizer-method'></span>

<h3>Description</h3>

<p>Find out which fields in a data.frame are &quot;faulty&quot; using validation rules
This method returns found errors, according to the specified method <code>x</code>.
Use method <code><a href="#topic+replace_errors">replace_errors()</a></code>, to automatically remove these errors.
'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_errors(
  data,
  x,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  timeout = 60
)

## S4 method for signature 'data.frame,validator'
locate_errors(
  data,
  x,
  weight = NULL,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  timeout = 60
)

## S4 method for signature 'data.frame,ErrorLocalizer'
locate_errors(
  data,
  x,
  weight = NULL,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  timeout = 60
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_errors_+3A_data">data</code></td>
<td>
<p>data to be checked</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_x">x</code></td>
<td>
<p>validation rules or errorlocalizer object to be used for finding
possible errors.</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_...">...</code></td>
<td>
<p>optional parameters that are passed to <code><a href="lpSolveAPI.html#topic+lp.control">lpSolveAPI::lp.control()</a></code> (see details)</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_cl">cl</code></td>
<td>
<p>optional parallel / cluster.</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_ncpus">Ncpus</code></td>
<td>
<p>number of nodes to use. See details</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_timeout">timeout</code></td>
<td>
<p>maximum number of seconds that the localizer should use per record.</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_weight">weight</code></td>
<td>
<p><code>numeric</code> optional weight specification to be used in the
error localization (see <code><a href="#topic+expand_weights">expand_weights()</a></code>).</p>
</td></tr>
<tr><td><code id="locate_errors_+3A_ref">ref</code></td>
<td>
<p><code>data.frame</code> optional reference data to be used in the rules checking</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use an <code>Inf</code> <code>weight</code> specification to fixate variables that can not be changed.
See <code><a href="#topic+expand_weights">expand_weights()</a></code> for more details.
</p>
<p><code>locate_errors</code> uses lpSolveAPI to formulate and solves a mixed integer problem.
For details see the vignettes.
This solver has many options:  <a href="lpSolveAPI.html#topic+lp.control.options">lpSolveAPI::lp.control.options</a>. Noteworthy
options to be used are:
</p>

<ul>
<li> <p><code>timeout</code>: restricts the time the solver spends on a record (seconds)
</p>
</li>
<li> <p><code>break.at.value</code>: set this to minimum weight + 1 to improve speed.
</p>
</li>
<li> <p><code>presolve</code>: default for errorlocate is &quot;rows&quot;. Set to &quot;none&quot; when you have
solutions where all variables are deemed wrong.
</p>
</li></ul>

<p><code>locate_errors</code> can be run on multiple cores using R package <code>parallel</code>.
</p>

<ul>
<li><p> The easiest way to use the parallel option is to set <code>Ncpus</code> to the number of
desired cores, @seealso <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.
</p>
</li>
<li><p> Alternatively one can create a cluster object (<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>)
and use <code>cl</code> to pass the cluster object.
</p>
</li>
<li><p> Or set <code>cl</code> to an integer which results in <code><a href="parallel.html#topic+mclapply">parallel::mclapply()</a></code>, which only works
on non-windows.
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="#topic+errorlocation-class">errorlocation-class()</a></code> object describing the errors found.
</p>


<h3>See Also</h3>

<p>Other error finding: 
<code><a href="#topic+errorlocation-class">errorlocation-class</a></code>,
<code><a href="#topic+errors_removed">errors_removed</a>()</code>,
<code><a href="#topic+expand_weights">expand_weights</a>()</code>,
<code><a href="#topic+replace_errors">replace_errors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rules &lt;- validator( profit + cost == turnover
                  , cost &gt;= 0.6 * turnover # cost should be at least 60% of turnover
                  , turnover &gt;= 0 # can not be negative.
                  )
data &lt;- data.frame( profit   = 755
                  , cost     = 125
                  , turnover = 200
                  )
le &lt;- locate_errors(data, rules)

print(le)
summary(le)

v_categorical &lt;- validator( branch %in% c("government", "industry")
                          , tax %in% c("none", "VAT")
                          , if (tax == "VAT") branch == "industry"
)

data &lt;- read.csv(text=
"   branch, tax
government, VAT
industry  , VAT
", strip.white = TRUE)
locate_errors(data, v_categorical)$errors

v_logical &lt;- validator( citizen %in% c(TRUE, FALSE)
                      , voted %in% c(TRUE, FALSE)
                      ,  if (voted == TRUE) citizen == TRUE
                      )

data &lt;- data.frame(voted = TRUE, citizen = FALSE)
locate_errors(data, v_logical, weight=c(2,1))$errors

# try a condinational rule
v &lt;- validator( married %in% c(TRUE, FALSE)
              , if (married==TRUE) age &gt;= 17
              )
data &lt;- data.frame( married = TRUE, age = 16)
locate_errors(data, v, weight=c(married=1, age=2))$errors


# different weights per row
data &lt;- read.csv(text=
"married, age
    TRUE,  16
    TRUE,  14
", strip.white = TRUE)

weight &lt;- read.csv(text=
"married, age
       1,   2
       2,   1
", strip.white = TRUE)

locate_errors(data, v, weight = weight)$errors

# fixate / exclude a variable from error localiziation
# using an Inf weight
weight &lt;- c(age = Inf)
locate_errors(data, v, weight = weight)$errors
</code></pre>

<hr>
<h2 id='mip_rule'>Create a rule used by mip</h2><span id='topic+mip_rule'></span>

<h3>Description</h3>

<p>Create a rule used by mip
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mip_rule(a, op, b, rule, type, weight = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mip_rule_+3A_a">a</code></td>
<td>
<p>named vector with coefficients</p>
</td></tr>
<tr><td><code id="mip_rule_+3A_op">op</code></td>
<td>
<p>operator in (&quot;&lt;=&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='MipRules-class'>Create a mip object from a validator object</h2><span id='topic+MipRules-class'></span><span id='topic+miprules'></span>

<h3>Description</h3>

<p>Create a mip object from <code><a href="validate.html#topic+validator">validator()</a></code> object.
This is a utility class that translates a validor object into a mixed integer problem that
can be solved.
Most users should use <code><a href="#topic+locate_errors">locate_errors()</a></code> which will handle all translation and execution
automatically. This class is provided so users can implement or derive an alternative solution.
</p>


<h3>Methods</h3>

<p>The <code>MipRules</code> class contains the following methods:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$execute()&#8288;</code> calls the mip solver to execute the rules.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$to_lp()&#8288;</code>: transforms the object into a lp_solve object
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$is_infeasible&#8288;</code> Checks if the current system of mixed integer rules is feasible.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$set_values&#8288;</code>: set values and weights for variables (determines the objective function).
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Mixed Integer Problem: 
<code><a href="#topic+inspect_mip">inspect_mip</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rules &lt;- validator(x &gt; 1)
mr &lt;- miprules(rules)
mr$to_lp()
mr$set_values(c(x=0), weights=c(x=1))
mr$execute()
</code></pre>

<hr>
<h2 id='replace_errors'>Replace erroneous fields with NA or a suggested value</h2><span id='topic+replace_errors'></span><span id='topic+replace_errors+2Cdata.frame+2Cvalidator-method'></span><span id='topic+replace_errors+2Cdata.frame+2CErrorLocalizer-method'></span><span id='topic+replace_errors+2Cdata.frame+2Cerrorlocation-method'></span>

<h3>Description</h3>

<p>Find erroneous fields using <code><a href="#topic+locate_errors">locate_errors()</a></code> and replace these
fields automatically with NA or a suggestion that is provided by the error detection algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_errors(
  data,
  x,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  value = c("NA", "suggestion")
)

## S4 method for signature 'data.frame,validator'
replace_errors(
  data,
  x,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  value = c("NA", "suggestion")
)

## S4 method for signature 'data.frame,ErrorLocalizer'
replace_errors(
  data,
  x,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = getOption("Ncpus", 1),
  value = c("NA", "suggestion")
)

## S4 method for signature 'data.frame,errorlocation'
replace_errors(
  data,
  x,
  ref = NULL,
  ...,
  cl = NULL,
  Ncpus = 1,
  value = c("NA", "suggestion")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_errors_+3A_data">data</code></td>
<td>
<p>data to be checked</p>
</td></tr>
<tr><td><code id="replace_errors_+3A_x">x</code></td>
<td>
<p><code><a href="validate.html#topic+validator">validator()</a></code> or <code>errorlocation</code> object.
If an <code>errorlocation</code> is already available (through <code><a href="#topic+locate_errors">locate_errors()</a></code>) this
is more efficient.</p>
</td></tr>
<tr><td><code id="replace_errors_+3A_ref">ref</code></td>
<td>
<p>optional reference data set</p>
</td></tr>
<tr><td><code id="replace_errors_+3A_...">...</code></td>
<td>
<p>these parameters are handed over to <code><a href="#topic+locate_errors">locate_errors()</a></code></p>
</td></tr>
<tr><td><code id="replace_errors_+3A_cl">cl</code></td>
<td>
<p>optional cluster for parallel execution (see details)</p>
</td></tr>
<tr><td><code id="replace_errors_+3A_ncpus">Ncpus</code></td>
<td>
<p>number of nodes to use. (see details)</p>
</td></tr>
<tr><td><code id="replace_errors_+3A_value">value</code></td>
<td>
<p><code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that you can also use the result of <code><a href="#topic+locate_errors">locate_errors()</a></code> with <code>replace_errors</code>.
When the procedure takes a long time and <code>locate_errors</code> was called previously
this is the preferred way, because otherwise <code>locate_errors</code> will be executed again.
The errors that were removed from the <code>data.frame</code> can be retrieved with the function
<code><a href="#topic+errors_removed">errors_removed()</a></code>. For more control over error localization see <code><a href="#topic+locate_errors">locate_errors()</a></code>.
</p>
<p><code>replace_errors</code> has the same parallelization options as <code><a href="#topic+locate_errors">locate_errors()</a></code> (see there).
</p>


<h3>Value</h3>

<p><code>data</code> with erroneous values removed.
</p>


<h3>Note</h3>

<p>In general it is better to replace the erroneous fields with <code>NA</code> and apply a proper
imputation method. Suggested values from the error localization method may introduce an undesired bias.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+errorlocation-class">errorlocation-class()</a></code>
</p>
<p>Other error finding: 
<code><a href="#topic+errorlocation-class">errorlocation-class</a></code>,
<code><a href="#topic+errors_removed">errors_removed</a>()</code>,
<code><a href="#topic+expand_weights">expand_weights</a>()</code>,
<code><a href="#topic+locate_errors">locate_errors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rules &lt;- validator( profit + cost == turnover
              , cost - 0.6*turnover &gt;= 0
              , cost&gt;= 0
              , turnover &gt;= 0
)
data &lt;- data.frame(profit=755, cost=125, turnover=200)

data_no_error &lt;- replace_errors(data,rules)

# faulty data was replaced with NA
data_no_error

errors_removed(data_no_error)

# a bit more control, you can supply the result of locate_errors
# to replace_errors, which is a good thing, otherwise replace_errors will call
# locate_errors internally.
error_locations &lt;- locate_errors(data, rules)
replace_errors(data, error_locations)
</code></pre>

<hr>
<h2 id='translate_mip_lp'>translate linear rules into an lp problem</h2><span id='topic+translate_mip_lp'></span>

<h3>Description</h3>

<p>translate linear rules into an lp problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate_mip_lp(rules, objective = NULL, eps = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translate_mip_lp_+3A_rules">rules</code></td>
<td>
<p>mip rules</p>
</td></tr>
<tr><td><code id="translate_mip_lp_+3A_objective">objective</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="translate_mip_lp_+3A_eps">eps</code></td>
<td>
<p>accuracy for equality/inequality</p>
</td></tr>
<tr><td><code id="translate_mip_lp_+3A_...">...</code></td>
<td>
<p>additional <code><a href="lpSolveAPI.html#topic+lp.control">lp.control()</a></code> parameters that are set for the mip problem</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
