<!DOCTYPE html><html><head><title>Help for package ICSKAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICSKAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACAT'><p>Aggregated Cauchy Association Test</p></a></li>
<li><a href='#calcScoreStats'><p>calcScoreStats.R</p></a></li>
<li><a href='#chiSqMatchFast'><p>chiSqMatchFast.R</p></a></li>
<li><a href='#construct_interval_probs'><p>construct_interval_probs.R</p></a></li>
<li><a href='#coxphFn'><p>coxphFn</p></a></li>
<li><a href='#createInt'><p>Called by gen_IC_data() to turn the actual outcome times and observation times into interval-censored</p>
outcomes for each subject. Apply this with mapply over a data.frame of visit times, pass in the exact times.</a></li>
<li><a href='#fIntegrate'><p>fIntegrate.R</p></a></li>
<li><a href='#fIntegrateLiu'><p>fIntegrateLiu.R</p></a></li>
<li><a href='#gen_IC_data'><p>gen_IC_data.R</p></a></li>
<li><a href='#ICsingleSNP'><p>ICsingleSNP.R</p></a></li>
<li><a href='#ICskat'><p>ICSKAT.R</p></a></li>
<li><a href='#ICSKAT_fit_null'><p>ICSKAT_fit_null.R</p></a></li>
<li><a href='#ICSKAT_fit_null_PO'><p>ICSKAT_fit_null_PO.R</p></a></li>
<li><a href='#ICSKATO'><p>ICSKATO.R</p></a></li>
<li><a href='#ICSKATO_bootstrap'><p>ICSKATO_bootstrap.R</p></a></li>
<li><a href='#ICskatPO'><p>ICSKATPO.R</p></a></li>
<li><a href='#ICSKATwrapper'><p>ICSKATwrapper.R</p></a></li>
<li><a href='#make_IC_dmat'><p>make_IC_dmat.R</p></a></li>
<li><a href='#matchVisit'><p>match_visit.R</p></a></li>
<li><a href='#mixture_kurtosis'><p>mixture_kurtosis.R</p></a></li>
<li><a href='#QrhoIC'><p>QrhoIC.R</p></a></li>
<li><a href='#singleSNPalt'><p>singleSNPalt.R</p></a></li>
<li><a href='#survregFn'><p>survregFn</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interval-Censored Sequence Kernel Association Test</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Interval-Censored Sequence Kernel Association (ICSKAT) test for testing the association between interval-censored time-to-event outcomes and groups of single nucleotide polymorphisms (SNPs). Interval-censored time-to-event data occur when the event time is not known exactly but can be deduced to fall within a given interval. For example, some medical conditions like bone mineral density deficiency are generally only diagnosed at clinical visits. If a patient goes for clinical checkups yearly and is diagnosed at, say, age 30, then the onset of the deficiency is only known to fall between the date of their age 29 checkup and the date of the age 30 checkup. Interval-censored data include right- and left-censored data as special cases. This package also implements the interval-censored Burden test and the ICSKATO test, which is the optimal combination of the ICSKAT and Burden tests. Please see the vignette for a quickstart guide.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>CompQuadForm, dplyr, magrittr, Rcpp (&ge; 0.11.3), rje,
survival, zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-25 05:14:53 UTC; rsun3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Sun [aut, cre],
  Liang Zhu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Sun &lt;ryansun.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-25 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACAT'>Aggregated Cauchy Association Test</h2><span id='topic+ACAT'></span>

<h3>Description</h3>

<p>A p-value combination method using the Cauchy distribution.
Code provided by Dr. Yaowu Liu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACAT(Pvals, Weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACAT_+3A_pvals">Pvals</code></td>
<td>
<p>a numeric vector of p-values to be combined by ACAT.</p>
</td></tr>
<tr><td><code id="ACAT_+3A_weights">Weights</code></td>
<td>
<p>a numeric vector of non-negative weights for the combined p-values. When it is NULL, the equal weights are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value of ACAT.
</p>


<h3>Author(s)</h3>

<p>Yaowu Liu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p.values&lt;-c(2e-02,4e-04,0.2,0.1,0.8)
ACAT(Pvals=p.values)

</code></pre>

<hr>
<h2 id='calcScoreStats'>calcScoreStats.R</h2><span id='topic+calcScoreStats'></span>

<h3>Description</h3>

<p>Function that is applied in ICsingleSNP() to calculate a score statistic and p-value for each
column of an n*p genotype matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcScoreStats(x, UgTerm, ggTerm, gtTermCommon, gtHalfL, gtHalfR, solveItt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcScoreStats_+3A_x">x</code></td>
<td>
<p>n*1 vector of genotypes.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_ugterm">UgTerm</code></td>
<td>
<p>n*1 vector multiplier for the score statistic.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_ggterm">ggTerm</code></td>
<td>
<p>n*1 vector multiplier for the Igg term of the variance.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_gttermcommon">gtTermCommon</code></td>
<td>
<p>n*p matrix multiplier for the common part of the Igt term of the variance.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_gthalfl">gtHalfL</code></td>
<td>
<p>n*(nknots+1) matrix multiplier for one half of the unique part of the Igt term of the variance.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_gthalfr">gtHalfR</code></td>
<td>
<p>n*(nknots+1) matrix multiplier for one half of the unique part of the Igt term of the variance.</p>
</td></tr>
<tr><td><code id="calcScoreStats_+3A_solveitt">solveItt</code></td>
<td>
<p>p*p inverse of the Itt matrix from ICSKAT_fit_null().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2*1 vector with the test statistic and then p-value.
</p>

<hr>
<h2 id='chiSqMatchFast'>chiSqMatchFast.R</h2><span id='topic+chiSqMatchFast'></span>

<h3>Description</h3>

<p>Match the moments of a mixture of scaled chi-square random variables to a single non-central chi-square,
assumes the quadratic form case where the mean of the multivariate normal V=RV is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiSqMatchFast(lambdaVec, alwaysCentral = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chiSqMatchFast_+3A_lambdavec">lambdaVec</code></td>
<td>
<p>Numeric vector holding the eigenvalues of the A term, where we are interested in x^TAX
and x is multivariate normal.</p>
</td></tr>
<tr><td><code id="chiSqMatchFast_+3A_alwayscentral">alwaysCentral</code></td>
<td>
<p>Boolean determining whether to always set the noncentrality parameter to 0, as in SKAT package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>sigmaQrho</code></td>
<td>
<p>Standard deviation of the mixture distribution</p>
</td></tr>
<tr><td><code>muQrho</code></td>
<td>
<p>Mean of the mixture distribution</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noncentrality parameter of the matched distribution</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>Degrees of freedom of the matched distribution</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)
icskatOut &lt;- ICskat(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat,
lt = lt, rt = rt, obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat,
null_beta = nullFit$beta_fit, Itt = nullFit$Itt)
Rrho &lt;- matrix(data=0.5, nrow=20, ncol=20)
diag(Rrho) &lt;- 1
toDecomp &lt;- Rrho %*% icskatOut$sig_mat
tempEvals &lt;- eigen(toDecomp, symmetric = TRUE, only.values = TRUE)$values
idx1 &lt;- which(tempEvals &gt;= 0)
idx2 &lt;- which(tempEvals &gt; mean(tempEvals[idx1])/100000)
tempEvals &lt;- tempEvals[idx2]
chiSqMatchFast(lambdaVec = tempEvals)

</code></pre>

<hr>
<h2 id='construct_interval_probs'>construct_interval_probs.R</h2><span id='topic+construct_interval_probs'></span>

<h3>Description</h3>

<p>Construct the probabilities of falling into each time interval for bootstrapping of interval-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_interval_probs(
  allTimes,
  dmats,
  nullBeta,
  p,
  nKnots,
  infVal = 999,
  zeroVal = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_interval_probs_+3A_alltimes">allTimes</code></td>
<td>
<p>n*s matrix where n is number of subjects and s is all visit times for that subjects.</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_dmats">dmats</code></td>
<td>
<p>Output from make_IC_dmats, a list holding left_dmat and right_dmat.</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_nullbeta">nullBeta</code></td>
<td>
<p>Vector of coefficients under the null model.</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_p">p</code></td>
<td>
<p>Number of covariates in the null model.</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_nknots">nKnots</code></td>
<td>
<p>Number of knots in the spline.</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_infval">infVal</code></td>
<td>
<p>The numeric value representing time 0 (left-censored observation).</p>
</td></tr>
<tr><td><code id="construct_interval_probs_+3A_zeroval">zeroVal</code></td>
<td>
<p>The numeric value representing time infinity (right-censored observation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n*(s+1) matrix where element (i,j) holds the probability that subject i will fail in interval j.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind,
lt = lt, rt = rt)
intervalProbOutput &lt;- construct_interval_probs(allTimes = outcomeDat$allVisits,
dmats = dmats, nullBeta = nullFit$beta_fit, p = ncol(xMat), nKnots=1)

</code></pre>

<hr>
<h2 id='coxphFn'>coxphFn</h2><span id='topic+coxphFn'></span>

<h3>Description</h3>

<p>Function to be applied over gMat to get p-values from coxPH().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxphFn(x, xMat, midTime, midEvent, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxphFn_+3A_x">x</code></td>
<td>
<p>n*1 genotype vector.</p>
</td></tr>
<tr><td><code id="coxphFn_+3A_xmat">xMat</code></td>
<td>
<p>n*p matrix of non-genotype covariates.</p>
</td></tr>
<tr><td><code id="coxphFn_+3A_midtime">midTime</code></td>
<td>
<p>n*1 vector of event times imputed to be right-censored times using the midpoint imputation method.</p>
</td></tr>
<tr><td><code id="coxphFn_+3A_midevent">midEvent</code></td>
<td>
<p>n*1 vector event indicators (0 for censoring, 1 for event) after times have been transformed to right-censored observations.</p>
</td></tr>
<tr><td><code id="coxphFn_+3A_p">p</code></td>
<td>
<p>scalar, number of columns in xMat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar p-value for testing the effect of the genotype in survreg() Weibull model.
</p>

<hr>
<h2 id='createInt'>Called by gen_IC_data() to turn the actual outcome times and observation times into interval-censored
outcomes for each subject. Apply this with mapply over a data.frame of visit times, pass in the exact times.</h2><span id='topic+createInt'></span>

<h3>Description</h3>

<p>Called by gen_IC_data() to turn the actual outcome times and observation times into interval-censored
outcomes for each subject. Apply this with mapply over a data.frame of visit times, pass in the exact times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createInt(obsTimes, eventTime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createInt_+3A_obstimes">obsTimes</code></td>
<td>
<p>A vector of all the times a subject is observed.</p>
</td></tr>
<tr><td><code id="createInt_+3A_eventtime">eventTime</code></td>
<td>
<p>The exact event time for the subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2*1 vector which is the interval of the event time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obsTimes &lt;- 1:10
eventTime &lt;- 7.7
createInt(obsTimes, eventTime)

</code></pre>

<hr>
<h2 id='fIntegrate'>fIntegrate.R</h2><span id='topic+fIntegrate'></span>

<h3>Description</h3>

<p>The integrand in the SKATO p-value, pass it to a numerical integration function like integrate(), uses
Davies method instead of Liu to calculate the probability in the integrand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fIntegrate(x, muK1, sigmaK1, sigmaZeta, kappaLambda, QrhoDF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fIntegrate_+3A_x">x</code></td>
<td>
<p>Variable to be integrated over, can be a vector or scalar.</p>
</td></tr>
<tr><td><code id="fIntegrate_+3A_muk1">muK1</code></td>
<td>
<p>Mean of the mixture of chi-squares that are the first part of the kappa variable.
When we do bootstrap we often pass in the mean of the entire kappa, since the mean of zeta is supposed to be 0.</p>
</td></tr>
<tr><td><code id="fIntegrate_+3A_sigmak1">sigmaK1</code></td>
<td>
<p>Standard deviation of the entire kappa term.</p>
</td></tr>
<tr><td><code id="fIntegrate_+3A_sigmazeta">sigmaZeta</code></td>
<td>
<p>Standard deviation of the zeta part of the kappa variable.</p>
</td></tr>
<tr><td><code id="fIntegrate_+3A_kappalambda">kappaLambda</code></td>
<td>
<p>Eigenvalues that weight the mixture of chi-squares that are the first part of the kappa variable.</p>
</td></tr>
<tr><td><code id="fIntegrate_+3A_qrhodf">QrhoDF</code></td>
<td>
<p>The data frame output from calling QrhoIC().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integrand at x.
</p>

<hr>
<h2 id='fIntegrateLiu'>fIntegrateLiu.R</h2><span id='topic+fIntegrateLiu'></span>

<h3>Description</h3>

<p>The integrand in the SKATO p-value when using Liu instead of Davies method, pass it to a numerical integration function like integrate().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fIntegrateLiu(x, muK1, sigmaK1, QrhoDF, dfK1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fIntegrateLiu_+3A_x">x</code></td>
<td>
<p>Variable to be integrated over, can be a vector or scalar.</p>
</td></tr>
<tr><td><code id="fIntegrateLiu_+3A_muk1">muK1</code></td>
<td>
<p>Mean of the mixture of chi-squares that are the first part of the kappa variable.</p>
</td></tr>
<tr><td><code id="fIntegrateLiu_+3A_sigmak1">sigmaK1</code></td>
<td>
<p>Standard deviation of the mixture of chi-squares that are the first part of the kappa variable.</p>
</td></tr>
<tr><td><code id="fIntegrateLiu_+3A_qrhodf">QrhoDF</code></td>
<td>
<p>The data frame output from calling QrhoIC().</p>
</td></tr>
<tr><td><code id="fIntegrateLiu_+3A_dfk1">dfK1</code></td>
<td>
<p>The degrees of freedom from the approximated chi-square.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the integrand at x.
</p>

<hr>
<h2 id='gen_IC_data'>gen_IC_data.R</h2><span id='topic+gen_IC_data'></span>

<h3>Description</h3>

<p>Generate interval-censored data under the proportional odds/PH model given a baseline hazard function and
some information about observation times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_IC_data(bhFunInv, obsTimes, windowHalf, etaVec, mod = "PH", probMiss = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_IC_data_+3A_bhfuninv">bhFunInv</code></td>
<td>
<p>A function, the inverse of the baseline hazard function.</p>
</td></tr>
<tr><td><code id="gen_IC_data_+3A_obstimes">obsTimes</code></td>
<td>
<p>Vector of the intended observation times.</p>
</td></tr>
<tr><td><code id="gen_IC_data_+3A_windowhalf">windowHalf</code></td>
<td>
<p>The amount of time before or after the intended obsTimes that a visit might take place.</p>
</td></tr>
<tr><td><code id="gen_IC_data_+3A_etavec">etaVec</code></td>
<td>
<p>n*1 linear predictor in either the proportional odds or proportional hzards model.</p>
</td></tr>
<tr><td><code id="gen_IC_data_+3A_mod">mod</code></td>
<td>
<p>Either &quot;PH&quot; to generate under PH model or &quot;PO&quot; to generate under PO model.</p>
</td></tr>
<tr><td><code id="gen_IC_data_+3A_probmiss">probMiss</code></td>
<td>
<p>The probability of missing any given visit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code>tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code>tVec</code></td>
<td>
<p>Fisher information matrix for the fitted coefficients.</p>
</td></tr>
<tr><td><code>leftTimes</code></td>
<td>
<p>n*1 vector of left side of interval times.</p>
</td></tr>
<tr><td><code>rightTimes</code></td>
<td>
<p>n*1 vector of right side of interval times.</p>
</td></tr>
<tr><td><code>tVec</code></td>
<td>
<p>n*1 vector of exact event times.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)

</code></pre>

<hr>
<h2 id='ICsingleSNP'>ICsingleSNP.R</h2><span id='topic+ICsingleSNP'></span>

<h3>Description</h3>

<p>Burden test from ICSKAT() except do a separate burden test for each SNP in gMat, one at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICsingleSNP(
  left_dmat,
  right_dmat,
  lt,
  rt,
  obs_ind,
  tpos_ind,
  gMat,
  null_beta,
  solveItt,
  p
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICsingleSNP_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left side of time interval.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right side of time interval.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_gmat">gMat</code></td>
<td>
<p>n*q genotype matrix.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_null_beta">null_beta</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients for null model.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_solveitt">solveItt</code></td>
<td>
<p>Inverse of (p+nknots+2)*(p+nknots+2) Fisher information matrix for null model coefficients.</p>
</td></tr>
<tr><td><code id="ICsingleSNP_+3A_p">p</code></td>
<td>
<p>number of non-SNP covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>testStatsVec</code></td>
<td>
<p>p*1 vector of score test statistics</p>
</td></tr>
<tr><td><code>pVec</code></td>
<td>
<p>p*1 vector of score test p-values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)
solveItt  &lt;- solve(nullFit$Itt)
ICsingleSNP(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat, lt = lt, rt = rt,
obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat, null_beta = nullFit$beta_fit,
solveItt = solveItt, p=2)

</code></pre>

<hr>
<h2 id='ICskat'>ICSKAT.R</h2><span id='topic+ICskat'></span>

<h3>Description</h3>

<p>Calculate the test statistic and p-value for interval-censored SKAT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICskat(
  left_dmat,
  right_dmat,
  lt,
  rt,
  obs_ind,
  tpos_ind,
  gMat,
  null_beta,
  Itt,
  pvalue = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICskat_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left side of interval times.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right side of interval times.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICskat_+3A_gmat">gMat</code></td>
<td>
<p>n*q genotype matrix.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_null_beta">null_beta</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients for null model.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_itt">Itt</code></td>
<td>
<p>(p+nknots+2)*(p+nknots+2) Fisher information matrix for null model coefficients.</p>
</td></tr>
<tr><td><code id="ICskat_+3A_pvalue">pvalue</code></td>
<td>
<p>Boolean, if TRUE then find the p-value (maybe don't need it if bootstrapping, saves eigendecomposition)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>p_SKAT</code></td>
<td>
<p>ICSKAT p-value</p>
</td></tr>
<tr><td><code>p_burden</code></td>
<td>
<p>IC burden test p-value</p>
</td></tr>
<tr><td><code>complex</code></td>
<td>
<p>Indicator of whether the SKAT variance matrix was positive definite</p>
</td></tr>
<tr><td><code>sig_mat</code></td>
<td>
<p>The covariance matrix of the score equations for genetic effects when treated as fixed effects</p>
</td></tr>
<tr><td><code>skatQ</code></td>
<td>
<p>SKAT test statistic</p>
</td></tr>
<tr><td><code>burdenQ</code></td>
<td>
<p>Burden test statistic</p>
</td></tr>
<tr><td><code>Ugamma</code></td>
<td>
<p>Score vector</p>
</td></tr>
<tr><td><code>lambdaQ</code></td>
<td>
<p>Vector of eigenvalues of variance matrix</p>
</td></tr>
<tr><td><code>null_beta</code></td>
<td>
<p>The fitted null parameters</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>Will be 0 for no error, 22 if had to adjust parameters on CompQuadForm (totally normal), or 99 if NA in variance matrix. ICSKATwrapper will return 1 here if the null fit has an error</p>
</td></tr>
<tr><td><code>errMsg</code></td>
<td>
<p>Explains error code, blank string if no error</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind,
lt = lt, rt = rt)
ICskat(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat,
lt = lt, rt = rt, obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat,
null_beta = nullFit$beta_fit, Itt = nullFit$Itt)

</code></pre>

<hr>
<h2 id='ICSKAT_fit_null'>ICSKAT_fit_null.R</h2><span id='topic+ICSKAT_fit_null'></span>

<h3>Description</h3>

<p>Fit the null model (cubic basis spline for baseline cumulative hazard and coefficients
for non-genetic coefficiens) for interval-censored skat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSKAT_fit_null(
  init_beta,
  left_dmat,
  right_dmat,
  obs_ind,
  tpos_ind,
  lt,
  rt,
  runOnce = FALSE,
  checkpoint = FALSE,
  eps = 10^(-6)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSKAT_fit_null_+3A_init_beta">init_beta</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients to initialize the Newton-Raphson.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left interval times.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right interval times.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_runonce">runOnce</code></td>
<td>
<p>Boolean tells the function to just go through the loop once instead of converging (to get quantites for bootstrapping).</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_checkpoint">checkpoint</code></td>
<td>
<p>Boolean tells the function to print when each iteration completes.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_+3A_eps">eps</code></td>
<td>
<p>Stop when the L2 norm of the difference in model coefficients reaches this limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>beta_fit</code></td>
<td>
<p>(p+nknots+2)*1 vector of fitted coefficients under null model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>Itt</code></td>
<td>
<p>Fisher information matrix for the fitted coefficients.</p>
</td></tr>
<tr><td><code>diff_beta</code></td>
<td>
<p>Difference between beta_fit and previous iteration of the vector, can be checked for errors.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>Value is 0 if no errors and 1 if Itt is singular, can't perform fit.</p>
</td></tr>
<tr><td><code>errMsg</code></td>
<td>
<p>Empty string if err=0, explains error if there is one.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)

</code></pre>

<hr>
<h2 id='ICSKAT_fit_null_PO'>ICSKAT_fit_null_PO.R</h2><span id='topic+ICSKAT_fit_null_PO'></span>

<h3>Description</h3>

<p>Fit the null model (cubic basis spline for baseline cumulative hazard and coefficients
for non-genetic coefficients) for interval-censored skat with PO model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSKAT_fit_null_PO(
  init_beta,
  left_dmat,
  right_dmat,
  obs_ind,
  tpos_ind,
  lt,
  rt,
  checkpoint = FALSE,
  eps = 10^(-6)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_init_beta">init_beta</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients to initialize the Newton-Raphson.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left side of interval times.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right side of interval times.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_checkpoint">checkpoint</code></td>
<td>
<p>Boolean tells the function to print when each iteration completes.</p>
</td></tr>
<tr><td><code id="ICSKAT_fit_null_PO_+3A_eps">eps</code></td>
<td>
<p>Stop when the L2 norm of the difference in model coefficients reaches this limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>beta_fit</code></td>
<td>
<p>(p+nknots+2)*1 vector of fitted coefficients under null model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations needed to converge.</p>
</td></tr>
<tr><td><code>Itt</code></td>
<td>
<p>Fisher information matrix for the fitted coefficients.</p>
</td></tr>
<tr><td><code>diff_beta</code></td>
<td>
<p>Difference between beta_fit and previous iteration of the vector, can be checked for errors.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>err=1 if NA shows up in the calculation.</p>
</td></tr>
<tr><td><code>IterrMsg</code></td>
<td>
<p>Describes the error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat = xMat, lt = lt, rt = rt, obs_ind = obs_ind,
tpos_ind = tpos_ind)
ICSKAT_fit_null_PO(init_beta = rep(0.1, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)
</code></pre>

<hr>
<h2 id='ICSKATO'>ICSKATO.R</h2><span id='topic+ICSKATO'></span>

<h3>Description</h3>

<p>Calculate SKATO test for ICSKAT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSKATO(
  rhoVec = c(0, 0.01, 0.04, 0.09, 0.25, 0.5, 1),
  icskatOut,
  useMixtureKurt = FALSE,
  liu = TRUE,
  liuIntegrate = FALSE,
  bootstrapOut = NULL,
  alwaysCentral = FALSE,
  ACAT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSKATO_+3A_rhovec">rhoVec</code></td>
<td>
<p>Vector of rhos to search over.</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_icskatout">icskatOut</code></td>
<td>
<p>The output list from ICSKAT().</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_usemixturekurt">useMixtureKurt</code></td>
<td>
<p>Boolean for whether to use the mixture formula to estimate the kurtosis of Qrho when we
have bootstrap results. Default is false, instead we just use the bootstraped kurtosis of Qrho.</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_liu">liu</code></td>
<td>
<p>Boolean for whether to use Liu moment matching approximation for p-value of each Qrho (as opposed to Davies).
If Davies, cannot use bootstrapped moments of Qrho.</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_liuintegrate">liuIntegrate</code></td>
<td>
<p>Boolean for whether to use Liu moment matching approximation integration in SKATO p-value (as opposed to Davies).</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_bootstrapout">bootstrapOut</code></td>
<td>
<p>Output list from call to ICSKATO_bootstrap().</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_alwayscentral">alwaysCentral</code></td>
<td>
<p>A boolean, if TRUE, follow SKAT package practice of always setting delta=0 in chi-square moment matching.</p>
</td></tr>
<tr><td><code id="ICSKATO_+3A_acat">ACAT</code></td>
<td>
<p>Uses the ACAT method to perform ICSKATO, will result in a conservative test but is much faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>SKATO p-value.</p>
</td></tr>
<tr><td><code>correctedP</code></td>
<td>
<p>Corrected SKATO p-value, which will be the same as pval when not all Qrho values produce
a p-value between 0 and 1 (e.g. sometimes it will be 0). Correction is same as SKAT package correction..</p>
</td></tr>
<tr><td><code>QrhoDF</code></td>
<td>
<p>Data frame containing the distribution and p-value for each Qrho.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The rank of the cholesky decomposition of the sig_mat returned from ICSKAT(), i.e. V^-1/2 or Z.</p>
</td></tr>
<tr><td><code>intDavies</code></td>
<td>
<p>Boolean denoting whether integration was with Davies (true) or Liu method (false).</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>0 is no error, 1 is early error like possibly only one eigenvalue/issue with sigmat/issue with kappaMat/issue with QrhoDF,
2 is corrected p-value (fine), 3 is integration error, 9 is no positive p-values (so SKATOp should be 0 unless burden is 1).</p>
</td></tr>
<tr><td><code>lambdaKurtK1</code></td>
<td>
<p>Kurtosis of kappa term minus zeta using eigenvalues, we use it to approximate the kurtosis of the entire kappa.</p>
</td></tr>
<tr><td><code>lambdaSigmaK1</code></td>
<td>
<p>Standard deviation of kappa term, including zeta, using eigenvalues.</p>
</td></tr>
<tr><td><code>lambdaMuK1</code></td>
<td>
<p>Mean of kappa term using eigenvalues.</p>
</td></tr>
<tr><td><code>bootKurtKappaAll</code></td>
<td>
<p>Kurtosis of entire kappa term, including zeta, using bootstrap data</p>
</td></tr>
<tr><td><code>bootSigmaKappaAll</code></td>
<td>
<p>Standard deviation of entire kappa term using bootstrap data.</p>
</td></tr>
<tr><td><code>bootMuKappaAll</code></td>
<td>
<p>Mean of entire kappa term using bootstrap data.</p>
</td></tr>
<tr><td><code>mixDFVec</code></td>
<td>
<p>Degrees of freedom of Qrho if useMixtureKurt is true, only here to match SKAT package, not really used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind,
lt = lt, rt = rt)
icskatOut &lt;- ICskat(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat,
lt = lt, rt = rt, obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat,
null_beta = nullFit$beta_fit, Itt = nullFit$Itt)
ICSKATO(icskatOut = icskatOut)
</code></pre>

<hr>
<h2 id='ICSKATO_bootstrap'>ICSKATO_bootstrap.R</h2><span id='topic+ICSKATO_bootstrap'></span>

<h3>Description</h3>

<p>The version of ICSKATO to run when bootstrapping to match kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSKATO_bootstrap(
  icskatOut,
  B,
  intervalProbs,
  allVisits,
  quant_r,
  seed = NULL,
  null_fit,
  gMat,
  xMat,
  fitAgain,
  checkpoint = FALSE,
  downsample = 1,
  rhoVec
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSKATO_bootstrap_+3A_icskatout">icskatOut</code></td>
<td>
<p>The output list from ICSKAT().</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_intervalprobs">intervalProbs</code></td>
<td>
<p>n*(s+1) matrix where n is number of subjects and s is the number of visits possible, probability of falling in each interval.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_allvisits">allVisits</code></td>
<td>
<p>n*s matrix with all the visit times for each subject.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_quant_r">quant_r</code></td>
<td>
<p>Quantiles of time from make_IC_dmats, to keep them constant through bootstrapping.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_seed">seed</code></td>
<td>
<p>Seed to start the bootstrapping.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_null_fit">null_fit</code></td>
<td>
<p>The null fit output from ICSKAT_fit_null.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_gmat">gMat</code></td>
<td>
<p>Genotype matrix used in original test.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_xmat">xMat</code></td>
<td>
<p>n*p matrix of non-genetic covariates.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_fitagain">fitAgain</code></td>
<td>
<p>Boolean, whether to fit the null model again in each bootstrap.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_checkpoint">checkpoint</code></td>
<td>
<p>Boolean, whether to print every time 100 bootstraps finish.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_downsample">downsample</code></td>
<td>
<p>A number in (0, 1], will use this fraction of the bootstrap iterations to try running the test with fewer bootstraps.</p>
</td></tr>
<tr><td><code id="ICSKATO_bootstrap_+3A_rhovec">rhoVec</code></td>
<td>
<p>Vector of rhos to search over in SKATO.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>kurtQvec</code></td>
<td>
<p>Vector of bootstrapped excess kurtosis of each Qrho.</p>
</td></tr>
<tr><td><code>varQvec</code></td>
<td>
<p>Vector of bootstrapped variance of each Qrho.</p>
</td></tr>
<tr><td><code>meanQvec</code></td>
<td>
<p>Vector of bootstrapped mean of each Qrho.</p>
</td></tr>
<tr><td><code>kurtKappa</code></td>
<td>
<p>Bootstrapped kurtosis of kappa term without zeta.</p>
</td></tr>
<tr><td><code>kurtKappaAll</code></td>
<td>
<p>Bootstrapped kurtosis of full kappa term with zeta.</p>
</td></tr>
<tr><td><code>varKappaAll</code></td>
<td>
<p>Bootstrapped variance of full kappa term with zeta.</p>
</td></tr>
<tr><td><code>meanKappaAll</code></td>
<td>
<p>Bootstrapped mean of full kappa term with zeta.</p>
</td></tr>
<tr><td><code>bootDF</code></td>
<td>
<p>Matrix with B rows containing all the bootstrapped quantities over all iterations.</p>
</td></tr>
<tr><td><code>QrhoBoot</code></td>
<td>
<p>Matrix with B rows containing all the bootstrapped Qrho values, one column for each rho.</p>
</td></tr>
<tr><td><code>listDS</code></td>
<td>
<p>A list containing all of the other elements in this return list, except using the downsampled iterations.</p>
</td></tr>
<tr><td><code>nonNA</code></td>
<td>
<p>Number of bootstraps that did not result in NA (and thus were not removed).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind,
lt = lt, rt = rt)
icskatOut &lt;- ICskat(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat,
lt = lt, rt = rt, obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat,
null_beta = nullFit$beta_fit, Itt = nullFit$Itt)
intervalProbOutput &lt;- construct_interval_probs(allTimes = outcomeDat$allVisits,
dmats = dmats, nullBeta = nullFit$beta_fit, p = ncol(xMat), nKnots=1)
ICSKATO_bootstrap(icskatOut = icSkatOut, B = 100, intervalProbs = intervalProbOutput$probMat,
allVisits = intervalProbOutput$allTimesFilled, quant_r = dmats$quant_r, seed = 0,
null_fit = nullFit, gMat = gMat, xMat, fitAgain = TRUE,
rhoVec=c(0, 0.01, 0.04, 0.09, 0.25, 0.5, 1))
</code></pre>

<hr>
<h2 id='ICskatPO'>ICSKATPO.R</h2><span id='topic+ICskatPO'></span>

<h3>Description</h3>

<p>Calculate the test statistic and p-value for interval-censored skat with PO model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICskatPO(
  left_dmat,
  right_dmat,
  lt,
  rt,
  obs_ind,
  tpos_ind,
  gMat,
  null_beta,
  Itt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICskatPO_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left side of interval times.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right side of interval times.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_gmat">gMat</code></td>
<td>
<p>n*q genotype matrix.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_null_beta">null_beta</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients for null model.</p>
</td></tr>
<tr><td><code id="ICskatPO_+3A_itt">Itt</code></td>
<td>
<p>(p+nknots+2)*(p+nknots+2) Fisher information matrix for null model coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>p_SKAT</code></td>
<td>
<p>ICSKAT p-value for PO model.</p>
</td></tr>
<tr><td><code>p_burden</code></td>
<td>
<p>IC burden test p-value for PO model.</p>
</td></tr>
<tr><td><code>complex</code></td>
<td>
<p>Indicator of whether the SKAT variance matrix was positive definite</p>
</td></tr>
<tr><td><code>sig_mat</code></td>
<td>
<p>The covariance matrix of the score equations for genetic effects when treated as fixed effects</p>
</td></tr>
<tr><td><code>skatQ</code></td>
<td>
<p>SKAT test statistic.</p>
</td></tr>
<tr><td><code>burdenQ</code></td>
<td>
<p>Burden test statistic.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>err=1 for a bad null fit.</p>
</td></tr>
<tr><td><code>errMsg</code></td>
<td>
<p>Describes the error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0.1, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)
ICskatPO(left_dmat = dmats$left_dmat, right_dmat=dmats$right_dmat, lt = lt, rt = rt,
obs_ind = obs_ind, tpos_ind = tpos_ind, gMat = gMat, null_beta = nullFit$beta_fit,
Itt = nullFit$Itt)

</code></pre>

<hr>
<h2 id='ICSKATwrapper'>ICSKATwrapper.R</h2><span id='topic+ICSKATwrapper'></span>

<h3>Description</h3>

<p>Wrapper to fit the null model and run ICSKAT all in one instead of separately - offers some functionality
for error checking or using different initial values when fit fails to converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSKATwrapper(
  left_dmat,
  right_dmat,
  initValues,
  lt,
  rt,
  obs_ind,
  tpos_ind,
  gMat,
  PH = TRUE,
  nKnots = 1,
  maxIter = 3,
  eps = 10^(-6),
  runOnce = FALSE,
  returnNull = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSKATwrapper_+3A_left_dmat">left_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_right_dmat">right_dmat</code></td>
<td>
<p>n*(p+nknots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_initvalues">initValues</code></td>
<td>
<p>(p+nknots+2)*1 vector of coefficients to initialize the Newton-Raphson.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_lt">lt</code></td>
<td>
<p>Left side of interval times.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_rt">rt</code></td>
<td>
<p>Right side of interval times.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_gmat">gMat</code></td>
<td>
<p>n*q matrix of genotypes.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_ph">PH</code></td>
<td>
<p>Boolean for whether to fit PH model (TRUE) or PO model (FALSE).</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_nknots">nKnots</code></td>
<td>
<p>Number of knots in the spline.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_maxiter">maxIter</code></td>
<td>
<p>Number of times to try the fit if initial values do not lead to convergence.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_eps">eps</code></td>
<td>
<p>Difference in L2 norm of fitted null coefficients that stops the Newton Raphson.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_runonce">runOnce</code></td>
<td>
<p>Boolean, if true then just go through the algorithm once with the initial
values for coefficients, updating the variance matrix, useful for bootstrapping.</p>
</td></tr>
<tr><td><code id="ICSKATwrapper_+3A_returnnull">returnNull</code></td>
<td>
<p>Return a list with the skat output and null model, or just return the skat output (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list with skatOutput and nullFit (two lists), or just skatOutput.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
gMat &lt;- matrix(data=rbinom(n=2000, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
ICSKATwrapper(left_dmat = dmats$left_dmat, right_dmat = dmats$right_dmat,
initValues = rep(0, ncol(xMat) + 3), lt = lt, rt = rt, obs_ind = obs_ind,
tpos_ind = tpos_ind, gMat = gMat, returnNull = TRUE)

</code></pre>

<hr>
<h2 id='make_IC_dmat'>make_IC_dmat.R</h2><span id='topic+make_IC_dmat'></span>

<h3>Description</h3>

<p>Puts together the entire design matrix for both the left and right ends of the
interval, pasting together the non-genetic covariates with the cubic spline basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind, quant_r = NULL, nKnots = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_IC_dmat_+3A_xmat">xMat</code></td>
<td>
<p>n*p matrix of non-genetic covariates.</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_lt">lt</code></td>
<td>
<p>n*1 vector with left end of intervals (min is 0).</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_rt">rt</code></td>
<td>
<p>n*1 vector with right end of intervals.</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed before last follow-up.</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed after follow-up started (t&gt;0).</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_quant_r">quant_r</code></td>
<td>
<p>Quantiles of time to use in constructing the spline, pass in if doing bootstrap.</p>
</td></tr>
<tr><td><code id="make_IC_dmat_+3A_nknots">nKnots</code></td>
<td>
<p>Number of knots to use for cubic spline basis (default is 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>right_dmat</code></td>
<td>
<p>n*(p+nKnots+2) design matrix for right end of interval.</p>
</td></tr>
<tr><td><code>left_dmat</code></td>
<td>
<p>n*(p+nKnots+2) design matrix for left end of interval.</p>
</td></tr>
<tr><td><code>quant_r</code></td>
<td>
<p>Quantiles used for constructing spline.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
make_IC_dmat(xMat = xMat, lt = lt, rt = rt, obs_ind = obs_ind, tpos_ind = tpos_ind)

</code></pre>

<hr>
<h2 id='matchVisit'>match_visit.R</h2><span id='topic+matchVisit'></span>

<h3>Description</h3>

<p>Match visit to a time for model-based bootstrap with interval-censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchVisit(draw, visitTimes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchVisit_+3A_draw">draw</code></td>
<td>
<p>(s+1)-length vector of all 0s except for one 1, which is the failure interval.</p>
</td></tr>
<tr><td><code id="matchVisit_+3A_visittimes">visitTimes</code></td>
<td>
<p>s-length vector where is the number of inspection times for a subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n*(s+1) matrix where element (i,j) holds the probability that subject i will fail in interval j.
</p>

<hr>
<h2 id='mixture_kurtosis'>mixture_kurtosis.R</h2><span id='topic+mixture_kurtosis'></span>

<h3>Description</h3>

<p>Calculate the kurtosis of Qrho when performing SKATO with bootstrapped moments. This function is
included to allow for the potential to match the SKAT package, however we generally don't call it
because we can just bootstrap the kurtosis of Qrho directly if we are already doing bootstrap,
thus avoiding this calculation. Also it's only used in calculating the qmin values, not in
the final p-value calculation, which uses a kappa expression that is only the first two terms of Qrho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture_kurtosis(tempDF1, tempDF2, v1, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_kurtosis_+3A_tempdf1">tempDF1</code></td>
<td>
<p>Generally the bootstrapped kurtosis of the mixture of chi-squares in kappa.</p>
</td></tr>
<tr><td><code id="mixture_kurtosis_+3A_tempdf2">tempDF2</code></td>
<td>
<p>Generally 1 because it's for the chi-square1 RV in kappa.</p>
</td></tr>
<tr><td><code id="mixture_kurtosis_+3A_v1">v1</code></td>
<td>
<p>Generally the variance of the mixture of chi-squares plus the variance of zeta in kappa.</p>
</td></tr>
<tr><td><code id="mixture_kurtosis_+3A_a1">a1</code></td>
<td>
<p>Generally the 1-rho in front of the first part of the kappa term.</p>
</td></tr>
<tr><td><code id="mixture_kurtosis_+3A_a2">a2</code></td>
<td>
<p>Generally the tau(rho) term in front of the chi-square1 RV in kappa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kurtosis (excess kurtosis to be more precise), use df = 12 / kurtosis.
</p>

<hr>
<h2 id='QrhoIC'>QrhoIC.R</h2><span id='topic+QrhoIC'></span>

<h3>Description</h3>

<p>Calculate the test statistic, distribution, and p-value for each value of Krho in SKATO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QrhoIC(
  rhoVec,
  icskatOut,
  liu = TRUE,
  bootstrapOut = NULL,
  alwaysCentral = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QrhoIC_+3A_rhovec">rhoVec</code></td>
<td>
<p>Numeric vector of the rho values to use in SKATO.</p>
</td></tr>
<tr><td><code id="QrhoIC_+3A_icskatout">icskatOut</code></td>
<td>
<p>The output list returned from  a call to ICSKAT().</p>
</td></tr>
<tr><td><code id="QrhoIC_+3A_liu">liu</code></td>
<td>
<p>Boolean for whether to use Liu (TRUE) or Davies (FALSE) method in calculating p-values for each Qrho.
Default is Liu, following SKAT package. If wanting to use bootstrap moments for Qrho, need to use Liu method.</p>
</td></tr>
<tr><td><code id="QrhoIC_+3A_bootstrapout">bootstrapOut</code></td>
<td>
<p>The output (a list) from a call the ICSKATO_bootstrap() function, holding moments for Qrho.</p>
</td></tr>
<tr><td><code id="QrhoIC_+3A_alwayscentral">alwaysCentral</code></td>
<td>
<p>A boolean, if TRUE, follow SKAT package practice of always setting delta=0 in chi-square moment matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame holding the SKAT pvalue + test statistic for each fixed rho, the matched noncentrality + degree of freedom parameters
for each fixed rho (using both bootstrap and analytic calculation), and the mean and variance of each Qrho using both
bootstrap and analytic calculation.
</p>

<hr>
<h2 id='singleSNPalt'>singleSNPalt.R</h2><span id='topic+singleSNPalt'></span>

<h3>Description</h3>

<p>Take a matrix of SNPs and get the interval-censored regression p-value for each one separately using either
survreg() or coxph() with midpoint approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleSNPalt(
  lt,
  rt,
  tpos_ind,
  obs_ind,
  xMat,
  gMat,
  coxph = TRUE,
  survreg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singleSNPalt_+3A_lt">lt</code></td>
<td>
<p>n*1 vector of left side of time interval.</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_rt">rt</code></td>
<td>
<p>n*1 vector of right side of time interval.</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_tpos_ind">tpos_ind</code></td>
<td>
<p>n*1 binary vector of whether the event was observed after follow-up started (takes value 1 if t&gt;0, 0 otherwise).</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_obs_ind">obs_ind</code></td>
<td>
<p>n*1 vector of whether the event was observed or right-censored (takes value 1 if observed or 0 if right-censored).</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_xmat">xMat</code></td>
<td>
<p>non-SNP covariates matrix.</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_gmat">gMat</code></td>
<td>
<p>n*q genotype matrix.</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_coxph">coxph</code></td>
<td>
<p>Boolean, whether to fit Cox PH model.</p>
</td></tr>
<tr><td><code id="singleSNPalt_+3A_survreg">survreg</code></td>
<td>
<p>Boolean, whether to fit survreg() Wiibull model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements:
</p>
<table>
<tr><td><code>pvalCox</code></td>
<td>
<p>q*1 vector of marginal SNP p-values with Cox model</p>
</td></tr>
<tr><td><code>pvalSurv</code></td>
<td>
<p>q*1 vector of marginal SNP p-values with survreg Weibull model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
gMat &lt;- matrix(data=rbinom(n=200, size=2, prob=0.3), nrow=100)
xMat &lt;- matrix(data=rnorm(200), nrow=100)
bhFunInv &lt;- function(x) {x}
obsTimes &lt;- 1:5
etaVec &lt;- rep(0, 100)
outcomeDat &lt;- gen_IC_data(bhFunInv = bhFunInv, obsTimes = obsTimes, windowHalf = 0.1,
probMiss = 0.1, etaVec = etaVec)
lt &lt;- outcomeDat$leftTimes
rt &lt;- outcomeDat$rightTimes
tpos_ind &lt;- as.numeric(lt &gt; 0)
obs_ind &lt;- as.numeric(rt != Inf)
dmats &lt;- make_IC_dmat(xMat, lt, rt, obs_ind, tpos_ind)
nullFit &lt;- ICSKAT_fit_null(init_beta = rep(0, 5), left_dmat = dmats$left_dmat,
right_dmat=dmats$right_dmat, obs_ind = obs_ind, tpos_ind = tpos_ind, lt = lt, rt = rt)
singleSNPalt(lt = lt, rt = rt,tpos_ind = tpos_ind, obs_ind = obs_ind, xMat = xMat, gMat = gMat)

</code></pre>

<hr>
<h2 id='survregFn'>survregFn</h2><span id='topic+survregFn'></span>

<h3>Description</h3>

<p>Function to be applied over gMat to get p-values from survreg().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survregFn(x, xMat, leftTime2, rightTime2, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survregFn_+3A_x">x</code></td>
<td>
<p>n*1 genotype vector.</p>
</td></tr>
<tr><td><code id="survregFn_+3A_xmat">xMat</code></td>
<td>
<p>n*p matrix of non-genotype covariates.</p>
</td></tr>
<tr><td><code id="survregFn_+3A_lefttime2">leftTime2</code></td>
<td>
<p>n*1 vector of left interval times in the format of Surv() interval2 type, i.e NA for left or right censored observations.</p>
</td></tr>
<tr><td><code id="survregFn_+3A_righttime2">rightTime2</code></td>
<td>
<p>n*1 vector of right interval times in the format of Surv() interval2 type, i.e NA for left or right censored observations.</p>
</td></tr>
<tr><td><code id="survregFn_+3A_p">p</code></td>
<td>
<p>scalar, number of columns in xMat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar p-value for testing the effect of the genotype in survreg() Weibull model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
