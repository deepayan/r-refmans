<!DOCTYPE html><html><head><title>Help for package plgraphics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plgraphics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asinp'><p>arc sine Transformation</p></a></li>
<li><a href='#charSize'>
<p>Adjust character size to number of observations</p></a></li>
<li><a href='#clipat'><p>Clip Data Outside a Range</p></a></li>
<li><a href='#colorpale'><p>determine more pale colors for given colors</p></a></li>
<li><a href='#colors'><p>colors used by plgraphics</p></a></li>
<li><a href='#condquant'><p>Quantiles of a Conditional Distribution</p></a></li>
<li><a href='#d.babysurvival'><p>Survival of Premature Infants</p></a></li>
<li><a href='#d.birthrates'><p>Birthrates in Swiss Districts</p></a></li>
<li><a href='#d.blast'><p>Blasting for a tunnel</p></a></li>
<li><a href='#d.fossileShapes'><p>Coccolith Abundance and Environmental Variables</p></a></li>
<li><a href='#d.pollZH16'>
<p>Air Pollution Monitoring in Zurich</p></a></li>
<li><a href='#d.river'><p>Chemical Compounds in a Swiss River, Time Series</p></a></li>
<li><a href='#deparseCond'><p>Analyze formula with conditional variables</p></a></li>
<li><a href='#doc'><p> Define and obtain the doc or tit attribute</p></a></li>
<li><a href='#dropdata'><p>Drop Observations from a Data.frame</p></a></li>
<li><a href='#dropNA'><p>drop or replace NA values</p></a></li>
<li><a href='#fitcomp'><p>Component Effects for a Model Fit</p></a></li>
<li><a href='#gendateaxis'><p>Generate a variable expressing time with its attributes for plotting</p></a></li>
<li><a href='#gensmooth'><p>Smooth: wrapper function</p></a></li>
<li><a href='#genvarattributes'><p>Generate or Set Variable Attributes for Plotting</p></a></li>
<li><a href='#getmeth'><p>get S3 method of a generic function</p></a></li>
<li><a href='#getvariables'><p>Extract Variables or Variable Names</p></a></li>
<li><a href='#legendr'><p>Add a Legend to a Plot</p></a></li>
<li><a href='#leverage'><p>Get leverage values</p></a></li>
<li><a href='#linear.predictors'><p>linear predictors from a (generalized) linear model</p></a></li>
<li><a href='#logst'><p>Started Logarithmic Transformation</p></a></li>
<li><a href='#markextremes'>
<p>Adjust the default proportion of extreme points to be labeled to the number</p>
of observations</a></li>
<li><a href='#modarg'>
<p>Modify default arguments according to a named vector or list</p></a></li>
<li><a href='#months'><p>strings for month and weekday names</p></a></li>
<li><a href='#nainf.exclude'><p>Drop Rows Containing NA or Inf</p></a></li>
<li><a href='#notice'><p>Generate a Notice</p></a></li>
<li><a href='#pl.control'><p>Arguments for plotting functions</p></a></li>
<li><a href='#pl.envir'><p>Environment Containing Information for Generating Pl Graphics</p></a></li>
<li><a href='#plbars'><p>Add bars to a pl plot</p></a></li>
<li><a href='#plcond'><p>Plot Two Variables Conditional on Two Others</p></a></li>
<li><a href='#plcoord'><p> Determines Values for Plotting with Limited &quot;Inner&quot; Plot Range</p></a></li>
<li><a href='#plframe'><p>Low level plotting functions for the 'pl' system</p></a></li>
<li><a href='#plgraphics-internal'><p>Internal 'plgraphics' Objects</p></a></li>
<li><a href='#plinnerrange'><p>Inner Plotting Limits</p></a></li>
<li><a href='#pllimits'><p>Determine Inner Plot Range</p></a></li>
<li><a href='#plmarginpar'><p>Set Graphical Parameters According to Those used in the Pl</p>
Function Called Last</a></li>
<li><a href='#plmark'><p>Labels for Extreme Points</p></a></li>
<li><a href='#plmatrix'><p>Scatterplot Matrix</p></a></li>
<li><a href='#plmboxes'>
<p>Multibox plots</p></a></li>
<li><a href='#plmframes'><p>Multiple Frames for Plotting</p></a></li>
<li><a href='#ploptions'><p>Set and Get User &quot;Session&quot; Options that Influence &quot;plgraphics&quot;s Behavior</p></a></li>
<li><a href='#ploptions.list'><p>The List of pl Options</p></a></li>
<li><a href='#plpanel'><p>Panel function for multiple plots</p></a></li>
<li><a href='#plpoints'><p>Plot Points and Lines in the 'pl' system</p></a></li>
<li><a href='#plregr'><p>Diagnostic Plots for Regr Objects</p></a></li>
<li><a href='#plregr.control'>
<p>Further Arguments to <code>plregr</code></p></a></li>
<li><a href='#plres2x'><p>Plot Residuals vs. Two Explanatory Variables</p></a></li>
<li><a href='#plscale'><p>Generate Plscaled Plotting Scale</p></a></li>
<li><a href='#plsmooth'><p>Smooth and Reference Line Plotting</p></a></li>
<li><a href='#plsubset'><p>Subsetting a Data.Frame with pl Attributes</p></a></li>
<li><a href='#plticks'><p>Ticks for plotting</p></a></li>
<li><a href='#plyx'><p>Scatterplot, enhanced</p></a></li>
<li><a href='#predict.regrpolr'><p>Predict and Fitted for polr Models</p></a></li>
<li><a href='#prettyscale'><p>Pretty Tickmark Locations for Transformed Scales</p></a></li>
<li><a href='#prevgumbel'><p>&quot;Reverse&quot; Gumbel Distribution Functions</p></a></li>
<li><a href='#quantilew'><p>Quantiles for weighted observations</p>
</p></a></li>
<li><a href='#quinterpol'><p>Interpolated Quantiles</p></a></li>
<li><a href='#residuals.regrpolr'><p>Residuals of a Binary, Ordered, or Censored Regression</p></a></li>
<li><a href='#robrange'><p> Robust Range of Data</p></a></li>
<li><a href='#shortenstring'><p>Shorten Strings</p></a></li>
<li><a href='#showd'><p>Show a Part of a Data.frame</p></a></li>
<li><a href='#simresiduals'><p>Simulate Residuals</p></a></li>
<li><a href='#smoothpar'>
<p>Adjust the smoothing parameter to number of observations</p></a></li>
<li><a href='#smoothRegr'><p>Smoothing function used as a default in plgraphics /</p>
straight line &quot;smoother&quot;</a></li>
<li><a href='#smoothxtrim'>
<p>Adjust range for smooth lines to number of observations</p></a></li>
<li><a href='#stamp'><p> Add a &quot;Stamp&quot;, i.e., an Identification Line to a Plot</p></a></li>
<li><a href='#stdresiduals'><p>Get Standardized Residuals</p></a></li>
<li><a href='#sumNA'><p>Count NAs</p></a></li>
<li><a href='#Tobit'><p>Prepare a Response for a Tobit Model</p></a></li>
<li><a href='#transferAttributes'><p>Transfer Attributes</p></a></li>
<li><a href='#warn'><p>List Warnings</p></a></li>
<li><a href='#weekday'><p>Get Day of Week or Year, Month, Day</p></a></li>
<li><a href='#xdistResdiff'><p>Residual Differences for Near Replicates: Tabulate and Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>User Oriented Plotting Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices, chron, survival, MASS, lme4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Plots with high flexibility and easy handling, including
  informative regression diagnostics for many models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-29 09:04:52 UTC; stahel</td>
</tr>
<tr>
<td>Author:</td>
<td>Werner A. Stahel [aut, cre],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Werner A. Stahel &lt;stahel@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-29 13:42:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='asinp'>arc sine Transformation</h2><span id='topic+asinp'></span>

<h3>Description</h3>

<p>Calculates the sqrt arc sine of x/100, rescaled to be in the unit
interval.<br />
This transformation is useful for analyzing percentages or proportions
of any kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asinp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asinp_+3A_x">x</code></td>
<td>
<p>vector of data values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of transformed values</p>


<h3>Note</h3>

<p>This very simple function is provided in order to simplify
formulas. It has an attribute <code>"inverse"</code> that contains
the inverse function, see example.  
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>asinp(seq(0,100,10))
( y &lt;- asinp(c(1,50,90,95,99)) )
attr(asinp, "inverse")(y)
</code></pre>

<hr>
<h2 id='charSize'>
Adjust character size to number of observations
</h2><span id='topic+charSize'></span>

<h3>Description</h3>

<p>Adjusts the character size <code>cex</code> to number of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charSize(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charSize_+3A_n">n</code></td>
<td>
<p>number of observations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply applies <code>min(1.5/log10(n), 2)</code>
</p>


<h3>Value</h3>

<p>A scalar, defining <code>cex</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charSize(20)
for (n in c(10,20,50,100,1000))  print(c(n,charSize(n)))
</code></pre>

<hr>
<h2 id='clipat'>Clip Data Outside a Range
</h2><span id='topic+clipat'></span>

<h3>Description</h3>

<p>Drop values outside a given range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipat(x, range=NULL, clipped=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipat_+3A_x">x</code></td>
<td>
<p>vector of data to be clipped at <code>range</code>
</p>
</td></tr>
<tr><td><code id="clipat_+3A_range">range</code></td>
<td>
<p>range, a numerical vector of 2 elements
</p>
</td></tr>
<tr><td><code id="clipat_+3A_clipped">clipped</code></td>
<td>
<p>if <code>NULL</code>, the clipped data will be dropped.
Otherwise, they will be replaced by <code>clipped</code>, which is
typically set to <code>NA</code>.
If <code>clipped</code> is numerical of length 2, the elements of
<code>x</code> clipped below are set to <code>clipped[1]</code>,
those clipped by <code>range[2]</code>, by <code>clipped[2]</code>.
Therefore, if <code>clipped</code> equals <code>range</code>,
<code>x</code> will be &quot;Winsorized&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As the input <code>x</code>, with pertinent elements dropped or replaced 
</p>


<h3>Author(s)</h3>

<p>Werner A, Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clipat(rnorm(10,8,2), c(10,20), clipped=NA)
</code></pre>

<hr>
<h2 id='colorpale'>determine more pale colors for given colors
</h2><span id='topic+colorpale'></span>

<h3>Description</h3>

<p>Finds colors that are &lsquo;equivalent&rsquo; to the colors given as the first
argument, but more pale or less pale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorpale(col = NA, pale = NULL, rgb = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorpale_+3A_col">col</code></td>
<td>

<p>a color or a vector of colors for which the pale version should be found
</p>
</td></tr>
<tr><td><code id="colorpale_+3A_pale">pale</code></td>
<td>

<p>number between -1 and 1 determining how much paler the result should
be. If <code>=0</code>, the original color, <code>col</code> will be returned
unchanged (but in the 'rgb' or 'hexadecimal' form). If <code>=1</code> or
<code>-1</code>,     the result is white (<code>#FFFFFF</code>) or black, respectively. 
</p>
</td></tr>
<tr><td><code id="colorpale_+3A_rgb">rgb</code></td>
<td>
<p>should result be expressed in 'rgb' form? If <code>FALSE</code>,
it will be in hexadecimal form.
</p>
</td></tr>
<tr><td><code id="colorpale_+3A_...">...</code></td>
<td>

<p>further arguments passed on to <code><a href="grDevices.html#topic+rgb">rgb</a></code>
if <code>rgb</code> is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function increases rgb coordinates of colors &lsquo;proportionally&rsquo;:
crgb &lt;- t(col2rgb(col)/255);
rgb(1 - pale * (1 - crgb))
</p>


<h3>Value</h3>

<p>character vector: names of colors to be used as color argument
for graphical functions.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rgb">rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( t.col &lt;- colorpale(c("red","blue")) )
plot(0:6, type="h", col=c("black","red","blue",t.col, colorpale(t.col)), lwd=5)
</code></pre>

<hr>
<h2 id='colors'>colors used by plgraphics</h2><span id='topic+c.colors'></span>

<h3>Description</h3>

<p>Vectors of color names to be used, mainly for distinguishing groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c.colors
</code></pre>


<h3>Arguments</h3>

<p>none
</p>


<h3>Value</h3>

<p>vector of color names
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>c.colors
</code></pre>

<hr>
<h2 id='condquant'>Quantiles of a Conditional Distribution</h2><span id='topic+condquant'></span>

<h3>Description</h3>

<p>Calculates quantiles of a conditional distribution, as well
as corresponding random numbers.  The condtion is simply to restrict
the distribution (given by <code>dist</code>) to a range (given by
<code>x</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condquant(x, dist = "normal", mu = 0, sigma = 1, randomrange = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condquant_+3A_x">x</code></td>
<td>
<p>matrix with 2 columns or vector of length 2 giving the
limits for the conditional distribution</p>
</td></tr>
<tr><td><code id="condquant_+3A_dist">dist</code></td>
<td>
<p>(unconditional) distribution. Currently, only
<code>normal</code> (or <code>gaussian</code>),
<code>logistic</code> and <code>revgumbel</code> (reverse-Gumbel,
distribution of the logarithm of a Weibull variable) are implemented.
</p>
</td></tr>
<tr><td><code id="condquant_+3A_mu">mu</code>, <code id="condquant_+3A_sigma">sigma</code></td>
<td>
<p>locarion and scale parameter of the distribution
</p>
</td></tr>
<tr><td><code id="condquant_+3A_randomrange">randomrange</code></td>
<td>
<p>random numbers from the conditional distribution
are drawn for the inner <code>100*randomrange</code> percent of the
suitable p-range. This avoids random extreme outliers and points
close to the limit of the intervals on which they are conditioned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix consisting of a row for each row of <code>x</code> for which
x[,1] differs from x[,2] and the following columns:
</p>
<table>
<tr><td><code>median</code></td>
<td>
<p>Median</p>
</td></tr>
<tr><td><code>lowq</code>, <code>uppq</code></td>
<td>
<p>lower and upper quartiles</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>random number according to the conditional distribution
(one for each row)</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>probability of the condition being true</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>(row) index of the corresponding entry in the input 'x'</p>
</td></tr>
</table>
<p>Attribute <code>distribution</code> comprises the arguments
<code>dist, mu, sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, Seminar for Statistics, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>condquant(cbind(seq(-2,1),c(0,1,Inf,1)))
</code></pre>

<hr>
<h2 id='d.babysurvival'>Survival of Premature Infants</h2><span id='topic+d.babysurvival'></span><span id='topic+d.babysurvGr'></span>

<h3>Description</h3>

<p>Survival of Premature Infants to be modeled
using 5 potential explanatory variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data("d.babysurvival")
  data("d.babysurvGr")
</code></pre>


<h3>Format</h3>

<p><code>d.babysurvival</code>: 
A data frame with 246 observations on the following 6 variables.
</p>

<dl>
<dt><code>Survival</code></dt><dd><p>binary, 1 means the infant survived</p>
</dd>
<dt><code>Weight</code></dt><dd><p>birth weight [g]</p>
</dd>
<dt><code>Age</code></dt><dd><p>pregnancy in weeks</p>
</dd>
<dt><code>Apgar1</code></dt><dd><p>A score indication the fitness of the infant at
birth, scores 0 to 9</p>
</dd>
<dt><code>Apgar5</code></dt><dd><p>alternative score</p>
</dd>
<dt><code>pH</code></dt><dd><p>blood pH</p>
</dd>
</dl>

<p><code>d.babysurvGr</code>: 
Grouped data: Number of Infants that died and survived for each class
of birth weight.
</p>

<dl>
<dt><code>n</code></dt><dd><p>Number of infants in the weight class</p>
</dd>
<dt><code>Survival.0, Survivl.1</code></dt><dd><p>Number of infants that died and
survived, respectively</p>
</dd>
<dt><code>Weight</code></dt><dd><p>birth weight</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hibbard (1986)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.babysurvival)
summary(d.babysurvival)
rr &lt;- glm(Survival~Weight+Age+Apgar1, data=d.babysurvival, family="binomial")
plregr(rr, xvar= ~Age+Apgar1)
</code></pre>

<hr>
<h2 id='d.birthrates'>Birthrates in Swiss Districts</h2><span id='topic+d.birthrates'></span><span id='topic+d.birthratesVars'></span>

<h3>Description</h3>

<p>Standardized fertility measure and socio-economic indicators for
each of 182 districts of Switzerland at about 1888.
This is an extended version of the <code>swiss</code> dataset of standard R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data("d.birthrates")
  data("d.birthratesVars")
</code></pre>


<h3>Format</h3>

<p><code>d.birthrates</code>:
A data frame with 182 observations on the following 25 variables.
</p>

<dl>
<dt><code>fertility</code></dt><dd><p>Common standardizedfertility measure, see details</p>
</dd>
<dt><code>fertTotal</code></dt><dd><p>Alternative fertility measure</p>
</dd>
<dt><code>infantMort</code></dt><dd><p>Infant mortality</p>
</dd>
<dt><code>catholic</code></dt><dd><p>percentage of members of the catholic church</p>
</dd>
<dt><code>single24</code></dt><dd><p>percentage of women aged 20-24 who are single</p>
</dd>
<dt><code>single49</code></dt><dd><p>percentage of women aged 45-49 who are single</p>
</dd>
<dt><code>eAgric</code></dt><dd><p>Proportion male labor force in agriculture</p>
</dd>
<dt><code>eIndustry</code></dt><dd><p>Proportion male labor force in industry</p>
</dd>
<dt><code>eCommerce</code></dt><dd><p>Proportion male labor force in trade</p>
</dd>
<dt><code>eTransport</code></dt><dd><p>Proportion male labor force in transportation</p>
</dd>
<dt><code>eAdmin</code></dt><dd><p>Proportion male labor force in public service</p>
</dd>
<dt><code>german</code></dt><dd><p>percentage of German</p>
</dd>
<dt><code>french</code></dt><dd><p>percentage of French</p>
</dd>
<dt><code>italian</code></dt><dd><p>percentage of Italian</p>
</dd>
<dt><code>romansh</code></dt><dd><p>percentage of Romansh</p>
</dd>
<dt><code>gradeHigh</code></dt><dd><p>Prop. high grade in draftees exam</p>
</dd>
<dt><code>gradeLow</code></dt><dd><p>Propr. low grade in draftees exma</p>
</dd>
<dt><code>educHigh</code></dt><dd><p>Prop. draftees with &gt; primary educ.</p>
</dd>
<dt><code>bornLocal</code></dt><dd><p>Proportion living in commune of birth</p>
</dd>
<dt><code>bornForeign</code></dt><dd><p>Proportion born in foreign country</p>
</dd>
<dt><code>sexratio</code></dt><dd><p>Sex ratio (M/F)</p>
</dd>
<dt><code>canton</code></dt><dd><p>Canton Name</p>
</dd>
<dt><code>district</code></dt><dd><p>District Name</p>
</dd>
<dt><code>altitude</code></dt><dd><p>altitude in three categories: low, medium, high</p>
</dd>
<dt><code>language</code></dt><dd><p>dominating language: german, french, italian,
romansh</p>
</dd>
</dl>

<p><code>d.birthratesVars</code>:
Data.frame that contains the descriptions of the variables just read.
</p>


<h3>Details</h3>

<p><code>?swiss</code> says:<br />
(paraphrasing Mosteller and Tukey):<br />
Switzerland, in 1888, was entering a period known as the
'demographic transition'; i.e., its fertility was beginning to
fall from the high level typical of underdeveloped countries.<br />
</p>
<p>The exact definition of fertility is as follows.<br />
fertility = 100 * B_l/ sum m_i f_i, where <br />
B_l = annual legitimate births,
m_i = the number of married women in age interval i,
and f_i = the fertility Hutterite women in the same age interval.<br />
&quot;Hutterite women&quot; are women in a population that is known to be extremely
fertile.<br />  
Stillbirths are included.
</p>


<h3>Source</h3>

<p>https://opr.princeton.edu/archive/pefp/switz.aspx
</p>


<h3>References</h3>

<p>see source
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.birthrates)
## maybe str(d.birthrates) ; plot(d.birthrates) ...
</code></pre>

<hr>
<h2 id='d.blast'>Blasting for a tunnel</h2><span id='topic+d.blast'></span>

<h3>Description</h3>

<p>Blasting causes tremor in buildings, which can lead to
damages. This dataset shows the relation between tremor and
distance and charge of blasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("d.blast")</code></pre>


<h3>Format</h3>

<p>A data frame with 388 observations on the following 7 variables.
</p>

<dl>
<dt><code>no</code></dt><dd><p>Identification of the date and time</p>
</dd>
<dt><code>date</code></dt><dd><p>Date in Date format. (The day and month are correct, the year is
a wild guess.)</p>
</dd>
<dt><code>datetime</code></dt><dd><p>Date and time in the format '%d.%m. %H:%M'</p>
</dd>
<dt><code>device</code></dt><dd><p>Number of measuring device, 1 to 4</p>
</dd>
<dt><code>charge</code></dt><dd><p>Charge of blast</p>
</dd>
<dt><code>distance</code></dt><dd><p>Distance between blasting and location
of measurement</p>
</dd>
<dt><code>tremor</code></dt><dd><p>Tremor energy (target variable)</p>
</dd>
<dt><code>location</code></dt><dd><p>Code for location of the building,
<code>loc1</code> to <code>loc8</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The charge of the blasting should be controled in order to
avoid tremors that exceed a threshold.
This dataset can be used to establish the suitable rule:
For a given <code>distance</code>, how large can <code>charge</code> be in order
to avoid exceedance of the threshold?
</p>


<h3>Source</h3>

<p>Basler and Hoffmann AG, Zurich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
showd(d.blast)

plyx(tremor~distance, psize=charge, data=d.blast)

rr &lt;-  lm(logst(tremor)~location+log10(distance)+log10(charge), data=d.blast)
plregr(rr)

t.date &lt;- as.POSIXlt(paste("1999",d.blast$datetime,sep="."),
                     format='%Y.%d.%m. %H:%M')

</code></pre>

<hr>
<h2 id='d.fossileShapes'>Coccolith Abundance and Environmental Variables
</h2><span id='topic+d.fossileShapes'></span><span id='topic+d.fossileSamples'></span>

<h3>Description</h3>

<p>The abundance of cocolith shells can be used to infer
environmental conditions in epochs corresponding to earlier epochs.
This data set contains the core location, the relative abundance of
Gephyrocapsa morphotypes and the sea surface temperatures from all
deep see cores used in this study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("d.fossileShapes")
data("d.fossileSamples")</code></pre>


<h3>Format</h3>

<p><code>d.fossilShapes</code>:
A data frame with 5864 observations on the following 15
variables:<br />
Identification and location of the sample:
</p>

<dl>
<dt><code>Sample</code></dt><dd><p>Identification number of the sample</p>
</dd>
<dt><code>Sname</code></dt><dd><p>Identification code</p>
</dd>
<dt><code>Magnification</code></dt><dd><p>(technical)</p>
</dd>
</dl>

<p>Shape features and recommended transformations:
</p>

<dl>
<dt><code>Angle</code></dt><dd><p>bridge angle</p>
</dd>
<dt><code>Length, Width</code></dt><dd><p>lengtha and width of the shell</p>
</dd>
<dt><code>CLength, CWidth</code></dt><dd><p>length and width of the 'central area'</p>
</dd>
<dt><code>Cratio</code></dt><dd><p>ratio between width and length of the central area</p>
</dd>
<dt><code>sAngle</code></dt><dd><p>sqrt of <code>Angle</code></p>
</dd>
<dt><code>lLength</code></dt><dd><p><code>log10(Length)</code></p>
</dd>
<dt><code>rWidth, rCLength, rCWidth</code></dt><dd><p>relative measures,
percentage of <code>Length</code></p>
</dd>
<dt><code>Cratio</code></dt><dd><p><code>CWidth/Clength</code></p>
</dd>
<dt><code>ShapeClass</code></dt><dd><p>shape class as defined in the cited paper,
classes ar
<code>CM</code> &lt; <code>CC</code> &lt; <code>CT</code> &lt; <code>CO</code> &lt; <code>CE</code> &lt; <code>CL</code></p>
</dd>
</dl>

<p><code>d.fossilSamples</code>:
A data frame with 108 observations on the following 32
variables:<br />
Identification and location:
</p>

<dl>
<dt><code>Sample</code></dt><dd><p>Identification number of the sample (as above)</p>
</dd>
<dt><code>Sname</code></dt><dd><p>Identification code</p>
</dd>
<dt><code>Latitude, Longitude</code></dt><dd><p>Coordinates of the location</p>
</dd>
<dt><code>Region</code></dt><dd><p>Ocean: <code>Pacific, Atlantic, Indian.Ocean</code></p>
</dd>
<dt><code>SDepth</code></dt><dd><p>sample depth below soil surface [cm]</p>
</dd>
<dt><code>WDepth</code></dt><dd><p>Water depth [m]</p>
</dd>
<dt><code>N</code></dt><dd><p>number of specimen measured</p>
</dd>
</dl>

<p>Shape features as above, averaged.
(This is the reason for introducing transformed variables above:
The transformed values are averaged.)<br />
</p>

<dl>
<dt><code>CM, CC, CT, CO, CE, CL</code></dt><dd><p>percentages of shape classes
in the sample</p>
</dd>
</dl>

<p>Environment:
</p>

<dl>
<dt><code>SST</code></dt><dd><p>Sea Surface Temperature, mean, [deg C]</p>
</dd>
<dt><code>SST.Spring</code>, <code>SST.Summer</code>, <code>SST.Fall</code>,
<code>SST.Winter</code></dt><dd><p>... in each season</p>
</dd>
<dt><code>Chlorophyll, lChlorophyll</code></dt><dd><p>Chlorophyll content
[microgram/L] and <code>log10</code> of it</p>
</dd>
<dt><code>Salinity</code></dt><dd><p>Salinity of the sea water</p>
</dd>
</dl>



<h3>Details</h3>

<p>The paradigm of research associated with this dataset is the
following:
Datasets of this kind are used to establish the relationship
between the shell shapes of cocoliths (species Gephyrocapsa)
from the most recent sediment
layer with actual environmental conditions. This relationship is then
used to infer environmental conditions of earlier epochs from
the shell shapes from the corresponding layers.
</p>
<p>The analysis presented in the paper cited below consisted of first
introducing classes of shells based on the shapes and then use the
relative abundance of the classes to predict the environmental
conditions. 
</p>


<h3>Source</h3>

<p>J\&quot;org Bollmann, Jorijntje Henderiks and Bernhard Brabec (2002).
Global calibration of Gephyrocapsa coccolith abundance in Holocene
sediments for paleotemperature assessment.
Paleoceanography, 17(3), 1035
</p>


<h3>References</h3>

<p>J\&quot;org Bollmann (1997).
Morphology and biogeography of Gephyrocapsa coccoliths in Holocene
sediments.
Marine Micropaleontology, 29, 319-350
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.fossileShapes)
names(d.fossileShapes)

data(d.fossileSamples)
plyx(sqrt(Angle) ~ SST, data=d.fossileSamples)

</code></pre>

<hr>
<h2 id='d.pollZH16'>
Air Pollution Monitoring in Zurich
</h2><span id='topic+d.pollZH16'></span><span id='topic+d.pollZH16d'></span>

<h3>Description</h3>

<p>Hourly air pollution measurements from a station in the city center of
Zurich, in a courtyard, for the whole year 2016, resulting in
8784 measurements of the two pollution variables
ozone and nitrogen dioxyde, the three weather variables
temperature, radiation and precipitation, and 8 variables
characterizing the date.
</p>
<p><code>pollZH16d</code>  is the subset of measurements for <code>hour=15</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("d.pollZH16")</code></pre>


<h3>Format</h3>

<p>A data frame with 8784 observations on the following 13 variables.
</p>

<dl>
<dt><code>date</code></dt><dd><p>date of the measurement</p>
</dd>
<dt><code>hour</code></dt><dd><p>hour of the measurement</p>
</dd>
<dt><code>O3</code></dt><dd><p>Ozone</p>
</dd>
<dt><code>NO2</code></dt><dd><p>Nitroge dioxyde</p>
</dd>
<dt><code>temp</code></dt><dd><p>temperature</p>
</dd>
<dt><code>rad</code></dt><dd><p>solar radiation</p>
</dd>
<dt><code>prec</code></dt><dd><p>precipitation</p>
</dd>
<dt><code>dateshort</code></dt><dd><p>two letter identification of the day.
A-L encodes the month;  1-9, a-x encodes the day within month.</p>
</dd>
<dt><code>weekday</code></dt><dd><p>day of the week</p>
</dd>
<dt><code>month</code></dt><dd><p>month</p>
</dd>
<dt><code>sumhalf</code></dt><dd><p>indicator for summer half year (April to Sept)</p>
</dd>
<dt><code>sunday</code></dt><dd><p>logical: indicator for Sunday</p>
</dd>
<dt><code>daytype</code></dt><dd><p>a factor with levels  <code>work</code> for working
day, <code>Sat</code> and <code>Sun</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>Legal threshold for NO2 in the EU:
The threshold of 200 micrograms/m3 must not be exceeded by
more than 18 hourly measurements per year.<br />
Source: Umweltbundesamt, Germany
http://www.umweltbundesamt.de/daten/luftbelastung/stickstoffdioxid-belastung#textpart-2
</p>


<h3>Source</h3>

<p>Bundesamt fur Umwelt (BAFU), Schw. Eidgenossenschaft
https://www.bafu.admin.ch/bafu/de/home/themen/luft/zustand/daten/datenabfrage-nabel.html<br />
The data set has been generated by downloading the files
for the individual variables,
converting the entries with <code>hour==24</code> to <code>hour==0</code> of the
following day and restricting the data to year 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.pollZH16)
dp &lt;- d.pollZH16
names(dp)

dp$date &lt;- gendateaxis(date=dp$date, hour=dp$hour)

plyx(O3+NO2~date, data=dp, subset= month=="May", type="l")

dp$summer &lt;- dp$month %in% c("Jun","Jul","Aug") 
dp$daylight &lt;- dp$hour&gt;8 &amp; dp$hour&lt;17
plmatrix(O3~temp+logst(rad)+logst(prec), data=dp, 
         subset = summer &amp; daylight)
</code></pre>

<hr>
<h2 id='d.river'>Chemical Compounds in a Swiss River, Time Series</h2><span id='topic+d.river'></span>

<h3>Description</h3>

<p>This time series of chemical concentrations can be used
to research the activities of photosynthesis and respiration
in a river.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("d.river")</code></pre>


<h3>Format</h3>

<p>A time series with 9792 observations (10 minutes interval)
on the following 12 variables.
</p>

<dl>
<dt><code>date</code></dt><dd><p>Date of the observation, class <code>Date</code></p>
</dd>
<dt><code>hour</code></dt><dd><p>Hour</p>
</dd>
<dt><code>pH</code></dt><dd><p>pH</p>
</dd>
<dt><code>O2</code></dt><dd><p>concentration of Oxygen</p>
</dd>
<dt><code>O2S</code></dt><dd><p>Oxygen saturation value</p>
</dd>
<dt><code>T</code></dt><dd><p>Temperature [deg C]</p>
</dd>
<dt><code>H2CO3</code></dt><dd><p>Carbon dioxide concentration in the water</p>
</dd>
<dt><code>CO2atm</code></dt><dd><p>Carbon dioxide concentration in the atmosphere</p>
</dd>
<dt><code>Q</code></dt><dd><p>flow</p>
</dd>
<dt><code>su</code></dt><dd><p>sunshine</p>
</dd>
<dt><code>pr</code></dt><dd><p>precipitation</p>
</dd>
<dt><code>ra</code></dt><dd><p>radiation</p>
</dd>
</dl>



<h3>Note</h3>

<p>This is not a time series in the sense of <code>ts</code> of R.
The date-time information is contained in the variables <code>date</code> and
<code>hour</code>.
</p>


<h3>Source</h3>

<p>The measurements have been collected in the river Glatt near Zurich.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.river)
range(d.river$date)
t.i &lt;- d.river$date &lt; as.Date("2010-03-31")

plyx(~date, ~O2, data=d.river, subset=t.i &amp; hour==14, smooth=FALSE)

d.river$Date &lt;- gendateaxis(d.river$date, hour=d.river$hour)
plyx(O2~Date, data=d.river, subset=t.i, type="l")

plyx(O2+T+ra~Date, data=d.river, subset=t.i &amp; hour==14, 
  smooth.par=0.5, smooth.xtrim=0.03, ycol=c(O2="blue",ra="red"))
</code></pre>

<hr>
<h2 id='deparseCond'>Analyze formula with conditional variables
</h2><span id='topic+deparseCond'></span>

<h3>Description</h3>

<p>Check if <code>formula</code> is valid and, if it contains a
<code>|</code> character, idenitfy regressors and conditional variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparseCond(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deparseCond_+3A_formula">formula</code></td>
<td>
<p>A model formula, possibly containing a <code>|</code>
character that introduces terms describing conditions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the formula with the following attributes:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>&quot;vertical&quot; (response) variable(s)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>&quot;horizontal&quot; (regressor) variable(s)</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>(first) conditional variable, if any</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>second conditional variable, if any</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>This function is typically used for conditional plots
and mixed models
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  deparseCond(yy ~ xx)
  deparseCond(yy ~ xx | aa + bb)
  deparseCond(y1 + y2 ~ x1 + log(x2) | sqrt(quantity))

  plyx(Sepal.Width~Sepal.Length | Species, data=iris)
</code></pre>

<hr>
<h2 id='doc'> Define and obtain the doc or tit attribute </h2><span id='topic+doc'></span><span id='topic+doc+3C-'></span><span id='topic+tit'></span><span id='topic+tit+3C-'></span>

<h3>Description</h3>

<p>The attributes <code>doc</code> and <code>tit</code> describe an object, typically
a data frame or a model. <code>tit</code> should be a short description (title),
<code>doc</code> should contain all documentation useful to identify
the origin and the changes made to the object.<br />
The <code>doc</code> and <code>tit</code> functions set them and extract these
attributes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doc(x)
tit(x) 
doc(x) &lt;- value
tit(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doc_+3A_x">x</code></td>
<td>
<p> object to which the <code>doc</code> or <code>tit</code> attribute
should be attached
or from which it is obtained</p>
</td></tr>
<tr><td><code id="doc_+3A_value">value</code></td>
<td>
<p>character vector (<code>doc</code>) or string (<code>tit</code>)
to be stored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting and printing functions may search for the <code>tit</code>
attribute or even for the <code>doc</code> attribute, depending on
<code>c.env$docout</code>.
</p>
<p><code>doc(x) &lt;- text</code> will append the existing <code>doc(x)</code> text to
the new <code>text</code> unless its first element equals (the first element
of) <code>text</code>.
(This avoids piling up the same line by unintended multiple call to
<code>doc(x) &lt;- value</code> with the same <code>value</code>.)
If the first element of <code>text</code> equals <code>"^"</code>,
the first element of <code>doc(x)</code> is dropped.
<code>tit(x) &lt;- string</code> replaces <code>tit(x)</code> with <code>string</code>. 
</p>


<h3>Value</h3>

<p><code>doc</code> and <code>tit</code> return the respective attributes of object
<code>x</code> 
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
doc(d.blast)
doc(d.blast) &lt;- "I will use this dataset in class soon."
doc(d.blast)
</code></pre>

<hr>
<h2 id='dropdata'>Drop Observations from a Data.frame</h2><span id='topic+dropdata'></span>

<h3>Description</h3>

<p>Allows for dropping observations (rows) determined by row names or
factor levels from a data.frame or matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropdata(data, rowid = NULL, incol = "row.names", colid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropdata_+3A_data">data</code></td>
<td>
<p>a data.frame of matrix</p>
</td></tr>
<tr><td><code id="dropdata_+3A_rowid">rowid</code></td>
<td>
<p>vector of character strings identifying the rows to be
dropped</p>
</td></tr>
<tr><td><code id="dropdata_+3A_incol">incol</code></td>
<td>
<p>name or index of the column used to identify the
observations (rows)</p>
</td></tr>
<tr><td><code id="dropdata_+3A_colid">colid</code></td>
<td>
<p>vector of character strings identifying the columns to be
dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data.frame or matrix without the dropped observations and/or
variables. 
Attributes are passed on.
</p>


<h3>Note</h3>

<p>Ordinary subsetting by <code>[...,...]</code> drops attributes like
<code><a href="#topic+doc">doc</a></code> or <code><a href="#topic+tit">tit</a></code>. Furthermore, the convenient
way to drop rows or columns by giving negative indices to
<code>[...,...]</code> cannot be used with names of rows or columns.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- data.frame(rbind(a=1:3,b=4:6,c=7:9,d=10:12))
dropdata(dd,"b")
dropdata(dd, col="X3")

d1 &lt;- dropdata(dd,"d")
d2 &lt;- dropdata(d1,"b")
naresid(attr(d2,"na.action"),as.matrix(d2))

dropdata(letters, 3:5)
</code></pre>

<hr>
<h2 id='dropNA'>drop or replace NA values
</h2><span id='topic+dropNA'></span><span id='topic+replaceNA'></span>

<h3>Description</h3>

<p><code>dropNA</code> returns the vector 'x', without elements that are NA or NaN
or, if 'inf' is TRUE, equal to Inf or -Inf.
<code>replaceNA</code> replaces these values by values from the second argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropNA(x, inf = TRUE)
replaceNA(x, na, inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropNA_+3A_x">x</code></td>
<td>
<p>vector from which the non-real values should be dropped
or replaced
</p>
</td></tr>
<tr><td><code id="dropNA_+3A_na">na</code></td>
<td>
<p>replacement or vector from which the replacing values
are taken.
</p>
</td></tr>
<tr><td><code id="dropNA_+3A_inf">inf</code></td>
<td>
<p>logical: should 'Inf' and '-Inf' be considered &quot;non-real&quot;?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>dropNA</code>: Vector containing the 'real' values
of 'x' only <br />
For <code>replaceNA</code>: Vector with 'non-real' values replaced by
the respective elements of <code>na</code>.
</p>


<h3>Note</h3>

<p>The differences to 'na.omit(x)' are:
'Inf' and '-Inf' are also dropped, unless 'inf==FALSE'.\
no attribute 'na.action' is appended.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a>, <a href="#topic+sumNA">sumNA</a>, <a href="base.html#topic+ifelse">ifelse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- c(1, NA, 0/0, 4, -1/0, 6)
dropNA(dd)
na.omit(dd)

replaceNA(dd, 99)
replaceNA(dd, 100+1:6)
</code></pre>

<hr>
<h2 id='fitcomp'>Component Effects for a Model Fit</h2><span id='topic+fitcomp'></span>

<h3>Description</h3>

<p>Determines effects of varying each of the given variables while all
others are held constant. This function is mainly used to produce
plots of residuals versus explanatory variables, also showing
component effects. It can handle a multivariate response fitted by
<code>lm</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitcomp(object, data = NULL, vars=NULL, transformed=FALSE, se = FALSE, 
  xm = NULL, xfromdata = FALSE, noexpand=NULL, nxcomp = 51)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitcomp_+3A_object">object</code></td>
<td>
<p>a model fit, result of a fitting function</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_data">data</code></td>
<td>
<p>data frame in which the variables are found.
If not provided, it is obtained from <code>object</code>.</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_vars">vars</code></td>
<td>
<p>character vector of names of variables for which
components are required. Only variables that appear in <code>data</code>
will be used. If <code>NULL</code> (the default), all variables in
<code>data</code> are used.
</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_transformed">transformed</code></td>
<td>
<p>logical: should components be calculated for 
transformed explanatory variables? If <code>TRUE</code>, the variables are
transformed as implied by the model.</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_se">se</code></td>
<td>
<p>if TRUE, standard errors will be returned</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_xm">xm</code></td>
<td>
<p>named vector of values of the fixed (central) point from
which the individual variables are varied in turn. <br />
Defaults to the componentwise median of quantitative variables and
the modes of factors.</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_xfromdata">xfromdata</code></td>
<td>
<p>if TRUE, the components effects will be evaluated for
the data values in <code>data</code>. Otherwise, the range of each
numerical variable is filled with <code>nxcomp</code> equidistant points,
whereas for factors, all levels are used.
This is useful for residual plots with component effects.</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_noexpand">noexpand</code></td>
<td>
<p>vector determining which variables should not be
&ldquo;filled in&rdquo;, probably because they are used like factors.
Either a character vector of variable names or a vector of
logical or numerical values with names, in which case the names
corresponding to positive values will be identified.</p>
</td></tr>
<tr><td><code id="fitcomp_+3A_nxcomp">nxcomp</code></td>
<td>
<p>number of points used for each (quantitative) variable
if <code>xfromdata</code> is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The component effect is defined as the curve of fitted values
obtained by varying the explanatory variable or term, keeping all the other
variables (terms) at their &quot;central value&quot; <code>xm</code> (the mean of continuous variables
and the mode of factors).
</p>


<h3>Value</h3>

<p>A list consisting of
</p>
<table>
<tr><td><code>comp</code></td>
<td>
<p>component effects. A matrix, unless the response is
multivariate, in which case it will be a 3-dimensional array.
</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the values of the x variables for which the effects have been
calculated</p>
</td></tr>
<tr><td><code>xm</code></td>
<td>
<p>the values at which the x variables are held fixed while one
of them is varied</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard errors of the component effects, if required by the
argument <code>se</code>. Same structure as <code>comp</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
t.r &lt;- lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast)
t.fc &lt;- fitcomp(t.r,se=TRUE)
t.fc$comp[1:10,]
</code></pre>

<hr>
<h2 id='gendateaxis'>Generate a variable expressing time with its attributes for plotting
</h2><span id='topic+gendate'></span><span id='topic+gendateaxis'></span>

<h3>Description</h3>

<p><code>gendateaxis</code> generates suitable attributes for
plotting a date or time variable.<br />
<code>gendate</code> generates a date variable and is an extension of
<code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendate(date = NULL, year = 2000, month = 1, day = 1, hour = 0, 
  min = 0, sec = 0, data = NULL, format = "y-m-d", origin = NULL)

gendateaxis(date = NULL, year = 2000, month = 1, day = 1, hour = 0,
  min = 0, sec = 0, data = NULL, format = "y-m-d", origin = NULL,
  ploptions=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendateaxis_+3A_date">date</code></td>
<td>
<p>vector of class <code>dates</code> or <code>chron</code> or vector
to be converted into such an object. May also be the name of such
a variable contained in <code>data</code>.
If <code>date</code> has class <code>dates</code> or <code>chron</code>, the arguments
<code>year, month</code> and <code>day</code> are ignored. 
</p>
</td></tr> 
<tr><td><code id="gendateaxis_+3A_year">year</code>, <code id="gendateaxis_+3A_month">month</code>, <code id="gendateaxis_+3A_day">day</code>, <code id="gendateaxis_+3A_hour">hour</code>, <code id="gendateaxis_+3A_min">min</code>, <code id="gendateaxis_+3A_sec">sec</code></td>
<td>
<p>numeric vectors giving the
year, month, day of month, hour, minute, second &ndash; or the name of such a
variable contained in <code>data</code>.
<code>day, hour, min, sec</code> can be fractional, see Details.
If these arguments are used, the supersede the respective parts in
<code>date</code>.
</p>
</td></tr>
<tr><td><code id="gendateaxis_+3A_data">data</code></td>
<td>
<p>data.frame, where variables can be found
</p>
</td></tr>
<tr><td><code id="gendateaxis_+3A_format">format</code></td>
<td>
<p>format for <code>date</code> in case that the latter is
a character vector
</p>
</td></tr>
<tr><td><code id="gendateaxis_+3A_origin">origin</code></td>
<td>
<p>year of origin for dates, defaults to
<code>ploptions("date.origin")</code>
</p>
</td></tr>
<tr><td><code id="gendateaxis_+3A_ploptions">ploptions</code></td>
<td>
<p>list pl options, generated by <code>pl.control</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>hour</code> is fractional, e.g., 6.2, the fraction is respected,
that is, it will be the same as time <code>06:12</code>.
If <code>min</code> is also given, the fraction of <code>hour</code> is ignored.
Similar for <code>day</code> and <code>min</code>.
<br />
If <code>hour</code> is <code>&gt;=24</code>, the <code>day</code> is augmented by
<code>hour%/%24</code> and the hour is set to <code>hour%%24</code>.
Similar for <code>min</code> and <code>sec</code>.
</p>


<h3>Value</h3>

<p>For <code>gendate</code>, a vector of times in <code>POSIXct</code> format.<br />
For <code>gendateaxis</code>, this is augmented by the attribute
</p>
<table>
<tr><td><code>numvalues</code></td>
<td>
<p>numerical values used for plotting.
If years, months or days vary in the data, the units are days.
Otherwise, they are hours, minutes, or seconds, depending on the
highest category that varies.
</p>
</td></tr>
</table>
<p>Unless the dates only cover one of the categories
(only years differ, or only months, ...), the following plotting
attributes are added:
</p>
<table>
<tr><td><code>ticksat</code></td>
<td>
<p>vector where tickmarks are shown.
It contains its own attribute <code>small</code> if secondary ticks are
suitable.</p>
</td></tr> 
<tr><td><code>ticklabels</code></td>
<td>
<p>May be years, quarters, month names, days, ...</p>
</td></tr>
<tr><td><code>ticklabelsat</code></td>
<td>
<p>vecor of coordinates to place the ticklabels</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>equals &quot;&quot;, since the time scale makes it clear enough
that the axis represents time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genvarattributes">genvarattributes</a>, <a href="graphics.html#topic+axis.Date">axis.Date</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>## call gendateaxis without 'real' data
tt &lt;- gendate(year=rep(2010:2012, each=12), month=rep(1:12, 3))
ta &lt;- gendateaxis(tt)

## ... derived from data
data(d.river)
d.river$dt &lt;- gendateaxis(date="date", hour="hour", data=d.river)
plyx(O2~dt, data=d.river, subset=months(date)!="Sep")
plyx(O2~dt, data=d.river[months(d.river$date)!="Sep",])
plyx(O2~dt, data=d.river, subset=1:1000)
</code></pre>

<hr>
<h2 id='gensmooth'>Smooth: wrapper function
</h2><span id='topic+gensmooth'></span>

<h3>Description</h3>

<p>Generate fits of a smoothing function for multiple y's.
Smooths can be calculated within given groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gensmooth(x, y, band = FALSE, power = 1, resid = "difference",
  weight = NULL, plargs=NULL, ploptions=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gensmooth_+3A_x">x</code></td>
<td>
<p>vector of x values.
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_y">y</code></td>
<td>
<p>vector or matrix of y values.
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_band">band</code></td>
<td>
<p>logical: Should a band consisting of low and high smooth
be calculated? It will only be calculated for the first column of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_power">power</code></td>
<td>
<p><code>y</code> will be raised to <code>power</code> before smoothing.
Results will be back-transformed. (Useful for smoothing absolute
values for a 'scale plot', for which <code>power=0.5</code> is recommended.)    
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_resid">resid</code></td>
<td>
<p>Which residuals be calculated?
<code>resid=1</code> or <code>="difference"</code> means usual residuals;
<code>resid=2</code> or <code>="ratio"</code> means $y_i/\hat y_i$, which is useful
to get scaled y's (regression residuals) according to a smooth fit in the
scale plot.
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_weight">weight</code></td>
<td>
<p>weights of observations, may also be passed by a
variable <code>.smoothWeights.</code> in the data set <code>plargs$pldata</code></p>
</td></tr>
<tr><td><code id="gensmooth_+3A_plargs">plargs</code>, <code id="gensmooth_+3A_ploptions">ploptions</code></td>
<td>
<p>result of calling <code>pl.control</code>.
The component <code>plargs$pdata</code> may contain <code>smooth.weight</code>
and <code>smooth.group</code>, and <code>ploptions</code> specifies
<code>smoothPar</code> and <code>smoothIter</code>.
All of these may be used by the smoothing function.
</p>
</td></tr>
<tr><td><code id="gensmooth_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to the smoothing function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for generating the smooths enhancing
residual plots.
It generates a smooth for a single x
variable and multiple y's.
It is also used to draw smooths from simulated residuals.
</p>
<p>NA's in either <code>x</code> or any column of <code>y</code> cause dropping the
observation (equivalent to <code>na.omit</code>).
</p>
<p>The smoothing function used to produce the smooth is
<code><a href="#topic+smoothRegr">smoothRegr</a></code>, which relies <code><a href="stats.html#topic+loess">loess</a></code>, by default.
This may be changed via <code>ploptions(smooth.function = func)</code> where
<code>func</code> is a smoothing function with the same arguments as
<code><a href="#topic+smoothRegr">smoothRegr</a></code>.
</p>
<p>The result of the smoothing function may carry an attribute
<code>xtrim</code>. This regulates if the fitted values corresponding to
extreme x values will be suppressed when plotting:
The number of extreme x values corresponding to
<code>ploptions("smooth.xtrim")</code> will be multiplied by
this attribute to obtain the number of extreme points suppressed at
each end. If the smoothing function is <code>smoothLm</code>, which fits a
straight line, then trimming is suppressed since this function returns
0 as the <code>xtrim</code> attribute.
</p>
<p>If <code>band</code> is <code>TRUE</code>, a vector of &quot;low&quot; and a vector of
&quot;high&quot; smooth values will be calculated for the first column of
<code>y</code> in the following way:
Residuals are calculated as the diference
between the observations and the respective smoothed values hat.$s_i$.
Then a smooth is calculated for the square roots of the positive residuals,
and the squared fitted values are added to the hat.$s_i$.
(The transformation by square roots makes the distribution of the residuals 
more symmetric.)
This defines the &ldquo;high&rdquo; smooth values. 
The construction of the &ldquo;low&rdquo; one is analogous.
The resulting values of the two are stored in the list component
<code>yband</code>, and <code>ybandindex</code> contains the information to which
group (&quot;low&quot; or &quot;high&quot;) the value belongs.
</p>


<h3>Value</h3>

<p>A list with components:  
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>vector of x values, sorted, within levels of <code>group</code>
if grouping is actif.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>matrix with 1 or more columns of corresponding fitted values
of the smoothing.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>grouping factor, sorted, if actif. <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>vector of indices of the argument <code>x</code> used for
sorting. This is useful to relate the results to the input.
Use <code>ysmoothed[value$index,] &lt;- value$y</code> to get values
corresponding to input <code>y</code>.</p>
</td></tr>
<tr><td><code>xorig</code></td>
<td>
<p>original <code>x</code> values</p>
</td></tr>
<tr><td><code>ysmorig</code></td>
<td>
<p>corresponding fitted values</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>if required by the argument <code>resid</code>,
residuals from the smooth fit are provided in the original order,
i.e. <code>value$resid[i,j]</code> corresponds to the input
<code>value$y[i,j]</code>.</p>
</td></tr>
</table>
<p>If <code>band==TRUE</code>,
</p>
<table>
<tr><td><code>yband</code></td>
<td>
<p>vector of low and high smoothed values (for the first
column of <code>y</code>)</p>
</td></tr>
<tr><td><code>ybandindex</code></td>
<td>
<p>Indicator if <code>yband</code> is a high value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called by <code><a href="#topic+plyx">plyx</a></code> and
<code><a href="#topic+plmatrix">plmatrix</a></code> when <code>smooth=T</code> is set,
as well as by
<code><a href="#topic+plregr">plregr</a></code> applied to model objects.
It is rarely needed to call it directly.<br />
A band is generated only for the first columnn of <code>y</code> since the
others are supposed to be simulated versions of the first one
and do not need a band. 
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothRegr">smoothRegr</a></code>,
<code><a href="#topic+plsmooth">plsmooth</a></code>, <code><a href="#topic+plsmoothline">plsmoothline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast,
    na.action=na.exclude)
r.smooth &lt;- gensmooth( fitted(r.blast), residuals(r.blast))
showd(r.smooth$y)
plot(fitted(r.blast), resid(r.blast), main="Tukey-Anscombe Plot")
abline(h=0)
lines(r.smooth$x,r.smooth$y, col="red")

## grouped data
t.plargs &lt;- list(pdata=data.frame(".smooth.group."=d.blast$location))

r.smx &lt;- gensmooth( d.blast$dist, residuals(r.blast), plargs=t.plargs)

plot(d.blast$dist, residuals(r.blast), main="Residuals against Regressor")
abline(h=0)
plsmoothline(r.smx, d.blast$dist, resid(r.blast), plargs=t.plargs)
## or, without using plsmoothlines:
## for (lg in 1:length(levels(r.smx$group))) {
##   li &lt;- as.numeric(r.smx$group)==lg 
##   lines(r.smx$x[li],r.smx$y[li], col=lg+1, lwd=3)
## }
</code></pre>

<hr>
<h2 id='genvarattributes'>Generate or Set Variable Attributes for Plotting
</h2><span id='topic+genvarattributes'></span><span id='topic+setvarattributes'></span>

<h3>Description</h3>

<p><code>genvarattributes</code> generates attributes of variables that are
useful for the <code>plgraphics</code> functions.
It is called by <code><a href="#topic+pl.control">pl.control</a></code>.<br />
<code>setvarattributes</code> modifies or sets such attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genvarattributes(data, vnames = NULL, vcol = NULL, vlty = NULL, vpch = NULL,
  varlabel = NULL, innerrange = NULL, plscale = NULL, zeroline = NULL, 
  replace=FALSE, ploptions = NULL, ...)

setvarattributes(data, attributes = NULL, list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genvarattributes_+3A_data">data</code></td>
<td>
<p>data.frame consisting of the variables (columns) to be
characterized by their attributes
</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_vnames">vnames</code></td>
<td>
<p>names of variables to be treated as y variables</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_vcol">vcol</code>, <code id="genvarattributes_+3A_vlty">vlty</code>, <code id="genvarattributes_+3A_vpch">vpch</code></td>
<td>
<p>color, line type and plotting character
to be used when multiple y-s are plotted (in the sense of
<code>matplot</code>)
</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_varlabel">varlabel</code></td>
<td>
<p>labels of the variables, in the case that the
<code>names</code> of <code>data</code> are not appropriate.
</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_innerrange">innerrange</code></td>
<td>
<p>logical indicating whether inner plotting ranges
should be determined and/or used.
May also be the limits of the inner plotting range, if
predetermined, see Details</p>
</td></tr> 
<tr><td><code id="genvarattributes_+3A_plscale">plscale</code></td>
<td>
<p>plot scale: name of the function to be used for
generating a plotting scale, like <code>"log"</code>.
A named character vector can be given, where the names correspond
to variable names in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_zeroline">zeroline</code></td>
<td>
<p>value(s) for which a horizontal or vertical line will be
drawn (in addition to the gridlines). The default is given by
<code>ploptions("zeroline")</code>.
</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_ploptions">ploptions</code></td>
<td>
<p>list containing the plotting elements
needed to set the attributes</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_replace">replace</code></td>
<td>
<p>logical: should existing attributes be replaced?</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_attributes">attributes</code></td>
<td>
<p>(for <code>setvarattributes</code>) is a list of lists.
Its names identify the variables for which the attributes are
set or modified. Each component is a list which is added to the
existing attributes of the respective variable or replaces them if
they already exist.</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_list">list</code></td>
<td>
<p>a list of attributes to be set.
Each component must have a name giving the name of the variable
attribute to be set, and be itself a list (or a vector).
This list must have names that identify the variables in 
<code>data</code> for which the attributes are set.
See examples to understand this.</p>
</td></tr>
<tr><td><code id="genvarattributes_+3A_...">...</code></td>
<td>
<p>further arguments, which will be collected and used as or
added to <code>list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the attribute <code>innerrange</code> is replaced, then <code>plcoord</code> is
also replaced.
</p>
<p><code>innerrange</code> may be a named list of ranges with names
corresponding to variables (not necessarily all of them),
or a scalar vector of length 2 to be used as range for all the
variables. 
It can also be a logical vector superseding the argument
<code>innerrange</code>, either named (as just mentioned) or
unnamed, to be repeated the appropriate number of times.
</p>


<h3>Value</h3>

<p>Data.frame, returning the original values, but the variables are
supplemented by the following <code>attributes</code>, where available:
</p>
<table>
<tr><td><code>nvalues</code></td>
<td>
<p>number of distinct values
</p>
</td></tr>
<tr><td><code>innerrange</code></td>
<td>
<p>inner plotting range
</p>
</td></tr>
<tr><td><code>plcoord</code></td>
<td>
<p>plotting coordinates
</p>
</td></tr>
<tr><td><code>ticksat</code></td>
<td>
<p>tick marks for axis
</p>
</td></tr>
<tr><td><code>varlabel</code></td>
<td>
<p>label to be used as axis label
</p>
</td></tr>
<tr><td><code>zeroline</code></td>
<td>
<p>value(s) for which a horizontal or vertical line will be
drawn (in addition to the gridlines)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
dd &lt;- genvarattributes(d.blast)
str(attributes(dd$tremor))

ddd &lt;- setvarattributes(dd, list( tremor=list(ticksat=seq(0,24,2),
  ticklabelsat = seq(0,24,10), ticklabels=c("low","medium","high")) ) )
str(attributes(ddd$tremor))

data(d.river)
plyx(O2+H2CO3+T ~ date, data=d.river, subset=as.Date(date)&lt;as.Date("2010-02-28"))
dd &lt;- setvarattributes(d.river,
  list=list(vcol=c(O2="blue", T="red")), vpch=c(O2=1, T="T", H2CO3=5) )
attributes(dd$O2)
plyx(O2+H2CO3+T ~ date, data=d.river, subset=as.Date(date)&lt;as.Date("2010-02-28"),
  plscale = c(O2="log", H2CO3="log") )
</code></pre>

<hr>
<h2 id='getmeth'>get S3 method of a generic function
</h2><span id='topic+getmeth'></span>

<h3>Description</h3>

<p>identical to <code>getS3method</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>getmeth(fn, mt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmeth_+3A_fn">fn</code></td>
<td>
<p>name of generic function, quoted or unquoted</p>
</td></tr>
<tr><td><code id="getmeth_+3A_mt">mt</code></td>
<td>
<p>name of method, quoted or unquoted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Source code of the method
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+getS3method">getS3method</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getmeth(simresiduals, glm)
</code></pre>

<hr>
<h2 id='getvariables'>Extract Variables or Variable Names
</h2><span id='topic+getvariables'></span><span id='topic+getvarnames'></span>

<h3>Description</h3>

<p><code>getvarnames</code> extracts the variables' names 
occurring in a formula, in raw form
(as <code>get\_all\_vars</code>) or in transformed form
(as <code>model.frame</code> does it).
</p>
<p><code>getvariables</code> collects variables from a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getvariables(formula, data = NULL, transformed = TRUE,
  envir = parent.frame(), ...)
getvarnames(formula, data = NULL, transformed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getvariables_+3A_formula">formula</code></td>
<td>
<p>a model 'formula' or 'terms' object or an R object,
or a character vector of variable names</p>
</td></tr>
<tr><td><code id="getvariables_+3A_data">data</code></td>
<td>
<p>a data.frame, list or environment (or object coercible by
'as.data.frame' to a data.frame), containing the variables in
'formula'.  Neither a matrix nor an array will be accepted.</p>
</td></tr>
<tr><td><code id="getvariables_+3A_transformed">transformed</code></td>
<td>
<p>logical. If <code>TRUE</code>, variables will be extracted as
transformed in <code>formula</code>, otherwise, untransformed variables
are returned.</p>
</td></tr>
<tr><td><code id="getvariables_+3A_envir">envir</code></td>
<td>
<p>environment in which the <code>formula</code> will be evaluated
</p>
</td></tr>
<tr><td><code id="getvariables_+3A_...">...</code></td>
<td>
<p>further arguments such as
<code>data, weight, subset, offset</code>
used to create extra columns in the resulting data.frame, with
names between dots such as '&quot;.offset.&quot;'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>getvarnames</code>:
names of all variables (<code>transformed=FALSE</code>)
or simple terms (<code>transformed=TRUE</code>),
including the attributes 
</p>
<table>
<tr><td><code>xvar</code></td>
<td>
<p>those from the right hand side of the formula</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>left hand side, if present</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>conditioning part, denoted after a <code>|</code> symbol
in formula, if applicable</p>
</td></tr> 
</table>
<p>For <code>getvariables</code>: 
data.frame containing the extracted variables or simple terms,
with the attributes of <code>getvarnames</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+get_all_vars">get_all_vars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
getvarnames(log10(tremor)~log10(distance)*log10(charge), data=d.blast)

dd &lt;- getvariables(log10(tremor)~log10(distance)*log10(charge),
                   data=d.blast, by=location)
str(dd)
</code></pre>

<hr>
<h2 id='legendr'>Add a Legend to a Plot</h2><span id='topic+legendr'></span>

<h3>Description</h3>

<p>Adds a legend to a plot as does <code><a href="graphics.html#topic+legend">legend</a></code>. This function
just expresses the position relative to the range of the coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendr(x = 0.05, y = 0.95, legend, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendr_+3A_x">x</code></td>
<td>
<p>position in horizontal direction, between 0 for left margin
and 1 for right margin</p>
</td></tr>
<tr><td><code id="legendr_+3A_y">y</code></td>
<td>
<p>position in vertical direction, between 0 for bottom margin
and 1 for top margin</p>
</td></tr>
<tr><td><code id="legendr_+3A_legend">legend</code></td>
<td>
<p>text of the legend</p>
</td></tr>
<tr><td><code id="legendr_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="graphics.html#topic+legend">legend</a></code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+legend">legend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     ts.plot(ldeaths, mdeaths, fdeaths,xlab="year", ylab="deaths", lty=c(1:3))
     legendr(0.7,0.95, c("total","female","male"), lty=1:3)
</code></pre>

<hr>
<h2 id='leverage'>Get leverage values</h2><span id='topic+leverage'></span>

<h3>Description</h3>

<p>Extracts the leverage component of a fit object using the
<code>na.action</code> component if available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage_+3A_object">object</code></td>
<td>

<p>an object containing a component <code>fit$leverage</code> and possibly
a component <code>fit$na.action</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference to <code>hatvalues</code> is that <code>leverage</code> does not
call <code>influence</code> and therefore does not require residuals.
It is therefore simpler and more widely applicable.
</p>
<p>The function uses the <code>qr</code> decomposition of <code>object</code>.
If necessary, it generate it.
</p>
<p>The leverage is the squared Mahalanobis distance of the observation
from the center of the design X (<code>model.matrix</code>) with
&quot;covariance&quot; X^T X. If there are weights (<code>object$weights</code>),
the weighted center and &quot;covariance&quot; are used, and the distances are
multiplied by the weights.
To obtain the distances in the latter case, &quot;de-weight&quot; the leverages
by dividing them by the weights.
</p>


<h3>Value</h3>

<p>The vector <code>fit$leverage</code>, possibly expanded by missing values
if <code>fit$na.action</code> has class <code>na.exclude</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hat">hat</a>; <a href="stats.html#topic+hatvalues">hatvalues</a>; <a href="stats.html#topic+influence">influence</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast)
showd(leverage(r.blast))
</code></pre>

<hr>
<h2 id='linear.predictors'>linear predictors from a (generalized) linear model
</h2><span id='topic+linear.predictors'></span><span id='topic+linpred'></span>

<h3>Description</h3>

<p>extracts the linear.predictor component of a model object,
taking 'na.resid' into account, in analogy to 'residuals' or
'fitted.values'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.predictors(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear.predictors_+3A_object">object</code></td>
<td>
<p>model fit
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector (or, for models inheriting from 'multinom', matrix)
of linear predictor values
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted.values">fitted.values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from 'glm'
clotting &lt;- data.frame(
u = c(5,10,15,20,30,40,60,80,100),
lot1 = c(118,58,NA,35,27,25,21,19,18), ## NA inserted instead of 42
lot2 = c(69,35,26,21,18,16,13,12,12))

r.gam  &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma)
linear.predictors(r.gam)
## 8 elements; 3rd missing.
r.gex  &lt;- glm(lot1 ~ log(u), data = clotting, family = Gamma,
              na.action=na.exclude)
linear.predictors(r.gex)
## 9 elements, third is NA
</code></pre>

<hr>
<h2 id='logst'>Started Logarithmic Transformation</h2><span id='topic+logst'></span>

<h3>Description</h3>

<p>Transforms the data by a log10 transformation, modifying small and zero
observations such that the transformation yields finite values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logst(data, calib=data, threshold=NULL, mult = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logst_+3A_data">data</code></td>
<td>
<p>a vector or matrix of data, which is to be transformed</p>
</td></tr>
<tr><td><code id="logst_+3A_calib">calib</code></td>
<td>
<p>a vector or matrix of data used to calibrate the
transformation(s),
i.e., to determine the constant <code>c</code> needed</p>
</td></tr>
<tr><td><code id="logst_+3A_threshold">threshold</code></td>
<td>
<p>constant c that determines the transformation,
possibly a vector with a value for each variable.</p>
</td></tr>
<tr><td><code id="logst_+3A_mult">mult</code></td>
<td>
<p>a tuning constant affecting the transformation of small
values, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small values are determined by the threshold c. If not given by the
argument <code>threshold</code>, then it is determined by the quartiles
<code class="reqn">q_1</code> and <code class="reqn">q_3</code> of the non-zero data as those
smaller than <code class="reqn">c=q_1 / (q_3/q_1)^{mult}</code>.
The rationale is that for lognormal data, this constant identifies
2 percent of the data as small.
Beyond this limit, the transformation continues linear with the
derivative of the log curve at this point. See code for the formula.
</p>
<p>The function chooses log10 rather than natural logs because they can
be backtransformed relatively easily in the mind.
</p>


<h3>Value</h3>

<p>the transformed data. The value c needed for the transformation is
returned as <code>attr(.,"threshold")</code>. 
</p>


<h3>Note</h3>

<p>The names of the function alludes to Tudey's idea of &quot;started logs&quot;.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- c(seq(0,1,0.1),5*10^rnorm(100,0,0.2))
dd &lt;- sort(dd)
r.dl &lt;- logst(dd)
plot(dd, r.dl, type="l")
abline(v=attr(r.dl,"threshold"),lty=2)
</code></pre>

<hr>
<h2 id='markextremes'>
Adjust the default proportion of extreme points to be labeled to the number
of observations
</h2><span id='topic+markextremes'></span>

<h3>Description</h3>

<p>Adjusts the proportion of extreme points to be labeled to the number of
observations. It is the default of the <code>ploption markextremes</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markextremes(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markextremes_+3A_n">n</code></td>
<td>
<p>number of observations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply applies <code>ceiling(sqrt(n)/2)/n</code>.
</p>


<h3>Value</h3>

<p>A scalar between 0 and 0.5
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>markextremes(20)
for (n in c(10,20,50,100,1000))  print(c(n,markextremes(n)))
</code></pre>

<hr>
<h2 id='modarg'>
Modify default arguments according to a named vector or list
</h2><span id='topic+modarg'></span>

<h3>Description</h3>

<p>Makes it easy to modify one or a few elements of a vector or list
of default settings.
This function is to be used within functions that contain vectors
of control arguments such as colors for different elements of a plot  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modarg(arg = NULL, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modarg_+3A_arg">arg</code></td>
<td>
<p>named vector or list of the elements that should override
the settings in 'default'
</p>
</td></tr>
<tr><td><code id="modarg_+3A_default">default</code></td>
<td>
<p>named vector or list of default settings
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as the argument 'default' with elements replaced according to
'arg'.
See the source code of <code>plmboxes.default</code> for a typical application.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>Examples</h3>

<pre><code class='language-R'>modarg(c(b="B", c=0), list(a=4, b="bb", c=NA))

df &lt;- ploptions("linewidth")
cbind(df, modarg(c(dot=1.4, dashLongDot=1.3), df))

## These statements lead to a warning:
modarg(c(b=2, d=6), c(a="4", b="bb", c=NA)) 
modarg(1:6, c(a="4", b="bb", c=NA))
</code></pre>

<hr>
<h2 id='months'>strings for month and weekday names</h2><span id='topic+c.months'></span><span id='topic+c.mon'></span><span id='topic+c.weekdays'></span><span id='topic+c.wkd'></span>

<h3>Description</h3>

<p>Vectors of month and weekday names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c.months
c.mon
c.weekdays
c.wkd
</code></pre>


<h3>Arguments</h3>

<p>none
</p>


<h3>Value</h3>

<p>character vector.<br />
<code>c.months</code> contains the 12 month names.<br />
<code>c.mon</code> same, abbreviated to 3 characters,<br />
<code>c.weekdays</code> names of the 7 weekdays<br />
<code>c.wkd</code> same, abbreviated to 3 characters,<br />
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>c.weekdays[1:5]
</code></pre>

<hr>
<h2 id='nainf.exclude'>Drop Rows Containing NA or Inf</h2><span id='topic+nainf.exclude'></span><span id='topic+nainf.omit'></span>

<h3>Description</h3>

<p>Drops the rows of a data frame that contain an NA, an NaN, or an Inf value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nainf.exclude(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nainf.exclude_+3A_object">object</code></td>
<td>
<p>an R object, typically a data frame</p>
</td></tr>
<tr><td><code id="nainf.exclude_+3A_...">...</code></td>
<td>
<p>further arguments special methods could require.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple modification of <code><a href="stats.html#topic+na.omit">na.omit</a></code> and
<code><a href="stats.html#topic+na.exclude">na.exclude</a></code>
</p>


<h3>Value</h3>

<p>The value is of the same type as the argument <code>object</code>,
with possibly less elements.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>t.d &lt;- data.frame(V1=c(1,2,NA,4), V2=c(11,12,13,Inf))
nainf.exclude(t.d)
</code></pre>

<hr>
<h2 id='notice'>Generate a Notice
</h2><span id='topic+notice'></span>

<h3>Description</h3>

<p>Generate a notice to be sent to output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notice(..., printnotices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notice_+3A_...">...</code></td>
<td>
<p>contents of the notice, will be pasted together
</p>
</td></tr>
<tr><td><code id="notice_+3A_printnotices">printnotices</code></td>
<td>
<p>logical: Should the notice be printed?
Default is the respective pl option. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very similar to 'message'
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+message">message</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ff &lt;- function(x) {
    if (length(x)==0)  {
      notice("ff: argument 'x' is NULL. I return 0")
      return(0)
    }
    1/x
  }
  ff(3)
  ff(NULL)
  oo &lt;- ploptions(printnotices=FALSE)
  ff(NULL)
</code></pre>

<hr>
<h2 id='pl.control'>Arguments for plotting functions</h2><span id='topic+pl.control'></span>

<h3>Description</h3>

<p>Arguments that can be specified calling <code>plyx</code> and
other 'pl' functions are checked and data is prepared for plotting.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl.control(x=NULL, y=NULL, condvar = NULL, data = NULL, subset = NULL,
  transformed = TRUE, distinguishy = TRUE, gensequence = NULL,
  csize = NULL, csize.pch = NULL, 
  psize = NULL, plab = FALSE, pch = NULL, pcol = NULL,  
  smooth.weights = NULL, smooth.weight = NULL,
  markextremes = NULL, smooth = NULL,
  xlab = NULL, ylab = NULL, varlabel = NULL,
  vcol = NULL, vlty = NULL, vpch = NULL, plscale = NULL, log = NULL,
  main = NULL, sub = NULL, .subdefault = NULL, mar = NULL, 
  gencoord = TRUE,
  plargs = pl.envir, ploptions = NULL, .environment. = parent.frame(),
  assign = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pl.control_+3A_x">x</code>, <code id="pl.control_+3A_y">y</code>, <code id="pl.control_+3A_data">data</code></td>
<td>
<p>as in <code><a href="#topic+plyx">plyx</a></code>
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_condvar">condvar</code></td>
<td>
<p>conditioning variables for <code><a href="#topic+plcond">plcond</a></code>
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_subset">subset</code></td>
<td>
<p>subset of data.frame 'data' to be used for plotting.
See details.</p>
</td></tr>
<tr><td><code id="pl.control_+3A_transformed">transformed</code></td>
<td>
<p>logical: should transformed variables be used?
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_distinguishy">distinguishy</code></td>
<td>
<p>logical: should multiple y's be distinguished?
This is <code>TRUE</code> if <code>pl.control</code> is called from
<code>plyx</code>.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_gensequence">gensequence</code></td>
<td>
<p>logical: if only <code>x</code> or only <code>y</code> is set,
should the other of these be specified as the sequence
<code>1:nobs</code> (where <code>nobs</code> is the number of observations)?
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_csize">csize</code></td>
<td>
<p>character expansion, applied to both labels and plotting
characters.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_csize.pch">csize.pch</code></td>
<td>
<p>expansion of plotting symbol relative to
<code>par("pch")</code>.
By default, it adjusts to the number of observations.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_psize">psize</code>, <code id="pl.control_+3A_plab">plab</code>, <code id="pl.control_+3A_pch">pch</code>, <code id="pl.control_+3A_pcol">pcol</code></td>
<td>
<p>Plotting characteristics of points,
specified as a (unquoted) variable name found in <code>data</code>
or as a vector.
They set the size of the plotting symbols, labels (character
strings), plotting character, and color, respectively.<br />
<code>plabs = TRUE</code> asks for using the row names of <code>data</code>.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_smooth.weights">smooth.weights</code>, <code id="pl.control_+3A_smooth.weight">smooth.weight</code></td>
<td>
<p>weights to be used in calculating
smooth lines. Both are equivalent.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_markextremes">markextremes</code></td>
<td>
<p>scalar: proportion of extreme points to be labelled
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_smooth">smooth</code></td>
<td>
<p>logical: should a smooth line be added?
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_xlab">xlab</code>, <code id="pl.control_+3A_ylab">ylab</code></td>
<td>
<p>axis labels</p>
</td></tr>
<tr><td><code id="pl.control_+3A_varlabel">varlabel</code></td>
<td>

<p>labels for variables replacing their names in the <code>x</code> and
<code>y</code> arguments, either a simple vector of strings with an
element for each variable,
or a named vector, where names correspond to such variables.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_vcol">vcol</code>, <code id="pl.control_+3A_vlty">vlty</code>, <code id="pl.control_+3A_vpch">vpch</code></td>
<td>
<p>color, line type and plotting character
to be used when multiple y-s are plotted (in the sense of
<code>matplot</code>)
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_plscale">plscale</code></td>
<td>
<p>plot scale: name of the function to be used for
generating a plotting scale, like <code>"log"</code>.
A named character vector can be given, where the names correspond
to variable names in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_log">log</code></td>
<td>
<p>requires log scale as in R's basic plot function,
e.g., equals either <code>"x"</code>, <code>"y"</code> or <code>"xy"</code></p>
</td></tr>
<tr><td><code id="pl.control_+3A_main">main</code>, <code id="pl.control_+3A_sub">sub</code></td>
<td>
<p>string. Main title of the plot(s).
If <code>sub</code> starts by <code>":"</code> (the default),
<code>pl.control</code> tries to generate an informative subtitle,
determined by the data or a model formula.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_.subdefault">.subdefault</code></td>
<td>
<p>for internal use: default of subtitle</p>
</td></tr>
<tr><td><code id="pl.control_+3A_mar">mar</code></td>
<td>
<p>plot margins</p>
</td></tr>
<tr><td><code id="pl.control_+3A_gencoord">gencoord</code></td>
<td>
<p>logical: should plotting coordinates be generated?
This is avoided for low level pl graphics.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_plargs">plargs</code></td>
<td>
<p>pl arguments, a list with components
<code>ploptions</code>, see the following argument;
<code>pldata</code>, the data used for plotting;
<code>pmarpar</code>, graphical parameters defining margins.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_ploptions">ploptions</code></td>
<td>
<p>Plotting attributes, e.g., plotting character,
line types, colors and the like, for different aspects of plots.
Result of <code><a href="#topic+ploptions">ploptions</a></code>. Defaults to
<code>pl.envir$ploptions</code>.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_.environment.">.environment.</code></td>
<td>
<p>used by the calling function to provide the
environment for evaluating <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_assign">assign</code></td>
<td>
<p>logical: should the result of <code>pl.control</code> be
assigned to the <code>pl.envir</code> environment?
This will be done for high level pl functions, but avoided for low
level ones. It allows for reusing the settings and helps debug
unexpected behavior.
</p>
</td></tr>
<tr><td><code id="pl.control_+3A_...">...</code></td>
<td>
<p>further arguments. These may include:
</p>

<dl>
<dt><code>psize, plab, pch, pcol, group, smooth.group,
	smooth.weights</code>: </dt><dd><p>these specify graphical elements for each
observation (row of <code>data</code>).
the respective columns are added to the <code>pldata</code>
data.frame.</p>
</dd>
<dt><code>...</code>: </dt><dd><p>further <code>...</code> arguments will be passed on to
<code>ploptions</code>. The respective settings will be used
in the calling pl function, but not permanently stored
in <code>ploptions</code> in the <code>pl.envir</code> environment.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The function selects the data according to the arguments
<code>x, y, data</code> and <code>subset</code> (the latter by calling
<code><a href="#topic+plsubset">plsubset</a></code>).
The argument <code>subset</code> should be used instead of
<code>data[subset,]</code> if the dataset <code>data</code> contains variable
attributes like <code>varlabel, ticksat, ...</code>.
The argument is evaluated in the dataset defined by <code>data</code>,
i.e., variable names may be used to define the subset.
</p>


<h3>Value</h3>

<p>A list containing all the arguments, possibly in modified form.
Specifically, the evaluations of the variables contained in
<code>x</code> and <code>y</code> along with 
<code>psize, plab, pch, pcol, smoothGroup, smoothWeights</code>
are collected in the component <code>pldata</code>.
The component, <code>ploptions</code>, collects the ploptions, and 
<code>plfeatures</code> contains a list of additional features, both
to be used in the calling high level pl function
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plyx">plyx</a></code>, <code><a href="#topic+plmatrix">plmatrix</a></code>, <code><a href="#topic+ploptions">ploptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyx(Sepal.Width~Sepal.Length, data=iris, axp=7, plab=TRUE, csize.plab=0.6)
## same as
plargs &lt;- pl.control(Sepal.Width~Sepal.Length, data=iris)
plargs$pdata$plab &lt;- row.names(iris)
plargs$csize.lab &lt;- 0.6
plargs$axp &lt;- 7
plyx(Sepal.Width~Sepal.Length, plargs=plargs)

</code></pre>

<hr>
<h2 id='pl.envir'>Environment Containing Information for Generating Pl Graphics</h2><span id='topic+pl.envir'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+environment">environment</a></code> <code>pl.envir</code> contains options and
information generated by the user or the high level <code>pl*()</code> functions
to guide many aspects of pl graphical displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pl.envir </code></pre>


<h3>Details</h3>

<p>The <code><a href="base.html#topic+environment">environment</a></code> contains the following objects:
</p>

<dl>
<dt><code>usr.ploptions</code>: </dt><dd><p>The ploptions that are the current
user choice. It is initiated with the package's
choices in <code><a href="#topic+default.ploptions">default.ploptions</a></code> and
modified whenever <code>ploptions</code> are set
(and <code>assign</code> is <code>TRUE</code>),
see <code><a href="#topic+ploptions">ploptions</a></code>.
</p>
</dd>
<dt><code>ploptions</code>: </dt><dd><p>The last (or current) list used
(and often modified) by a high level pl function.
</p>
</dd>
<dt><code>plfeatures, marpar</code>: </dt><dd><p>Additional features used by pl functions</p>
</dd>
<dt><code>pldata</code>: </dt><dd><p>The last (or current) data set used by pl functions</p>
</dd>
<dt><code>pl.scaleFunctions</code>: </dt><dd><p>scale functions known to <span class="pkg">plgraphics</span>,
useful for scales to be used for showing axes.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>pl.envir$usr.ploptions$margin.line   ## same as ...
ploptions("margin.line")
# The objects inside pl.envir:
ls(pl.envir) 

plyx(1:4)
ploptions(margin.line=c(3,1))
ploptions("margin.line")
pl.envir$usr.ploptions$margin.line
pl.envir$ploptions$margin.line  ## the choice for
  ## the last called high level pl function
str( pl.envir$plfeatures )
</code></pre>

<hr>
<h2 id='plbars'>Add bars to a pl plot
</h2><span id='topic+plbars'></span>

<h3>Description</h3>

<p>Adds horizontal or vertical bars to a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plbars(x = NULL, y = NULL, midpointwidth = NULL, 
  plargs = NULL, ploptions = NULL, marpar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plbars_+3A_x">x</code>, <code id="plbars_+3A_y">y</code></td>
<td>
<p>coordinates for the horizontal and veritical axis,
respectively. Either of them must have 3 columns.
If <code>y</code> has 3 columns, <code>x</code> must have one only or be
a vector. Then <code>y[,1]</code> contains the midpoints, and the other
two columns determine the endpoints of the bars, which will be
vertical.
Analogously if <code>x</code> has 3 columns.
</p>
</td></tr>
<tr><td><code id="plbars_+3A_midpointwidth">midpointwidth</code></td>
<td>
<p>for <code>plbars</code>: determines the length of the
segments that mark the midpoints. See Details.
</p>
</td></tr>
<tr><td><code id="plbars_+3A_plargs">plargs</code>, <code id="plbars_+3A_ploptions">ploptions</code></td>
<td>
<p>result of <code><a href="#topic+pl.control">pl.control</a></code>, see Details
</p>
</td></tr>
<tr><td><code id="plbars_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>
<tr><td><code id="plbars_+3A_...">...</code></td>
<td>
<p>absorbs extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>plbars</code>, the argument <code>midpointwidth</code> determines the
length of the segments that mark the midpoint relative to the default,
which is proportional to the range of the plotting area and inversely
proportional to the number of (finite) observations.
</p>
<p><code>plargs</code> and <code>ploptions</code> may be specified explicitly.
Otherwise, they are taken from <code>pl.envir</code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.river)
dd &lt;- plsubset(d.river, 1:2000)
da &lt;- aggregate(dd[,3:7], dd[,"date",drop=FALSE], mean, na.rm=TRUE)
ds &lt;- aggregate(dd[,3:7], dd[,"date",drop=FALSE], sd, na.rm=TRUE)
plyx(O2~date, data=da, type="n")
td &lt;- da$O2 + outer(ds$O2, c(0,-1,1))
plbars(y = td, midpointwidth=0.1, bar.lwd=2)

</code></pre>

<hr>
<h2 id='plcond'>Plot Two Variables Conditional on Two Others
</h2><span id='topic+plcond'></span>

<h3>Description</h3>

<p>A scatterplot matrix is generated that shows, in each
panel, the relationship between two primary variables, with the
dataset restricted by appropriate subranges of two 'conditioning'
variables.
This corresponds to <code>link{coplot}</code>.
The points that are near to the the 'window' defining the panel's
restriction are also shown, in a distinct style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plcond(x, y = NULL, condvar = NULL, data = NULL,
  panel = NULL, nrow = NULL, ncol = NULL,
  xaxmar = NULL, yaxmar = NULL, xlab = NULL, ylab = NULL,
  oma = NULL, plargs = NULL, ploptions = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plcond_+3A_x">x</code>, <code id="plcond_+3A_y">y</code></td>
<td>
<p>the two variables used to generate each panel.
They may be specified as vectors, as column names of <code>data</code> or
by formulas as in <code><a href="#topic+plyx">plyx</a></code>.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_condvar">condvar</code></td>
<td>
<p>two (or one) variables that define the restrictions of
the data for the different panels.
A numerical variable is cut into intervals, see Details.
A factor defines the 'ranges' as its levels. For each combination
of intervals or levels of the two variables, a panel is generated.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_data">data</code></td>
<td>
<p>data.frame in which the variables are found if needed
</p>
</td></tr>
<tr><td><code id="plcond_+3A_panel">panel</code></td>
<td>
<p>function that generates each panel.
If set by the user, it must accept the arguments
<code>x, y, ckeyx, ckeyy, pcol, pale, cex, smooth, smooth.minobs,
      ploptions</code>. The default is <code>ploptions("plcond.panel")</code>,
which in turn is initiated as the function <code>plpanelCond</code>.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_nrow">nrow</code>, <code id="plcond_+3A_ncol">ncol</code></td>
<td>
<p>number of maximum rows and columns on a page
</p>
</td></tr>
<tr><td><code id="plcond_+3A_xaxmar">xaxmar</code>, <code id="plcond_+3A_yaxmar">yaxmar</code></td>
<td>
<p>margin in which the axis (tick marks and
corresponding labels) should be shown: either 1 or 3 for
<code>xaxmar</code> and 2 or 4 for <code>yaxmar</code>.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_xlab">xlab</code>, <code id="plcond_+3A_ylab">ylab</code></td>
<td>
<p>labels of the variables <code>x</code> and <code>y</code>
</p>
</td></tr>
<tr><td><code id="plcond_+3A_oma">oma</code></td>
<td>
<p>width of outer margins, see <code><a href="graphics.html#topic+par">par</a></code>.
Note that a minimum of 2.1 is generally needed for showing
tick and axis labels.</p>
</td></tr>
<tr><td><code id="plcond_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plcond_+3A_assign">assign</code></td>
<td>
<p>logical: Should the plargs be stored in <code>pl.envir</code>? 
</p>
</td></tr>
<tr><td><code id="plcond_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>panel</code> function
and possibly further to functions called by the panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A numerical conditioning variable (<code>condvar</code>) will be
split by default into classes by splitting its robust range
(<code><a href="#topic+robrange">robrange</a></code>) into <code>ploptions("plcond.nintervals")</code>
equally long intervals. Alternatively, the variable may contain
an attribute <code>cutpoints</code> which then defines the intervals.
</p>
<p>For numerical conditioning variables, each panel also shows
neighboring points with a different color and diminished size.
The size of the neighborhood is defined by the proportion of extension 
<code>ploptions("plcond.ext")</code>.
The point size of the respective 'exterior' points is given by
<code>ploptions("plcond.cex")</code> The color are given by
the 4 elements of <code>ploptions("plcond.col")</code>:
The first element is used to paint the neighboring points
to the left of the current range of the conditioning x variable, 
the second element paints those to the right,
and the third and fourth are used in the same way for the
conditioning y variable. The neighboring points that are outside
both ranges get a color mixing the two applicable colors according to
this rule.
Finally, paling is applied to these colors with a degree that is
linear in the distance from the interval, determined by the range
given by <code>ploptions("plcond.pale")</code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+coplot">coplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plcond(Sepal.Width~Sepal.Length, data=iris, condvar=~Species+Petal.Length)
</code></pre>

<hr>
<h2 id='plcoord'> Determines Values for Plotting with Limited &quot;Inner&quot; Plot Range </h2><span id='topic+plcoord'></span>

<h3>Description</h3>

<p>For plots with an &quot;inner plot range&quot; (see Details) this function
converts the data values to the coordinates in the plot 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plcoord(x, range = NULL, innerrange.factor = NULL,
  innerrange.ext = NULL, plext = NULL, ploptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plcoord_+3A_x">x</code></td>
<td>
<p> data to be represented </p>
</td></tr>
<tr><td><code id="plcoord_+3A_range">range</code></td>
<td>
<p> vector of 2 elements giving the inner plot range. Data
beyond the given interval will be non-linearly transformed to fit
within the (outer) plot margins. Defaults to
<code><a href="#topic+robrange">robrange</a>(x, fac=fac)</code>.
</p>
</td></tr>
<tr><td><code id="plcoord_+3A_innerrange.factor">innerrange.factor</code></td>
<td>
<p> factor used to determine the default of
<code>range</code> </p>
</td></tr>
<tr><td><code id="plcoord_+3A_innerrange.ext">innerrange.ext</code></td>
<td>
<p> factor for extending the <code>range</code> to
determine the outer plot range </p>
</td></tr>
<tr><td><code id="plcoord_+3A_plext">plext</code></td>
<td>
<p> vector of 1 or 2 elements setting the extension factor
for the plotting range</p>
</td></tr>
<tr><td><code id="plcoord_+3A_ploptions">ploptions</code></td>
<td>
<p>plotting options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When plotting data that contain outliers, the non-outlying data is
represented poorly. Rather than simply clipping outliers, one can
split the plotting area into an inner region, where the (non-outlying)
data is plotted as usual, and a plot area margin, in which outliers
are represented on a highly non-linear scale that allows to display
them all.
</p>
<p>This function converts the data to the coordinates used in the
graphical display, and also returns the inner and outer ranges for
plotting.
</p>


<h3>Value</h3>

<p>vector of coordinates used for plotting, that is, unchanged <code>x</code>
values for   those within the <code>range</code> and transformed values
for those outside.
</p>
<p>Attributes:
</p>
<table>
<tr><td><code>attr(</code>, <code>"plrange")</code></td>
<td>
<p>the range to be used when plotting</p>
</td></tr>
<tr><td><code>attr(</code>, <code>"range")</code></td>
<td>
<p>the &quot;inner&quot; plot range, either the argument
<code>range</code> or the values determined by default.</p>
</td></tr>
<tr><td><code>attr(</code>, <code>"nouter")</code></td>
<td>
<p>the number of modified observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>See Also</h3>

 <p><code><a href="#topic+robrange">robrange</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(0)
  x &lt;- c(rnorm(20),rnorm(3,5,10))
  ( xmod &lt;- plcoord(x) )

  plot(x,xmod)
## This shows what high level pl functions do by default
  plot(xmod)
  abline(h=attr(xmod,"innerrange"),lty=3, lwd=2)
## plgraphics
  plyx(x)  
</code></pre>

<hr>
<h2 id='plframe'>Low level plotting functions for the 'pl' system
</h2><span id='topic+plframe'></span><span id='topic+pltitle'></span><span id='topic+plaxis'></span>

<h3>Description</h3>

<p>These functions set up the frame of a plot
based on the 'pl' paradigm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plframe(x = NULL, y = NULL, xlab = NULL, ylab = NULL,
  xlim = NULL, ylim = NULL, mar = NULL, showlabels = TRUE, 
  plext = NULL, axcol = rep(1, 4), 
  plargs = NULL, ploptions = NULL, marpar = NULL, xy = NULL, ...)

pltitle(main=NULL, sub=NULL, csize=NULL, csizemin=NULL, 
  side=3, line=NULL, adj=NULL, outer.margin=NULL, col="black",
  doc=NULL, show=NA, plargs=NULL, ploptions = NULL, marpar = NULL, ...)

plaxis(side, x=NULL, showlabels=TRUE, range=NULL, varlabel=NULL, col=1,
  tickintervals=NULL,
  plargs = NULL, ploptions = NULL, marpar = NULL, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plframe_+3A_x">x</code></td>
<td>
<p>coordinates for the horizontal axis
</p>
</td></tr>
<tr><td><code id="plframe_+3A_y">y</code></td>
<td>
<p>coordinates for the vertical axis
</p>
</td></tr>
<tr><td><code id="plframe_+3A_xlab">xlab</code>, <code id="plframe_+3A_ylab">ylab</code></td>
<td>
<p>axis labels</p>
</td></tr>
<tr><td><code id="plframe_+3A_xlim">xlim</code>, <code id="plframe_+3A_ylim">ylim</code></td>
<td>
<p>plot ranges</p>
</td></tr>
<tr><td><code id="plframe_+3A_mar">mar</code></td>
<td>
<p>plot margins</p>
</td></tr>
<tr><td><code id="plframe_+3A_showlabels">showlabels</code></td>
<td>
<p>logical: should labels for tickmarks and the
variable label be displayed?
If <code>==1</code>, they are shown if there is enough space in the margin
(including outer margin), if <code>==2</code>, it is shown anyway
(by setting <code>xpd=TRUE</code>).</p>
</td></tr>
<tr><td><code id="plframe_+3A_plext">plext</code></td>
<td>
<p>extension of the plotting area beyond the range of the
data. 
</p>
</td></tr>
<tr><td><code id="plframe_+3A_axcol">axcol</code></td>
<td>
<p>colors for drawing axes scales
</p>
</td></tr>
<tr><td><code id="plframe_+3A_main">main</code>, <code id="plframe_+3A_sub">sub</code></td>
<td>
<p>main title and subtitle</p>
</td></tr>
<tr><td><code id="plframe_+3A_varlabel">varlabel</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="plframe_+3A_side">side</code></td>
<td>
<p>For <code>pltitle</code>: in which margin should the text
be shown?<br />
For <code>plaxis</code>: integer indicating which axis is to be drawn
</p>
</td></tr>
<tr><td><code id="plframe_+3A_csize">csize</code></td>
<td>
<p>character size. May be vector of length 3, giving size for
main title, subtitle, and <code>tit</code> attribute of title,
respectively. The default is given by <code>ploptions("title.cex")</code>.
</p>
</td></tr>
<tr><td><code id="plframe_+3A_csizemin">csizemin</code></td>
<td>
<p>minimal character size, to be used to adjust the
character size to the length of the text (if <code>cex</code> is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plframe_+3A_line">line</code></td>
<td>
<p>line in margin on which the main title is placed &ndash; or the
subtitle if <code>main</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code id="plframe_+3A_adj">adj</code></td>
<td>
<p>text adjustment, scalar between 0 and 1</p>
</td></tr>
<tr><td><code id="plframe_+3A_outer.margin">outer.margin</code></td>
<td>
<p>logical: should title text be placed in outer margin?</p>
</td></tr>
<tr><td><code id="plframe_+3A_col">col</code></td>
<td>
<p>color for the title text or axis line and tickmarks</p>
</td></tr>
<tr><td><code id="plframe_+3A_range">range</code></td>
<td>
<p>range in which tickmarks are set</p>
</td></tr>
<tr><td><code id="plframe_+3A_doc">doc</code></td>
<td>
<p>logical: should the <code>tit</code> attribute of <code>main</code>
be displayed if available?</p>
</td></tr>
<tr><td><code id="plframe_+3A_show">show</code></td>
<td>
<p>logical: if <code>FALSE</code>, nothing will be done if
there are multiple frames and the current one is not the first.
If it is negative, no title will be shown, but the value will be
returned.
</p>
</td></tr>
<tr><td><code id="plframe_+3A_tickintervals">tickintervals</code></td>
<td>
<p>number of intervals used by
<code><a href="base.html#topic+pretty">pretty</a></code> to determine the axis ticks.
</p>
</td></tr>
<tr><td><code id="plframe_+3A_plargs">plargs</code>, <code id="plframe_+3A_ploptions">ploptions</code></td>
<td>
<p>result of <code><a href="#topic+pl.control">pl.control</a></code>, see Details
</p>
</td></tr>
<tr><td><code id="plframe_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>    
<tr><td><code id="plframe_+3A_xy">xy</code></td>
<td>
<p>logical: should the coordinates be obtained as in
high level graphics? This is set to <code>FALSE</code> to save time and
avoid complications, in case the user is sure that <code>x</code> and
<code>y</code> are vectors rather than formulas or variable names.
</p>
</td></tr>
<tr><td><code id="plframe_+3A_...">...</code></td>
<td>
<p>absorbs extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the arguments <code>x</code> and <code>y</code> are not given,
they are obtained from <code>pl.envir$pldata</code>.
</p>
<p><code>plframe</code> draws axes according to argument <code>axes</code>,
by calling <code>plaxis</code>.
It looks for attributes of <code>x</code> and <code>y</code>, such as
<code>innerrange</code> and <code>ticksat</code>.
Tick labels are shown at the values of the <code>ticklabelsat</code>
attribute if available, otherwise at the values of <code>ticksat</code>.
The labels can be given by the attribute <code>ticklabels</code>.
This facilitates setting more tick marks than labels, see the
example.<br />
It also draws a grid.
The positions of gridlines at <code>ticksat</code> by default.<br />
Finally, it draws &quot;zero&quot; lines as determined by the pl option
<code>zeroline</code>. The latter can be a numeric vector giving
the positions of such threshold lines, or a list of two such vectors,
the first for horizontal axis, the second for the vertical axis.
</p>
<p><code>plaxis</code> only shows the variable label, tick labels and tickmarks
if there is enough space or <code>showlabels &gt; 1</code>.
If it is called when there are multiple panels, this is decided
according to the actual <code>mar</code> setting if it is an inner panel;
if it is a panel adjacent to an outer margin, then the <code>oma</code>
setting is also used.
</p>
<p><code>plargs</code> and <code>ploptions</code> may be specified explicitly,
but they are usually generated by calling <code>pl.control</code>.
</p>


<h3>Value</h3>

<p><code>plframe</code> and <code>plaxis</code> invisibly return the former
<code>par(c("cex", "mar", "mgp"))</code>
if <code>setpar</code> is <code>TRUE</code>, otherwise <code>NULL</code>.
</p>
<p><code>pltitle</code> invisibly return a list consisting of the <code>main</code>
and <code>sub</code> title.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><a href="#topic+gendateaxis">gendateaxis</a>; <a href="#topic+pl.control">pl.control</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyx(Sepal.Width ~ Sepal.Length, data=iris)

## again, each step separately
t.dt &lt;- pl.envir$pldata
oldpar &lt;- plframe() ## or plframe(t.dt$Sepal.Length, t.dt$Sepal.Width, plargs=pl.envir)
plsmooth() ## or plsmooth(t.dt$Sepal.Length, t.dt$Sepal.Width, plargs=pl.envir)
t.plab &lt;- plmark(markextremes=0.03)
  ## or plmark(t.dt$Sepal.Length, t.dt$Sepal.Width, markextremes=0.03, plargs=pl.envir)
plpoints(plab=t.plab) ## or plpoints(t.dt$Sepal.Length, t.dt$Sepal.Width,
                      ##      plargs=pl.envir, plab=t.plab)
plaxis(4)

par(oldpar)   ## reset the changed graphical parameters
</code></pre>

<hr>
<h2 id='plgraphics-internal'>Internal 'plgraphics' Objects</h2><span id='topic+is.formula'></span><span id='topic+RNAMES'></span><span id='topic++25nin+25'></span><span id='topic+u.true'></span><span id='topic+u.false'></span><span id='topic+u.notfalse'></span><span id='topic+i.def'></span><span id='topic+u.debug'></span><span id='topic+DB'></span>

<h3>Description</h3>

<p>Internal functions of package <span class="pkg">plgraphics</span> that are exported, but
will normally not be called by the user directly.
They mostly are simple shortcuts, combining two or a few R commands.
</p>

<dl>
<dt>is.formula</dt><dd><p>Check if argument is of <code>mode</code> <code>formula</code></p>
</dd>
<dt>RNAMES</dt><dd><p>coderow.names if <code>x</code> is a matrix or data.frame,
otherwise give the <code>names</code> back</p>
</dd>
<dt>%nin%</dt><dd><p>check which elements of <code>x</code> are not contaied in
<code>y</code></p>
</dd>
<dt>u.true, u.false, u.notfalse</dt><dd><p>check if argument is logical
and <code>TRUE, ...</code></p>
</dd>
<dt>i.def</dt><dd><p>define: if the first argument is
either null or <code>NA</code>, return <code>value</code>,
if it is <code>TRUE</code>, return <code>valuetrue</code>,
if it is <code>FALSE</code>, return <code>valuefalse</code></p>
</dd>      
<dt>u.debug</dt><dd><p>check if <code>ploptions("debug")</code> is <code>TRUE</code></p>
</dd>
<dt>DB</dt><dd><p>set debug level and action:
if argument <code>on</code> if <code>TRUE</code> or <code>&gt;=1</code>,
call <code>browser</code> on error,
if <code>on&gt;1</code>, additionally convert warnings into errors,
if <code>on==0</code>, reset to usual error and warning handling
</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>is.formula(object)
RNAMES(x)
x %nin% y
u.true(x)
u.false(x)
u.notfalse(x)
i.def(arg, value = TRUE, valuetrue = value, valuefalse = FALSE)
u.debug()
DB(on=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plgraphics-internal_+3A_x">x</code>, <code id="plgraphics-internal_+3A_y">y</code>, <code id="plgraphics-internal_+3A_object">object</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects</p>
</td></tr>
<tr><td><code id="plgraphics-internal_+3A_on">on</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="plgraphics-internal_+3A_arg">arg</code>, <code id="plgraphics-internal_+3A_value">value</code>, <code id="plgraphics-internal_+3A_valuetrue">valuetrue</code>, <code id="plgraphics-internal_+3A_valuefalse">valuefalse</code></td>
<td>
<p>see above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see description of purpose</p>


<h3>Examples</h3>

<pre><code class='language-R'>i.def(NA, 10, 20, 30)  ## 10
i.def(TRUE, 10)  ## 10
i.def(TRUE, 10, 20)  ## 20
i.def(FALSE, 10, 20, 0)  ## 0

u.true(1) ## FALSE, since 1 is not of mode logical
u.notfalse(2) ## TRUE
u.notfalse(FALSE) ## FALSE
</code></pre>

<hr>
<h2 id='plinnerrange'>Inner Plotting Limits
</h2><span id='topic+plinnerrange'></span>

<h3>Description</h3>

<p>Calculates inner limits for plotting, based on a robust
estimate of the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plinnerrange(innerrange, data, factor = 4, FUNC = robrange)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plinnerrange_+3A_innerrange">innerrange</code></td>
<td>
<p>logical: Should range be calculated?
If <code>FALSE</code>, the result will contain only the values
<code>FALSE</code>.
If it is a list or matrix of the approriate size, it will be
returned as is.
</p>
</td></tr>
<tr><td><code id="plinnerrange_+3A_data">data</code></td>
<td>
<p>vector or data.frame for which the range(s) will be calculated
</p>
</td></tr>
<tr><td><code id="plinnerrange_+3A_factor">factor</code></td>
<td>
<p>expansion of the calculated robust range to yield the
plotting range
</p>
</td></tr>
<tr><td><code id="plinnerrange_+3A_func">FUNC</code></td>
<td>
<p>function used to calculate the robust range.
The <code>factor</code> will be handed over to <code>FNC</code> as the argument
<code>fac</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of 2 rows giving the ranges to be used as
inner plotting ranges for the variables.
If <code>innerrange</code> is such a matrix or data.frame, it will be returned
as is.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robrange">robrange</a></code>, <code><a href="#topic+plcoord">plcoord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
dd &lt;- d.blast[,c("charge","distance","tremor")]
( t.ipl &lt;- plinnerrange(TRUE, dd) )
plot(dd[,"tremor"], plcoord(dd[,"tremor"], t.ipl[,"tremor"]))
abline(h=t.ipl[,"tremor"])
</code></pre>

<hr>
<h2 id='pllimits'>Determine Inner Plot Range 
</h2><span id='topic+pllimits'></span>

<h3>Description</h3>

<p>The inner plotting range is the range in which
plotting functions of the regr0 package show unmodified coordinates.
This function determines the range for one or more variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pllimits(pllim, data, limfac = NULL, FUNC=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pllimits_+3A_pllim">pllim</code></td>
<td>
<p>either a logical: shall an inner plotting range be
determined? &ndash; or a matrix with 2 rows and <code>NCOL(data)</code> rows,
in which case the suitability will be checked.</p>
</td></tr>
<tr><td><code id="pllimits_+3A_data">data</code></td>
<td>
<p>vector or matrix or data.frame of data for which the inner
plotting range is to be determined</p>
</td></tr>
<tr><td><code id="pllimits_+3A_limfac">limfac</code></td>
<td>
<p>scalar factor by which the range determined by
<code>FUNC</code> is expanded</p>
</td></tr>
<tr><td><code id="pllimits_+3A_func">FUNC</code></td>
<td>
<p>function that determines the range of the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 2 rows containing the minimum and the maximum
of the inner plotting range. The columns correspond to those in
<code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>See Also</h3>

<p><code><a href="#topic+plcoord">plcoord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(0)
  xx &lt;- rt(50, df=3)
  ( pll &lt;- pllimits(TRUE, xx) )
  sum(xx&lt;pll[1,] | xx&gt;pll[2,])  ## 3
</code></pre>

<hr>
<h2 id='plmarginpar'>Set Graphical Parameters According to Those used in the Pl
Function Called Last
</h2><span id='topic+plmarginpar'></span>

<h3>Description</h3>

<p><code>plmarginpar</code> calls <code>par</code> to set the margin widths
<code>mar</code> and <code>mgp</code> equal to those used in the last call of a
high level pl function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmarginpar(plargs = pl.envir, csize = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plmarginpar_+3A_plargs">plargs</code></td>
<td>
<p>list from which the margin parameters are obtained.
If <code>NULL</code>, the default, <code>pl.envir</code> is used. 
</p>
</td></tr>
<tr><td><code id="plmarginpar_+3A_csize">csize</code></td>
<td>
<p>size of plot symbols and text, changes <code>par("cex")</code>
to <code>csize*par("cex")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The old settings of <code>par(c("mar","mgp"))</code> are returned
invisibly.
</p>


<h3>Note</h3>

<p><code>plmarginpar</code> is used to complement a plot with
low level ordinary R functions like <code>mtext</code> or
<code>segments</code>, see Example.
</p>
<p>The same effect can be achieved by setting the pl option
<code>keeppar</code> to <code>TRUE</code>, either by calling <code>ploptions</code>
or by setting <code>keeppar=TRUE</code> in the call to the high level
pl function.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mar=c(2,2,5,2))
plyx(Sepal.Width~Sepal.Length, data=iris) ## margins according to ploptions
par("mar") ## paramteres have been recovered
mtext("wrong place for text",3,1, col="red")  ## margins not appropriate for active plot
plmarginpar()
par("mar") ## margins used inside the call to  plyx . These are now active
mtext("here is the right place",3,1, col="blue")
</code></pre>

<hr>
<h2 id='plmark'>Labels for Extreme Points
</h2><span id='topic+plmark'></span>

<h3>Description</h3>

<p>Determine extreme points and get labels for them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmark(x, y = NULL, markextremes = NULL, plabel = NULL, plargs = NULL, ploptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plmark_+3A_x">x</code>, <code id="plmark_+3A_y">y</code></td>
<td>
<p>coordinates of points. If <code>x</code> is of length 0,
it is retrieved from <code>plargs$pldata[,1]</code>.
</p>
</td></tr>
<tr><td><code id="plmark_+3A_markextremes">markextremes</code></td>
<td>
<p>proportion of extreme points to be 'marked'.
This may be a list of proportions with names
indicating the variables for which the proportion is to be applied.
If a vector (of length 2), the elements define the proportions
for the lower and upper end, respectively.
In the default case (<code>NULL</code>), the proportion is obtained from
<code>ploptions</code>, which in turn leads to calling the function
<code><a href="#topic+markextremes">markextremes</a></code> with the argument equal to the number of
(finite) observations.
</p>
</td></tr>
<tr><td><code id="plmark_+3A_plabel">plabel</code></td>
<td>
<p>character vector of labels to be used for extreme
points. If <code>NULL</code>, they are obtained from <code>plargs$plabel</code>.
</p>
</td></tr>
<tr><td><code id="plmark_+3A_plargs">plargs</code>, <code id="plmark_+3A_ploptions">ploptions</code></td>
<td>
<p>result of <code><a href="#topic+pl.control">pl.control</a></code>, cf
<code><a href="#topic+plpoints">plpoints</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector in which the 'marked' observations contain
the respective label and the others equal <code>""</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plyx">plyx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plyx(Sepal.Width ~ Sepal.Length, data=iris)
  ( t.plab &lt;-
    plmark(iris$Sepal.Length, iris$Sepal.Width, markextremes=0.03) )
</code></pre>

<hr>
<h2 id='plmatrix'>Scatterplot Matrix</h2><span id='topic+plmatrix'></span>

<h3>Description</h3>

<p>Plots a scatterplot matrix, for which the variables shown horizontally
do not necessarily coincide with those shown vertically. If desired,
the matrix is divided into several blocks such that it fills more than
1 plot page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmatrix(x, y = NULL, data = NULL, panel = NULL, 
  nrow = NULL, ncol = nrow, reduce = TRUE, 
  xaxmar=NULL, yaxmar=NULL, xlabmar=NULL, ylabmar=NULL,
  xlab=NULL, ylab=NULL, mar=NULL, oma=NULL, diaglabel.csize = NULL,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plmatrix_+3A_x">x</code></td>
<td>
<p>data for columns (x axis), or formula defining column
variables. If it is a formula containing a left hand side,
the left side variables will be used last.</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_y">y</code></td>
<td>
<p>data or formula for rows (y axis). Defaults to <code>x</code></p>
</td></tr>
<tr><td><code id="plmatrix_+3A_data">data</code></td>
<td>
<p>data.frame containing the variables in case <code>x</code>
or <code>y</code> is a formula</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_panel">panel</code></td>
<td>
<p>a function that generates the marks of the individual
panels, see Details.
</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_nrow">nrow</code>, <code id="plmatrix_+3A_ncol">ncol</code></td>
<td>
<p>maximum number of rows and columns of panels on a page</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_reduce">reduce</code></td>
<td>
<p>if y is not provided and <code>reduce==TRUE</code>,
the first row and the last column are suppressed.</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_xaxmar">xaxmar</code>, <code id="plmatrix_+3A_yaxmar">yaxmar</code></td>
<td>
<p>margin in which the axis (tick marks and
corresponding labels) should be shown: either 1 or 3 for
<code>xaxmar</code> and 2 or 4 for <code>yaxmar</code>.
</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_xlabmar">xlabmar</code>, <code id="plmatrix_+3A_ylabmar">ylabmar</code></td>
<td>
<p>in which margin should the x- [y-] axis be
labelled?</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_xlab">xlab</code>, <code id="plmatrix_+3A_ylab">ylab</code></td>
<td>
<p>not used (introduced to avoid confusion with
<code>xlabmar, ylabmar</code>)</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_mar">mar</code>, <code id="plmatrix_+3A_oma">oma</code></td>
<td>
<p>width of margins, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plmatrix_+3A_diaglabel.csize">diaglabel.csize</code></td>
<td>
<p>Character expansion for labels appearing in the
&quot;diagonal&quot; of the scatterplot matrix (if present)</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_assign">assign</code></td>
<td>
<p>logical: Should the plargs be stored in the <code>pl.envir</code>
environment?
</p>
</td></tr>
<tr><td><code id="plmatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>panel</code> function
and possibly further to functions called by the panel function<br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>panel</code> function can be user written. It needs <code class="reqn">&gt;=5</code>
arguments which must correspond to the arguments of
<code><a href="#topic+plpanel">plpanel</a></code>: <code>x, y, indx, indy, plargs</code>.
If some arguments are not used, just introduce them as arguments
to the function anyway in order to avoid (unnecessary) error messages
and stops.
<br />
Since large scatterplot matrices lead to tiny panels, <code>plmatrix</code>
splits the matrix into blocks of at most <code>nrow</code> rows and
<code>ncol</code> columns. If these numbers are missing, they default to
<code>nrow=5</code> and <code>ncol=6</code> for landscape pages, and to
<code>nrow=8</code> and <code>ncol=5</code> for portrait pages.
</p>
<p>The <code>panel</code> argument defaults to <code>plpanel</code>, which results
essentially in <code><a href="graphics.html#topic+points">points</a></code> or <code><a href="graphics.html#topic+text">text</a></code>
depending on the argument <code>pch</code>, including a smooth line,
to <code><a href="#topic+plmboxes">plmboxes</a></code> if  'x'  is a factor and  'y'  is not or
vice versa,
or to a modification of <code>sunflowers</code> if both are factors.<br />
The function must have the arguments <code>x</code> and <code>y</code>
to take the coordinates of the points and may have the arguments
<code>indx</code> and <code>indy</code> to transfer the variables\' index.
If there is an argument <code>plargs</code>, the current value of
<code>plargs</code> will be passed on. It is a list and can be extended
to pass any additional items to the function.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Note</h3>

<p>There are many more arguments, obtained from <code>pl.control</code>,
see <code>?<a href="#topic+pl.control">pl.control</a></code>. These can be passed to <code>plmatrix</code>
by an argument <code>plargs</code> that is hidden in the ... argument list.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="#topic+plyx">plyx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plmatrix(iris, pch=as.numeric(Species))
plmatrix(~Sepal.Length+Sepal.Width, ~Petal.Length+Petal.Width,
    data=iris, smooth=TRUE, plab=substr(Species,1,2))
</code></pre>

<hr>
<h2 id='plmboxes'>
Multibox plots
</h2><span id='topic+plmboxes'></span><span id='topic+plmboxes.default'></span><span id='topic+plmboxes.formula'></span><span id='topic+plmbox'></span>

<h3>Description</h3>

<p>Draw multibox plot(s) for given (grouped) values, possibly asymmetric.
'plbox' draws a single multibox plot (low level graphical function).
'plboxes' is a high level graphics function that draws multiboxes for
grouped data. A secondary, binary grouping factor can be given
to produce asymmetric multiboxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmboxes(x, ...)
## S3 method for class 'formula'
plmboxes(x, y=NULL, data, ...)

## Default S3 method:
plmboxes(x=NULL, y=NULL, data=NULL, width=1, at=NULL,
    horizontal=FALSE,
    probs=NULL, outliers=TRUE, na=FALSE, backback=NULL, refline=NULL,
    add=FALSE, xlim=NULL, ylim=NULL, axes=TRUE, xlab=NULL, ylab=NULL,
    labelsperp=FALSE, xmar=NULL, mar=NULL,
    widthfac=NULL, minheight=NULL, colors=NULL, lwd=NULL, 
    .subdefault=NULL, plargs = NULL, ploptions = NULL, marpar = NULL, ...)

plmbox(x, at=0, probs=NULL, outliers=TRUE, na.pos=NULL, horizontal=FALSE,
    width=1, wfac=NULL, minheight=NULL, adj=0.5, extquant=FALSE, 
    widthfac=c(max=2, med=1.3, medmin=0.3, outl=NA),
    colors=c(box="lightblue2",med="blue",na="gray90"),
    lwd=c(med=3, range=2), warn=options("warn"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plmboxes_+3A_x">x</code></td>
<td>
<p>For 'plmboxes.formula':
a formula, such as 'y ~ grp' or 'y~grp+grp2',
where 'y' is a numeric vector of data values to be split into groups
according to the grouping variable 'grp' (usually a factor)
and, if given, according to the binary variable 'grp2'.
'y~1+grp2' produces a single asymmetric mbox.
</p>
<p>For 'plmboxes.default':
factor to be used as the grouping variable or matrix or data.frame
with 2 columns (for asymmetric mbox plot), where the second column
is binary.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_data">data</code></td>
<td>
<p>a data.frame from which the variables in 'formula'
should be taken.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_width">width</code></td>
<td>
<p>a vector giving the widths of the multibox plot
for each group 'grp1'. 
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_at">at</code></td>
<td>
<p>horizontal position of the multiboxes. Must have length equal
to the number of (present) levels of the factor 'grp'.
if an element of 'at' is 'NA', the group will be skipped.
Defaults to 1, 2, ...
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. If TRUE, boxes will be drawn horizontally.
Note that 'y' is then the horizontal coordinate, i.e., still the
quantitative variable defining the boxes, and 'x' is still the
grouping.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_probs">probs</code></td>
<td>
<p>probability values for selecting the quantiles.
If all 'probs' are &lt;=0.5, they will be mirrored at 0.5 for
'plmboxes'. The default is c(0.05,0.25,0.5) if the average number of
data per group (for 'plmboxes', or the number of data, for 'plmbox')
is less than 20, c(0.025,0.05,0.125,0.25,0.375,0.5), otherwise. 
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_outliers">outliers</code></td>
<td>
<p>logical: should outliers be marked?
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_na">na</code>, <code id="plmboxes_+3A_na.pos">na.pos</code></td>
<td>
<p>if 'na' is not NULL, NA values will be represented by
a box.
If 'na' is TRUE, the position of the box will be generated to be below
the minimum of the data.
If 'na' (for 'plmboxes') or 'na.pos' (for 'plmbox') is a scalar or
a vector of length 2,
the position of the box is at that value (with a generated width) or
between the 2 values, respectively.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_backback">backback</code></td>
<td>
<p>logical: Should two back-to-back multiboxes be
displayed if the (single) x factor is binary?
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_refline">refline</code></td>
<td>
<p>vertical positions of any horizontal reference lines
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_add">add</code></td>
<td>
<p>logical. If TRUE, the mboxes will be added to an existing
plot without calling 'plot'.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_xlim">xlim</code></td>
<td>
<p>plotting limits for the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_ylim">ylim</code></td>
<td>
<p>plotting limits for the vertical axis.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_axes">axes</code></td>
<td>
<p>logical. If FALSE, no axes are drawn.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis. Defaults to the &quot;x factor&quot; &ndash;
the first name on the right hand side of 'formula'
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_ylab">ylab</code></td>
<td>
<p>label for the x axis. Defaults to the left hand side of
'formula'.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_labelsperp">labelsperp</code></td>
<td>
<p>logical: Should the labels for the levels of the
&quot;x factor&quot; be shown in perpendicular to the axis?
If it is numeric, it determines the maximum label length, with a
maximum of 20.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_xmar">xmar</code></td>
<td>
<p>plot margin for the &quot;x factor&quot; axis.
Default tries to be suitable, i.e. expand the margin if
<code>labelsperp</code> is <code>TRUE</code> according to the length of the
levels' labels. If <code>xmar</code> has two more elements,
they determine the margin lines where the variable label and the levels'
labels are shown.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_mar">mar</code></td>
<td>
<p>margin widths</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_widthfac">widthfac</code></td>
<td>
<p>named vector used to modify the following settings:
<br />  
max=2: determes the maximal width of the boxes.
Boxes that should be wider are censored and marked as such.
<br />
med=1.3, medmin=0.3: determine the width of the mark for the data median.
The width is 'med' times the maximal width of the boxes,
but at least 'medmin'.
<br />
outl=NA: length of the marks for outliers.
<br />
sep=0.003: width of the gap between the &quot;half&quot; mbox plots in case of
asymmetric mboxes (only needed for 'plmboxes').
<br />
For 'plmboxes', the argument needs to contain only the elements that
should be different from the default values.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_colors">colors</code></td>
<td>
<p>named vector or list selecting the colors to be used,
with named elements:
</p>
<p>box=&quot;lightblue2&quot;: color with which the central box(es)
(those corresponding to probabilieties between 0.25 and 0.75)
will be filled.
</p>
<p>med=&quot;blue&quot;: color of the mark for the median.
</p>
<p>na=&quot;grey90&quot;: color with which the box for NA values will be filled.
</p>
<p>For 'plmboxes', the argument needs to contain only the elements that
should be different from the default values.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_lwd">lwd</code></td>
<td>
<p>named vector or list selecting the line width to be used,
with named elements:
</p>
<p>med=3: line width for the mark showing the median
</p>
<p>range=2: line width for the line along the range of the data
</p>
<p>For 'plmboxes', the argument needs to contain only the elements that
should be different from the default values.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_...">...</code></td>
<td>
<p>additional arguments passed to 'plot'
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_.subdefault">.subdefault</code></td>
<td>
<p>text for the subtitle in case that it is not
specified
</p>
</td></tr>
</table>
<p>Specific arguments for 'plmbox':
</p>
<table>
<tr><td><code id="plmboxes_+3A_wfac">wfac</code></td>
<td>
<p>factor by which the widths of the boxes must be multiplied.
If given, it overrides 'width'
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_minheight">minheight</code></td>
<td>
<p>minimal class width (&quot;height&quot;) for the boxes (in case
two quantiled are [almost] identical). The default is 0.02 times
the (median of the within group) IQR.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_adj">adj</code></td>
<td>
<p>adjustment of the boxes. 'adj=0' leads to boxes aligned on
the left, 'adj=1', on the right, 'adj=0.5', centered. Other values of
'adj' make little sense.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_extquant">extquant</code></td>
<td>
<p>logical, passed to <code><a href="#topic+quinterpol">quinterpol</a></code>:
Should the quantiles be extrapolated beyond the range of the data?
This may make sense if the sample is small or the data is rounded
or grouped or a score.
</p>
</td></tr>
<tr><td><code id="plmboxes_+3A_warn">warn</code></td>
<td>
<p>level of warning for the case when there is no non-missing data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multibox plot is a generalization (and modification) of the
ordinary box plot that draws more details of the distribution in the
form of a histogram with variable class widths.
The classes are selected such that preselected quantiles form the
class breaks. By default, these quantiled include the median and the
quartiles, thereby recovering the box of the traditional box plot.
</p>


<h3>Value</h3>

<p><code>plmboxes</code> invisibly returns the 'at' values that are finally
used.\
<code>plmbox</code> returns a scalar by which the width of the boxes are
multiplied for plotting, 
and, as attributes, the quantiles and widths used to draw the boxes
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plmboxes(Sepal.Length~Species, data=iris)

plmboxes(Sepal.Length~Species, data=iris,
  widthfac=c(med=2), colors=c(med="red"), horizontal=TRUE)

plmboxes(Sepal.Length~factor(Species)+I(Sepal.Width&lt;=3), data=iris[1:100,],
         labelsperp=TRUE, horizontal=TRUE)
</code></pre>

<hr>
<h2 id='plmframes'>Multiple Frames for Plotting</h2><span id='topic+plmframes'></span>

<h3>Description</h3>

<p>This is a short-cut to set some graphical parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plmframes(mfrow = NULL, mfcol = NULL, mft = NULL, byrow = TRUE, reduce = FALSE, 
  oma = NULL, mar = NULL, mgp = NULL, plargs = NULL, ploptions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plmframes_+3A_mfrow">mfrow</code>, <code id="plmframes_+3A_mfcol">mfcol</code></td>
<td>
<p>number of rows and columns of panels. The default
is 1 for both, which will reset the subdivision of the plotting page.</p>
</td></tr>
<tr><td><code id="plmframes_+3A_mft">mft</code></td>
<td>
<p>total number of panels, to be split into <code>mfrow</code>
and <code>mfcol</code> by the function. The result depends on the current
aspect ratio (ratio of height to width) of the plotting area.</p>
</td></tr>
<tr><td><code id="plmframes_+3A_byrow">byrow</code></td>
<td>
<p>if TRUE, the panels will be generated by rows, otherwise, by
columns</p>
</td></tr>
<tr><td><code id="plmframes_+3A_reduce">reduce</code></td>
<td>
<p>logical: If the number of rows or columns asked for by
<code>mfrow</code> or <code>mfcol</code> exceeds the maximum numbers determined
from <code>ploptions("mframesmax")</code>, suitable numbers for multiple
pages are calculated. If <code>reduce</code> is <code>TRUE</code>, these
suggested numbers are applied.
</p>
</td></tr>
<tr><td><code id="plmframes_+3A_mar">mar</code></td>
<td>
<p>plot margins.
Any <code>NA</code>s in <code>mar</code> will be replaced by appropriate values.
</p>
</td></tr>
<tr><td><code id="plmframes_+3A_oma">oma</code></td>
<td>
<p>outer plot margins.
Any <code>NA</code>s will be replaced by appropriate values.
</p>
</td></tr>
<tr><td><code id="plmframes_+3A_mgp">mgp</code></td>
<td>
<p>margin-pars passed to <code><a href="graphics.html#topic+par">par</a>(...)</code>.
If <code>NULL</code>, it will be generated.
</p>
</td></tr>
<tr><td><code id="plmframes_+3A_plargs">plargs</code>, <code id="plmframes_+3A_ploptions">ploptions</code></td>
<td>
<p>result of calling <code>pl.control</code>, used
for generating appropriate values for the margin parameters.
If <code>NULL</code>, <code>pl.envir</code> will be used.
</p>
</td></tr>
<tr><td><code id="plmframes_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to
<code><a href="graphics.html#topic+par">par</a>(...)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code>par</code>. Its purpose is to simplify a call like
<code>par(mfrow=c(3,4))</code> to <code>plmframes(3,4)</code> and to set some
defaults differently from <code>par</code>.
</p>


<h3>Value</h3>

<p>A named <code>list</code> containing the old values of the parameters,
as for <code>par</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plmframes(2,3)
plmframes(mft=15)  ## will split the plotting area into &gt;= 15 panels,
plmframes()  ## reset to 1 panel

t.plo &lt;- ploptions(mframesmax=9, assign=FALSE)
t.mf &lt;- plmframes(4,4, reduce=TRUE, ploptions=t.plo)
par("mfg")  
t.mf[c("mfigsug","npages")]
##  $mfigsug
##  [1] 2 4
##  $npages
##  [1] 2 1
##  if the device area was higher than wide,
##  the result is the other way 'round
t.mft &lt;- plmframes(mft=12, reduce=TRUE, ploptions=t.plo)

</code></pre>

<hr>
<h2 id='ploptions'>Set and Get User &quot;Session&quot; Options that Influence &quot;plgraphics&quot;s Behavior</h2><span id='topic+ploptions'></span><span id='topic+default.ploptions'></span>

<h3>Description</h3>

<p>The user can set (and get) 'pl' options &ndash; mostly graphical &quot;parameters&quot; &ndash;
which influence the behavior <span class="pkg">plgraphics</span> functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ploptions(x = NULL, ploptions = NULL, list = NULL, default = NULL, 
          assign = TRUE, ...)

default.ploptions
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ploptions_+3A_x">x</code></td>
<td>
<p>character (vector) of name(s) of ploptions to query.
If <code>x</code> is set, all further arguments will be ignored.
</p>
</td></tr>
<tr><td><code id="ploptions_+3A_ploptions">ploptions</code></td>
<td>
<p>the list of options that should be inspected or
modified. Defaults to <code>usr.ploptions</code> from the <code><a href="#topic+pl.envir">pl.envir</a></code>
environment. <code>ploptions&gt;1</code> is equivalent to
<code>ploptions=pl.envir$ploptions</code>, the last (or current) list
used by a high level pl function.</p>
</td></tr>
<tr><td><code id="ploptions_+3A_list">list</code></td>
<td>
<p>a named list of options to be set, see Details</p>
</td></tr>
<tr><td><code id="ploptions_+3A_default">default</code></td>
<td>
<p>character vector of option names.
These ploptions will be set according to <code>default.ploptions</code>.
<code>default="all"</code> or <code>=TRUE</code> will reset all options.
If <code>default</code> is set, all further arguments will be ignored.
</p>
</td></tr>
<tr><td><code id="ploptions_+3A_assign">assign</code></td>
<td>
<p>logical: should the list be assigned to
<code>pl.envir$usr.ploptions</code>? It is then permanant until changed
again by calling <code>ploptions</code> again or the session is closed.
If <code>&gt;1</code>, the resulting options are stored as
<code>ploptions</code> in <code><a href="#topic+pl.envir">pl.envir</a></code>, which is changed
by the high level pl functions.
</p>
</td></tr>
<tr><td><code id="ploptions_+3A_...">...</code></td>
<td>
<p>any ploptions can be defined or modified,
using <code>name = value</code>, as in <code><a href="base.html#topic+options">options</a></code> of basic R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument <code>list</code> is set, it must be a named list,
and each component, with name <code>name</code> and value <code>value</code>
is used as described for arguments in <code>...</code>, see above
(in addition to such arguments).
</p>
<p>There is an object <code>ploptions</code> in the <code>pl.envir</code>
environment, which contains the ploptions that have been used
(usually after modification) by the high level pl function
last called. This list is used by subsequent calls of lower level pl
functions. Advanced uses may want to modify this list by assigning to
<code>pl.envir$ploptions$pch</code>, for example.
</p>
<p>Here is an incomplete list of the components of <code>default.ploptions</code>,
describing the suitable alternative values to be set by calling
<code>ploptions</code>. For the full set, see
<code>?<a href="#topic+ploptions.list">ploptions.list</a></code>.

</p>

<dl>
<dt>keeppar:</dt><dd><p> logical. If TRUE, the graphical parameter settings 
&quot;mar&quot;, &quot;oma&quot;, &quot;cex&quot;, &quot;mgp&quot;, and &quot;mfg&quot; will be maintained when
leaving high level pl functions, 
otherwise, the old values will be restored (default).</p>
</dd>
<dt>colors:</dt><dd><p> The palette to be used by pl functions</p>
</dd>
<dt>csize:</dt><dd><p> General character size, relative to <code>par("cex")</code></p>
</dd>
<dt>pale:</dt><dd><p> default argument for <code><a href="#topic+colorpale">colorpale</a></code></p>
</dd>
<dt>tickintervals:</dt><dd><p> vector of length 2. The first element is the
desired number of tick intervals for axes, to be used as argument
<code>n</code> in <code><a href="base.html#topic+pretty">pretty</a></code>.
The second determines how many tick labels are shown in the same
way, and should therefore be smaller than (or equal to) the first.
</p>
</dd>
<dt>pch:</dt><dd><p> plotting symbols or characters</p>
</dd>
<dt>csize.pch:</dt><dd><p> size of plotting symbols, relative to default.
This may be a function with an argument that will be the number of
observations at the time it is used.</p>
</dd>
<dt>csize.plab:</dt><dd><p> size of point labels, relative to <code>csize.pch</code></p>
</dd>
<dt>psize.max:</dt><dd><p> maximum value of size of plotting symbols</p>
</dd>
<dt>lty, lwd:</dt><dd><p> line type(s) and width(s) </p>
</dd>
<dt>col, pcol, lcol:</dt><dd><p> colors to be used generally and
specifically for points (symbols or text) and lines, respectively,
given as index of <code>ploptions("colors")</code>.
This are often (and by default) vectors to be used for showing
groups. The first element is usually black.
</p>
</dd>
<dt>colors:</dt><dd><p> the palette to be used</p>
</dd>
<dt>censored.pch, censored.size, censored.pale:</dt><dd><p> ...</p>
</dd>
<dt>gridlines:</dt><dd><p>  can be <br /> 
&ndash; a logical indicating if gridlines should be drawn. If
<code>TRUE</code>, gridlines will be drawn at the values given in
<code>attr(.,"ticksat")</code>;
&ndash; a vector of values at which the gridlines should appear;<br />
&ndash; a list of length 2 of such values;<br />
&ndash; a named list. If a name equals the attribute <code>varname</code>
of either the x or y variable, the respective component will be
used.
</p>
</dd>
<dt><code>smooth.lty, smooth.col</code>:</dt><dd><p> line type and color.
Note that if there is a <code>smooth.group</code> factor,
<code>group.lty</code> and <code>group.col</code> are used.
</p>
</dd>
<dt><code>smooth.lwd</code>:</dt><dd><p> line width. If of length 2 (or more),
the second element is the factor by which the line width is
reduced for simulated smooths (that is, for the second to the last
column of <code>smoothline$y</code>). It defaults to 0.7.
</p>
</dd>
<dt>smooth.xtrim:</dt><dd><p> proportion of fitted values to be trimmed off on
both sides when drawing a smooth line, either a number or a function
that takes the number of points as its argument.
The default is the simple function <code>2^log10(n)/n</code>.
The smoothing function may produce an attribute <code>xtrim</code>
that is used as an additional factor to <code>smooth.xtrim</code>.
This is applied, e.g., to suppress trimming if a straight line is
fitted instead of a smooth by requiring <code>smoothLm</code> as the
smoothing function.
</p>
</dd>
<dt>smooth.minobs:</dt><dd><p> minimal number of observations needed for
calculating a smooth.</p>
</dd>
<dt>smooth.band:</dt><dd><p> Indicator (logical) determining
whether &quot;low&quot; and &quot;high&quot; smooth lines should be drawn.
See above for their definition.</p>
</dd>
<dt>condquant...:</dt><dd><p> Conditional quantiles for censored residuals.
</p>

<dl>
<dt>condquant:</dt><dd><p> logical: should bars be drawn for censored residuals?
If <code>FALSE</code>, censored observations will be set to the median of
the conditional distribution and shown by a different plotting
character, see argument <code>censored</code> of
<code><a href="#topic+ploptions">ploptions</a></code>.
If <code>NULL</code>, the standard plotting character will be used.
</p>
</dd>
<dt>condquant.probrange:</dt><dd><p> range for probabilities.
If the probability corresponding to the censored part of the
distribution is outside the range, bars will not be drawn.</p>
</dd>
<dt>condquant.pale:</dt><dd><p> factor by which the <code>pcol</code> color
will be paled to show the points (<code>condquant.pale[1]</code>)
and the bars (<code>...[2]</code>).
</p>
</dd>
</dl>

</dd>
<dt>plcond...:</dt><dd><p> features of <code><a href="#topic+plcond">plcond</a></code>.
</p>

<dl>
<dt>plcond/panel:</dt><dd><p> panel function to be used</p>
</dd>
<dt>plcond.nintervals:</dt><dd><p> number of intervals into which
numerical variables will be cut</p>
</dd>
<dt>plcond.extend:</dt><dd><p> proportion of neighboring intervals for
which points are shown. 0 means no overlap.</p>
</dd>
<dt>plcond.col:</dt><dd><p> 4 colors to be used to mark the points of
the neighboing intervals:
The first and second ones color the points lower or higher
than the interval of the horizontal conditioning variable,
and the other two regulating the same features for the
vertical variable.
The points which are outside the intervals of both
conditioning variables will get a mixed color.</p>
</dd>
<dt>plond.pale:</dt><dd><p> minimum and maximum paling, to be applied
for distance 0 and maximal distance from the interval.</p>
</dd>
<dt>plcond.cex:</dt><dd><p> symbol size, relative to <code>cex</code>, used to
show the points outside the interval</p>
</dd>
</dl>

</dd>
</dl>



<h3>Value</h3>

<p>For <code>ploptions(x)</code>, where <code>x</code> is the name of a pl option,
the current value of the option,
or <code>NULL</code> if it is not such a name.
If <code>x</code> contains several (valid) names, the respective list.
</p>
<p>For <code>ploptions()</code>, the list of all plptions sorted by name.  
</p>
<p>For uses setting one or more options, the important effect is a changed
list <code>usr.ploptions</code> in the <code><a href="#topic+pl.envir">pl.envir</a></code> environment
that is used by the package's functions
(if <code>assign</code> is <code>TRUE</code>).
The (invisibly) returned value is the same list, complemented by an
attribute <code>"old"</code> containing the previous values of those options
that have been changed.
This list is useful for undoing the changes to restore
the previous status.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>See Also</h3>

<p><code><a href="#topic+stamp">stamp</a></code>; <code><a href="#topic+ploptions.list">ploptions.list</a></code>;
<code><a href="#topic+pl.envir">pl.envir</a></code>;
<span class="rlang"><b>R</b></span>'s own predefined <code><a href="base.html#topic+options">options</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get options
ploptions(c("jitter.factor", "gridlines"))
ploptions("stamp")  ## see example(stamp)
ploptions()  ## all pl options, see '?ploptions.list'

## set options
ploptions(stamp=FALSE, pch=0, col=c.colors[-1], anything="do what you want")
ploptions(c("stamp", "anything"))
ploptions(default=TRUE)  ## reset all pl options, see '?ploptions.list'

## assign to transient options 
t.plopt &lt;- ploptions(smooth.col="purple", assign=2) 
t.plopt$smooth.col
attr(t.plopt, "old")
ploptions("smooth.col") ## unchanged
ploptions("smooth.col", ploptions=2) ## transient options
pl.envir$ploptions["smooth.col"] ## the same

## switching 'margin parameters' between those used
## outside and inside high level pl functions
par(mar=c(2,2,5,2))
plyx(Sepal.Width~Sepal.Length, data=iris, title="The famous iris data set")
par("mar")
mtext("wrong place for text",3,1, col="red")
t.plo &lt;- plmarginpar()
par("mar")
mtext("here is the right place",3,1)

par(attr(t.plo, "oldpar"))  ## resets the 'margin parameters'
par("mar")
plyx(Sepal.Width~Sepal.Length, data=iris, keeppar=TRUE)
par("mar")

## manipulating 'pl.envir$ploptions'
plyx(Sepal.Width~Sepal.Length, data=iris)
pl.envir$ploptions$pch
plpoints(7,4, csize=4)
pl.envir$ploptions$pch &lt;- 4
plpoints(7.5,4, csize=4)

</code></pre>

<hr>
<h2 id='ploptions.list'>The List of pl Options</h2><span id='topic+ploptions.list'></span>

<h3>Description</h3>

<p>The user can set (and get) 'pl' options &ndash; mostly graphical &quot;parameters&quot; &ndash;
which influence the behavior of <span class="pkg">plgraphics</span> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## not used, this gives the complete list of 'pl' options
</code></pre>


<h3>Value</h3>


<dl>
<dt>keeppar:</dt><dd><p> logical. If TRUE, the graphical parameter settings 
&quot;mar&quot;, &quot;oma&quot;, &quot;cex&quot;, &quot;mgp&quot;, and &quot;mfg&quot; will be maintained when
leaving high level pl functions, 
otherwise, the old values will be restored (default).</p>
</dd>
<dt>colors:</dt><dd><p> The palette to be used by pl functions</p>
</dd>
<dt>pale:</dt><dd><p> default argument for <code><a href="#topic+colorpale">colorpale</a></code></p>
</dd>
<dt>linewidth:</dt><dd><p> vector of <code>lwd</code> values to be used for
the different line types (<code>lty</code>). The package
sets <code>lwd</code> to a value
<code>ploptions("linewidth")[lty]*lwd</code> intending to balance
the visual impact of the different line types, e.g.,
to allow a dotted line to make a similar impression as a solid
line.</p>
</dd>
<dt>csize:</dt><dd><p> General character size, relative to <code>par("cex")</code></p>
</dd>
<dt>ticklength:</dt><dd><p> vector of 4 scalars: tickmark length,
corresponding to <code>par("tcl")</code>. The first 2 elements
define the length of the regular tickmarks, the other two,
of the &ldquo;small&rdquo; tichmarks given by
<code>attr(ticksat, "small")</code> (<code>ticksat</code> is a possible
attribute of each variable).
There are two elements each in order to define tickmarks that
cross the axis.
</p>
</dd>
<dt>tickintervals:</dt><dd><p> vector of length 2. The first element is the
desired number of tick intervals for axes, to be used as argument
<code>n</code> in <code><a href="base.html#topic+pretty">pretty</a></code>.
The second determines how many tick labels are shown in the same
way, and should therefore be smaller than (or equal to) the first.
</p>
</dd>
<dt>pch:</dt><dd><p> plotting symbols or characters</p>
</dd>
<dt>csize.pch:</dt><dd><p> size of plotting symbols, relative to default.
This may be a function with an argument that will be the number of
observations at the time it is used.</p>
</dd>
<dt>csize.plab:</dt><dd><p> size of point labels, relative to <code>csize.pch</code></p>
</dd>
<dt>psize.max:</dt><dd><p> maximum value of size of plotting symbols</p>
</dd>
<dt>lty, lwd, col, pcol, lcol:</dt><dd><p> line type, line width, color to
be used</p>
</dd>
<dt>pcol, lcol:</dt><dd><p> color to be used for plotting symbols and
labels, respectively</p>
</dd>
<dt>***</dt><dd><p>innerrange</p>
</dd>
</dl>

<dl>
<dt>innerrange</dt><dd><p> logical: should an innerrange be used in plots
if needed?</p>
</dd>
<dt>innerrange.factor</dt><dd><p> factor needed to determined the inner
range</p>
</dd>
<dt>innerrange.ext</dt><dd><p> extension of the inner range</p>
</dd>
<dt>innerrange.function</dt><dd><p> function used to calculate the inner
range</p>
</dd>
</dl>

<dl>
<dt>plext</dt><dd><p> extension of the data range to the plotting range</p>
</dd>
<dt>markextremes</dt><dd><p> proportion of observations to be marked by
their labels on the lower and upper extremes</p>
</dd>
<dt>variables.pch, variables.col, variables.lty,
variables.lcol:</dt><dd><p> vectors of symbols, color, line type, line color
to be used for showing different y variables</p>
</dd>
<dt>censored.pch, censored.size, censored.pale:</dt><dd><p> plotting symbol
and size, and pale value to be applied to censored observations.
Different symbols are used for distinguishing right and left
censoring in vertical and horizontal direction and there
combination.
</p>
</dd>
<dt>group.pch, group.col, group.lty, group.lcol:</dt><dd><p> vector of
symbols and colors used for observations and types and colors used
for lines in the different groups
</p>
</dd>
<dt>***</dt><dd><p>title parameters.
</p>

<dl>
<dt>title.line</dt><dd><p> line in margin[3] on which the title
appears</p>
</dd>
<dt>title.adj</dt><dd><p> adjustment of the title</p>
</dd>
<dt>title.csize</dt><dd><p> character size of the title, relative to
<code>ploptions("csize")*ploptions("margin.csize")[1]</code></p>
</dd>
<dt>title.csizemin</dt><dd><p> minimum csize</p>
</dd>
<dt>title.maxchars</dt><dd><p> maximum number of characters in title</p>
</dd>
<dt>sub</dt><dd><p> logical: should subtitle be shown?</p>
</dd>
</dl>

</dd>
<dt>xlab, ylab</dt><dd><p> labels of x and y axes</p>
</dd>
<dt>mframesmax</dt><dd><p> maximum number of panels to be shown on one page</p>
</dd>
<dt>panel</dt><dd><p> panel function to be used in high level pl functions</p>
</dd>
<dt>axes:</dt><dd><p> axes to be shown</p>
</dd>
<dt>***</dt><dd><p>margin parameters.
</p>

<dl>
<dt>mar, oma</dt><dd><p> ...</p>
</dd>
<dt>mar.default, oma.default</dt><dd><p> their default values</p>
</dd>
<dt>margin.csize</dt><dd><p> character size for variable labels and
tick labels</p>
</dd>
<dt>margin.line</dt><dd><p> lines in margin where variable labels and
tick labels are shown</p>
</dd>
<dt>margin.exp</dt><dd><p> expansion of margins beyond needed lines,
for inner and outer margins</p>
</dd>
<dt>panelsep</dt><dd><p> space between panels</p>
</dd>
</dl>

</dd>
<dt>***</dt><dd><p>date parameters.
</p>

<dl>
<dt>date.origin</dt><dd><p> The year which serves as origin of the
internal (julian) date scale</p>
</dd>
<dt>date.format</dt><dd><p> format for showing dates</p>
</dd>
<dt>date.ticks</dt><dd><p> data.frame ruling
how many small and large ticks and tick labels will be shown.
The first column determines the row that will be used</p>
</dd>
</dl>

</dd>
<dt>gridlines:</dt><dd><p>  can be <br /> 
&ndash; a logical indicating if gridlines should be drawn. If
<code>TRUE</code>, gridlines will be drawn at the values given in
<code>attr(.,"ticksat")</code>;
&ndash; a vector of values at which the gridlines should appear;<br />
&ndash; a list of length 2 of such values;<br />
&ndash; a named list. If a name equals the attribute <code>varname</code>
of either the x or y variable, the respective component will be
used.
</p>
</dd>
<dt>zeroline:</dt><dd><p> logical: should zero (0) be shown be a special
grid line?
Can be numerical, then gives coordinates of such lines,
generalizing the zero line.</p>
</dd>
<dt>zeroline.lty, zeroline.lwd, zeroline.col</dt><dd><p> line type, width
and color of the zero line</p>
</dd>
<dt>refline</dt><dd><p> reference line, any line to be added to the current
plot using the following properties. See <code><a href="#topic+plrefline">plrefline</a></code>
for possible types of values</p>
</dd>
<dt>refline.lty, refline.lwd, refline.col</dt><dd><p> line type, width
and color of the ref line</p>
</dd>
<dt>***</dt><dd><p>smooth.
</p>

<dl>
<dt>smooth</dt><dd><p>logical: should a smoothing line be shown?</p>
</dd>
<dt>smooth.function:</dt><dd><p> function for calculating the smoother</p>
</dd>
<dt>smooth.par, smooth.iter</dt><dd><p>parameters for the function</p>
</dd>
<dt>smooth.minobs:</dt><dd><p> minimal number of observations needed for
calculating a smooth.</p>
</dd>
<dt>smooth.band:</dt><dd><p> Indicator (logical) determining
whether &quot;low&quot; and &quot;high&quot; smooth lines should be drawn.
See above for their definition.</p>
</dd>
<dt><code>smooth.lty, smooth.col</code>:</dt><dd><p> line type and color.
Note that if there is a <code>smooth.group</code> factor,
<code>group.lty</code> and <code>group.col</code> are used.</p>
</dd>
<dt><code>smooth.lwd</code>:</dt><dd><p> line width. If of length 2 (or more),
the second element is the factor by which the line width is
reduced for simulated smooths (that is, for the second to the last
column of <code>smoothline$y</code>). It defaults to 0.7.</p>
</dd>
<dt>smooth.pale</dt><dd><p>paling factor to be applied for secondary
smooth lines</p>
</dd>
<dt>smooth.xtrim:</dt><dd><p> proportion of fitted values
to be trimmed off on both sides when drawing a smooth line,
either a number or a function
that takes the number of points as its argument.
The default is the simple function <code>2^log10(n)/n</code>.
The smoothing function may produce an attribute <code>xtrim</code>
that is used as an additional factor to <code>smooth.xtrim</code>.
This is applied, e.g., to suppress trimming if a straight line is
fitted instead of a smooth by requiring <code>smoothLm</code> as the
smoothing function.
</p>
</dd>
</dl>

</dd>
<dt>bar.midpointwidth</dt><dd><p>width of the line shown at the central
point of a bar</p>
</dd>
<dt>bar.lty, bar.lwd, bar.col</dt><dd><p>line type, width (for bar and
midpoint line), color of bars</p>
</dd>
<dt>***</dt><dd><p>factors, multibox plots:
</p>

<dl>
<dt>factor.show:</dt><dd><p>how should factors be plotted.
Options are <code>"mbox"</code>, <code>"jitter"</code> or <code>"asis"</code></p>
</dd>
<dt>mbox.minobs</dt><dd><p>minimal number of observations shown as a
multibox plot</p>
</dd>
<dt>mbox.minheigth</dt><dd><p>see <code>?<a href="#topic+plmboxes">plmboxes</a></code></p>
</dd>
<dt>mbox.colors</dt><dd><p>colors to be used for multibox plots</p>
</dd>
<dt>jitter</dt><dd><p>amount of jitter,
or logical: should jittering be applied?</p>
</dd> 
<dt>jitter.minobs</dt><dd><p>minimal number of observations to which
jittering should be applied</p>
</dd>
<dt>jitter.factor</dt><dd><p>what proportion of the gap between
different values will be filled by the jittering?</p>
</dd>
</dl>

</dd>
<dt>***</dt><dd><p>condquant: Conditional quantiles for censored residuals.
</p>

<dl>
<dt>condquant:</dt><dd><p> logical: should bars be drawn
for censored residuals?
If <code>FALSE</code>, censored observations will be set to the median of
the conditional distribution and shown by a different plotting
character, see argument <code>censored</code> of
<code><a href="#topic+ploptions">ploptions</a></code>.
If <code>NULL</code>, the standard plotting character will be used.
</p>
</dd>
<dt>condquant.probrange:</dt><dd><p> range for probabilities.
If the probability corresponding to the censored part of the
distribution is outside the range, bars will not be drawn.</p>
</dd>
<dt>condquant.pale:</dt><dd><p> factor by which the <code>pcol</code> color
will be paled to show the points (<code>condquant.pale[1]</code>)
and the bars (<code>...[2]</code>).
</p>
</dd>
</dl>

</dd>
<dt>***</dt><dd><p>plcond: features of <code><a href="#topic+plcond">plcond</a></code>.
</p>

<dl>
<dt>plcond/panel:</dt><dd><p> panel function to be used</p>
</dd>
<dt>plcond.nintervals:</dt><dd><p> number of intervals into which
numerical variables will be cut</p>
</dd>
<dt>plcond.extend:</dt><dd><p> proportion of neighboring intervals for
which points are shown. 0 means no overlap.</p>
</dd>
<dt>plcond.col:</dt><dd><p> 4 colors to be used to mark the points of
the neighboing intervals:
The first and second ones color the points lower or higher
than the interval of the horizontal conditioning variable,
and the other two regulating the same features for the
vertical variable.
The points which are outside the intervals of both
conditioning variables will get a mixed color.</p>
</dd>
<dt>plond.pale:</dt><dd><p> minimum and maximum paling, to be applied
for distance 0 and maximal distance from the interval.</p>
</dd>
<dt>plcond.cex:</dt><dd><p> symbol size, relative to <code>cex</code>, used to
show the points outside the interval</p>
</dd>
</dl>

</dd>
<dt>subset.rgratio</dt><dd><p>adjust plot range for a subset if the range is
smaller than <code>subset.rgratio</code> times the plot range for the full
data set</p>
</dd>
<dt>functionxvalues</dt><dd><p>if a function is to be shown, the number of
argument values for which the function is evaluated</p>
</dd>
<dt>***</dt><dd><p>options for the function <code>plregr</code>
</p>

<dl>
<dt>regr.plotselect</dt><dd><p> selection of diagnostic plots that are
produced, see ...</p>
</dd> 
<dt>regr.addcomp</dt><dd><p> should residuals be shown as they are or
component effects added to them?</p>
</dd>
<dt>leveragelimit</dt><dd><p> ...</p>
</dd> 
<dt>cookdistancelines</dt><dd><p>values of Cook's distance for which
contours will be shown on the leverage plot</p>
</dd>
</dl>

</dd>
<dt>stamp</dt><dd><p>logical: should stamps be shown in the bottom right
concern documenting the date and any project and step titles?</p>
</dd>
<dt>doc</dt><dd><p>logical: should any documentations of the data set
be shown as subtitles, i.e., at in the top margin of the plot?</p>
</dd>
<dt>printnotices:</dt><dd><p> logical: should notices produced by the
functions be shown?</p>
</dd>
<dt>debug:</dt><dd><p> Some functions that produce nice-to-have features
are prevented from aborting the process if they fail
(by using the <code>try</code> function) and produce a warning instead
&ndash; unless <code>debug</code> is <code>TRUE</code>
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>See Also</h3>

<p><code><a href="#topic+ploptions">ploptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(default.ploptions)
</code></pre>

<hr>
<h2 id='plpanel'>Panel function for multiple plots</h2><span id='topic+plpanel'></span><span id='topic+panelSmooth'></span><span id='topic+plpanelCond'></span>

<h3>Description</h3>

<p>Draw a scatterplot or multibox plot, usuallly after <code>pl.control</code>
and <code>plframe</code> have been called. 
May also be used to augment an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plpanel(x = NULL, y = NULL, indx = NULL, indy = NULL, type = "p",
  frame = FALSE, title = FALSE,
  plargs = NULL, ploptions = NULL, marpar = NULL, ...)

panelSmooth(x, y, indx, indy, plargs = NULL, ...)

plpanelCond(x, y, ckeyx, ckeyy, pch = 1, pcol = 1, psize = 1,
  pale = c(0.2, 0.6), csize = 0.8,
  smooth = NULL, smooth.minobs = NULL, plargs = NULL, ploptions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plpanel_+3A_x">x</code></td>
<td>
<p>values of the horizontal variable</p>
</td></tr>
<tr><td><code id="plpanel_+3A_y">y</code></td>
<td>
<p>values of the vertical variable</p>
</td></tr>
<tr><td><code id="plpanel_+3A_indx">indx</code></td>
<td>
<p>index of the variable shown horizontally, among the
<code>y</code> variables</p>
</td></tr>
<tr><td><code id="plpanel_+3A_indy">indy</code></td>
<td>
<p>index of the variable shown horizontally, among the
<code>y</code> variables</p>
</td></tr>
<tr><td><code id="plpanel_+3A_type">type</code></td>
<td>
<p>type of plot as usual in R: &quot;p&quot; for points, ...</p>
</td></tr>
<tr><td><code id="plpanel_+3A_frame">frame</code></td>
<td>
<p>logical: should <code>plframe</code> be called?
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_title">title</code></td>
<td>
<p>logical: should <code>pltitle</code> be called?
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_ckeyx">ckeyx</code>, <code id="plpanel_+3A_ckeyy">ckeyy</code></td>
<td>
<p>vectors of 'keys' to calculate paling values and
weights for smoothing. NA means that points should not be shown
in this panel. 0 means no paling and weight 1.
Other values are between -1 and 1,
<code>cpl=(1-abs(ckeyx))*(1-abs(ckeyy))</code> is used for paling and weights.
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_pch">pch</code>, <code id="plpanel_+3A_pcol">pcol</code>, <code id="plpanel_+3A_psize">psize</code></td>
<td>
<p>vector of plotting symbols, colors and sizes
for plotting points
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_pale">pale</code></td>
<td>
<p>vector of length 2 indicating the range of paling values
obtained from <code>cpl</code> values from 1 to 0.
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_csize">csize</code></td>
<td>
<p>factor applied to the character expansion of the points
with <code>cpl&lt;1</code>
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_smooth">smooth</code></td>
<td>
<p>should a smooth line be drawn?
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_smooth.minobs">smooth.minobs</code></td>
<td>
<p>minimum number of points required for calculating
and showing a smooth line
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_plargs">plargs</code>, <code id="plpanel_+3A_ploptions">ploptions</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>plargs</code> is <code>NULL</code>, <code>pl.control</code> will be called to
generate it.
The components are often needed to generate the panel.
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>
<tr><td><code id="plpanel_+3A_...">...</code></td>
<td>
<p>further arguments passed to
<code>plpoints, plmboxes, plsmooth</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The panel function <code>plpanel</code> draws a scatterplot if both
<code>x</code> and <code>y</code> are
numerical, and a multibox plot if one of them is a factor and
<code>ploptions$factor.show == "mbox"</code>.<br />
Grouping, reference and smooth lines and properties of the points
are determined by the component of <code>plargs</code> in <code>plpanel</code>.
</p>
<p>This function is usually called by the high level pl functions
<code><a href="#topic+plyx">plyx</a></code> and <code><a href="#topic+plmatrix">plmatrix</a></code>.
A different suitable function can be used by setting their
argument <code>panel</code>.
</p>
<p>The first arguments, <code>x</code> and <code>y</code>,
can be formulas, and an argument <code>data</code> can be given.
These arguments then have the same meaning as in <code><a href="#topic+plyx">plyx</a></code>,
with the restriction that only one variable should result for
the <code>x</code> and <code>y</code> coordinates in the plot.
When <code>frame</code> is true, <code>plpanel</code> can be used instead of
<code><a href="#topic+plyx">plyx</a></code> for generating a single plot.
Note that <code>plpanel</code> does not modify <code>pl.envir</code>,
in contrast to <code>plyx</code>.
</p>
<p><code>plpanelCond</code> shows selected points only and may show
some of them with reduced size and paled color.
It is appropriate for the high level function <code><a href="#topic+plcond">plcond</a></code>.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Note</h3>

<p>These functions are rarely called by the user.
The intention is to modify ond of them and then call the modified
version when using <code><a href="#topic+plyx">plyx</a>, <a href="#topic+plmatrix">plmatrix</a></code> or
<code><a href="#topic+plcond">plcond</a></code> by setting <code>panel=mypanel</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="#topic+plyx">plyx</a></code> is essentially a wrapper function of
<code>plpanel</code> which calls <code>pl.control</code> and provides additional
features.
<code><a href="#topic+plmatrix">plmatrix</a></code> also uses <code>plpanel</code>, whereas
<code><a href="#topic+plcond">plcond</a></code> uses <code>plpanelCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.plargs &lt;-
  pl.control(~Species+Petal.Length, ~Sepal.Width+Sepal.Length,
             data=iris, smooth.group=Species, pcol=Species)
t.plargs$ploptions$group.col &lt;- c("magenta","orange","cyan")
plpanel(iris$Petal.Length, iris$Petal.Width, plargs=t.plargs,
        frame=TRUE)
</code></pre>

<hr>
<h2 id='plpoints'>Plot Points and Lines in the 'pl' system
</h2><span id='topic+plpoints'></span><span id='topic+pllines'></span>

<h3>Description</h3>

<p>Low level functions for plotting point and lines
based on the 'pl' paradigm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plpoints(x=NULL, y=NULL, type="p", plab=NULL, pch=NULL,
  pcol=NULL, col=NULL, lcol=NULL, lty=NULL, lwd=NULL, psize=NULL,
  csize = NULL, group = NULL, plargs = NULL, ploptions = NULL,
  marpar = NULL, xy = TRUE, ...)

pllines(x, y, type="l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plpoints_+3A_x">x</code>, <code id="plpoints_+3A_y">y</code></td>
<td>
<p>coordinates for the horizontal and veritical axis,
respectively. If <code>NULL</code>, they will be retrieved from
<code>plargs$pldata</code>.
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_type">type</code></td>
<td>
<p>type of displaying points. See <code>?<a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plpoints_+3A_plab">plab</code></td>
<td>
<p>labels for displaying points. Overrides labels provided by
<code>plargs$pdata[["plab"]]</code>.
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_pcol">pcol</code>, <code id="plpoints_+3A_col">col</code></td>
<td>
<p>color for points. <code>col</code> is used if <code>pcol</code>
is <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_lcol">lcol</code></td>
<td>
<p>color for lines
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_pch">pch</code>, <code id="plpoints_+3A_psize">psize</code>, <code id="plpoints_+3A_csize">csize</code>, <code id="plpoints_+3A_lty">lty</code>, <code id="plpoints_+3A_lwd">lwd</code></td>
<td>
<p>... and <code>col</code> in <code>plpoints</code>:
plotting character(s), relative size, median character expansion,
and color for plotting points,
and line type. 
Overrides other settings, defined in <code>plargs</code>.
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_group">group</code></td>
<td>
<p>grouping of observations, used to determine <code>pch</code>
and <code>col</code>
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_plargs">plargs</code>, <code id="plpoints_+3A_ploptions">ploptions</code></td>
<td>
<p>result of <code><a href="#topic+pl.control">pl.control</a></code>, see Details
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_xy">xy</code></td>
<td>
<p>logical: should the coordinates be obtained as in
high level graphics? This is set to <code>FALSE</code> to save time and
avoid complications, in case the user is sure that <code>x</code> and
<code>y</code> are vectors rather than formulas or variable names.
</p>
</td></tr>
<tr><td><code id="plpoints_+3A_...">...</code></td>
<td>
<p>absorbs extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>plpoints</code>, the first arguments, <code>x</code> and <code>y</code>
can be formulas, and an argument <code>data</code> can be given.
These arguments then have the same meaning as in <code><a href="#topic+plyx">plyx</a></code>.
</p>
<p><code>plargs</code> and <code>ploptions</code> may be specified explicitly,
but they are usually generated by calling <code>pl.control</code>.
</p>


<h3>Value</h3>

<p><code>plsmooth</code> invisibly returns the data.frame needed for
drawing the smooth line. The other functions return <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><a href="#topic+pl.control">pl.control</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyx(Sepal.Width ~ Sepal.Length, data=iris, pcol=Species)

da &lt;- aggregate(iris[,1:4], list(Species=iris$Species), mean)
plpoints(Sepal.Width ~ Sepal.Length, plargs=list(pldata=da),
  plab=da$Species, csize.pch=1, pcol=as.numeric(da$Species))
</code></pre>

<hr>
<h2 id='plregr'>Diagnostic Plots for Regr Objects</h2><span id='topic+plregr'></span><span id='topic+plot.regr'></span><span id='topic+plresx'></span>

<h3>Description</h3>

<p>Diagnostic plots for fitted regression models:
Residuals versus fit (Tukey-Anscombe plot) and/or target variable
versus fit;
Absolute residuals versus fit to assess equality of error variances;
Normal Q-Q plot (for ordinary regression models);
Residuals versus leverages to identify influential observations;
Residuals versus sequence (if requested);
and residuals versus explanatory variables.
These plots are adjusted to the type of regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plregr(x, data = NULL, plotselect = NULL, xvar = TRUE,
  transformed = NULL, sequence = FALSE, weights = NULL,
  addcomp = NULL, smooth = 2, smooth.legend = FALSE, markextremes = NA,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)

plresx(x, data = NULL, xvar = TRUE, transformed = NULL,
  sequence = FALSE, weights = NULL,
  addcomp = NULL, smooth = 2, smooth.legend = FALSE, markextremes = NA,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plregr_+3A_x">x</code></td>
<td>
<p><code>"regr"</code> (or also <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>)
object, result of a call to <code>regr()</code> from package <span class="pkg">regr</span>.
This is the only argument needed.  All others have useful defaults.</p>
</td></tr>
<tr><td><code id="plregr_+3A_data">data</code></td>
<td>
<p>data set where explanatory variables and the following
possible arguments are found: <code>weights, plweights, pch, plabs</code></p>
</td></tr>
<tr><td><code id="plregr_+3A_plotselect">plotselect</code></td>
<td>
<p>which plots should be shown? See Details</p>
</td></tr>
<tr><td><code id="plregr_+3A_xvar">xvar</code></td>
<td>
<p>if TRUE, residuals will be plotted versus all
explanatory variables (or terms, according to argument 'transformed')
in the model (<code>plregr</code> will call <code>plresx</code>).<br />
If it is a character vector, it contains the variables to be used.<br />
If it is a formula, its right hand side contains these variables.
The model formula is updated by such a formula.
Whence, the use of <code>\~{}.+</code> adds variables to those in the
model.<br />
If any variables are not be contained in the model, the argument
<code>data</code> is needed.
</p>
</td></tr>
<tr><td><code id="plregr_+3A_transformed">transformed</code></td>
<td>
<p>logical: should residuals be shown against
transformed explanatory variables? If <code>TRUE</code>, the variables are
transformed as implied by the model.</p>
</td></tr>
<tr><td><code id="plregr_+3A_sequence">sequence</code></td>
<td>
<p>if TRUE, residuals will be plotted versus the
sequence as they appear in the data.
If another explanatory variable is monotone increasing or
decreasing, the plot is not shown, but a warning is given.</p>
</td></tr>
<tr><td><code id="plregr_+3A_weights">weights</code></td>
<td>
<p>if TRUE, residuals will be plotted versus
<code>x$weights</code>. Alternatively, a vector of weights can be specified</p>
</td></tr>
<tr><td><code id="plregr_+3A_addcomp">addcomp</code></td>
<td>
<p> logical: should component effects be added to
residuals for residuals versus input variables plots? </p>
</td></tr>
<tr><td><code id="plregr_+3A_smooth">smooth</code></td>
<td>
<p>logical: should a smooth line be added?</p>
</td></tr>
<tr><td><code id="plregr_+3A_smooth.legend">smooth.legend</code></td>
<td>
<p>When a grouping factor is used
(argument <code>smooth.group</code>, see below),
this argument determines whether and where the legend
for identifying the groups should be shown, see Details</p>
</td></tr>
<tr><td><code id="plregr_+3A_markextremes">markextremes</code></td>
<td>
<p>proportion of extreme residuals to be labeled.
If all points should be labeled, let <code>markextremes=1</code>.</p>
</td></tr>
<tr><td><code id="plregr_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plregr_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plregr_+3A_assign">assign</code></td>
<td>
<p>logical: Should the plargs be stored
in the <code>pl.envir</code> environment?
</p>
</td></tr>
<tr><td><code id="plregr_+3A_...">...</code></td>
<td>
<p>Many further arguments are available to customize the plots,
see below for some of the most useful ones, and
<code><a href="#topic+plregr.control">plregr.control</a></code> for a complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>plotselect</code> is used to determine which plots will be
shown. It should be a named vector of numbers indicating
</p>

<dl>
<dt>0</dt><dd><p>do not show</p>
</dd>
<dt>1</dt><dd><p>show without smooth</p>
</dd>
<dt>2</dt><dd><p>show with smooth (not for <code>qq</code> nor <code>leverage</code>)</p>
</dd>
<dt>3</dt><dd><p>show with smooth and smooth band (only for <code>resfit</code>
in <code>plregr</code> and in <code>plresx</code>)</p>
</dd>
</dl>

<p>The default is
<code>c( yfit=0, resfit=smdef, absresfit = NA, absresweights = NA, qq = NA,
    leverage = 2, resmatrix = 1, qqmult = 3)</code>, where
<code>smdef</code> is 3 (actually argument <code>smooth</code> of
<code>plregr.control</code> plus 1) for normal random deviations and
one less (no band) for others.
</p>
<p>Modify this vector to change the selection and the sequence in
which the plots appear.
Alternatively, provide a named vector defining all plots that should
be shown on a different level than the default indicates,
like <code>plotselect = c(resfit = 2, leverage = 1)</code>.
Adding an element <code>default = 0</code> suppresses all plots not
mentioned. This is useful to select single plots, like
<code>plotselect = c(resfit = 3, default = 0)</code>
</p>
<p>The names of <code>plotselect</code> refer to:
</p>

<dl>
<dt>yfit</dt><dd><p>response versus fitted values</p>
</dd>
<dt>resfit</dt><dd><p>residuals versus fitted values (Tukey-Anscombe plot)</p>
</dd>
<dt>absresfit</dt><dd><p>residuals versus fitted values, defaults to TRUE for
ordinary regression, FALSE for glm and others</p>
</dd>
<dt>absresweights</dt><dd><p>residuals versus weights</p>
</dd>
<dt>qq</dt><dd><p>normal Q-Q plot, defaults to TRUE for
ordinary regression, FALSE for glm and others</p>
</dd>
<dt>leverage</dt><dd><p>residuals versus leverage (hat diabgonal)</p>
</dd>
<dt>resmatrix</dt><dd><p>scatterplot matrix of residuals for
multivariate regression</p>
</dd>
<dt>qqmult</dt><dd><p>qq plot for Mahlanobis lengths versus sqrt of chisquare
quantiles.</p>
</dd>
</dl>

<p>In the 'resfit' (Tukey-Anscombe) plot, the reference line indicates
a &quot;contour&quot; line with constant values of the response variable,
<code class="reqn">Y=\widehat y+r=</code> constant. It has slope <code>-1</code>.
It is useful to judge whether any curvature shown by the smooth
might disappear after a nonlinear, monotone transformation of the
response.
</p>
<p>If <code>smresid</code> is true, the 'absresfit' plot uses modified
residuals: differences between the ordinary residuals and the smooth
appearing in the 'resfit' plot.
Analogously, the 'qq' plot is then based on yet another modification
of these modified residuals: they are scaled by the smoothed scale
shown in the 'absresfit' plot, after these scales have been
standardized to have a median of 0.674 (=<code>qnorm(0.75)</code>).
</p>
<p>The smoothing function used by default is <code><a href="#topic+smoothRegr">smoothRegr</a></code>,
which calls <code><a href="stats.html#topic+loess">loess</a></code>. This can be changed by setting
<code>ploptions(smooth.function=&lt;func&gt;)</code>, which must have the same
arguments as <code>smoothRegr</code>.
</p>
<p>The arguments <code>lty, lwd, colors</code> characterize how the graphical
elements in the plot are shown.
They should be three vectors of length 9 each, defining the
line types, line widths, and colors to be used for ...
</p>

<dl>
<dt>[1] </dt><dd><p>observations;</p>
</dd>
<dt>[2] </dt><dd><p>reference lines;</p>
</dd>
<dt>[3] </dt><dd><p>smooth;</p>
</dd>
<dt>[4] </dt><dd><p>simulated smooths;</p>
</dd>
<dt>[5] </dt><dd><p>component effects in plresx;</p>
</dd>
<dt>[6] </dt><dd><p>confidence bands of component effects.</p>
</dd>
</dl>
<p>In the case of <code>glm.restype="cond.quant"</code>
</p>
<dl>
<dt>[7] </dt><dd><p>(random) observations;</p>
</dd>
<dt>[8] </dt><dd><p>conditional medians;</p>
</dd>
<dt>[9] </dt><dd><p>bars showing conditional quantiles.</p>
</dd>
</dl>

<p>If smooths are shown according to groups (given in
<code>smooth.group</code>), then a legend can be required and positioned
in the respecive plots by using the argument <code>smooth.legend</code>.
If it is <code>TRUE</code>, then the legend will be placed in the
<code>"bottomright"</code> corner.
Alternatively, the corner can be specified as
&quot;bottomright&quot;, &quot;bottomleft&quot;, &quot;topleft&quot;, or &quot;topright&quot;.
A coordinate pair may also be given.
These possibilities can be used individually for each plot by
giving a named vector or a named list, where the names are
one of &quot;yfit&quot;, &quot;resfit&quot;, &quot;absresfit&quot;, &quot;absresweight&quot;, &quot;.xvar.&quot; or
names of x variables provided by the <code>xvar</code> argument.
A component &quot;.xvar.&quot; selects the first x variable.
</p>
<p>There is an hidden argument <code>innerrange.fit</code> that allows
for fixing an inner range for plotting the fitted values.
</p>


<h3>Value</h3>

<p>The list of the evaluations of all arguments and some more useful
items is returned invisibly.
</p>


<h3>Note</h3>

<p>This is a function under development. Future versions may behave
differently and may not be compatible with this version.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="#topic+plregr.control">plregr.control</a>, <a href="stats.html#topic+plot.lm">plot.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LifeCycleSavings, package="datasets")
r.savings &lt;- lm(sr ~ pop15 + pop75 + dpi + ddpi, data = LifeCycleSavings)
plregr(r.savings)

## --- *transformed* linear model
data(d.blast)
r.blast &lt;-
     lm(log10(tremor) ~ location+log10(distance)+log10(charge),
          data=d.blast)
plregr(r.blast, sequence=TRUE, transformed=TRUE)
plregr(r.blast, xvar=FALSE, innerrange.fit=c(0.3,1.2))


## --- multivariate regression
data(d.fossileSamples)
r.foss &lt;-
  lm(cbind(sAngle,lLength,rWidth) ~ SST+Salinity+lChlorophyll+Region+N,
  data=d.fossileSamples)
plregr(r.foss, plotselect=c(resfit=3, resmatrix=1, qqmult=1))


## --- logistic regression
data(d.babysurvival)
rr &lt;- glm(Survival ~ Weight+Age+Apgar1, data=d.babysurvival, family=binomial)
plregr(rr, xvar= ~Weight, cex.plab=0.7, ylim=c(-5,5))
plregr(rr, condquant=FALSE)

## --- ordinal regression
if(requireNamespace("MASS")) {
data(housing, package="MASS")
rr &lt;- MASS::polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
plregr(rr, factor.show="jitter")
}
</code></pre>

<hr>
<h2 id='plregr.control'>
Further Arguments to <code>plregr</code>
</h2><span id='topic+plregr.control'></span>

<h3>Description</h3>

<p>Specify some arguments of minor importance for the function
<code><a href="#topic+plregr">plregr</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plregr.control(x, data = NULL, xvar = TRUE, transformed = FALSE,
  weights = NULL, stdresid = TRUE, mar = NULL,
  glm.restype = "working", condquant = TRUE, smresid = TRUE,
  partial.resid = NULL, addcomp = NULL, cookdistlines = NULL,
  leveragelimit = NULL, condprob.range = NULL,
  testlevel = 0.05,
  refline = TRUE, 
  smooth = 2, 
  smooth.sim = NULL,
  xlabs = NULL, reslabs = NULL, markextremes = NULL,
  mf = TRUE, mfcol = FALSE, multnrow = 0, multncol = 0, marmult = NULL,
  oma = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plregr.control_+3A_x">x</code></td>
<td>
<p>an object (result of a call to a model fitting function
such as <code>lm, glm, ...</code>. This is the only argument
that is needed. All others have useful defaults.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_data">data</code></td>
<td>
<p>see <code>?<a href="#topic+plregr">plregr</a></code></p>
</td></tr>
<tr><td><code id="plregr.control_+3A_xvar">xvar</code></td>
<td>
<p>variables for which residuals shall be plotted.
Either a formula like <code>~ x1 + x2</code> or a character vector of
names. Defaults to all variables (or terms, see <code>transformed</code>)
in the model.
</p>
</td></tr>    
<tr><td><code id="plregr.control_+3A_transformed">transformed</code></td>
<td>
<p>see <code>?<a href="#topic+plregr">plregr</a></code></p>
</td></tr>
<tr><td><code id="plregr.control_+3A_weights">weights</code></td>
<td>
<p>logical: should residuals be plotted against weights?
Used in <code>plresx</code>.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_stdresid">stdresid</code></td>
<td>
<p>logical: should leverages and standardized residuals
be calculated? This is avoided for <code>plresx</code></p>
</td></tr>
<tr><td><code id="plregr.control_+3A_mar">mar</code></td>
<td>
<p>plot margins
</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_glm.restype">glm.restype</code></td>
<td>
<p>type of residuals to be used for glm models.
In addition to those allowed in <code>residuals()</code> for
<code>glm</code> objects, type <code>condquant</code> is possible for
(ungrouped) binary regression.
See <code>?<a href="#topic+residuals.regrpolr">residuals.regrpolr</a></code> for an explanation.
Warning: type &quot;deviance&quot; will not work with simulated smooths since
NAs will emerge.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_condquant">condquant</code></td>
<td>
<p>logical: should conditional quantiles be shown for
censored observations, binary and ordered responses?</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_smresid">smresid</code></td>
<td>
<p>logical: Should residuals from smooth be used for
'tascale' and 'qq' plots?</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_partial.resid">partial.resid</code>, <code id="plregr.control_+3A_addcomp">addcomp</code></td>
<td>
<p>logical, synonyms: Should component
effects be added to the residuals? This leads to what some authors
call &quot;partial residual plot&quot;.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_cookdistlines">cookdistlines</code></td>
<td>
<p>levels of Cook distance for which contours are
plotted in the leverage plot</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_leveragelimit">leveragelimit</code></td>
<td>
<p>bound for leverages to be used in standardizing
residuals and in calculation of standardized residuals from smooth
(if <code>smresid</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_condprob.range">condprob.range</code></td>
<td>
<p>numeric vector of length 2.
In the case of residuals of class <code>condquant</code>, quartile bars
are only drawn for residuals with probability between
<code>condprob.range[1]</code> and <code>condprob.range[1]</code>.
Default is <code>c(0.05,0.8)</code> for less than 50 observations, and
<code>c(0,0)</code>, suppressing the bars, otherwise.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_testlevel">testlevel</code></td>
<td>
<p>level for statistical tests</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_refline">refline</code></td>
<td>
<p>logical: should reference line be shown?
If <code>refline==2</code>, a confidence band be drawn for the component
effects
</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_smooth">smooth</code></td>
<td>
<p>if TRUE (or 1), smooths are added to the plots where
appropriate. If <code>==2</code>, smmooths to positive and negative
residuals-from-smooth are also shown.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_smooth.sim">smooth.sim</code></td>
<td>
<p>number of simulated smooths added to each plot.
If NULL (the default) 19 simulated smooths will be generated if
possible and sensible (i.e., none if <code>smooth.group</code> is set).</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_xlabs">xlabs</code></td>
<td>
<p>labels for x variables. Defaults to <code>vars</code></p>
</td></tr>
<tr><td><code id="plregr.control_+3A_reslabs">reslabs</code></td>
<td>
<p>labels for vertical axes</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_markextremes">markextremes</code></td>
<td>
<p>proportion of extreme residuals to be labeled.
If all points should be labeled, let <code>markextremes=1</code>.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_mf">mf</code></td>
<td>
<p>vector of 2 elements, indicating the number of rows and
columns of panels on each plot page.
Defaults to <code>c(2,2)</code>, except for multivariate models, where
it adjusts to the number of target variables.
<code>mf=c(1,1)</code> or <code>mf=1</code> asks for a single frame per page.
<code>mf=NA</code> or <code>mf=0</code> leaves the framing (and <code>oma</code>)
unchanged.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_mfcol">mfcol</code></td>
<td>
<p>if TRUE, the panel will be filled columnwise</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_multnrow">multnrow</code>, <code id="plregr.control_+3A_multncol">multncol</code></td>
<td>
<p>number of rows and columns of panels on
one page, for residuals of multivariate regression only</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_marmult">marmult</code></td>
<td>
<p>plot margins for scatterplot matrices in the case of
multivariate regression</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_oma">oma</code></td>
<td>
<p>vector of length 4 giving the number of lines in the outer
margin. If it is of length 2, they refer to top an right margins.</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_assign">assign</code></td>
<td>
<p>logical: should the result of <code>pl.control</code> be
assigned to the <code>pl.envir</code> environment?
This will be done for high level pl functions, but avoided for low
level ones. It allows for reusing the settings and helps debug
unexpected behavior.
</p>
</td></tr>
<tr><td><code id="plregr.control_+3A_...">...</code></td>
<td>
<p>further arguments in the call, to be ignored by
'plotregr.control'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all the items needed to specify plotting
in <code><a href="#topic+plregr">plregr</a></code> and <code><a href="#topic+plresx">plresx</a></code>
</p>


<h3>Note</h3>

<p>This function is not explicitly called by the user, but by
<code><a href="#topic+plregr">plregr</a></code> and <code><a href="#topic+plresx">plresx</a></code>.
All the arguments specified here can and should be given as
arguments to these functions.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, Seminar for Statistics, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="#topic+plregr">plregr</a></code> and <code><a href="#topic+plresx">plresx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
( r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast) )

plargs &lt;- plregr.control(r.blast, formula = ~.+distance, transformed=TRUE,
smooth.group = location )
showd(plargs$pdata)
names(plargs)

</code></pre>

<hr>
<h2 id='plres2x'>Plot Residuals vs. Two Explanatory Variables</h2><span id='topic+plres2x'></span>

<h3>Description</h3>

<p>Plot 2 variables, showing a third one with line symbols. Most suitable
for showing residuals of a model as this third variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plres2x(formula = NULL, reg = NULL, data = NULL, restrict = NULL,
  size = 1, xlab = NULL, ylab = NULL, pale = 0.2,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plres2x_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>~x+y</code>, where
<code>x, y</code> are the 2 variables shown by the coordinates of points,
and residuals are shown by line symbols: their orientation
corresponds to the sign of <code>the residual</code>, and their length,
to the absolute value.
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_reg">reg</code></td>
<td>
<p>the result of the model fit, from which the residuals are
extracted
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_data">data</code></td>
<td>
<p>the data.frame where the variables are found. Only needed
if the variable 'x' or 'y' is not available from the fitting results.</p>
</td></tr>
<tr><td><code id="plres2x_+3A_restrict">restrict</code></td>
<td>
<p>absolute value which truncates the size.
if <code>TRUE</code>, the inner plotting limits of the residuals is used
if available.
Truncation is shown by stars at the end of the line symbols.
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_size">size</code></td>
<td>
<p>the symbols are scaled so that <code>size*par("cin")[1]</code>
is the length of the largest symbol, as a percentage of the length
of the horizontal axis.</p>
</td></tr>
<tr><td><code id="plres2x_+3A_xlab">xlab</code>, <code id="plres2x_+3A_ylab">ylab</code></td>
<td>
<p>labels for horizontal and vertical axes.
Default to the variable names (or labels)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plres2x_+3A_pale">pale</code></td>
<td>
<p>scalar between 0 and 1: The points are shown in a more
pale color than the segments as determined by
<code><a href="#topic+colorpale">colorpale</a></code> with argument <code>pale=pale</code>.</p>
</td></tr>
<tr><td><code id="plres2x_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_assign">assign</code></td>
<td>
<p>logical: Should the plargs be stored 
in the <code>pl.envir</code> environment?
</p>
</td></tr>
<tr><td><code id="plres2x_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code>plotregr.control</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel and Andreas Ruckstuhl</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(d.blast)
  t.r &lt;- lm(log10(tremor)~location+log10(distance)+log10(charge),
            data=d.blast)
  plres2x(~distance+charge, t.r)
</code></pre>

<hr>
<h2 id='plscale'>Generate Plscaled Plotting Scale
</h2><span id='topic+plscale'></span>

<h3>Description</h3>

<p>Generates plscaled values and appropriate tick mark
positions and labels for expressing a variable on a plscaled scale,
e.g., on log scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plscale(x, plscale = "log10", ticksat = NULL, logscale = NULL,
  valuesonly = FALSE, ploptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plscale_+3A_x">x</code></td>
<td>
<p>data to be used in plotting
</p>
</td></tr>
<tr><td><code id="plscale_+3A_plscale">plscale</code></td>
<td>
<p>name of the function defining the plscaled scale
</p>
</td></tr>
<tr><td><code id="plscale_+3A_ticksat">ticksat</code></td>
<td>
<p>tick locations, If <code>NULL</code>, these locations will be
generated by the function.
An attribute <code>attr(..., "ticklabels")</code> may also be given.
</p>
</td></tr>
<tr><td><code id="plscale_+3A_logscale">logscale</code></td>
<td>
<p>if <code>NULL</code>, R's function <code>axTicks</code>
will be called if the plscale is a log function.
</p>
</td></tr>
<tr><td><code id="plscale_+3A_valuesonly">valuesonly</code></td>
<td>
<p>logical: should only the transformed values be
returned? Otherwise, axis ranges and tick information is also
calculated.
</p>
</td></tr>
<tr><td><code id="plscale_+3A_ploptions">ploptions</code></td>
<td>
<p>See <code><a href="#topic+ploptions">ploptions</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>x</code> data is returned, augmented by the following attributes:
</p>

<dl>
<dt>numvalues</dt><dd><p>the plscaled values to be used for plotting</p>
</dd>
<dt>ticksat</dt><dd><p>the location of tick marks (plscaled values)</p>
</dd>
<dt>ticklabels</dt><dd><p>the labels for the tick marks showing the original
scale</p>
</dd>
<dt>plscale</dt><dd><p>the name of the function used for the plscaleation</p>
</dd>
</dl>



<h3>Note</h3>

<p>Besides the logarithmic plscale that is supported by core R
graphics, any other plscaleation may be used, notably the so-called
&quot;first aid plscaleations&quot;.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+axTicks">axTicks</a>, <a href="#topic+prettyscale">prettyscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 10^seq(-1,3,0.5)
  plscale(x)
  xx &lt;- plscale(x, plscale="sqrt")
  plyx(xx)
  x &lt;- seq(0,100,2)
  plyx(plscale(x, plscale="asinp"), type="l") 
</code></pre>

<hr>
<h2 id='plsmooth'>Smooth and Reference Line Plotting</h2><span id='topic+plsmooth'></span><span id='topic+plsmoothline'></span><span id='topic+plrefline'></span>

<h3>Description</h3>

<p>These functions add smooths or reference lines to an existing pl plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsmooth(x = NULL, y = NULL, ysec = NULL, band=NULL, power = NULL,
  group = NULL, weight = NULL, smooth = TRUE,
  plargs = NULL, ploptions = NULL, xy = TRUE, ...)

plsmoothline(smoothline = NULL, x = NULL, y = NULL, ysec = NULL,
  smooth.col = NULL, smooth.lty = NULL, smooth.lwd = NULL, 
  plargs = NULL, ploptions = NULL, marpar = NULL, ...)

plrefline(refline, x=NULL, innerrange=NULL, y=NULL,
  cutrange = c(x = TRUE, y = FALSE), plargs=NULL, ploptions=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsmooth_+3A_x">x</code>, <code id="plsmooth_+3A_y">y</code></td>
<td>
<p>coordinates for the horizontal and veritical axis,
respectively. If <code>NULL</code>, they will be retrieved from
<code>plargs$pldata</code>.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_ysec">ysec</code></td>
<td>
<p>for <code>plsmooth, plsmoothline</code>:
matrix of secondary y values. The smooths generated or given by its
columns will be drawn thinner and with paled color.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_band">band</code></td>
<td>
<p>logical: should a band (e.g., a confidence band)
be drawn together with the smooth?
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_power">power</code></td>
<td>
<p>for <code>plsmooth</code>: smooth will be calcutated for
<code>y^power</code> and the back-transformed. Usually, <code>power=0</code>.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_group">group</code></td>
<td>
<p>for <code>plsmooth</code>: grouping variable.
If <code>NULL</code>, the variable <code>.smooth.group.</code> column in
<code>plargs$pldata</code> will be used if available.
If <code>group</code> is of length 1, there will be no grouping
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_weight">weight</code></td>
<td>
<p>weights of observations used for generating the smooth</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_smooth">smooth</code></td>
<td>
<p>logical: should smooth be done? Will almost always be
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="plsmooth_+3A_smoothline">smoothline</code></td>
<td>
<p>for <code>plsmoothline</code>: result of a smooth fitting</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_smooth.col">smooth.col</code>, <code id="plsmooth_+3A_smooth.lty">smooth.lty</code>, <code id="plsmooth_+3A_smooth.lwd">smooth.lwd</code></td>
<td>
<p>for <code>plsmoothline</code>:
color, line type and line width for the smooth line(s).
By default, they will be taken from ploptions.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_refline">refline</code></td>
<td>
<p>for <code>plrefline</code>:
A two element vector giving intercept and slope of a straight line, 
or a function that returns these as the first 2 elemnts of the
result's <code>coef</code> component, such as <code>lm</code>.
For more possibilities, see Details.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_innerrange">innerrange</code></td>
<td>
<p>for <code>plrefline</code>: inner range in x direction -
only needed if the refline should be clipped at a range different
from the <code>innerrange</code> attribute of the horizontal variable</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_cutrange">cutrange</code></td>
<td>
<p>for <code>plrefline</code>: logical vector of length 2:
should the reference line(s) be cut at the inner plotting ranges in
x- and y-direction?
Otherwise, it will be continued outside it with the appropriate
transformation.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_plargs">plargs</code>, <code id="plsmooth_+3A_ploptions">ploptions</code></td>
<td>
<p>result of <code><a href="#topic+pl.control">pl.control</a></code>, see Details
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_marpar">marpar</code></td>
<td>
<p>margin parameters, if already available.
By default, they will be retieved from <code>ploptions</code>.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_xy">xy</code></td>
<td>
<p>logical: should the coordinates be obtained as in
high level graphics? This is set to <code>FALSE</code> to save time and
avoid complications, in case the user is sure that <code>x</code> and
<code>y</code> are vectors rather than formulas or variable names.
</p>
</td></tr>
<tr><td><code id="plsmooth_+3A_...">...</code></td>
<td>
<p>absorbs extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>refline</code> accepts different types of values.
If it is a function, it must either accept a formula
(which will be <code>y~x</code>) as its first argument or
<code>x</code> and <code>y</code> as the first two arguments.<br />
Alternatively, <code>refline</code> can be
a list with components <code>x</code> and <code>y</code>
and possibly a component <code>band</code> that contains the coordinates
of the line (or lines, if <code>y</code> is a matrix) and the width of
a band around it (that is, additional lines, to be drawn with
<code>ploptions("refline.col")[2]</code>).<br />
In order to obtain more than one reference line, a list of such
items may be given. It should not have compontents named
<code>coef, coefficients, x</code> or <code>y</code>, since it would otherwise
be mistaken for an argument of the types just described.
The components may carry attributes <code>lty, lwd</code> and <code>lcol</code>
to specify the properties of the lines individually. See Examples.
</p>
<p><code>plsmooth</code> and <code>plrefline</code> are very similar.
They are both called by high level pl functions.
<code>plsmooth</code> gets its smoothing function from
<code>ploptions("smooth.function")</code>.
Their properties (line type, width, color) come from different
sets of pl options. <code>plsmooth</code> can also respect a group
structure in the data.
</p>
<p>If <code>x</code> or <code>y</code> has an attribute <code>"numvalues"</code>,
these are used as the values to calculate the smooth or the
refline.
</p>
<p><code>plargs</code> and <code>ploptions</code> may be specified explicitly,
but they are usually generated by calling <code>pl.control</code>.
</p>
<p>The argument <code>getpar</code> is used for setting the graphical
parameters <code>mar, mgp</code> according to <code>ploptions</code>?
This is needed if the high level pl function has changed <code>mar</code>,
since this change has been reversed when the function was left.
By default, these graphical parameters will be retieved from
<code>pl.envir$ploptions</code>.
</p>


<h3>Value</h3>

<p><code>plsmooth</code> invisibly returns the data.frame needed for
drawing the smooth line. The other functions return <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><a href="#topic+pl.control">pl.control</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyx(Sepal.Width ~ Sepal.Length, data=iris, smooth=TRUE,
  smooth.group=Species, pch=Species)
plsmooth(smooth.group=FALSE)

## plrefline  called from  plyx
plyx(Sepal.Width ~ Sepal.Length, data=iris, smooth=TRUE, pch=Species,
     smooth.group=iris$Species, refline=lm)
## more reference lines
plrefline(list(c(-2,1), structure(c(-2.3,1), lcol="purple", lty=1)))
</code></pre>

<hr>
<h2 id='plsubset'>Subsetting a Data.Frame with pl Attributes
</h2><span id='topic+plsubset'></span>

<h3>Description</h3>

<p>Select rows of data.frames keeping the variable attributes
that drive pl graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsubset(x, subset = NULL, omit = NULL, select = NULL, drop = FALSE,
         keeprange = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsubset_+3A_x">x</code></td>
<td>
<p>data.frame from which the subset is to be generated
</p>
</td></tr>
<tr><td><code id="plsubset_+3A_subset">subset</code>, <code id="plsubset_+3A_omit">omit</code></td>
<td>
<p>logical vector or vector of indices of rows or or
rownames of <code>x</code>.
If <code>subset</code> is used, <code>omit</code> is ignored.
</p>
</td></tr>
<tr><td><code id="plsubset_+3A_select">select</code></td>
<td>
<p>vector of indices or names of variables to be selected
</p>
</td></tr>
<tr><td><code id="plsubset_+3A_drop">drop</code></td>
<td>
<p>logical: if only one variable remains, should the
data.frame be converted into a vector?
</p>
</td></tr>
<tr><td><code id="plsubset_+3A_keeprange">keeprange</code></td>
<td>
<p>logical: should ranges
(<code>inner.range</code> and <code>plrange</code>) be maintained?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plsubset</code> maintains the 'pl' attributes of the variables
of the data.frame (if there are), such as 'col', 'lty', ..., and
subsets the two attributes 'numvalues' and 'plcoord'.
This is useful if the way of displaying the axis is to be kept when a
new plot is drawn.
</p>


<h3>Value</h3>

<p>Data.frame with the selected rows (or without the <code>omit</code>ted
rows, respectively) and all attributes as described above. 
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p>Argument <code>subset</code> of the high level 'pl' functions
<code><a href="#topic+plyx">plyx</a>, <a href="#topic+plmatrix">plmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.river)
dd &lt;- d.river[seq(1,1000,4),]
dd$date &lt;- gendateaxis("date",hour="hour", data=dd)
attr(dd$date, "ticksat")

dsubs &lt;- plsubset(dd, subset=1:50)
attr(dsubs$date, "ticksat")

plyx(O2~date, data=dsubs)
## same as
## plyx(O2~date, data=dd, subset=1:50)
</code></pre>

<hr>
<h2 id='plticks'>Ticks for plotting
</h2><span id='topic+plticks'></span>

<h3>Description</h3>

<p>Find ticks locations and labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plticks(range, plscale = NULL, transformed = FALSE, nouter = 0,
  tickintervals = NULL, ploptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plticks_+3A_range">range</code></td>
<td>
<p>range of values that the ticks should cover
</p>
</td></tr>
<tr><td><code id="plticks_+3A_plscale">plscale</code></td>
<td>
<p>function defining the scale of the axis.
Either the name of the function or a function, see Details.
</p>
</td></tr>
<tr><td><code id="plticks_+3A_transformed">transformed</code></td>
<td>
<p>logical: Is <code>range</code> scaled according to
<code>plscale</code> rather than in original scale?
</p>
</td></tr>
<tr><td><code id="plticks_+3A_nouter">nouter</code></td>
<td>
<p>number of outer .. 
</p>
</td></tr>
<tr><td><code id="plticks_+3A_tickintervals">tickintervals</code></td>
<td>
<p>approximate number of tick intervals desired.
Default is taken from <code>ploptions('tickintervals')</code>.
</p>
</td></tr>
<tr><td><code id="plticks_+3A_ploptions">ploptions</code></td>
<td>
<p>pl options
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plticks</code> calls <code><a href="base.html#topic+pretty">pretty</a></code> for getting
tick locations if <code>plscale</code> is not specified and
<code><a href="#topic+prettyscale">prettyscale</a></code> if it is.
It generates another set for locations of tick labels if
<code>tickintervals</code> has 2 elements, such that not all ticks
are labelled. 
</p>
<p>The scaling function <code>plscale</code> can be given by its name
if that name is one of
<code>log, log10, logst, sqrt, asinp, logit, qnorm</code>.
Otherwise, it must be a function with an attribute
<code>inverse</code> that defines the inverse function.
It should also have an attribute <code>range</code> and an
attribute <code>range.transformed</code> if the possible
range for its argument or its values are restricted,
like <code><a href="#topic+asinp">asinp</a></code> that is defined for values between 0 and 100
and has values in the interval from 0 to 1.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>ticksat</code></td>
<td>
<p>locations of ticks</p>
</td></tr>
<tr><td><code>ticklabelsat</code></td>
<td>
<p>locations of tick labels</p>
</td></tr>
<tr><td><code>ticklabels</code></td>
<td>
<p>tick labels, if <code>plscale</code> is given</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+pretty">pretty</a></code>, <code><a href="#topic+prettyscale">prettyscale</a></code>, <code><a href="#topic+plaxis">plaxis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plticks(c(23,87))
plticks(c(23,91), plscale="asinp", transformed=FALSE,
  tickintervals=c(10,2))

asinp ## shows the attributes 'inverse', 'range' and 'range.transformed'
</code></pre>

<hr>
<h2 id='plyx'>Scatterplot, enhanced
</h2><span id='topic+plyx'></span>

<h3>Description</h3>

<p>A scatterplot or a bunch of them is produced according to
the concept of the  plplot  package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plyx(x = NULL, y = NULL, by=NULL, group = NULL, data = NULL, type = "p",
  panel = NULL, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL,
  markextremes = 0, rescale = TRUE, mar = NULL, mf = FALSE,
  plargs = NULL, ploptions = NULL, assign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plyx_+3A_x">x</code></td>
<td>
<p>either a formula or the data to be used for the horizontal
axis. If a formula of the type 'y~x', the variable 'y' in
'data' will be plotted against the variable(s) 'x'.
If a data.frame with more than one column is given,
each column will be used in turn to produce a plot.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_y">y</code></td>
<td>
<p>data to be used as the y axis.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_by">by</code></td>
<td>
<p>grouping factor: for each <code>by</code> group, a plot will be shown
for the respective subset of the data</p>
</td></tr>
<tr><td><code id="plyx_+3A_group">group</code></td>
<td>
<p>grouping that determines plotting symbols, colors, and
line types</p>
</td></tr>
<tr><td><code id="plyx_+3A_data">data</code></td>
<td>
<p>data.frame containing the variables if 'x' is a formula</p>
</td></tr>
<tr><td><code id="plyx_+3A_xlab">xlab</code>, <code id="plyx_+3A_ylab">ylab</code></td>
<td>
<p>axis labels</p>
</td></tr>
<tr><td><code id="plyx_+3A_xlim">xlim</code>, <code id="plyx_+3A_ylim">ylim</code></td>
<td>
<p>plot ranges</p>
</td></tr>
<tr><td><code id="plyx_+3A_type">type</code></td>
<td>
<p>type of plot, see <code>?<a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="plyx_+3A_panel">panel</code></td>
<td>
<p>panel function to do the actual drawing. See Details.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_markextremes">markextremes</code></td>
<td>
<p>proportion of extreme residuals to be labeled.
If all points should be labeled, let <code>markextremes=1</code>.</p>
</td></tr>
<tr><td><code id="plyx_+3A_rescale">rescale</code></td>
<td>
<p>logical. Only applies if there are multiple y
variables. If <code>TRUE</code>, the vertical axis will be adjusted
for each of these variables.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_mar">mar</code></td>
<td>
<p>plot margins, see <code><a href="graphics.html#topic+par">par</a></code>
</p>
</td></tr>
<tr><td><code id="plyx_+3A_mf">mf</code></td>
<td>
<p>number of multiple frames. If more than one plot will be
generated because of a grouping or multiple x variables,
multiple frames will be produced by calling <code><a href="#topic+plmframes">plmframes</a></code>
unless <code>mf</code> is <code>FALSE</code>.
If <code>mf</code> is <code>TRUE</code>, the function will determine the number
of rows and columns suitably. If <code>mf</code> is a vector of length 2,
these numbers will be used for the number of panels in rows and
columns (unless they are too large for the restriction in
<code>ploptions("mframesmax")</code>).
If it has lenngth 1, this is used as the total number of
panels on a page.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_plargs">plargs</code></td>
<td>
<p>result of calling <code>pl.control</code>.
If <code>NULL</code>, <code>pl.control</code> will be called to generate it.
If not null, arguments given in <code>...</code> will be ignored.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_ploptions">ploptions</code></td>
<td>
<p>list of pl options.
</p>
</td></tr>
<tr><td><code id="plyx_+3A_assign">assign</code></td>
<td>
<p>logical: Should the plargs be stored
in the <code>pl.envir</code> environment?
</p>
</td></tr>
<tr><td><code id="plyx_+3A_...">...</code></td>
<td>
<p> more arguments, to be passed to <code><a href="#topic+pl.control">pl.control</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel</code> defaults to <code>plpanel</code>, which results essentially in
<code><a href="graphics.html#topic+points">points</a></code> or <code><a href="graphics.html#topic+text">text</a></code>
depending on the argument <code>pch</code> including a smooth line,
to <code><a href="#topic+plmboxes">plmboxes</a></code> if  'x'  is a factor and  'y'  is not or
vice versa,
or to a modification of <code>sunflowers</code> if both are factors.<br />
The function must have the arguments <code>x</code> and <code>y</code>
to take the coordinates of the points and may have the arguments
<code>indx</code> and <code>indy</code> to transfer the two variables' indexes and
<code>panelargs</code> for any additional objects to be passed on.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Note</h3>

<p>There are many more arguments, obtained from <code>pl.control</code>,
see <code>?<a href="#topic+pl.control">pl.control</a></code>. These can be passed to <code>plmatrix</code>
by an argument <code>plargs</code> that is hidden in the ... argument list.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="#topic+plmatrix">plmatrix</a></code>, <code><a href="#topic+plcond">plcond</a></code>;
<code><a href="#topic+pl.control">pl.control</a></code>, <code><a href="#topic+ploptions">ploptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plyx(Petal.Width ~ Sepal.Length, data=iris)
plyx(Petal.Width ~ Sepal.Length+Sepal.Width, data=iris, smooth=TRUE,
     group=Species)
plyx(Petal.Length + Petal.Width ~ Sepal.Length+Sepal.Width,
     by  = Species, data=iris, smooth=TRUE)

</code></pre>

<hr>
<h2 id='predict.regrpolr'>Predict and Fitted for polr Models</h2><span id='topic+predict.regrpolr'></span><span id='topic+fitted.regrpolr'></span>

<h3>Description</h3>

<p>Methods of <code>predict</code> and <code>fitted</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regrpolr'
predict(object, newdata = NULL,
  type =  c("class", "probs", "link"), ...)
## S3 method for class 'regrpolr'
fitted(object, type = c("class", "probs", "link"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.regrpolr_+3A_object">object</code></td>
<td>
<p>result of <code>polr</code></p>
</td></tr>
<tr><td><code id="predict.regrpolr_+3A_newdata">newdata</code></td>
<td>
<p>data frame in which to look for variables with
which to predict.  If <code>NULL</code>, fitted values are produced.
</p>
</td></tr>
<tr><td><code id="predict.regrpolr_+3A_type">type</code></td>
<td>
<p>type of prediction:<br />
<code>"link"</code> asks for the linear predictor values.<br />
Other <code>type</code>s are available according to the standard
methods of the <code>predict</code> function.
</p>
</td></tr>
<tr><td><code id="predict.regrpolr_+3A_...">...</code></td>
<td>
<p>arguments passed to standard methods of <code>predict</code>
or <code>fitted</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of predicted or linear predictor values
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a>, <a href="stats.html#topic+fitted">fitted</a>, <a href="#topic+residuals.regrpolr">residuals.regrpolr</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("MASS")) {
data(housing, package="MASS")
rr &lt;- MASS::polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
aa &lt;- fitted(rr)
bb &lt;- predict(rr)
cc &lt;- predict.regrpolr(rr)
}
</code></pre>

<hr>
<h2 id='prettyscale'>Pretty Tickmark Locations for Transformed Scales
</h2><span id='topic+prettyscale'></span>

<h3>Description</h3>

<p>Compute about <code>n</code> 'round' values that are about equally spaced
in a transformed (plotting) scale and cover the range of the values
in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettyscale(x, transformed = FALSE, plscale = "log10", inverse = NULL, 
    range = NULL, range.transformed = NULL, n = NULL, logscale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettyscale_+3A_x">x</code></td>
<td>
<p>numeric vector of data (original scale)
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_transformed">transformed</code></td>
<td>
<p>logical: Is <code>x</code> scaled according to
<code>plscale</code> rather than in original scale?
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_plscale">plscale</code></td>
<td>
<p>name of the transformation defining the plotting scale
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_inverse">inverse</code></td>
<td>
<p>back (or inverse) back transformation
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_range">range</code>, <code id="prettyscale_+3A_range.transformed">range.transformed</code></td>
<td>
<p>admissible range of original and
transformed values, respectively. Usually not needed, cf. Details
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_n">n</code></td>
<td>
<p>approximate number of tickmark locations.
If of length <code>&gt;=2</code>, <code>n[2]</code> can be varied to obtain more
adequate locations. See Details.
</p>
</td></tr>
<tr><td><code id="prettyscale_+3A_logscale">logscale</code></td>
<td>
<p>if <code>NULL</code>, R's function <code>axTicks</code>
will be called if the plscale is a log function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>prettyscale</code> generates <code>n+2</code> &quot;anchor&quot; values in the
transformed scale which cover the range of the transformed <code>x</code>
values and are equidistant within the range.
It then back-transforms these anchor values. For each one of them,
say <code>c</code>, 
it seeks a pretty value near to it by the following construction:
it calls the R function <code>pretty</code> on the range given by the
back-transformed neighboring anchor values, asking for <code>n[2]</code>
pretty values. From these, it chooses the one for which the
transformed value is closest to the transformed <code>c</code>.
</p>
<p>Therefore, if <code>n[2]</code> is large, the pretty values may be less
pretty, whereas small <code>n[2]</code> may lead to equal pretty values
for neighboring anchors and thus to too few resulting pretty values.
The default value for <code>n[2]</code> is 3.
</p>
<p>The ranges are needed to get the limits as pretty values when
appropriate (and to avoid warning messages).
They are generated in the function for the commonly used plscales
and may be given as attributes of the <code>plscale</code> function,
see Examples.
</p>


<h3>Value</h3>

<p>Numeric vector of tick mark locations in transformed scale,
with an attribute <code>ticklabels</code> containing the appropriate
tick marks and labels (in original scale)
</p>


<h3>Note</h3>

<p>The function does not always lead to consistent results.
Increasing <code>n</code> sometimes leads to fewer resulting values.
</p>


<h3>Author(s)</h3>

<p>W. A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+axTicks">axTicks</a>, <a href="#topic+plticks">plticks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  prettyscale(10^rnorm(10))
  prettyscale(c(0.5, 2, 10, 90), plscale="sqrt")
  prettyscale(c(50,90,95,99), plscale="asinp", n=10)
  ## asinp has the useful attributes:
  asinp
</code></pre>

<hr>
<h2 id='prevgumbel'>&quot;Reverse&quot; Gumbel Distribution Functions</h2><span id='topic+drevgumbel'></span><span id='topic+prevgumbel'></span><span id='topic+qrevgumbel'></span><span id='topic+rrevgumbel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the &ldquo;Reverse&rdquo; Gumbel distribution with
parameters <code>location</code> and <code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drevgumbel (x, location = 0, scale = 1)
prevgumbel (q, location = 0, scale = 1)
qrevgumbel (p, location = 0, scale = 1)
rrevgumbel (n, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prevgumbel_+3A_x">x</code>, <code id="prevgumbel_+3A_q">q</code></td>
<td>
<p>numeric vector of abscissa (or quantile) values at which
to evaluate the density or distribution function.</p>
</td></tr>
<tr><td><code id="prevgumbel_+3A_p">p</code></td>
<td>
<p>numeric vector of probabilities at which to evaluate the
quantile function.</p>
</td></tr>
<tr><td><code id="prevgumbel_+3A_location">location</code></td>
<td>
<p>location of the distribution</p>
</td></tr>
<tr><td><code id="prevgumbel_+3A_scale">scale</code></td>
<td>
<p>scale (<code class="reqn">&gt; 0</code>) of the distribution.</p>
</td></tr>
<tr><td><code id="prevgumbel_+3A_n">n</code></td>
<td>
<p>number of random variates, i.e., <code><a href="base.html#topic+length">length</a></code> of
resulting vector of <code>rrevgumbel(..)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, of the same length as <code>x</code>, <code>q</code>, or
<code>p</code> for the first three functions, and of length <code>n</code> for
<code>rrevgumbel()</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel; partly inspired by package <span class="pkg">VGAM</span>.
Martin Maechler for numeric cosmetic.
</p>


<h3>See Also</h3>

<p>the <code><a href="stats.html#topic+Weibull">Weibull</a></code> distribution functions in <span class="rlang"><b>R</b></span>'s <span class="pkg">stats</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(prevgumbel(x, scale= 1/2), -3,2, n=1001, col=1, lwd=2,
      main = "revgumbel(x, scale = 1/2)")
abline(h=0:1, v = 0, lty=3, col = "gray30")
curve(drevgumbel(x, scale= 1/2),       n=1001, add=TRUE,
      col = (col.d &lt;- adjustcolor(2, 0.5)), lwd=3)
legend("left", c("cdf","pdf"), col=c("black", col.d), lwd=2:3, bty="n")

med &lt;- qrevgumbel(0.5, scale=1/2)
cat("The median is:",  format(med),"\n")
</code></pre>

<hr>
<h2 id='quantilew'>Quantiles for weighted observations
</h2><span id='topic+quantilew'></span>

<h3>Description</h3>

<p>Quantiles for weighted observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantilew(x, probs = c(0.25, 0.5, 0.75), weights = 1, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantilew_+3A_x">x</code></td>
<td>
<p>numeric vector whose sample quantiles are wanted
'NA' and 'NaN' values are not allowed unless 'na.rm' is 'TRUE'.
</p>
</td></tr>
<tr><td><code id="quantilew_+3A_probs">probs</code></td>
<td>

<p>numeric vector of probabilities with values in [0,1].
</p>
</td></tr>
<tr><td><code id="quantilew_+3A_weights">weights</code></td>
<td>

<p>numeric vector of weights. They will be standardized to sum to 1.
</p>
</td></tr>
<tr><td><code id="quantilew_+3A_na.rm">na.rm</code></td>
<td>

<p>remove NAs from 'x'? If FALSE and 'x' contains NAs, the value will be NA.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Empirical quantiles corresponding to the given probabilities and
weights. If a quantile is not unique since the cumulated weights
hit the probability value exactly (the case of the median of a sample
of even size), the mean of the corresponding values is returned.  
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- c(1,3,4,8,12,13,18,20)
   quantile(x, c(0.25, 0.5))
   quantilew(x, c(0.25, 0.5), weights=1:8)  ##  8  13
   ## relative weights  (1+2+3)/36  sum to  &lt;0.25 , with the forth, they
   ##   are over 0.25, therefore, the quantile is the 4th value
</code></pre>

<hr>
<h2 id='quinterpol'>Interpolated Quantiles
</h2><span id='topic+quinterpol'></span>

<h3>Description</h3>

<p>This function implements a version of empirical quantiles
based on interpolation 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quinterpol(x, probs = c(0.25, 0.5, 0.75), extend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quinterpol_+3A_x">x</code></td>
<td>
<p>vector of data determining the quantiles 
</p>
</td></tr>
<tr><td><code id="quinterpol_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities defining which quantiles should
be produced
</p>
</td></tr>
<tr><td><code id="quinterpol_+3A_extend">extend</code></td>
<td>
<p>logical: Should quantiled be calculated outside the
range of the data by linear extrapolation?
This may make sense if the sample is small or the data is rounded
or grouped or a score.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical quantile function jumps at the data values
according to the usual definition.
The version of quantiles calculated by 'quinterpol' avoids jumps.
It is based on linear interpolation of the step version of the
empirical cumulative distribution function, using as the given points
the midpoints of both vertical and horizontal pieces of the latter.
See 'examples' for a visualization.
</p>


<h3>Value</h3>

<p>vector of quantiles
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p>quantile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This example illustrates the definition of the "interpolated quantiles"

set.seed(2)
t.x &lt;- sort(round(2*rchisq(20,2)))
table(t.x)
t.p &lt;- ppoints(100)
plot(quinterpol(t.x,t.p),t.p, type="l")
</code></pre>

<hr>
<h2 id='residuals.regrpolr'>Residuals of a Binary, Ordered, or Censored Regression</h2><span id='topic+residuals.polr'></span><span id='topic+residuals.regrpolr'></span><span id='topic+residuals.regrsurvreg'></span><span id='topic+residuals.regrcoxph'></span>

<h3>Description</h3>

<p>Methods of <code>residuals</code> for classes
<code>polr, survreg</code> and <code>coxph</code>,
calculating quartiles and random numbers according to the
conditional distribution of residuals for the latent variable of a
binary or ordinal regression or a regression with censored response,
given the observed response value.
See Details for an explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polr'
residuals(object, type="condquant", ...)
## S3 method for class 'regrpolr'
residuals(object, type="condquant", ...)
## S3 method for class 'regrsurvreg'
residuals(object, type="condquant", ...)
## S3 method for class 'regrcoxph'
residuals(object, type="CoxSnellMod", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.regrpolr_+3A_object">object</code></td>
<td>
<p>the result of <code>polr</code>, of
<code>glm(,family=binomial)</code> with binary data
for the <code>regrpolr</code> method,
or of <code>survreg</code> or <code>coxph</code> for the respective methods.</p>
</td></tr>
<tr><td><code id="residuals.regrpolr_+3A_type">type</code></td>
<td>
<p>type of residuals:
<code>"condquant"</code> requires conditional quantiles (and more) of the
residuals of the model, see Details.<br />
For <code>residuals.regrsurvreg</code>, type <code>CoxSnellMod</code> yields
a modified version of Cox-Snell residuals, also including
a <code>condquant</code> attribute, see Details.<br />
Other <code>type</code>s are available according to the standard
methods of the <code>residuals</code> function.
</p>
</td></tr>
<tr><td><code id="residuals.regrpolr_+3A_...">...</code></td>
<td>
<p>arguments passed to standard methods of <code>residuals</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For binary and ordinal regression, the regression models can be
described by introducing a latent response variable Z of which the
observed response Y is a classified version, and for which a linear
regression applies. The errors of this &quot;latent regression&quot; have a
logistic distribution. Given the linearly predicted value eta[i],
which is the fitted value for the latent variable, the residual for
Z[i] can therefore be assumed to have a logistic distribution.
</p>
<p>This function calculates quantiles and random numbers according to the
conditional distribution of residuals for Z[i], given the observed
y[i].
</p>
<p>Modified Cox-Snell residuals:
Cox-Snell residuals are defined in a way that they always follow an
exponential distribution. Since this is an unususal law for residuals,
it is convenient to transform them such that they then obey a standard
normal distribution. See the vignette for more detail.
</p>


<h3>Value</h3>

<p>Vector of residual values. If conditional quantiles are requested,
the residuals for censored observations are replaced by conditional
medians, and an attribute <code>"condquant"</code> is attached, which is 
a data.frame with the variables
</p>
<table>
<tr><td><code>median</code></td>
<td>
<p>median of the conditional distributions</p>
</td></tr>
<tr><td><code>lowq</code></td>
<td>
<p>lower quartile</p>
</td></tr>
<tr><td><code>uppq</code></td>
<td>
<p>upper quartile</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>random number, drawn according to the conditional
distribution</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>probability of the condition being true</p>
</td></tr>
<tr><td><code>limlow</code>, <code>limup</code></td>
<td>
<p>lower and upper limits of the intervals</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>index of the observation in the sequence of the result
(residuals)</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>linear predictor value</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>observed response value</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>residuals.polr</code> and <code>residuals.regrpolr</code> are identical
for the time being. Only <code>type="condquant"</code> is available now.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>References</h3>

<p>See http://stat.ethz.ch/~stahel/regression</p>


<h3>See Also</h3>

<p><code><a href="#topic+condquant">condquant</a></code>, <code><a href="#topic+plregr">plregr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(MASS)
data(housing, package="MASS")
rr &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)
t.res &lt;- residuals.regrpolr(rr)
head   (t.res)
summary(t.res)
</code></pre>

<hr>
<h2 id='robrange'> Robust Range of Data </h2><span id='topic+robrange'></span>

<h3>Description</h3>

<p>Determines a robust range of the data on the basis of the trimmed mean
and mean absolute deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robrange(data, trim = 0.2, fac = 5.0, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robrange_+3A_data">data</code></td>
<td>
<p> a vector of data. Missing values are dropped </p>
</td></tr>
<tr><td><code id="robrange_+3A_trim">trim</code></td>
<td>
<p> trimming proportion </p>
</td></tr>
<tr><td><code id="robrange_+3A_fac">fac</code></td>
<td>
<p> factor used for expanding the range, see Details </p>
</td></tr>
<tr><td><code id="robrange_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: should NAs be removed? If FALSE, result will be
NA if there are NAs in 'data'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function determines the trimmed mean <code>m</code> and then the &quot;upper
trimmed mean&quot; <code>s</code> of absolute deviations from m, multiplied by
<code>fac</code>. The robust minimum is then defined as <code>m-fac*s</code> or
<code>min(data)</code>, whichever is larger, and similarly for the maximum.
</p>


<h3>Value</h3>

<p>The robust range.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plcoord">plcoord</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c(rnorm(20),rnorm(3,5,20))
  robrange(x)
</code></pre>

<hr>
<h2 id='shortenstring'>Shorten Strings
</h2><span id='topic+shortenstring'></span>

<h3>Description</h3>

<p>Strings are shortened if they are longer than
<code>n</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortenstring(x, n = 50, endstring = "..", endchars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortenstring_+3A_x">x</code></td>
<td>
<p>a string or a vector of strings
</p>
</td></tr>
<tr><td><code id="shortenstring_+3A_n">n</code></td>
<td>
<p>maximal character length
</p>
</td></tr>
<tr><td><code id="shortenstring_+3A_endstring">endstring</code></td>
<td>
<p>string(s) to be appended to the shortened strings
</p>
</td></tr>
<tr><td><code id="shortenstring_+3A_endchars">endchars</code></td>
<td>
<p>number of last characters to be shown at the end of
the abbreviated string. By default, it adjusts to <code>n</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abbreviated string(s)
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+substring">substring</a></code>, <code><a href="base.html#topic+abbreviate">abbreviate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shortenstring("abcdefghiklmnop", 8)

shortenstring(c("aaaaaaaaaaaaaaaaaaaaaa","bbbbc",
  "This text is certainly too long, don't you think?"),c(8,3,20))

</code></pre>

<hr>
<h2 id='showd'>Show a Part of a Data.frame</h2><span id='topic+showd'></span>

<h3>Description</h3>

<p>Shows a part of the data.frame which allows for grasping the nature of
the data. The function is typically used to make sure that the data is
what was desired and to grasp the nature of the variables in the phase
of getting acquainted with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showd(data, first = 3, nrow. = 4, ncol. = NULL, digits=getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showd_+3A_data">data</code></td>
<td>
<p>a data.frame, a matrix, or a vector</p>
</td></tr>
<tr><td><code id="showd_+3A_first">first</code></td>
<td>
<p>the first <code>first</code> rows will be shown and ...</p>
</td></tr>
<tr><td><code id="showd_+3A_nrow.">nrow.</code></td>
<td>
<p>a selection of <code>nrow.</code> rows will be shown in
addition. They will be selected with equal row number differences.
The last row is always included.</p>
</td></tr>
<tr><td><code id="showd_+3A_ncol.">ncol.</code></td>
<td>
<p>number of columns (variables) to be shown. The first and
last columns will also be included. If <code>ncol.</code> has more than
one element, it is used to identify the columns directly.</p>
</td></tr>
<tr><td><code id="showd_+3A_digits">digits</code></td>
<td>
<p>number of significant digits used in formatting numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tit</code> attribute of <code>data</code> will be printed if available and
<code>getUserOption("doc") &gt; 0</code>, and any <code>doc</code> attribute,
if <code>getUserOption("doc") &gt;= 2</code> (see <code><a href="#topic+tit">tit</a></code>).
</p>


<h3>Value</h3>

<p>returns invisibly the character vector containing the formatted data
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head</a></code> and <code><a href="utils.html#topic+tail">tail</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showd(iris)

data(d.birthrates)
names(d.birthrates)
## only show 7 columns, including the first and last
showd(d.birthrates, ncol=7)  

showd(cbind(1:100))
</code></pre>

<hr>
<h2 id='simresiduals'>Simulate Residuals</h2><span id='topic+simresiduals'></span><span id='topic+simresiduals.default'></span><span id='topic+simresiduals.gam'></span><span id='topic+simresiduals.glm'></span>

<h3>Description</h3>

<p>Simulates residuals for a given regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simresiduals(object, ...)
## Default S3 method:
simresiduals(object, nrep=19, simfunction=NULL,
  stdresiduals = NULL, sigma = object$sigma, ...)
## S3 method for class 'glm'
simresiduals(object, nrep=19, simfunction=NULL,
        glm.restype="working", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simresiduals_+3A_object">object</code></td>
<td>
<p>result of fitting a regression</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_simfunction">simfunction</code></td>
<td>
<p>if a function, it is used to generate random values for
the target variable, with three arguments, which will be fed by
the number of observations, the fitted values, and
<code>object$sigma</code> in the case of <code>simresiduals.default</code>,
respectively. <br />
If TRUE, the appropriate random number generator will be used.<br />
If NULL (default) the standardized residuals of
<code>object</code> will be randomly permuted in the case of
<code>simresiduals.default</code>. For <code>simresiduals.glm</code>,
this is the same as TRUE.
</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_stdresiduals">stdresiduals</code></td>
<td>
<p>logical: should standardized residuals be
produced?</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter to be used, defaults to
<code>object$sigma</code>
</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_glm.restype">glm.restype</code></td>
<td>
<p>type of residuals to be generated (for glm)
Warning: type &quot;deviance&quot; may produce NAs.</p>
</td></tr>
<tr><td><code id="simresiduals_+3A_...">...</code></td>
<td>
<p>further arguments passed to forthcoming methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulated residuals are obtained for the default method
by replacing the response variable by permuted standardized residuals
of the fitted regression, multiplied by the scale
<code>object\$sigma</code>, then fitting the model to these residuals and
getting the reseiduals  from this new fit.
This is repeated <code>nrep</code> times.
If standarized residuals are not available, ordinary residuals are
used.
</p>
<p>For the <code>glm</code> method, the values of the response variable are
obtained from simulating according to the model (binomial or Poisson),
and the model is re-fitted to these generated values.
</p>


<h3>Value</h3>

<p>A matrix of which each column contains an set of simulated residuals.
If standardized residuals are available,
attribute <code>"stdresisduals"</code> is the matrix containing corresponding
standardized residuals.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge),
  data=d.blast)
r.simblast &lt;- simresiduals(r.blast, nrep=5)
showd(r.simblast)
## --------------------------
data(d.babysurvival)
r.babysurv &lt;- lm( Survival~Weight+Age+Apgar1, data=d.babysurvival)
r.simbs &lt;- simresiduals(r.babysurv, nrep=5)
showd(r.simbs)
</code></pre>

<hr>
<h2 id='smoothpar'>
Adjust the smoothing parameter to number of observations
</h2><span id='topic+smoothpar'></span>

<h3>Description</h3>

<p>Adjust the smoothing parameter to number of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothpar(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothpar_+3A_n">n</code></td>
<td>
<p>number of observations
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothing parameter
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smoothpar(50)
  t.n &lt;- c(5,10,20,100,1000)
  smoothpar(t.n)
</code></pre>

<hr>
<h2 id='smoothRegr'>Smoothing function used as a default in plgraphics /
straight line &quot;smoother&quot;
</h2><span id='topic+smoothRegr'></span><span id='topic+smoothLm'></span>

<h3>Description</h3>

<p>These functions wrap the <code>loess</code> smoothing function or
the <code>lm.fit</code> function in order to meet the argument conventions
used in the <code>plgraphics</code> package.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothRegr(x, y, weights = NULL, par = NULL, iterations = 50, minobs=NULL, ...)
smoothLm(x, y, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothRegr_+3A_x">x</code></td>
<td>
<p>vector of x values
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_y">y</code></td>
<td>
<p>vector of y values to be smoothed
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_weights">weights</code></td>
<td>
<p>vector of weigths used for fitting the smooth 
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_par">par</code></td>
<td>
<p>value for the <code>span</code> argument of <code>loess</code>.
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations for the <code>loess</code> algorithm.
If <code>==1</code>, the non-robust, least squares version is applied.
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_minobs">minobs</code></td>
<td>
<p>minimal number of observations. If less valid observations
are provided, the result is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="smoothRegr_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>loess</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of smoothed values, with an attribute <code>xtrim</code>,
which is 1 for <code>smoothRegr</code> and 0 for <code>smoothLm</code>.
If <code>loess</code> fails, NAs will be returned without issuing a
warning.<br />
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">loess</a></code>, <code><a href="#topic+gensmooth">gensmooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.x &lt;- (1:50)^1.5
t.y &lt;- log10(t.x) + rnorm(length(t.x),0,0.3)
t.y[40] &lt;- 5
r.sm &lt;- smoothRegr(t.x, t.y, par=0.5)
r.sm1 &lt;- smoothRegr(t.x, t.y, iterations=1, par=0.5)

plot(t.x,t.y)
lines(t.x,r.sm, col=2)
lines(t.x,r.sm1, col=3)

</code></pre>

<hr>
<h2 id='smoothxtrim'>
Adjust range for smooth lines to number of observations
</h2><span id='topic+smoothxtrim'></span>

<h3>Description</h3>

<p>The range in which smooth lines are drawn should be restricted in
order to avoid the ill determined parts at both ends.
The proportion of suppressed values is determined as a function of
the number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothxtrim(n, c=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothxtrim_+3A_n">n</code></td>
<td>
<p>number of observations
</p>
</td></tr>
<tr><td><code id="smoothxtrim_+3A_c">c</code></td>
<td>
<p>tuning parameter: how rapidly should the result decrease
with <code>n</code>?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proportion of x values for which the smoothline will not be shown
on both ends. Equals \ 1.6^(log10(n)*c) / n
</p>


<h3>Author(s)</h3>

<p>W. Stahel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  smoothxtrim(50)
  t.n &lt;- c(5,10,20,100,1000)
  t.n * smoothxtrim(t.n)
</code></pre>

<hr>
<h2 id='stamp'> Add a &quot;Stamp&quot;, i.e., an Identification Line to a Plot </h2><span id='topic+stamp'></span>

<h3>Description</h3>

<p>A line is added to the current plot in the lower right corner
that contains project information and date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp(sure = TRUE, outer.margin = NULL, 
      project = getOption("project"), step = getOption("step"),
      stamp = NULL, line = NULL, ploptions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp_+3A_sure">sure</code></td>
<td>
<p> if FALSE, the stamp will only be added if
<code>options("stamp")&gt;0</code> </p>
</td></tr>
<tr><td><code id="stamp_+3A_outer.margin">outer.margin</code></td>
<td>
<p> if TRUE, the stamp is put to the outer margin of
the plot.  This is the default if the plot is currently split into panels.</p>
</td></tr>
<tr><td><code id="stamp_+3A_project">project</code>, <code id="stamp_+3A_step">step</code></td>
<td>
<p>character string describing the project and the step of
analysis.</p>
</td></tr>
<tr><td><code id="stamp_+3A_stamp">stamp</code></td>
<td>
<p>controls default action, see details </p>
</td></tr>
<tr><td><code id="stamp_+3A_line">line</code></td>
<td>
<p>line in the (outer) margin on which the stamp should be
shown.
</p>
</td></tr>
<tr><td><code id="stamp_+3A_ploptions">ploptions</code></td>
<td>
<p>pl options</p>
</td></tr>
<tr><td><code id="stamp_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>mtext</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to document plots produced during a data
analysis. It is called by all plotting functions of this package.
For getting final presentation versions of the plots, the stamp can be
suppressed by changing the default by calling <code>options(stamp=0)</code>.
</p>
<p>In more detail:  If <code>stamp==0</code>
(or <code>options("stamp")==0</code>)
the function will only do its thing if <code>sure==TRUE</code>.
</p>
<p>If <code>stamp==2</code>, it will certainly do it.
</p>
<p>If <code>stamp==1</code> and <code>sure==FALSE</code>, the stamp is added when a
plot page is complete.
</p>


<h3>Value</h3>

<p>invisibly returns the string that is added to the plot &ndash;
consisting of project title, step title and
current date (including time).
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(project="Example A",  step="regression analysis")
plot(1:10)
stamp() ##-&gt; "stamp" at bottom of right border
</code></pre>

<hr>
<h2 id='stdresiduals'>Get Standardized Residuals</h2><span id='topic+stdresiduals'></span>

<h3>Description</h3>

<p>Calculates standardized residuals and leverage values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdresiduals(x, residuals=NULL, sigma=x$sigma, weights=NULL,
             leveragelimit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdresiduals_+3A_x">x</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="stdresiduals_+3A_residuals">residuals</code></td>
<td>
<p>unstandardized residuals. If missing, they are
obtained from <code>x</code>
</p>
</td></tr>
<tr><td><code id="stdresiduals_+3A_sigma">sigma</code></td>
<td>
<p>error standard deviation or other scale</p>
</td></tr>
<tr><td><code id="stdresiduals_+3A_weights">weights</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="stdresiduals_+3A_leveragelimit">leveragelimit</code></td>
<td>
<p>scalar a little smaller than 1:
limit on leverage values to avoid unduely large or infinite
standardized residuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference to <code><a href="MASS.html#topic+stdres">stdres</a>()</code> from package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>
is that <code>stdresiduals</code> also applies to multivariate regression
and can be used with regression model fits not inheriting from <code>lm</code>.
</p>
<p>The function uses the <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition of <code>object</code>.
If necessary, it generates it.
</p>


<h3>Value</h3>

<p>vector or matrix of standardized residuals,
with attributes<br />
<code>attr(.,"stdresratio")</code>:
ratio of standardized / unstandardized residuals,<br />
<code>attr(.,"leverage")</code>: leverage (hat) values,<br />
<code>attr(.,"weighted")</code>: weights used in the standardization,<br />
<code>attr(.,"stddev")</code>: error standard deviation or scale parameter.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+stdres">stdres</a>; <a href="stats.html#topic+hat">hat</a>; <a href="stats.html#topic+hatvalues">hatvalues</a>; <a href="stats.html#topic+influence">influence</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
r.blast &lt;-
  lm(log10(tremor)~location+log10(distance)+log10(charge), data=d.blast)
t.stdr &lt;- stdresiduals(r.blast)
showd(t.stdr)
showd(attr(t.stdr, "leverage"))
</code></pre>

<hr>
<h2 id='sumNA'>Count NAs</h2><span id='topic+sumNA'></span>

<h3>Description</h3>

<p>Count the missing or non-finite values for each column of a matrix or
data.frame 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumNA(object, inf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumNA_+3A_object">object</code></td>
<td>
<p>a vector, matrix, or data.frame</p>
</td></tr>
<tr><td><code id="sumNA_+3A_inf">inf</code></td>
<td>
<p>if TRUE, Inf and NaN values are counted along with NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector containing the missing value counts for each column
</p>


<h3>Note</h3>

<p>This is a simple shortcut for <code>apply(is.na(object),2,sum)</code>
or <code>apply(!is.finite(object),2,sum)</code>
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.na">is.na</a></code>, <a href="Matrix.html#topic+is.finite">is.finite</a>, <a href="#topic+dropNA">dropNA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.d &lt;- data.frame(V1=c(1,2,NA,4), V2=c(11,12,13,Inf), V3=c(21,NA,23,Inf))
sumNA(t.d)
</code></pre>

<hr>
<h2 id='Tobit'>Prepare a Response for a Tobit Model</h2><span id='topic+Tobit'></span>

<h3>Description</h3>

<p>Returns a <code>Surv</code> object that allows for setting up a Tobit
regression model by calling <code>survreg</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tobit(data, limit = 0, limhigh = NULL, transform = NULL, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tobit_+3A_data">data</code></td>
<td>

<p>the variable to be used as the response in the Tobit regression
</p>
</td></tr>
<tr><td><code id="Tobit_+3A_limit">limit</code></td>
<td>

<p>Lower limit which censors the observations.
If <code>log</code> is <code>TRUE</code>, then the default is the minimal value
of <code><a href="#topic+logst">logst</a></code>(data), and if <code>limit&gt;0</code>, it refers to the
untransformed data.
</p>
</td></tr>
<tr><td><code id="Tobit_+3A_limhigh">limhigh</code></td>
<td>

<p>Upper limit which censors the observations (for untransformed data).
</p>
</td></tr>
<tr><td><code id="Tobit_+3A_transform">transform</code></td>
<td>

<p>if data should be transformed, specify the function to be used.
</p>
</td></tr>
<tr><td><code id="Tobit_+3A_log">log</code></td>
<td>

<p>logical. If <code>TRUE</code>, <code>data</code> will be log transformed
by calling <code><a href="#topic+logst">logst</a></code>. Argument <code>transform</code> will be
ignored.
</p>
</td></tr>
<tr><td><code id="Tobit_+3A_...">...</code></td>
<td>

<p>any additional arguments to the <code>transform</code> function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tobit regression is a special case of regression with left censored
response data. The function <code>survreg</code> is suitable for fitting.
In <code>regr</code>, this is done automatically.
</p>


<h3>Value</h3>

<p>A <code>Surv</code> object.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+Surv">Surv</a>()</code> from package <a href="https://CRAN.R-project.org/package=survival"><span class="pkg">survival</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("survival")) {
data("tobin", package="survival")

Tobit(tobin$durable)
(t.r &lt;- survival::survreg(Tobit(durable) ~ age + quant,
                          data = tobin, dist="gaussian"))
if(interactive())
    plregr(t.r)
}
</code></pre>

<hr>
<h2 id='transferAttributes'>Transfer Attributes
</h2><span id='topic+transferAttributes'></span>

<h3>Description</h3>

<p>Attach the attributes of an object to another object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transferAttributes(x, xbefore, except = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferAttributes_+3A_x">x</code></td>
<td>
<p>the object to which the attributes should be transferred
</p>
</td></tr>
<tr><td><code id="transferAttributes_+3A_xbefore">xbefore</code></td>
<td>
<p>the object which delvers the attributes
</p>
</td></tr>
<tr><td><code id="transferAttributes_+3A_except">except</code></td>
<td>
<p>names of attributes that will not be transferred</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object <code>x</code> with attributes from <code>xbefore</code> (and possibly
some that it already had)
</p>


<h3>Note</h3>

<p>This function would not be needed if <code>structure</code>
allowed for a list of attributes.
</p>


<h3>Author(s)</h3>

<p>W. A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+structure">structure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- structure(1:10, title="sequence")
transferAttributes(31:40, a)
</code></pre>

<hr>
<h2 id='warn'>List Warnings</h2><span id='topic+warn'></span>

<h3>Description</h3>

<p>Gives a List of Warnings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn()
</code></pre>


<h3>Details</h3>

<p>This function simplyfies the output of <code><a href="base.html#topic+warnings">warnings</a></code> if there
are several identical warnings, by counting their occurence
</p>


<h3>Value</h3>

<p>the table of warnings
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+warnings">warnings</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in 3:6) m &lt;- matrix(1:7, 3, i)

suppressWarnings(  ## or set  options(warn=-1)
for (i in 3:6) m &lt;- matrix(1:7, 3, i))
warn()
</code></pre>

<hr>
<h2 id='weekday'>Get Day of Week or Year, Month, Day
</h2><span id='topic+weekday'></span><span id='topic+ymd'></span>

<h3>Description</h3>

<p>From Dates, obtain the day of the week or
the year, month and day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weekday(date, month = NULL, day = NULL, out = NULL, factor = FALSE)
ymd(date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weekday_+3A_date">date</code></td>
<td>
<p>date(s), given as a <code>Date</code> object, a character object
that can be converted into a <code>Date</code>, or as julian,
or the year, in which case <code>month</code> and <code>day</code> must be given.
</p>
</td></tr>
<tr><td><code id="weekday_+3A_month">month</code>, <code id="weekday_+3A_day">day</code></td>
<td>
<p>If the first argument is the year, these arguments
must also be given.
</p>
</td></tr>
<tr><td><code id="weekday_+3A_factor">factor</code></td>
<td>
<p>logical: Should the result be a (ordered) factor?
</p>
</td></tr>
<tr><td><code id="weekday_+3A_out">out</code></td>
<td>
<p>selection of output: either
<code>"numeric"</code> for numeric output
(0 for Sunday, ... 6 for Saturday),
<code>"full"</code> or <code>"long"</code> for full weekday names, or
<code>"short"</code> for abbreviated (3 character) names.
Defaults to <code>"full"</code> if <code>factor</code> is <code>TRUE</code>,
to <code>"numeric"</code> otherwise.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>weekdays</code>,
the output is as described above, depending on
<code>factor</code> and <code>out</code>.
</p>


<h3>Note</h3>

<p>The functions call functions from the <code>chron</code>
package
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel
</p>


<h3>See Also</h3>

<p><code><a href="chron.html#topic+day.of.week">day.of.week</a>, <a href="chron.html#topic+month.day.year">month.day.year</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weekday(c("2020-05-01", "2020-05-02"), factor=TRUE)
## [1] Thursday Sunday  
## Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; Friday &lt; Saturday

dt &lt;- ymd(18100+1:5)
weekday(dt)
## [1] 3 4 5 6 0
</code></pre>

<hr>
<h2 id='xdistResdiff'>Residual Differences for Near Replicates: Tabulate and Test
</h2><span id='topic+xdistResdiff'></span><span id='topic+xdistResscale'></span><span id='topic+plot.xdistResscale'></span>

<h3>Description</h3>

<p>A test for the completeness of a linear regression model can be
performed based on comparing the differences of residuals for
pairs of observations that are close to each other to the
estimated standard deviation of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xdistResdiff(object, perc = c(3, 10, 80), trim = 0.1,
  nmax = 100, out = "aggregate")
xdistResscale(x, perc = c(3, 10, 90), trim = 1/6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xdistResdiff_+3A_object">object</code></td>
<td>
<p>an object containing the result of fitting a linear
model by <code>regr</code></p>
</td></tr>
<tr><td><code id="xdistResdiff_+3A_x">x</code></td>
<td>
<p>an object produced by <code>xdistResdiff</code></p>
</td></tr>
<tr><td><code id="xdistResdiff_+3A_perc">perc</code></td>
<td>
<p>Percentage points to define distance classes</p>
</td></tr>
<tr><td><code id="xdistResdiff_+3A_trim">trim</code></td>
<td>
<p>Trimming proportion for calculating means of
absolute residual differences</p>
</td></tr>
<tr><td><code id="xdistResdiff_+3A_nmax">nmax</code></td>
<td>
<p>maximal number of observations to form pairs</p>
</td></tr>
<tr><td><code id="xdistResdiff_+3A_out">out</code></td>
<td>
<p>determines the value of <code>xdistResdiff</code>:
if <code>=="aggregate"</code> (the default), the value will be
produced by calling <code>xdistResscale</code>, otherwise,
all x distances and respective residual differences will be
returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See package vignette.
</p>


<h3>Value</h3>

<p>For <code>xdistResdiff</code> with <code>out="aggregate"</code> and
<code>xdistResscale</code>, a matrix is returned with a row for
each class of x distances and the columns
</p>
<table>
<tr><td><code>xdist</code></td>
<td>
<p>mean x distance</p>
</td></tr>
<tr><td><code>rdiff.mean</code></td>
<td>
<p>absolute differences of residuals for pairs of
observations in the distance class, averaged over the class</p>
</td></tr>
<tr><td><code>rdiff.simmean</code></td>
<td>
<p>mean of (trimmed) means for simulated data</p>
</td></tr>
<tr><td><code>rdiff.se</code></td>
<td>
<p>standard error of (trimmed) means as obtained from
simulation</p>
</td></tr>
</table>
<p>The matrix carries along the following attributes:
</p>
<table>
<tr><td><code>perc</code></td>
<td>
<p>given argument <code>perc</code></p>
</td></tr>
<tr><td><code>xd.classlim</code></td>
<td>
<p>the actual class limits corresponding to
<code>perc</code></p>
</td></tr>
<tr><td><code>trim</code></td>
<td>
<p>given argument <code>trim</code></p>
</td></tr>
<tr><td><code>rdiff.grandmean</code></td>
<td>
<p>overall mean of absolute residual differences</p>
</td></tr>
<tr><td><code>p-values</code></td>
<td>
<p>p values for the classes as obtained from simulation,
and p-value for the sum of squares statistic</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>The value has S3 class <code>xdistResscale</code> and
<code>matrix</code></p>
</td></tr></table>
<p>.
</p>
<p>If <code>xdistResdiff</code> with <code>out</code> different from
<code>"aggregate"</code>, then a data.frame is returned containing a row for
each pair of observations and the columns
</p>
<table>
<tr><td><code>id1</code>, <code>id2</code></td>
<td>
<p>the labels of the two observations</p>
</td></tr>
<tr><td><code>xdist</code></td>
<td>
<p>the x distance between the two observations</p>
</td></tr>
<tr><td><code>resdiff</code></td>
<td>
<p>the difference of residuals for the two observations</p>
</td></tr>
</table>
<p>The value has S3 class <code>xdistResdiff</code> and <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Werner A. Stahel, ETH Zurich</p>


<h3>References</h3>

<p>See package vignette.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.xdistResscale">plot.xdistResscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(d.blast)
rr &lt;- lm(tremor~distance+charge, data=d.blast)
## an inadequate model!
xdrs &lt;- xdistResdiff(rr)
xdrd &lt;- xdistResdiff(rr, out="all")
showd(xdrd)
xdrs &lt;- xdistResscale(xdrd)
## same as first call of  xdiffResdiff
plot(xdrs)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
