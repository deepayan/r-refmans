<!DOCTYPE html><html lang="en"><head><title>Help for package PTXQC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PTXQC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PTXQC-package'><p>PTXQC: A package for computing Quality Control (QC) metrics for Proteomics (PTX)</p></a></li>
<li><a href='#+25+2B+25'><p>A string concatenation function, more readable than 'paste()'.</p></a></li>
<li><a href='#alignmentCheck'><p>Verify an alignment by checking the retention time differences of identical peptides across Raw files</p></a></li>
<li><a href='#appendEnv'><p>Add the value of a variable to an environment (fast append)</p></a></li>
<li><a href='#assembleMZQC'><p>Collects all 'mzQC' members from each entry in lst_qcMetrics and stores them in an overall mzQC object, which can be written to disk (see writeMZQC()) or augmented otherwise</p></a></li>
<li><a href='#assignBlocks'><p>Assign set numbers to a vector of values.</p></a></li>
<li><a href='#boxplotCompare'><p>Boxplots - one for each condition (=column) in a data frame.</p></a></li>
<li><a href='#brewer.pal.Safe'><p>Return color brew palettes, but fail hard if number of requested colors</p>
is larger than the palette is holding.</a></li>
<li><a href='#byX'><p>Calls FUN on a subset of data in blocks of size 'subset_size' of unique indices.</p></a></li>
<li><a href='#byXflex'><p>Same as <code>byX</code>, but with more flexible group size, to avoid that the last group has only a few entries (&lt;50% of desired size).</p></a></li>
<li><a href='#checkEnglishLocale'><p>When MaxQuant is run with a wrong locale (i.e. the decimal separator is not a '.', but a ','),</p>
then MaxQuant results are plainly wrong and broken. The can be detected by, e.g. checking for negative charge annotation</a></li>
<li><a href='#computeMatchRTFractions'><p>Combine several data structs into a final picture for segmentation incurred by 'Match-between-runs'.</p></a></li>
<li><a href='#correctSetSize'><p>Re-estimate a new set size to split a number of items into equally sized sets.</p></a></li>
<li><a href='#createReport'><p>Create a quality control report (in PDF format).</p></a></li>
<li><a href='#createYaml'><p>Creates a yaml file storing the parameters that are used for creating the PTXQC report</p>
and returns these parameters as well as a list of available qc-Metrics objects.</a></li>
<li><a href='#CV'><p>Coefficient of variation (CV)</p></a></li>
<li><a href='#darken'><p>Make a color (given as name or in RGB) darker by factor x = [0 = black, 1=unchanged]</p></a></li>
<li><a href='#del0'><p>Replace 0 with NA in a vector</p></a></li>
<li><a href='#delLCP'><p>Removes the longest common prefix (LCP) from a vector of strings.</p></a></li>
<li><a href='#delLCS'><p>Removes the longest common suffix (LCS) from a vector of strings.</p></a></li>
<li><a href='#FilenameMapper-class'><p>Make sure to call $readMappingFile(some_file) if you want to support a user-defined file mapping.</p>
Otherwise, calls to $getShortNames() will create/augment the mapping for filenames.</a></li>
<li><a href='#findAlignReference'><p>Return list of raw file names which were reported by MaxQuant as reference point for alignment.</p></a></li>
<li><a href='#fixCalibration'><p>Detect (and fix) MaxQuant mass recalibration columns, since they</p>
sometimes report wrong values.</a></li>
<li><a href='#flattenList'><p>Flatten lists of lists with irregular depths to just a list of items,</p>
i.e. a list of the leaves (if you consider the input as a tree).</a></li>
<li><a href='#getAbundanceClass'><p>Assign a relative abundance class to a set of (log10) abundance values</p></a></li>
<li><a href='#getECDF'><p>Estimate the empirical density and return it</p></a></li>
<li><a href='#getFileEncoding'><p>Determine if a file is 'UTF-8' or 'UTF-8-BOM' (as of MQ2.4) or 'UTF-16BE' or 'UTF-16LE'</p></a></li>
<li><a href='#getFragmentErrors'><p>Extract fragment mass deviation errors from a data.frame from msms.txt</p></a></li>
<li><a href='#getHTMLTable'><p>Create an HTML table with an extra header row</p></a></li>
<li><a href='#getMaxima'><p>Find the local maxima in a vector of numbers.</p></a></li>
<li><a href='#getMetaData'><p>Extract meta information (orderNr, metric name, category)</p>
from a list of Qc metric objects</a></li>
<li><a href='#getMetaFilenames'><p>Parses the given mqpar.xml file (or, if not found, tries the 'txt_folder' + '/../../' folder (i.e. where the raw data should be)) to extract the full filepaths for all Raw files</p></a></li>
<li><a href='#getMetricsObjects'><p>Get all currently available metrics</p></a></li>
<li><a href='#getMQPARValue'><p>Retrieve a parameter value from a mqpar.xml file</p></a></li>
<li><a href='#getPCA'><p>Create a principal component analysis (PCA) plot for the first two dimensions.</p></a></li>
<li><a href='#getPeptideCounts'><p>Extract the number of peptides observed per Raw file</p>
from an evidence table.</a></li>
<li><a href='#getProteinCounts'><p>Extract the number of protein groups observed per Raw file</p>
from an evidence table.</a></li>
<li><a href='#getQCHeatMap'><p>Generate a Heatmap from a list of QC measurements.</p></a></li>
<li><a href='#getReportFilenames'><p>Assembles a list of output file names, which will be created during reporting.</p></a></li>
<li><a href='#getRunQualityTemplate'><p>Get an mzQC runQuality without actual metrics, but with full metadata</p></a></li>
<li><a href='#ggAxisLabels'><p>Function to thin out the number of labels shown on an axis in GGplot</p></a></li>
<li><a href='#ggText'><p>Plot a text as graphic using ggplot2.</p></a></li>
<li><a href='#grepv'><p>Grep with values returned instead of indices.</p></a></li>
<li><a href='#idTransferCheck'><p>Check how close transferred ID's after alignment are to their genuine IDs within one Raw file.</p></a></li>
<li><a href='#inMatchWindow'><p>For grouped peaks: separate them into in-width vs. out-width class.</p></a></li>
<li><a href='#lcpCount'><p>Count the number of chars of the longest common prefix</p></a></li>
<li><a href='#LCS'><p>Compute longest common substring of two strings.</p></a></li>
<li><a href='#lcsCount'><p>Count the number of chars of the longest common suffix</p></a></li>
<li><a href='#LCSn'><p>Find longest common substring from 'n' strings.</p></a></li>
<li><a href='#longestCommonPrefix'><p>Get the longest common prefix from a set of strings.</p></a></li>
<li><a href='#longestCommonSuffix'><p>Like longestCommonPrefix(), but on the suffix.</p></a></li>
<li><a href='#modsToTable'><p>Convert list of (mixed)modifications to a frequency table</p></a></li>
<li><a href='#modsToTableByRaw'><p>Convert list of (mixed)modifications to a frequency table</p></a></li>
<li><a href='#mosaicize'><p>Prepare a Mosaic plot of two columns in long format.</p></a></li>
<li><a href='#MQDataReader-class'><p>S5-RefClass to read MaxQuant .txt files</p></a></li>
<li><a href='#MzTabReader-class'><p>Class to read an mzTab file and store the tables internally.</p></a></li>
<li><a href='#pasten'><p>paste with newline as separator</p></a></li>
<li><a href='#pastet'><p>paste with tab as separator</p></a></li>
<li><a href='#peakSegmentation'><p>Determine fraction of evidence which causes segmentation, i.e. sibling peaks at different RTs</p>
confirmed either by genuine or transferred MS/MS.</a></li>
<li><a href='#peakWidthOverTime'><p>Discretize RT peak widths by averaging values per time bin.</p></a></li>
<li><a href='#plot_CalibratedMSErr'><p>Plot bargraph of uncalibrated mass errors for each Raw file.</p></a></li>
<li><a href='#plot_Charge'><p>The plots shows the charge distribution per Raw file.</p>
The output of 'mosaicize()' can be used directly.</a></li>
<li><a href='#plot_ContEVD'><p>Plot contaminants from evidence.txt, broken down into top5-proteins.</p></a></li>
<li><a href='#plot_ContsPG'><p>Plot contaminants from proteinGroups.txt</p></a></li>
<li><a href='#plot_ContUser'><p>Plot user-defined contaminants from evidence.txt</p></a></li>
<li><a href='#plot_ContUserScore'><p>Plot Andromeda score distribution of contaminant peptide vs. matrix peptides.</p></a></li>
<li><a href='#plot_CountData'><p>Plot Protein groups per Raw file</p></a></li>
<li><a href='#plot_DataOverRT'><p>Plot some count data over time for each Raw file.</p></a></li>
<li><a href='#plot_IDRate'><p>Plot percent of identified MS/MS for each Raw file.</p></a></li>
<li><a href='#plot_IDsOverRT'><p>Plot IDs over time for each Raw file.</p></a></li>
<li><a href='#plot_IonInjectionTimeOverRT'><p>Plot line graph of TopN over Retention time.</p></a></li>
<li><a href='#plot_MBRAlign'><p>Plot MaxQuant Match-between-runs alignment performance.</p></a></li>
<li><a href='#plot_MBRgain'><p>Plot MaxQuant Match-between-runs id transfer performance as a scatterplot.</p></a></li>
<li><a href='#plot_MBRIDtransfer'><p>Plot MaxQuant Match-between-runs id transfer performance.</p></a></li>
<li><a href='#plot_MissedCleavages'><p>Plot bargraph of missed cleavages.</p></a></li>
<li><a href='#plot_MS2Decal'><p>Plot bargraph of oversampled 3D-peaks.</p></a></li>
<li><a href='#plot_MS2Oversampling'><p>Plot bargraph of oversampled 3D-peaks.</p></a></li>
<li><a href='#plot_peptideMods'><p>Plot peptide modification frequencies</p></a></li>
<li><a href='#plot_RatiosPG'><p>Plot ratios of labeled data (e.g. SILAC) from proteinGroups.txt</p></a></li>
<li><a href='#plot_RTPeakWidth'><p>Plot RT peak width over time</p></a></li>
<li><a href='#plot_ScanIDRate'><p>Plot line graph of TopN over Retention time.</p></a></li>
<li><a href='#plot_TIC'><p>Plot Total Ion Count over time</p></a></li>
<li><a href='#plot_TopN'><p>Plot line graph of TopN over Retention time.</p></a></li>
<li><a href='#plot_TopNoverRT'><p>Plot line graph of TopN over Retention time.</p></a></li>
<li><a href='#plot_UncalibratedMSErr'><p>A boxplot of uncalibrated mass errors for each Raw file.</p></a></li>
<li><a href='#plotTable'><p>Plot a table with row names and title</p></a></li>
<li><a href='#plotTableRaw'><p>Colored table plot.</p></a></li>
<li><a href='#pointsPutX'><p>Distribute a set of points with fixed y-values on a stretch of the x-axis.</p></a></li>
<li><a href='#print.PTXQC_table'><p>helper S3 class, enabling print(some-plot_Table-object)</p></a></li>
<li><a href='#printWithFooter'><p>Augment a ggplot with footer text</p></a></li>
<li><a href='#QCMetaFilenames'><p>Define a Singleton class which holds the full raw filenames (+path) and their PSI-MS CV terms for usage in the mzQC metadata</p></a></li>
<li><a href='#qcMetric_MSMSScans_TopNoverRT-class'><p>Metric for msmsscans.txt, showing TopN over RT.</p></a></li>
<li><a href='#qcMetric-class'><p>Class which can compute plots and generate mzQC output (usually for a single metric).</p></a></li>
<li><a href='#qualBestKS'><p>From a list of vectors, compute all vs. all Kolmogorov-Smirnoff distance statistics (D)</p></a></li>
<li><a href='#qualCentered'><p>Quality metric for 'centeredness' of a distribution around zero.</p></a></li>
<li><a href='#qualCenteredRef'><p>Quality metric for 'centeredness' of a distribution around zero with a user-supplied range threshold.</p></a></li>
<li><a href='#qualGaussDev'><p>Compute probability of Gaussian (mu=m, sd=s) at a position 0, with reference</p>
to the max obtainable probability of that Gaussian at its center.</a></li>
<li><a href='#qualHighest'><p>Score an empirical density distribution of values, where the best possible distribution is right-skewed.</p></a></li>
<li><a href='#qualLinThresh'><p>Quality metric with linear response to input, reaching the maximum score at the given threshold.</p></a></li>
<li><a href='#qualMedianDist'><p>Quality metric which measures the absolute distance from median.</p></a></li>
<li><a href='#qualUniform'><p>Compute deviation from uniform distribution</p></a></li>
<li><a href='#read.MQ'><p>Convenience wrapper for MQDataReader when only a single MQ file should be read</p>
and file mapping need not be stored.</a></li>
<li><a href='#renameFile'><p>Given a vector of (short/long) filenames, translate to the (long/short) version</p></a></li>
<li><a href='#repEach'><p>Repeat each element x_i in X, n_i times.</p></a></li>
<li><a href='#RSD'><p>Relative standard deviation (RSD)</p></a></li>
<li><a href='#RTalignmentTree'><p>Return a tree plot with a possible alignment tree.</p></a></li>
<li><a href='#scale_x_discrete_reverse'><p>Inverse the order of items on the x-axis (for discrete scales)</p></a></li>
<li><a href='#scale_y_discrete_reverse'><p>Inverse the order of items on the y-axis (for discrete scales)</p></a></li>
<li><a href='#scale01linear'><p>Scales a vector of values linearly to [0, 1]</p>
If all input values are equal, returned values are all 0</a></li>
<li><a href='#ScoreInAlignWindow'><p>Compute the fraction of features per Raw file which have an acceptable RT difference after alignment</p></a></li>
<li><a href='#shortenStrings'><p>Shorten a string to a maximum length and indicate shorting by appending '..'</p></a></li>
<li><a href='#simplifyNames'><p>Removes common substrings (infixes) in a set of strings.</p></a></li>
<li><a href='#supCount'><p>Compute shortest prefix length which makes all strings in a vector uniquely identifyable.</p></a></li>
<li><a href='#theme_blank'><p>A blank theme (similar to the deprecated theme_blank())</p></a></li>
<li><a href='#thinOut'><p>Thin out a data.frame by removing rows with similar numerical values in a certain column.</p></a></li>
<li><a href='#thinOutBatch'><p>Apply 'thinOut' on all subsets of a data.frame, split by a batch column</p></a></li>
<li><a href='#wait_for_writable'><p>Check if a file is writable and blocks an interactive session, waiting for user input.</p></a></li>
<li><a href='#YAMLClass-class'><p>Query a YAML object for a certain parameter.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quality Report Generation for MaxQuant and mzTab Results</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates Proteomics (PTX) quality control (QC) reports for shotgun LC-MS data analyzed with the 
             MaxQuant software suite (from .txt files) or mzTab files (ideally from OpenMS 'QualityControl' tool).
             Reports are customizable (target thresholds, subsetting) and available in HTML or PDF format.
             Published in J. Proteome Res., Proteomics Quality Control: Quality Control Software for MaxQuant Results (2015)
             &lt;<a href="https://doi.org/10.1021%2Facs.jproteome.5b00780">doi:10.1021/acs.jproteome.5b00780</a>&gt;.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (http://pandoc.org) for building Vignettes
and output reports as HTML</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, ggplot2 (&ge; 3.4), ggdendro, grid, gridExtra,
grDevices, gtable, htmlTable, knitr (&ge; 1.10), magrittr,
methods, plyr, R6, R6P, RColorBrewer, reshape2, rlang,
rmarkdown, rmzqc (&ge; 0.5.0), seqinr, stats, utils, UpSetR,
xml2, yaml</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cbielow/PTXQC">https://github.com/cbielow/PTXQC</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cbielow/PTXQC/issues">https://github.com/cbielow/PTXQC/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-09 12:47:03 UTC; bielow</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Bielow [aut, cre],
  Juliane Schmachtenberg [ctb],
  Swenja Wagner [ctb],
  Patricia Scheil [ctb],
  Tom Waschischek [ctb],
  Guido Mastrobuoni [dtc, rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Bielow &lt;chris.bielow@bsc.fu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-09 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PTXQC-package'>PTXQC: A package for computing Quality Control (QC) metrics for Proteomics (PTX)</h2><span id='topic+PTXQC'></span><span id='topic+PTXQC-package'></span>

<h3>Description</h3>

<p>The following sections describe the main components:
</p>


<h3>Input</h3>

<p>Valid input data are either the files from MaxQuant's .txt folder (all versions from MaxQuant &gt;= 1.0 upwards are supported)
or a single mzTab file. All mzTab files will work, but most metrics can be obtained from OpenMS' mzTab as produced
by the QualityControl TOPP tool (from OpenMS 2.5 onwards).
</p>


<h3>Important functions</h3>

<p>The central function of this package is called <code><a href="#topic+createReport">createReport</a></code> and it accepts either MaxQuant or mzTab data, along with 
a configuration (optional).
There is a parser for mzTab <code><a href="#topic+MzTabReader">MzTabReader</a></code> and MaxQuant txt files <code><a href="#topic+MQDataReader">MQDataReader</a></code>, as well as a plethora of QC metrics
derived from a common <code><a href="#topic+qcMetric">qcMetric</a></code> class and scoring functions <code>qual...</code>, e.g. <code><a href="#topic+qualGaussDev">qualGaussDev</a></code>.
</p>


<h3>Configuration</h3>

<p>The user can modify the behaviour of PTXQC, e.g. to enable/disable certain metrics or change scoring thresholds, via a YAML object/file.
By default a Yaml file is written automatically side-by-side to the input files upon running PTXQC for the first time on a particular input.
A custom Yaml object can be passed to the main <code><a href="#topic+createReport">createReport</a></code> function for customization. 
Use <code>yaml::yaml.load_file(input = 'myYAML.yaml')</code> to load an existing file and pass the Yaml object along.
</p>


<h3>Output</h3>

<p>Either a PDF and/or Html report which contains QC plots and a description of the metrics.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Chris Bielow <a href="mailto:chris.bielow@bsc.fu-berlin.de">chris.bielow@bsc.fu-berlin.de</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Juliane Schmachtenberg [contributor]
</p>
</li>
<li><p> Swenja Wagner [contributor]
</p>
</li>
<li><p> Patricia Scheil [contributor]
</p>
</li>
<li><p> Tom Waschischek [contributor]
</p>
</li>
<li><p> Guido Mastrobuoni [data contributor, reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cbielow/PTXQC">https://github.com/cbielow/PTXQC</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cbielow/PTXQC/issues">https://github.com/cbielow/PTXQC/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+2B+25'>A string concatenation function, more readable than 'paste()'.</h2><span id='topic++25+2B+25'></span>

<h3>Description</h3>

<p>A string concatenation function, more readable than 'paste()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %+% b
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B2B+2B25_+3A_a">a</code></td>
<td>
<p>Char vector</p>
</td></tr>
<tr><td><code id="+2B25+2B2B+2B25_+3A_b">b</code></td>
<td>
<p>Char vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Concatenated string (no separator)
</p>

<hr>
<h2 id='alignmentCheck'>Verify an alignment by checking the retention time differences of identical peptides across Raw files</h2><span id='topic+alignmentCheck'></span>

<h3>Description</h3>

<p>The input is a data frame containing feature evidence with corrected retention times,
e.g. a 'calibrated.retention.time' column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignmentCheck(data, referenceFile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alignmentCheck_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'calibrated.retention.time', 'id', 'modified.sequence', 'charge', 'raw.file' and 'fraction' (if present)</p>
</td></tr>
<tr><td><code id="alignmentCheck_+3A_referencefile">referenceFile</code></td>
<td>
<p>A raw file name as occuring in data$raw.file, serving as alignment reference (when no fractions are used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function must be given real MS/MS identifications only (type &quot;MULTI-MSMS&quot;)
in order to work correctly!
</p>
<p>For each peptide sequence (and charge) in the reference Raw file, this function looks up the
already calibrated retention time difference of the same feature in all other files. For every comparison made,
we report the RT difference. If alignment worked perfectly, the differences are very small (&lt;1 min).
</p>
<p>An 'id' column must be present, to enable mapping the result of this function to the original data frame.
</p>
<p>A reference Raw file can be identified using 'findAlignReference()'. If Maxquants experimental design included
pre-fractionation, a column named 'fraction' should be given and 'referenceFile' should be empty. This function will
pick the one Raw file for each fraction (the first in order) to use as reference. Only the immediately neighbouring
fractions will be matched to this reference.
</p>


<h3>Value</h3>

<p>A data.frame containing the RT diff for each feature found in a Raw file and the reference.
</p>

<hr>
<h2 id='appendEnv'>Add the value of a variable to an environment (fast append)</h2><span id='topic+appendEnv'></span>

<h3>Description</h3>

<p>The environment must exist, and its name must be given as string literal in 'env_name'!
The value of the variable 'v' will be stored under the name given in 'v_name'.
If 'v_name' is not given, a variable name will be created by increasing an internal counter
and using the its value padded with zeros as name (i.e., &quot;0001&quot;, &quot;0002&quot; etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendEnv(env_name, v, v_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="appendEnv_+3A_env_name">env_name</code></td>
<td>
<p>String of the environment variable</p>
</td></tr>
<tr><td><code id="appendEnv_+3A_v">v</code></td>
<td>
<p>Value to be inserted</p>
</td></tr>
<tr><td><code id="appendEnv_+3A_v_name">v_name</code></td>
<td>
<p>String used as variable name. Automatically generated if omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always TRUE
</p>

<hr>
<h2 id='assembleMZQC'>Collects all 'mzQC' members from each entry in lst_qcMetrics and stores them in an overall mzQC object, which can be written to disk (see writeMZQC()) or augmented otherwise</h2><span id='topic+assembleMZQC'></span>

<h3>Description</h3>

<p>Collects all 'mzQC' members from each entry in lst_qcMetrics and stores them in an overall mzQC object, which can be written to disk (see writeMZQC()) or augmented otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assembleMZQC(lst_qcMetrics, raw_file_mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assembleMZQC_+3A_lst_qcmetrics">lst_qcMetrics</code></td>
<td>
<p>A list of qcMetric objects which have their mzQC member populated with &quot;MzQCrunQuality&quot; and/or &quot;MzQCsetQuality&quot; objects</p>
</td></tr>
<tr><td><code id="assembleMZQC_+3A_raw_file_mapping">raw_file_mapping</code></td>
<td>
<p>A data.frame with cols 'from', to' and maybe 'best.effort' (if shorting was unsuccessful), as e.g. obtained by a FilenameMapper$raw_file_mapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MzQCmzQC object (root object of an mzQC document)
</p>

<hr>
<h2 id='assignBlocks'>Assign set numbers to a vector of values.</h2><span id='topic+assignBlocks'></span>

<h3>Description</h3>

<p>Each set has size set_size (internally optimized using <code><a href="#topic+correctSetSize">correctSetSize</a></code>), holding values from 'values'.
This gives n such sets and the return value is just the set index for each value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignBlocks(values, set_size = 5, sort_values = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignBlocks_+3A_values">values</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="assignBlocks_+3A_set_size">set_size</code></td>
<td>
<p>Number of distinct values allowed in a set</p>
</td></tr>
<tr><td><code id="assignBlocks_+3A_sort_values">sort_values</code></td>
<td>
<p>Before assigning values to sets, sort the values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector (same length as input) with set numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #library(PTXQC)
 assignBlocks(c(1:11, 1), set_size = 3, sort_values = FALSE)
 ## --&gt; 1 1 1 2 2 2 3 3 3 4 4 1
 
</code></pre>

<hr>
<h2 id='boxplotCompare'>Boxplots - one for each condition (=column) in a data frame.</h2><span id='topic+boxplotCompare'></span>

<h3>Description</h3>

<p>Given a data.frame with two/three columns in long format (name, value, [contaminant]; in that order), each group (given from 1st column)
is plotted as a bar.
Contaminants (if given) are separated and plotted as yellow bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplotCompare(
  data,
  log2 = TRUE,
  ylab = "intensity",
  mainlab = ylab,
  sublab = "",
  boxes_per_page = 30,
  abline = NA,
  coord_flip = TRUE,
  names = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxplotCompare_+3A_data">data</code></td>
<td>
<p>Data frame in long format with numerical expression data</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_log2">log2</code></td>
<td>
<p>Apply log2 to the data (yes/no)</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_ylab">ylab</code></td>
<td>
<p>Label on Y-axis</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_mainlab">mainlab</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_sublab">sublab</code></td>
<td>
<p>Sub title</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_boxes_per_page">boxes_per_page</code></td>
<td>
<p>Maximum number of boxplots per plot. Yields multiple plots if more groups are given.</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_abline">abline</code></td>
<td>
<p>Draw a horizontal green line at the specified y-position (e.g. to indicate target median values)</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_coord_flip">coord_flip</code></td>
<td>
<p>Exchange Y and X-axis for better readability</p>
</td></tr>
<tr><td><code id="boxplotCompare_+3A_names">names</code></td>
<td>
<p>An optional data.frame(long=.., short=..), giving a renaming scheme (long-&gt;short) for the 'name' column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Boxes are shaded: many NA or Inf lead to more transparency. Allows to easily spot sparse groups
</p>


<h3>Value</h3>

<p>List of ggplot objects
</p>

<hr>
<h2 id='brewer.pal.Safe'>Return color brew palettes, but fail hard if number of requested colors
is larger than the palette is holding.</h2><span id='topic+brewer.pal.Safe'></span>

<h3>Description</h3>

<p>Internally calls 'brewer.pal(n, palette)', checking 'n' beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brewer.pal.Safe(n = 3, palette = "Set1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brewer.pal.Safe_+3A_n">n</code></td>
<td>
<p>Number of colours</p>
</td></tr>
<tr><td><code id="brewer.pal.Safe_+3A_palette">palette</code></td>
<td>
<p>Name of palette (e.g. &quot;set1&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of colors
</p>

<hr>
<h2 id='byX'>Calls FUN on a subset of data in blocks of size 'subset_size' of unique indices.</h2><span id='topic+byX'></span>

<h3>Description</h3>

<p>One subset consists of 'subset_size' unique groups and thus of all rows which
in 'data' which have any of these groups.
The last subset might have less groups, if the number of unique groups is not dividable by subset_size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byX(data, indices, subset_size = 5, FUN, sort_indices = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="byX_+3A_data">data</code></td>
<td>
<p>Data.frame whose subsets to use on FUN</p>
</td></tr>
<tr><td><code id="byX_+3A_indices">indices</code></td>
<td>
<p>Vector of group assignments, same length as nrow(data)</p>
</td></tr>
<tr><td><code id="byX_+3A_subset_size">subset_size</code></td>
<td>
<p>Number of groups to use in one subset</p>
</td></tr>
<tr><td><code id="byX_+3A_fun">FUN</code></td>
<td>
<p>Function applied to subsets of data</p>
</td></tr>
<tr><td><code id="byX_+3A_sort_indices">sort_indices</code></td>
<td>
<p>Sort groups (by their sorted character(!) names) before building subsets</p>
</td></tr>
<tr><td><code id="byX_+3A_...">...</code></td>
<td>
<p>More arguments to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is applied on each subset.
</p>


<h3>Value</h3>

<p>list of function result (one entry for each subset)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> byX(data.frame(d=1:10), 1:10, 2, sum)
 
</code></pre>

<hr>
<h2 id='byXflex'>Same as <code><a href="#topic+byX">byX</a></code>, but with more flexible group size, to avoid that the last group has only a few entries (&lt;50% of desired size).</h2><span id='topic+byXflex'></span>

<h3>Description</h3>

<p>The 'subset_size' param is internally optimized using <code><a href="#topic+correctSetSize">correctSetSize</a></code> and
then <code><a href="#topic+byX">byX</a></code> is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byXflex(data, indices, subset_size = 5, FUN, sort_indices = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="byXflex_+3A_data">data</code></td>
<td>
<p>Data.frame whose subset to use on FUN</p>
</td></tr>
<tr><td><code id="byXflex_+3A_indices">indices</code></td>
<td>
<p>Vector of group assignments, same length as nrow(data)</p>
</td></tr>
<tr><td><code id="byXflex_+3A_subset_size">subset_size</code></td>
<td>
<p>Ideal number of groups to use in one subset &ndash; this can be changed internally, from 75%-150%</p>
</td></tr>
<tr><td><code id="byXflex_+3A_fun">FUN</code></td>
<td>
<p>function Applied to subsets of data</p>
</td></tr>
<tr><td><code id="byXflex_+3A_sort_indices">sort_indices</code></td>
<td>
<p>Groups are formed by their sorted character(!) names</p>
</td></tr>
<tr><td><code id="byXflex_+3A_...">...</code></td>
<td>
<p>More arguments to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of function result (one entry for each subset)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> stopifnot(
   byXflex(data.frame(d=1:10), 1:10, 2, sum, sort_indices = FALSE) ==
   c(3, 7, 11, 15, 19)
 )
 
</code></pre>

<hr>
<h2 id='checkEnglishLocale'>When MaxQuant is run with a wrong locale (i.e. the decimal separator is not a '.', but a ','), 
then MaxQuant results are plainly wrong and broken. The can be detected by, e.g. checking for negative charge annotation</h2><span id='topic+checkEnglishLocale'></span>

<h3>Description</h3>

<p>When MaxQuant is run with a wrong locale (i.e. the decimal separator is not a '.', but a ','), 
then MaxQuant results are plainly wrong and broken. The can be detected by, e.g. checking for negative charge annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEnglishLocale(df_evd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkEnglishLocale_+3A_df_evd">df_evd</code></td>
<td>
<p>Evidence table from which we only need the 'charge' column</p>
</td></tr>
</table>

<hr>
<h2 id='computeMatchRTFractions'>Combine several data structs into a final picture for segmentation incurred by 'Match-between-runs'.</h2><span id='topic+computeMatchRTFractions'></span>

<h3>Description</h3>

<p>qMBRSeg_Dist_inGroup might be empty if there are only singlets (transferred and genuine), but then the scores will be pretty
boring as well (100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMatchRTFractions(qMBR, qMBRSeg_Dist_inGroup)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeMatchRTFractions_+3A_qmbr">qMBR</code></td>
<td>
<p>A data.frame as computed by peakSegmentation()</p>
</td></tr>
<tr><td><code id="computeMatchRTFractions_+3A_qmbrseg_dist_ingroup">qMBRSeg_Dist_inGroup</code></td>
<td>
<p>A data.frame as computed by inMatchWindow()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame which details the distribution of singlets and pairs (inRT and outRT) for each Raw file and genuine vs. all
</p>

<hr>
<h2 id='correctSetSize'>Re-estimate a new set size to split a number of items into equally sized sets.</h2><span id='topic+correctSetSize'></span>

<h3>Description</h3>

<p>This is useful for plotting large datasets where multiple pages are needed.
E.g. you know that you need 101 barplots, but you only want to fit about 25 per page.
Naively one would now do five plots, with the last one only containing a single barplot.
Using this function with correctSetSize(101, 25) would tell you to use 26 barplots per page,
so you end up with four plots, all roughly equally filled.
It also works the other extreme case, where your initial size is chosen slightly too high, e.g.
Sets of size 5 for just 8 items is too much, because we can reduce the set size to 4 and still
need two sets but now they are much more equally filled (correctSetSize(8, 5) == 4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctSetSize(item_count, initial_set_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctSetSize_+3A_item_count">item_count</code></td>
<td>
<p>Known number of items which need to assigned to sets</p>
</td></tr>
<tr><td><code id="correctSetSize_+3A_initial_set_size">initial_set_size</code></td>
<td>
<p>Desired number of items a single set should hold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We allow for up to set sizes of 150% from default, to avoid the last set being sparse (we remove it and distribute to the other bins)
150
Once the number of sets is fixed, we distribute all items equally.
</p>
<p>E.g. 6 items &amp; initial_set_size=5, would result in 2 bins (5 items, 1 item), but we'd rather have one bin of 6 items
or 8 items &amp; initial_set_size=5, would result in 2 bins (5+3 items), since the last set is more than half full, but we'd rather have 4+4
</p>


<h3>Value</h3>

<p>re-estimated set size which a set should hold in order to avoid underfilled sets
</p>


<h3>Examples</h3>

<pre><code class='language-R'> stopifnot(
   correctSetSize(8, 5) == 4
 )
 stopifnot(
   correctSetSize(101, 25) == 26
 )
 
</code></pre>

<hr>
<h2 id='createReport'>Create a quality control report (in PDF format).</h2><span id='topic+createReport'></span>

<h3>Description</h3>

<p>This is the main function of the package and the only thing you need to call directly if you are 
just interested in getting a QC report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createReport(
  txt_folder = NULL,
  mztab_file = NULL,
  yaml_obj = list(),
  report_filenames = NULL,
  enable_log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createReport_+3A_txt_folder">txt_folder</code></td>
<td>
<p>Path to txt output folder of MaxQuant (e.g. &quot;c:/data/Hek293/txt&quot;)</p>
</td></tr>
<tr><td><code id="createReport_+3A_mztab_file">mztab_file</code></td>
<td>
<p>Alternative to **txt_folder**, you can provide a single mzTab file which contains PSM, PEP and PRT tables</p>
</td></tr>
<tr><td><code id="createReport_+3A_yaml_obj">yaml_obj</code></td>
<td>
<p>A nested list object with configuration parameters for the report.
Useful to switch off certain plots or skip entire sections.</p>
</td></tr>
<tr><td><code id="createReport_+3A_report_filenames">report_filenames</code></td>
<td>
<p>Optional list with names (as generated by <code><a href="#topic+getReportFilenames">getReportFilenames</a></code>). 
If not provided, will be created internally by calling <code><a href="#topic+getReportFilenames">getReportFilenames</a></code>.</p>
</td></tr>
<tr><td><code id="createReport_+3A_enable_log">enable_log</code></td>
<td>
<p>If TRUE all console output (including warnings and errors) is logged to the file given in **report_filenames$log_file**.
Note: warnings/errors can only be shown in either the log **or** the console, not both!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You need to provide either 
a) the folder name of the 'txt' output, as generated by MaxQuant or an mzTab file 
or b) an mzTab file as generated by the OpenMS QualityControl TOPP tool (other mzTab files will probably not work)
</p>
<p>Optionally, provide a YAML configuration object, which allows to (de)activate certain plots and holds other parameters.
The yaml_obj is complex and best obtained by running this function once using the default (empty list).
A full YAML configuration object will be written in the 'txt' folder you provide and can be loaded using
<code><a href="yaml.html#topic+yaml.load">yaml.load</a></code>.
</p>
<p>The PDF and the config file will be stored in the given txt folder.
</p>


<h3>Value</h3>

<p>List with named filename strings, e.g. $yaml_file, $report_file etc..
</p>


<h3>Note</h3>

<p>You need write access to the txt/mzTab folder!
</p>
<p>For updates, bug fixes and feedback please visit <a href="https://github.com/cbielow/PTXQC">https://github.com/cbielow/PTXQC</a>.
</p>

<hr>
<h2 id='createYaml'>Creates a yaml file storing the parameters that are used for creating the PTXQC report 
and returns these parameters as well as a list of available qc-Metrics objects.</h2><span id='topic+createYaml'></span>

<h3>Description</h3>

<p>Valid parameters are: 
param_useMQPAR, add_fs_col, id_rate_bad, id_rate_great , pg_ratioLabIncThresh , param_PG_intThresh,
param_EV_protThresh , param_EV_intThresh, param_EV_pepThresh , yaml_contaminants, param_EV_MatchingTolerance,
param_evd_mbr , param_EV_PrecursorTolPPM, param_EV_PrecursorOutOfCalSD , param_EV_PrecursorTolPPMmainSearch, 
param_MSMSScans_ionInjThresh, param_OutputFormats and param_PageNumbers 
</p>
<p>Please provide them as a list() of this format: list$parameter_name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createYaml(
  yc,
  param = list(),
  DEBUG_PTXQC = FALSE,
  txt_files = NULL,
  metrics = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createYaml_+3A_yc">yc</code></td>
<td>
<p>A yaml class object created by YAMLClass$new()</p>
</td></tr>
<tr><td><code id="createYaml_+3A_param">param</code></td>
<td>
<p>list of parameters sorted by names; if empty, will be populated with defaults</p>
</td></tr>
<tr><td><code id="createYaml_+3A_debug_ptxqc">DEBUG_PTXQC</code></td>
<td>
<p>print some debugging information; default FALSE</p>
</td></tr>
<tr><td><code id="createYaml_+3A_txt_files">txt_files</code></td>
<td>
<p>list of paths to MaxQuant files; if NULL, it is assumed that the parameters are for mzTab-mode</p>
</td></tr>
<tr><td><code id="createYaml_+3A_metrics">metrics</code></td>
<td>
<p>list of metric names that should be plotted; if NULL, will be populated with defaults</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of parameters used for creating the report and list of qc-Metrics objects
</p>

<hr>
<h2 id='CV'>Coefficient of variation (CV)</h2><span id='topic+CV'></span>

<h3>Description</h3>

<p>Computes sd(x) / mean(x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CV_+3A_x">x</code></td>
<td>
<p>Vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CV
</p>

<hr>
<h2 id='darken'>Make a color (given as name or in RGB) darker by factor x = [0 = black, 1=unchanged]</h2><span id='topic+darken'></span>

<h3>Description</h3>

<p>Make a color (given as name or in RGB) darker by factor x = [0 = black, 1=unchanged]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>darken(color, factor = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="darken_+3A_color">color</code></td>
<td>
<p>A color as understood by col2rgb</p>
</td></tr>
<tr><td><code id="darken_+3A_factor">factor</code></td>
<td>
<p>Between 0 (make black) and 1 (leave color as is)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>darkened color
</p>

<hr>
<h2 id='del0'>Replace 0 with NA in a vector</h2><span id='topic+del0'></span>

<h3>Description</h3>

<p>Replace 0 with NA in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>del0(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="del0_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of same size as 'x', with 0's replaced by NA
</p>

<hr>
<h2 id='delLCP'>Removes the longest common prefix (LCP) from a vector of strings.</h2><span id='topic+delLCP'></span>

<h3>Description</h3>

<p>You should provide only unique strings (to increase speed).
If only a single string is given, the empty string will be returned unless <code>minOutputLength</code> is set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delLCP(x, min_out_length = 0, add_dots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delLCP_+3A_x">x</code></td>
<td>
<p>Vector of strings with common prefix</p>
</td></tr>
<tr><td><code id="delLCP_+3A_min_out_length">min_out_length</code></td>
<td>
<p>Minimal length of the shortest element of x after LCP removal [default: 0, i.e. empty string is allowed] . If the output would be shorter, the last part of the LCP is kept.</p>
</td></tr>
<tr><td><code id="delLCP_+3A_add_dots">add_dots</code></td>
<td>
<p>Prepend output with '..' if shortening was done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shortened vector of strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  delLCP(c("TK12345_H1"), min_out_length=0)
  ## ""

  delLCP(c("TK12345_H1"), min_out_length=4)
  ## "5_H1"

  delLCP(c("TK12345_H1"), min_out_length=4, add_dots = TRUE)
  ## "..5_H1"

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=4)
  ## "5_H1" "5_H2"

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=4, add_dots = TRUE)
  ## "..5_H1" "..5_H2"

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=8)
  ## "12345_H1", "12345_H2"

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=8, add_dots = TRUE)
  ## "TK12345_H1", "TK12345_H2" (unchanged, since '..' would add another two)

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=60)
  ## "TK12345_H1", "TK12345_H2" (unchanged)

  delLCP(c("TK12345_H1", "TK12345_H2"), min_out_length=60, add_dots = TRUE)
  ## "TK12345_H1", "TK12345_H2" (unchanged)


</code></pre>

<hr>
<h2 id='delLCS'>Removes the longest common suffix (LCS) from a vector of strings.</h2><span id='topic+delLCS'></span>

<h3>Description</h3>

<p>Removes the longest common suffix (LCS) from a vector of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delLCS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delLCS_+3A_x">x</code></td>
<td>
<p>Vector of strings with common suffix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shortened vector of strings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>delLCS(c("TK12345_H1"))                     ## ""
delLCS(c("TK12345_H1", "TK12345_H2"))       ## "TK12345_H1" "TK12345_H2" 
delLCS(c("TK12345_H1", "TK12!45_H1"))       ## "TK123"    "TK12!" 
 
</code></pre>

<hr>
<h2 id='FilenameMapper-class'>Make sure to call $readMappingFile(some_file) if you want to support a user-defined file mapping.
Otherwise, calls to $getShortNames() will create/augment the mapping for filenames.</h2><span id='topic+FilenameMapper-class'></span><span id='topic+FilenameMapper'></span>

<h3>Description</h3>

<p>Make sure to call $readMappingFile(some_file) if you want to support a user-defined file mapping.
Otherwise, calls to $getShortNames() will create/augment the mapping for filenames.
</p>


<h3>Fields</h3>


<dl>
<dt><code>raw_file_mapping</code></dt><dd><p>Data.frame with columns 'from', 'to' and maybe 'best.effort' (if shorting was unsuccessful)</p>
</dd>
<dt><code>mapping.creation</code></dt><dd><p>how the current mapping was obtained (user or auto)</p>
</dd>
<dt><code>external.mapping.file</code></dt><dd><p>Filename of user-defined mapping file; only defined if readMappingFile() was called</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>getShortNamesStatic(raw.files, max_len, fallbackStartNr = 1)</code></dt><dd><p>Static method: Shorten a set of Raw file names and return a data frame with the mappings.
Mapping will have: $from, $to and optionally $best.effort (if shorting was unsuccessful and numbers had to be used)
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;raw.files&#8288;</code>  Vector of Raw files.
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;max_len&#8288;</code> Maximal length of shortening results, before resorting to canonical names (file 1,...).
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;fallbackStartNr&#8288;</code> Starting index for canonical names.
</p>
</li></ul>



<h4>Return Value</h4>

<p> data.frame with mapping.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>a = FilenameMapper$new()
a$readMappingFile('filenamemapping.txt') 

</code></pre>

<hr>
<h2 id='findAlignReference'>Return list of raw file names which were reported by MaxQuant as reference point for alignment.</h2><span id='topic+findAlignReference'></span>

<h3>Description</h3>

<p>There is only one reference point which has '0' in 'retention.time.calibration' column in evidence.txt 
as corrected RT. This is true for most MaxQuant versions
and also true for fractions. However, some evidence.txt files show 0.03 as an averaged minimum per Raw file.
We use the raw.file with the smallest average as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAlignReference(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findAlignReference_+3A_data">data</code></td>
<td>
<p>The data.frame with columns 'retention.time.calibration' and 'raw.file'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that MaxQuant uses a guide tree to align the Raw files, so the order of files does not influence the 
alignment. But the first file will always be used as reference point when reporting delta-RTs. And this file is also
used by PTXQC as reference file vs all other files to find the real calibration function (see alignmentCheck()).
</p>
<p>This function might return multiple raw file names (if MQ decides to change its mind at some point in the future).
In this case the result should be treated with caution or (better) regarded as failure.
</p>


<h3>Value</h3>

<p>List of reference raw files (usually just one)
</p>

<hr>
<h2 id='fixCalibration'>Detect (and fix) MaxQuant mass recalibration columns, since they
sometimes report wrong values.</h2><span id='topic+fixCalibration'></span>

<h3>Description</h3>

<p>Returns a list of items for both diagnostics and possibly a fixed evidence data.frame.
Also two strings with messages are returned, which can serve as user message for
pre and post calibration status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixCalibration(
  df_evd,
  df_idrate = NULL,
  tolerance_sd_PCoutOfCal = 2,
  low_id_rate = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixCalibration_+3A_df_evd">df_evd</code></td>
<td>
<p>Evidence data.frame with columns ()</p>
</td></tr>
<tr><td><code id="fixCalibration_+3A_df_idrate">df_idrate</code></td>
<td>
<p>Data.frame from summary.txt, giving ID rates for each raw file (cols: &quot;ms.ms.identified....&quot;, &quot;fc.raw.file&quot;). Can also be NULL.</p>
</td></tr>
<tr><td><code id="fixCalibration_+3A_tolerance_sd_pcoutofcal">tolerance_sd_PCoutOfCal</code></td>
<td>
<p>Maximal standard deviation allowed before considered 'failed'</p>
</td></tr>
<tr><td><code id="fixCalibration_+3A_low_id_rate">low_id_rate</code></td>
<td>
<p>Minimum ID rate in Percent before a Raw file is considered 'failed'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data (stats, affected_raw_files, df_evd, recal_message, recal_message_post)
</p>

<hr>
<h2 id='flattenList'>Flatten lists of lists with irregular depths to just a list of items,
i.e. a list of the leaves (if you consider the input as a tree).</h2><span id='topic+flattenList'></span>

<h3>Description</h3>

<p>Flatten lists of lists with irregular depths to just a list of items,
i.e. a list of the leaves (if you consider the input as a tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flattenList(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flattenList_+3A_x">x</code></td>
<td>
<p>List of 'stuff' (could be lists or items or a mix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flat list
</p>

<hr>
<h2 id='getAbundanceClass'>Assign a relative abundance class to a set of (log10) abundance values</h2><span id='topic+getAbundanceClass'></span>

<h3>Description</h3>

<p>Abundances (should be logged already) are grouped into different levels,
starting from the smallest values (&quot;low&quot;) to the highest values (&quot;high&quot;).
Intermediate abundances are either assigned as &quot;mid&quot;, or &quot;low-mid&quot;.
If the range is too large, only &quot;low&quot; and &quot;high&quot; are assigned, the intermediate values
are just numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAbundanceClass(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAbundanceClass_+3A_x">x</code></td>
<td>
<p>Vector of numeric values (in log10)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example:
getAbundanceClass(c(12.4, 17.1, 14.9, 12.3)) ## &ndash;&gt; factor(c(&quot;low&quot;, &quot;high&quot;, &quot;mid&quot;, &quot;low&quot;))
</p>


<h3>Value</h3>

<p>Vector of factors corresponding to input with abundance class names (e.g. low, high)
</p>

<hr>
<h2 id='getECDF'>Estimate the empirical density and return it</h2><span id='topic+getECDF'></span>

<h3>Description</h3>

<p>Estimate the empirical density and return it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getECDF(samples, y_eval = (1:100)/100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getECDF_+3A_samples">samples</code></td>
<td>
<p>Vector of input values (samples from the distribution)</p>
</td></tr>
<tr><td><code id="getECDF_+3A_y_eval">y_eval</code></td>
<td>
<p>Vector of points where CDF is evaluated (each percentile by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with columns 'x', 'y'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(getECDF(rnorm(1e4)))
  
</code></pre>

<hr>
<h2 id='getFileEncoding'>Determine if a file is 'UTF-8' or 'UTF-8-BOM' (as of MQ2.4) or 'UTF-16BE' or 'UTF-16LE'</h2><span id='topic+getFileEncoding'></span>

<h3>Description</h3>

<p>Determine if a file is 'UTF-8' or 'UTF-8-BOM' (as of MQ2.4) or 'UTF-16BE' or 'UTF-16LE'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFileEncoding(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFileEncoding_+3A_filename">filename</code></td>
<td>
<p>Relative or absolute path to a file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&rdquo; if the file does not exist or is not readable
</p>

<hr>
<h2 id='getFragmentErrors'>Extract fragment mass deviation errors from a data.frame from msms.txt</h2><span id='topic+getFragmentErrors'></span>

<h3>Description</h3>

<p>Given a data.frame as obtainable from a msms.txt with 
- a 'mass.analyzer' column which contains only a single value for the whole column
- a 'mass.deviations..da.' and (if available) 'mass.deviations..ppm.'
- a 'masses' column (only required if 'mass.deviations..ppm.' is unavailable and the mass.analyzer
indicates hig-res data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFragmentErrors(x, recurse = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFragmentErrors_+3A_x">x</code></td>
<td>
<p>Data frame in long format with numerical expression data</p>
</td></tr>
<tr><td><code id="getFragmentErrors_+3A_recurse">recurse</code></td>
<td>
<p>Internal usage only. Leave at 0 when calling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mass deviations are extracted from the columns, e.g. each cell containing values separated by
semicolons is split into single values. The appropriate unit is chosen (Da or ppm, depending on
ITMS or FTMS data). Also the fragmentation type can be used: CID indicates ITMS, HCD to FTMS.
This is not 100
</p>
<p>Sometimes, peptides are identified purely based on MS1, i.e. have no fragments. These will be ignored.
</p>
<p>If ppm mass deviations are not available, errors in Da will be converted to ppm using the corresponding mass values.
</p>


<h3>Value</h3>

<p>Data frame with mass errors ('msErr') and their 'unit' (Da or ppm) or NULL (if no fragments were given)
</p>

<hr>
<h2 id='getHTMLTable'>Create an HTML table with an extra header row</h2><span id='topic+getHTMLTable'></span>

<h3>Description</h3>

<p>Create an HTML table with an extra header row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHTMLTable(data, caption = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHTMLTable_+3A_data">data</code></td>
<td>
<p>A data.frame which serves as table</p>
</td></tr>
<tr><td><code id="getHTMLTable_+3A_caption">caption</code></td>
<td>
<p>A set of headlines, e.g. c(&quot;top line&quot;, &quot;bottom line&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table as html character string for cat()'ing into an html document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(raw.file = letters[1:4],
                    id.rate = 3:6)
  getHTMLTable(data, 
               caption = "some header line")

</code></pre>

<hr>
<h2 id='getMaxima'>Find the local maxima in a vector of numbers.</h2><span id='topic+getMaxima'></span>

<h3>Description</h3>

<p>A vector of booleans is returned with the same length as input
which contains TRUE when there is a maximum.
Simply sum up the vector to get the number of maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxima(x, thresh_rel = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMaxima_+3A_x">x</code></td>
<td>
<p>Vector of numbers</p>
</td></tr>
<tr><td><code id="getMaxima_+3A_thresh_rel">thresh_rel</code></td>
<td>
<p>Minimum relative intensity to maximum intensity of 'x' required
to be a maximum (i.e., a noise threshold). Default is 20%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of bool's, where TRUE indicates a local maximum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    r = getMaxima(c(1,0,3,4,5,0))                                
    all(r == c(TRUE,FALSE,FALSE,FALSE,TRUE,FALSE))
    
    getMaxima(c(1, NA, 3, 2, 3, NA, 4, 2, 5))
    
</code></pre>

<hr>
<h2 id='getMetaData'>Extract meta information (orderNr, metric name, category)
from a list of Qc metric objects</h2><span id='topic+getMetaData'></span>

<h3>Description</h3>

<p>Extract meta information (orderNr, metric name, category)
from a list of Qc metric objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMetaData(lst_qcMetrics)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMetaData_+3A_lst_qcmetrics">lst_qcMetrics</code></td>
<td>
<p>List of qcMetrics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns 'name', 'order' and 'cat' (category)
</p>

<hr>
<h2 id='getMetaFilenames'>Parses the given mqpar.xml file (or, if not found, tries the 'txt_folder' + '/../../' folder (i.e. where the raw data should be)) to extract the full filepaths for all Raw files</h2><span id='topic+getMetaFilenames'></span>

<h3>Description</h3>

<p>Parses the given mqpar.xml file (or, if not found, tries the 'txt_folder' + '/../../' folder (i.e. where the raw data should be)) to extract the full filepaths for all Raw files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMetaFilenames(mqpar_file, txt_folder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMetaFilenames_+3A_mqpar_file">mqpar_file</code></td>
<td>
<p>Location of the mqpar.xml (can be empty, if unknown)</p>
</td></tr>
<tr><td><code id="getMetaFilenames_+3A_txt_folder">txt_folder</code></td>
<td>
<p>Fallback option: path to the txt folder (which contains evidence.txt, etc)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>May return 'NULL' if no mqpar.xml could be found.
Otherwise: data.frame with columns:
</p>

<ul>
<li><p> 'file' (no path), 'path' (full path incl. names)
</p>
</li>
<li><p> 'file_no_suffix' (as 'file' but without suffix) 
</p>
</li>
<li><p> 'CV' (CV term for filetype, e.g. for Thermo Raw)
</p>
</li></ul>


<hr>
<h2 id='getMetricsObjects'>Get all currently available metrics</h2><span id='topic+getMetricsObjects'></span>

<h3>Description</h3>

<p>Get all currently available metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMetricsObjects(DEBUG_PTXQC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMetricsObjects_+3A_debug_ptxqc">DEBUG_PTXQC</code></td>
<td>
<p>Use qc objects from the package (FALSE) or from environment (TRUE/DEBUG)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matric objects
</p>

<hr>
<h2 id='getMQPARValue'>Retrieve a parameter value from a mqpar.xml file</h2><span id='topic+getMQPARValue'></span>

<h3>Description</h3>

<p>If the file has the param, then return it as string.
If the file is missing, warning is shown and NULL is returned.
If the param (i.e. XML tag) is unknown or cannot be extracted, the program will quit (since this is a hard error).
When multiple occurrences of the param are found (usually due to parameter groups), we test if the values are all identical.
If so, the value is returned. If the values are different, a warning is emitted and NULL is returned unless 'allow_multiple = TRUE'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMQPARValue(mqpar_filename, xpath, allow_multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMQPARValue_+3A_mqpar_filename">mqpar_filename</code></td>
<td>
<p>Filename (incl. absolute or relative path) to the mqpar.xml file</p>
</td></tr>
<tr><td><code id="getMQPARValue_+3A_xpath">xpath</code></td>
<td>
<p>An XPath to extract the content of XML tag(s), e.g. '//firstSearchTol'</p>
</td></tr>
<tr><td><code id="getMQPARValue_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If the XPath expression returns more than one value, all values must be identical (not allowing multiple different values) or 'stop()' is called</p>
</td></tr>
</table>


<h3>Details</h3>

<p>E.g. calling getMQPARValue(&quot;mqpar.xml&quot;, &quot;//firstSearchTol&quot;)
will look up the line
&lt;firstSearchTol&gt;20&lt;/firstSearchTol&gt;
and return &quot;20&quot; (string!).
</p>


<h3>Value</h3>

<p>The stored value as string(!)
</p>

<hr>
<h2 id='getPCA'>Create a principal component analysis (PCA) plot for the first two dimensions.</h2><span id='topic+getPCA'></span>

<h3>Description</h3>

<p>Create a principal component analysis (PCA) plot for the first two dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPCA(data, do_plot = TRUE, connect_line_order = NA, gg_layer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPCA_+3A_data">data</code></td>
<td>
<p>Matrix(!) where each row is one high-dimensional point, with ncol dimensions, 
e.g. a mouse as an array of proteinexpressions
rownames(data) give classes for colouring (can be duplicates in matrices, as opposed to data.frames)</p>
</td></tr>
<tr><td><code id="getPCA_+3A_do_plot">do_plot</code></td>
<td>
<p>Show PCA plot? if ==2, then shows correlations plot as well</p>
</td></tr>
<tr><td><code id="getPCA_+3A_connect_line_order">connect_line_order</code></td>
<td>
<p>Connect points by lines, the order is given by this vector.
Default: NA (no lines)</p>
</td></tr>
<tr><td><code id="getPCA_+3A_gg_layer">gg_layer</code></td>
<td>
<p>More parameters added to a ggplot object (ggplot(x) + gg_layer)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[invisible] Named list with &quot;PCA&quot;: The PCA object as returned by <code><a href="stats.html#topic+prcomp">prcomp</a></code>, access $x for PC values
and &quot;plots&quot;: list of plot objects (one or two)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 5
m = 10
data = matrix(runif(n * m), nrow = n, ncol = m)
rownames(data) = 1:n
getPCA(data, connect_line_order = 1:n, gg_layer = ggplot2::ggtitle("test"))

</code></pre>

<hr>
<h2 id='getPeptideCounts'>Extract the number of peptides observed per Raw file
from an evidence table.</h2><span id='topic+getPeptideCounts'></span>

<h3>Description</h3>

<p>Required columns are &quot;fc.raw.file&quot;, &quot;modified.sequence&quot; and &quot;is.transferred&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPeptideCounts(df_evd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPeptideCounts_+3A_df_evd">df_evd</code></td>
<td>
<p>Data.frame of evidence.txt as read by MQDataReader</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If match-between-runs was enabled during the MaxQuant run,
the data.frame returned will contain separate values for 'transferred' evidence
plus an 'MBRgain' column, which will give the extra MBR evidence in percent.
</p>


<h3>Value</h3>

<p>Data.frame with columns 'fc.raw.file', 'counts', 'category', 'MBRgain'
</p>

<hr>
<h2 id='getProteinCounts'>Extract the number of protein groups observed per Raw file
from an evidence table.</h2><span id='topic+getProteinCounts'></span>

<h3>Description</h3>

<p>Required columns are &quot;protein.group.ids&quot;, &quot;fc.raw.file&quot; and &quot;is.transferred&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProteinCounts(df_evd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getProteinCounts_+3A_df_evd">df_evd</code></td>
<td>
<p>Data.frame of evidence.txt as read by MQDataReader</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If match-between-runs was enabled during the MaxQuant run,
the data.frame returned will contain separate values for 'transferred' evidence
plus an 'MBRgain' column, which will give the extra MBR evidence in percent.
</p>


<h3>Value</h3>

<p>Data.frame with columns 'fc.raw.file', 'counts', 'category', 'MBRgain'
</p>

<hr>
<h2 id='getQCHeatMap'>Generate a Heatmap from a list of QC measurements.</h2><span id='topic+getQCHeatMap'></span>

<h3>Description</h3>

<p>Each list entry is a data.frame with two columns. 
The first one contains the Raw file name (or the short version).
and should be named 'raw.file' (or 'fc.raw.file'). 
The second column's name must be an expression (see ?plotmath)
and contains quality values in the range [0,1]. If values are outside this range, 
a warning is issued and values are cut to the nearest allowed value (e.g. '1.2' becomes '1').
List entries are merged and columns are ordered by name.
</p>
<p>All substrings enclosed by 'X[0-9]*X.' will be removed (can be used for sorting columns).
The resulting string is evaluated as an expression. 
E.g. parse(text = &lt;colname&gt;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQCHeatMap(lst_qcMetrics, raw_file_mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getQCHeatMap_+3A_lst_qcmetrics">lst_qcMetrics</code></td>
<td>
<p>List of QCMetric objects</p>
</td></tr>
<tr><td><code id="getQCHeatMap_+3A_raw_file_mapping">raw_file_mapping</code></td>
<td>
<p>Data.frame with 'from' and 'to' columns for name mapping to unify names from list entries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To judge the overall quality of each raw file a summary column is added, 
values being the mean of all other columns per row.
</p>


<h3>Value</h3>

<p>A ggplot object for printing
</p>

<hr>
<h2 id='getReportFilenames'>Assembles a list of output file names, which will be created during reporting.</h2><span id='topic+getReportFilenames'></span>

<h3>Description</h3>

<p>You can combine **report_name_has_folder** (and **mzTab_filename** for mzTab files) to obtain report filenames which are even more
robust to moving around (since they contain infixes of the mzTab filename and the folder),
e.g. '@em 'report_HEK293-study_myProjects.html&ldquo;, where the input 
was &lsquo;mzTab_filename=&rsquo;HEK293-study.mzTab&lsquo; and 'folder=&rsquo;c:/somePath/myProjects/'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReportFilenames(
  folder,
  report_name_has_folder = TRUE,
  mzTab_filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getReportFilenames_+3A_folder">folder</code></td>
<td>
<p>Directory where the MaxQuant output (txt folder) or the mzTab file resides</p>
</td></tr>
<tr><td><code id="getReportFilenames_+3A_report_name_has_folder">report_name_has_folder</code></td>
<td>
<p>Boolean: Should the report files (html, pdf) contain the name
of the deepest(=last) subdirectory in **txt_folder** which is not 'txt'?
Useful for discerning different reports in a PDF viewer.
E.g. when flag is FALSE: 'report_v0.91.0.html'; and 'report_v0.91.0_bloodStudy.html' when flag is TRUE (and the
txt folder is '.../bloodStudy/txt/' or '...bloodStudy/')</p>
</td></tr>
<tr><td><code id="getReportFilenames_+3A_mztab_filename">mzTab_filename</code></td>
<td>
<p>If input is an mzTab, specify its name, so that the filenames can use its basename as infix
E.g. when &lsquo;mzTab_filename = &rsquo;HEK293-study.mzTab'' then the output will be
'report_HEK293-study.html'.
This allows to get reports on multiple mzTabs in the same folder without overwriting report results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of output file names (just names, no file is created) 
with list entries: 
**yaml_file**, **heatmap_values_file**, **R_plots_file**, **filename_sorting**, **mzQC_file**, **log_file**, **report_file_prefix**, **report_file_PDF**, **report_file_HTML**
</p>

<hr>
<h2 id='getRunQualityTemplate'>Get an mzQC runQuality without actual metrics, but with full metadata</h2><span id='topic+getRunQualityTemplate'></span>

<h3>Description</h3>

<p>Get an mzQC runQuality without actual metrics, but with full metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRunQualityTemplate(fc.raw.file, raw_file_mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRunQualityTemplate_+3A_fc.raw.file">fc.raw.file</code></td>
<td>
<p>For which run</p>
</td></tr>
<tr><td><code id="getRunQualityTemplate_+3A_raw_file_mapping">raw_file_mapping</code></td>
<td>
<p>A data.frame with cols 'from', 'to' and maybe 'best.effort' (if shorting was unsuccessful), as e.g. obtained by a FilenameMapper$raw_file_mapping</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MzQCrunQuality object
</p>

<hr>
<h2 id='ggAxisLabels'>Function to thin out the number of labels shown on an axis in GGplot</h2><span id='topic+ggAxisLabels'></span>

<h3>Description</h3>

<p>By default, 20 labels (or up to 40 see below) are shown.
If the number of items is less than twice the number of desired labels,
all labels will be shown (to avoid irregular holes for some labels).
I.e. if n=20, and x has 22 entries, there would be only two labels removed, giving a very irregular picture.
It only becomes somewhat regular if after any label there is at least one blank, i.e. at most
half the entries are labeled.
#' 
Example: 
## p is any ggplot object
p + scale_y_discrete(breaks = ggAxisLabels) 
## customize 'n'
my.ggAxisLabels = function(x) ggAxisLabels(x, n = 4)
p + scale_y_discrete(breaks = my.ggAxisLabels)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggAxisLabels(x, n = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggAxisLabels_+3A_x">x</code></td>
<td>
<p>Vector of labels (passed by GGplot)</p>
</td></tr>
<tr><td><code id="ggAxisLabels_+3A_n">n</code></td>
<td>
<p>Number of labels to show</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shortened version of 'x'
</p>

<hr>
<h2 id='ggText'>Plot a text as graphic using ggplot2.</h2><span id='topic+ggText'></span>

<h3>Description</h3>

<p>Plot a text as graphic using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggText(title, text, col = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggText_+3A_title">title</code></td>
<td>
<p>The title of the plot</p>
</td></tr>
<tr><td><code id="ggText_+3A_text">text</code></td>
<td>
<p>Centered text, can contain linebreaks</p>
</td></tr>
<tr><td><code id="ggText_+3A_col">col</code></td>
<td>
<p>Colour of text (excluding the title)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='grepv'>Grep with values returned instead of indices.</h2><span id='topic+grepv'></span>

<h3>Description</h3>

<p>The parameter 'value' should not be passed to this function since it is 
passed internally already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepv(reg, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grepv_+3A_reg">reg</code></td>
<td>
<p>regex param</p>
</td></tr>
<tr><td><code id="grepv_+3A_data">data</code></td>
<td>
<p>container</p>
</td></tr>
<tr><td><code id="grepv_+3A_...">...</code></td>
<td>
<p>other params forwarded to grep()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values of data which matched the regex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  grepv("x", c("abc", "xyz"))
  ## --&gt; "xyz"
  
</code></pre>

<hr>
<h2 id='idTransferCheck'>Check how close transferred ID's after alignment are to their genuine IDs within one Raw file.</h2><span id='topic+idTransferCheck'></span>

<h3>Description</h3>

<p>The input is a data.frame containing feature evidence with corrected retention times,
e.g. a 'calibrated.retention.time' column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idTransferCheck(df_evd_all)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idTransferCheck_+3A_df_evd_all">df_evd_all</code></td>
<td>
<p>A data.frame with columns 'type', 'calibrated.retention.time', 'modified.sequence', 'charge', 'raw.file'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function must be given MS/MS identifications of type &quot;MULTI-MSMS&quot; and &quot;MSMS-MATCH&quot;.
It will stop() otherwise.
</p>
<p>We compare for each peptide sequence (and charge) the RT difference within groups of either genuine as well as mixed pairs.
For every comparison made, we report the RT span If alignment worked perfectly, the span are very small (&lt;1 min),
for the mixed group, i.e. the pairs are accidentally split 3D peaks. Alignment performance has no influence on the
genuine-only groups.
</p>
<p>Note: We found early MaxQuant versions (e.g. 1.2.2.5) to have an empty 'modified.sequence' column for 'MULTI-MATCH' entries.
The sequence which SHOULD be present is equal to the immediate upper row. This is what we use to guess the sequence.
However, this relies on the data.frame not being subsetted before (we can sort using the 'id' column)!
</p>


<h3>Value</h3>

<p>A data.frame containing the RT diff for each ID-group found in a Raw file (bg = genuine).
</p>

<hr>
<h2 id='inMatchWindow'>For grouped peaks: separate them into in-width vs. out-width class.</h2><span id='topic+inMatchWindow'></span>

<h3>Description</h3>

<p>Looking at groups only: Compute the fraction of 3D-peak pair groups per Raw file which 
have an acceptable RT difference after alignment using the result from 'idTransferCheck()',
i.e. compute the fraction of groups which are within a certain RT tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inMatchWindow(data, df.allowed.deltaRT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inMatchWindow_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'rtdiff_mixed', 'rtdiff_genuine'</p>
</td></tr>
<tr><td><code id="inMatchWindow_+3A_df.allowed.deltart">df.allowed.deltaRT</code></td>
<td>
<p>The allowed matching difference for each Raw file (as data.frame(fc.rawfile, m))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returned value is between 0 (bad) and 1 (all within tolerance).
</p>


<h3>Value</h3>

<p>A data.frame with one row for each raw.file and columns 'raw.file' and score 'withinRT' (0-1)
</p>

<hr>
<h2 id='lcpCount'>Count the number of chars of the longest common prefix</h2><span id='topic+lcpCount'></span>

<h3>Description</h3>

<p>Count the number of chars of the longest common prefix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcpCount(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lcpCount_+3A_x">x</code></td>
<td>
<p>Vector of strings with common prefix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length of LCP
</p>

<hr>
<h2 id='LCS'>Compute longest common substring of two strings.</h2><span id='topic+LCS'></span>

<h3>Description</h3>

<p>Implementation is very inefficient (dynamic programming in R)
&ndash;&gt; use only on small instances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCS(s1, s2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCS_+3A_s1">s1</code></td>
<td>
<p>String one</p>
</td></tr>
<tr><td><code id="LCS_+3A_s2">s2</code></td>
<td>
<p>String two</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String containing the longest common substring
</p>

<hr>
<h2 id='lcsCount'>Count the number of chars of the longest common suffix</h2><span id='topic+lcsCount'></span>

<h3>Description</h3>

<p>Count the number of chars of the longest common suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcsCount(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lcsCount_+3A_x">x</code></td>
<td>
<p>Vector of strings with common suffix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length of LCS
</p>

<hr>
<h2 id='LCSn'>Find longest common substring from 'n' strings.</h2><span id='topic+LCSn'></span>

<h3>Description</h3>

<p>Warning: greedy heuristic! This is not guaranteed to find the best solution (or any solution at all), since its done pairwise with the shortest input string as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCSn(strings, min_LCS_length = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCSn_+3A_strings">strings</code></td>
<td>
<p>A vector of strings in which to search for LCS</p>
</td></tr>
<tr><td><code id="LCSn_+3A_min_lcs_length">min_LCS_length</code></td>
<td>
<p>Minimum length expected. Empty string is returned if the result is shorter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>longest common substring (or &quot;&quot; if shorter than <code>min_LCS_length</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LCSn(c("1_abcde...",
       "2_abcd...",
       "x_abc..."))  ## --&gt; "_abc"
LCSn(c("16_IMU008_CISPLA_E5_R11", 
       "48_IMU008_CISPLA_P4_E7_R31",
       "60_IMU008_CISPLA_E7_R11"), 3) ## --&gt;"_IMU008_CISPLA_"
LCSn(c("AAAAACBBBBB", 
       "AAAAADBBBBB",
       "AAAABBBBBEF",
       "AAABBBBBDGH")) ## --&gt;  "BBBBB"
LCSn(c("AAAXXBBB",
       "BBBXXDDD",
       "XXAAADDD")) ## --&gt; fails due to greedy approach; should be "XX"

</code></pre>

<hr>
<h2 id='longestCommonPrefix'>Get the longest common prefix from a set of strings.</h2><span id='topic+longestCommonPrefix'></span>

<h3>Description</h3>

<p>Input is converted to character (e.g. from factor) first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longestCommonPrefix(strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longestCommonPrefix_+3A_strings">strings</code></td>
<td>
<p>Vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single string - might be empty (&quot;&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  longestCommonPrefix(c("CBA.321", "CBA.77654", ""))    ## ""
  longestCommonPrefix(c("CBA.321", "CBA.77654", "CB"))  ## "CB"
  longestCommonPrefix(c("ABC.123", "ABC.456"))          ## "ABC."
  longestCommonPrefix(c("nothing", "in", "common"))     ## ""


</code></pre>

<hr>
<h2 id='longestCommonSuffix'>Like longestCommonPrefix(), but on the suffix.</h2><span id='topic+longestCommonSuffix'></span>

<h3>Description</h3>

<p>Like longestCommonPrefix(), but on the suffix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longestCommonSuffix(strings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longestCommonSuffix_+3A_strings">strings</code></td>
<td>
<p>Vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single string - might be empty (&quot;&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 longestCommonSuffix(c("123.ABC", "45677.ABC", "BC"))  ## "BC"
 longestCommonSuffix(c("123.ABC", "", "BC"))           ## ""
 longestCommonSuffix(c("123.ABC", "45677.ABC"))        ## ".ABC"
 longestCommonSuffix(c("nothing", "in", "common"))     ## ""
 
</code></pre>

<hr>
<h2 id='modsToTable'>Convert list of (mixed)modifications to a frequency table</h2><span id='topic+modsToTable'></span>

<h3>Description</h3>

<p>Convert list of (mixed)modifications to a frequency table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsToTable(mod_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modsToTable_+3A_mod_list">mod_list</code></td>
<td>
<p>A vector with modifications, each for a specific peptide. Multiple mods per entry are allowed, each separated by comma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with 'modification_names' and 'Freq' (0-100)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modsToTable(c("Ox (M)", 
              "Unmodified",
              "Ox (M),Acetyl (Prot N-term)",
              "2 Ox (M)",
              "Unmodified",
              "Unmodified"))


</code></pre>

<hr>
<h2 id='modsToTableByRaw'>Convert list of (mixed)modifications to a frequency table</h2><span id='topic+modsToTableByRaw'></span>

<h3>Description</h3>

<p>Convert list of (mixed)modifications to a frequency table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modsToTableByRaw(
  df_evd,
  name_unmod = "Unmodified",
  name_unmod_inverse = "Modified (total)"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modsToTableByRaw_+3A_df_evd">df_evd</code></td>
<td>
<p>data.frame with 'fc.raw.file' and a 'modifications' column, which contains the modifications for each peptide.</p>
</td></tr>
<tr><td><code id="modsToTableByRaw_+3A_name_unmod">name_unmod</code></td>
<td>
<p>String in 'modifications' which represents an unmodified peptide</p>
</td></tr>
<tr><td><code id="modsToTableByRaw_+3A_name_unmod_inverse">name_unmod_inverse</code></td>
<td>
<p>If non-empty, then inverse the frequencies of the 'name_unmod' modifications (i.e. 100-x) IFF they are &gt;=50% on average (across Raw files) and rename them to this string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with 'fc.raw.file', 'modification_names' (factor), and 'Freq' (0-100)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = data.frame(fc.raw.file = rep(c("file A", "file B"),
                                each = 3),
       modifications = c("Oxidation (M)",
                        "Unmodified",
                        "Oxidation (M),Acetyl (Protein N-term)",
                        "2 Oxidation (M)", 
                        "Unmodified", "Unmodified"))
modsToTableByRaw(data)


</code></pre>

<hr>
<h2 id='mosaicize'>Prepare a Mosaic plot of two columns in long format.</h2><span id='topic+mosaicize'></span>

<h3>Description</h3>

<p>Found at http://stackoverflow.com/questions/19233365/how-to-create-a-marimekko-mosaic-plot-in-ggplot2
Modified (e.g. to pass R check)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaicize(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosaicize_+3A_data">data</code></td>
<td>
<p>A data.frame with exactly two columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame, which can be used for plotting and has the following columns:
'Var1' - marginalized values from 1st input column
'Var2' - marginalized values from 2nd input column
'Freq' - relative frequency of the combination given in [Var1, Var2]
'margin_var1' - frequency of the value given in Var1
'var2_height' - frequency of the value given in Var2, relative to Var1
'var1_center' - X-position when plotting (large sets get a larger share)
</p>


<h3>Value</h3>

<p>Data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(raw.file = c(rep('file A', 100), rep('file B', 40)),
                    charge = c(rep(2, 60), rep(3, 30), rep(4, 10),
                               rep(2, 30), rep(3, 7), rep(4, 3)))
  mosaicize(data)                             
  
</code></pre>

<hr>
<h2 id='MQDataReader-class'>S5-RefClass to read MaxQuant .txt files</h2><span id='topic+MQDataReader-class'></span><span id='topic+MQDataReader'></span>

<h3>Description</h3>

<p>This class is used to read MQ data tables using <code>MQDataReader::readMQ()</code> while holding
the internal raw file &ndash;&gt; short raw file name mapping (stored in a member called 
'fn_map') and updating/using it every time <code>MQDataReader::readMQ()</code> is called.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MQDataReader-class_+3A_file">file</code></td>
<td>
<p>(Relative) path to a MQ txt file.</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_filter">filter</code></td>
<td>
<p>Searched for &quot;C&quot; and &quot;R&quot;. If present, [c]ontaminants and [r]everse hits are removed if the respective columns are present.
E.g. to filter both, <code>filter = "C+R"</code></p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_type">type</code></td>
<td>
<p>Allowed values are:
&quot;pg&quot; (proteinGroups) [default], adds abundance index columns (*AbInd*, replacing 'intensity')
&quot;sm&quot; (summary), splits into three row subsets (raw.file, condition, total)
&quot;ev&quot; (evidence), will fix empty modified.sequence cells for older MQ versions (when MBR is active)
&quot;msms_scans&quot;, will fix invalid (negative) scan event numbers
Any other value will not add/modify any columns</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_col_subset">col_subset</code></td>
<td>
<p>A vector of column names as read by read.delim(), e.g., spaces are replaced by dot already.
If given, only columns with these names (ignoring lower/uppercase) will be returned (regex allowed)
E.g. col_subset=c(&quot;^lfq.intensity.&quot;, &quot;protein.name&quot;)</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_add_fs_col">add_fs_col</code></td>
<td>
<p>If TRUE and a column 'raw.file' is present, an additional column 'fc.raw.file' will be added with 
common prefix AND common substrings removed (<code><a href="#topic+simplifyNames">simplifyNames</a></code>)
E.g. two rawfiles named 'OrbiXL_2014_Hek293_Control', 'OrbiXL_2014_Hek293_Treated' will give
'Control', 'Treated'
If <code>add_fs_col</code> is a number AND the longest short-name is still longer, the names are discarded and replaced by
a running ID of the form 'file &lt;x&gt;', where &lt;x&gt; is a number from 1 to N.
If the function is called again and a mapping already exists, this mapping is used.
Should some raw.files be unknown (ie the mapping from the previous file is incomplete), they will be augmented</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_check_invalid_lines">check_invalid_lines</code></td>
<td>
<p>After reading the data, check for unusual number of NA's to detect if file was corrupted by Excel or alike</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_lfq_action">LFQ_action</code></td>
<td>
<p>[For type=='pg' only] An additional custom LFQ column ('cLFQ...') is created where
zero values in LFQ columns are replaced by the following method IFF(!) the corresponding raw intensity is &gt;0 (indicating that LFQ is erroneusly 0)
&quot;toNA&quot;: replace by NA
&quot;impute&quot;: replace by lowest LFQ value &gt;0 (simulating 'noise')</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_...">...</code></td>
<td>
<p>Additional parameters passed on to read.delim()</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_colname">colname</code></td>
<td>
<p>Name of the column (e.g. 'contaminants') in the mq.data table</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_valid_entries">valid_entries</code></td>
<td>
<p>Vector of values to be replaced (must contain all values expected in the column &ndash; fails otherwise)</p>
</td></tr>
<tr><td><code id="MQDataReader-class_+3A_replacements">replacements</code></td>
<td>
<p>Vector of values inserted with the same length as <code>valid_entries</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since MaxQuant changes capitalization and sometimes even column names, it seemed convenient
to have a function which just reads a txt file and returns unified column names, irrespective of the MQ version.
So, it unifies access to columns (e.g. by using lower case for ALL columns) and ensures columns are
identically named across MQ versions:
</p>
<pre>
 alternative term          new term
 -----------------------------------------
 protease                  enzyme
 protein.descriptions      fasta.headers
 potential.contaminant     contaminant
 mass.deviations           mass.deviations..da.
 basepeak.intensity        base.peak.intensity
</pre>
<p>We also correct 'reporter.intensity.*' naming issues to MQ 1.6 convention, when 'reporter.intensity.not.corrected' is present.
MQ 1.5 uses: reporter.intensity.X and reporter.intensity.not.corrected.X
MQ 1.6 uses: reporter.intensity.X and reporter.intensity.corrected.X       
</p>
<p>Note: you must find a regex which matches both versions, or explicitly add both terms if you are requesting only a subset
of columns!
</p>
<p>Fixes for msmsScans.txt:
negative Scan Event Numbers in msmsScans.txt are reconstructed by using other columns
</p>
<p>Automatically detects UTF8-BOM encoding and deals with it (since MQ2.4).
</p>
<p>Example of usage:
</p>
<pre>
  mq = MQDataReader$new()
  d_evd = mq$readMQ("evidence.txt", type="ev", filter="R", col_subset=c("proteins", "Retention.Length", "retention.time.calibration")) 
</pre>
<p>If the file is empty, this function shows a warning and returns NULL.
If the file is present but cannot be read, the program will stop.
</p>
<p>Wrapper to read a MQ txt file (e.g. proteinGroups.txt).
</p>


<h3>Value</h3>

<p>A data.frame of the respective file
</p>
<p>Replaces values in the mq.data member with (binary) values.
Most MQ tables contain columns like 'contaminants' or 'reverse', whose values are either empty strings
or &quot;+&quot;, which is inconvenient and can be much better represented as TRUE/FALSE.
The params <code>valid_entries</code> and <code>replacements</code> contain the matched pairs, which determine what is replaced with what.
</p>
<p>Returns <code>TRUE</code> if successful.
</p>


<h3>Methods</h3>


<dl>
<dt><code>getInvalidLines()</code></dt><dd><p>Detect broken lines (e.g. due to Excel import+export)
</p>
<p>When editing a MQ txt file in Microsoft Excel, saving the file can cause it to be corrupted,
since Excel has a single cell content limit of 32k characters 
(see http://office.microsoft.com/en-001/excel-help/excel-specifications-and-limits-HP010342495.aspx)
while MQ can easily reach 60k (e.g. in oxidation sites column).
Thus, affected cells will trigger a line break, effectively splitting one line into two (or more).
</p>
<p>If the table has an 'id' column, we can simply check the numbers are consecutive. If no 'id' column is available,
we detect line-breaks by counting the number of NA's per row and finding outliers.
The line break then must be in this line (plus the preceeding or following one). Depending on where
the break happened we can also detect both lines right away (if both have more NA's than expected).
</p>
<p>Currently, we have no good strategy to fix the problem since columns are not aligned any longer, which
leads to columns not having the class (e.g. numeric) they should have.
(thus one would need to un-do the linebreak and read the whole file again)
</p>
<p>[Solution to the problem: try LibreOffice 4.0.x or above &ndash; seems not to have this limitation]
</p>
<p>@return Returns a vector of indices of broken (i.e. invalid) lines
</p>
</dd>
</dl>

<hr>
<h2 id='MzTabReader-class'>Class to read an mzTab file and store the tables internally.</h2><span id='topic+MzTabReader-class'></span><span id='topic+MzTabReader'></span>

<h3>Description</h3>

<p>The 'sections' field is initialized after $readMzTab was called.
The 'fn_map' fields should be initialized via ...$fn_map$readMappingFile(...) manually if user-defined filename mappings are desired
and is automatically updated/queried when $readMzTab is called.
</p>


<h3>Fields</h3>


<dl>
<dt><code>sections</code></dt><dd><p>MzTab sections as list. Valid list entries are: &quot;MTD&quot;, &quot;PRT&quot;, &quot;PEP&quot;, &quot;PSM&quot;, &quot;SML&quot;, &quot;filename&quot; and &quot;comments&quot;</p>
</dd>
<dt><code>fn_map</code></dt><dd><p>FilenameMapper which can translate raw filenames into something shorter</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>RTUnitCorrection(dt)</code></dt><dd><p>Convert all RT columns from seconds (OpenMS default) to minutes (MaxQuant default)</p>
</dd>
<dt><code>getEvidence()</code></dt><dd><p>Basically the PSM table and additionally columns named 'raw.file' and 'fc.raw.file'.</p>
</dd>
<dt><code>getMSMSScans(identified_only = FALSE)</code></dt><dd><p>Basically the PSM table (partially renamed columns) and additionally two columns 'raw.file' and 'fc.raw.file'. 
If identified_only is TRUE, only MS2 scans which were identified (i.e. a PSM) are returned &ndash; this is equivalent to msms.txt in MaxQuant.</p>
</dd>
<dt><code>getParameters()</code></dt><dd><p>Converts internal mzTab metadata section to a two column key-value data.frame similar to MaxQuants parameters.txt.</p>
</dd>
<dt><code>getProteins()</code></dt><dd><p>Basically the PRT table ...</p>
</dd>
<dt><code>getSummary()</code></dt><dd><p>Converts internal mzTab metadata section to a two data.frame with columns 'fc.raw.file', 'ms.ms.identified....'
similar to MaxQuants summary.txt.</p>
</dd>
<dt><code>renameColumns(dt, namelist)</code></dt><dd><p>Renames all columns and throws a warning if a column does not exist in the data</p>
</dd>
</dl>

<hr>
<h2 id='pasten'>paste with newline as separator</h2><span id='topic+pasten'></span>

<h3>Description</h3>

<p>paste with newline as separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pasten(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pasten_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to paste()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value of paste()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pasten("newline","separated")
  ## --&gt; "newline\nseparated"
  
</code></pre>

<hr>
<h2 id='pastet'>paste with tab as separator</h2><span id='topic+pastet'></span>

<h3>Description</h3>

<p>paste with tab as separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pastet(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pastet_+3A_...">...</code></td>
<td>
<p>Arguments forwarded to paste()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value of paste()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pastet("tab","separated")
  ## --&gt; "tab\tseparated"
  
</code></pre>

<hr>
<h2 id='peakSegmentation'>Determine fraction of evidence which causes segmentation, i.e. sibling peaks at different RTs
confirmed either by genuine or transferred MS/MS.</h2><span id='topic+peakSegmentation'></span>

<h3>Description</h3>

<p>Sometimes, MQ splits a feature into 2 or more if the chromatograpic conditions are not optimal and there
is a drop in RT intensity.
If both features contain successful MS/MS scans, we will find the same peptide twice (with slightly different RT)
in the same charge state. This constitutes a natively split peak and is rare (95
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peakSegmentation(df_evd_all)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peakSegmentation_+3A_df_evd_all">df_evd_all</code></td>
<td>
<p>A data.frame of evidences containing the above columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Match-between-runs is used and the RT alignment is not perfect, then a peptide might be inferred at a wrong
RT position, even though this Raw file already contains MS/MS evidence of this peptide.
Usually the number of peak duplicates rises drastically (e.g. only 75
In most cases, the RT is too far off to be a split peak. It's rather a lucky hit with accidentally the same mass-to-charge,
and thus the intensity is random.
To find by how much these peak pairs differ in RT, use idTransferCheck() and inMatchWindow().
</p>
<p>Required columns are 'is.transferred', 'fc.raw.file', 'modified.sequence', 'charge', 'type'.
</p>
<p>Note that this function must be given MS/MS identifications of type &quot;MULTI-MSMS&quot; and &quot;MSMS-MATCH&quot;.
It will stop() otherwise.
</p>


<h3>Value</h3>

<p>A data.frame with one row per Raw file and 
three columns: 
1) 
2) 
3) 
</p>

<hr>
<h2 id='peakWidthOverTime'>Discretize RT peak widths by averaging values per time bin.</h2><span id='topic+peakWidthOverTime'></span>

<h3>Description</h3>

<p>Should be applied for each Raw file individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peakWidthOverTime(data, RT_bin_width = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peakWidthOverTime_+3A_data">data</code></td>
<td>
<p>Data.frame with columns 'retention.time' and 'retention.length'</p>
</td></tr>
<tr><td><code id="peakWidthOverTime_+3A_rt_bin_width">RT_bin_width</code></td>
<td>
<p>Bin size in minutes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data.frame, where 'bin' gives the index of each bin, 'RT' is 
the middle of each bin and 'peakWidth' is the averaged peak width per bin.
</p>


<h3>Value</h3>

<p>Data.frame with columns 'bin', 'RT', 'peakWidth'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(retention.time = seq(30,200, by=0.001)) ## one MS/MS per 0.1 sec
  data$retention.length = seq(0.3, 0.6, length.out = nrow(data)) + rnorm(nrow(data), 0, 0.1)
  d = peakWidthOverTime(data)
  plot(d$RT, d$peakWidth)
  
  
</code></pre>

<hr>
<h2 id='plot_CalibratedMSErr'>Plot bargraph of uncalibrated mass errors for each Raw file.</h2><span id='topic+plot_CalibratedMSErr'></span>

<h3>Description</h3>

<p>Boxes are optionally colored to indicate that a MQ bug was detected or 
if PTXQC detected a too narrow search window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_CalibratedMSErr(
  data,
  MQBug_raw_files,
  stats,
  y_lim,
  extra_limit = NA,
  title_sub = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_CalibratedMSErr_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'mass.error..ppm.'</p>
</td></tr>
<tr><td><code id="plot_CalibratedMSErr_+3A_mqbug_raw_files">MQBug_raw_files</code></td>
<td>
<p>List of Raw files with invalid calibration values</p>
</td></tr>
<tr><td><code id="plot_CalibratedMSErr_+3A_stats">stats</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'outOfCal'</p>
</td></tr>
<tr><td><code id="plot_CalibratedMSErr_+3A_y_lim">y_lim</code></td>
<td>
<p>Range of y-axis</p>
</td></tr>
<tr><td><code id="plot_CalibratedMSErr_+3A_extra_limit">extra_limit</code></td>
<td>
<p>Position where a v-line is plotted (for visual guidance)</p>
</td></tr>
<tr><td><code id="plot_CalibratedMSErr_+3A_title_sub">title_sub</code></td>
<td>
<p>Subtitle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n = c(150, 1000, 1000, 1000)
  data = data.frame(fc.raw.file = repEach(letters[4:1], n),
                    mass.error..ppm. = c(rnorm(n[1], 1, 2.4),
                                         rnorm(n[2], 0.5, 0.5),
                                         rnorm(n[3], 0.1, 0.7),
                                         rnorm(n[4], 0.3, 0.8)))
  stats = data.frame(fc.raw.file = letters[4:1],
                     sd = c(2.4, 0.5, 0.7, 0.8),
                     outOfCal = c(TRUE, FALSE, FALSE, FALSE))           
  plot_CalibratedMSErr(data, MQBug_raw_files = letters[1], stats, y_lim = c(-20,20), 15, "subtitle")

</code></pre>

<hr>
<h2 id='plot_Charge'>The plots shows the charge distribution per Raw file.
The output of 'mosaicize()' can be used directly.</h2><span id='topic+plot_Charge'></span>

<h3>Description</h3>

<p>The input is a data.frame with columns
'Var1' - name of the Raw file
'Var2' - charge (used as fill color)
'Var1_center' - contains X-position of the Raw file
'Var2_height' - relative frequency of the charge
'Margin_var1' - 
where each row represents one peptide sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_Charge(d_charge)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_Charge_+3A_d_charge">d_charge</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = data.frame(raw.file = c(rep('file A', 100), rep('file B', 40)),
                       data = c(rep(2, 60), rep(3, 30), rep(4, 10),
                                rep(2, 30), rep(3, 7), rep(4, 3)))
 plot_Charge(mosaicize(data))

</code></pre>

<hr>
<h2 id='plot_ContEVD'>Plot contaminants from evidence.txt, broken down into top5-proteins.</h2><span id='topic+plot_ContEVD'></span>

<h3>Description</h3>

<p>Plot contaminants from evidence.txt, broken down into top5-proteins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ContEVD(data, top5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ContEVD_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'contaminant', 'pname', 'intensity'</p>
</td></tr>
<tr><td><code id="plot_ContEVD_+3A_top5">top5</code></td>
<td>
<p>Name of the Top-5 Proteins (by relative intensity or whatever seems relevant)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(intensity = 1:12, 
                   pname = rep(letters[1:3], 4), 
                   fc.raw.file = rep(paste("f", 1:4), each=3),
                   contaminant = TRUE)
 ## providing more proteins than present... d,e will be ignored
 plot_ContEVD(data, top5 = letters[1:5])
 ## classify 'c' as 'other'
 plot_ContEVD(data, top5 = letters[1:2])

</code></pre>

<hr>
<h2 id='plot_ContsPG'>Plot contaminants from proteinGroups.txt</h2><span id='topic+plot_ContsPG'></span>

<h3>Description</h3>

<p>Plot contaminants from proteinGroups.txt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ContsPG(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ContsPG_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'group', 'cont_pc', 'logAbdClass'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame( 'group' = letters[1:10], 'cont_pc' = 2:11, 'logAbdClass' = c("low","high"))
 plot_ContsPG(data)

</code></pre>

<hr>
<h2 id='plot_ContUser'>Plot user-defined contaminants from evidence.txt</h2><span id='topic+plot_ContUser'></span>

<h3>Description</h3>

<p>Kolmogorov-Smirnoff p-values are plotted on top of each group.
High p-values indicate that Andromeda scores for contaminant peptides
are equal or higher compared to sample peptide scores, i.e. the probability that
sample peptides scores are NOT greater than contaminant peptide scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ContUser(data, name_contaminant, extra_limit, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ContUser_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'variable', 'value'</p>
</td></tr>
<tr><td><code id="plot_ContUser_+3A_name_contaminant">name_contaminant</code></td>
<td>
<p>Name of the contaminant shown in title</p>
</td></tr>
<tr><td><code id="plot_ContUser_+3A_extra_limit">extra_limit</code></td>
<td>
<p>Position where a h-line is plotted (for visual guidance)</p>
</td></tr>
<tr><td><code id="plot_ContUser_+3A_subtitle">subtitle</code></td>
<td>
<p>Optional subtitle for plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file = letters[1:3], 
                   variable = c(rep("spectralCount", 3),
                                 rep("intensity", 3),
                                 rep("above.thresh", 3),
                                 rep("score_KS", 3)),
                   value = c(10, 20, 15, 9, 21, 14, 0, 1, 1, 0.3, 0.01, 0.04))
 plot_ContUser(data, "myco", 5, "subtitle")

</code></pre>

<hr>
<h2 id='plot_ContUserScore'>Plot Andromeda score distribution of contaminant peptide vs. matrix peptides.</h2><span id='topic+plot_ContUserScore'></span>

<h3>Description</h3>

<p>The data is expected to be an ECDF already, x being the Andromeda score, y being the culmulative probability.
The Score is the probability of a Kolm.-Smirnoff test that the contaminant scores are larger (i.e.
large p-values indicate true contamination).
You will only see this plot if the 
but high-scoring contaminant peptides, which would erroneously give you a large p-value and make you believe
your sample is contaminated although that's not the case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ContUserScore(data, raw.file, score)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ContUserScore_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'x', 'y', 'condition'</p>
</td></tr>
<tr><td><code id="plot_ContUserScore_+3A_raw.file">raw.file</code></td>
<td>
<p>Name of Raw file for which the data is displayed (will become part of the plot title)</p>
</td></tr>
<tr><td><code id="plot_ContUserScore_+3A_score">score</code></td>
<td>
<p>Score of how distinct the distributions are (will become part of the title)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(x = 10:60,
                   y = c(seq(0,1,length=51), seq(0.1, 1, length=51)), 
                   condition = rep(c("sample","contaminant"), each=51))
 plot_ContUserScore(data, 'test file', 0.96)

</code></pre>

<hr>
<h2 id='plot_CountData'>Plot Protein groups per Raw file</h2><span id='topic+plot_CountData'></span>

<h3>Description</h3>

<p>The input is a data.frame with protein/peptide counts, where 'category' designates
the origin of information (genuine ID, transferred ID, or both).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_CountData(data, y_max, thresh_line, title)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_CountData_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'counts', 'category'</p>
</td></tr>
<tr><td><code id="plot_CountData_+3A_y_max">y_max</code></td>
<td>
<p>Plot limit of y-axis</p>
</td></tr>
<tr><td><code id="plot_CountData_+3A_thresh_line">thresh_line</code></td>
<td>
<p>Position of a threshold line, indicating the usual target value</p>
</td></tr>
<tr><td><code id="plot_CountData_+3A_title">title</code></td>
<td>
<p>Main title, and optional subtitle (if vector of length 2 is provided)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file = rep(c("file A", "file B"), each=3),
                   counts = c(3674, 593, 1120, 2300, 400, 600), 
                   category = c("genuine","genuine+transferred","transferred"))
 plot_CountData(data, 6000, 4000, c("EVD: Protein Groups count", "gain: 23%"))

</code></pre>

<hr>
<h2 id='plot_DataOverRT'>Plot some count data over time for each Raw file.</h2><span id='topic+plot_DataOverRT'></span>

<h3>Description</h3>

<p>The input is a data.frame with columns
'RT' - RT in seconds, representing one bin
'counts' - number of counts at this bin
'fc.raw.file' - name of the Raw file
where each row represents one bin in RT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_DataOverRT(
  data,
  title,
  y_lab,
  x_lim = range(data$RT),
  y_max = max(data$counts)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_DataOverRT_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plot_DataOverRT_+3A_title">title</code></td>
<td>
<p>The plot title</p>
</td></tr>
<tr><td><code id="plot_DataOverRT_+3A_y_lab">y_lab</code></td>
<td>
<p>Label of y-axis</p>
</td></tr>
<tr><td><code id="plot_DataOverRT_+3A_x_lim">x_lim</code></td>
<td>
<p>Limits of the x-axis (2-tuple)</p>
</td></tr>
<tr><td><code id="plot_DataOverRT_+3A_y_max">y_max</code></td>
<td>
<p>Maximum of the y-axis (single value)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At most nine(!) Raw files can be plotted. If more are given,
an error is thrown.
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = data.frame(fc.raw.file = rep(paste('file', letters[1:3]), each=30),
                            RT = seq(20, 120, length.out = 30),
                        counts = c(rnorm(30, 400, 20), rnorm(30, 250, 15), rnorm(30, 50, 15)))
 plot_DataOverRT(data, "some title", "count data")

</code></pre>

<hr>
<h2 id='plot_IDRate'>Plot percent of identified MS/MS for each Raw file.</h2><span id='topic+plot_IDRate'></span>

<h3>Description</h3>

<p>Useful for a first overall impression of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_IDRate(data, id_rate_bad, id_rate_great, label_ID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_IDRate_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plot_IDRate_+3A_id_rate_bad">id_rate_bad</code></td>
<td>
<p>Number below which the ID rate is considered bad</p>
</td></tr>
<tr><td><code id="plot_IDRate_+3A_id_rate_great">id_rate_great</code></td>
<td>
<p>Number above which the ID rate is considered great</p>
</td></tr>
<tr><td><code id="plot_IDRate_+3A_label_id">label_ID</code></td>
<td>
<p>Named vector with colors for the categories given in data$cat</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a data.frame with columns
'fc.raw.file' - name of the Raw file
'ms.ms.identified....' - fraction of identified MS/MS spectra in percent
'cat' - identification category as arbitrary string
where each row represents one Raw file.
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> id_rate_bad = 20; id_rate_great = 35;
 label_ID = c("bad (&lt;20%)" = "red", "ok (...)" = "blue", "great (&gt;35%)" = "green")
 data = data.frame(fc.raw.file = paste('file', letters[1:3]),
                   ms.ms.identified.... = rnorm(3, 25, 15))
 data$cat = factor(cut(data$ms.ms.identified....,
                       breaks=c(-1, id_rate_bad, id_rate_great, 100),
                       labels=names(label_ID)))                  
 plot_IDRate(data, id_rate_bad, id_rate_great, label_ID)

</code></pre>

<hr>
<h2 id='plot_IDsOverRT'>Plot IDs over time for each Raw file.</h2><span id='topic+plot_IDsOverRT'></span>

<h3>Description</h3>

<p>Uses plot_DataOverRT() internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_IDsOverRT(data, x_lim = range(data$RT), y_max = max(data$counts))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_IDsOverRT_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plot_IDsOverRT_+3A_x_lim">x_lim</code></td>
<td>
<p>Limits of the x-axis (2-tuple)</p>
</td></tr>
<tr><td><code id="plot_IDsOverRT_+3A_y_max">y_max</code></td>
<td>
<p>Maximum of the y-axis (single value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = data.frame(fc.raw.file = rep(paste('file', letters[1:3]), each=30),
                            RT = seq(20, 120, length.out = 30),
                        counts = c(rnorm(30, 400, 20), rnorm(30, 250, 15), rnorm(30, 50, 15)))
 plot_IDsOverRT(data)

</code></pre>

<hr>
<h2 id='plot_IonInjectionTimeOverRT'>Plot line graph of TopN over Retention time.</h2><span id='topic+plot_IonInjectionTimeOverRT'></span>

<h3>Description</h3>

<p>Number of Raw files must be 6 at most. Function will stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_IonInjectionTimeOverRT(data, stats, extra_limit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_IonInjectionTimeOverRT_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'rRT', 'medIIT'</p>
</td></tr>
<tr><td><code id="plot_IonInjectionTimeOverRT_+3A_stats">stats</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'mean'</p>
</td></tr>
<tr><td><code id="plot_IonInjectionTimeOverRT_+3A_extra_limit">extra_limit</code></td>
<td>
<p>Visual guidance line (maximum acceptable IIT)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = rep(c("d","a","x"), each=100),
                    rRT = seq(20, 120, length.out = 100),
                    medIIT = c(round(runif(100, min=3, max=5)),
                               round(runif(100, min=5, max=8)),
                               round(runif(100, min=1, max=3)))
                    )
  stats = data.frame(fc.raw.file = c("d","a","x"),
                     mean = c(4, 6.5, 2))
  plot_IonInjectionTimeOverRT(data, stats, 10)

</code></pre>

<hr>
<h2 id='plot_MBRAlign'>Plot MaxQuant Match-between-runs alignment performance.</h2><span id='topic+plot_MBRAlign'></span>

<h3>Description</h3>

<p>The plots shows the correction function applied by MaxQuant, and the
residual RT (ideally 0) of each peptide to its reference. Uncalibrated peptides
are shown in red, calibrated ones in green.
The MaxQuant RT correction which was applied prior is shown in blue. The range of this function
can give hints if the allowed RT search window (20min by default) is sufficient or if
MaxQuant should be re-run with more tolerant settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MBRAlign(data, y_lim, title_sub, match_tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MBRAlign_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plot_MBRAlign_+3A_y_lim">y_lim</code></td>
<td>
<p>Plot range of y-axis</p>
</td></tr>
<tr><td><code id="plot_MBRAlign_+3A_title_sub">title_sub</code></td>
<td>
<p>Subtitle</p>
</td></tr>
<tr><td><code id="plot_MBRAlign_+3A_match_tol">match_tol</code></td>
<td>
<p>Maximal residual RT delta to reference (usually ~1 min)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a data.frame with columns
'calibrated.retention.time' - resulting (hopefully) calibratated RT after MQ-recal (the X-axis of the plot)
'retention.time.calibration' - delta applied by MaxQuant
'rtdiff' - remaining RT diff to reference peptide of the same sequence
'RTdiff_in' - is the feature aligned (within 'match_tol')?
'fc.raw.file_ext' - raw file
where each row represents one peptide whose RT was corrected by MaxQuant.
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file_ext = "file A", ## more than one would be possible
                   calibrated.retention.time = c(20:100), 
                   retention.time.calibration = 6 + sin((20:100)/10))
 data$rtdiff = rnorm(nrow(data))
 data$RTdiff_in = c("green", "red")[1 + (abs(data$rtdiff) &gt; 0.7)]
 
 plot_MBRAlign(data, c(-10, 10), "fancy subtitle", 0.7)

</code></pre>

<hr>
<h2 id='plot_MBRgain'>Plot MaxQuant Match-between-runs id transfer performance as a scatterplot.</h2><span id='topic+plot_MBRgain'></span>

<h3>Description</h3>

<p>Per Raw file, the absolute number of transferred IDs as well as the relative gain in percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MBRgain(data, title_sub = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MBRgain_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plot_MBRgain_+3A_title_sub">title_sub</code></td>
<td>
<p>Subtitle text</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a data.frame with columns
'fc.raw.file' - raw file name
'abs' - absolute number of transferred ID's
'pc' - gain on top of genuine IDs [
where each row represents one rawfile.
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = data.frame(fc.raw.file = paste("file", letters[1:4]),
                   abs = c(5461, 5312, 3618, 502), 
                   pc = c(34, 32, 22, 2))
 plot_MBRgain(data, "MBR gain: 18%")

</code></pre>

<hr>
<h2 id='plot_MBRIDtransfer'>Plot MaxQuant Match-between-runs id transfer performance.</h2><span id='topic+plot_MBRIDtransfer'></span>

<h3>Description</h3>

<p>The plots shows the different categories of peak classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MBRIDtransfer(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MBRIDtransfer_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a data.frame with columns
'fc.raw.file' - raw file name
'single' - fraction of peptides with are represent only once
'multi.inRT' - fraction of peptides with are represent multiple times, 
but within a certain RT peak width
'multi.outRT' - fraction of peptides with are represent multiple times,
with large RT distance
'sample' - raw file
where each row represents one peptide sequence.
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data = data.frame(fc.raw.file = rep(c("file A", "file B"), each = 3),
                   single = c(0.9853628, 0.8323160, 0.9438375,
                              0.9825538, 0.8003763, 0.9329961), 
                   multi.inRT = c(0.002927445, 0.055101018, 0.017593087,
                                  0.005636457, 0.099640044, 0.031870056),
                   multi.outRT = c(0.01170978, 0.11258294, 0.03856946,
                                   0.01180972, 0.09998363, 0.03513386),
                   sample = rep(c("genuine", "transferred", "all"), 2))
 plot_MBRIDtransfer(data)

</code></pre>

<hr>
<h2 id='plot_MissedCleavages'>Plot bargraph of missed cleavages.</h2><span id='topic+plot_MissedCleavages'></span>

<h3>Description</h3>

<p>Per Raw file, an arbitrary number of missed cleavage classes (one per column) can be given.
The total fraction of 3D-peaks must sum to 1 (=100
Columns are ordered by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MissedCleavages(data, title_sub = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MissedCleavages_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', '...' (missed cleavage classes)</p>
</td></tr>
<tr><td><code id="plot_MissedCleavages_+3A_title_sub">title_sub</code></td>
<td>
<p>Plot's subtitle</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A visual threshold line is drawn at 75
</p>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = letters[1:5],
                    MC0 = c(0.8, 0.5, 0.85, 0.2, 0.9),
                    MC1 = c(0.1, 0.4, 0.05, 0.7, 0.0),
                    "MS2+" =  c(0.1, 0.1, 0.1, 0.1, 0.1),
                    check.names = FALSE)
  plot_MissedCleavages(data, "contaminant inclusion unknown")

</code></pre>

<hr>
<h2 id='plot_MS2Decal'>Plot bargraph of oversampled 3D-peaks.</h2><span id='topic+plot_MS2Decal'></span>

<h3>Description</h3>

<p>Per Raw file, at most three n's must be given, i.e.
the fraction of 3D-peaks for n=1, n=2 and n=3(or more).
The fractions must sum to 1 (=100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MS2Decal(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MS2Decal_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'file', 'msErr', 'type'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n = c(100, 130, 50)
  data = data.frame(file = repEach(paste(letters[1:3],"\nLTQ [Da]"), n),
                    msErr = c(rnorm(n[1], 0.5), rnorm(n[2], 0.0), rnorm(n[3], -0.5)),
                    type = c("forward", "decoy")[1+(runif(sum(n))&gt;0.95)])
  plot_MS2Decal(data)

</code></pre>

<hr>
<h2 id='plot_MS2Oversampling'>Plot bargraph of oversampled 3D-peaks.</h2><span id='topic+plot_MS2Oversampling'></span>

<h3>Description</h3>

<p>Per Raw file, at most three n's must be given, i.e.
the fraction of 3D-peaks for n=1, n=2 and n=3(or more).
The fractions must sum to 1 (=100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_MS2Oversampling(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_MS2Oversampling_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'n', 'fraction'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = rep(letters[1:3], each=3),
                    n = 1:3,
                    fraction = c(0.8, 0.1, 0.1, 0.6, 0.3, 0.1, 0.7, 0.25, 0.05))
  plot_MS2Oversampling(data)

</code></pre>

<hr>
<h2 id='plot_peptideMods'>Plot peptide modification frequencies</h2><span id='topic+plot_peptideMods'></span>

<h3>Description</h3>

<p>The input is a data.frame, as obtained from modsToTableByRaw().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_peptideMods(tbl, y_max = NA, show_missing_modification_levels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_peptideMods_+3A_tbl">tbl</code></td>
<td>
<p>A data.frame with 'fc.raw.file', 'modification_names' (can be a factor), and 'Freq' (0-100)</p>
</td></tr>
<tr><td><code id="plot_peptideMods_+3A_y_max">y_max</code></td>
<td>
<p>The upper limit of the y-axis's (==Freq); useful for multiple plots with identical limits; if 'NA' the limit is computed from the given 'tbl'</p>
</td></tr>
<tr><td><code id="plot_peptideMods_+3A_show_missing_modification_levels">show_missing_modification_levels</code></td>
<td>
<p>If 'tbl$modification_names' is a factor and has more (but missing) levels than actually used, should missing values be dropped or assumed as '0' frequency?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file = rep(c("file A", "file B"), each=3),
                   modifications = c("Oxidation (M)",
                   "Unmodified",
                   "Oxidation (M), Acetyl (Protein N-term)",
                   "2 Oxidation (M)", 
                   "Unmodified", 
                   "Unmodified"))
 tbl = modsToTableByRaw(data)
 plot_peptideMods(tbl,show_missing_modification_levels = TRUE)

</code></pre>

<hr>
<h2 id='plot_RatiosPG'>Plot ratios of labeled data (e.g. SILAC) from proteinGroups.txt</h2><span id='topic+plot_RatiosPG'></span>

<h3>Description</h3>

<p>The 'x' values are expected to be log2() transformed already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_RatiosPG(df_ratios, d_range, main_title, main_col, legend_title)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_RatiosPG_+3A_df_ratios">df_ratios</code></td>
<td>
<p>A data.frame with columns 'x', 'y', 'col', 'ltype'</p>
</td></tr>
<tr><td><code id="plot_RatiosPG_+3A_d_range">d_range</code></td>
<td>
<p>X-axis range of plot</p>
</td></tr>
<tr><td><code id="plot_RatiosPG_+3A_main_title">main_title</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="plot_RatiosPG_+3A_main_col">main_col</code></td>
<td>
<p>Color of title</p>
</td></tr>
<tr><td><code id="plot_RatiosPG_+3A_legend_title">legend_title</code></td>
<td>
<p>Legend text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x1 = seq(-3, 3, by = 0.1)
 y1 = dnorm(x1)
 x2 = seq(-5, 1, by = 0.1)
 y2 = dnorm(x2, mean = -1)
 data = data.frame( x = c(x1,x2),
                    y = c(y1,y2), 
                    col = c(rep("ok", length(x1)), rep("shifted", length(x2))), 
                    ltype = c(rep("solid", length(x1)), rep("dotted", length(x2))))
 plot_RatiosPG(data, range(data$x), "Ratio plot", "red", "group")

</code></pre>

<hr>
<h2 id='plot_RTPeakWidth'>Plot RT peak width over time</h2><span id='topic+plot_RTPeakWidth'></span>

<h3>Description</h3>

<p>The input is a data.frame with already averaged counts over binned RT-slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_RTPeakWidth(data, x_lim, y_lim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_RTPeakWidth_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'RT', 'peakWidth'</p>
</td></tr>
<tr><td><code id="plot_RTPeakWidth_+3A_x_lim">x_lim</code></td>
<td>
<p>Plot range of x-axis</p>
</td></tr>
<tr><td><code id="plot_RTPeakWidth_+3A_y_lim">y_lim</code></td>
<td>
<p>Plot range of y-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file = rep(c("file A", "file B", "file C"), each=81),
                   RT = c(20:100), 
                   peakWidth = c(rnorm(81, mean=20), rnorm(81, mean=10), rnorm(81, mean=30)))
 plot_RTPeakWidth(data, c(10, 100), c(0, 40))

</code></pre>

<hr>
<h2 id='plot_ScanIDRate'>Plot line graph of TopN over Retention time.</h2><span id='topic+plot_ScanIDRate'></span>

<h3>Description</h3>

<p>Number of Raw files must be 6 at most. Function will stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ScanIDRate(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ScanIDRate_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'scan.event.number', 'ratio', 'count'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = factor(rep(c("d","a","x"), each=10), levels = c("d","a","x")),
                    scan.event.number = 1:10,
                    ratio = seq(40, 20, length.out=10),
                    count = seq(400, 200, length.out=10))
  plot_ScanIDRate(data)

</code></pre>

<hr>
<h2 id='plot_TIC'>Plot Total Ion Count over time</h2><span id='topic+plot_TIC'></span>

<h3>Description</h3>

<p>The input is a data.frame with already averaged counts over binned RT-slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_TIC(data, x_lim, y_lim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_TIC_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'RT', 'intensity'</p>
</td></tr>
<tr><td><code id="plot_TIC_+3A_x_lim">x_lim</code></td>
<td>
<p>Plot range of x-axis</p>
</td></tr>
<tr><td><code id="plot_TIC_+3A_y_lim">y_lim</code></td>
<td>
<p>Plot range of y-axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data = data.frame(fc.raw.file = rep(c("file A", "file B", "file C"), each=81),
                   RT = c(20:100), 
                   intensity = c(rnorm(81, mean=20), rnorm(81, mean=10), rnorm(81, mean=30)))
 plot_TIC(data, c(10, 100), c(0, 40))

</code></pre>

<hr>
<h2 id='plot_TopN'>Plot line graph of TopN over Retention time.</h2><span id='topic+plot_TopN'></span>

<h3>Description</h3>

<p>Number of Raw files must be 6 at most. Function will stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_TopN(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_TopN_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'scan.event.number', 'n'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = rep(c("d","a","x"), each=10),
                    scan.event.number = 1:10,
                    n = 11:20)
  plot_TopN(data)

</code></pre>

<hr>
<h2 id='plot_TopNoverRT'>Plot line graph of TopN over Retention time.</h2><span id='topic+plot_TopNoverRT'></span>

<h3>Description</h3>

<p>Number of Raw files must be 6 at most. Function will stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_TopNoverRT(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_TopNoverRT_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'rRT', 'topN'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(fc.raw.file = rep(letters[1:3], each=100),
                    rRT = seq(20, 120, length.out = 100),
                    topN = c(round(runif(100, min=3, max=5)),
                             round(runif(100, min=5, max=8)),
                             round(runif(100, min=1, max=3)))
                    )
  plot_TopNoverRT(data)

</code></pre>

<hr>
<h2 id='plot_UncalibratedMSErr'>A boxplot of uncalibrated mass errors for each Raw file.</h2><span id='topic+plot_UncalibratedMSErr'></span>

<h3>Description</h3>

<p>Boxes are optionally colored to indicate that a MQ bug was detected or 
if PTXQC detected a too narrow search window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_UncalibratedMSErr(
  data,
  MQBug_raw_files,
  stats,
  y_lim,
  extra_limit,
  title_sub
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_UncalibratedMSErr_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'uncalibrated.mass.error..ppm.'</p>
</td></tr>
<tr><td><code id="plot_UncalibratedMSErr_+3A_mqbug_raw_files">MQBug_raw_files</code></td>
<td>
<p>List of Raw files with invalid calibration values</p>
</td></tr>
<tr><td><code id="plot_UncalibratedMSErr_+3A_stats">stats</code></td>
<td>
<p>A data.frame with columns 'fc.raw.file', 'sd', 'outOfCal'</p>
</td></tr>
<tr><td><code id="plot_UncalibratedMSErr_+3A_y_lim">y_lim</code></td>
<td>
<p>Range of y-axis</p>
</td></tr>
<tr><td><code id="plot_UncalibratedMSErr_+3A_extra_limit">extra_limit</code></td>
<td>
<p>Position where a v-line is plotted (for visual guidance)</p>
</td></tr>
<tr><td><code id="plot_UncalibratedMSErr_+3A_title_sub">title_sub</code></td>
<td>
<p>Subtitle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>GGplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  n = c(150, 1000, 1000, 1000)
  data = data.frame(fc.raw.file = repEach(letters[4:1], n),
                    uncalibrated.mass.error..ppm. = c(rnorm(n[1], 13, 2.4),
                                                      rnorm(n[2], 1, 0.5),
                                                      rnorm(n[3], 3, 0.7),
                                                      rnorm(n[4], 4.5, 0.8)))
  stats = data.frame(fc.raw.file = letters[4:1],
                     sd_uncal = c(2.4, 0.5, 0.7, 0.8),
                     outOfCal = c(TRUE, FALSE, FALSE, FALSE))           
  plot_UncalibratedMSErr(data, MQBug_raw_files = letters[1],
                         stats, y_lim = c(-20,20), 15, "subtitle")

</code></pre>

<hr>
<h2 id='plotTable'>Plot a table with row names and title</h2><span id='topic+plotTable'></span>

<h3>Description</h3>

<p>Restriction: currently, the footer will be cropped at the table width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTable(
  data,
  title = "",
  footer = "",
  col_names = colnames(data),
  fill = c("grey90", "grey70"),
  col = "black",
  just = "centre"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTable_+3A_data">data</code></td>
<td>
<p>A data.frame with columns as described above</p>
</td></tr>
<tr><td><code id="plotTable_+3A_title">title</code></td>
<td>
<p>Table title</p>
</td></tr>
<tr><td><code id="plotTable_+3A_footer">footer</code></td>
<td>
<p>Footer text</p>
</td></tr>
<tr><td><code id="plotTable_+3A_col_names">col_names</code></td>
<td>
<p>Column names for Table</p>
</td></tr>
<tr><td><code id="plotTable_+3A_fill">fill</code></td>
<td>
<p>Fill pattern (by row)</p>
</td></tr>
<tr><td><code id="plotTable_+3A_col">col</code></td>
<td>
<p>Text color (by column)</p>
</td></tr>
<tr><td><code id="plotTable_+3A_just">just</code></td>
<td>
<p>(ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gTree object with class 'PTXQC_table'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data = data.frame(raw.file = letters[1:4],
                    id.rate = 3:6)
  plotTable(data, 
            title = "Bad files",
            footer = "bottom", 
            col_names = c("first col", "second col"),
            col=c("red", "green"))

</code></pre>

<hr>
<h2 id='plotTableRaw'>Colored table plot.</h2><span id='topic+plotTableRaw'></span>

<h3>Description</h3>

<p>Code taken from http://stackoverflow.com/questions/23819209/change-text-color-for-cells-using-tablegrob-in-r
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTableRaw(data, colours = "black", fill = NA, just = "centre")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTableRaw_+3A_data">data</code></td>
<td>
<p>Table as Data.frame</p>
</td></tr>
<tr><td><code id="plotTableRaw_+3A_colours">colours</code></td>
<td>
<p>Single or set of colours (col-wise)</p>
</td></tr>
<tr><td><code id="plotTableRaw_+3A_fill">fill</code></td>
<td>
<p>Cell fill (row-wise)</p>
</td></tr>
<tr><td><code id="plotTableRaw_+3A_just">just</code></td>
<td>
<p>(ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gTable
</p>

<hr>
<h2 id='pointsPutX'>Distribute a set of points with fixed y-values on a stretch of the x-axis.</h2><span id='topic+pointsPutX'></span>

<h3>Description</h3>

<p>#' 
Usage: 
ggplot(...) + geom_X(...) + pointsPutX(...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsPutX(x_range, x_section, y, col = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointsPutX_+3A_x_range">x_range</code></td>
<td>
<p>[min,max] valid range of x-values</p>
</td></tr>
<tr><td><code id="pointsPutX_+3A_x_section">x_section</code></td>
<td>
<p>[min,max] fraction in which to distribute the values (in [0,1] for min,max, e.g. c(0.03,0.08) for 3-8%)</p>
</td></tr>
<tr><td><code id="pointsPutX_+3A_y">y</code></td>
<td>
<p>Y-values</p>
</td></tr>
<tr><td><code id="pointsPutX_+3A_col">col</code></td>
<td>
<p>Colour of the points (used as argument to aes(colour=))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object with new geom_point
</p>

<hr>
<h2 id='print.PTXQC_table'>helper S3 class, enabling print(some-plot_Table-object)</h2><span id='topic+print.PTXQC_table'></span>

<h3>Description</h3>

<p>helper S3 class, enabling print(some-plot_Table-object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PTXQC_table'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.PTXQC_table_+3A_x">x</code></td>
<td>
<p>Some Grid object to plot</p>
</td></tr>
<tr><td><code id="print.PTXQC_table_+3A_...">...</code></td>
<td>
<p>Further arguments (not used, but required for consistency with other print methods)</p>
</td></tr>
</table>

<hr>
<h2 id='printWithFooter'>Augment a ggplot with footer text</h2><span id='topic+printWithFooter'></span>

<h3>Description</h3>

<p>Augment a ggplot with footer text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printWithFooter(gg_obj, bottom_left = NULL, bottom_right = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printWithFooter_+3A_gg_obj">gg_obj</code></td>
<td>
<p>ggplot2 object to be printed</p>
</td></tr>
<tr><td><code id="printWithFooter_+3A_bottom_left">bottom_left</code></td>
<td>
<p>Footer text for bottom left side</p>
</td></tr>
<tr><td><code id="printWithFooter_+3A_bottom_right">bottom_right</code></td>
<td>
<p>Footer text for bottom right side</p>
</td></tr>
</table>


<h3>Value</h3>

<p>-
</p>

<hr>
<h2 id='QCMetaFilenames'>Define a Singleton class which holds the full raw filenames (+path) and their PSI-MS CV terms for usage in the mzQC metadata</h2><span id='topic+QCMetaFilenames'></span>

<h3>Description</h3>

<p>The internal data is filled using, e.g. 'getMetaFilenames()'
</p>


<h3>Super class</h3>

<p><code><a href="R6P.html#topic+Singleton">R6P::Singleton</a></code> -&gt; <code>QCMetaFilenames</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>data</code></dt><dd><p>Stores the data of the singleton. Set the data once before using the singleton all over the place</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QCMetaFilenames-clone"><code>QCMetaFilenames$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="R6P" data-topic="Singleton" data-id="initialize"><a href='../../R6P/html/Singleton.html#method-Singleton-initialize'><code>R6P::Singleton$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-QCMetaFilenames-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCMetaFilenames$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='qcMetric_MSMSScans_TopNoverRT-class'>Metric for msmsscans.txt, showing TopN over RT.</h2><span id='topic+qcMetric_MSMSScans_TopNoverRT-class'></span><span id='topic+qcMetric_MSMSScans_TopNoverRT'></span>

<h3>Description</h3>

<p>Metric for msmsscans.txt, showing TopN over RT.
</p>

<hr>
<h2 id='qcMetric-class'>Class which can compute plots and generate mzQC output (usually for a single metric).</h2><span id='topic+qcMetric-class'></span><span id='topic+qcMetric'></span>

<h3>Description</h3>

<p>Internally calls the workerFcn() , which computes the actual plots metric scores and supporting data (e.g. mzQC metrics) of the derived class; the resulting data is checked and stored in the members of this class
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcMetric-class_+3A_df">df</code></td>
<td>
<p>The expected data, usually a data frame. If empty, this function will return immediately without failure.</p>
</td></tr>
<tr><td><code id="qcMetric-class_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the workerFcn()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reference class which is instanciated with a metric description and a
worker function (at initialization time, i.e. in the package)
and can produce plots and mzQC values (at runtime, when data is provided) using setData().
</p>
<p>All derived classes need to implement a 'workerFcn()' function, which returns a list with
elements: c(&quot;plots&quot;, &quot;mzQC&quot;, &quot;htmlTable&quot;, &quot;qcScores&quot;, &quot;title&quot;),
where 'plots' is required; all others are optional.
</p>


<h3>Fields</h3>


<dl>
<dt><code>helpText</code></dt><dd><p>Description (lengthy) of the metric and plot elements</p>
</dd>
<dt><code>workerFcn</code></dt><dd><p>Function which generates a result (usually plots). Data is provided using setData().</p>
</dd>
<dt><code>plots</code></dt><dd><p>List of plots (after setData() was called)</p>
</dd>
<dt><code>htmlTable</code></dt><dd><p>A table for display in the HTML report (preferred over a plot in Html mode)</p>
</dd>
<dt><code>qcScores</code></dt><dd><p>Data.frame of scores from a qcMetric (computed within workerFcn())</p>
</dd>
<dt><code>mzQC</code></dt><dd><p>An named list of mzQC MzQCqualityMetric's (named by their fc.raw.file for runQuality or concatenated fc.raw.files for setQualities (e.g. &quot;file 1;file4&quot;)) (valid after setData() was called)</p>
</dd>
<dt><code>qcCat</code></dt><dd><p>QC category (LC, MS, or prep)</p>
</dd>
<dt><code>qcName</code></dt><dd><p>Name of the qcScore in the heatmap</p>
</dd>
<dt><code>orderNr</code></dt><dd><p>Column index during heatmap generation and for the general order of plots</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ggplot2)
dd = data.frame(x=1:10, y=11:20)
a = qcMetric$new(helpText="small help text", 
                 ## arbitrary arguments, matched during setData()
                 workerFcn=function(.self, data, gtitle)
                 {
                   ## usually some code here to produce ggplots
                   pl = lapply(1:2, function(xx) {
                       ggplot(data) +
                         geom_point(aes(x=x*xx,y=y)) +
                         ggtitle(gtitle)
                     })
                     ## add mzQC metric for count of identified clusters
                     template_proteinCount = rmzqc::getQualityMetricTemplate("MS:1002406") 
                     mzqc = lapply(1:3, function(id){
                       out = template_proteinCount$copy();
                       out$value = id;
                       return(out) })
                     names(mzqc) = paste0("file", 1:3);
                   return(list(plots = pl, mzQC = mzqc))
                 }, 
                 qcCat="LC", 
                 qcName="MS/MS Peak shape", 
                 orderNr = 30)
## test some output
a$setData(dd, "my title")
a$plots  ## the raw plots
a$getPlots(TRUE) ## same as above
a$getPlots(FALSE) ## plots without title
a$getTitles()  ## get the titles of the all plots
a$helpText
a$qcName
a$mzQC


</code></pre>

<hr>
<h2 id='qualBestKS'>From a list of vectors, compute all vs. all Kolmogorov-Smirnoff distance statistics (D)</h2><span id='topic+qualBestKS'></span>

<h3>Description</h3>

<p>... and report the row of the matrix which has maximum sum (i.e the best &quot;reference&quot; distribution).
The returned data.frame has as many rows as distributions given and two columns.
The first column 'name' gives the name of the list element, the second column 'ks_best' gives '1-statistic' of the
Kolmogorov-Smirnoff test to the &quot;reference&quot; distribution (which was picked by maximising the sum of 'ks_best').
Thus, the row with a 'ks_best' of 1 is the reference distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualBestKS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualBestKS_+3A_x">x</code></td>
<td>
<p>List of vectors, where each vector holds a distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with ks-test values of the &quot;reference&quot; to all other distributions (see Details)
</p>

<hr>
<h2 id='qualCentered'>Quality metric for 'centeredness' of a distribution around zero.</h2><span id='topic+qualCentered'></span>

<h3>Description</h3>

<p>Ranges between 0 (worst score) and 1 (best score).
A median of zero gives the best score of 1.
The closer the median is to the most extreme value of the distribution, the smaller the score (until reaching 0).
Can be used for calibrated mass errors, as a measure of how well they are centered around 0.
E.g. if the median is 0.1, while the range is [-0.5,0.5], the score will be 0.8 (punishing the 20
If the range of data is asymmetric, e.g. [-1.5,-0.5] and does not include zero, the score cannot reach 1, 
since the median can never be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualCentered(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualCentered_+3A_x">x</code></td>
<td>
<p>Numeric values (e.g. ppm errors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value between [0, 1]
</p>

<hr>
<h2 id='qualCenteredRef'>Quality metric for 'centeredness' of a distribution around zero with a user-supplied range threshold.</h2><span id='topic+qualCenteredRef'></span>

<h3>Description</h3>

<p>Ranges between 0 (worst score) and 1 (best score).
The best score is achieved when the median of 'x' is close to the center of the interval [-tol, tol].
If median of 'x' is close to the border (on either side), the score decreases linearly to zero.
Can be used for uncalibrated mass errors, as a measure of how well they are centered around 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualCenteredRef(x, tol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualCenteredRef_+3A_x">x</code></td>
<td>
<p>Vector of values (hopefully in interval [-tol, tol])</p>
</td></tr>
<tr><td><code id="qualCenteredRef_+3A_tol">tol</code></td>
<td>
<p>Border of interval (must be positive)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA's are removed for all computations.
</p>


<h3>Value</h3>

<p>Value between [0, 1]
</p>

<hr>
<h2 id='qualGaussDev'>Compute probability of Gaussian (mu=m, sd=s) at a position 0, with reference 
to the max obtainable probability of that Gaussian at its center.</h2><span id='topic+qualGaussDev'></span>

<h3>Description</h3>

<p>Measure for centeredness around 0.
Highest score is 1, worst score is 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualGaussDev(mu, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualGaussDev_+3A_mu">mu</code></td>
<td>
<p>Center of Gaussian</p>
</td></tr>
<tr><td><code id="qualGaussDev_+3A_sd">sd</code></td>
<td>
<p>SD of Gaussian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quality, ranging from 0 (bad agreement) to 1 (perfect, i.e. centered at 0)
</p>

<hr>
<h2 id='qualHighest'>Score an empirical density distribution of values, where the best possible distribution is right-skewed.</h2><span id='topic+qualHighest'></span>

<h3>Description</h3>

<p>The score is computed according to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualHighest(x, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualHighest_+3A_x">x</code></td>
<td>
<p>Vector of numeric values (e.g. height of histogram bins)</p>
</td></tr>
<tr><td><code id="qualHighest_+3A_n">N</code></td>
<td>
<p>Length of x (just a precaution currently)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>q = ((N-1) - sum_i( ((N-i-1)*x_i) ) / (N-1)
</p>
<p>Scores range from 0 (worst), to 1 (best).
E.g. c(0,0,0,16) would yield a score of 1.
c(16,0,0,0,0) gives a score of 0.
</p>


<h3>Value</h3>

<p>Quality score in the range of [0,1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'> qualHighest(c(0,0,0,16), 4)   ## 1
 qualHighest(c(16,0,0,0), 4)   ## 0 
 qualHighest(c(1,1,1,1), 4)    ## 0.5
 qualHighest(c(0,16,0,0), 4)   ## 1/3
 
</code></pre>

<hr>
<h2 id='qualLinThresh'>Quality metric with linear response to input, reaching the maximum score at the given threshold.</h2><span id='topic+qualLinThresh'></span>

<h3>Description</h3>

<p>Ranges between 0 (worst score) and 1 (best score).
Useful for performance measures where reaching a certain reference threshold 't'
will be enough to reach 100%.
The input range from [0, t] is scored from 0-100%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualLinThresh(x, t = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualLinThresh_+3A_x">x</code></td>
<td>
<p>Numeric value(s) between [0, inf]</p>
</td></tr>
<tr><td><code id="qualLinThresh_+3A_t">t</code></td>
<td>
<p>Threshold value, which indicates 100%</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value between [0, 1]
</p>

<hr>
<h2 id='qualMedianDist'>Quality metric which measures the absolute distance from median.</h2><span id='topic+qualMedianDist'></span>

<h3>Description</h3>

<p>Ranges between 0 (worst score) and 1 (best score).
Input must be between [0,1].
Deviations from the median of the sample represent the score for each sample point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualMedianDist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualMedianDist_+3A_x">x</code></td>
<td>
<p>A vector numeric values between [0,1]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same size as x, with quality values between [0, 1]
</p>

<hr>
<h2 id='qualUniform'>Compute deviation from uniform distribution</h2><span id='topic+qualUniform'></span>

<h3>Description</h3>

<p>The score ranges between 0 (worst score) and 1 (best score).
Input 'x' is a vector of counts (or probabilities) for equally spaced bins in a histogram.
A uniform distribution (e.g. c(3,3,3) will get a score of 1. The worst possible case (e.g. c(4,0,0)), will get a score of 0,
and a linear increasing function (e.g. c(1,2,3)) will get something in between (0.585 here)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualUniform(x, weight = vector())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualUniform_+3A_x">x</code></td>
<td>
<p>Vector of numeric intensity/count values (e.g. ID's per RT bin); bins are assumed to have equal widths</p>
</td></tr>
<tr><td><code id="qualUniform_+3A_weight">weight</code></td>
<td>
<p>Vector of weights for values in 'x' (same length as 'x').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition, bin values can be weighted (e.g. by their confidence). The total sum of weights is normalized to 1 internally.
</p>
<p>The distance function used is the square root of the absolute difference between a uniform distribution and the input 'x'
(summed for each element of 'x').
This distance is normalized to the worst possible input (e.g. one bin with 100
</p>


<h3>Value</h3>

<p>Value between [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'> stopifnot(qualUniform(c(3,3,3))==1)
 stopifnot(qualUniform(c(4,0,0))==0)         

 ## how 'uniform' is a vector where only a single index has weight?-- answer: very
 stopifnot(qualUniform(c(4,0,0), c(1,0,0))==1)   
 stopifnot(qualUniform(c(4,0,0), c(0,1,0))==1)     
 stopifnot(qualUniform(c(0,4,0))==0)              
 stopifnot(abs(qualUniform(c(3,2,1))-0.58578) &lt; 0.0001)
 stopifnot(abs(qualUniform(c(1,2,3))-0.58578) &lt; 0.0001)
 stopifnot(qualUniform(c(1,2,3), c(0,1,0))==1)   
 stopifnot(abs(qualUniform(c(1,2,3))-0.58578) &lt; 0.0001)
 stopifnot(abs(qualUniform(c(1,2,3), c(0,1,1))- 0.590316) &lt; 0.0001)
 stopifnot(abs(qualUniform(c(2,3), c(1,1))-0.552786) &lt; 0.0001)
 stopifnot(abs(qualUniform(1:120)-0.38661) &lt; 0.0001)
 
</code></pre>

<hr>
<h2 id='read.MQ'>Convenience wrapper for MQDataReader when only a single MQ file should be read
and file mapping need not be stored.</h2><span id='topic+read.MQ'></span>

<h3>Description</h3>

<p>For params, see <code>MQDataReader::readMQ()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.MQ(
  file,
  filter = "",
  type = "pg",
  col_subset = NA,
  add_fs_col = 10,
  LFQ_action = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.MQ_+3A_file">file</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_filter">filter</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_type">type</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_col_subset">col_subset</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_add_fs_col">add_fs_col</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_lfq_action">LFQ_action</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
<tr><td><code id="read.MQ_+3A_...">...</code></td>
<td>
<p>see <code>MQDataReader::readMQ()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code>MQDataReader::readMQ()</code>
</p>

<hr>
<h2 id='renameFile'>Given a vector of (short/long) filenames, translate to the (long/short) version</h2><span id='topic+renameFile'></span>

<h3>Description</h3>

<p>Given a vector of (short/long) filenames, translate to the (long/short) version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameFile(f_names, mapping)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="renameFile_+3A_f_names">f_names</code></td>
<td>
<p>Vector of filenames</p>
</td></tr>
<tr><td><code id="renameFile_+3A_mapping">mapping</code></td>
<td>
<p>A data.frame with from,to columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of translated file names as factor (ordered by mapping!)
</p>

<hr>
<h2 id='repEach'>Repeat each element x_i in X, n_i times.</h2><span id='topic+repEach'></span>

<h3>Description</h3>

<p>Repeat each element x_i in X, n_i times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repEach(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repEach_+3A_x">x</code></td>
<td>
<p>Values to be repeated</p>
</td></tr>
<tr><td><code id="repEach_+3A_n">n</code></td>
<td>
<p>Number of repeat for each x_i (same length as x)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with values from x, n times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  repEach(1:3, 1:3)  ## 1, 2, 2, 3, 3, 3

</code></pre>

<hr>
<h2 id='RSD'>Relative standard deviation (RSD)</h2><span id='topic+RSD'></span>

<h3>Description</h3>

<p>Simply <code><a href="#topic+CV">CV</a></code>*100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSD(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RSD_+3A_x">x</code></td>
<td>
<p>Vector of numeric values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RSD
</p>

<hr>
<h2 id='RTalignmentTree'>Return a tree plot with a possible alignment tree.</h2><span id='topic+RTalignmentTree'></span>

<h3>Description</h3>

<p>This allows the user to judge which Raw files have similar corrected RT's (i.e. where aligned successfully).
If there are clear sub-clusters, it might be worth introducing artifical fractions into MaxQuant,
to avoid ID-transfer between these clusters (use the MBR-Align and MBR-ID-Transfer metrics to support the decision).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RTalignmentTree(df_evd, col_fraction = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RTalignmentTree_+3A_df_evd">df_evd</code></td>
<td>
<p>Evidence table containing calibrated retention times and sequence information.</p>
</td></tr>
<tr><td><code id="RTalignmentTree_+3A_col_fraction">col_fraction</code></td>
<td>
<p>Empty vector or 1-values vector giving the name of the fraction column (if existing)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input contains fractions, leaf nodes will be colored accordingly.
Distinct sub-clusters should have their own color.
If not, MaxQuant's fraction settings should be optimized.
Note that introducing fractions in MaxQuant will naturally lead to a clustering here (it's somewhat circular).
</p>


<h3>Value</h3>

<p>ggplot object containing the correlation tree
</p>

<hr>
<h2 id='scale_x_discrete_reverse'>Inverse the order of items on the x-axis (for discrete scales)</h2><span id='topic+scale_x_discrete_reverse'></span>

<h3>Description</h3>

<p>Inverse the order of items on the x-axis (for discrete scales)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_discrete_reverse(values, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_x_discrete_reverse_+3A_values">values</code></td>
<td>
<p>The vector of values as given to the x aestetic</p>
</td></tr>
<tr><td><code id="scale_x_discrete_reverse_+3A_...">...</code></td>
<td>
<p>Other arguments forwarded to 'scale_y_discrete()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object, concatenatable with '+'
</p>

<hr>
<h2 id='scale_y_discrete_reverse'>Inverse the order of items on the y-axis (for discrete scales)</h2><span id='topic+scale_y_discrete_reverse'></span>

<h3>Description</h3>

<p>Inverse the order of items on the y-axis (for discrete scales)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_discrete_reverse(values, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_y_discrete_reverse_+3A_values">values</code></td>
<td>
<p>The vector of values as given to the y aestetic</p>
</td></tr>
<tr><td><code id="scale_y_discrete_reverse_+3A_...">...</code></td>
<td>
<p>Other arguments forwarded to 'scale_y_discrete()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object, concatenatable with '+'
</p>

<hr>
<h2 id='scale01linear'>Scales a vector of values linearly to [0, 1]
If all input values are equal, returned values are all 0</h2><span id='topic+scale01linear'></span>

<h3>Description</h3>

<p>Scales a vector of values linearly to [0, 1]
If all input values are equal, returned values are all 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale01linear(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale01linear_+3A_x">X</code></td>
<td>
<p>Vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled vector
</p>

<hr>
<h2 id='ScoreInAlignWindow'>Compute the fraction of features per Raw file which have an acceptable RT difference after alignment</h2><span id='topic+ScoreInAlignWindow'></span>

<h3>Description</h3>

<p>Using the result from 'alignmentCheck()', score the features of every Raw file and see if they 
have been properly aligned.
Returned value is between 0 (bad) and 1 (all aligned).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreInAlignWindow(data, allowed.deltaRT = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreInAlignWindow_+3A_data">data</code></td>
<td>
<p>A data.frame with columns 'rtdiff' and 'raw.file'</p>
</td></tr>
<tr><td><code id="ScoreInAlignWindow_+3A_allowed.deltart">allowed.deltaRT</code></td>
<td>
<p>The allowed matching difference (1 minute by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one row for each raw.file and columns 'raw.file' and 'withinRT' (0-1)
</p>

<hr>
<h2 id='shortenStrings'>Shorten a string to a maximum length and indicate shorting by appending '..'</h2><span id='topic+shortenStrings'></span>

<h3>Description</h3>

<p>Some axis labels are sometimes just too long and printing them will either
squeeze the actual plot (ggplot) or make the labels disappear beyond the margins (graphics::plot)
One ad-hoc way of avoiding this is to shorten the names, hoping they are still meaningful to the viewer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortenStrings(x, max_len = 20, verbose = TRUE, allow_duplicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shortenStrings_+3A_x">x</code></td>
<td>
<p>Vector of input strings</p>
</td></tr>
<tr><td><code id="shortenStrings_+3A_max_len">max_len</code></td>
<td>
<p>Maximum length allowed</p>
</td></tr>
<tr><td><code id="shortenStrings_+3A_verbose">verbose</code></td>
<td>
<p>Print which strings were shortened</p>
</td></tr>
<tr><td><code id="shortenStrings_+3A_allow_duplicates">allow_duplicates</code></td>
<td>
<p>If shortened strings are not discernible any longer, consider the short version valid (not the default), otherwise (default) return the full string (&ndash;&gt; no-op)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be applied AFTER you tried more gentle methods, such as <code><a href="#topic+delLCP">delLCP</a></code> or <code><a href="#topic+simplifyNames">simplifyNames</a></code>.
</p>


<h3>Value</h3>

<p>A vector of shortened strings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delLCP">delLCP</a></code>, <code><a href="#topic+simplifyNames">simplifyNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r = shortenStrings(c("gamg_101", "gamg_101230100451", "jurkat_06_100731121305", "jurkat_06_1"))
all(r == c("gamg_101", "gamg_101230100..", "jurkat_06_1007..", "jurkat_06_1"))

</code></pre>

<hr>
<h2 id='simplifyNames'>Removes common substrings (infixes) in a set of strings.</h2><span id='topic+simplifyNames'></span>

<h3>Description</h3>

<p>Usually handy for plots, where condition names should be as concise as possible.
E.g. you do not want names like 
'TK20130501_H2M1_010_IMU008_CISPLA_E3_R1.raw' and 
'TK20130501_H2M1_026_IMU008_CISPLA_E7_R2.raw' 
but rather 'TK.._010_I.._E3_R1.raw' and
'TK.._026_I.._E7_R2.raw'
</p>
<p>If multiple such substrings exist, the algorithm will remove the longest first and iterate
a number of times (two by default) to find the second/third etc longest common substring.
Each substring must fulfill a minimum length requirement - if its shorter, its not considered worth removing
and the iteration is aborted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyNames(
  strings,
  infix_iterations = 2,
  min_LCS_length = 7,
  min_out_length = 7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplifyNames_+3A_strings">strings</code></td>
<td>
<p>A vector of strings which are to be shortened</p>
</td></tr>
<tr><td><code id="simplifyNames_+3A_infix_iterations">infix_iterations</code></td>
<td>
<p>Number of successive rounds of substring removal</p>
</td></tr>
<tr><td><code id="simplifyNames_+3A_min_lcs_length">min_LCS_length</code></td>
<td>
<p>Minimum length of the longest common substring (default:7, minimum: 6)</p>
</td></tr>
<tr><td><code id="simplifyNames_+3A_min_out_length">min_out_length</code></td>
<td>
<p>Minimum length of shortest element of output (no shortening will be done which causes output to be shorter than this threshold)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of shortened strings, with the same length as the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(PTXQC)
simplifyNames(c('TK20130501_H2M1_010_IMU008_CISPLA_E3_R1.raw',
                'TK20130501_H2M1_026_IMU008_CISPLA_E7_R2.raw'), infix_iterations = 2)
# --&gt; "TK.._010_I.._E3_R1.raw","TK.._026_I.._E7_R2.raw"

try(simplifyNames(c("bla", "foo"), min_LCS_length=5))
# --&gt; error, since min_LCS_length must be &gt;=6

</code></pre>

<hr>
<h2 id='supCount'>Compute shortest prefix length which makes all strings in a vector uniquely identifyable.</h2><span id='topic+supCount'></span>

<h3>Description</h3>

<p>If there is no unique prefix (e.g. if a string is contained twice), then the length
of the longest string is returned, i.e. if the return value is used in a call to substr, nothing happens
e.g.  substr(x, 1, supCount(x)) == x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supCount(x, prefix_l = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supCount_+3A_x">x</code></td>
<td>
<p>Vector of strings</p>
</td></tr>
<tr><td><code id="supCount_+3A_prefix_l">prefix_l</code></td>
<td>
<p>Starting prefix length, which is incremented in steps of 1 until all prefixes are unique (or maximum string length is reached)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer with minimal prefix length required
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  supCount(c("abcde...", "abcd...", "abc..."))  ## 5

  x = c("doubled", "doubled", "aLongDummyString")
  all( substr(x, 1, supCount(x)) == x )   
  ## TRUE (no unique prefix due to duplicated entries)

</code></pre>

<hr>
<h2 id='theme_blank'>A blank theme (similar to the deprecated theme_blank())</h2><span id='topic+theme_blank'></span>

<h3>Description</h3>

<p>A blank theme (similar to the deprecated theme_blank())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_blank()
</code></pre>


<h3>Value</h3>

<p>A ggplot2 object, representing an empty theme
</p>

<hr>
<h2 id='thinOut'>Thin out a data.frame by removing rows with similar numerical values in a certain column.</h2><span id='topic+thinOut'></span>

<h3>Description</h3>

<p>All values in the numerical column 'filterColname' are assigned to bins of width 'binsize'.
Only one value per bin is retained. All other rows are removed and the reduced
data frame will all its columns is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinOut(data, filterColname, binsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thinOut_+3A_data">data</code></td>
<td>
<p>The data.frame to be filtered</p>
</td></tr>
<tr><td><code id="thinOut_+3A_filtercolname">filterColname</code></td>
<td>
<p>Name of the filter column as string</p>
</td></tr>
<tr><td><code id="thinOut_+3A_binsize">binsize</code></td>
<td>
<p>Width of a bin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with reduced rows, but identical input columns
</p>

<hr>
<h2 id='thinOutBatch'>Apply 'thinOut' on all subsets of a data.frame, split by a batch column</h2><span id='topic+thinOutBatch'></span>

<h3>Description</h3>

<p>The binsize is computed from the global data range of the filter column by dividing the range
into binCount bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinOutBatch(data, filterColname, batchColname, binCount = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thinOutBatch_+3A_data">data</code></td>
<td>
<p>The data.frame to be split and filtered(thinned)</p>
</td></tr>
<tr><td><code id="thinOutBatch_+3A_filtercolname">filterColname</code></td>
<td>
<p>Name of the filter column as string</p>
</td></tr>
<tr><td><code id="thinOutBatch_+3A_batchcolname">batchColname</code></td>
<td>
<p>Name of the split column as string</p>
</td></tr>
<tr><td><code id="thinOutBatch_+3A_bincount">binCount</code></td>
<td>
<p>Number of bins in the 'filterColname' dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with reduced rows, but identical input columns
</p>

<hr>
<h2 id='wait_for_writable'>Check if a file is writable and blocks an interactive session, waiting for user input.</h2><span id='topic+wait_for_writable'></span>

<h3>Description</h3>

<p>This functions gives the user a chance to make the output file writeable before a write attempt
is actually made by R to avoid having run the whole program again upon write failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait_for_writable(
  filename,
  prompt_text = paste0("The file '", filename,
    "' is not writable. Please close all applications using this file. Press '",
    abort_answer, "' to abort!"),
  abort_answer = "n"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wait_for_writable_+3A_filename">filename</code></td>
<td>
<p>The file to test for writable</p>
</td></tr>
<tr><td><code id="wait_for_writable_+3A_prompt_text">prompt_text</code></td>
<td>
<p>If not writable, show this prompt text to the user</p>
</td></tr>
<tr><td><code id="wait_for_writable_+3A_abort_answer">abort_answer</code></td>
<td>
<p>If the user enters this string into the prompt, this function will stop()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The file will not be overwritten or changed by this function.
</p>


<h3>Value</h3>

<p>TRUE if writable, FALSE if aborted by user or (not-writeable and non-interactive)
</p>

<hr>
<h2 id='YAMLClass-class'>Query a YAML object for a certain parameter.</h2><span id='topic+YAMLClass-class'></span><span id='topic+YAMLClass'></span>

<h3>Description</h3>

<p>If the object has the param, then return it.
If the param is unknown, create it with the given default value and return the default.
</p>


<h3>Fields</h3>


<dl>
<dt><code>yamlObj</code></dt><dd><p>A Yaml object as created by <code><a href="yaml.html#topic+yaml.load">yaml.load</a></code></p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>getYAML(param_name, default, min = NA, max = NA)</code></dt><dd><p>Query this YAML object for a certain parameter and return its value. If it does not exist it is created with a default value.
An optional min/max range can be specified and will be enforced if the value is known (default will be used upon violation).</p>
</dd>
<dt><code>setYAML(param_name, value)</code></dt><dd><p>Set a YAML parameter to a certain value. Overwrites the old value or creates a new entry if hithero unknown.</p>
</dd>
<dt><code>writeYAML(filename)</code></dt><dd><p>Write YAML config (including some documentation) to a YAML file. Returns TRUE on success (always), unless writing the file generates an error.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>    yc = YAMLClass$new(list())
    val = yc$getYAML("cat$subCat", "someDefault")
    val  ## someDefault
    val = yc$setYAML("cat$subCat", "someValue")
    val  ## someValue
    yc$getYAML("cat$subCat", "someDefault") ## still 'someValue' (since its set already)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
