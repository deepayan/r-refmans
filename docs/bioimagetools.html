<!DOCTYPE html><html><head><title>Help for package bioimagetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bioimagetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bwlabel3d'><p>Binary segmentation in 3d</p></a></li>
<li><a href='#cmoments3d'><p>Computes moments from image objects</p></a></li>
<li><a href='#cnnTest'><p>Permutation Test for cross-type nearest neighbor distances</p></a></li>
<li><a href='#crossNN'><p>Compute cross-type nearest neighbor distances</p></a></li>
<li><a href='#distance2border'><p>A function to compute the distance from spots to borders of classes</p></a></li>
<li><a href='#filterImage3d'><p>Apply filter to 3D images</p></a></li>
<li><a href='#folder.choose'><p>Choose a folder interactively</p></a></li>
<li><a href='#img'><p>Display an image stack</p></a></li>
<li><a href='#intensity3D'><p>Intensity of a 3d Dataset or a Model</p></a></li>
<li><a href='#K.cross.3D'><p>K-function cross-type in 3D</p></a></li>
<li><a href='#L.cross.3D'><p>L-function cross-type in 3d</p></a></li>
<li><a href='#mexican.hat.brush'><p>Mexican hat brush</p>
to use with filter2</a></li>
<li><a href='#nearest.neighbour.distribution'><p>Nearest neighbor distribution (D curve)</p></a></li>
<li><a href='#nearestClassDistance'><p>Title Find distance to next neighbour of a specific class</p></a></li>
<li><a href='#nearestClassDistances'><p>Find all distances to next neighbor of all classes</p></a></li>
<li><a href='#outside'><p>Segmentation of the background of 3D images based on classes</p></a></li>
<li><a href='#plotNearestClassDistances'><p>Title Plot nearest class distances</p></a></li>
<li><a href='#readBMP'><p>Read bitmap files</p></a></li>
<li><a href='#readClassTIF'><p>Read TIF file with classes</p></a></li>
<li><a href='#readTIF'><p>Read tif stacks</p></a></li>
<li><a href='#segment'><p>Segmentation of 3D images using EM algorithms</p></a></li>
<li><a href='#segment.outside'><p>Segmentation of the background of 3D images based on automatic threshold</p></a></li>
<li><a href='#spots'><p>Find spots based on threshold and minimum total intensity</p></a></li>
<li><a href='#standardize'><p>Standardize images</p></a></li>
<li><a href='#table.n'><p>Cross Tabulation and Table Creation (including empty classes)</p></a></li>
<li><a href='#testColoc'><p>Permutation Test for cross-type nearest neighbor distances</p></a></li>
<li><a href='#writeTIF'><p>Writes image stack into a TIFF file.</p>
Wrapper for writeTIFF</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Microscopy Imaging</td>
</tr>
<tr>
<td>Author:</td>
<td>Volker Schmid [aut, cre],
  Priyanka Kukreja [ctb],
  Fabian Scheipl [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Volker Schmid &lt;stats@volkerschmid.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, tiff, stats, grDevices, utils, EBImage, httr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>tiff fftw libcurl openssl</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for 3D imaging, mostly for biology/microscopy. 
    Read and write TIFF stacks. Functions for segmentation, filtering and analyzing 3D point patterns.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bioimaginggroup.github.io/bioimagetools/">https://bioimaginggroup.github.io/bioimagetools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bioimaginggroup/bioimagetools/issues">https://github.com/bioimaginggroup/bioimagetools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, abind, fs, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-28 10:06:27 UTC; schmid</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-28 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bwlabel3d'>Binary segmentation in 3d</h2><span id='topic+bwlabel3d'></span>

<h3>Description</h3>

<p>Binary segmentation in 3d
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwlabel3d(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bwlabel3d_+3A_img">img</code></td>
<td>
<p>A 3d array. x is considered as a binary image, whose pixels of value 0 are considered as background ones and other pixels as foreground ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grayscale 3d array, containing the labeled version of x.
</p>


<h3>Author(s)</h3>

<p>Fabian Scheipl, Volker Schmid
</p>

<hr>
<h2 id='cmoments3d'>Computes moments from image objects</h2><span id='topic+cmoments3d'></span>

<h3>Description</h3>

<p>Computes intensity-weighted centers of objects and their mass (sum of intensities) and size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmoments3d(mask, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmoments3d_+3A_mask">mask</code></td>
<td>
<p>a labeled stack as returned from bwlabel3d</p>
</td></tr>
<tr><td><code id="cmoments3d_+3A_ref">ref</code></td>
<td>
<p>the original image stack</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the moments of the objects in the stack
</p>


<h3>Author(s)</h3>

<p>Volker Schmid
</p>

<hr>
<h2 id='cnnTest'>Permutation Test for cross-type nearest neighbor distances</h2><span id='topic+cnnTest'></span>

<h3>Description</h3>

<p>Permutation Test for cross-type nearest neighbor distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnnTest(
  dist,
  n1,
  n2,
  w = rep(1, n1 + n2),
  B = 999,
  alternative = "less",
  returnSample = TRUE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnnTest_+3A_dist">dist</code></td>
<td>
<p>a distance matrix, the upper n1 x n1 part contains distances between objects of type 1
the lower n2 x n2 part contains distances between objects of type 2</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_n1">n1</code></td>
<td>
<p>numbers of objects of type 1</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_n2">n2</code></td>
<td>
<p>numbers of objects of type 2</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_w">w</code></td>
<td>
<p>(optional) weights of the objects (length n1+n2)</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_b">B</code></td>
<td>
<p>number of permutations to generate</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis (&quot;less&quot; to test H0:Colocalization )</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_returnsample">returnSample</code></td>
<td>
<p>return sampled null distribution</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Should we use parallel computing?</p>
</td></tr>
<tr><td><code id="cnnTest_+3A_...">...</code></td>
<td>
<p>additional arguments for mclapply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the p.value, the observed weighted mean of the cNN-distances, alternative and (if returnSample) the simulated null dist
</p>


<h3>Author(s)</h3>

<p>Fabian Scheipl
</p>

<hr>
<h2 id='crossNN'>Compute cross-type nearest neighbor distances</h2><span id='topic+crossNN'></span>

<h3>Description</h3>

<p>Compute cross-type nearest neighbor distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossNN(dist, n1, n2, w = rep(1, n1 + n2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossNN_+3A_dist">dist</code></td>
<td>
<p>a distance matrix, the upper n1 x n1 part contains distances between objects of type 1
the lower n2 x n2 part contains distances between objects of type 2</p>
</td></tr>
<tr><td><code id="crossNN_+3A_n1">n1</code></td>
<td>
<p>numbers of objects of type 1</p>
</td></tr>
<tr><td><code id="crossNN_+3A_n2">n2</code></td>
<td>
<p>numbers of objects of type 2</p>
</td></tr>
<tr><td><code id="crossNN_+3A_w">w</code></td>
<td>
<p>optional weights of the objects (length n1+n2), defaults to equal weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (n1+n2) x 2 matrix with the cross-type nearest neighbor distances and 
weights given as the sum of the weights of the involved objects
</p>


<h3>Author(s)</h3>

<p>Fabian Scheipl
</p>

<hr>
<h2 id='distance2border'>A function to compute the distance from spots to borders of classes</h2><span id='topic+distance2border'></span>

<h3>Description</h3>

<p>A function to compute the distance from spots to borders of classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance2border(
  points,
  img.classes,
  x.microns,
  y.microns,
  z.microns,
  class1,
  class2 = NULL,
  mask = array(TRUE, dim(img.classes)),
  voxel = FALSE,
  hist = FALSE,
  main = "Minimal distance to border",
  xlab = "Distance in Microns",
  xlim = c(-0.3, 0.3),
  n = 20,
  stats = TRUE,
  file = NULL,
  silent = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance2border_+3A_points">points</code></td>
<td>
<p>Data frame containing the coordinates of points in microns as X-, Y-, and Z-variables.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_img.classes">img.classes</code></td>
<td>
<p>3D array (or image) of classes for each voxel.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_x.microns">x.microns</code></td>
<td>
<p>Size of image in x-direction in microns.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_y.microns">y.microns</code></td>
<td>
<p>Size of image in y-direction in microns.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_z.microns">z.microns</code></td>
<td>
<p>Size of image in z-direction in microns.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_class1">class1</code></td>
<td>
<p>Which class is the reference class. If is.null(class2), the function computes the distance of points to the border of class (in img.classes).</p>
</td></tr>
<tr><td><code id="distance2border_+3A_class2">class2</code></td>
<td>
<p>Which class is the second reference class. If not is.null(class2), the function computes the distance of points from the border between classes class1 and class2. Default: class2=NULL.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_mask">mask</code></td>
<td>
<p>Array of mask. Needs to have same dimension as img.classes. Only voxels with mask[i,j,k]==TRUE are used. Default: array(TRUE,dim(img.classes))</p>
</td></tr>
<tr><td><code id="distance2border_+3A_voxel">voxel</code></td>
<td>
<p>Logical. If TRUE, points coordinates are given as voxels rather than in microns.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_hist">hist</code></td>
<td>
<p>Automatically plot histogram using hist() function. Default: FALSE.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_main">main</code></td>
<td>
<p>If (hist) title of histogram. Default: &quot;Minimal distance to border&quot;.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_xlab">xlab</code></td>
<td>
<p>If (hist) description of x axis. Default: &quot;Distance in Microns&quot;.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_xlim">xlim</code></td>
<td>
<p>If (hist) vector of range of x axis (in microns). Default: c(-.3,.3)</p>
</td></tr>
<tr><td><code id="distance2border_+3A_n">n</code></td>
<td>
<p>If (hist) number of bins used in hist(). Default: 20.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_stats">stats</code></td>
<td>
<p>If (hist) write statistics into plot. Default: TRUE.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_file">file</code></td>
<td>
<p>If (hist) the file name of the produced png. If NULL, the histogram is plotted to the standard device. Default: NULL.</p>
</td></tr>
<tr><td><code id="distance2border_+3A_silent">silent</code></td>
<td>
<p>if TRUE, function remains silent during running time</p>
</td></tr>
<tr><td><code id="distance2border_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Can we use parallel computing?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the distances from points to the border of a class or the border between two classes. For the latter, only points in these two classes are used.
</p>


<h3>Value</h3>

<p>The function returns a vector with distances. Negative values correspond to points lying in class1.
</p>


<h3>Note</h3>

<p>Warning: So far no consistency check for arguments is done. E.g., distance2border(randompoints,img.classes=array(1,c(100,100,2)),3,3,1,class1=2) will fail with some cryptic error message (because class1 &gt; max(img.classes)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#simulate random data
randompoints&lt;-data.frame("X"=runif(100,0,3),"Y"=runif(100,0,3),"Z"=runif(100,0,.5))
# coordinates in microns!
plot(randompoints$X,randompoints$Y,xlim=c(0,3),ylim=c(0,3),pch=19)

# points in a circle
circlepoints&lt;-read.table(system.file("extdata","kreispunkte.table",
                               package="bioimagetools"),header=TRUE)
plot(circlepoints$X,circlepoints$Y,xlim=c(0,3),ylim=c(0,3),pch=19)

# a circle like image
img&lt;-readTIF(system.file("extdata","kringel.tif",package="bioimagetools"))
img&lt;-array(img,dim(img)) # save as array for easier handling
img(img, z=1)

#and a mask
mask&lt;-readTIF(system.file("extdata","amask.tif",package="bioimagetools"))
img(mask, z=1, col="greyinverted")

xy.microns &lt;- 3 # size in x and y direction (microns)
z.microns &lt;- 0.5 # size in z direction (microns)

# distance from points to class 
d1&lt;-distance2border(randompoints, img, xy.microns, xy.microns, z.microns, class1=1,hist=TRUE)
d2&lt;-distance2border(circlepoints, img, xy.microns, xy.microns, z.microns, class1=1,hist=FALSE)
plot(density(d2),type="l")
lines(c(0,0),c(0,10),lty=3)
lines(density(d1),col="blue")

# use mask, should give some small changes
d3&lt;-distance2border(circlepoints, img, xy.microns, xy.microns, z.microns, 
                                                class1=1,mask=mask,hist=FALSE)
plot(density(d2),type="l")
lines(c(0,0),c(0,10),lty=3)
lines(density(d3),col="blue")

# distance from border between classes
anotherimg&lt;-img+mask
image(seq(0,3,length=300),seq(0,3,length=300),anotherimg[,,1])
points(circlepoints,pch=19)
d4&lt;-distance2border(circlepoints, anotherimg, xy.microns, xy.microns, z.microns, 
                                                               class1=1,class2=2)
plot(density(d4),lwd=2)

# this should give the same answer
d5&lt;-distance2border(circlepoints, anotherimg, xy.microns, xy.microns, z.microns, 
                                                                class1=2,class2=1)
lines(density(-d5),lty=3,col="blue",lwd=1.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='filterImage3d'>Apply filter to 3D images</h2><span id='topic+filterImage3d'></span>

<h3>Description</h3>

<p>A filter is applied to a 3D array representing an image. So far only variance filters are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterImage3d(img, filter = "var", window, z.scale = 1, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterImage3d_+3A_img">img</code></td>
<td>
<p>is a 3d array representing an image.</p>
</td></tr>
<tr><td><code id="filterImage3d_+3A_filter">filter</code></td>
<td>
<p>is the filter to be applied. Options: var: Variance filter.</p>
</td></tr>
<tr><td><code id="filterImage3d_+3A_window">window</code></td>
<td>
<p>half size of window; i.e. window=1 uses a window of 3 voxels in each direction.</p>
</td></tr>
<tr><td><code id="filterImage3d_+3A_z.scale">z.scale</code></td>
<td>
<p>ratio of voxel dimension in x/y direction and z direction.</p>
</td></tr>
<tr><td><code id="filterImage3d_+3A_silent">silent</code></td>
<td>
<p>Logical. If FALSE, information on progress will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multi-dimensional array of filtered image data.
</p>

<hr>
<h2 id='folder.choose'>Choose a folder interactively</h2><span id='topic+folder.choose'></span>

<h3>Description</h3>

<p>Choose a folder interactively by choosing a file in that folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folder.choose()
</code></pre>


<h3>Value</h3>

<p>A character vector of length one giving the folder path.
</p>

<hr>
<h2 id='img'>Display an image stack</h2><span id='topic+img'></span>

<h3>Description</h3>

<p>Display an image stack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img(
  x,
  z = NULL,
  ch = NULL,
  mask = NULL,
  col = "grey",
  low = NULL,
  up = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="img_+3A_x">x</code></td>
<td>
<p>Image, 2D or 3D Matrix</p>
</td></tr>
<tr><td><code id="img_+3A_z">z</code></td>
<td>
<p>slice to show, default: NULL, expects x to be 2d or 2d+channels</p>
</td></tr>
<tr><td><code id="img_+3A_ch">ch</code></td>
<td>
<p>channel. Default: NULL, either only one channel, rgb or channel will be assumed from col</p>
</td></tr>
<tr><td><code id="img_+3A_mask">mask</code></td>
<td>
<p>mask for image, voxel outside the mask will be transparent (default: NULL, no mask)</p>
</td></tr>
<tr><td><code id="img_+3A_col">col</code></td>
<td>
<p>Color, either a character (&quot;grey&quot; or &quot;gray&quot;, &quot;greyinvert&quot; or &quot;grayinvert&quot;, &quot;red&quot; (&quot;r&quot;), &quot;green&quot; (&quot;g&quot;) or &quot;blue&quot; (&quot;b&quot;), rgb&quot; for 3D matrices),
a vector of character with hex rgb values or a function.</p>
</td></tr>
<tr><td><code id="img_+3A_low">low</code></td>
<td>
<p>minimal value of shown intensity. Default: NULL: use min(x, na.rm=TRUE).</p>
</td></tr>
<tr><td><code id="img_+3A_up">up</code></td>
<td>
<p>maximal value of shown intensity. Default: NULL: use max(x, na.rm=TRUE).</p>
</td></tr>
<tr><td><code id="img_+3A_...">...</code></td>
<td>
<p>other parameters for graphics::image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return
</p>

<hr>
<h2 id='intensity3D'>Intensity of a 3d Dataset or a Model</h2><span id='topic+intensity3D'></span>

<h3>Description</h3>

<p>Computing the intensity of a 3d point pattern using kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intensity3D(X, Y, Z, bw = NULL, psz = 25, kernel = "Square")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity3D_+3A_x">X</code></td>
<td>
<p>X coordinate</p>
</td></tr>
<tr><td><code id="intensity3D_+3A_y">Y</code></td>
<td>
<p>Y coordinate</p>
</td></tr>
<tr><td><code id="intensity3D_+3A_z">Z</code></td>
<td>
<p>Z coordinate</p>
</td></tr>
<tr><td><code id="intensity3D_+3A_bw">bw</code></td>
<td>
<p>bandwidth</p>
</td></tr>
<tr><td><code id="intensity3D_+3A_psz">psz</code></td>
<td>
<p>pointsize used for discretization (large: fast, but not precise)</p>
</td></tr>
<tr><td><code id="intensity3D_+3A_kernel">kernel</code></td>
<td>
<p>&quot;Square&quot; or &quot;Uniform&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3d Array
</p>

<hr>
<h2 id='K.cross.3D'>K-function cross-type in 3D</h2><span id='topic+K.cross.3D'></span>

<h3>Description</h3>

<p>Calculates an estimate of the cross-type K-function for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K.cross.3D(
  X,
  Y,
  Z,
  X2,
  Y2,
  Z2,
  psz = 25,
  width = 1,
  intensity = NULL,
  intensity2 = NULL,
  parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K.cross.3D_+3A_x">X</code></td>
<td>
<p>X coordinate of first observed point pattern in microns.</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_y">Y</code></td>
<td>
<p>Y coordinate</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_z">Z</code></td>
<td>
<p>Z coordinate</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_x2">X2</code></td>
<td>
<p>X coordinate of second observed point pattern</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_y2">Y2</code></td>
<td>
<p>Y coordinate</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_z2">Z2</code></td>
<td>
<p>Z coordinate</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_psz">psz</code></td>
<td>
<p>pointsize used for discretization. Smaller values are more precise, but need more computation time.</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_width">width</code></td>
<td>
<p>maximum distance</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_intensity">intensity</code></td>
<td>
<p>intensity of first pattern. Only if </p>
<p style="text-align: center;"><code class="reqn">\lambda(s)!=\lambda</code>
</p>
<p>.</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_intensity2">intensity2</code></td>
<td>
<p>intensity of second pattern</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Can we use parallel computing?</p>
</td></tr>
<tr><td><code id="K.cross.3D_+3A_verbose">verbose</code></td>
<td>
<p>Plot verbose information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of breaks and counts.
</p>

<hr>
<h2 id='L.cross.3D'>L-function cross-type in 3d</h2><span id='topic+L.cross.3D'></span>

<h3>Description</h3>

<p>Calculates an estimate of the cross-type L-function for a multitype point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L.cross.3D(
  X,
  Y,
  Z,
  X2,
  Y2,
  Z2,
  psz = 25,
  width = 1,
  intensity = NULL,
  intensity2 = NULL,
  parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L.cross.3D_+3A_x">X</code></td>
<td>
<p>X coordinate of first observed point pattern in microns.</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_y">Y</code></td>
<td>
<p>Y coordinate</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_z">Z</code></td>
<td>
<p>Z coordinate</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_x2">X2</code></td>
<td>
<p>X coordinate of second observed point pattern</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_y2">Y2</code></td>
<td>
<p>Y coordinate</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_z2">Z2</code></td>
<td>
<p>Z coordinate</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_psz">psz</code></td>
<td>
<p>pointsize used for discretization. Smaller values are more precise, but need more computation time.</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_width">width</code></td>
<td>
<p>maximum distance</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_intensity">intensity</code></td>
<td>
<p>intensity of first pattern. Only if </p>
<p style="text-align: center;"><code class="reqn">\lambda(s)!=\lambda</code>
</p>
<p>.</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_intensity2">intensity2</code></td>
<td>
<p>intensity of second pattern</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Can we use parallel computing?</p>
</td></tr>
<tr><td><code id="L.cross.3D_+3A_verbose">verbose</code></td>
<td>
<p>Plot verbose information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of breaks and counts.
</p>

<hr>
<h2 id='mexican.hat.brush'>Mexican hat brush
to use with filter2</h2><span id='topic+mexican.hat.brush'></span>

<h3>Description</h3>

<p>Mexican hat brush
to use with filter2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexican.hat.brush(n = 7, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mexican.hat.brush_+3A_n">n</code></td>
<td>
<p>size of brush</p>
</td></tr>
<tr><td><code id="mexican.hat.brush_+3A_sigma2">sigma2</code></td>
<td>
<p>standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>brush
</p>

<hr>
<h2 id='nearest.neighbour.distribution'>Nearest neighbor distribution (D curve)</h2><span id='topic+nearest.neighbour.distribution'></span>

<h3>Description</h3>

<p>Nearest neighbor distribution (D curve)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest.neighbour.distribution(
  X,
  Y,
  Z,
  X2 = X,
  Y2 = Y,
  Z2 = Z,
  same = TRUE,
  psz = 25,
  main = "Nearest neighbour distribution",
  file = NULL,
  return = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest.neighbour.distribution_+3A_x">X</code></td>
<td>
<p>X coordinates of point pattern 1</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_y">Y</code></td>
<td>
<p>Y coordinates of point pattern 1</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_z">Z</code></td>
<td>
<p>Z coordinates of point pattern 1</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_x2">X2</code></td>
<td>
<p>X coordinates of point pattern 2</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_y2">Y2</code></td>
<td>
<p>Y coordinates of point pattern 2</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_z2">Z2</code></td>
<td>
<p>Z coordinates of point pattern 2</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_same">same</code></td>
<td>
<p>binary, FALSE for cross D curve</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_psz">psz</code></td>
<td>
<p>pointsize for discretization</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_main">main</code></td>
<td>
<p>Title for graphic</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_file">file</code></td>
<td>
<p>File name for PNG file. If NULL, plots to standard device.</p>
</td></tr>
<tr><td><code id="nearest.neighbour.distribution_+3A_return">return</code></td>
<td>
<p>Logical. Return histogram?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>histogram of nearest neighbors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-read.csv(system.file("extdata","cell.csv",package="bioimagetools")) 
nearest.neighbour.distribution(p$X,p$Y,p$Z)
</code></pre>

<hr>
<h2 id='nearestClassDistance'>Title Find distance to next neighbour of a specific class</h2><span id='topic+nearestClassDistance'></span>

<h3>Description</h3>

<p>Title Find distance to next neighbour of a specific class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestClassDistance(coord, img, class, voxelsize, step = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestClassDistance_+3A_coord">coord</code></td>
<td>
<p>coordinate of relevant voxel</p>
</td></tr>
<tr><td><code id="nearestClassDistance_+3A_img">img</code></td>
<td>
<p>image array of classes</p>
</td></tr>
<tr><td><code id="nearestClassDistance_+3A_class">class</code></td>
<td>
<p>class to find</p>
</td></tr>
<tr><td><code id="nearestClassDistance_+3A_voxelsize">voxelsize</code></td>
<td>
<p>vector of length three. size of voxel in X-/Y-/Z-direction</p>
</td></tr>
<tr><td><code id="nearestClassDistance_+3A_step">step</code></td>
<td>
<p>size of window to start with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance to nearest voxel of class &quot;class&quot;
</p>

<hr>
<h2 id='nearestClassDistances'>Find all distances to next neighbor of all classes</h2><span id='topic+nearestClassDistances'></span>

<h3>Description</h3>

<p>Find all distances to next neighbor of all classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestClassDistances(
  img,
  voxelsize = NULL,
  size = NULL,
  classes = 7,
  maxdist = NULL,
  silent = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestClassDistances_+3A_img">img</code></td>
<td>
<p>Image array of classes</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_voxelsize">voxelsize</code></td>
<td>
<p>Real size of voxels in microns.</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_size">size</code></td>
<td>
<p>Real size of image in microns. Either size or voxelsize must be given.</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_classes">classes</code></td>
<td>
<p>Number of classes</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_maxdist">maxdist</code></td>
<td>
<p>Maximum distance to consider</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_silent">silent</code></td>
<td>
<p>Remain silent?</p>
</td></tr>
<tr><td><code id="nearestClassDistances_+3A_cores">cores</code></td>
<td>
<p>Number of cores available for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with distances
</p>

<hr>
<h2 id='outside'>Segmentation of the background of 3D images based on classes</h2><span id='topic+outside'></span>

<h3>Description</h3>

<p>Segmentation of the background of 3D images based on classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outside(img, what, blobsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outside_+3A_img">img</code></td>
<td>
<p>is a 3d array representing an image.</p>
</td></tr>
<tr><td><code id="outside_+3A_what">what</code></td>
<td>
<p>is an integer of the class of the background.</p>
</td></tr>
<tr><td><code id="outside_+3A_blobsize">blobsize</code></td>
<td>
<p>is an integer, representing the minimal diameter for bridges from the outside. E.g., a blobsize=3 allows for holes of size 2*(blobsize-1)=4 in the edge of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary 3d array: 1 outside the object, 0 inside the object
</p>

<hr>
<h2 id='plotNearestClassDistances'>Title Plot nearest class distances</h2><span id='topic+plotNearestClassDistances'></span>

<h3>Description</h3>

<p>Title Plot nearest class distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNearestClassDistances(
  distances,
  method,
  classes = length(distances),
  ylim = c(0, 1),
  qu = 0.01,
  mfrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNearestClassDistances_+3A_distances">distances</code></td>
<td>
<p>list of list with distances as produced by nearestClassDistances()</p>
</td></tr>
<tr><td><code id="plotNearestClassDistances_+3A_method">method</code></td>
<td>
<p>&quot;boxplot&quot;, &quot;min&quot; or &quot;quantile&quot;</p>
</td></tr>
<tr><td><code id="plotNearestClassDistances_+3A_classes">classes</code></td>
<td>
<p>number of classes, default=7</p>
</td></tr>
<tr><td><code id="plotNearestClassDistances_+3A_ylim">ylim</code></td>
<td>
<p>limits for distances, default=c(0,1)</p>
</td></tr>
<tr><td><code id="plotNearestClassDistances_+3A_qu">qu</code></td>
<td>
<p>quantile for method=&quot;quantile&quot;; default 0.01</p>
</td></tr>
<tr><td><code id="plotNearestClassDistances_+3A_mfrow">mfrow</code></td>
<td>
<p>mfrow option forwarded to par; default NULL, computes some optimal values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots
</p>

<hr>
<h2 id='readBMP'>Read bitmap files</h2><span id='topic+readBMP'></span>

<h3>Description</h3>

<p>Read 2D grey-value BMP files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBMP(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readBMP_+3A_file">file</code></td>
<td>
<p>A character vector of file names or URLs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with BMP data as integer.
</p>


<h3>Author(s)</h3>

<p>Volker J. Schmid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bi&lt;-readBMP(system.file("extdata/V.bmp",package="bioimagetools"))
image(bi,col=grey(seq(1,0,length=100)))
</code></pre>

<hr>
<h2 id='readClassTIF'>Read TIF file with classes</h2><span id='topic+readClassTIF'></span>

<h3>Description</h3>

<p>Read TIF file with classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readClassTIF(file, n = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readClassTIF_+3A_file">file</code></td>
<td>
<p>file</p>
</td></tr>
<tr><td><code id="readClassTIF_+3A_n">n</code></td>
<td>
<p>number of classes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>

<hr>
<h2 id='readTIF'>Read tif stacks</h2><span id='topic+readTIF'></span>

<h3>Description</h3>

<p>Read tif stacks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTIF(file = file.choose(), native = FALSE, as.is = FALSE, channels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTIF_+3A_file">file</code></td>
<td>
<p>Name of the file to read from. Can also be an URL.</p>
</td></tr>
<tr><td><code id="readTIF_+3A_native">native</code></td>
<td>
<p>determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting).</p>
</td></tr>
<tr><td><code id="readTIF_+3A_as.is">as.is</code></td>
<td>
<p>attempt to return original values without re-scaling where possible</p>
</td></tr>
<tr><td><code id="readTIF_+3A_channels">channels</code></td>
<td>
<p>number of channels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3d or 4d array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kringel &lt;- readTIF(system.file("extdata","kringel.tif",package="bioimagetools"))
img(kringel)

</code></pre>

<hr>
<h2 id='segment'>Segmentation of 3D images using EM algorithms</h2><span id='topic+segment'></span>

<h3>Description</h3>

<p>Segmentation of 3D images using EM algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(
  img,
  nclust,
  beta,
  z.scale = 0,
  method = "cem",
  varfixed = TRUE,
  maxit = 30,
  mask = array(TRUE, dim(img)),
  priormu = rep(NA, nclust),
  priormusd = rep(NULL, nclust),
  min.eps = 10^{
     -7
 },
  inforce.nclust = FALSE,
  start = NULL,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment_+3A_img">img</code></td>
<td>
<p>is a 3d array representing an image.</p>
</td></tr>
<tr><td><code id="segment_+3A_nclust">nclust</code></td>
<td>
<p>is the number of clusters/classes to be segmented.</p>
</td></tr>
<tr><td><code id="segment_+3A_beta">beta</code></td>
<td>
<p>is a matrix of size nclust x nclust, representing the prior weight of classes neighboring each other.</p>
</td></tr>
<tr><td><code id="segment_+3A_z.scale">z.scale</code></td>
<td>
<p>ratio of voxel dimension in x/y direction and z direction. Will be multiplied on beta for neighboring voxel in z direction.</p>
</td></tr>
<tr><td><code id="segment_+3A_method">method</code></td>
<td>
<p>only &quot;cem&quot; classification EM algorithm implemented.</p>
</td></tr>
<tr><td><code id="segment_+3A_varfixed">varfixed</code></td>
<td>
<p>is a logical variable. If TRUE, the variance is equal in each class.</p>
</td></tr>
<tr><td><code id="segment_+3A_maxit">maxit</code></td>
<td>
<p>is the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="segment_+3A_mask">mask</code></td>
<td>
<p>is a logical array, representing the voxels to be used in the segmentation.</p>
</td></tr>
<tr><td><code id="segment_+3A_priormu">priormu</code></td>
<td>
<p>is a vector with mean of the normal prior of the expected values of all classes. Default is NA, which represents no prior assumption.</p>
</td></tr>
<tr><td><code id="segment_+3A_priormusd">priormusd</code></td>
<td>
<p>is a vector with standard deviations of the normal prior of the expected values of all classes.</p>
</td></tr>
<tr><td><code id="segment_+3A_min.eps">min.eps</code></td>
<td>
<p>stop criterion. Minimal change in sum of squared estimate of mean in order to stop.</p>
</td></tr>
<tr><td><code id="segment_+3A_inforce.nclust">inforce.nclust</code></td>
<td>
<p>if TRUE enforces number of clusters to be nclust. Otherwise classes might be removed during algorithm.</p>
</td></tr>
<tr><td><code id="segment_+3A_start">start</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="segment_+3A_silent">silent</code></td>
<td>
<p>if TRUE, function remains silent during running time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with &quot;class&quot;: 3d array of class per voxel; &quot;mu&quot; estimated means; &quot;sigma&quot;: estimated standard deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
original&lt;-array(1,c(300,300,50))
for (i in 1:5)original[(i*60)-(0:20),,]&lt;-original[(i*60)-(0:20),,]+1
for (i in 1:10)original[,(i*30)-(0:15),]&lt;-original[,(i*30)-(0:15),]+1
original[,,26:50]&lt;-4-aperm(original[,,26:50],c(2,1,3))

img&lt;-array(rnorm(300*300*50,original,.2),c(300,300,50))
img&lt;-img-min(img)
img&lt;-img/max(img)

try1&lt;-segment(img,3,beta=0.5,z.scale=.3)
print(sum(try1$class!=original)/prod(dim(original)))

beta&lt;-matrix(rep(-.5,9),nrow=3)
beta&lt;-beta+1.5*diag(3)
try2&lt;-segment(img,3,beta,z.scale=.3)
print(sum(try2$class!=original)/prod(dim(original)))

par(mfrow=c(2,2))
img(original)
img(img)
img(try1$class)
img(try2$class)

## End(Not run)
</code></pre>

<hr>
<h2 id='segment.outside'>Segmentation of the background of 3D images based on automatic threshold</h2><span id='topic+segment.outside'></span>

<h3>Description</h3>

<p>Segmentation of the background of 3D images. Starting from the borders of the image, the algorithm tries to find the edges of an object in the middle of the image. From this, a threshold for the edge is defined automatically. The function then return the a logical array representing voxel inside the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment.outside(img, blobsize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment.outside_+3A_img">img</code></td>
<td>
<p>is a 3d array representing an image.</p>
</td></tr>
<tr><td><code id="segment.outside_+3A_blobsize">blobsize</code></td>
<td>
<p>is an integer, representing the minimal diameter for bridges from the outside. E.g., a blobsize=3 allows for holes of size 2*(blobsize-1)=4 in the edge of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary 3D array: 1 outside the object, 0 inside the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kringel &lt;- readTIF(system.file("extdata","kringel.tif",package="bioimagetools"))
out &lt;- segment.outside(kringel)
img(out, z=1)

</code></pre>

<hr>
<h2 id='spots'>Find spots based on threshold and minimum total intensity</h2><span id='topic+spots'></span>

<h3>Description</h3>

<p>Find spots based on threshold and minimum total intensity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spots(
  img,
  mask,
  thresh.offset = 0.1,
  window = c(5, 5),
  min.sum.intensity = 0,
  zero = NA,
  max.spots = NULL,
  return = "intensity"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spots_+3A_img">img</code></td>
<td>
<p>image array.</p>
</td></tr>
<tr><td><code id="spots_+3A_mask">mask</code></td>
<td>
<p>mask array.</p>
</td></tr>
<tr><td><code id="spots_+3A_thresh.offset">thresh.offset</code></td>
<td>
<p>threshold for minimum voxel intensity.</p>
</td></tr>
<tr><td><code id="spots_+3A_window">window</code></td>
<td>
<p>Half width and height of the moving rectangular window.</p>
</td></tr>
<tr><td><code id="spots_+3A_min.sum.intensity">min.sum.intensity</code></td>
<td>
<p>threshold for minimum total spot intensity</p>
</td></tr>
<tr><td><code id="spots_+3A_zero">zero</code></td>
<td>
<p>if NA, background is set to NA, if 0, background is set to 0.</p>
</td></tr>
<tr><td><code id="spots_+3A_max.spots">max.spots</code></td>
<td>
<p>find max.spots spots with highest total intensity.</p>
</td></tr>
<tr><td><code id="spots_+3A_return">return</code></td>
<td>
<p>&quot;mask&quot; returns binarized mask, &quot;intensity&quot; returns intensity for spots, zero or NA otherwise
&quot;label&quot; return labeled (numbered) spots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>

<hr>
<h2 id='standardize'>Standardize images</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Standardizes images in order to compare different images. Mean of standardized image is 0.5, standard deviation is sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(img, mask = array(TRUE, dim(img)), log = FALSE, N = 32, sd = 1/6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_img">img</code></td>
<td>
<p>is a 2d/3d array representing an image.</p>
</td></tr>
<tr><td><code id="standardize_+3A_mask">mask</code></td>
<td>
<p>a mask.</p>
</td></tr>
<tr><td><code id="standardize_+3A_log">log</code></td>
<td>
<p>Logical. Transform to log scale before standardization?</p>
</td></tr>
<tr><td><code id="standardize_+3A_n">N</code></td>
<td>
<p>number of classes.</p>
</td></tr>
<tr><td><code id="standardize_+3A_sd">sd</code></td>
<td>
<p>standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multi-dimensional array of standardized image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simuliere Daten zum Testen
test2&lt;-runif(128*128,0,1)
test2&lt;-sort(test2)
test2&lt;-array(test2,c(128,128))
img(test2)
# Standardisiere test2 in 32 Klassen
std&lt;-standardize(test2,N=32,sd=4)
</code></pre>

<hr>
<h2 id='table.n'>Cross Tabulation and Table Creation (including empty classes)</h2><span id='topic+table.n'></span>

<h3>Description</h3>

<p>Cross Tabulation and Table Creation (including empty classes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.n(
  x,
  m = max(x, na.rm = TRUE),
  percentage = FALSE,
  weight = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.n_+3A_x">x</code></td>
<td>
<p>R object with classes</p>
</td></tr>
<tr><td><code id="table.n_+3A_m">m</code></td>
<td>
<p>maximum number of classes</p>
</td></tr>
<tr><td><code id="table.n_+3A_percentage">percentage</code></td>
<td>
<p>boolean. If TRUE result is in percentages.</p>
</td></tr>
<tr><td><code id="table.n_+3A_weight">weight</code></td>
<td>
<p>weight for each voxel</p>
</td></tr>
<tr><td><code id="table.n_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Can we use parallel computing?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with (weighted) counts (including empty classes)
</p>


<h3>Author(s)</h3>

<p>Volker Schmid 2013-2016
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1,1,2,2,4,4,4)
table.n(x)
# [1] 2 2 0 3
table.n(x, m=5)
# [1] 2 2 0 3 0
table.n(x, weight=c(1,1,1,2,.5,.5,.5))
# [1] 2.0 3.0 0.0 1.5

</code></pre>

<hr>
<h2 id='testColoc'>Permutation Test for cross-type nearest neighbor distances</h2><span id='topic+testColoc'></span>

<h3>Description</h3>

<p>Permutation Test for cross-type nearest neighbor distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testColoc(
  im1,
  im2,
  hres = 0.102381,
  vres = 0.25,
  B = 999,
  alternative = "less",
  returnSample = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testColoc_+3A_im1">im1</code></td>
<td>
<p>image stack as returned by preprocessing</p>
</td></tr>
<tr><td><code id="testColoc_+3A_im2">im2</code></td>
<td>
<p>image stack as returned by preprocessing</p>
</td></tr>
<tr><td><code id="testColoc_+3A_hres">hres</code></td>
<td>
<p>horizontal resolution of the stacks</p>
</td></tr>
<tr><td><code id="testColoc_+3A_vres">vres</code></td>
<td>
<p>vertical resolution of the stacks</p>
</td></tr>
<tr><td><code id="testColoc_+3A_b">B</code></td>
<td>
<p>number of permutations to generate</p>
</td></tr>
<tr><td><code id="testColoc_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis (&quot;less&quot; to test H0:Colocalization )</p>
</td></tr>
<tr><td><code id="testColoc_+3A_returnsample">returnSample</code></td>
<td>
<p>return sampled null distribution</p>
</td></tr>
<tr><td><code id="testColoc_+3A_...">...</code></td>
<td>
<p>additional arguments for papply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the p.value, the observed weighted mean of the cNN-distances
</p>


<h3>Author(s)</h3>

<p>Fabian Scheipl
</p>

<hr>
<h2 id='writeTIF'>Writes image stack into a TIFF file.
Wrapper for writeTIFF</h2><span id='topic+writeTIF'></span>

<h3>Description</h3>

<p>Writes image stack into a TIFF file.
Wrapper for writeTIFF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeTIF(
  img,
  file,
  bps = attributes(img)$bits.per.sample,
  twod = FALSE,
  reduce = TRUE,
  attr = attributes(img),
  compression = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeTIF_+3A_img">img</code></td>
<td>
<p>An image, a 3d or 4d array.</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_file">file</code></td>
<td>
<p>File name.</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_bps">bps</code></td>
<td>
<p>number of bits per sample (numeric scalar). Supported values in this version are 8, 16, and 32.</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_twod">twod</code></td>
<td>
<p>Dimension of channels. TRUE for 2d images, FALSE for 3d images.</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_reduce">reduce</code></td>
<td>
<p>if TRUE then writeTIFF will attempt to reduce the number of planes in native rasters by analyzing the image to choose one of RGBA, RGB, GA or G formats, whichever uses the least planes without any loss. Otherwise the image is always saved with four planes (RGBA).</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_attr">attr</code></td>
<td>
<p>Attributes of image stack. Will be propagated to each 2d image.</p>
</td></tr>
<tr><td><code id="writeTIF_+3A_compression">compression</code></td>
<td>
<p>(see ?writeTIFF)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
