<!DOCTYPE html><html><head><title>Help for package declared</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {declared}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.declared'><p>Labelled vectors with declared missing values</p></a></li>
<li><a href='#as.haven'><p>Coerce to haven / labelled objects</p></a></li>
<li><a href='#declared_internal'><p>declared internal functions</p></a></li>
<li><a href='#declared_package'><p>Functions for Declared Missing Values</p></a></li>
<li><a href='#drop_undeclare'><p>Drop information / undeclare labelled objects</p></a></li>
<li><a href='#is.empty'><p>Test the presence of empty (undeclared) missing values</p></a></li>
<li><a href='#labels'><p>Get / Declare value labels</p></a></li>
<li><a href='#measurement'><p>Get / Set measurement levels for declared objects</p></a></li>
<li><a href='#missing_range'><p>Get / Declare missing values</p></a></li>
<li><a href='#w_IQR'><p>Compute weighted summaries for declared objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions for Declared Missing Values</td>
</tr>
<tr>
<td>Version:</td>
<td>0.24</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dusadrian/declared">https://github.com/dusadrian/declared</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dusadrian/declared/issues">https://github.com/dusadrian/declared/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A zero dependency package containing functions to declare labels
    and missing values, coupled with associated functions to create (weighted)
    tables of frequencies and various other summary measures. 
    Some of the base functions have been rewritten to make use of the specific 
    information about the missing values, most importantly to distinguish
    between empty NA and declared NA values.
    Some functions have similar functionality with the corresponding ones from
    packages "haven" and "labelled". The aim is to ensure as much compatibility
    as possible with these packages, while offering an alternative in the
    objects of class "declared".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 07:02:35 UTC; dusadrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Dusa <a href="https://orcid.org/0000-0002-3525-9253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Daniel Antal <a href="https://orcid.org/0000-0001-7513-6760"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Dusa &lt;dusa.adrian@unibuc.ro&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 11:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.declared'>Labelled vectors with declared missing values</h2><span id='topic+as.declared'></span><span id='topic+declared'></span><span id='topic+is.declared'></span><span id='topic+anyNAdeclared'></span>

<h3>Description</h3>

<p>The labelled vectors are mainly used to analyse social science data,
and the missing values declaration is an important step in the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.declared(x, ...)

declared(
  x,
  labels = NULL,
  na_values = NULL,
  na_range = NULL,
  label = NULL,
  measurement = NULL,
  llevels = FALSE,
  ...
)

is.declared(x)

anyNAdeclared(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.declared_+3A_x">x</code></td>
<td>
<p>A numeric vector to label, or a declared labelled vector
(for <code>undeclare</code>)</p>
</td></tr>
<tr><td><code id="as.declared_+3A_...">...</code></td>
<td>
<p>Other arguments used by various other methods</p>
</td></tr>
<tr><td><code id="as.declared_+3A_labels">labels</code></td>
<td>
<p>A named vector or <code>NULL</code>. The vector should be the same type
as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction
of the values might be labelled</p>
</td></tr>
<tr><td><code id="as.declared_+3A_na_values">na_values</code></td>
<td>
<p>A vector of values that should also be considered as missing</p>
</td></tr>
<tr><td><code id="as.declared_+3A_na_range">na_range</code></td>
<td>
<p>A numeric vector of length two giving the (inclusive) extents
of the range. Use <code>-Inf</code> and <code>Inf</code> if you want the range to be
open ended</p>
</td></tr>
<tr><td><code id="as.declared_+3A_label">label</code></td>
<td>
<p>A short, human-readable description of the vector</p>
</td></tr>
<tr><td><code id="as.declared_+3A_measurement">measurement</code></td>
<td>
<p>Optional, user specified measurement level</p>
</td></tr>
<tr><td><code id="as.declared_+3A_llevels">llevels</code></td>
<td>
<p>Logical, when <code>x</code> is a factor only use those levels that have
labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>declared</code> objects are very similar to the <code>haven_labelled_spss</code> objects
from package <b>haven</b>. It has exactly the same arguments, but it features
a fundamental difference in the treatment of (declared) missing values.
</p>
<p>In package <b>haven</b>, existing values are treated as if they were missing.
By contrast, in package <b>declared</b> the NA values are treated as if they
were existing values.
</p>
<p>This difference is fundamental and points to an inconsistency in package
<b>haven</b>: while existing values can be identified as missing using the
function <code>is.na()</code>, they are in fact present in the vector and other
packages (most importantly the base ones) do not know these values should be
treated as missing.
</p>
<p>Consequently, the existing values are interpreted as missing only by package
<b>haven</b>. Statistical procedures will use those values as if they were
valid values.
</p>
<p>Package <b>declared</b> approaches the problem in exactly the opposite way:
instead of treating existing values as missing, it treats (certain) NA values
as existing. It does that by storing an attribute containing the indices of
those NA values which are to be treated as declared missing values, and it
refreshes this attribute each time the declared object is changed.
</p>
<p>This is a trade off and has important implications when subsetting datasets:
all declared variables get this attribute refreshed, which consumes some time
depending on the number of variables in the data.
</p>
<p>The generic function <code>as.declared()</code> attempts to coerce only the compatible
types of objects, namely <code>haven_labelled</code> and <code>factor</code>s. Dedicated class
methods can be written for any other type of object, and users are free to
write their own. To end of with a declared object, additional metadata is
needed such as value labels, which values should be treated as missing etc.
</p>
<p>The measurement level is optional and, for the moment, purely aesthetic. It
might however be useful to (automatically) determine if a declared object is
suitable for a certain statistical analysis, for instance regression requires
quantitative variables, while some declared objects are certainly categorical
despite using numbers to denote categories.
</p>
<p>It distinguishes between <code>"categorial"</code> and <code>"quantitative"</code> types of
variables, and additionally recognizes <code>"nominal"</code> and <code>"ordinal"</code> as
categorical, and similarly recognizes <code>"interval"</code>, <code>"ratio"</code>,
<code>"discrete"</code> and <code>"continuous"</code> as quantitative.
</p>


<h3>Value</h3>

<p><code>declared()</code> and <code>as.declared()</code> return labelled vector of class
&quot;declared&quot;. When applied to a data frame, <code>as.declared()</code> will return a
corresponding data frame with declared variables. <code>is.declared()</code> and
<code>anyNAdeclared</code> return a logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- declared(
    c(1:5, -1),
    labels = c(Good = 1, Bad = 5, DK = -1),
    na_values = -1
)

x

is.na(x)

x &gt; 0

x == -1

# Values are actually placeholder for categories,
# so labels work as if they were factors:
x == "DK"


# when newly added values are already declared as missing,
# they are automatically coerced
c(x, 2, -1)

# switch NAs with their original values
undeclare(x)

as.character(x)

# Returning values instead of categories
as.character(x, values = TRUE)
</code></pre>

<hr>
<h2 id='as.haven'>Coerce to haven / labelled objects</h2><span id='topic+as.haven'></span>

<h3>Description</h3>

<p>Convert declared labelled objects to haven labelled objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.haven(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.haven_+3A_x">x</code></td>
<td>
<p>A declared labelled vector</p>
</td></tr>
<tr><td><code id="as.haven_+3A_...">...</code></td>
<td>
<p>Other arguments used by various methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function that reverses the process of <code>as.declared()</code>, making
a round trip between <code>declared</code> and <code>haven_labelled_spss</code> classes.
</p>


<h3>Value</h3>

<p>A labelled vector of class &quot;haven_labelled_spss&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- declared(
    c(1:5, -1),
    labels = c(Good = 1, Bad = 5, DK = -1),
    na_values = -1
)

x

as.haven(x)
</code></pre>

<hr>
<h2 id='declared_internal'>declared internal functions</h2><span id='topic+declared_internal'></span><span id='topic+format_declared'></span><span id='topic+order_declared'></span><span id='topic+value_labels'></span><span id='topic+variable_label'></span><span id='topic+names_values'></span><span id='topic+makeTag_'></span><span id='topic+hasTag_'></span><span id='topic+getTag_'></span><span id='topic+anyTagged_'></span>

<h3>Description</h3>

<p>Functions to be used internally, only by developers and
contributors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_declared(x, digits = getOption("digits"))

order_declared(
  x,
  na.last = NA,
  decreasing = FALSE,
  method = c("auto", "shell", "radix"),
  empty.last = na.last,
  ...
)

value_labels(...)

variable_label(...)

names_values(x, drop_na = FALSE, observed = TRUE)

makeTag_(...)

hasTag_(x, tag = NULL)

getTag_(x)

anyTagged_(x)
</code></pre>

<hr>
<h2 id='declared_package'>Functions for Declared Missing Values</h2><span id='topic+declared_package'></span><span id='topic+declared-package'></span>

<h3>Description</h3>

<p>A set of functions to declare labels and missing values, coupled
with associated functions to create (weighted) tables of frequencies and
various other summary measures.
Some of the base functions are rewritten to make use of the specific
information about the missing values, most importantly to distinguish between
empty and declared missing values.
Many functions have a similar functionality with the corresponding ones from
packages &quot;haven&quot; and &quot;labelled&quot;. The aim is to ensure as much compatibility
as possible with these packages, while offering an alternative in the objects
of class &quot;declared&quot;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> declared</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.24</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-v3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Adrian Dusa
</p>
<p>Maintainer: Adrian Dusa (dusa.adrian@unibuc.ro)
</p>

<hr>
<h2 id='drop_undeclare'>Drop information / undeclare labelled objects</h2><span id='topic+drop_undeclare'></span><span id='topic+undeclare'></span><span id='topic+drop_na'></span>

<h3>Description</h3>

<p>A function to obtain a version of the object with all information about
declared missing values, dropped
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undeclare(x, drop = FALSE, ...)

drop_na(x, drop_labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_undeclare_+3A_x">x</code></td>
<td>
<p>A labelled object with declared missing values</p>
</td></tr>
<tr><td><code id="drop_undeclare_+3A_drop">drop</code></td>
<td>
<p>Logical, drop all attributes</p>
</td></tr>
<tr><td><code id="drop_undeclare_+3A_...">...</code></td>
<td>
<p>Other internal arguments</p>
</td></tr>
<tr><td><code id="drop_undeclare_+3A_drop_labels">drop_labels</code></td>
<td>
<p>Logical, drop the labels for the declared missing values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>undeclare()</code> replaces the NA entries into their original
numeric values, and drops all attributes related to missing values:
<code>na_values</code>, <code>na_range</code> and <code>na_index</code>, and it preserves the labels referring
to the missing values.
</p>
<p>The result can be a regular vector (dropping all attributes, including the
class &quot;declared&quot;) by activating the argument <code>drop</code>.
</p>
<p>Function <code>drop_na()</code> transforms the declared missing values in regular empty
NAs, and the labels referring to the missing values are deleted by default.
</p>
<p>Function <code>drop()</code> deletes all attributes.
</p>


<h3>Value</h3>

<p>A declared labelled object.
</p>


<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+labels">labels</a>()</code>,
<code><a href="#topic+measurement">measurement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- declared(
    c(-2, 1:5, -1),
    labels = c("Good" = 1, "Bad" = 5, "DK" = -1),
    na_values = c(-1, -2),
    label = "Test variable"
)

x

undeclare(x)

drop_na(x)

drop(x)

undeclare(x, drop = TRUE)

# similar to:
drop(undeclare(x))
</code></pre>

<hr>
<h2 id='is.empty'>Test the presence of empty (undeclared) missing values</h2><span id='topic+is.empty'></span><span id='topic+anyNAempty'></span>

<h3>Description</h3>

<p>Functions that indicate which elements are empty <code>NA</code> missing values, in
contrast to declared missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.empty(x)

anyNAempty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.empty_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All missing values, declared or undeclared, as stored as regular <code>NA</code>
values, therefore the base function <code>is_na()</code> does not differentiate
between them.
</p>
<p>These functions are specifically adapted to objects of class <code>"declared"</code>,
to return a truth value only for those elements that are completely missing
with no reason.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- declared(
    c(1:2, -91),
    labels = c(Good = 1, Bad = 2, Missing = -91),
    na_values = -91
)

x

is.empty(x) # FALSE FALSE FALSE

anyNAempty(x) # FALSE

x &lt;- c(x, NA)

is.empty(x) # FALSE FALSE FALSE  TRUE

anyNAempty(x) # TRUE

</code></pre>

<hr>
<h2 id='labels'>Get / Declare value labels</h2><span id='topic+labels'></span><span id='topic+label'></span><span id='topic+label+3C-'></span><span id='topic+labels+3C-'></span>

<h3>Description</h3>

<p>Functions to extract information about the declared variable / value labels,
or to declare such values if they are present in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label(x)

label(x, ...) &lt;- value

labels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_+3A_x">x</code></td>
<td>
<p>Any vector of values that should be declared as missing
(for <code>labels</code>) or a numeric vector of length two giving the (inclusive)
extents of the range of missing values (for <code>label</code>).</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>Other arguments, for internal use.</p>
</td></tr>
<tr><td><code id="labels_+3A_value">value</code></td>
<td>
<p>The variable label, or a list of (named) variable labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>labels()</code> is a adaptation of the base function to the objects
of class <code>declared</code>. In addition to the regular arguments, it has two
additional (logical) arguments called <code>prefixed</code> (FALSE by default), to
retrieve the value labels prefixed with their values, and <code>print_as_df</code>
(TRUE by default) to print the result as a data frame.
</p>


<h3>Value</h3>

<p><code>labels()</code> will return a named vector.
</p>
<p><code>label()</code> will return a single character string.
</p>


<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+drop_undeclare">drop_undeclare</a></code>,
<code><a href="#topic+measurement">measurement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- declared(
    c(-2, 1:5, -1),
    labels = c("Good" = 1, "Bad" = 5, "DK" = -1),
    na_values = c(-1, -2),
    label = "Test variable"
)
x

labels(x)

labels(x, prefixed = TRUE)

labels(x) &lt;- c("Good" = 1, "Bad" = 5, "DK" = -1, "Not applicable" = -2)

label(x)

label(x) &lt;- "This is a proper label"

x

</code></pre>

<hr>
<h2 id='measurement'>Get / Set measurement levels for declared objects</h2><span id='topic+measurement'></span><span id='topic+measurement+3C-'></span>

<h3>Description</h3>

<p>Functions to extract information about the measurement levels of a variable
(if already present), or to specify such measurement levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurement(x)

measurement(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurement_+3A_x">x</code></td>
<td>
<p>A declared vector.</p>
</td></tr>
<tr><td><code id="measurement_+3A_value">value</code></td>
<td>
<p>A single character string of measurement levels,
separated by commas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an attribute called <code>"measurement"</code> to a declared
This object, as an optional feature, at this point for purely aesthetic
reasons. attribute might become useful in the future to (automatically)
determine if a declared object is suitable for a certain statistical
analysis, for instance regression requires quantitative variables, while some
declared objects are certainly categorical despite using numbers to denote
categories.
</p>
<p>It distinguishes between <code>"categorical"</code> and <code>"quantitative"</code> types of
variables, and additionally recognizes <code>"nominal"</code> and <code>"ordinal"</code> as
categorical, and similarly recognizes <code>"interval"</code>, <code>"ratio"</code>,
<code>"discrete"</code> and <code>"continuous"</code> as quantitative.
</p>
<p>The words <code>"qualitative"</code> is treated as a synonym for <code>"categorical"</code>,
and the words <code>"metric"</code> and <code>"numeric"</code> are treated as synonyms for
<code>"quantitative"</code>, respectively.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other labelling functions: 
<code><a href="#topic+drop_undeclare">drop_undeclare</a></code>,
<code><a href="#topic+labels">labels</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- declared(
    c(-2, 1:5, -1),
    labels = c(Good = 1, Bad = 5, DK = -1),
    na_values = c(-1, -2),
    label = "Test variable"
)

x

measurement(x)

# automatically recognized as categorical
measurement(x) &lt;- "ordinal"

measurement(x)

# the same with
measurement(x) &lt;- "categorical, ordinal"

set.seed(1890)
x &lt;- declared(
    sample(c(18:90, -91), 20, replace = TRUE),
    labels = c("No answer" = -91),
    na_values = -91,
    label = "Respondent's age"
)

# automatically recognized as quantitative
measurement(x) &lt;- "discrete"

measurement(x)

# the same with
measurement(x) &lt;- "metric, discrete"

</code></pre>

<hr>
<h2 id='missing_range'>Get / Declare missing values</h2><span id='topic+missing_range'></span><span id='topic+missing_range+3C-'></span><span id='topic+missing_values'></span><span id='topic+missing_values+3C-'></span>

<h3>Description</h3>

<p>Functions to extract information about the declared missing values, or to
declare such values if they are present in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_range(x)

missing_range(x) &lt;- value

missing_values(x)

missing_values(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_range_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="missing_range_+3A_value">value</code></td>
<td>
<p>Any vector of values that should be declared as missing
(for <code>missing_values</code>) or a numeric vector of length two giving the
(inclusive) extents of the range of missing values (for <code>missing_range</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>missing_values()</code> will return a vector of one or more values.
</p>
<p><code>missing_range()</code> will return a numeric vector of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- declared(c(-2, 1:5, -1),
    labels = c(Good = 1, Bad = 5, DK = -1, NotApplicable = -2),
    na_values = c(-1, -2)
)
x

missing_values(x)

missing_range(x) &lt;- c(-10, -7)

missing_range(x)

</code></pre>

<hr>
<h2 id='w_IQR'>Compute weighted summaries for declared objects</h2><span id='topic+w_IQR'></span><span id='topic+w_fivenum'></span><span id='topic+w_mean'></span><span id='topic+w_median'></span><span id='topic+w_mode'></span><span id='topic+w_quantile'></span><span id='topic+w_sd'></span><span id='topic+w_standardize'></span><span id='topic+w_summary'></span><span id='topic+weighted'></span><span id='topic+w_table'></span><span id='topic+w_var'></span>

<h3>Description</h3>

<p>Functions to compute weighted tables or summaries, based on a vector of
frequency weights. These are reimplementations of various existing functions,
adapted to objects of class <code>"declared"</code> (see Details below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_IQR(x, wt = NULL, na.rm = FALSE, ...)

w_fivenum(x, wt = NULL, na.rm = FALSE)

w_mean(x, wt = NULL, trim = 0, na.rm = TRUE)

w_median(x, wt = NULL, na.rm = TRUE, ...)

w_mode(x, wt = NULL)

w_quantile(x, wt = NULL, probs = seq(0, 1, 0.25), na.rm = TRUE, ...)

w_sd(x, wt = NULL, method = NULL, na.rm = TRUE)

w_standardize(x, wt = NULL, na.rm = TRUE)

w_summary(x, wt = NULL, ...)

w_table(
  x,
  y = NULL,
  wt = NULL,
  values = FALSE,
  valid = TRUE,
  observed = TRUE,
  margin = NULL,
  vlabel = FALSE
)

w_var(x, wt = NULL, method = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="w_IQR_+3A_x">x</code></td>
<td>
<p>A numeric vector for summaries, or declared / factor for frequency
tables</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_wt">wt</code></td>
<td>
<p>A numeric vector of frequency weights</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, should the empty missing values be removed?</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_trim">trim</code></td>
<td>
<p>A fraction (0 to 0.5) of observations to be trimmed from each end
of x before the mean is computed. Values of trim outside that range are
taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1]</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_method">method</code></td>
<td>
<p>Character, specifying how the result is scaled, see 'Details'
below.</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_y">y</code></td>
<td>
<p>An optional variable, to create crosstabs; must have the same length
as x</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_values">values</code></td>
<td>
<p>Logical, print the values in the table rows</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_valid">valid</code></td>
<td>
<p>Logical, print separate percent distribution for valid values,
if any missing values are present; for cross tables, use valid values only</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_observed">observed</code></td>
<td>
<p>Logical, print the observed categories only</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_margin">margin</code></td>
<td>
<p>Numeric, indicating the margin to calculate crosstab
proportions: 0 from the total, 1 from row totals and 2 from column totals</p>
</td></tr>
<tr><td><code id="w_IQR_+3A_vlabel">vlabel</code></td>
<td>
<p>Logical, print the variable label, if existing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted summaries
</p>
<p>A frequency table is usually performed for a categorical variable, displaying
the frequencies of the respective categories. Note that general variables
containing text are not necessarily factors, despite having a small number of
characters.
</p>
<p>A general table of frequencies, using the base function <code>table()</code>, ignores
the defined missing values (which are all stored as NAs). The
reimplementation of this function in <code>w_table()</code> takes care of this detail,
and presents frequencies for each separately defined missing values. Similar
reimplementations for the other functions have the same underlying objective.
</p>
<p>It is also possible to perform a frequency table for numerical variables, if
the number of values is limited (an arbitrary and debatable upper limit of 15
is used). An example of such variable can be the number of children, where
each value can be interpreted as a class, containing a single value (for
instance 0 meaning the category of people with no children).
</p>
<p>Objects of class <code>declared</code> are not pure categorical variables (R factors)
but they are nevertheless interpreted as if they were factors, to allow
producing frequency tables. Given the high similarity with package
<strong><code>haven</code></strong>, objects of class <code>haven_labelled_spss</code> are automatically
coerced to objects of class <code>declared</code> and treated accordingly.
</p>
<p>The argument <code>values</code> makes sense only when the input is of family class
<code>declared</code>, otherwise for regular (base R) factors the values are
just a sequence of numbers.
</p>
<p>The later introduced argument <code>observed</code> is useful in situations when a
variable has a very large number of potential values, and a smaller subset of
actually observed ones. As an example, the variable &ldquo;Occupation&rdquo; has
hundreds of possible values in the ISCO08 codelist, and not all of them might
be actually observed. When activated, this argument restricts the printed
frequency table to the subset of observed values only.
</p>
<p>The argument <code>method</code> can be one of <code>"unbiased"</code> or <code>"ML"</code>.
</p>
<p>When this is set to <code>"unbiased"</code>, the result is an unbiased estimate
using Bessel's correction. When this is set to <code>"ML"</code>, the result is the
maximum likelihood estimate for a Gaussian distribution.
</p>
<p>The argument <code>wt</code> refers only to frequency weights. Users should be
aware of the differences between frequency weights, analytic weights,
probability weights, design weights, post-stratification weights etc. For
purposes of inferential testing, Thomas Lumley's package <strong><code>survey</code></strong>
should be employed.
</p>
<p>If no frequency weights are provided, the result is identical to the
corresponding base functions.
</p>
<p>The function <code>w_quantile()</code> extensively borrowed ideas from packages
<strong><code>stats</code></strong> and <strong><code>Hmisc</code></strong>, to ensure a constant interpolation that would
produce the same quantiles if no weights are provided or if all
weights are equal to 1.
</p>
<p>Other arguments can be passed to the stats function <code>quantile()</code> via the
three dots <code>...</code> argument, and their extensive explanation is found in the
corresponding stats function's help page.
</p>
<p>For all functions, the argument <code>na.rm</code> refers to the empty missing values
and its default is set to TRUE. The declared missing values are automatically
eliminated from the summary statistics, even if this argument is deactivated.
</p>
<p>The function <code>w_mode()</code> returns the weighted mode of a variable. Unlike the
other functions where the prefix <code>w_</code> signals a weighted version of the
base function with the same name, this has nothing to do with the base
function <code>mode()</code> which refers to the storage mode / type of an R object.
</p>


<h3>Value</h3>

<p>A vector of (weighted) values.
</p>


<h3>Author(s)</h3>

<p>Adrian Dusa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(215)

# a pure categorical variable
x &lt;- factor(sample(letters[1:5], 215, replace = TRUE))
w_table(x)


# simulate number of children
x &lt;- sample(0:4, 215, replace = TRUE)
w_table(x)

# simulate a Likert type response scale from 1 to 7
values &lt;- sample(c(1:7, -91), 215, replace = TRUE)
x &lt;- declared(values, labels = c("Good" = 1, "Bad" = 7))
w_table(x)


# Defining missing values
missing_values(x) &lt;- -91
w_table(x)


# Defined missing values with labels
values &lt;- sample(c(1:7, -91, NA), 215, replace = TRUE)
x &lt;- declared(
    values,
    labels = c("Good" = 1, "Bad" = 7, "Don't know" = -91),
    na_values = -91
)

w_table(x)

# Including the values in the table of frequencies
w_table(x, values = TRUE)


# An example involving multiple variables
DF &lt;- data.frame(
    Area = declared(
        sample(1:2, 215, replace = TRUE, prob = c(0.45, 0.55)),
        labels = c(Rural = 1, Urban = 2)
    ),
    Gender = declared(
        sample(1:2, 215, replace = TRUE, prob = c(0.55, 0.45)),
        labels = c(Males = 1, Females = 2)
    ),
    Age = sample(18:90, 215, replace = TRUE),
    Children = sample(0:5, 215, replace = TRUE)
)

w_table(DF$Gender)

w_sd(DF$Age)


# Weighting: observed proportions
op &lt;- proportions(with(DF, table(Gender, Area)))

# Theoretical proportions: 53% Rural, and 50.2% Females
tp &lt;- rep(c(0.53, 0.47), each = 2) * rep(c(0.498, 0.502), 2)

# Corrections by strata
fweights &lt;- tp / op

DF$fweight &lt;- fweights[match(10 * DF$Area + DF$Gender, c(11, 12, 21, 22))]

with(DF, w_table(Gender, wt = fweight))

with(DF, w_mean(Age, wt = fweight))

with(DF, w_quantile(Age, wt = fweight))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
