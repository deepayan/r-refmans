<!DOCTYPE html><html lang="en"><head><title>Help for package rTensor2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rTensor2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.tensor'><p>Tensor Conversion</p></a></li>
<li><a href='#LU'><p>LU Decomposition of a Complex Matrix</p></a></li>
<li><a href='#Mnist'>
<p>Subset of MNIST training and testing data.</p></a></li>
<li><a href='#polar'><p>Polar/Jordan Form of a Matrix</p></a></li>
<li><a href='#QR'><p>QR Decomposition of a Complex Matrix Without Pivoting</p></a></li>
<li><a href='#rand_tensor'><p>Tensor with Random Entries</p></a></li>
<li><a href='#raytrace'>
<p>Subset of raytrace data</p></a></li>
<li><a href='#t_tpose'><p>Transpose 3-mode Tensor</p></a></li>
<li><a href='#tDWT'><p>Discrete Wavelet Transform of a 3-D Tensor</p></a></li>
<li><a href='#tEIG'><p>Tensor Eigenvalue Decomposition Using any Discrete Transform</p></a></li>
<li><a href='#tEIGdct'><p>Tensor Eigenvalue Decomposition Using  the Discrete Cosine Transform</p></a></li>
<li><a href='#tEIGdht'><p>Tensor Eigenvalue Decomposition Using  the Discrete Hadley Transform</p></a></li>
<li><a href='#tEIGdst'><p>Tensor Eigenvalue Decomposition Using  the Discrete Sine Transform</p></a></li>
<li><a href='#tEIGdwht'><p>Tensor Eigenvalue Decomposition Using  the Discrete Walsh-Hadamard Transform</p></a></li>
<li><a href='#tEIGdwt'><p>Tensor Eigenvalue Decomposition Using  the Discrete Wavelet Transform</p></a></li>
<li><a href='#tEIGfft'><p>Tensor Eigenvalue Decomposition Using  the Discrete Fourier Transform</p></a></li>
<li><a href='#tIDWT'><p>Discrete Inverse Wavelet Transform of a 3-D Tensor</p></a></li>
<li><a href='#tINV'><p>Inverse of a 3-mode Tensor Using any Discrete Transform</p></a></li>
<li><a href='#tINVdct'><p>Inverse of a 3-mode Tensor Using the Discrete Cosine Transform</p></a></li>
<li><a href='#tINVdht'><p>Inverse of a 3-mode Tensor Using the Discrete Hartley Transform</p></a></li>
<li><a href='#tINVdst'><p>Inverse of a 3-mode Tensor Using the Discrete Sine Transform</p></a></li>
<li><a href='#tINVdwht'><p>Inverse of a 3-mode Tensor Using the Discrete Walsh-Hadamard Transform</p></a></li>
<li><a href='#tINVdwt'><p>Inverse of a 3-mode Tensor Using the Discrete Wavelet Transform</p></a></li>
<li><a href='#tINVfft'><p>Inverse of a 3-mode Tensor Using the Discrete Fourier Transform</p></a></li>
<li><a href='#tLDA'><p>Linear Discriminate Analysis of a 3-mode Tensor Using any Discrete Transform</p></a></li>
<li><a href='#tLU'><p>Tensor LU Decomposition Using Using Any Discrete Transform</p></a></li>
<li><a href='#tLUdct'><p>Tensor LU Decomposition Using the Discrete Cosine Transform</p></a></li>
<li><a href='#tLUdht'><p>Tensor LU Decomposition Using the Discrete Hartley Transform</p></a></li>
<li><a href='#tLUdst'><p>Tensor LU Decomposition Using the Discrete Cosine Transform</p></a></li>
<li><a href='#tLUdwht'><p>Tensor LU Decomposition Using the Discrete Walsh-Hadamard Transform</p></a></li>
<li><a href='#tLUdwt'><p>Tensor LU Decomposition Using  the Discrete Wavelet Transform</p></a></li>
<li><a href='#tLUfft'><p>Tensor LU Decomposition Using  the Discrete Fourier Transform</p></a></li>
<li><a href='#tmean'><p>Find the mean of a tensor</p></a></li>
<li><a href='#tmult'><p>Tensor Multiplication Using Any Discrete Transform</p></a></li>
<li><a href='#tQR'><p>Tensor QR Decomposition Using Using Any Discrete Transform</p></a></li>
<li><a href='#tQRdct'><p>Tensor QR Decomposition Using  the Discrete Cosine Transform</p></a></li>
<li><a href='#tQRdht'><p>Tensor QR Decomposition Using the Discrete Hartley Transform</p></a></li>
<li><a href='#tQRdst'><p>Tensor QR Decomposition Using  the Discrete Sine Transform</p></a></li>
<li><a href='#tQRdwht'><p>Tensor QR Decomposition Using the Discrete Walsh-Hadamard Transform</p></a></li>
<li><a href='#tQRdwt'><p>Tensor QR Decomposition Using  the Discrete Wavelet Transform</p></a></li>
<li><a href='#tQRfft'><p>Tensor QR Decomposition Using  the Discrete Fourier Transform</p></a></li>
<li><a href='#tSVD'><p>Tensor Singular Value Decomposition Using Any Discrete Transform</p></a></li>
<li><a href='#tSVDdct'><p>Tensor Singular Value Decomposition Using  the Discrete Cosine Transform</p></a></li>
<li><a href='#tSVDdht'><p>Tensor Singular Value Decomposition Using  the Discrete Harley Transform</p></a></li>
<li><a href='#tSVDdst'><p>Tensor Singular Value Decomposition Using  the Discrete Sine Transform</p></a></li>
<li><a href='#tSVDdwht'><p>Tensor Singular Value Decomposition Using  the Discrete Walsh-Hadamard Transform</p></a></li>
<li><a href='#tSVDdwt'><p>Tensor Singular Value Decomposition Using  the Discrete Wavelet Transform</p></a></li>
<li><a href='#tSVDfft'><p>Tensor Singular Value Decomposition Using  the Discrete Fourier Transform</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MultiLinear Algebra</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Caudle &lt;kyle.caudle@sdsmt.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for basic tensor operators.  A tensor in the context of data analysis in a multidimensional array. The tools in this package rely on using any discrete transformation (e.g. Fast Fourier Transform (FFT)).  Standard tools included are the Eigenvalue decomposition of a tensor, the QR decomposition and LU decomposition.  Other functionality includes the inverse of a tensor and the transpose of a symmetric tensor. Functionality in the package is outlined in Kernfeld et al. (2015) <a href="https://www.sciencedirect.com/science/article/pii/S0024379515004358">https://www.sciencedirect.com/science/article/pii/S0024379515004358</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods,raster,png,rTensor, wavethresh, gsignal, Matrix,
matrixcalc</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 15:40:45 UTC; kcaudle</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Caudle [aut, cre],
  Randy Hoover [ctb],
  Jackson Cates [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.tensor'>Tensor Conversion</h2><span id='topic+as.tensor'></span>

<h3>Description</h3>

<p>Create a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object from an array, matrix, or vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.tensor(x, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.tensor_+3A_x">x</code></td>
<td>
<p>: an instance of array, matrix, or vector</p>
</td></tr>
<tr><td><code id="as.tensor_+3A_drop">drop</code></td>
<td>
<p>: whether or not modes equal to 1 should be dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>Imported from rTensor package version 1.4.8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#From vector
vec &lt;- runif(3); vecT &lt;- as.tensor(vec); vecT
#From matrix
mat &lt;- matrix(runif(2*3),nrow=2,ncol=3)
matT &lt;- as.tensor(mat); matT
#From array
indices &lt;- c(2,3,4)
arr &lt;- array(runif(prod(indices)), dim = indices)
arrT &lt;- as.tensor(arr); arrT
</code></pre>

<hr>
<h2 id='LU'>LU Decomposition of a Complex Matrix</h2><span id='topic+LU'></span>

<h3>Description</h3>

<p>Decompose a square matrix A into the product of a lower triangular matrix L and an upper triangular matrix U.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LU(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LU_+3A_a">A</code></td>
<td>
<p>: an  <code class="reqn">n</code> x <code class="reqn">n</code> matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a lower triangular matrix L and an upper triangular matrix U so that A = LU.
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- complex(real = rnorm(16), imag = rnorm(16))
A &lt;- matrix(z,nrow=4)
LU(A)
</code></pre>

<hr>
<h2 id='Mnist'>
Subset of MNIST training and testing data.
</h2><span id='topic+Mnist'></span>

<h3>Description</h3>

<p>10000 MNIST training images (1000 of every digit), reformatted into a tensor: 28 x 10000 x 28.
1000 MNIST test images (100 of every digit), reformatted into a tensor: 28 x 1000 x 28
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mnist")</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p>Mnist$train$images, Mnist$train$labels
</p>
<p>Mnist$test$images, Mnist$test$labels
</p>


<h3>References</h3>

<p>Deng L (2012). “The mnist database of handwritten digit images for machine learning research.” IEEE Signal Processing Magazine, 29(6), 141–142
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tensor)
</code></pre>

<hr>
<h2 id='polar'>Polar/Jordan Form of a Matrix</h2><span id='topic+polar'></span>

<h3>Description</h3>

<p>Creates the polar/Jordan form of the P and D matrices after performing eigenvalue decomposition where the eigenvalue values are complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar(P,D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polar_+3A_p">P</code></td>
<td>
<p>: the eigenvectors from an eigenvalue decomposition.</p>
</td></tr>
<tr><td><code id="polar_+3A_d">D</code></td>
<td>
<p>: the eigenvalues from an eigenvalue decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>P the polar form (real-valued) matrix of eigenvectors.
</p>
<p>D the polar form (real-valued) matrix of eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- complex(real = rnorm(16), imag = rnorm(16))
M &lt;- matrix(z,nrow=4)
decomp &lt;- eigen(M)
polar(decomp$vectors,decomp$values)
</code></pre>

<hr>
<h2 id='QR'>QR Decomposition of a Complex Matrix Without Pivoting</h2><span id='topic+QR'></span>

<h3>Description</h3>

<p>Performs QR Decomposition of a Complex Matrix without pivoting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QR(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QR_+3A_a">A</code></td>
<td>
<p>: an  <code class="reqn">n</code> x <code class="reqn">n</code> matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an orthogonal matrix Q and an upper triangular matrix R so that A = QR.
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- complex(real = rnorm(16), imag = rnorm(16))
A &lt;- matrix(z,nrow=4)
QR(A)
</code></pre>

<hr>
<h2 id='rand_tensor'>Tensor with Random Entries</h2><span id='topic+rand_tensor'></span>

<h3>Description</h3>

<p>Generate a Tensor with specified modes with iid normal(0,1) entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rand_tensor(modes = c(3, 4, 5), drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rand_tensor_+3A_modes">modes</code></td>
<td>
<p>: the modes of the output Tensor</p>
</td></tr>
<tr><td><code id="rand_tensor_+3A_drop">drop</code></td>
<td>
<p>: whether or not modes equal to 1 should be dropped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Tensor object with modes given by modes
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>Imported from rTensor package version 1.4.8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rand_tensor()
  rand_tensor(c(4,4,4))
  rand_tensor(c(10,2,1),TRUE)
</code></pre>

<hr>
<h2 id='raytrace'>
Subset of raytrace data
</h2><span id='topic+raytrace'></span>

<h3>Description</h3>

<p>4 tensors (128 x 128 x 128) for 4 different gray scale images.  boat, flashlight, keyboard, scooter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("raytrace")</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p>raytrace$boat 
</p>
<p>raytrace$flashlight
</p>
<p>raytrace$keyboard
</p>
<p>raytrace$scooter
</p>


<h3>References</h3>

<p>Hoover RC, Braman KS, Hao N (2011b). “Pose estimation from a single image using tensor
decomposition and an algebra of circulants.” In 2011 IEEE/RSJ International Conference
on Intelligent Robots and Systems, pp. 2928–2934. IEEE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raytrace)
</code></pre>

<hr>
<h2 id='t_tpose'>Transpose 3-mode Tensor</h2><span id='topic+t_tpose'></span>

<h3>Description</h3>

<p>Performs the transpose of a symmetric 3-mode tensor using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_tpose(tnsr,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t_tpose_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="t_tpose_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(t_tpose(T,"dct"))
</code></pre>

<hr>
<h2 id='tDWT'>Discrete Wavelet Transform of a 3-D Tensor</h2><span id='topic+tDWT'></span>

<h3>Description</h3>

<p>Performs the Discrete Wavelet Transform of a 3-D Tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tDWT(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tDWT_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>G. Strang and T. Nguyen, Wavelets and filter banks. SIAM, 1996.
</p>
<p>A. Haar, &quot;Zur theorie der orthogonalen funktionensysteme&quot;, Mathematische annalen, vol. 69, no. 3, pp. 331-371, 1910.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tDWT(T))
</code></pre>

<hr>
<h2 id='tEIG'>Tensor Eigenvalue Decomposition Using any Discrete Transform</h2><span id='topic+tEIG'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIG(tnsr, tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIG_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor, <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code></p>
</td></tr>
<tr><td><code id="tEIG_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>Kernfeld, E., Kilmer, M., &amp; Aeron, S. (2015). Tensor-tensor products with invertible linear transforms. Linear Algebra and its Applications, 485, 545-570.
</p>
<p>M. E. Kilmer, C. D. Martin, and L. Perrone, “A third-order generalization
of the matrix svd as a product of third-order tensors,” Tufts University,
Department of Computer Science, Tech. Rep. TR-2008-4, 2008
</p>
<p>K. Braman, &quot;Third-order tensors as linear operators on a space of
matrices&quot;, Linear Algebra and its Applications, vol. 433, no. 7, pp.
1241-1253, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
tEIG(T,"dst")
</code></pre>

<hr>
<h2 id='tEIGdct'>Tensor Eigenvalue Decomposition Using  the Discrete Cosine Transform</h2><span id='topic+tEIGdct'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Cosine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGdct(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGdct_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGdct(T))
</code></pre>

<hr>
<h2 id='tEIGdht'>Tensor Eigenvalue Decomposition Using  the Discrete Hadley Transform</h2><span id='topic+tEIGdht'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Hadley transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGdht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGdht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGdht(T))
</code></pre>

<hr>
<h2 id='tEIGdst'>Tensor Eigenvalue Decomposition Using  the Discrete Sine Transform</h2><span id='topic+tEIGdst'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Sine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGdst(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGdst_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGdst(T))
</code></pre>

<hr>
<h2 id='tEIGdwht'>Tensor Eigenvalue Decomposition Using  the Discrete Walsh-Hadamard Transform</h2><span id='topic+tEIGdwht'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGdwht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGdwht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGdwht(T))
</code></pre>

<hr>
<h2 id='tEIGdwt'>Tensor Eigenvalue Decomposition Using  the Discrete Wavelet Transform</h2><span id='topic+tEIGdwt'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Wavelet transform (Haar Wavelet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGdwt(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGdwt_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>G. Strang and T. Nguyen, Wavelets and filter banks. SIAM, 1996.
</p>
<p>A. Haar, “Zur theorie der orthogonalen funktionensysteme,” Mathema-
tische annalen, vol. 69, no. 3, pp. 331–371, 1910.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGdwt(T))
</code></pre>

<hr>
<h2 id='tEIGfft'>Tensor Eigenvalue Decomposition Using  the Discrete Fourier Transform</h2><span id='topic+tEIGfft'></span>

<h3>Description</h3>

<p>Performs a Eigenvalue decomposition of 3-mode tensor using the discrete Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEIGfft(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tEIGfft_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If Eigenvalue decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>P: A tensor of Eigenvectors (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>D: An diagonal tensor of Eigenvalues (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tEIGfft(T))
</code></pre>

<hr>
<h2 id='tIDWT'>Discrete Inverse Wavelet Transform of a 3-D Tensor</h2><span id='topic+tIDWT'></span>

<h3>Description</h3>

<p>Performs the Discrete Inverse Wavelet Transform of a 3-D Tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tIDWT(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tIDWT_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>G. Strang and T. Nguyen, Wavelets and filter banks. SIAM, 1996.
</p>
<p>A. Haar, &quot;Zur theorie der orthogonalen funktionensysteme&quot;, Mathematische annalen, vol. 69, no. 3, pp. 331-371, 1910.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tIDWT(T))
</code></pre>

<hr>
<h2 id='tINV'>Inverse of a 3-mode Tensor Using any Discrete Transform</h2><span id='topic+tINV'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINV(tnsr,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINV_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tINV_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINV(T,"dst"))
</code></pre>

<hr>
<h2 id='tINVdct'>Inverse of a 3-mode Tensor Using the Discrete Cosine Transform</h2><span id='topic+tINVdct'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete cosine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVdct(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVdct_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVdct(T))
</code></pre>

<hr>
<h2 id='tINVdht'>Inverse of a 3-mode Tensor Using the Discrete Hartley Transform</h2><span id='topic+tINVdht'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete Hartley transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVdht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVdht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVdht(T))
</code></pre>

<hr>
<h2 id='tINVdst'>Inverse of a 3-mode Tensor Using the Discrete Sine Transform</h2><span id='topic+tINVdst'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete sine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVdst(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVdst_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVdst(T))
</code></pre>

<hr>
<h2 id='tINVdwht'>Inverse of a 3-mode Tensor Using the Discrete Walsh-Hadamard Transform</h2><span id='topic+tINVdwht'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVdwht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVdwht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVdwht(T))
</code></pre>

<hr>
<h2 id='tINVdwt'>Inverse of a 3-mode Tensor Using the Discrete Wavelet Transform</h2><span id='topic+tINVdwt'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete wavelet transform (Haar Wavelet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVdwt(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVdwt_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVdwt(T))
</code></pre>

<hr>
<h2 id='tINVfft'>Inverse of a 3-mode Tensor Using the Discrete Fourier Transform</h2><span id='topic+tINVfft'></span>

<h3>Description</h3>

<p>Performs the inverse of a tensor using the discrete Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tINVfft(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tINVfft_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tINVfft(T))
</code></pre>

<hr>
<h2 id='tLDA'>Linear Discriminate Analysis of a 3-mode Tensor Using any Discrete Transform</h2><span id='topic+tLDA'></span>

<h3>Description</h3>

<p>Performs linear discriminate analysis on a tensor using any discrete transform.  Assumes tensor is sorted by classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLDA(tnsr,nClass,nSamplesPerClass,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLDA_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tLDA_+3A_nclass">nClass</code></td>
<td>
<p>: Number of classes</p>
</td></tr>
<tr><td><code id="tLDA_+3A_nsamplesperclass">nSamplesPerClass</code></td>
<td>
<p>: Samples in each class</p>
</td></tr>
<tr><td><code id="tLDA_+3A_tform">tform</code></td>
<td>
<p>: one of six-discrete transforms. Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Mnist")
T &lt;- Mnist$train$images
myorder &lt;- order(Mnist$train$labels)
# tLDA need to be sorted by classes
T_sorted &lt;- as.tensor(T[,myorder,])
# Using small tensor, 2 images for each class for demonstration
T &lt;- T_sorted[,c(1:2,1001:1002,2001:2002,3001:3002,
      4001:4002,5001:5002,6001:6002,7001:7002,
      8001:8002,9001:9002),]
tLDA(T,10,2,"dct")
</code></pre>

<hr>
<h2 id='tLU'>Tensor LU Decomposition Using Using Any Discrete Transform</h2><span id='topic+tLU'></span>

<h3>Description</h3>

<p>Performs a tensor LU decomposition on any 3-mode tensor using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLU(tnsr,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLU_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor </p>
</td></tr>
<tr><td><code id="tLU_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>Kernfeld, E., Kilmer, M., &amp; Aeron, S. (2015). Tensor-tensor products with invertible linear transforms. Linear Algebra and its Applications, 485, 545-570.
</p>
<p>M. E. Kilmer, C. D. Martin, and L. Perrone, “A third-order generalization
of the matrix svd as a product of third-order tensors,” Tufts University,
Department of Computer Science, Tech. Rep. TR-2008-4, 2008
</p>
<p>K. Braman, &quot;Third-order tensors as linear operators on a space of
matrices&quot;, Linear Algebra and its Applications, vol. 433, no. 7, pp.
1241-1253, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
tLU(T,"dst")
</code></pre>

<hr>
<h2 id='tLUdct'>Tensor LU Decomposition Using the Discrete Cosine Transform</h2><span id='topic+tLUdct'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Cosine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUdct(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUdct_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUdct(T))
</code></pre>

<hr>
<h2 id='tLUdht'>Tensor LU Decomposition Using the Discrete Hartley Transform</h2><span id='topic+tLUdht'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Hartley transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUdht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUdht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUdht(T))
</code></pre>

<hr>
<h2 id='tLUdst'>Tensor LU Decomposition Using the Discrete Cosine Transform</h2><span id='topic+tLUdst'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Sine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUdst(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUdst_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUdst(T))
</code></pre>

<hr>
<h2 id='tLUdwht'>Tensor LU Decomposition Using the Discrete Walsh-Hadamard Transform</h2><span id='topic+tLUdwht'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUdwht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUdwht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUdwht(T))
</code></pre>

<hr>
<h2 id='tLUdwt'>Tensor LU Decomposition Using  the Discrete Wavelet Transform</h2><span id='topic+tLUdwt'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Wavelet transform (Haar Wavelet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUdwt(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUdwt_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The left singular value tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The right singular value tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUdwt(T))
</code></pre>

<hr>
<h2 id='tLUfft'>Tensor LU Decomposition Using  the Discrete Fourier Transform</h2><span id='topic+tLUfft'></span>

<h3>Description</h3>

<p>Performs a LU decomposition of 3-mode tensor using the discrete Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tLUfft(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tLUfft_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If LU decomposition is performed on a <code class="reqn">n x n x k</code> tensor, the components in the returned value are:
</p>
<p>L: The lower triangular tensor object (<code class="reqn">n x n x k</code>)
</p>
<p>U: The upper triangular tensor object (<code class="reqn">n x n x k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tLUfft(T))
</code></pre>

<hr>
<h2 id='tmean'>Find the mean of a tensor</h2><span id='topic+tmean'></span>

<h3>Description</h3>

<p>Find the mean of a 3-mode tensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmean(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tmean_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tnsr &lt;- rand_tensor(modes=c(3,4,5))
tmean(tnsr)
</code></pre>

<hr>
<h2 id='tmult'>Tensor Multiplication Using Any Discrete Transform</h2><span id='topic+tmult'></span>

<h3>Description</h3>

<p>Multiplies two 3-mode tensors using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmult(x,y,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tmult_+3A_x">x</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tmult_+3A_y">y</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tmult_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1 &lt;- rand_tensor(modes=c(2,2,4))
T2 &lt;- rand_tensor(modes=c(2,3,4))
print(tmult(T1,T2,"dst"))
</code></pre>

<hr>
<h2 id='tQR'>Tensor QR Decomposition Using Using Any Discrete Transform</h2><span id='topic+tQR'></span>

<h3>Description</h3>

<p>Performs a tensor QR decomposition on any 3-mode tensor using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQR(tnsr,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQR_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tQR_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the QR decomposition is performed on a <code class="reqn">n \times n \times k</code> tensor, the components in the returned value are:
</p>
<p>Q: The left singular value tensor object (<code class="reqn">n \times n \times k</code>)
</p>
<p>R: The right singular value tensor object (<code class="reqn">n \times n \times k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle kyle.caudle@sdsmt.edu
</p>


<h3>References</h3>

<p>Kernfeld, E., Kilmer, M., &amp; Aeron, S. (2015). Tensor-tensor products with invertible linear transforms. Linear Algebra and its Applications, 485, 545-570.
</p>
<p>M. E. Kilmer, C. D. Martin, and L. Perrone, “A third-order generalization
of the matrix svd as a product of third-order tensors,” Tufts University,
Department of Computer Science, Tech. Rep. TR-2008-4, 2008
</p>
<p>K. Braman, &quot;Third-order tensors as linear operators on a space of
matrices&quot;, Linear Algebra and its Applications, vol. 433, no. 7, pp.
1241-1253, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
tQR(T,"dst")
</code></pre>

<hr>
<h2 id='tQRdct'>Tensor QR Decomposition Using  the Discrete Cosine Transform</h2><span id='topic+tQRdct'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete Cosine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRdct(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRdct_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQR(T,"dct"))
</code></pre>

<hr>
<h2 id='tQRdht'>Tensor QR Decomposition Using the Discrete Hartley Transform</h2><span id='topic+tQRdht'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete Hartley transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRdht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRdht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQRdht(T))
</code></pre>

<hr>
<h2 id='tQRdst'>Tensor QR Decomposition Using  the Discrete Sine Transform</h2><span id='topic+tQRdst'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete Sine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRdst(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRdst_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQRdst(T))
</code></pre>

<hr>
<h2 id='tQRdwht'>Tensor QR Decomposition Using the Discrete Walsh-Hadamard Transform</h2><span id='topic+tQRdwht'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRdwht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRdwht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQRdwht(T))
</code></pre>

<hr>
<h2 id='tQRdwt'>Tensor QR Decomposition Using  the Discrete Wavelet Transform</h2><span id='topic+tQRdwt'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRdwt(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRdwt_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQRdwt(T))
</code></pre>

<hr>
<h2 id='tQRfft'>Tensor QR Decomposition Using  the Discrete Fourier Transform</h2><span id='topic+tQRfft'></span>

<h3>Description</h3>

<p>Performs a QR decomposition of 3-mode tensor using the discrete Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tQRfft(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tQRfft_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If QR decomposition is performed on a <code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>Q: An orthogonal tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>).
</p>
<p>R: An upper triangular tensor (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,2,4))
print(tQRfft(T))
</code></pre>

<hr>
<h2 id='tSVD'>Tensor Singular Value Decomposition Using Any Discrete Transform</h2><span id='topic+tSVD'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using any discrete transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVD(tnsr,tform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVD_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
<tr><td><code id="tSVD_+3A_tform">tform</code></td>
<td>
<p>: Any discrete transform.  Supported transforms are:
</p>
<p>fft: Fast Fourier Transform
</p>
<p>dwt: Discrete Wavelet Transform (Haar Wavelet)
</p>
<p>dct: Discrete Cosine transform
</p>
<p>dst: Discrete Sine transform
</p>
<p>dht: Discrete Hadley transform
</p>
<p>dwht: Discrete Walsh-Hadamard transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>References</h3>

<p>Kernfeld, E., Kilmer, M., &amp; Aeron, S. (2015). Tensor-tensor products with invertible linear transforms. Linear Algebra and its Applications, 485, 545-570.
</p>
<p>M. E. Kilmer, C. D. Martin, and L. Perrone, “A third-order generalization
of the matrix svd as a product of third-order tensors,” Tufts University,
Department of Computer Science, Tech. Rep. TR-2008-4, 2008
</p>
<p>K. Braman, &quot;Third-order tensors as linear operators on a space of
matrices&quot;, Linear Algebra and its Applications, vol. 433, no. 7, pp.
1241-1253, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVD(T,"dst"))
</code></pre>

<hr>
<h2 id='tSVDdct'>Tensor Singular Value Decomposition Using  the Discrete Cosine Transform</h2><span id='topic+tSVDdct'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete cosine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDdct(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDdct_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDdct(T))
</code></pre>

<hr>
<h2 id='tSVDdht'>Tensor Singular Value Decomposition Using  the Discrete Harley Transform</h2><span id='topic+tSVDdht'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete Harley transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDdht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDdht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDdht(T))
</code></pre>

<hr>
<h2 id='tSVDdst'>Tensor Singular Value Decomposition Using  the Discrete Sine Transform</h2><span id='topic+tSVDdst'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete Sine transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDdst(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDdst_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDdst(T))
</code></pre>

<hr>
<h2 id='tSVDdwht'>Tensor Singular Value Decomposition Using  the Discrete Walsh-Hadamard Transform</h2><span id='topic+tSVDdwht'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete Walsh-Hadamard transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDdwht(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDdwht_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDdwht(T))
</code></pre>

<hr>
<h2 id='tSVDdwt'>Tensor Singular Value Decomposition Using  the Discrete Wavelet Transform</h2><span id='topic+tSVDdwt'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete wavelet transform (Haar Wavelet).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDdwt(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDdwt_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDdwt(T))
</code></pre>

<hr>
<h2 id='tSVDfft'>Tensor Singular Value Decomposition Using  the Discrete Fourier Transform</h2><span id='topic+tSVDfft'></span>

<h3>Description</h3>

<p>Performs a tensor singular value decomposition on any 3-mode tensor using the discrete Fourier transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSVDfft(tnsr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSVDfft_+3A_tnsr">tnsr</code></td>
<td>
<p>: a 3-mode tensor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="/library/rTensor/help/Tensor-class">Tensor-class</a> object
</p>
<p>If the SVD is performed on a <code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code> tensor, the components in the returned value are:
</p>
<p>U: The left singular value tensor object (<code class="reqn">m</code> x <code class="reqn">m</code> x <code class="reqn">k</code>)
</p>
<p>V: The right singular value tensor object (<code class="reqn">n</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>
<p>S: A diagonal tensor (<code class="reqn">m</code> x <code class="reqn">n</code> x <code class="reqn">k</code>)
</p>


<h3>Author(s)</h3>

<p>Kyle Caudle
</p>
<p>Randy Hoover
</p>
<p>Jackson Cates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T &lt;- rand_tensor(modes=c(2,3,4))
print(tSVDfft(T))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
